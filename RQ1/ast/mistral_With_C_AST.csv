Number,Signature,Early_Version,Late_Version,Early_Signature,Late_Signature,Diff_Signature,Early_Implementation_AST_Node,Late_Implementation_AST_Node,Diff_Implementation,Early_Comment,Late_Comment,Diff_Comment,Early_Annotation,Late_Annotation,Diff_Annotation,Early_Callback,Late_Callback,Diff_Callback,GT_CI_ControlFlow,GT_Change_Type,GT_CI_Type,pred_change,pred_CI,change_description,CI_description
1,<android.os.StrictMode.ThreadPolicy.Builder: Builder permitUnbufferedIo()>,28,29,<android.os.StrictMode.ThreadPolicy.Builder: Builder permitUnbufferedIo()>,<android.os.StrictMode.ThreadPolicy.Builder: Builder permitUnbufferedIo()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(return disable(DETECT_UNBUFFERED_IO), []), Statement(}, [])])  Statement({, [])  Statement(return disable(DETECT_UNBUFFERED_IO), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return disable(DETECT_THREAD_UNBUFFERED_IO), []), Statement(}, [])])  Statement({, [])  Statement(return disable(DETECT_THREAD_UNBUFFERED_IO), [])  Statement(}, [])",1,"/**
 * Disable detection of unbuffered input/output operations.
 */","/**
 * Disable detection of unbuffered input/output operations.
 */",0,,[@NonNull],1,0,0,0,1,1,1,"1,5",1,"The return statement has changed from disable(DETECT\_UNBUFFERED\_IO) to disable(DETECT\_THREAD\_UNBUFFERED\_IO) and the parameter type of disable() also changed, so the code change type is 1,5.","As the return statement has changed, the API potentially returns a different value, so the CI type is 1."
2,<android.app.NotificationManager: int getCurrentInterruptionFilter()>,23,24,<android.app.NotificationManager: int getCurrentInterruptionFilter()>,<android.app.NotificationManager: int getCurrentInterruptionFilter()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final INotificationManager service, []), Expression(getService(), [])]), Statement(try {, []), MethodCall(return zenModeToInterruptionFilter(service.getZenMode()), [VariableReference(return zenModeToInterruptionFilter(service, []), Expression(), [])]), Statement(} catch (RemoteException e) {, []), MethodCall(Log.e(TAG, ""Unable to talk to notification manager. Woe!"", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Unable to talk to notification manager. Woe!"", []), Expression(e, [])]), Statement(}, []), Statement(return INTERRUPTION_FILTER_UNKNOWN, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final INotificationManager service, []), Expression(getService(), [])])    VariableReference(final INotificationManager service, [])    Expression(getService(), [])  Statement(try {, [])  MethodCall(return zenModeToInterruptionFilter(service.getZenMode()), [VariableReference(return zenModeToInterruptionFilter(service, []), Expression(), [])])    VariableReference(return zenModeToInterruptionFilter(service, [])    Expression(), [])  Statement(} catch (RemoteException e) {, [])  MethodCall(Log.e(TAG, ""Unable to talk to notification manager. Woe!"", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Unable to talk to notification manager. Woe!"", []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Unable to talk to notification manager. Woe!"", [])    Expression(e, [])  Statement(}, [])  Statement(return INTERRUPTION_FILTER_UNKNOWN, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final INotificationManager service, []), Expression(getService(), [])]), Statement(try {, []), MethodCall(return zenModeToInterruptionFilter(service.getZenMode()), [VariableReference(return zenModeToInterruptionFilter(service, []), Expression(), [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final INotificationManager service, []), Expression(getService(), [])])    VariableReference(final INotificationManager service, [])    Expression(getService(), [])  Statement(try {, [])  MethodCall(return zenModeToInterruptionFilter(service.getZenMode()), [VariableReference(return zenModeToInterruptionFilter(service, []), Expression(), [])])    VariableReference(return zenModeToInterruptionFilter(service, [])    Expression(), [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Gets the current notification interruption filter.
 *
 * <p>
 * The interruption filter defines which notifications are allowed to interrupt the user
 * (e.g. via sound &amp; vibration) and is applied globally.
 * @return One of the INTERRUPTION_FILTER_ constants, or INTERRUPTION_FILTER_UNKNOWN when
 * unavailable.
 *
 * <p>
 * Only available if policy access is granted to this package.
 * See {@link #isNotificationPolicyAccessGranted}.
 */","/**
 * Gets the current notification interruption filter.
 *
 * <p>
 * The interruption filter defines which notifications are allowed to interrupt the user
 * (e.g. via sound &amp; vibration) and is applied globally.
 * @return One of the INTERRUPTION_FILTER_ constants, or INTERRUPTION_FILTER_UNKNOWN when
 * unavailable.
 */",1,,[@InterruptionFilter],0,0,0,0,"1,2","1,2","1,2","1,2","1,2",The return statement has been removed and a new exception handling statement has been introduced (throw e.rethrowFromSystemServer()).,"The removal of the return statement and the introduction of the new exception handling statement could lead to different behavior when the late version API is invoked, thus it is a compatibility issue caused by potential different return values or types and potential different exception handlings."
3,<android.app.NotificationManager: int getCurrentInterruptionFilter()>,25,26,<android.app.NotificationManager: int getCurrentInterruptionFilter()>,<android.app.NotificationManager: int getCurrentInterruptionFilter()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final INotificationManager service, []), Expression(getService(), [])]), Statement(try {, []), MethodCall(return zenModeToInterruptionFilter(service.getZenMode()), [VariableReference(return zenModeToInterruptionFilter(service, []), Expression(), [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final INotificationManager service, []), Expression(getService(), [])])    VariableReference(final INotificationManager service, [])    Expression(getService(), [])  Statement(try {, [])  MethodCall(return zenModeToInterruptionFilter(service.getZenMode()), [VariableReference(return zenModeToInterruptionFilter(service, []), Expression(), [])])    VariableReference(return zenModeToInterruptionFilter(service, [])    Expression(), [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final INotificationManager service, []), Expression(getService(), [])]), Statement(try {, []), MethodCall(return zenModeToInterruptionFilter(service.getZenMode()), [VariableReference(return zenModeToInterruptionFilter(service, []), Expression(), [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final INotificationManager service, []), Expression(getService(), [])])    VariableReference(final INotificationManager service, [])    Expression(getService(), [])  Statement(try {, [])  MethodCall(return zenModeToInterruptionFilter(service.getZenMode()), [VariableReference(return zenModeToInterruptionFilter(service, []), Expression(), [])])    VariableReference(return zenModeToInterruptionFilter(service, [])    Expression(), [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",0,"/**
 * Gets the current notification interruption filter.
 *
 * <p>
 * The interruption filter defines which notifications are allowed to interrupt the user
 * (e.g. via sound &amp; vibration) and is applied globally.
 * @return One of the INTERRUPTION_FILTER_ constants, or INTERRUPTION_FILTER_UNKNOWN when
 * unavailable.
 */","/**
 * Gets the current notification interruption filter.
 * <p>
 * The interruption filter defines which notifications are allowed to
 * interrupt the user (e.g. via sound &amp; vibration) and is applied
 * globally.
 */",1,[@InterruptionFilter],[@InterruptionFilter],0,0,0,0,0,0,0,0,0,"The given early and late implementation AST nodes are identical, there is no change in the code.","As there is no change in the code, there is no compatibility issue."
9,<android.os.Environment: boolean isExternalStorageEmulated()>,27,28,<android.os.Environment: boolean isExternalStorageEmulated()>,<android.os.Environment: boolean isExternalStorageEmulated()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(if (isStorageDisabled()), []), Statement(return false, []), AssignmentExpression(=, [VariableReference(final File externalDir, []), Expression(sCurrentUser.getExternalDirs()[0], [])]), Statement(return isExternalStorageEmulated(externalDir), []), Statement(}, [])])  Statement({, [])  Statement(if (isStorageDisabled()), [])  Statement(return false, [])  AssignmentExpression(=, [VariableReference(final File externalDir, []), Expression(sCurrentUser.getExternalDirs()[0], [])])    VariableReference(final File externalDir, [])    Expression(sCurrentUser.getExternalDirs()[0], [])  Statement(return isExternalStorageEmulated(externalDir), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final File externalDir, []), Expression(sCurrentUser.getExternalDirs()[0], [])]), Statement(return isExternalStorageEmulated(externalDir), []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final File externalDir, []), Expression(sCurrentUser.getExternalDirs()[0], [])])    VariableReference(final File externalDir, [])    Expression(sCurrentUser.getExternalDirs()[0], [])  Statement(return isExternalStorageEmulated(externalDir), [])  Statement(}, [])",1,"/**
 * Returns whether the primary shared/external storage media is emulated.
 * <p>
 * The contents of emulated storage devices are backed by a private user
 * data partition, which means there is little benefit to apps storing data
 * here instead of the private directories returned by
 * {@link Context#getFilesDir()}, etc.
 * <p>
 * This returns true when emulated storage is backed by either internal
 * storage or an adopted storage device.
 *
 * @see DevicePolicyManager#setStorageEncryption(android.content.ComponentName,
 * boolean)
 */","/**
 * Returns whether the primary shared/external storage media is emulated.
 * <p>
 * The contents of emulated storage devices are backed by a private user
 * data partition, which means there is little benefit to apps storing data
 * here instead of the private directories returned by
 * {@link Context#getFilesDir()}, etc.
 * <p>
 * This returns true when emulated storage is backed by either internal
 * storage or an adopted storage device.
 *
 * @see DevicePolicyManager#setStorageEncryption(android.content.ComponentName,
 * boolean)
 */",0,,,0,0,0,0,1,"1,3",1,3,1,"The early version of the implementation contains an if statement that checks whether storage is disabled, and if so, returns false. This if statement has been removed in the late version of the implementation.","The removal of the if statement means that the late version of the API will not check whether storage is disabled before returning a value. This could potentially result in a compatibility issue if an app relies on the API to accurately report whether the primary shared/external storage media is emulated, and the app is running on a device where storage is disabled. In this case, the late version of the API would return a different value (true instead of false) than the early version, which could cause the app to behave unexpectedly."
10,"<android.app.usage.NetworkStatsManager: NetworkStats queryDetails(int,String,long,long)>",23,24,"<android.app.usage.NetworkStatsManager: NetworkStats queryDetails(int,String,long,long)>",android.app.usage.NetworkStatsManager.queryDetails,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(NetworkTemplate template, []), Expression(createTemplate(networkType, subscriberId), [])]), AssignmentExpression(=, [VariableReference(if (template, []), Expression(, [])]), Statement(return null, []), Statement(}, []), Statement(NetworkStats result, []), AssignmentExpression(=, [VariableReference(result, []), Expression(new NetworkStats(mContext, template, startTime, endTime), [])]), MethodCall(result.startUserUidEnumeration(), [VariableReference(result, []), Expression(, [])]), Statement(return result, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(NetworkTemplate template, []), Expression(createTemplate(networkType, subscriberId), [])])    VariableReference(NetworkTemplate template, [])    Expression(createTemplate(networkType, subscriberId), [])  AssignmentExpression(=, [VariableReference(if (template, []), Expression(, [])])    VariableReference(if (template, [])    Expression(, [])  Statement(return null, [])  Statement(}, [])  Statement(NetworkStats result, [])  AssignmentExpression(=, [VariableReference(result, []), Expression(new NetworkStats(mContext, template, startTime, endTime), [])])    VariableReference(result, [])    Expression(new NetworkStats(mContext, template, startTime, endTime), [])  MethodCall(result.startUserUidEnumeration(), [VariableReference(result, []), Expression(, [])])    VariableReference(result, [])    Expression(, [])  Statement(return result, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(NetworkTemplate template, []), Statement(try {, []), AssignmentExpression(=, [VariableReference(template, []), Expression(createTemplate(networkType, subscriberId), [])]), Statement(} catch (IllegalArgumentException e) {, []), Statement(if (DBG), []), MethodCall(Log.e(TAG, ""Cannot create template"", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Cannot create template"", []), Expression(e, [])]), Statement(return null, []), Statement(}, []), Statement(NetworkStats result, []), AssignmentExpression(=, [VariableReference(result, []), Expression(new NetworkStats(mContext, template, startTime, endTime), [])]), MethodCall(result.startUserUidEnumeration(), [VariableReference(result, []), Expression(, [])]), Statement(return result, []), Statement(}, [])])  Statement({, [])  Statement(NetworkTemplate template, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(template, []), Expression(createTemplate(networkType, subscriberId), [])])    VariableReference(template, [])    Expression(createTemplate(networkType, subscriberId), [])  Statement(} catch (IllegalArgumentException e) {, [])  Statement(if (DBG), [])  MethodCall(Log.e(TAG, ""Cannot create template"", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Cannot create template"", []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Cannot create template"", [])    Expression(e, [])  Statement(return null, [])  Statement(}, [])  Statement(NetworkStats result, [])  AssignmentExpression(=, [VariableReference(result, []), Expression(new NetworkStats(mContext, template, startTime, endTime), [])])    VariableReference(result, [])    Expression(new NetworkStats(mContext, template, startTime, endTime), [])  MethodCall(result.startUserUidEnumeration(), [VariableReference(result, []), Expression(, [])])    VariableReference(result, [])    Expression(, [])  Statement(return result, [])  Statement(}, [])",1,"/**
 * Query network usage statistics details. Result filtered to include only uids belonging to
 * calling user. Result is aggregated over state but not aggregated over time or uid. This means
 * buckets' start and end timestamps are going to be between 'startTime' and 'endTime'
 * parameters, state is going to be {@link NetworkStats.Bucket#STATE_ALL} and uid will vary.
 * <p>Only includes buckets that atomically occur in the inclusive time range. Doesn't
 * interpolate across partial buckets. Since bucket length is in the order of hours, this
 * method cannot be used to measure data usage on a fine grained time scale.
 *
 * @param networkType As defined in {@link ConnectivityManager}, e.g.
 * {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}
 * etc.
 * @param subscriberId If applicable, the subscriber id of the network interface.
 * @param startTime Start of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime End of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @return Statistics object or null if permissions are insufficient or error happened during
 * statistics collection.
 */","/**
 * Query network usage statistics details. Result filtered to include only uids belonging to
 * calling user. Result is aggregated over state but not aggregated over time or uid. This means
 * buckets' start and end timestamps are going to be between 'startTime' and 'endTime'
 * parameters. State is going to be {@link NetworkStats.Bucket#STATE_ALL}, uid will vary,
 * tag {@link NetworkStats.Bucket#TAG_NONE} and roaming is going to be
 * {@link NetworkStats.Bucket#ROAMING_ALL}.
 * <p>Only includes buckets that atomically occur in the inclusive time range. Doesn't
 * interpolate across partial buckets. Since bucket length is in the order of hours, this
 * method cannot be used to measure data usage on a fine grained time scale.
 *
 * @param networkType As defined in {@link ConnectivityManager}, e.g.
 * {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}
 * etc.
 * @param subscriberId If applicable, the subscriber id of the network interface.
 * @param startTime Start of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime End of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @return Statistics object or null if permissions are insufficient or error happened during
 * statistics collection.
 */",1,,,0,0,0,0,1,"1,2,3","1,2","2,5","1,2","The code change between the two versions is the addition of a try-catch block for the statement `template = createTemplate(networkType, subscriberId)`. This block catches the `IllegalArgumentException` and logs the error while returning null. Also, there is a new variable declaration `NetworkTemplate template` in the late version. The control dependency of the code has changed due to the addition of the try-catch block, hence the change type is 2 and 5.","The Compatibility Issue (CI) can arise in two ways. Firstly, the late version of the code will return null in case of an `IllegalArgumentException` while the early version will not, hence the potential different return values or types, which is CI type 1. Secondly, the late version of the code will throw the `IllegalArgumentException` which is caught and logged, while the early version will not, hence the potential different exception handlings, which is CI type 2."
11,"<android.app.usage.NetworkStatsManager: NetworkStats queryDetails(int,String,long,long)>",25,26,"<android.app.usage.NetworkStatsManager: NetworkStats queryDetails(int,String,long,long)>","<android.app.usage.NetworkStatsManager: NetworkStats queryDetails(int,String,long,long)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(NetworkTemplate template, []), Statement(try {, []), AssignmentExpression(=, [VariableReference(template, []), Expression(createTemplate(networkType, subscriberId), [])]), Statement(} catch (IllegalArgumentException e) {, []), Statement(if (DBG), []), MethodCall(Log.e(TAG, ""Cannot create template"", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Cannot create template"", []), Expression(e, [])]), Statement(return null, []), Statement(}, []), Statement(NetworkStats result, []), AssignmentExpression(=, [VariableReference(result, []), Expression(new NetworkStats(mContext, template, startTime, endTime), [])]), MethodCall(result.startUserUidEnumeration(), [VariableReference(result, []), Expression(, [])]), Statement(return result, []), Statement(}, [])])  Statement({, [])  Statement(NetworkTemplate template, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(template, []), Expression(createTemplate(networkType, subscriberId), [])])    VariableReference(template, [])    Expression(createTemplate(networkType, subscriberId), [])  Statement(} catch (IllegalArgumentException e) {, [])  Statement(if (DBG), [])  MethodCall(Log.e(TAG, ""Cannot create template"", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Cannot create template"", []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Cannot create template"", [])    Expression(e, [])  Statement(return null, [])  Statement(}, [])  Statement(NetworkStats result, [])  AssignmentExpression(=, [VariableReference(result, []), Expression(new NetworkStats(mContext, template, startTime, endTime), [])])    VariableReference(result, [])    Expression(new NetworkStats(mContext, template, startTime, endTime), [])  MethodCall(result.startUserUidEnumeration(), [VariableReference(result, []), Expression(, [])])    VariableReference(result, [])    Expression(, [])  Statement(return result, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(NetworkTemplate template, []), Statement(try {, []), AssignmentExpression(=, [VariableReference(template, []), Expression(createTemplate(networkType, subscriberId), [])]), Statement(} catch (IllegalArgumentException e) {, []), Statement(if (DBG), []), MethodCall(Log.e(TAG, ""Cannot create template"", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Cannot create template"", []), Expression(e, [])]), Statement(return null, []), Statement(}, []), Statement(NetworkStats result, []), AssignmentExpression(=, [VariableReference(result, []), Expression(new NetworkStats(mContext, template, startTime, endTime), [])]), MethodCall(result.startUserUidEnumeration(), [VariableReference(result, []), Expression(, [])]), Statement(return result, []), Statement(}, [])])  Statement({, [])  Statement(NetworkTemplate template, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(template, []), Expression(createTemplate(networkType, subscriberId), [])])    VariableReference(template, [])    Expression(createTemplate(networkType, subscriberId), [])  Statement(} catch (IllegalArgumentException e) {, [])  Statement(if (DBG), [])  MethodCall(Log.e(TAG, ""Cannot create template"", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Cannot create template"", []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Cannot create template"", [])    Expression(e, [])  Statement(return null, [])  Statement(}, [])  Statement(NetworkStats result, [])  AssignmentExpression(=, [VariableReference(result, []), Expression(new NetworkStats(mContext, template, startTime, endTime), [])])    VariableReference(result, [])    Expression(new NetworkStats(mContext, template, startTime, endTime), [])  MethodCall(result.startUserUidEnumeration(), [VariableReference(result, []), Expression(, [])])    VariableReference(result, [])    Expression(, [])  Statement(return result, [])  Statement(}, [])",0,"/**
 * Query network usage statistics details. Result filtered to include only uids belonging to
 * calling user. Result is aggregated over state but not aggregated over time or uid. This means
 * buckets' start and end timestamps are going to be between 'startTime' and 'endTime'
 * parameters. State is going to be {@link NetworkStats.Bucket#STATE_ALL}, uid will vary,
 * tag {@link NetworkStats.Bucket#TAG_NONE} and roaming is going to be
 * {@link NetworkStats.Bucket#ROAMING_ALL}.
 * <p>Only includes buckets that atomically occur in the inclusive time range. Doesn't
 * interpolate across partial buckets. Since bucket length is in the order of hours, this
 * method cannot be used to measure data usage on a fine grained time scale.
 *
 * @param networkType As defined in {@link ConnectivityManager}, e.g.
 * {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}
 * etc.
 * @param subscriberId If applicable, the subscriber id of the network interface.
 * @param startTime Start of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime End of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @return Statistics object or null if permissions are insufficient or error happened during
 * statistics collection.
 */","/**
 * Query network usage statistics details. Result filtered to include only uids belonging to
 * calling user. Result is aggregated over state but not aggregated over time, uid, tag,
 * metered, nor roaming. This means buckets' start and end timestamps are going to be between
 * 'startTime' and 'endTime' parameters. State is going to be
 * {@link NetworkStats.Bucket#STATE_ALL}, uid will vary,
 * tag {@link NetworkStats.Bucket#TAG_NONE}, metered is going to be
 * {@link NetworkStats.Bucket#METERED_ALL}, and roaming is going to be
 * {@link NetworkStats.Bucket#ROAMING_ALL}.
 * <p>Only includes buckets that atomically occur in the inclusive time range. Doesn't
 * interpolate across partial buckets. Since bucket length is in the order of hours, this
 * method cannot be used to measure data usage on a fine grained time scale.
 *
 * @param networkType As defined in {@link ConnectivityManager}, e.g.
 * {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}
 * etc.
 * @param subscriberId If applicable, the subscriber id of the network interface.
 * @param startTime Start of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime End of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @return Statistics object or null if permissions are insufficient or error happened during
 * statistics collection.
 */",1,,,0,0,0,0,1,0,0,0,0,"The AST nodes of the two versions are exactly the same, so no code change has occurred.","Since there is no code change, there is no compatibility issue."
12,"<android.app.usage.NetworkStatsManager: NetworkStats queryDetails(int,String,long,long)>",26,27,"<android.app.usage.NetworkStatsManager: NetworkStats queryDetails(int,String,long,long)>","<android.app.usage.NetworkStatsManager: NetworkStats queryDetails(int,String,long,long)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(NetworkTemplate template, []), Statement(try {, []), AssignmentExpression(=, [VariableReference(template, []), Expression(createTemplate(networkType, subscriberId), [])]), Statement(} catch (IllegalArgumentException e) {, []), Statement(if (DBG), []), MethodCall(Log.e(TAG, ""Cannot create template"", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Cannot create template"", []), Expression(e, [])]), Statement(return null, []), Statement(}, []), Statement(NetworkStats result, []), AssignmentExpression(=, [VariableReference(result, []), Expression(new NetworkStats(mContext, template, startTime, endTime), [])]), MethodCall(result.startUserUidEnumeration(), [VariableReference(result, []), Expression(, [])]), Statement(return result, []), Statement(}, [])])  Statement({, [])  Statement(NetworkTemplate template, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(template, []), Expression(createTemplate(networkType, subscriberId), [])])    VariableReference(template, [])    Expression(createTemplate(networkType, subscriberId), [])  Statement(} catch (IllegalArgumentException e) {, [])  Statement(if (DBG), [])  MethodCall(Log.e(TAG, ""Cannot create template"", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Cannot create template"", []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Cannot create template"", [])    Expression(e, [])  Statement(return null, [])  Statement(}, [])  Statement(NetworkStats result, [])  AssignmentExpression(=, [VariableReference(result, []), Expression(new NetworkStats(mContext, template, startTime, endTime), [])])    VariableReference(result, [])    Expression(new NetworkStats(mContext, template, startTime, endTime), [])  MethodCall(result.startUserUidEnumeration(), [VariableReference(result, []), Expression(, [])])    VariableReference(result, [])    Expression(, [])  Statement(return result, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(NetworkTemplate template, []), Statement(try {, []), AssignmentExpression(=, [VariableReference(template, []), Expression(createTemplate(networkType, subscriberId), [])]), Statement(} catch (IllegalArgumentException e) {, []), Statement(if (DBG), []), MethodCall(Log.e(TAG, ""Cannot create template"", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Cannot create template"", []), Expression(e, [])]), Statement(return null, []), Statement(}, []), Statement(NetworkStats result, []), AssignmentExpression(=, [VariableReference(result, []), Expression(new NetworkStats(mContext, template, mFlags, startTime, endTime), [])]), MethodCall(result.startUserUidEnumeration(), [VariableReference(result, []), Expression(, [])]), Statement(return result, []), Statement(}, [])])  Statement({, [])  Statement(NetworkTemplate template, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(template, []), Expression(createTemplate(networkType, subscriberId), [])])    VariableReference(template, [])    Expression(createTemplate(networkType, subscriberId), [])  Statement(} catch (IllegalArgumentException e) {, [])  Statement(if (DBG), [])  MethodCall(Log.e(TAG, ""Cannot create template"", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Cannot create template"", []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Cannot create template"", [])    Expression(e, [])  Statement(return null, [])  Statement(}, [])  Statement(NetworkStats result, [])  AssignmentExpression(=, [VariableReference(result, []), Expression(new NetworkStats(mContext, template, mFlags, startTime, endTime), [])])    VariableReference(result, [])    Expression(new NetworkStats(mContext, template, mFlags, startTime, endTime), [])  MethodCall(result.startUserUidEnumeration(), [VariableReference(result, []), Expression(, [])])    VariableReference(result, [])    Expression(, [])  Statement(return result, [])  Statement(}, [])",1,"/**
 * Query network usage statistics details. Result filtered to include only uids belonging to
 * calling user. Result is aggregated over state but not aggregated over time, uid, tag,
 * metered, nor roaming. This means buckets' start and end timestamps are going to be between
 * 'startTime' and 'endTime' parameters. State is going to be
 * {@link NetworkStats.Bucket#STATE_ALL}, uid will vary,
 * tag {@link NetworkStats.Bucket#TAG_NONE}, metered is going to be
 * {@link NetworkStats.Bucket#METERED_ALL}, and roaming is going to be
 * {@link NetworkStats.Bucket#ROAMING_ALL}.
 * <p>Only includes buckets that atomically occur in the inclusive time range. Doesn't
 * interpolate across partial buckets. Since bucket length is in the order of hours, this
 * method cannot be used to measure data usage on a fine grained time scale.
 *
 * @param networkType As defined in {@link ConnectivityManager}, e.g.
 * {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}
 * etc.
 * @param subscriberId If applicable, the subscriber id of the network interface.
 * @param startTime Start of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime End of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @return Statistics object or null if permissions are insufficient or error happened during
 * statistics collection.
 */","/**
 * Query network usage statistics details. Result filtered to include only uids belonging to
 * calling user. Result is aggregated over state but not aggregated over time, uid, tag,
 * metered, nor roaming. This means buckets' start and end timestamps are going to be between
 * 'startTime' and 'endTime' parameters. State is going to be
 * {@link NetworkStats.Bucket#STATE_ALL}, uid will vary,
 * tag {@link NetworkStats.Bucket#TAG_NONE}, metered is going to be
 * {@link NetworkStats.Bucket#METERED_ALL}, and roaming is going to be
 * {@link NetworkStats.Bucket#ROAMING_ALL}.
 * <p>Only includes buckets that atomically occur in the inclusive time range. Doesn't
 * interpolate across partial buckets. Since bucket length is in the order of hours, this
 * method cannot be used to measure data usage on a fine grained time scale.
 *
 * @param networkType As defined in {@link ConnectivityManager}, e.g.
 * {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}
 * etc.
 * @param subscriberId If applicable, the subscriber id of the network interface.
 * @param startTime Start of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime End of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @return Statistics object or null if permissions are insufficient or error happened during
 * statistics collection.
 */",0,,,0,0,0,0,"1,2","1,5",1,5,1,"In the late version implementation, an additional parameter 'mFlags' has been added to the constructor of the 'NetworkStats' class. This change is classified as 'Dependent API changed' (code change type 5), as it involves a modification to the method signature of a dependent API.","The addition of the 'mFlags' parameter to the 'NetworkStats' constructor in the late version could potentially lead to a compatibility issue of type 1 (Compatibility Issue caused by potential different return values or types). This is because the behavior of the 'NetworkStats' object may differ based on the value of 'mFlags', which was not present in the early version. This, in turn, could result in the 'queryDetails' method returning a 'NetworkStats' object with different properties or behavior in the late version, compared to the early version."
13,"<android.app.usage.NetworkStatsManager: NetworkStats queryDetails(int,String,long,long)>",27,28,"<android.app.usage.NetworkStatsManager: NetworkStats queryDetails(int,String,long,long)>","<android.app.usage.NetworkStatsManager: NetworkStats queryDetails(int,String,long,long)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(NetworkTemplate template, []), Statement(try {, []), AssignmentExpression(=, [VariableReference(template, []), Expression(createTemplate(networkType, subscriberId), [])]), Statement(} catch (IllegalArgumentException e) {, []), Statement(if (DBG), []), MethodCall(Log.e(TAG, ""Cannot create template"", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Cannot create template"", []), Expression(e, [])]), Statement(return null, []), Statement(}, []), Statement(NetworkStats result, []), AssignmentExpression(=, [VariableReference(result, []), Expression(new NetworkStats(mContext, template, mFlags, startTime, endTime), [])]), MethodCall(result.startUserUidEnumeration(), [VariableReference(result, []), Expression(, [])]), Statement(return result, []), Statement(}, [])])  Statement({, [])  Statement(NetworkTemplate template, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(template, []), Expression(createTemplate(networkType, subscriberId), [])])    VariableReference(template, [])    Expression(createTemplate(networkType, subscriberId), [])  Statement(} catch (IllegalArgumentException e) {, [])  Statement(if (DBG), [])  MethodCall(Log.e(TAG, ""Cannot create template"", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Cannot create template"", []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Cannot create template"", [])    Expression(e, [])  Statement(return null, [])  Statement(}, [])  Statement(NetworkStats result, [])  AssignmentExpression(=, [VariableReference(result, []), Expression(new NetworkStats(mContext, template, mFlags, startTime, endTime), [])])    VariableReference(result, [])    Expression(new NetworkStats(mContext, template, mFlags, startTime, endTime), [])  MethodCall(result.startUserUidEnumeration(), [VariableReference(result, []), Expression(, [])])    VariableReference(result, [])    Expression(, [])  Statement(return result, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(NetworkTemplate template, []), Statement(try {, []), AssignmentExpression(=, [VariableReference(template, []), Expression(createTemplate(networkType, subscriberId), [])]), Statement(} catch (IllegalArgumentException e) {, []), Statement(if (DBG), []), MethodCall(Log.e(TAG, ""Cannot create template"", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Cannot create template"", []), Expression(e, [])]), Statement(return null, []), Statement(}, []), Statement(NetworkStats result, []), AssignmentExpression(=, [VariableReference(result, []), Expression(new NetworkStats(mContext, template, mFlags, startTime, endTime, mService), [])]), MethodCall(result.startUserUidEnumeration(), [VariableReference(result, []), Expression(, [])]), Statement(return result, []), Statement(}, [])])  Statement({, [])  Statement(NetworkTemplate template, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(template, []), Expression(createTemplate(networkType, subscriberId), [])])    VariableReference(template, [])    Expression(createTemplate(networkType, subscriberId), [])  Statement(} catch (IllegalArgumentException e) {, [])  Statement(if (DBG), [])  MethodCall(Log.e(TAG, ""Cannot create template"", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Cannot create template"", []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Cannot create template"", [])    Expression(e, [])  Statement(return null, [])  Statement(}, [])  Statement(NetworkStats result, [])  AssignmentExpression(=, [VariableReference(result, []), Expression(new NetworkStats(mContext, template, mFlags, startTime, endTime, mService), [])])    VariableReference(result, [])    Expression(new NetworkStats(mContext, template, mFlags, startTime, endTime, mService), [])  MethodCall(result.startUserUidEnumeration(), [VariableReference(result, []), Expression(, [])])    VariableReference(result, [])    Expression(, [])  Statement(return result, [])  Statement(}, [])",1,"/**
 * Query network usage statistics details. Result filtered to include only uids belonging to
 * calling user. Result is aggregated over state but not aggregated over time, uid, tag,
 * metered, nor roaming. This means buckets' start and end timestamps are going to be between
 * 'startTime' and 'endTime' parameters. State is going to be
 * {@link NetworkStats.Bucket#STATE_ALL}, uid will vary,
 * tag {@link NetworkStats.Bucket#TAG_NONE}, metered is going to be
 * {@link NetworkStats.Bucket#METERED_ALL}, and roaming is going to be
 * {@link NetworkStats.Bucket#ROAMING_ALL}.
 * <p>Only includes buckets that atomically occur in the inclusive time range. Doesn't
 * interpolate across partial buckets. Since bucket length is in the order of hours, this
 * method cannot be used to measure data usage on a fine grained time scale.
 *
 * @param networkType As defined in {@link ConnectivityManager}, e.g.
 * {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}
 * etc.
 * @param subscriberId If applicable, the subscriber id of the network interface.
 * @param startTime Start of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime End of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @return Statistics object or null if permissions are insufficient or error happened during
 * statistics collection.
 */","/**
 * Query network usage statistics details. Result filtered to include only uids belonging to
 * calling user. Result is aggregated over state but not aggregated over time, uid, tag,
 * metered, nor roaming. This means buckets' start and end timestamps are going to be between
 * 'startTime' and 'endTime' parameters. State is going to be
 * {@link NetworkStats.Bucket#STATE_ALL}, uid will vary,
 * tag {@link NetworkStats.Bucket#TAG_NONE},
 * default network is going to be {@link NetworkStats.Bucket#DEFAULT_NETWORK_ALL},
 * metered is going to be {@link NetworkStats.Bucket#METERED_ALL},
 * and roaming is going to be {@link NetworkStats.Bucket#ROAMING_ALL}.
 * <p>Only includes buckets that atomically occur in the inclusive time range. Doesn't
 * interpolate across partial buckets. Since bucket length is in the order of hours, this
 * method cannot be used to measure data usage on a fine grained time scale.
 *
 * @param networkType As defined in {@link ConnectivityManager}, e.g.
 * {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}
 * etc.
 * @param subscriberId If applicable, the subscriber id of the network interface.
 * @param startTime Start of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime End of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @return Statistics object or null if permissions are insufficient or error happened during
 * statistics collection.
 */",1,,,0,0,0,0,"1,2","1,5",1,5,1,"The constructor of the NetworkStats class in the return statement has changed. In the early version, it is ""new NetworkStats(mContext, template, mFlags, startTime, endTime)"" while in the late version, it is ""new NetworkStats(mContext, template, mFlags, startTime, endTime, mService)"".","The change in the constructor of the NetworkStats class in the return statement can potentially lead to a different object being returned, which may have different properties or behaviors. Therefore, it can be considered as a Compatibility Issue caused by potential different return values or types."
14,<android.animation.ValueAnimator: long getFrameDelay()>,23,24,<android.animation.ValueAnimator: long getFrameDelay()>,<android.animation.ValueAnimator: long getFrameDelay()>,0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(return Choreographer.getFrameDelay(), [VariableReference(return Choreographer, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return Choreographer.getFrameDelay(), [VariableReference(return Choreographer, []), Expression(, [])])    VariableReference(return Choreographer, [])    Expression(, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(return AnimationHandler.getInstance().getFrameDelay(), [VariableReference(return AnimationHandler, []), Expression().getFrameDelay(, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return AnimationHandler.getInstance().getFrameDelay(), [VariableReference(return AnimationHandler, []), Expression().getFrameDelay(, [])])    VariableReference(return AnimationHandler, [])    Expression().getFrameDelay(, [])  Statement(}, [])",1,"/**
 * The amount of time, in milliseconds, between each frame of the animation. This is a
 * requested time that the animation will attempt to honor, but the actual delay between
 * frames may be different, depending on system load and capabilities. This is a static
 * function because the same delay will be applied to all animations, since they are all
 * run off of a single timing loop.
 *
 * The frame delay may be ignored when the animation system uses an external timing
 * source, such as the display refresh rate (vsync), to govern animations.
 *
 * @return the requested time between frames, in milliseconds
 */","/**
 * The amount of time, in milliseconds, between each frame of the animation. This is a
 * requested time that the animation will attempt to honor, but the actual delay between
 * frames may be different, depending on system load and capabilities. This is a static
 * function because the same delay will be applied to all animations, since they are all
 * run off of a single timing loop.
 *
 * The frame delay may be ignored when the animation system uses an external timing
 * source, such as the display refresh rate (vsync), to govern animations.
 *
 * Note that this method should be called from the same thread that {@link #start()} is
 * called in order to check the frame delay for that animation. A runtime exception will be
 * thrown if the calling thread does not have a Looper.
 *
 * @return the requested time between frames, in milliseconds
 */",1,,,0,0,0,0,1,1,1,5,1,"The implementation of the `getFrameDelay()` method has been changed from using `Choreographer.getFrameDelay()` to `AnimationHandler.getInstance().getFrameDelay()` in the late version. This is a Dependent API change, as the method now relies on a different API to retrieve the frame delay.","The change in the Dependent API can potentially lead to a Compatibility Issue, as the new API `AnimationHandler.getInstance().getFrameDelay()` might return a different value than the previous API `Choreographer.getFrameDelay()`. This can cause the animation to behave differently in terms of speed or smoothness, which can impact the user experience."
16,<android.provider.Settings: boolean canDrawOverlays(Context)>,23,24,<android.provider.Settings: boolean canDrawOverlays(Context)>,<android.provider.Settings: boolean canDrawOverlays(Context)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(int uid, []), Expression(Binder.getCallingUid(), [])]), MethodCall(return Settings.isCallingPackageAllowedToDrawOverlays(context, uid, Settings.getPackageNameForUid(context, uid), false), [VariableReference(return Settings, []), Expression(context, []), Expression(uid, []), Expression(Settings.getPackageNameForUid(context, []), Expression(uid), []), Expression(false, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(int uid, []), Expression(Binder.getCallingUid(), [])])    VariableReference(int uid, [])    Expression(Binder.getCallingUid(), [])  MethodCall(return Settings.isCallingPackageAllowedToDrawOverlays(context, uid, Settings.getPackageNameForUid(context, uid), false), [VariableReference(return Settings, []), Expression(context, []), Expression(uid, []), Expression(Settings.getPackageNameForUid(context, []), Expression(uid), []), Expression(false, [])])    VariableReference(return Settings, [])    Expression(context, [])    Expression(uid, [])    Expression(Settings.getPackageNameForUid(context, [])    Expression(uid), [])    Expression(false, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(return Settings.isCallingPackageAllowedToDrawOverlays(context, Process.myUid(), context.getOpPackageName(), false), [VariableReference(return Settings, []), Expression(context, []), Expression(Process.myUid(), []), Expression(context.getOpPackageName(), []), Expression(false, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return Settings.isCallingPackageAllowedToDrawOverlays(context, Process.myUid(), context.getOpPackageName(), false), [VariableReference(return Settings, []), Expression(context, []), Expression(Process.myUid(), []), Expression(context.getOpPackageName(), []), Expression(false, [])])    VariableReference(return Settings, [])    Expression(context, [])    Expression(Process.myUid(), [])    Expression(context.getOpPackageName(), [])    Expression(false, [])  Statement(}, [])",1,"/**
 * An app can use this method to check if it is currently allowed to draw on top of other
 * apps. In order to be allowed to do so, an app must first declare the
 * {@link android.Manifest.permission#SYSTEM_ALERT_WINDOW} permission in its manifest. If it
 * is currently disallowed, it can prompt the user to grant it this capability through a
 * management UI by sending an Intent with action
 * {@link android.provider.Settings#ACTION_MANAGE_OVERLAY_PERMISSION}.
 *
 * @param context A context
 * @return true if the calling app can draw on top of other apps, false otherwise.
 */","/**
 * Checks if the specified context can draw on top of other apps. As of API
 * level 23, an app cannot draw on top of other apps unless it declares the
 * {@link android.Manifest.permission#SYSTEM_ALERT_WINDOW} permission in its
 * manifest, <em>and</em> the user specifically grants the app this
 * capability. To prompt the user to grant this approval, the app must send an
 * intent with the action
 * {@link android.provider.Settings#ACTION_MANAGE_OVERLAY_PERMISSION}, which
 * causes the system to display a permission management screen.
 *
 * @param context App context.
 * @return true if the specified context can draw on top of other apps, false otherwise
 */",1,,,0,0,0,0,"1,2","1,5",1,5,1,"The implementation of the method has changed from using `Binder.getCallingUid()` and `Settings.getPackageNameForUid(context, uid)` to using `Process.myUid()` and `context.getOpPackageName()`. This is a change in the dependent API.","The change in the dependent API could potentially result in different values being passed to the `Settings.isCallingPackageAllowedToDrawOverlays()` method, which in turn could cause the `canDrawOverlays()` method to return a different value, leading to a compatibility issue."
18,<android.app.NotificationManager.Policy: String toString()>,23,24,<android.app.NotificationManager.Policy: String toString()>,<android.app.NotificationManager.Policy: String toString()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(return ""NotificationManager.Policy["" + ""priorityCategories, []), Expression("" + priorityCategoriesToString(priorityCategories) + "",priorityCallSenders, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(return ""NotificationManager.Policy["" + ""priorityCategories, []), Expression("" + priorityCategoriesToString(priorityCategories) + "",priorityCallSenders, [])])    VariableReference(return ""NotificationManager.Policy["" + ""priorityCategories, [])    Expression("" + priorityCategoriesToString(priorityCategories) + "",priorityCallSenders, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(return ""NotificationManager.Policy["" + ""priorityCategories, []), Expression("" + priorityCategoriesToString(priorityCategories) + "",priorityCallSenders, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(return ""NotificationManager.Policy["" + ""priorityCategories, []), Expression("" + priorityCategoriesToString(priorityCategories) + "",priorityCallSenders, [])])    VariableReference(return ""NotificationManager.Policy["" + ""priorityCategories, [])    Expression("" + priorityCategoriesToString(priorityCategories) + "",priorityCallSenders, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,0,0,0,1,1,1,0,0,"The code between the two versions remains the same, so there is no change.",There is no Compatibility Issue between the two versions since the code remains the same.
19,<android.app.NotificationManager.Policy: String toString()>,27,28,<android.app.NotificationManager.Policy: String toString()>,<android.app.NotificationManager.Policy: String toString()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(return ""NotificationManager.Policy["" + ""priorityCategories, []), Expression("" + priorityCategoriesToString(priorityCategories) + "",priorityCallSenders, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(return ""NotificationManager.Policy["" + ""priorityCategories, []), Expression("" + priorityCategoriesToString(priorityCategories) + "",priorityCallSenders, [])])    VariableReference(return ""NotificationManager.Policy["" + ""priorityCategories, [])    Expression("" + priorityCategoriesToString(priorityCategories) + "",priorityCallSenders, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(return ""NotificationManager.Policy["" + ""priorityCategories, []), Expression("" + priorityCategoriesToString(priorityCategories) + "",priorityCallSenders, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(return ""NotificationManager.Policy["" + ""priorityCategories, []), Expression("" + priorityCategoriesToString(priorityCategories) + "",priorityCallSenders, [])])    VariableReference(return ""NotificationManager.Policy["" + ""priorityCategories, [])    Expression("" + priorityCategoriesToString(priorityCategories) + "",priorityCallSenders, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,0,0,0,1,1,1,0,0,No change has been made to the implementation of the toString() method in the NotificationManager.Policy class between versions 27 and 28.,"Since there are no changes in the implementation, there is no compatibility issue. The method will behave the same way in both versions."
23,<android.text.Html: String toHtml(Spanned)>,23,24,<android.text.Html: String toHtml(Spanned)>,<android.text.Html: String toHtml(Spanned)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(StringBuilder out, []), Expression(new StringBuilder(), [])]), Statement(withinHtml(out, text), []), MethodCall(return out.toString(), [VariableReference(return out, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(StringBuilder out, []), Expression(new StringBuilder(), [])])    VariableReference(StringBuilder out, [])    Expression(new StringBuilder(), [])  Statement(withinHtml(out, text), [])  MethodCall(return out.toString(), [VariableReference(return out, []), Expression(, [])])    VariableReference(return out, [])    Expression(, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return toHtml(text, TO_HTML_PARAGRAPH_LINES_CONSECUTIVE), []), Statement(}, [])])  Statement({, [])  Statement(return toHtml(text, TO_HTML_PARAGRAPH_LINES_CONSECUTIVE), [])  Statement(}, [])",1,"/**
 * Returns an HTML representation of the provided Spanned text. A best effort is
 * made to add HTML tags corresponding to spans. Also note that HTML metacharacters
 * (such as ""&lt;"" and ""&amp;"") within the input text are escaped.
 *
 * @param text input text to convert
 * @return string containing input converted to HTML
 */","/**
 * @deprecated use {@link #toHtml(Spanned, int)} instead.
 */",1,,[@Deprecated],1,0,0,0,1,"1,4,5",1,"1,5",1,"The implementation of the `toHtml` method has been completely changed. In the early version, a `StringBuilder` object is created, and the `withinHtml` method is called to process the input `Spanned` text and populate the `StringBuilder` object. Finally, the `toString` method of the `StringBuilder` object is called to return the HTML representation of the input text. In the late version, the `toHtml` method is called with the input `Spanned` text and a flag `TO_HTML_PARAGRAPH_LINES_CONSECUTIVE` to generate the HTML representation of the input text.",The change in the implementation of the `toHtml` method could potentially lead to a compatibility issue. The HTML representation generated by the late version of the method might not be the same as the HTML representation generated by the early version of the method. This could cause issues in applications that rely on the specific HTML representation generated by the early version of the method.
27,<android.app.Activity: void stopLockTask()>,27,28,<android.app.Activity: void stopLockTask()>,<android.app.Activity: void stopLockTask()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(ActivityManager.getService().stopLockTaskMode(), [VariableReference(ActivityManager, []), Expression().stopLockTaskMode(, [])]), Statement(} catch (RemoteException e) {, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(ActivityManager.getService().stopLockTaskMode(), [VariableReference(ActivityManager, []), Expression().stopLockTaskMode(, [])])    VariableReference(ActivityManager, [])    Expression().stopLockTaskMode(, [])  Statement(} catch (RemoteException e) {, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(ActivityManager.getService().stopLockTaskModeByToken(mToken), [VariableReference(ActivityManager, []), Expression().stopLockTaskModeByToken(mToken, [])]), Statement(} catch (RemoteException e) {, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(ActivityManager.getService().stopLockTaskModeByToken(mToken), [VariableReference(ActivityManager, []), Expression().stopLockTaskModeByToken(mToken, [])])    VariableReference(ActivityManager, [])    Expression().stopLockTaskModeByToken(mToken, [])  Statement(} catch (RemoteException e) {, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Allow the user to switch away from the current task.
 *
 * Called to end the mode started by {@link Activity#startLockTask}. This
 * can only be called by activities that have successfully called
 * startLockTask previously.
 *
 * This will allow the user to exit this app and move onto other activities.
 * <p>Note: This method should only be called when the activity is user-facing. That is,
 * between onResume() and onPause().
 * <p>Note: If there are other tasks below this one that are also locked then calling this
 * method will immediately finish this task and resume the previous locked one, remaining in
 * lockTask mode.
 *
 * @see android.R.attr#lockTaskMode
 * @see ActivityManager#getLockTaskModeState()
 */","/**
 * Stop the current task from being locked.
 *
 * <p>Called to end the LockTask or screen pinning mode started by {@link #startLockTask()}.
 * This can only be called by activities that have called {@link #startLockTask()} previously.
 *
 * <p><strong>Note:</strong> If the device is in LockTask mode that is not initially started
 * by this activity, then calling this method will not terminate the LockTask mode, but only
 * finish its own task. The device will remain in LockTask mode, until the activity which
 * started the LockTask mode calls this method, or until its whitelist authorization is revoked
 * by {@link DevicePolicyManager#setLockTaskPackages(ComponentName, String[])}.
 *
 * @see #startLockTask()
 * @see android.R.attr#lockTaskMode
 * @see ActivityManager#getLockTaskModeState()
 */",1,,,0,0,0,0,1,4,0,5,1,The method called in the try block has changed from stopLockTaskMode() to stopLockTaskModeByToken(mToken). This represents a change in the dependent API.,"The change in the dependent API may cause the method to behave differently and potentially return a different value. Therefore, this is a compatibility issue caused by potential different return values or types (class 1)."
28,<android.app.Activity: void stopLockTask()>,28,29,<android.app.Activity: void stopLockTask()>,<android.app.Activity: void stopLockTask()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(ActivityManager.getService().stopLockTaskModeByToken(mToken), [VariableReference(ActivityManager, []), Expression().stopLockTaskModeByToken(mToken, [])]), Statement(} catch (RemoteException e) {, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(ActivityManager.getService().stopLockTaskModeByToken(mToken), [VariableReference(ActivityManager, []), Expression().stopLockTaskModeByToken(mToken, [])])    VariableReference(ActivityManager, [])    Expression().stopLockTaskModeByToken(mToken, [])  Statement(} catch (RemoteException e) {, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(ActivityTaskManager.getService().stopLockTaskModeByToken(mToken), [VariableReference(ActivityTaskManager, []), Expression().stopLockTaskModeByToken(mToken, [])]), Statement(} catch (RemoteException e) {, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(ActivityTaskManager.getService().stopLockTaskModeByToken(mToken), [VariableReference(ActivityTaskManager, []), Expression().stopLockTaskModeByToken(mToken, [])])    VariableReference(ActivityTaskManager, [])    Expression().stopLockTaskModeByToken(mToken, [])  Statement(} catch (RemoteException e) {, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Stop the current task from being locked.
 *
 * <p>Called to end the LockTask or screen pinning mode started by {@link #startLockTask()}.
 * This can only be called by activities that have called {@link #startLockTask()} previously.
 *
 * <p><strong>Note:</strong> If the device is in LockTask mode that is not initially started
 * by this activity, then calling this method will not terminate the LockTask mode, but only
 * finish its own task. The device will remain in LockTask mode, until the activity which
 * started the LockTask mode calls this method, or until its whitelist authorization is revoked
 * by {@link DevicePolicyManager#setLockTaskPackages(ComponentName, String[])}.
 *
 * @see #startLockTask()
 * @see android.R.attr#lockTaskMode
 * @see ActivityManager#getLockTaskModeState()
 */","/**
 * Stop the current task from being locked.
 *
 * <p>Called to end the LockTask or screen pinning mode started by {@link #startLockTask()}.
 * This can only be called by activities that have called {@link #startLockTask()} previously.
 *
 * <p><strong>Note:</strong> If the device is in LockTask mode that is not initially started
 * by this activity, then calling this method will not terminate the LockTask mode, but only
 * finish its own task. The device will remain in LockTask mode, until the activity which
 * started the LockTask mode calls this method, or until its whitelist authorization is revoked
 * by {@link DevicePolicyManager#setLockTaskPackages(ComponentName, String[])}.
 *
 * @see #startLockTask()
 * @see android.R.attr#lockTaskMode
 * @see ActivityManager#getLockTaskModeState()
 */",0,,,0,0,0,0,1,4,0,5,0,"The method call to stop the lock task mode has changed from `ActivityManager.getService().stopLockTaskModeByToken(mToken)` to `ActivityTaskManager.getService().stopLockTaskModeByToken(mToken)`. This change is classified as 5) Dependent API changed, as the dependent API for stopping the lock task mode has been modified.","However, this change does not lead to any compatibility issues (CI), as the functionality of stopping the lock task mode remains the same. The only difference is the way the service is obtained to stop the lock task mode. Therefore, the pred_CI is 0) No Compatibility Issue exist."
29,<android.animation.ValueAnimator: void end()>,23,24,<android.animation.ValueAnimator: void end()>,<android.animation.ValueAnimator: void end()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(AnimationHandler handler, []), Expression(getOrCreateAnimationHandler(), [])]), Statement(// Special case if the animation has not yet started, []), Statement(get it ready for ending, []), AssignmentExpression(=, [VariableReference(mStartedDelay, []), Expression(false, [])]), Statement(startAnimation(handler), []), AssignmentExpression(=, [VariableReference(mStarted, []), Expression(true, [])]), Statement(} else if (!mInitialized) {, []), Statement(initAnimation(), []), Statement(}, []), Statement(animateValue(mPlayingBackwards ? 0f : 1f), []), Statement(endAnimation(handler), []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(AnimationHandler handler, []), Expression(getOrCreateAnimationHandler(), [])])    VariableReference(AnimationHandler handler, [])    Expression(getOrCreateAnimationHandler(), [])  Statement(// Special case if the animation has not yet started, [])  Statement(get it ready for ending, [])  AssignmentExpression(=, [VariableReference(mStartedDelay, []), Expression(false, [])])    VariableReference(mStartedDelay, [])    Expression(false, [])  Statement(startAnimation(handler), [])  AssignmentExpression(=, [VariableReference(mStarted, []), Expression(true, [])])    VariableReference(mStarted, [])    Expression(true, [])  Statement(} else if (!mInitialized) {, [])  Statement(initAnimation(), [])  Statement(}, [])  Statement(animateValue(mPlayingBackwards ? 0f : 1f), [])  Statement(endAnimation(handler), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (Looper.myLooper(), []), Expression(, [])]), Statement(throw new AndroidRuntimeException(""Animators may only be run on Looper threads""), []), Statement(}, []), Statement(if (!mRunning) {, []), Statement(// Special case if the animation has not yet started, []), Statement(get it ready for ending, []), Statement(startAnimation(), []), AssignmentExpression(=, [VariableReference(mStarted, []), Expression(true, [])]), Statement(} else if (!mInitialized) {, []), Statement(initAnimation(), []), Statement(}, []), Statement(animateValue(shouldPlayBackward(mRepeatCount) ? 0f : 1f), []), Statement(endAnimation(), []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (Looper.myLooper(), []), Expression(, [])])    VariableReference(if (Looper.myLooper(), [])    Expression(, [])  Statement(throw new AndroidRuntimeException(""Animators may only be run on Looper threads""), [])  Statement(}, [])  Statement(if (!mRunning) {, [])  Statement(// Special case if the animation has not yet started, [])  Statement(get it ready for ending, [])  Statement(startAnimation(), [])  AssignmentExpression(=, [VariableReference(mStarted, []), Expression(true, [])])    VariableReference(mStarted, [])    Expression(true, [])  Statement(} else if (!mInitialized) {, [])  Statement(initAnimation(), [])  Statement(}, [])  Statement(animateValue(shouldPlayBackward(mRepeatCount) ? 0f : 1f), [])  Statement(endAnimation(), [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,0,0,0,1,"2,3,4",2,"1,2,3","1,2","1) Return statement changed: In the early version, the method has a return type of void, and there is no explicit return statement. In the late version, the method's return type is still void, but an explicit return statement has been added at the end of the method.",
31,"<android.content.res.Resources: Drawable loadDrawable(TypedValue,int,Theme)>",23,24,"<android.content.res.Resources: Drawable loadDrawable(TypedValue,int,Theme)>","<android.content.res.Resources: Drawable loadDrawable(TypedValue,int,Theme)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(if (TRACE_FOR_PRELOAD) {, []), Statement(// Log only framework resources, []), AssignmentExpression(=, [VariableReference(if ((id >>> 24), []), Expression(, [])]), AssignmentExpression(=, [VariableReference(final String name, []), Expression(getResourceName(id), [])]), AssignmentExpression(=, [VariableReference(if (name !, []), Expression(null) {, [])]), MethodCall(Log.d(""PreloadDrawable"", name), [VariableReference(Log, []), Expression(""PreloadDrawable"", []), Expression(name, [])]), Statement(}, []), Statement(}, []), Statement(}, []), Statement(final boolean isColorDrawable, []), Statement(final DrawableCache caches, []), Statement(final long key, []), AssignmentExpression(=, [VariableReference(if (value.type >, []), Expression(TypedValue.TYPE_FIRST_COLOR_INT && value.type <, [])]), AssignmentExpression(=, [VariableReference(isColorDrawable, []), Expression(true, [])]), AssignmentExpression(=, [VariableReference(caches, []), Expression(mColorDrawableCache, [])]), AssignmentExpression(=, [VariableReference(key, []), Expression(value.data, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(isColorDrawable, []), Expression(false, [])]), AssignmentExpression(=, [VariableReference(caches, []), Expression(mDrawableCache, [])]), AssignmentExpression(=, [VariableReference(key, []), Expression((((long) value.assetCookie) << 32) | value.data, [])]), Statement(}, []), Statement(// that was inflated against the specified theme., []), Statement(if (!mPreloading) {, []), AssignmentExpression(=, [VariableReference(final Drawable cachedDrawable, []), Expression(caches.getInstance(key, theme), [])]), AssignmentExpression(=, [VariableReference(if (cachedDrawable !, []), Expression(null) {, [])]), Statement(return cachedDrawable, []), Statement(}, []), Statement(}, []), Statement(// Next, check preloaded drawables. These may contain unresolved theme, []), Statement(// attributes., []), Statement(final ConstantState cs, []), Statement(if (isColorDrawable) {, []), AssignmentExpression(=, [VariableReference(cs, []), Expression(sPreloadedColorDrawables.get(key), [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(cs, []), Expression(sPreloadedDrawables[mConfiguration.getLayoutDirection()].get(key), [])]), Statement(}, []), Statement(Drawable dr, []), AssignmentExpression(=, [VariableReference(if (cs !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(dr, []), Expression(cs.newDrawable(this), [])]), Statement(} else if (isColorDrawable) {, []), AssignmentExpression(=, [VariableReference(dr, []), Expression(new ColorDrawable(value.data), [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(dr, []), Expression(loadDrawableForCookie(value, id, null), [])]), Statement(}, []), Statement(// Determine if the drawable has unresolved theme attributes. If it, []), Statement(// does, we'll need to apply a theme and store it in a theme-specific, []), Statement(// cache., []), AssignmentExpression(=, [VariableReference(final boolean canApplyTheme, []), Expression(dr !, [])]), AssignmentExpression(=, [VariableReference(if (canApplyTheme && theme !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(dr, []), Expression(dr.mutate(), [])]), MethodCall(dr.applyTheme(theme), [VariableReference(dr, []), Expression(theme, [])]), MethodCall(dr.clearMutated(), [VariableReference(dr, []), Expression(, [])]), Statement(}, []), Statement(// cache: preload, not themed, null theme, or theme-specific., []), AssignmentExpression(=, [VariableReference(if (dr !, []), Expression(null) {, [])]), MethodCall(dr.setChangingConfigurations(value.changingConfigurations), [VariableReference(dr, []), Expression(value.changingConfigurations, [])]), Statement(cacheDrawable(value, isColorDrawable, caches, theme, canApplyTheme, key, dr), []), Statement(}, []), Statement(return dr, []), Statement(}, [])])  Statement({, [])  Statement(if (TRACE_FOR_PRELOAD) {, [])  Statement(// Log only framework resources, [])  AssignmentExpression(=, [VariableReference(if ((id >>> 24), []), Expression(, [])])    VariableReference(if ((id >>> 24), [])    Expression(, [])  AssignmentExpression(=, [VariableReference(final String name, []), Expression(getResourceName(id), [])])    VariableReference(final String name, [])    Expression(getResourceName(id), [])  AssignmentExpression(=, [VariableReference(if (name !, []), Expression(null) {, [])])    VariableReference(if (name !, [])    Expression(null) {, [])  MethodCall(Log.d(""PreloadDrawable"", name), [VariableReference(Log, []), Expression(""PreloadDrawable"", []), Expression(name, [])])    VariableReference(Log, [])    Expression(""PreloadDrawable"", [])    Expression(name, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(final boolean isColorDrawable, [])  Statement(final DrawableCache caches, [])  Statement(final long key, [])  AssignmentExpression(=, [VariableReference(if (value.type >, []), Expression(TypedValue.TYPE_FIRST_COLOR_INT && value.type <, [])])    VariableReference(if (value.type >, [])    Expression(TypedValue.TYPE_FIRST_COLOR_INT && value.type <, [])  AssignmentExpression(=, [VariableReference(isColorDrawable, []), Expression(true, [])])    VariableReference(isColorDrawable, [])    Expression(true, [])  AssignmentExpression(=, [VariableReference(caches, []), Expression(mColorDrawableCache, [])])    VariableReference(caches, [])    Expression(mColorDrawableCache, [])  AssignmentExpression(=, [VariableReference(key, []), Expression(value.data, [])])    VariableReference(key, [])    Expression(value.data, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(isColorDrawable, []), Expression(false, [])])    VariableReference(isColorDrawable, [])    Expression(false, [])  AssignmentExpression(=, [VariableReference(caches, []), Expression(mDrawableCache, [])])    VariableReference(caches, [])    Expression(mDrawableCache, [])  AssignmentExpression(=, [VariableReference(key, []), Expression((((long) value.assetCookie) << 32) | value.data, [])])    VariableReference(key, [])    Expression((((long) value.assetCookie) << 32) | value.data, [])  Statement(}, [])  Statement(// that was inflated against the specified theme., [])  Statement(if (!mPreloading) {, [])  AssignmentExpression(=, [VariableReference(final Drawable cachedDrawable, []), Expression(caches.getInstance(key, theme), [])])    VariableReference(final Drawable cachedDrawable, [])    Expression(caches.getInstance(key, theme), [])  AssignmentExpression(=, [VariableReference(if (cachedDrawable !, []), Expression(null) {, [])])    VariableReference(if (cachedDrawable !, [])    Expression(null) {, [])  Statement(return cachedDrawable, [])  Statement(}, [])  Statement(}, [])  Statement(// Next, check preloaded drawables. These may contain unresolved theme, [])  Statement(// attributes., [])  Statement(final ConstantState cs, [])  Statement(if (isColorDrawable) {, [])  AssignmentExpression(=, [VariableReference(cs, []), Expression(sPreloadedColorDrawables.get(key), [])])    VariableReference(cs, [])    Expression(sPreloadedColorDrawables.get(key), [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(cs, []), Expression(sPreloadedDrawables[mConfiguration.getLayoutDirection()].get(key), [])])    VariableReference(cs, [])    Expression(sPreloadedDrawables[mConfiguration.getLayoutDirection()].get(key), [])  Statement(}, [])  Statement(Drawable dr, [])  AssignmentExpression(=, [VariableReference(if (cs !, []), Expression(null) {, [])])    VariableReference(if (cs !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(dr, []), Expression(cs.newDrawable(this), [])])    VariableReference(dr, [])    Expression(cs.newDrawable(this), [])  Statement(} else if (isColorDrawable) {, [])  AssignmentExpression(=, [VariableReference(dr, []), Expression(new ColorDrawable(value.data), [])])    VariableReference(dr, [])    Expression(new ColorDrawable(value.data), [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(dr, []), Expression(loadDrawableForCookie(value, id, null), [])])    VariableReference(dr, [])    Expression(loadDrawableForCookie(value, id, null), [])  Statement(}, [])  Statement(// Determine if the drawable has unresolved theme attributes. If it, [])  Statement(// does, we'll need to apply a theme and store it in a theme-specific, [])  Statement(// cache., [])  AssignmentExpression(=, [VariableReference(final boolean canApplyTheme, []), Expression(dr !, [])])    VariableReference(final boolean canApplyTheme, [])    Expression(dr !, [])  AssignmentExpression(=, [VariableReference(if (canApplyTheme && theme !, []), Expression(null) {, [])])    VariableReference(if (canApplyTheme && theme !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(dr, []), Expression(dr.mutate(), [])])    VariableReference(dr, [])    Expression(dr.mutate(), [])  MethodCall(dr.applyTheme(theme), [VariableReference(dr, []), Expression(theme, [])])    VariableReference(dr, [])    Expression(theme, [])  MethodCall(dr.clearMutated(), [VariableReference(dr, []), Expression(, [])])    VariableReference(dr, [])    Expression(, [])  Statement(}, [])  Statement(// cache: preload, not themed, null theme, or theme-specific., [])  AssignmentExpression(=, [VariableReference(if (dr !, []), Expression(null) {, [])])    VariableReference(if (dr !, [])    Expression(null) {, [])  MethodCall(dr.setChangingConfigurations(value.changingConfigurations), [VariableReference(dr, []), Expression(value.changingConfigurations, [])])    VariableReference(dr, [])    Expression(value.changingConfigurations, [])  Statement(cacheDrawable(value, isColorDrawable, caches, theme, canApplyTheme, key, dr), [])  Statement(}, [])  Statement(return dr, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(return mResourcesImpl.loadDrawable(this, value, id, theme, true), [VariableReference(return mResourcesImpl, []), Expression(this, []), Expression(value, []), Expression(id, []), Expression(theme, []), Expression(true, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return mResourcesImpl.loadDrawable(this, value, id, theme, true), [VariableReference(return mResourcesImpl, []), Expression(this, []), Expression(value, []), Expression(id, []), Expression(theme, []), Expression(true, [])])    VariableReference(return mResourcesImpl, [])    Expression(this, [])    Expression(value, [])    Expression(id, [])    Expression(theme, [])    Expression(true, [])  Statement(}, [])",1,,,0,[@Nullable],[@NonNull],1,0,0,0,"1,2","1,3,4",1,5,1,"The implementation of the API `loadDrawable` has been changed to call a different method in the late version. In the early version, the API implementation includes multiple logical blocks for different scenarios, while in the late version, the API directly calls the `loadDrawable` method of the `mResourcesImpl` object. This is a change in the dependent API, as the method being called to perform the core functionality of the API has been changed.","The change in the dependent API could lead to different behaviors in the late version of the API. The logical blocks present in the early version of the API might not be executed in the late version, and the way the drawable is loaded and handled might be different. This could potentially lead to compatibility issues, where the API might return a different value or type of drawable in the late version compared to the early version."
32,<android.os.BatteryManager: boolean isCharging()>,23,24,<android.os.BatteryManager: boolean isCharging()>,<android.os.BatteryManager: boolean isCharging()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(return mBatteryStats.isCharging(), [VariableReference(return mBatteryStats, []), Expression(, [])]), Statement(} catch (RemoteException e) {, []), Statement(return true, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(return mBatteryStats.isCharging(), [VariableReference(return mBatteryStats, []), Expression(, [])])    VariableReference(return mBatteryStats, [])    Expression(, [])  Statement(} catch (RemoteException e) {, [])  Statement(return true, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(return mBatteryStats.isCharging(), [VariableReference(return mBatteryStats, []), Expression(, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(return mBatteryStats.isCharging(), [VariableReference(return mBatteryStats, []), Expression(, [])])    VariableReference(return mBatteryStats, [])    Expression(, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Return true if the battery is currently considered to be charging.  This means that
 * the device is plugged in and is supplying sufficient power that the battery level is
 * going up (or the battery is fully charged).  Changes in this state are matched by
 * broadcasts of {@link #ACTION_CHARGING} and {@link #ACTION_DISCHARGING}.
 */
","/**
 * Return true if the battery is currently considered to be charging.  This means that
 * the device is plugged in and is supplying sufficient power that the battery level is
 * going up (or the battery is fully charged).  Changes in this state are matched by
 * broadcasts of {@link #ACTION_CHARGING} and {@link #ACTION_DISCHARGING}.
 */
",0,,,0,0,0,0,1,"1,2","1,2","2,5",2,"The implementation of the catch block for RemoteException in the isCharging() method has been changed between the two versions. In the early version, the method returns a boolean value (true) in the catch block, while in the late version, the method re-throws the exception using the rethrowFromSystemServer() method of the RemoteException class. Additionally, a new dependent API (rethrowFromSystemServer()) has been introduced in the late version.","The change in the catch block implementation can potentially lead to compatibility issues. In the early version, the method always returns a boolean value, even if a RemoteException is thrown. However, in the late version, the method re-throws the exception, which can propagate up the call stack and potentially cause the application to crash if it is not handled properly. This can lead to potential different exception handlings."
33,<android.app.ApplicationContext: Drawable peekWallpaper()>,4,5,<android.app.ApplicationContext: Drawable peekWallpaper()>,<android.app.ApplicationContext: Drawable peekWallpaper()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mWallpaper !, []), Expression(null) {, [])]), Statement(return mWallpaper, []), Statement(}, []), AssignmentExpression(=, [VariableReference(mWallpaperCallback, []), Expression(new WallpaperCallback(this), [])]), AssignmentExpression(=, [VariableReference(mWallpaper, []), Expression(getCurrentWallpaperLocked(), [])]), Statement(return mWallpaper, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mWallpaper !, []), Expression(null) {, [])])    VariableReference(if (mWallpaper !, [])    Expression(null) {, [])  Statement(return mWallpaper, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mWallpaperCallback, []), Expression(new WallpaperCallback(this), [])])    VariableReference(mWallpaperCallback, [])    Expression(new WallpaperCallback(this), [])  AssignmentExpression(=, [VariableReference(mWallpaper, []), Expression(getCurrentWallpaperLocked(), [])])    VariableReference(mWallpaper, [])    Expression(getCurrentWallpaperLocked(), [])  Statement(return mWallpaper, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(return getWallpaperManager().peekDrawable(), [VariableReference(return getWallpaperManager(), []), Expression(, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return getWallpaperManager().peekDrawable(), [VariableReference(return getWallpaperManager(), []), Expression(, [])])    VariableReference(return getWallpaperManager(), [])    Expression(, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,0,0,0,1,"1,3,4",1,5,1,"The implementation of the peekWallpaper() method has been completely changed. In the early version, the method checks if the mWallpaper field is not null and returns it if it is. If mWallpaper is null, the method creates a new WallpaperCallback object and assigns it to the mWallpaperCallback field. Then, it calls the getCurrentWallpaperLocked() method and assigns the result to the mWallpaper field. Finally, it returns the mWallpaper field.",#CI_description
34,"<android.content.res.Resources: Drawable loadDrawable(TypedValue,int)>",4,5,"<android.content.res.Resources: Drawable loadDrawable(TypedValue,int)>","<android.content.res.Resources: Drawable loadDrawable(TypedValue,int)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(if (TRACE_FOR_PRELOAD) {, []), Statement(// Log only framework resources, []), AssignmentExpression(=, [VariableReference(if ((id >>> 24), []), Expression(, [])]), AssignmentExpression(=, [VariableReference(final String name, []), Expression(getResourceName(id), [])]), AssignmentExpression(=, [VariableReference(if (name !, []), Expression(null), [])]), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(final long key, []), Expression((((long) value.assetCookie) << 32) | value.data, [])]), AssignmentExpression(=, [VariableReference(Drawable dr, []), Expression(getCachedDrawable(key), [])]), AssignmentExpression(=, [VariableReference(if (dr !, []), Expression(null) {, [])]), Statement(return dr, []), Statement(}, []), AssignmentExpression(=, [VariableReference(Drawable.ConstantState cs, []), Expression(mPreloadedDrawables.get(key), [])]), AssignmentExpression(=, [VariableReference(if (cs !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(dr, []), Expression(cs.newDrawable(), [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(if (value.type >, []), Expression(TypedValue.TYPE_FIRST_COLOR_INT && value.type <, [])]), AssignmentExpression(=, [VariableReference(dr, []), Expression(new ColorDrawable(value.data), [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (dr, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(if (value.string, []), Expression(, [])]), Statement(throw new NotFoundException(""Resource is not a Drawable (color or path): "" + value), []), Statement(}, []), AssignmentExpression(=, [VariableReference(String file, []), Expression(value.string.toString(), [])]), Statement(if (DEBUG_LOAD), []), MethodCall(Log.v(TAG, ""Loading drawable for cookie "" + value.assetCookie + "": "" + file), [VariableReference(Log, []), Expression(TAG, []), Expression(""Loading drawable for cookie "" + value.assetCookie + "": "" + file, [])]), MethodCall(if (file.endsWith("".xml"")), [VariableReference(if (file, []), Expression("".xml""), [])]), Statement(try {, []), AssignmentExpression(=, [VariableReference(XmlResourceParser rp, []), Expression(loadXmlResourceParser(file, id, value.assetCookie, ""drawable""), [])]), AssignmentExpression(=, [VariableReference(dr, []), Expression(Drawable.createFromXml(this, rp), [])]), MethodCall(rp.close(), [VariableReference(rp, []), Expression(, [])]), Statement(} catch (Exception e) {, []), AssignmentExpression(=, [VariableReference(NotFoundException rnf, []), Expression(new NotFoundException(""File "" + file + "" from drawable resource ID #0x"" + Integer.toHexString(id)), [])]), MethodCall(rnf.initCause(e), [VariableReference(rnf, []), Expression(e, [])]), Statement(throw rnf, []), Statement(}, []), Statement(} else {, []), Statement(try {, []), AssignmentExpression(=, [VariableReference(InputStream is, []), Expression(mAssets.openNonAsset(value.assetCookie, file, AssetManager.ACCESS_BUFFER), [])]), AssignmentExpression(=, [VariableReference(dr, []), Expression(Drawable.createFromResourceStream(this, value, is, file), [])]), MethodCall(is.close(), [VariableReference(is, []), Expression(, [])]), Statement(} catch (Exception e) {, []), AssignmentExpression(=, [VariableReference(NotFoundException rnf, []), Expression(new NotFoundException(""File "" + file + "" from drawable resource ID #0x"" + Integer.toHexString(id)), [])]), MethodCall(rnf.initCause(e), [VariableReference(rnf, []), Expression(e, [])]), Statement(throw rnf, []), Statement(}, []), Statement(}, []), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (dr !, []), Expression(null) {, [])]), MethodCall(dr.setChangingConfigurations(value.changingConfigurations), [VariableReference(dr, []), Expression(value.changingConfigurations, [])]), AssignmentExpression(=, [VariableReference(cs, []), Expression(dr.getConstantState(), [])]), AssignmentExpression(=, [VariableReference(if (cs !, []), Expression(null) {, [])]), Statement(if (mPreloading) {, []), MethodCall(sPreloadedDrawables.put(key, cs), [VariableReference(sPreloadedDrawables, []), Expression(key, []), Expression(cs, [])]), Statement(} else {, []), Statement(synchronized (mTmpValue) {, []), MethodCall(// Integer.toHexString(key.intValue()), [VariableReference(// Integer, []), Expression(key.intValue(), [])]), Statement(// + "" in "" + this + "": "" + cs), []), MethodCall(mDrawableCache.put(key, new WeakReference<Drawable.ConstantState>(cs)), [VariableReference(mDrawableCache, []), Expression(key, []), Expression(new WeakReference<Drawable.ConstantState>(cs), [])]), Statement(}, []), Statement(}, []), Statement(}, []), Statement(}, []), Statement(return dr, []), Statement(}, [])])  Statement({, [])  Statement(if (TRACE_FOR_PRELOAD) {, [])  Statement(// Log only framework resources, [])  AssignmentExpression(=, [VariableReference(if ((id >>> 24), []), Expression(, [])])    VariableReference(if ((id >>> 24), [])    Expression(, [])  AssignmentExpression(=, [VariableReference(final String name, []), Expression(getResourceName(id), [])])    VariableReference(final String name, [])    Expression(getResourceName(id), [])  AssignmentExpression(=, [VariableReference(if (name !, []), Expression(null), [])])    VariableReference(if (name !, [])    Expression(null), [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(final long key, []), Expression((((long) value.assetCookie) << 32) | value.data, [])])    VariableReference(final long key, [])    Expression((((long) value.assetCookie) << 32) | value.data, [])  AssignmentExpression(=, [VariableReference(Drawable dr, []), Expression(getCachedDrawable(key), [])])    VariableReference(Drawable dr, [])    Expression(getCachedDrawable(key), [])  AssignmentExpression(=, [VariableReference(if (dr !, []), Expression(null) {, [])])    VariableReference(if (dr !, [])    Expression(null) {, [])  Statement(return dr, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(Drawable.ConstantState cs, []), Expression(mPreloadedDrawables.get(key), [])])    VariableReference(Drawable.ConstantState cs, [])    Expression(mPreloadedDrawables.get(key), [])  AssignmentExpression(=, [VariableReference(if (cs !, []), Expression(null) {, [])])    VariableReference(if (cs !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(dr, []), Expression(cs.newDrawable(), [])])    VariableReference(dr, [])    Expression(cs.newDrawable(), [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(if (value.type >, []), Expression(TypedValue.TYPE_FIRST_COLOR_INT && value.type <, [])])    VariableReference(if (value.type >, [])    Expression(TypedValue.TYPE_FIRST_COLOR_INT && value.type <, [])  AssignmentExpression(=, [VariableReference(dr, []), Expression(new ColorDrawable(value.data), [])])    VariableReference(dr, [])    Expression(new ColorDrawable(value.data), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (dr, []), Expression(, [])])    VariableReference(if (dr, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(if (value.string, []), Expression(, [])])    VariableReference(if (value.string, [])    Expression(, [])  Statement(throw new NotFoundException(""Resource is not a Drawable (color or path): "" + value), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(String file, []), Expression(value.string.toString(), [])])    VariableReference(String file, [])    Expression(value.string.toString(), [])  Statement(if (DEBUG_LOAD), [])  MethodCall(Log.v(TAG, ""Loading drawable for cookie "" + value.assetCookie + "": "" + file), [VariableReference(Log, []), Expression(TAG, []), Expression(""Loading drawable for cookie "" + value.assetCookie + "": "" + file, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Loading drawable for cookie "" + value.assetCookie + "": "" + file, [])  MethodCall(if (file.endsWith("".xml"")), [VariableReference(if (file, []), Expression("".xml""), [])])    VariableReference(if (file, [])    Expression("".xml""), [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(XmlResourceParser rp, []), Expression(loadXmlResourceParser(file, id, value.assetCookie, ""drawable""), [])])    VariableReference(XmlResourceParser rp, [])    Expression(loadXmlResourceParser(file, id, value.assetCookie, ""drawable""), [])  AssignmentExpression(=, [VariableReference(dr, []), Expression(Drawable.createFromXml(this, rp), [])])    VariableReference(dr, [])    Expression(Drawable.createFromXml(this, rp), [])  MethodCall(rp.close(), [VariableReference(rp, []), Expression(, [])])    VariableReference(rp, [])    Expression(, [])  Statement(} catch (Exception e) {, [])  AssignmentExpression(=, [VariableReference(NotFoundException rnf, []), Expression(new NotFoundException(""File "" + file + "" from drawable resource ID #0x"" + Integer.toHexString(id)), [])])    VariableReference(NotFoundException rnf, [])    Expression(new NotFoundException(""File "" + file + "" from drawable resource ID #0x"" + Integer.toHexString(id)), [])  MethodCall(rnf.initCause(e), [VariableReference(rnf, []), Expression(e, [])])    VariableReference(rnf, [])    Expression(e, [])  Statement(throw rnf, [])  Statement(}, [])  Statement(} else {, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(InputStream is, []), Expression(mAssets.openNonAsset(value.assetCookie, file, AssetManager.ACCESS_BUFFER), [])])    VariableReference(InputStream is, [])    Expression(mAssets.openNonAsset(value.assetCookie, file, AssetManager.ACCESS_BUFFER), [])  AssignmentExpression(=, [VariableReference(dr, []), Expression(Drawable.createFromResourceStream(this, value, is, file), [])])    VariableReference(dr, [])    Expression(Drawable.createFromResourceStream(this, value, is, file), [])  MethodCall(is.close(), [VariableReference(is, []), Expression(, [])])    VariableReference(is, [])    Expression(, [])  Statement(} catch (Exception e) {, [])  AssignmentExpression(=, [VariableReference(NotFoundException rnf, []), Expression(new NotFoundException(""File "" + file + "" from drawable resource ID #0x"" + Integer.toHexString(id)), [])])    VariableReference(NotFoundException rnf, [])    Expression(new NotFoundException(""File "" + file + "" from drawable resource ID #0x"" + Integer.toHexString(id)), [])  MethodCall(rnf.initCause(e), [VariableReference(rnf, []), Expression(e, [])])    VariableReference(rnf, [])    Expression(e, [])  Statement(throw rnf, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (dr !, []), Expression(null) {, [])])    VariableReference(if (dr !, [])    Expression(null) {, [])  MethodCall(dr.setChangingConfigurations(value.changingConfigurations), [VariableReference(dr, []), Expression(value.changingConfigurations, [])])    VariableReference(dr, [])    Expression(value.changingConfigurations, [])  AssignmentExpression(=, [VariableReference(cs, []), Expression(dr.getConstantState(), [])])    VariableReference(cs, [])    Expression(dr.getConstantState(), [])  AssignmentExpression(=, [VariableReference(if (cs !, []), Expression(null) {, [])])    VariableReference(if (cs !, [])    Expression(null) {, [])  Statement(if (mPreloading) {, [])  MethodCall(sPreloadedDrawables.put(key, cs), [VariableReference(sPreloadedDrawables, []), Expression(key, []), Expression(cs, [])])    VariableReference(sPreloadedDrawables, [])    Expression(key, [])    Expression(cs, [])  Statement(} else {, [])  Statement(synchronized (mTmpValue) {, [])  MethodCall(// Integer.toHexString(key.intValue()), [VariableReference(// Integer, []), Expression(key.intValue(), [])])    VariableReference(// Integer, [])    Expression(key.intValue(), [])  Statement(// + "" in "" + this + "": "" + cs), [])  MethodCall(mDrawableCache.put(key, new WeakReference<Drawable.ConstantState>(cs)), [VariableReference(mDrawableCache, []), Expression(key, []), Expression(new WeakReference<Drawable.ConstantState>(cs), [])])    VariableReference(mDrawableCache, [])    Expression(key, [])    Expression(new WeakReference<Drawable.ConstantState>(cs), [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(return dr, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (TRACE_FOR_PRELOAD) {, []), Statement(// Log only framework resources, []), AssignmentExpression(=, [VariableReference(if ((id >>> 24), []), Expression(, [])]), AssignmentExpression(=, [VariableReference(final String name, []), Expression(getResourceName(id), [])]), AssignmentExpression(=, [VariableReference(if (name !, []), Expression(null), [])]), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(final long key, []), Expression((((long) value.assetCookie) << 32) | value.data, [])]), AssignmentExpression(=, [VariableReference(Drawable dr, []), Expression(getCachedDrawable(key), [])]), AssignmentExpression(=, [VariableReference(if (dr !, []), Expression(null) {, [])]), Statement(return dr, []), Statement(}, []), AssignmentExpression(=, [VariableReference(Drawable.ConstantState cs, []), Expression(sPreloadedDrawables.get(key), [])]), AssignmentExpression(=, [VariableReference(if (cs !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(dr, []), Expression(cs.newDrawable(this), [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(if (value.type >, []), Expression(TypedValue.TYPE_FIRST_COLOR_INT && value.type <, [])]), AssignmentExpression(=, [VariableReference(dr, []), Expression(new ColorDrawable(value.data), [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (dr, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(if (value.string, []), Expression(, [])]), Statement(throw new NotFoundException(""Resource is not a Drawable (color or path): "" + value), []), Statement(}, []), AssignmentExpression(=, [VariableReference(String file, []), Expression(value.string.toString(), [])]), Statement(if (DEBUG_LOAD), []), MethodCall(Log.v(TAG, ""Loading drawable for cookie "" + value.assetCookie + "": "" + file), [VariableReference(Log, []), Expression(TAG, []), Expression(""Loading drawable for cookie "" + value.assetCookie + "": "" + file, [])]), MethodCall(if (file.endsWith("".xml"")), [VariableReference(if (file, []), Expression("".xml""), [])]), Statement(try {, []), AssignmentExpression(=, [VariableReference(XmlResourceParser rp, []), Expression(loadXmlResourceParser(file, id, value.assetCookie, ""drawable""), [])]), AssignmentExpression(=, [VariableReference(dr, []), Expression(Drawable.createFromXml(this, rp), [])]), MethodCall(rp.close(), [VariableReference(rp, []), Expression(, [])]), Statement(} catch (Exception e) {, []), AssignmentExpression(=, [VariableReference(NotFoundException rnf, []), Expression(new NotFoundException(""File "" + file + "" from drawable resource ID #0x"" + Integer.toHexString(id)), [])]), MethodCall(rnf.initCause(e), [VariableReference(rnf, []), Expression(e, [])]), Statement(throw rnf, []), Statement(}, []), Statement(} else {, []), Statement(try {, []), AssignmentExpression(=, [VariableReference(InputStream is, []), Expression(mAssets.openNonAsset(value.assetCookie, file, AssetManager.ACCESS_STREAMING), [])]), AssignmentExpression(=, [VariableReference(dr, []), Expression(Drawable.createFromResourceStream(this, value, is, file, null), [])]), MethodCall(is.close(), [VariableReference(is, []), Expression(, [])]), Statement(} catch (Exception e) {, []), AssignmentExpression(=, [VariableReference(NotFoundException rnf, []), Expression(new NotFoundException(""File "" + file + "" from drawable resource ID #0x"" + Integer.toHexString(id)), [])]), MethodCall(rnf.initCause(e), [VariableReference(rnf, []), Expression(e, [])]), Statement(throw rnf, []), Statement(}, []), Statement(}, []), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (dr !, []), Expression(null) {, [])]), MethodCall(dr.setChangingConfigurations(value.changingConfigurations), [VariableReference(dr, []), Expression(value.changingConfigurations, [])]), AssignmentExpression(=, [VariableReference(cs, []), Expression(dr.getConstantState(), [])]), AssignmentExpression(=, [VariableReference(if (cs !, []), Expression(null) {, [])]), Statement(if (mPreloading) {, []), MethodCall(sPreloadedDrawables.put(key, cs), [VariableReference(sPreloadedDrawables, []), Expression(key, []), Expression(cs, [])]), Statement(} else {, []), Statement(synchronized (mTmpValue) {, []), MethodCall(// Integer.toHexString(key.intValue()), [VariableReference(// Integer, []), Expression(key.intValue(), [])]), Statement(// + "" in "" + this + "": "" + cs), []), MethodCall(mDrawableCache.put(key, new WeakReference<Drawable.ConstantState>(cs)), [VariableReference(mDrawableCache, []), Expression(key, []), Expression(new WeakReference<Drawable.ConstantState>(cs), [])]), Statement(}, []), Statement(}, []), Statement(}, []), Statement(}, []), Statement(return dr, []), Statement(}, [])])  Statement({, [])  Statement(if (TRACE_FOR_PRELOAD) {, [])  Statement(// Log only framework resources, [])  AssignmentExpression(=, [VariableReference(if ((id >>> 24), []), Expression(, [])])    VariableReference(if ((id >>> 24), [])    Expression(, [])  AssignmentExpression(=, [VariableReference(final String name, []), Expression(getResourceName(id), [])])    VariableReference(final String name, [])    Expression(getResourceName(id), [])  AssignmentExpression(=, [VariableReference(if (name !, []), Expression(null), [])])    VariableReference(if (name !, [])    Expression(null), [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(final long key, []), Expression((((long) value.assetCookie) << 32) | value.data, [])])    VariableReference(final long key, [])    Expression((((long) value.assetCookie) << 32) | value.data, [])  AssignmentExpression(=, [VariableReference(Drawable dr, []), Expression(getCachedDrawable(key), [])])    VariableReference(Drawable dr, [])    Expression(getCachedDrawable(key), [])  AssignmentExpression(=, [VariableReference(if (dr !, []), Expression(null) {, [])])    VariableReference(if (dr !, [])    Expression(null) {, [])  Statement(return dr, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(Drawable.ConstantState cs, []), Expression(sPreloadedDrawables.get(key), [])])    VariableReference(Drawable.ConstantState cs, [])    Expression(sPreloadedDrawables.get(key), [])  AssignmentExpression(=, [VariableReference(if (cs !, []), Expression(null) {, [])])    VariableReference(if (cs !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(dr, []), Expression(cs.newDrawable(this), [])])    VariableReference(dr, [])    Expression(cs.newDrawable(this), [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(if (value.type >, []), Expression(TypedValue.TYPE_FIRST_COLOR_INT && value.type <, [])])    VariableReference(if (value.type >, [])    Expression(TypedValue.TYPE_FIRST_COLOR_INT && value.type <, [])  AssignmentExpression(=, [VariableReference(dr, []), Expression(new ColorDrawable(value.data), [])])    VariableReference(dr, [])    Expression(new ColorDrawable(value.data), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (dr, []), Expression(, [])])    VariableReference(if (dr, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(if (value.string, []), Expression(, [])])    VariableReference(if (value.string, [])    Expression(, [])  Statement(throw new NotFoundException(""Resource is not a Drawable (color or path): "" + value), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(String file, []), Expression(value.string.toString(), [])])    VariableReference(String file, [])    Expression(value.string.toString(), [])  Statement(if (DEBUG_LOAD), [])  MethodCall(Log.v(TAG, ""Loading drawable for cookie "" + value.assetCookie + "": "" + file), [VariableReference(Log, []), Expression(TAG, []), Expression(""Loading drawable for cookie "" + value.assetCookie + "": "" + file, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Loading drawable for cookie "" + value.assetCookie + "": "" + file, [])  MethodCall(if (file.endsWith("".xml"")), [VariableReference(if (file, []), Expression("".xml""), [])])    VariableReference(if (file, [])    Expression("".xml""), [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(XmlResourceParser rp, []), Expression(loadXmlResourceParser(file, id, value.assetCookie, ""drawable""), [])])    VariableReference(XmlResourceParser rp, [])    Expression(loadXmlResourceParser(file, id, value.assetCookie, ""drawable""), [])  AssignmentExpression(=, [VariableReference(dr, []), Expression(Drawable.createFromXml(this, rp), [])])    VariableReference(dr, [])    Expression(Drawable.createFromXml(this, rp), [])  MethodCall(rp.close(), [VariableReference(rp, []), Expression(, [])])    VariableReference(rp, [])    Expression(, [])  Statement(} catch (Exception e) {, [])  AssignmentExpression(=, [VariableReference(NotFoundException rnf, []), Expression(new NotFoundException(""File "" + file + "" from drawable resource ID #0x"" + Integer.toHexString(id)), [])])    VariableReference(NotFoundException rnf, [])    Expression(new NotFoundException(""File "" + file + "" from drawable resource ID #0x"" + Integer.toHexString(id)), [])  MethodCall(rnf.initCause(e), [VariableReference(rnf, []), Expression(e, [])])    VariableReference(rnf, [])    Expression(e, [])  Statement(throw rnf, [])  Statement(}, [])  Statement(} else {, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(InputStream is, []), Expression(mAssets.openNonAsset(value.assetCookie, file, AssetManager.ACCESS_STREAMING), [])])    VariableReference(InputStream is, [])    Expression(mAssets.openNonAsset(value.assetCookie, file, AssetManager.ACCESS_STREAMING), [])  AssignmentExpression(=, [VariableReference(dr, []), Expression(Drawable.createFromResourceStream(this, value, is, file, null), [])])    VariableReference(dr, [])    Expression(Drawable.createFromResourceStream(this, value, is, file, null), [])  MethodCall(is.close(), [VariableReference(is, []), Expression(, [])])    VariableReference(is, [])    Expression(, [])  Statement(} catch (Exception e) {, [])  AssignmentExpression(=, [VariableReference(NotFoundException rnf, []), Expression(new NotFoundException(""File "" + file + "" from drawable resource ID #0x"" + Integer.toHexString(id)), [])])    VariableReference(NotFoundException rnf, [])    Expression(new NotFoundException(""File "" + file + "" from drawable resource ID #0x"" + Integer.toHexString(id)), [])  MethodCall(rnf.initCause(e), [VariableReference(rnf, []), Expression(e, [])])    VariableReference(rnf, [])    Expression(e, [])  Statement(throw rnf, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (dr !, []), Expression(null) {, [])])    VariableReference(if (dr !, [])    Expression(null) {, [])  MethodCall(dr.setChangingConfigurations(value.changingConfigurations), [VariableReference(dr, []), Expression(value.changingConfigurations, [])])    VariableReference(dr, [])    Expression(value.changingConfigurations, [])  AssignmentExpression(=, [VariableReference(cs, []), Expression(dr.getConstantState(), [])])    VariableReference(cs, [])    Expression(dr.getConstantState(), [])  AssignmentExpression(=, [VariableReference(if (cs !, []), Expression(null) {, [])])    VariableReference(if (cs !, [])    Expression(null) {, [])  Statement(if (mPreloading) {, [])  MethodCall(sPreloadedDrawables.put(key, cs), [VariableReference(sPreloadedDrawables, []), Expression(key, []), Expression(cs, [])])    VariableReference(sPreloadedDrawables, [])    Expression(key, [])    Expression(cs, [])  Statement(} else {, [])  Statement(synchronized (mTmpValue) {, [])  MethodCall(// Integer.toHexString(key.intValue()), [VariableReference(// Integer, []), Expression(key.intValue(), [])])    VariableReference(// Integer, [])    Expression(key.intValue(), [])  Statement(// + "" in "" + this + "": "" + cs), [])  MethodCall(mDrawableCache.put(key, new WeakReference<Drawable.ConstantState>(cs)), [VariableReference(mDrawableCache, []), Expression(key, []), Expression(new WeakReference<Drawable.ConstantState>(cs), [])])    VariableReference(mDrawableCache, [])    Expression(key, [])    Expression(new WeakReference<Drawable.ConstantState>(cs), [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(return dr, [])  Statement(}, [])",1,"/*package*/
","/*package*/
",0,,,0,0,0,0,"1,2","1,3,4,5",1,"1,2,3,5","1,2","The return statement has changed: in the early version, `return dr` is used when `cs` is null, while in the late version, `return dr` is used when `dr` is not null. The exception handling statement has changed: the exception type `NotFoundException` is thrown in both versions, but the error message has been updated in the late version. The control dependency has changed: in the early version, `mPreloadedDrawables` is used to get the `ConstantState` object, while in the late version, `sPreloadedDrawables` is used. The dependent API has changed: in the early version, `Drawable.createFromResourceStream(this, value, is, file)` is used, while in the late version, `Drawable.createFromResourceStream(this, value, is, file, null)` is used.","The change in the return statement can lead to compatibility issues as the behavior of the method has been altered. In the early version, the method returns the `Drawable` object only if it is already in the cache or if a new `Drawable` object can be created from the resource data. In the late version, the method always returns a `Drawable` object if it is not null, even if it is not in the cache or cannot be created from the resource data. This can result in unexpected behavior in apps that rely on the previous behavior of the method."
35,"<android.content.pm.ResolveInfo: void dump(Printer,String)>",4,5,"<android.content.pm.ResolveInfo: void dump(Printer,String)>","<android.content.pm.ResolveInfo: void dump(Printer,String)>",0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (filter !, []), Expression(null) {, [])]), MethodCall(pw.println(prefix + ""Filter:""), [VariableReference(pw, []), Expression(prefix + ""Filter:"", [])]), MethodCall(filter.dump(pw, prefix + ""  ""), [VariableReference(filter, []), Expression(pw, []), Expression(prefix + ""  "", [])]), Statement(} else {, []), MethodCall(pw.println(prefix + ""Filter: null""), [VariableReference(pw, []), Expression(prefix + ""Filter: null"", [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(pw.println(prefix + ""priority, []), Expression("" + priority + "" preferredOrder, [])]), AssignmentExpression(=, [VariableReference(pw.println(prefix + ""labelRes, []), Expression(0x"" + Integer.toHexString(labelRes) + "" nonLocalizedLabel, [])]), AssignmentExpression(=, [VariableReference(if (activityInfo !, []), Expression(null) {, [])]), MethodCall(pw.println(prefix + ""ActivityInfo:""), [VariableReference(pw, []), Expression(prefix + ""ActivityInfo:"", [])]), MethodCall(activityInfo.dump(pw, prefix + ""  ""), [VariableReference(activityInfo, []), Expression(pw, []), Expression(prefix + ""  "", [])]), AssignmentExpression(=, [VariableReference(} else if (serviceInfo !, []), Expression(null) {, [])]), MethodCall(pw.println(prefix + ""ServiceInfo:""), [VariableReference(pw, []), Expression(prefix + ""ServiceInfo:"", [])]), Statement(// TODO, []), MethodCall(// serviceInfo.dump(pw, prefix + ""  ""), [VariableReference(// serviceInfo, []), Expression(pw, []), Expression(prefix + ""  "", [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (filter !, []), Expression(null) {, [])])    VariableReference(if (filter !, [])    Expression(null) {, [])  MethodCall(pw.println(prefix + ""Filter:""), [VariableReference(pw, []), Expression(prefix + ""Filter:"", [])])    VariableReference(pw, [])    Expression(prefix + ""Filter:"", [])  MethodCall(filter.dump(pw, prefix + ""  ""), [VariableReference(filter, []), Expression(pw, []), Expression(prefix + ""  "", [])])    VariableReference(filter, [])    Expression(pw, [])    Expression(prefix + ""  "", [])  Statement(} else {, [])  MethodCall(pw.println(prefix + ""Filter: null""), [VariableReference(pw, []), Expression(prefix + ""Filter: null"", [])])    VariableReference(pw, [])    Expression(prefix + ""Filter: null"", [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(pw.println(prefix + ""priority, []), Expression("" + priority + "" preferredOrder, [])])    VariableReference(pw.println(prefix + ""priority, [])    Expression("" + priority + "" preferredOrder, [])  AssignmentExpression(=, [VariableReference(pw.println(prefix + ""labelRes, []), Expression(0x"" + Integer.toHexString(labelRes) + "" nonLocalizedLabel, [])])    VariableReference(pw.println(prefix + ""labelRes, [])    Expression(0x"" + Integer.toHexString(labelRes) + "" nonLocalizedLabel, [])  AssignmentExpression(=, [VariableReference(if (activityInfo !, []), Expression(null) {, [])])    VariableReference(if (activityInfo !, [])    Expression(null) {, [])  MethodCall(pw.println(prefix + ""ActivityInfo:""), [VariableReference(pw, []), Expression(prefix + ""ActivityInfo:"", [])])    VariableReference(pw, [])    Expression(prefix + ""ActivityInfo:"", [])  MethodCall(activityInfo.dump(pw, prefix + ""  ""), [VariableReference(activityInfo, []), Expression(pw, []), Expression(prefix + ""  "", [])])    VariableReference(activityInfo, [])    Expression(pw, [])    Expression(prefix + ""  "", [])  AssignmentExpression(=, [VariableReference(} else if (serviceInfo !, []), Expression(null) {, [])])    VariableReference(} else if (serviceInfo !, [])    Expression(null) {, [])  MethodCall(pw.println(prefix + ""ServiceInfo:""), [VariableReference(pw, []), Expression(prefix + ""ServiceInfo:"", [])])    VariableReference(pw, [])    Expression(prefix + ""ServiceInfo:"", [])  Statement(// TODO, [])  MethodCall(// serviceInfo.dump(pw, prefix + ""  ""), [VariableReference(// serviceInfo, []), Expression(pw, []), Expression(prefix + ""  "", [])])    VariableReference(// serviceInfo, [])    Expression(pw, [])    Expression(prefix + ""  "", [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (filter !, []), Expression(null) {, [])]), MethodCall(pw.println(prefix + ""Filter:""), [VariableReference(pw, []), Expression(prefix + ""Filter:"", [])]), MethodCall(filter.dump(pw, prefix + ""  ""), [VariableReference(filter, []), Expression(pw, []), Expression(prefix + ""  "", [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(pw.println(prefix + ""priority, []), Expression("" + priority + "" preferredOrder, [])]), AssignmentExpression(=, [VariableReference(if (resolvePackageName !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(pw.println(prefix + ""resolvePackageName, []), Expression("" + resolvePackageName), [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (labelRes !, []), Expression(0 || nonLocalizedLabel !, [])]), AssignmentExpression(=, [VariableReference(pw.println(prefix + ""labelRes, []), Expression(0x"" + Integer.toHexString(labelRes) + "" nonLocalizedLabel, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (activityInfo !, []), Expression(null) {, [])]), MethodCall(pw.println(prefix + ""ActivityInfo:""), [VariableReference(pw, []), Expression(prefix + ""ActivityInfo:"", [])]), MethodCall(activityInfo.dump(pw, prefix + ""  ""), [VariableReference(activityInfo, []), Expression(pw, []), Expression(prefix + ""  "", [])]), AssignmentExpression(=, [VariableReference(} else if (serviceInfo !, []), Expression(null) {, [])]), MethodCall(pw.println(prefix + ""ServiceInfo:""), [VariableReference(pw, []), Expression(prefix + ""ServiceInfo:"", [])]), MethodCall(serviceInfo.dump(pw, prefix + ""  ""), [VariableReference(serviceInfo, []), Expression(pw, []), Expression(prefix + ""  "", [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (filter !, []), Expression(null) {, [])])    VariableReference(if (filter !, [])    Expression(null) {, [])  MethodCall(pw.println(prefix + ""Filter:""), [VariableReference(pw, []), Expression(prefix + ""Filter:"", [])])    VariableReference(pw, [])    Expression(prefix + ""Filter:"", [])  MethodCall(filter.dump(pw, prefix + ""  ""), [VariableReference(filter, []), Expression(pw, []), Expression(prefix + ""  "", [])])    VariableReference(filter, [])    Expression(pw, [])    Expression(prefix + ""  "", [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(pw.println(prefix + ""priority, []), Expression("" + priority + "" preferredOrder, [])])    VariableReference(pw.println(prefix + ""priority, [])    Expression("" + priority + "" preferredOrder, [])  AssignmentExpression(=, [VariableReference(if (resolvePackageName !, []), Expression(null) {, [])])    VariableReference(if (resolvePackageName !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(pw.println(prefix + ""resolvePackageName, []), Expression("" + resolvePackageName), [])])    VariableReference(pw.println(prefix + ""resolvePackageName, [])    Expression("" + resolvePackageName), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (labelRes !, []), Expression(0 || nonLocalizedLabel !, [])])    VariableReference(if (labelRes !, [])    Expression(0 || nonLocalizedLabel !, [])  AssignmentExpression(=, [VariableReference(pw.println(prefix + ""labelRes, []), Expression(0x"" + Integer.toHexString(labelRes) + "" nonLocalizedLabel, [])])    VariableReference(pw.println(prefix + ""labelRes, [])    Expression(0x"" + Integer.toHexString(labelRes) + "" nonLocalizedLabel, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (activityInfo !, []), Expression(null) {, [])])    VariableReference(if (activityInfo !, [])    Expression(null) {, [])  MethodCall(pw.println(prefix + ""ActivityInfo:""), [VariableReference(pw, []), Expression(prefix + ""ActivityInfo:"", [])])    VariableReference(pw, [])    Expression(prefix + ""ActivityInfo:"", [])  MethodCall(activityInfo.dump(pw, prefix + ""  ""), [VariableReference(activityInfo, []), Expression(pw, []), Expression(prefix + ""  "", [])])    VariableReference(activityInfo, [])    Expression(pw, [])    Expression(prefix + ""  "", [])  AssignmentExpression(=, [VariableReference(} else if (serviceInfo !, []), Expression(null) {, [])])    VariableReference(} else if (serviceInfo !, [])    Expression(null) {, [])  MethodCall(pw.println(prefix + ""ServiceInfo:""), [VariableReference(pw, []), Expression(prefix + ""ServiceInfo:"", [])])    VariableReference(pw, [])    Expression(prefix + ""ServiceInfo:"", [])  MethodCall(serviceInfo.dump(pw, prefix + ""  ""), [VariableReference(serviceInfo, []), Expression(pw, []), Expression(prefix + ""  "", [])])    VariableReference(serviceInfo, [])    Expression(pw, [])    Expression(prefix + ""  "", [])  Statement(}, [])  Statement(}, [])",1,,,0,,,0,0,0,0,1,"2,4",0,4,0,"In the late version implementation of `dump` method in `ResolveInfo` class, a new statement `pw.println(prefix + ""resolvePackageName: "" + resolvePackageName)` is added, which prints the value of `resolvePackageName` field of `ResolveInfo` class. However, this change does not affect the behavior of `dump` method, as it is only used for logging and debugging purposes.","No compatibility issue (CI) exists in this case, as the change does not affect the behavior of `dump` method, and the API still returns the same value and throws the same exception as in the early version."
36,<android.webkit.WebView: void clearMatches()>,4,5,<android.webkit.WebView: void clearMatches()>,<android.webkit.WebView: void clearMatches()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(mFindIsUp, []), Expression(false, [])]), Statement(nativeSetFindIsDown(), []), Statement(// Now that the dialog has been removed, ensure that we scroll to a, []), Statement(// location that is not beyond the end of the page., []), Statement(pinScrollTo(mScrollX, mScrollY, false, 0), []), Statement(invalidate(), []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(mFindIsUp, []), Expression(false, [])])    VariableReference(mFindIsUp, [])    Expression(false, [])  Statement(nativeSetFindIsDown(), [])  Statement(// Now that the dialog has been removed, ensure that we scroll to a, [])  Statement(// location that is not beyond the end of the page., [])  Statement(pinScrollTo(mScrollX, mScrollY, false, 0), [])  Statement(invalidate(), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (mFindIsUp) {, []), Statement(recordNewContentSize(mContentWidth, mContentHeight - mFindHeight, false), []), AssignmentExpression(=, [VariableReference(mFindIsUp, []), Expression(false, [])]), Statement(}, []), Statement(nativeSetFindIsDown(), []), Statement(// Now that the dialog has been removed, ensure that we scroll to a, []), Statement(// location that is not beyond the end of the page., []), Statement(pinScrollTo(mScrollX, mScrollY, false, 0), []), Statement(invalidate(), []), Statement(}, [])])  Statement({, [])  Statement(if (mFindIsUp) {, [])  Statement(recordNewContentSize(mContentWidth, mContentHeight - mFindHeight, false), [])  AssignmentExpression(=, [VariableReference(mFindIsUp, []), Expression(false, [])])    VariableReference(mFindIsUp, [])    Expression(false, [])  Statement(}, [])  Statement(nativeSetFindIsDown(), [])  Statement(// Now that the dialog has been removed, ensure that we scroll to a, [])  Statement(// location that is not beyond the end of the page., [])  Statement(pinScrollTo(mScrollX, mScrollY, false, 0), [])  Statement(invalidate(), [])  Statement(}, [])",1,"/*
     * Clear the highlighting surrounding text matches created by findAll.
     */
","/*
     * Clear the highlighting surrounding text matches created by findAll.
     */
",0,,,0,0,0,0,1,"2,4",0,3,1,"A new control dependency statement (if statement) has been introduced in the late version, which may cause the API to have different behaviors.","The new if statement in the late version may cause the API to return different values or types, as the execution of some statements is now dependent on the condition. Therefore, this is a Compatibility Issue caused by potential different return values or types."
37,<android.widget.VideoView: boolean isPlaying()>,4,5,<android.widget.VideoView: boolean isPlaying()>,<android.widget.VideoView: boolean isPlaying()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mMediaPlayer !, []), Expression(null && mIsPrepared) {, [])]), MethodCall(return mMediaPlayer.isPlaying(), [VariableReference(return mMediaPlayer, []), Expression(, [])]), Statement(}, []), Statement(return false, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mMediaPlayer !, []), Expression(null && mIsPrepared) {, [])])    VariableReference(if (mMediaPlayer !, [])    Expression(null && mIsPrepared) {, [])  MethodCall(return mMediaPlayer.isPlaying(), [VariableReference(return mMediaPlayer, []), Expression(, [])])    VariableReference(return mMediaPlayer, [])    Expression(, [])  Statement(}, [])  Statement(return false, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(return isInPlaybackState() && mMediaPlayer.isPlaying(), [VariableReference(return isInPlaybackState() && mMediaPlayer, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return isInPlaybackState() && mMediaPlayer.isPlaying(), [VariableReference(return isInPlaybackState() && mMediaPlayer, []), Expression(, [])])    VariableReference(return isInPlaybackState() && mMediaPlayer, [])    Expression(, [])  Statement(}, [])",1,,,0,,,0,0,0,0,1,"1,2",1,"1,5",1,"The return statement in the early version (`return mMediaPlayer.isPlaying()`) has been replaced with a new return statement in the late version (`return isInPlaybackState() && mMediaPlayer.isPlaying()`). Additionally, the dependent API `isInPlaybackState()` has been introduced in the late version.","The introduction of the `isInPlaybackState()` check in the late version could potentially cause the API to return a different value compared to the early version. Specifically, if `isInPlaybackState()` returns `false`, the API will return `false` even if `mMediaPlayer.isPlaying()` is `true`. This could lead to compatibility issues in client code that relies on the original behavior of the API."
39,<android.view.Surface: String toString()>,4,5,<android.view.Surface: String toString()>,<android.view.Surface: String toString()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(return ""Surface(native-token, []), Expression("" + mSurface + "")"", [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(return ""Surface(native-token, []), Expression("" + mSurface + "")"", [])])    VariableReference(return ""Surface(native-token, [])    Expression("" + mSurface + "")"", [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(return ""Surface(native-token, []), Expression("" + mSurfaceControl + "")"", [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(return ""Surface(native-token, []), Expression("" + mSurfaceControl + "")"", [])])    VariableReference(return ""Surface(native-token, [])    Expression("" + mSurfaceControl + "")"", [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,0,0,0,1,1,1,1,1,"The return statement in the method has been changed. In the early version, the method returns `mSurface`, while in the late version, the method returns `mSurfaceControl`.","The change of the return statement can lead to different behaviors. As the method returns a different object in the late version, the code that relies on the return value of this method may not work as expected. For example, if the code in the early version calls `mSurface.getWidth()` to get the width of the surface, the same code in the late version will not work, because `mSurfaceControl` does not have a `getWidth()` method."
40,<android.webkit.BrowserFrame: void didFirstLayout()>,4,5,<android.webkit.BrowserFrame: void didFirstLayout()>,<android.webkit.BrowserFrame: void didFirstLayout()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(if (!mFirstLayoutDone) {, []), AssignmentExpression(=, [VariableReference(mFirstLayoutDone, []), Expression(true, [])]), Statement(// ensure {@link WebViewCore#webkitDraw} is called as we were, []), Statement(// blocking the update in {@link #loadStarted}, []), MethodCall(mWebViewCore.contentDraw(), [VariableReference(mWebViewCore, []), Expression(, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(mWebViewCore.mEndScaleZoom, []), Expression(true, [])]), Statement(}, [])])  Statement({, [])  Statement(if (!mFirstLayoutDone) {, [])  AssignmentExpression(=, [VariableReference(mFirstLayoutDone, []), Expression(true, [])])    VariableReference(mFirstLayoutDone, [])    Expression(true, [])  Statement(// ensure {@link WebViewCore#webkitDraw} is called as we were, [])  Statement(// blocking the update in {@link #loadStarted}, [])  MethodCall(mWebViewCore.contentDraw(), [VariableReference(mWebViewCore, []), Expression(, [])])    VariableReference(mWebViewCore, [])    Expression(, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mWebViewCore.mEndScaleZoom, []), Expression(true, [])])    VariableReference(mWebViewCore.mEndScaleZoom, [])    Expression(true, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (!mFirstLayoutDone) {, []), AssignmentExpression(=, [VariableReference(mFirstLayoutDone, []), Expression(true, [])]), Statement(// ensure {@link WebViewCore#webkitDraw} is called as we were, []), Statement(// blocking the update in {@link #loadStarted}, []), MethodCall(mWebViewCore.contentDraw(), [VariableReference(mWebViewCore, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(if (!mFirstLayoutDone) {, [])  AssignmentExpression(=, [VariableReference(mFirstLayoutDone, []), Expression(true, [])])    VariableReference(mFirstLayoutDone, [])    Expression(true, [])  Statement(// ensure {@link WebViewCore#webkitDraw} is called as we were, [])  Statement(// blocking the update in {@link #loadStarted}, [])  MethodCall(mWebViewCore.contentDraw(), [VariableReference(mWebViewCore, []), Expression(, [])])    VariableReference(mWebViewCore, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",1,"/* package */
","/* package */
",0,,,0,0,0,0,1,"3,4",0,4,0,The only difference between the two versions is that the late version does not have the following statement:,
41,<android.hardware.Camera.Parameters: void setPictureFormat(int)>,4,5,<android.hardware.Camera.Parameters: void setPictureFormat(int)>,<android.hardware.Camera.Parameters: void setPictureFormat(int)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(String s, []), Expression(cameraFormatForPixelFormat(pixel_format), [])]), AssignmentExpression(=, [VariableReference(if (s, []), Expression(, [])]), Statement(throw new IllegalArgumentException(), []), Statement(}, []), Statement(set(""picture-format"", s), []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(String s, []), Expression(cameraFormatForPixelFormat(pixel_format), [])])    VariableReference(String s, [])    Expression(cameraFormatForPixelFormat(pixel_format), [])  AssignmentExpression(=, [VariableReference(if (s, []), Expression(, [])])    VariableReference(if (s, [])    Expression(, [])  Statement(throw new IllegalArgumentException(), [])  Statement(}, [])  Statement(set(""picture-format"", s), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(String s, []), Expression(cameraFormatForPixelFormat(pixel_format), [])]), AssignmentExpression(=, [VariableReference(if (s, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(throw new IllegalArgumentException(""Invalid pixel_format, []), Expression("" + pixel_format), [])]), Statement(}, []), Statement(set(KEY_PICTURE_FORMAT, s), []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(String s, []), Expression(cameraFormatForPixelFormat(pixel_format), [])])    VariableReference(String s, [])    Expression(cameraFormatForPixelFormat(pixel_format), [])  AssignmentExpression(=, [VariableReference(if (s, []), Expression(, [])])    VariableReference(if (s, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(throw new IllegalArgumentException(""Invalid pixel_format, []), Expression("" + pixel_format), [])])    VariableReference(throw new IllegalArgumentException(""Invalid pixel_format, [])    Expression("" + pixel_format), [])  Statement(}, [])  Statement(set(KEY_PICTURE_FORMAT, s), [])  Statement(}, [])",1,"/**
 * Sets the image format for pictures.
 *
 * @param pixel_format the desired picture format
 * (<var>PixelFormat.YCbCr_420_SP</var>,
 * <var>PixelFormat.RGB_565</var>, or
 * <var>PixelFormat.JPEG</var>)
 * @see android.graphics.PixelFormat
 */
","/**
 * Sets the image format for pictures.
 *
 * @param pixel_format the desired picture format
 * (<var>PixelFormat.YCbCr_420_SP (NV21)</var>,
 * <var>PixelFormat.RGB_565</var>, or
 * <var>PixelFormat.JPEG</var>)
 * @see android.graphics.PixelFormat
 */
",1,,,0,0,0,0,"1,2","2,3,4,5",2,"2,5","1,2","The code change between the two versions involves changes in the exception handling statement and the dependent API. Specifically, the exception handling statement in the early version throws a new IllegalArgumentException() with no message, while in the late version, it throws a new IllegalArgumentException(""Invalid pixel_format"" + pixel_format) with a customized error message. Additionally, the dependent API in the early version is set(""picture-format"", s) while in the late version, it is set(KEY_PICTURE_FORMAT, s), which might potentially lead to different behaviors.","The changes in the exception handling statement could cause the API to throw different exceptions, specifically, the late version throws an exception with a customized error message while the early version does not. The changes in the dependent API, set(""picture-format"", s) vs. set(KEY_PICTURE_FORMAT, s), might potentially cause the API to return different values or types. Therefore, the compatibility issue situation belongs to both class 1 and class 2."
42,<android.hardware.Camera.Parameters: Size getPictureSize()>,4,5,<android.hardware.Camera.Parameters: Size getPictureSize()>,<android.hardware.Camera.Parameters: Size getPictureSize()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(String pair, []), Expression(get(""picture-size""), [])]), AssignmentExpression(=, [VariableReference(if (pair, []), Expression(, [])]), Statement(return null, []), AssignmentExpression(=, [VariableReference(String[] dims, []), Expression(pair.split(""x""), [])]), AssignmentExpression(=, [VariableReference(if (dims.length !, []), Expression(2), [])]), Statement(return null, []), MethodCall(return new Size(Integer.parseInt(dims[0]), Integer.parseInt(dims[1])), [VariableReference(return new Size(Integer, []), Expression(dims[0]), []), Expression(Integer.parseInt(dims[1]), [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(String pair, []), Expression(get(""picture-size""), [])])    VariableReference(String pair, [])    Expression(get(""picture-size""), [])  AssignmentExpression(=, [VariableReference(if (pair, []), Expression(, [])])    VariableReference(if (pair, [])    Expression(, [])  Statement(return null, [])  AssignmentExpression(=, [VariableReference(String[] dims, []), Expression(pair.split(""x""), [])])    VariableReference(String[] dims, [])    Expression(pair.split(""x""), [])  AssignmentExpression(=, [VariableReference(if (dims.length !, []), Expression(2), [])])    VariableReference(if (dims.length !, [])    Expression(2), [])  Statement(return null, [])  MethodCall(return new Size(Integer.parseInt(dims[0]), Integer.parseInt(dims[1])), [VariableReference(return new Size(Integer, []), Expression(dims[0]), []), Expression(Integer.parseInt(dims[1]), [])])    VariableReference(return new Size(Integer, [])    Expression(dims[0]), [])    Expression(Integer.parseInt(dims[1]), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(String pair, []), Expression(get(KEY_PICTURE_SIZE), [])]), Statement(return strToSize(pair), []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(String pair, []), Expression(get(KEY_PICTURE_SIZE), [])])    VariableReference(String pair, [])    Expression(get(KEY_PICTURE_SIZE), [])  Statement(return strToSize(pair), [])  Statement(}, [])",1,"/**
 * Returns the dimension setting for pictures.
 *
 * @return a Size object with the height and width setting
 * for pictures
 */
","/**
 * Returns the dimension setting for pictures.
 *
 * @return a Size object with the height and width setting
 * for pictures
 */
",0,,,0,0,0,0,1,"1,3,4",1,5,1,"The implementation of the API has been changed significantly. In the early version, the API will return null if the parameter pair is null or if the length of the dims array is not 2. In the late version, the API will always return a Size object by calling the strToSize method.","The API in the early version may return null, while the API in the late version will always return a Size object. This can cause compatibility issues if the client code is not updated to handle the non-null return value."
43,<android.animation.ValueAnimator: void end()>,15,16,<android.animation.ValueAnimator: void end()>,<android.animation.ValueAnimator: void end()>,0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(if (!sAnimations.get().contains(this) && !sPendingAnimations.get().contains(this)), [VariableReference(if (!sAnimations, []), Expression().contains(this) && !sPendingAnimations.get().contains(this), [])]), Statement(// Special case if the animation has not yet started, []), Statement(get it ready for ending, []), AssignmentExpression(=, [VariableReference(mStartedDelay, []), Expression(false, [])]), Statement(startAnimation(), []), Statement(} else if (!mInitialized) {, []), Statement(initAnimation(), []), Statement(}, []), Statement(// was supposed to repeat an odd number of times, []), AssignmentExpression(=, [VariableReference(if (mRepeatCount > 0 && (mRepeatCount & 0x01), []), Expression(, [])]), Statement(animateValue(0f), []), Statement(} else {, []), Statement(animateValue(1f), []), Statement(}, []), Statement(endAnimation(), []), Statement(}, [])])  Statement({, [])  MethodCall(if (!sAnimations.get().contains(this) && !sPendingAnimations.get().contains(this)), [VariableReference(if (!sAnimations, []), Expression().contains(this) && !sPendingAnimations.get().contains(this), [])])    VariableReference(if (!sAnimations, [])    Expression().contains(this) && !sPendingAnimations.get().contains(this), [])  Statement(// Special case if the animation has not yet started, [])  Statement(get it ready for ending, [])  AssignmentExpression(=, [VariableReference(mStartedDelay, []), Expression(false, [])])    VariableReference(mStartedDelay, [])    Expression(false, [])  Statement(startAnimation(), [])  Statement(} else if (!mInitialized) {, [])  Statement(initAnimation(), [])  Statement(}, [])  Statement(// was supposed to repeat an odd number of times, [])  AssignmentExpression(=, [VariableReference(if (mRepeatCount > 0 && (mRepeatCount & 0x01), []), Expression(, [])])    VariableReference(if (mRepeatCount > 0 && (mRepeatCount & 0x01), [])    Expression(, [])  Statement(animateValue(0f), [])  Statement(} else {, [])  Statement(animateValue(1f), [])  Statement(}, [])  Statement(endAnimation(), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(AnimationHandler handler, []), Expression(getOrCreateAnimationHandler(), [])]), Statement(// Special case if the animation has not yet started, []), Statement(get it ready for ending, []), AssignmentExpression(=, [VariableReference(mStartedDelay, []), Expression(false, [])]), Statement(startAnimation(handler), []), AssignmentExpression(=, [VariableReference(mStarted, []), Expression(true, [])]), Statement(} else if (!mInitialized) {, []), Statement(initAnimation(), []), Statement(}, []), Statement(// was supposed to repeat an odd number of times, []), AssignmentExpression(=, [VariableReference(if (mRepeatCount > 0 && (mRepeatCount & 0x01), []), Expression(, [])]), Statement(animateValue(0f), []), Statement(} else {, []), Statement(animateValue(1f), []), Statement(}, []), Statement(endAnimation(handler), []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(AnimationHandler handler, []), Expression(getOrCreateAnimationHandler(), [])])    VariableReference(AnimationHandler handler, [])    Expression(getOrCreateAnimationHandler(), [])  Statement(// Special case if the animation has not yet started, [])  Statement(get it ready for ending, [])  AssignmentExpression(=, [VariableReference(mStartedDelay, []), Expression(false, [])])    VariableReference(mStartedDelay, [])    Expression(false, [])  Statement(startAnimation(handler), [])  AssignmentExpression(=, [VariableReference(mStarted, []), Expression(true, [])])    VariableReference(mStarted, [])    Expression(true, [])  Statement(} else if (!mInitialized) {, [])  Statement(initAnimation(), [])  Statement(}, [])  Statement(// was supposed to repeat an odd number of times, [])  AssignmentExpression(=, [VariableReference(if (mRepeatCount > 0 && (mRepeatCount & 0x01), []), Expression(, [])])    VariableReference(if (mRepeatCount > 0 && (mRepeatCount & 0x01), [])    Expression(, [])  Statement(animateValue(0f), [])  Statement(} else {, [])  Statement(animateValue(1f), [])  Statement(}, [])  Statement(endAnimation(handler), [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,0,0,0,"1,2","3,4",0,5,1,A new variable "AnimationHandler handler" is assigned with the result of "getOrCreateAnimationHandler()" method. The method "startAnimation()" and "endAnimation()" is changed to "startAnimation(handler)" and "endAnimation(handler)" respectively.,The change in method "startAnimation()" and "endAnimation()" may cause different behavior as the handler variable is now passed as an argument. The animation may not start or end as expected if the handler is not properly set up in the "getOrCreateAnimationHandler()" method.
44,<android.app.Activity: void onConfigurationChanged(Configuration)>,15,16,<android.app.Activity: void onConfigurationChanged(Configuration)>,<android.app.Activity: void onConfigurationChanged(Configuration)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(mCalled, []), Expression(true, [])]), MethodCall(mFragments.dispatchConfigurationChanged(newConfig), [VariableReference(mFragments, []), Expression(newConfig, [])]), AssignmentExpression(=, [VariableReference(if (mWindow !, []), Expression(null) {, [])]), Statement(// Pass the configuration changed event to the window, []), MethodCall(mWindow.onConfigurationChanged(newConfig), [VariableReference(mWindow, []), Expression(newConfig, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mActionBar !, []), Expression(null) {, [])]), Statement(// Do this last, []), Statement(the action bar will need to access, []), Statement(// view changes from above., []), MethodCall(mActionBar.onConfigurationChanged(newConfig), [VariableReference(mActionBar, []), Expression(newConfig, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(mCalled, []), Expression(true, [])])    VariableReference(mCalled, [])    Expression(true, [])  MethodCall(mFragments.dispatchConfigurationChanged(newConfig), [VariableReference(mFragments, []), Expression(newConfig, [])])    VariableReference(mFragments, [])    Expression(newConfig, [])  AssignmentExpression(=, [VariableReference(if (mWindow !, []), Expression(null) {, [])])    VariableReference(if (mWindow !, [])    Expression(null) {, [])  Statement(// Pass the configuration changed event to the window, [])  MethodCall(mWindow.onConfigurationChanged(newConfig), [VariableReference(mWindow, []), Expression(newConfig, [])])    VariableReference(mWindow, [])    Expression(newConfig, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mActionBar !, []), Expression(null) {, [])])    VariableReference(if (mActionBar !, [])    Expression(null) {, [])  Statement(// Do this last, [])  Statement(the action bar will need to access, [])  Statement(// view changes from above., [])  MethodCall(mActionBar.onConfigurationChanged(newConfig), [VariableReference(mActionBar, []), Expression(newConfig, [])])    VariableReference(mActionBar, [])    Expression(newConfig, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (DEBUG_LIFECYCLE), []), MethodCall(Slog.v(TAG, ""onConfigurationChanged "" + this + "": "" + newConfig), [VariableReference(Slog, []), Expression(TAG, []), Expression(""onConfigurationChanged "" + this + "": "" + newConfig, [])]), AssignmentExpression(=, [VariableReference(mCalled, []), Expression(true, [])]), MethodCall(mFragments.dispatchConfigurationChanged(newConfig), [VariableReference(mFragments, []), Expression(newConfig, [])]), AssignmentExpression(=, [VariableReference(if (mWindow !, []), Expression(null) {, [])]), Statement(// Pass the configuration changed event to the window, []), MethodCall(mWindow.onConfigurationChanged(newConfig), [VariableReference(mWindow, []), Expression(newConfig, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mActionBar !, []), Expression(null) {, [])]), Statement(// Do this last, []), Statement(the action bar will need to access, []), Statement(// view changes from above., []), MethodCall(mActionBar.onConfigurationChanged(newConfig), [VariableReference(mActionBar, []), Expression(newConfig, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(if (DEBUG_LIFECYCLE), [])  MethodCall(Slog.v(TAG, ""onConfigurationChanged "" + this + "": "" + newConfig), [VariableReference(Slog, []), Expression(TAG, []), Expression(""onConfigurationChanged "" + this + "": "" + newConfig, [])])    VariableReference(Slog, [])    Expression(TAG, [])    Expression(""onConfigurationChanged "" + this + "": "" + newConfig, [])  AssignmentExpression(=, [VariableReference(mCalled, []), Expression(true, [])])    VariableReference(mCalled, [])    Expression(true, [])  MethodCall(mFragments.dispatchConfigurationChanged(newConfig), [VariableReference(mFragments, []), Expression(newConfig, [])])    VariableReference(mFragments, [])    Expression(newConfig, [])  AssignmentExpression(=, [VariableReference(if (mWindow !, []), Expression(null) {, [])])    VariableReference(if (mWindow !, [])    Expression(null) {, [])  Statement(// Pass the configuration changed event to the window, [])  MethodCall(mWindow.onConfigurationChanged(newConfig), [VariableReference(mWindow, []), Expression(newConfig, [])])    VariableReference(mWindow, [])    Expression(newConfig, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mActionBar !, []), Expression(null) {, [])])    VariableReference(if (mActionBar !, [])    Expression(null) {, [])  Statement(// Do this last, [])  Statement(the action bar will need to access, [])  Statement(// view changes from above., [])  MethodCall(mActionBar.onConfigurationChanged(newConfig), [VariableReference(mActionBar, []), Expression(newConfig, [])])    VariableReference(mActionBar, [])    Expression(newConfig, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Called by the system when the device configuration changes while your
 * activity is running.  Note that this will <em>only</em> be called if
 * you have selected configurations you would like to handle with the
 * {@link android.R.attr#configChanges} attribute in your manifest.  If
 * any configuration change occurs that is not selected to be reported
 * by that attribute, then instead of reporting it the system will stop
 * and restart the activity (to have it launched with the new
 * configuration).
 *
 * <p>At the time that this function has been called, your Resources
 * object will have been updated to return resource values matching the
 * new configuration.
 *
 * @param newConfig The new device configuration.
 */
","/**
 * Called by the system when the device configuration changes while your
 * activity is running.  Note that this will <em>only</em> be called if
 * you have selected configurations you would like to handle with the
 * {@link android.R.attr#configChanges} attribute in your manifest.  If
 * any configuration change occurs that is not selected to be reported
 * by that attribute, then instead of reporting it the system will stop
 * and restart the activity (to have it launched with the new
 * configuration).
 *
 * <p>At the time that this function has been called, your Resources
 * object will have been updated to return resource values matching the
 * new configuration.
 *
 * @param newConfig The new device configuration.
 */
",0,,,0,0,0,0,1,"3,4",0,4,0,"The code change between two versions is the addition of two statements - an if statement and a method call (Slog.v) inside it. The if statement checks the value of DEBUG\_LIFECYCLE, and if it is true, it logs a message using the Slog.v method. This change does not affect the flow of the program or the return value, and it is only for debugging purposes.","No Compatibility Issue exists. The code change is an addition of a debugging statement, which does not affect the behavior of the API."
45,<android.webkit.WebSettings: void setBuiltInZoomControls(boolean)>,15,16,<android.webkit.WebSettings: void setBuiltInZoomControls(boolean)>,<android.webkit.WebSettings: void setBuiltInZoomControls(boolean)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(mBuiltInZoomControls, []), Expression(enabled, [])]), MethodCall(mWebView.updateMultiTouchSupport(mContext), [VariableReference(mWebView, []), Expression(mContext, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(mBuiltInZoomControls, []), Expression(enabled, [])])    VariableReference(mBuiltInZoomControls, [])    Expression(enabled, [])  MethodCall(mWebView.updateMultiTouchSupport(mContext), [VariableReference(mWebView, []), Expression(mContext, [])])    VariableReference(mWebView, [])    Expression(mContext, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(throw new MustOverrideException(), []), Statement(}, [])])  Statement({, [])  Statement(throw new MustOverrideException(), [])  Statement(}, [])",1,"/**
 * Sets whether the zoom mechanism built into WebView is used.
 */
","// {@link WebView#getZoomControls}, which is now hidden.
",1,,,0,0,0,0,1,"2,4",2,"2,5","1,2","The implementation of the method has been completely changed. In the early version, the method sets a variable `mBuiltInZoomControls` to the input parameter `enabled` and then calls `mWebView.updateMultiTouchSupport(mContext)`. In the late version, the method throws a `MustOverrideException` and does not have any other functionality. This is a major change that could lead to different behaviors.","The change in the implementation could lead to two types of compatibility issues. Firstly, the method no longer sets the `mBuiltInZoomControls` variable or calls `mWebView.updateMultiTouchSupport(mContext)`. This means that any code that relies on these actions being performed when `setBuiltInZoomControls` is called will no longer work as expected. Secondly, the method now throws a `MustOverrideException`. This means that any code that calls `setBuiltInZoomControls` without catching this exception will crash at runtime. Additionally, any code that catches the exception and expects the method to have performed its original functionality will also no longer work as expected."
47,<android.view.MenuInflater.InflatedOnMenuItemClickListener: boolean onMenuItemClick(MenuItem)>,15,16,<android.view.MenuInflater.InflatedOnMenuItemClickListener: boolean onMenuItemClick(MenuItem)>,<android.view.MenuInflater.InflatedOnMenuItemClickListener: boolean onMenuItemClick(MenuItem)>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), AssignmentExpression(=, [VariableReference(if (mMethod.getReturnType(), []), Expression(, [])]), MethodCall(return (Boolean) mMethod.invoke(mContext, item), [VariableReference(return (Boolean) mMethod, []), Expression(mContext, []), Expression(item, [])]), Statement(} else {, []), MethodCall(mMethod.invoke(mContext, item), [VariableReference(mMethod, []), Expression(mContext, []), Expression(item, [])]), Statement(return true, []), Statement(}, []), Statement(} catch (Exception e) {, []), Statement(throw new RuntimeException(e), []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(if (mMethod.getReturnType(), []), Expression(, [])])    VariableReference(if (mMethod.getReturnType(), [])    Expression(, [])  MethodCall(return (Boolean) mMethod.invoke(mContext, item), [VariableReference(return (Boolean) mMethod, []), Expression(mContext, []), Expression(item, [])])    VariableReference(return (Boolean) mMethod, [])    Expression(mContext, [])    Expression(item, [])  Statement(} else {, [])  MethodCall(mMethod.invoke(mContext, item), [VariableReference(mMethod, []), Expression(mContext, []), Expression(item, [])])    VariableReference(mMethod, [])    Expression(mContext, [])    Expression(item, [])  Statement(return true, [])  Statement(}, [])  Statement(} catch (Exception e) {, [])  Statement(throw new RuntimeException(e), [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), AssignmentExpression(=, [VariableReference(if (mMethod.getReturnType(), []), Expression(, [])]), MethodCall(return (Boolean) mMethod.invoke(mRealOwner, item), [VariableReference(return (Boolean) mMethod, []), Expression(mRealOwner, []), Expression(item, [])]), Statement(} else {, []), MethodCall(mMethod.invoke(mRealOwner, item), [VariableReference(mMethod, []), Expression(mRealOwner, []), Expression(item, [])]), Statement(return true, []), Statement(}, []), Statement(} catch (Exception e) {, []), Statement(throw new RuntimeException(e), []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(if (mMethod.getReturnType(), []), Expression(, [])])    VariableReference(if (mMethod.getReturnType(), [])    Expression(, [])  MethodCall(return (Boolean) mMethod.invoke(mRealOwner, item), [VariableReference(return (Boolean) mMethod, []), Expression(mRealOwner, []), Expression(item, [])])    VariableReference(return (Boolean) mMethod, [])    Expression(mRealOwner, [])    Expression(item, [])  Statement(} else {, [])  MethodCall(mMethod.invoke(mRealOwner, item), [VariableReference(mMethod, []), Expression(mRealOwner, []), Expression(item, [])])    VariableReference(mMethod, [])    Expression(mRealOwner, [])    Expression(item, [])  Statement(return true, [])  Statement(}, [])  Statement(} catch (Exception e) {, [])  Statement(throw new RuntimeException(e), [])  Statement(}, [])  Statement(}, [])",1,,,0,,,0,0,0,0,"1,2","1,5",1,5,1,"In the early version, the method `mMethod.invoke(mContext, item)` is used, while in the late version, the method `mMethod.invoke(mRealOwner, item)` is used. This is a dependent API change (class 5) as the method name and the parameter have been changed.","The change in the dependent API could potentially lead to a different return value or type, as the method `mMethod.invoke(mRealOwner, item)` might not behave in the same way as `mMethod.invoke(mContext, item)`. Therefore, this is a compatibility issue caused by potential different return values or types (class 1)."
49,"<android.content.ContentProviderClient: int update(Uri,ContentValues,String,String[])>",15,16,"<android.content.ContentProviderClient: int update(Uri,ContentValues,String,String[])>","<android.content.ContentProviderClient: int update(Uri,ContentValues,String,String[])>",0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(return mContentProvider.update(url, values, selection, selectionArgs), [VariableReference(return mContentProvider, []), Expression(url, []), Expression(values, []), Expression(selection, []), Expression(selectionArgs, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return mContentProvider.update(url, values, selection, selectionArgs), [VariableReference(return mContentProvider, []), Expression(url, []), Expression(values, []), Expression(selection, []), Expression(selectionArgs, [])])    VariableReference(return mContentProvider, [])    Expression(url, [])    Expression(values, [])    Expression(selection, [])    Expression(selectionArgs, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(return mContentProvider.update(url, values, selection, selectionArgs), [VariableReference(return mContentProvider, []), Expression(url, []), Expression(values, []), Expression(selection, []), Expression(selectionArgs, [])]), Statement(} catch (DeadObjectException e) {, []), Statement(if (!mStable) {, []), MethodCall(mContentResolver.unstableProviderDied(mContentProvider), [VariableReference(mContentResolver, []), Expression(mContentProvider, [])]), Statement(}, []), Statement(throw e, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(return mContentProvider.update(url, values, selection, selectionArgs), [VariableReference(return mContentProvider, []), Expression(url, []), Expression(values, []), Expression(selection, []), Expression(selectionArgs, [])])    VariableReference(return mContentProvider, [])    Expression(url, [])    Expression(values, [])    Expression(selection, [])    Expression(selectionArgs, [])  Statement(} catch (DeadObjectException e) {, [])  Statement(if (!mStable) {, [])  MethodCall(mContentResolver.unstableProviderDied(mContentProvider), [VariableReference(mContentResolver, []), Expression(mContentProvider, [])])    VariableReference(mContentResolver, [])    Expression(mContentProvider, [])  Statement(}, [])  Statement(throw e, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * See {@link ContentProvider#update ContentProvider.update}
 */
","/**
 * See {@link ContentProvider#update ContentProvider.update}
 */
",0,,,0,0,0,0,1,"1,2,3,4","1,2","2,5",2,"A try-catch block is added, and inside the catch block, there is a new if-statement and a method call. Also, the return statement is now inside the try block. These changes are classified as 2 (Exception handling statement changed) and 5 (Dependent API changed).","The added try-catch block may change the exception handling behavior of the API. When a DeadObjectException is thrown, the API will now execute the code inside the catch block, which includes a new if-statement and a method call. This may potentially lead to different behaviors compared to the early version, where the exception is not handled. Therefore, this is classified as a Compatibility Issue caused by potential different exception handlings (2)."
52,<android.widget.TextView: void onStartTemporaryDetach()>,15,16,<android.widget.TextView: void onStartTemporaryDetach()>,<android.widget.TextView: void onStartTemporaryDetach()>,0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(super.onStartTemporaryDetach(), [VariableReference(super, []), Expression(, [])]), Statement(// usually because this instance is an editable field in a list, []), Statement(if (!mDispatchTemporaryDetach), []), AssignmentExpression(=, [VariableReference(mTemporaryDetach, []), Expression(true, [])]), Statement(// Because of View recycling in ListView, there is no easy way to know when a TextView with, []), Statement(// selection becomes visible again. Until a better solution is found, stop text selection, []), Statement(hideControllers(), []), Statement(}, [])])  Statement({, [])  MethodCall(super.onStartTemporaryDetach(), [VariableReference(super, []), Expression(, [])])    VariableReference(super, [])    Expression(, [])  Statement(// usually because this instance is an editable field in a list, [])  Statement(if (!mDispatchTemporaryDetach), [])  AssignmentExpression(=, [VariableReference(mTemporaryDetach, []), Expression(true, [])])    VariableReference(mTemporaryDetach, [])    Expression(true, [])  Statement(// Because of View recycling in ListView, there is no easy way to know when a TextView with, [])  Statement(// selection becomes visible again. Until a better solution is found, stop text selection, [])  Statement(hideControllers(), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(super.onStartTemporaryDetach(), [VariableReference(super, []), Expression(, [])]), Statement(// usually because this instance is an editable field in a list, []), Statement(if (!mDispatchTemporaryDetach), []), AssignmentExpression(=, [VariableReference(mTemporaryDetach, []), Expression(true, [])]), Statement(// selection state as needed., []), AssignmentExpression(=, [VariableReference(if (mEditor !, []), Expression(null), [])]), AssignmentExpression(=, [VariableReference(mEditor.mTemporaryDetach, []), Expression(true, [])]), Statement(}, [])])  Statement({, [])  MethodCall(super.onStartTemporaryDetach(), [VariableReference(super, []), Expression(, [])])    VariableReference(super, [])    Expression(, [])  Statement(// usually because this instance is an editable field in a list, [])  Statement(if (!mDispatchTemporaryDetach), [])  AssignmentExpression(=, [VariableReference(mTemporaryDetach, []), Expression(true, [])])    VariableReference(mTemporaryDetach, [])    Expression(true, [])  Statement(// selection state as needed., [])  AssignmentExpression(=, [VariableReference(if (mEditor !, []), Expression(null), [])])    VariableReference(if (mEditor !, [])    Expression(null), [])  AssignmentExpression(=, [VariableReference(mEditor.mTemporaryDetach, []), Expression(true, [])])    VariableReference(mEditor.mTemporaryDetach, [])    Expression(true, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,0,0,0,1,"3,4",0,"3,5","1,2","The code change between the two versions involves both control dependency change and other statement change. In the late version, an additional if-statement is introduced, which checks whether the ""mEditor"" object is not null before assigning ""true"" to the ""mTemporaryDetach"" variable. This is a control dependency change. Additionally, the assignment statement ""if (mEditor != null) mEditor.mTemporaryDetach = true"" is introduced, which is an other statement change.","The Compatibility Issue arises from the code change since it can potentially lead to different behaviors between the two versions. Specifically, the control dependency change can cause the ""mTemporaryDetach"" variable to have different values if the ""mEditor"" object is null in the late version. This can be regarded as a Compatibility Issue caused by potential different return values or types (1). Moreover, the introduction of the new assignment statement in the late version can potentially cause a NullPointerException if the ""mEditor"" object is null. This can be regarded as a Compatibility Issue caused by potential different exception handlings (2)."
53,<android.widget.NumberPicker: void setEnabled(boolean)>,15,16,<android.widget.NumberPicker: void setEnabled(boolean)>,<android.widget.NumberPicker: void setEnabled(boolean)>,0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(super.setEnabled(enabled), [VariableReference(super, []), Expression(enabled, [])]), MethodCall(mIncrementButton.setEnabled(enabled), [VariableReference(mIncrementButton, []), Expression(enabled, [])]), MethodCall(mDecrementButton.setEnabled(enabled), [VariableReference(mDecrementButton, []), Expression(enabled, [])]), MethodCall(mInputText.setEnabled(enabled), [VariableReference(mInputText, []), Expression(enabled, [])]), Statement(}, [])])  Statement({, [])  MethodCall(super.setEnabled(enabled), [VariableReference(super, []), Expression(enabled, [])])    VariableReference(super, [])    Expression(enabled, [])  MethodCall(mIncrementButton.setEnabled(enabled), [VariableReference(mIncrementButton, []), Expression(enabled, [])])    VariableReference(mIncrementButton, [])    Expression(enabled, [])  MethodCall(mDecrementButton.setEnabled(enabled), [VariableReference(mDecrementButton, []), Expression(enabled, [])])    VariableReference(mDecrementButton, [])    Expression(enabled, [])  MethodCall(mInputText.setEnabled(enabled), [VariableReference(mInputText, []), Expression(enabled, [])])    VariableReference(mInputText, [])    Expression(enabled, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(super.setEnabled(enabled), [VariableReference(super, []), Expression(enabled, [])]), Statement(if (!mHasSelectorWheel) {, []), MethodCall(mIncrementButton.setEnabled(enabled), [VariableReference(mIncrementButton, []), Expression(enabled, [])]), Statement(}, []), Statement(if (!mHasSelectorWheel) {, []), MethodCall(mDecrementButton.setEnabled(enabled), [VariableReference(mDecrementButton, []), Expression(enabled, [])]), Statement(}, []), MethodCall(mInputText.setEnabled(enabled), [VariableReference(mInputText, []), Expression(enabled, [])]), Statement(}, [])])  Statement({, [])  MethodCall(super.setEnabled(enabled), [VariableReference(super, []), Expression(enabled, [])])    VariableReference(super, [])    Expression(enabled, [])  Statement(if (!mHasSelectorWheel) {, [])  MethodCall(mIncrementButton.setEnabled(enabled), [VariableReference(mIncrementButton, []), Expression(enabled, [])])    VariableReference(mIncrementButton, [])    Expression(enabled, [])  Statement(}, [])  Statement(if (!mHasSelectorWheel) {, [])  MethodCall(mDecrementButton.setEnabled(enabled), [VariableReference(mDecrementButton, []), Expression(enabled, [])])    VariableReference(mDecrementButton, [])    Expression(enabled, [])  Statement(}, [])  MethodCall(mInputText.setEnabled(enabled), [VariableReference(mInputText, []), Expression(enabled, [])])    VariableReference(mInputText, [])    Expression(enabled, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,0,0,0,1,"3,4",0,3,1,"In the late version, two 'if' statements are added before the method calls for 'mIncrementButton.setEnabled(enabled)' and 'mDecrementButton.setEnabled(enabled)'. The condition for the 'if' statements is '!mHasSelectorWheel'. This means that in the late version, if 'mHasSelectorWheel' is true, these two method calls will not be executed, while in the early version, they will be executed regardless of the value of 'mHasSelectorWheel'.","The change in the code can lead to a compatibility issue of type 1. In the late version, if 'mHasSelectorWheel' is true, the enabled state of 'mIncrementButton' and 'mDecrementButton' will not be updated, while in the early version, they will be updated. This can lead to a different behavior in the application, especially if the application relies on the enabled state of these two buttons."
56,<android.webkit.WebView: void onResume()>,15,16,<android.webkit.WebView: void onResume()>,<android.webkit.WebView: void onResume()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(checkThread(), []), Statement(if (mIsPaused) {, []), AssignmentExpression(=, [VariableReference(mIsPaused, []), Expression(false, [])]), MethodCall(mWebViewCore.sendMessage(EventHub.ON_RESUME), [VariableReference(mWebViewCore, []), Expression(EventHub.ON_RESUME, [])]), AssignmentExpression(=, [VariableReference(if (mNativeClass !, []), Expression(0) {, [])]), Statement(nativeSetPauseDrawing(mNativeClass, false), []), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(checkThread(), [])  Statement(if (mIsPaused) {, [])  AssignmentExpression(=, [VariableReference(mIsPaused, []), Expression(false, [])])    VariableReference(mIsPaused, [])    Expression(false, [])  MethodCall(mWebViewCore.sendMessage(EventHub.ON_RESUME), [VariableReference(mWebViewCore, []), Expression(EventHub.ON_RESUME, [])])    VariableReference(mWebViewCore, [])    Expression(EventHub.ON_RESUME, [])  AssignmentExpression(=, [VariableReference(if (mNativeClass !, []), Expression(0) {, [])])    VariableReference(if (mNativeClass !, [])    Expression(0) {, [])  Statement(nativeSetPauseDrawing(mNativeClass, false), [])  Statement(}, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(checkThread(), []), MethodCall(mProvider.onResume(), [VariableReference(mProvider, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  Statement(checkThread(), [])  MethodCall(mProvider.onResume(), [VariableReference(mProvider, []), Expression(, [])])    VariableReference(mProvider, [])    Expression(, [])  Statement(}, [])",1,"/**
 * Call this to resume a WebView after a previous call to onPause().
 */
","/**
 * Resumes a WebView after a previous call to onPause().
 */
",1,,,0,0,0,0,1,3,0,5,1,"The implementation of the onResume() method has undergone a significant change, with the entire method body being replaced in the late version. The original implementation involved checking the thread, setting the mIsPaused variable to false, and sending a message to the WebViewCore. In contrast, the late version directly calls the onResume() method of the mProvider object.","The different implementation of the onResume() method in the two versions could potentially lead to a Compatibility Issue with respect to the return value (although in this particular case, the return type is void, so it may not have a direct impact). The late version relies on the behavior of the mProvider's onResume() method, which may not be the same as the original implementation, and this could affect the overall functioning of the application."
57,"<android.view.ViewGroup: void dispatchAttachedToWindow(AttachInfo,int)>",15,16,"<android.view.ViewGroup: void dispatchAttachedToWindow(AttachInfo,int)>","<android.view.ViewGroup: void dispatchAttachedToWindow(AttachInfo,int)>",0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(mGroupFlags |, []), Expression(FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW, [])]), MethodCall(super.dispatchAttachedToWindow(info, visibility), [VariableReference(super, []), Expression(info, []), Expression(visibility, [])]), AssignmentExpression(=, [VariableReference(mGroupFlags &, []), Expression(~FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW, [])]), AssignmentExpression(=, [VariableReference(visibility |, []), Expression(mViewFlags & VISIBILITY_MASK, [])]), AssignmentExpression(=, [VariableReference(final int count, []), Expression(mChildrenCount, [])]), AssignmentExpression(=, [VariableReference(final View[] children, []), Expression(mChildren, [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < count, []), Statement(i++) {, []), MethodCall(children[i].dispatchAttachedToWindow(info, visibility), [VariableReference(children[i], []), Expression(info, []), Expression(visibility, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(mGroupFlags |, []), Expression(FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW, [])])    VariableReference(mGroupFlags |, [])    Expression(FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW, [])  MethodCall(super.dispatchAttachedToWindow(info, visibility), [VariableReference(super, []), Expression(info, []), Expression(visibility, [])])    VariableReference(super, [])    Expression(info, [])    Expression(visibility, [])  AssignmentExpression(=, [VariableReference(mGroupFlags &, []), Expression(~FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW, [])])    VariableReference(mGroupFlags &, [])    Expression(~FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW, [])  AssignmentExpression(=, [VariableReference(visibility |, []), Expression(mViewFlags & VISIBILITY_MASK, [])])    VariableReference(visibility |, [])    Expression(mViewFlags & VISIBILITY_MASK, [])  AssignmentExpression(=, [VariableReference(final int count, []), Expression(mChildrenCount, [])])    VariableReference(final int count, [])    Expression(mChildrenCount, [])  AssignmentExpression(=, [VariableReference(final View[] children, []), Expression(mChildren, [])])    VariableReference(final View[] children, [])    Expression(mChildren, [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < count, [])  Statement(i++) {, [])  MethodCall(children[i].dispatchAttachedToWindow(info, visibility), [VariableReference(children[i], []), Expression(info, []), Expression(visibility, [])])    VariableReference(children[i], [])    Expression(info, [])    Expression(visibility, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(mGroupFlags |, []), Expression(FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW, [])]), MethodCall(super.dispatchAttachedToWindow(info, visibility), [VariableReference(super, []), Expression(info, []), Expression(visibility, [])]), AssignmentExpression(=, [VariableReference(mGroupFlags &, []), Expression(~FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW, [])]), AssignmentExpression(=, [VariableReference(final int count, []), Expression(mChildrenCount, [])]), AssignmentExpression(=, [VariableReference(final View[] children, []), Expression(mChildren, [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < count, []), Statement(i++) {, []), AssignmentExpression(=, [VariableReference(final View child, []), Expression(children[i], [])]), MethodCall(child.dispatchAttachedToWindow(info, visibility | (child.mViewFlags & VISIBILITY_MASK)), [VariableReference(child, []), Expression(info, []), Expression(visibility | (child.mViewFlags & VISIBILITY_MASK), [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(mGroupFlags |, []), Expression(FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW, [])])    VariableReference(mGroupFlags |, [])    Expression(FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW, [])  MethodCall(super.dispatchAttachedToWindow(info, visibility), [VariableReference(super, []), Expression(info, []), Expression(visibility, [])])    VariableReference(super, [])    Expression(info, [])    Expression(visibility, [])  AssignmentExpression(=, [VariableReference(mGroupFlags &, []), Expression(~FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW, [])])    VariableReference(mGroupFlags &, [])    Expression(~FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW, [])  AssignmentExpression(=, [VariableReference(final int count, []), Expression(mChildrenCount, [])])    VariableReference(final int count, [])    Expression(mChildrenCount, [])  AssignmentExpression(=, [VariableReference(final View[] children, []), Expression(mChildren, [])])    VariableReference(final View[] children, [])    Expression(mChildren, [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < count, [])  Statement(i++) {, [])  AssignmentExpression(=, [VariableReference(final View child, []), Expression(children[i], [])])    VariableReference(final View child, [])    Expression(children[i], [])  MethodCall(child.dispatchAttachedToWindow(info, visibility | (child.mViewFlags & VISIBILITY_MASK)), [VariableReference(child, []), Expression(info, []), Expression(visibility | (child.mViewFlags & VISIBILITY_MASK), [])])    VariableReference(child, [])    Expression(info, [])    Expression(visibility | (child.mViewFlags & VISIBILITY_MASK), [])  Statement(}, [])  Statement(}, [])",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",0,[@Override],[@Override],0,0,0,0,1,"3,4",0,"3,4",1,"The code change includes control dependency change and other statement change. In the late version, a new variable `final View child` is introduced and the method call `children[i].dispatchAttachedToWindow(info, visibility)` is replaced with `child.dispatchAttachedToWindow(info, visibility | (child.mViewFlags & VISIBILITY_MASK))`. The new method call uses the bitwise OR operator `|` to combine `visibility` and `(child.mViewFlags & VISIBILITY_MASK)`, which may result in a different value being passed to the `dispatchAttachedToWindow` method.","The Compatibility Issue is caused by the potential different return values or types. In the late version, the value of `visibility` passed to the `dispatchAttachedToWindow` method may be different from that in the early version, which may lead to different behaviors in the application."
58,<android.webkit.WebSettings: void setJavaScriptCanOpenWindowsAutomatically(boolean)>,15,16,<android.webkit.WebSettings: void setJavaScriptCanOpenWindowsAutomatically(boolean)>,<android.webkit.WebSettings: void setJavaScriptCanOpenWindowsAutomatically(boolean)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mJavaScriptCanOpenWindowsAutomatically !, []), Expression(flag) {, [])]), AssignmentExpression(=, [VariableReference(mJavaScriptCanOpenWindowsAutomatically, []), Expression(flag, [])]), Statement(postSync(), []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mJavaScriptCanOpenWindowsAutomatically !, []), Expression(flag) {, [])])    VariableReference(if (mJavaScriptCanOpenWindowsAutomatically !, [])    Expression(flag) {, [])  AssignmentExpression(=, [VariableReference(mJavaScriptCanOpenWindowsAutomatically, []), Expression(flag, [])])    VariableReference(mJavaScriptCanOpenWindowsAutomatically, [])    Expression(flag, [])  Statement(postSync(), [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(throw new MustOverrideException(), []), Statement(}, [])])  Statement({, [])  Statement(throw new MustOverrideException(), [])  Statement(}, [])",1,"/**
 * Tell javascript to open windows automatically. This applies to the
 * javascript function window.open().
 * @param flag True if javascript can open windows automatically.
 */
","/**
 * Tells JavaScript to open windows automatically. This applies to the
 * JavaScript function window.open(). The default is false.
 *
 * @param flag true if JavaScript can open windows automatically
 */
",1,,,0,0,0,0,1,"2,3",2,2,2,"The early implementation of the API has a conditional check on the variable ""mJavaScriptCanOpenWindowsAutomatically"" and assigns it a new value based on the input parameter ""flag"". The late implementation, however, simply throws a ""MustOverrideException"" without any other logic. This means that the behavior of the late implementation is completely different from the early implementation, and it does not even perform the intended functionality of setting the value of ""mJavaScriptCanOpenWindowsAutomatically"".","The change in the implementation of the API can lead to compatibility issues as the late implementation does not perform the intended functionality of the API. If the API is used in a codebase that relies on the behavior of the early implementation, it can cause unexpected errors or incorrect behavior in the late implementation. The compatibility issue in this case is that the late implementation does not return the same value as the early implementation, and it also throws a different exception."
60,<android.database.sqlite.SQLiteStatement: long simpleQueryForLong()>,15,16,<android.database.sqlite.SQLiteStatement: long simpleQueryForLong()>,<android.database.sqlite.SQLiteStatement: long simpleQueryForLong()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), AssignmentExpression(=, [VariableReference(long timeStart, []), Expression(acquireAndLock(READ), [])]), AssignmentExpression(=, [VariableReference(long retValue, []), Expression(native_1x1_long(), [])]), MethodCall(mDatabase.logTimeStat(mSql, timeStart), [VariableReference(mDatabase, []), Expression(mSql, []), Expression(timeStart, [])]), Statement(return retValue, []), Statement(} catch (SQLiteDoneException e) {, []), Statement(} finally {, []), Statement(releaseAndUnlock(), []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(long timeStart, []), Expression(acquireAndLock(READ), [])])    VariableReference(long timeStart, [])    Expression(acquireAndLock(READ), [])  AssignmentExpression(=, [VariableReference(long retValue, []), Expression(native_1x1_long(), [])])    VariableReference(long retValue, [])    Expression(native_1x1_long(), [])  MethodCall(mDatabase.logTimeStat(mSql, timeStart), [VariableReference(mDatabase, []), Expression(mSql, []), Expression(timeStart, [])])    VariableReference(mDatabase, [])    Expression(mSql, [])    Expression(timeStart, [])  Statement(return retValue, [])  Statement(} catch (SQLiteDoneException e) {, [])  Statement(} finally {, [])  Statement(releaseAndUnlock(), [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(acquireReference(), []), Statement(try {, []), MethodCall(return getSession().executeForLong(getSql(), getBindArgs(), getConnectionFlags(), null), [VariableReference(return getSession(), []), Expression(getSql(), []), Expression(getBindArgs(), []), Expression(getConnectionFlags(), []), Expression(null, [])]), Statement(} catch (SQLiteDatabaseCorruptException ex) {, []), Statement(onCorruption(), []), Statement(throw ex, []), Statement(} finally {, []), Statement(releaseReference(), []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(acquireReference(), [])  Statement(try {, [])  MethodCall(return getSession().executeForLong(getSql(), getBindArgs(), getConnectionFlags(), null), [VariableReference(return getSession(), []), Expression(getSql(), []), Expression(getBindArgs(), []), Expression(getConnectionFlags(), []), Expression(null, [])])    VariableReference(return getSession(), [])    Expression(getSql(), [])    Expression(getBindArgs(), [])    Expression(getConnectionFlags(), [])    Expression(null, [])  Statement(} catch (SQLiteDatabaseCorruptException ex) {, [])  Statement(onCorruption(), [])  Statement(throw ex, [])  Statement(} finally {, [])  Statement(releaseReference(), [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Execute a statement that returns a 1 by 1 table with a numeric value.
 * For example, SELECT COUNT(*) FROM table;
 *
 * @return The result of the query.
 *
 * @throws android.database.sqlite.SQLiteDoneException if the query returns zero rows
 */
","/**
 * Execute a statement that returns a 1 by 1 table with a numeric value.
 * For example, SELECT COUNT(*) FROM table;
 *
 * @return The result of the query.
 *
 * @throws android.database.sqlite.SQLiteDoneException if the query returns zero rows
 */
",0,,,0,0,0,0,1,"1,2,4","1,2","1,5","1,2","The implementation of the method has been completely changed. In the early version, the method uses a native method `native_1x1_long()` to execute the SQL statement and returns the result. In the late version, the method uses a non-native method `executeForLong()` of the `SQLiteSession` class to execute the SQL statement and returns the result. Additionally, the exception handling has been changed. In the early version, the method catches `SQLiteDoneException` and does not rethrow it. In the late version, the method catches `SQLiteDatabaseCorruptException` and rethrows it.","The change of the implementation may lead to different behaviors of the method. The non-native method `executeForLong()` may have different performance or compatibility with certain devices or SQL statements, compared with the native method `native_1x1_long()`. Additionally, the change of the exception handling may also lead to different behaviors. In the early version, the method does not throw `SQLiteDoneException` when the query returns zero rows. In the late version, the method may throw `SQLiteDatabaseCorruptException` when the database is corrupted, which is not thrown in the early version."
61,<android.view.InputDevice: int[] getDeviceIds()>,15,16,<android.view.InputDevice: int[] getDeviceIds()>,<android.view.InputDevice: int[] getDeviceIds()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(IWindowManager wm, []), Expression(Display.getWindowManager(), [])]), Statement(try {, []), MethodCall(return wm.getInputDeviceIds(), [VariableReference(return wm, []), Expression(, [])]), Statement(} catch (RemoteException ex) {, []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(IWindowManager wm, []), Expression(Display.getWindowManager(), [])])    VariableReference(IWindowManager wm, [])    Expression(Display.getWindowManager(), [])  Statement(try {, [])  MethodCall(return wm.getInputDeviceIds(), [VariableReference(return wm, []), Expression(, [])])    VariableReference(return wm, [])    Expression(, [])  Statement(} catch (RemoteException ex) {, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(return InputManager.getInstance().getInputDeviceIds(), [VariableReference(return InputManager, []), Expression().getInputDeviceIds(, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return InputManager.getInstance().getInputDeviceIds(), [VariableReference(return InputManager, []), Expression().getInputDeviceIds(, [])])    VariableReference(return InputManager, [])    Expression().getInputDeviceIds(, [])  Statement(}, [])",1,"/**
 * Gets the ids of all input devices in the system.
 * @return The input device ids.
 */
","/**
 * Gets the ids of all input devices in the system.
 * @return The input device ids.
 */
",0,,,0,0,0,0,1,"1,2,4","1,2",5,1,The implementation of the method has changed from using `IWindowManager` to `InputManager.getInstance()` to get the input device ids. The return statement has also changed to use the new implementation.,"The change in implementation could potentially lead to different input device ids being returned, especially if the behavior of `IWindowManager` and `InputManager.getInstance()` differs. Therefore, it is a compatibility issue caused by potential different return values."
63,<android.database.ContentObservable: void notifyChange(boolean)>,15,16,<android.database.ContentObservable: void notifyChange(boolean)>,<android.database.ContentObservable: void notifyChange(boolean)>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(synchronized (mObservers) {, []), Statement(for (ContentObserver observer : mObservers) {, []), MethodCall(observer.onChange(selfChange), [VariableReference(observer, []), Expression(selfChange, [])]), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(synchronized (mObservers) {, [])  Statement(for (ContentObserver observer : mObservers) {, [])  MethodCall(observer.onChange(selfChange), [VariableReference(observer, []), Expression(selfChange, [])])    VariableReference(observer, [])    Expression(selfChange, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(synchronized (mObservers) {, []), Statement(for (ContentObserver observer : mObservers) {, []), MethodCall(observer.onChange(selfChange, null), [VariableReference(observer, []), Expression(selfChange, []), Expression(null, [])]), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(synchronized (mObservers) {, [])  Statement(for (ContentObserver observer : mObservers) {, [])  MethodCall(observer.onChange(selfChange, null), [VariableReference(observer, []), Expression(selfChange, []), Expression(null, [])])    VariableReference(observer, [])    Expression(selfChange, [])    Expression(null, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * invokes onChange on each observer
 * @param selfChange
 */
","/**
 * Invokes {@link ContentObserver#onChange} on each observer.
 *
 * @param selfChange True if this is a self-change notification.
 *
 * @deprecated Use {@link #dispatchChange} instead.
 */
",1,,[@Deprecated],1,0,0,0,2,5,0,1,1,"The method `observer.onChange` in the early version takes one argument `selfChange`, while in the late version it takes two arguments `selfChange` and `null`. This change in the method call may lead to different behaviors in the two versions.","The change in the method call may cause the `ContentObserver` objects in the late version to receive a different form of the `onChange` callback, which may be incompatible with their implementations. This can result in unexpected behaviors or crashes in the applications that rely on these `ContentObserver` objects."
64,<android.webkit.WebSettings: int getTextZoom()>,15,16,<android.webkit.WebSettings: int getTextZoom()>,<android.webkit.WebSettings: int getTextZoom()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(return mTextSize, []), Statement(}, [])])  Statement({, [])  Statement(return mTextSize, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(throw new MustOverrideException(), []), Statement(}, [])])  Statement({, [])  Statement(throw new MustOverrideException(), [])  Statement(}, [])",1,"/**
 * Get the text zoom of the page in percent.
 * @return A percent value describing the text zoom.
 * @see setTextSizeZoom
 */
","/**
 * Gets the text zoom of the page in percent.
 *
 * @return a percent value describing the text zoom
 * @see #setTextSizeZoom
 */
",1,,,0,0,0,0,1,"1,2","1,2",2,2,"The implementation of the method `getTextZoom()` has been changed from returning the value of `mTextSize` to throwing a `MustOverrideException`. This means that in the late version, the method is no longer supposed to be called directly and should be overridden in a subclass.","The change in the implementation of `getTextZoom()` from returning a value to throwing an exception means that any code that calls this method directly in the early version will no longer behave as expected in the late version. This can lead to crashes or other unexpected behavior, and is therefore a compatibility issue."
65,<android.webkit.WebView: void freeMemory()>,15,16,<android.webkit.WebView: void freeMemory()>,<android.webkit.WebView: void freeMemory()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(checkThread(), []), MethodCall(mWebViewCore.sendMessage(EventHub.FREE_MEMORY), [VariableReference(mWebViewCore, []), Expression(EventHub.FREE_MEMORY, [])]), Statement(}, [])])  Statement({, [])  Statement(checkThread(), [])  MethodCall(mWebViewCore.sendMessage(EventHub.FREE_MEMORY), [VariableReference(mWebViewCore, []), Expression(EventHub.FREE_MEMORY, [])])    VariableReference(mWebViewCore, [])    Expression(EventHub.FREE_MEMORY, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(checkThread(), []), MethodCall(mProvider.freeMemory(), [VariableReference(mProvider, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  Statement(checkThread(), [])  MethodCall(mProvider.freeMemory(), [VariableReference(mProvider, []), Expression(, [])])    VariableReference(mProvider, [])    Expression(, [])  Statement(}, [])",1,"/**
 * Call this to inform the view that memory is low so that it can
 * free any available memory.
 */
","/**
 * Informs this WebView that memory is low so that it can free any available
 * memory.
 */
",1,,,0,0,0,0,1,4,0,5,1,The method call to free memory has changed from `mWebViewCore.sendMessage(EventHub.FREE_MEMORY)` in the early version to `mProvider.freeMemory()` in the late version. This indicates that the implementation of the `freeMemory()` method in the `WebView` class has been modified to use a different approach for freeing memory.,"The change in the method call for freeing memory could potentially lead to different behavior in how memory is freed, which may impact the performance and stability of the app. Therefore, it is classified as a Compatibility Issue (CI) with type 1, indicating that the change could potentially cause the API to return a different variable (value or type) or behave differently."
67,"<android.database.DatabaseUtils: ParcelFileDescriptor blobFileDescriptorForQuery(SQLiteStatement,String[])>",15,16,"<android.database.DatabaseUtils: ParcelFileDescriptor blobFileDescriptorForQuery(SQLiteStatement,String[])>","<android.database.DatabaseUtils: ParcelFileDescriptor blobFileDescriptorForQuery(SQLiteDatabase,String,String[])>",0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(prog.bindAllArgsAsStrings(selectionArgs), [VariableReference(prog, []), Expression(selectionArgs, [])]), MethodCall(return prog.simpleQueryForBlobFileDescriptor(), [VariableReference(return prog, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  MethodCall(prog.bindAllArgsAsStrings(selectionArgs), [VariableReference(prog, []), Expression(selectionArgs, [])])    VariableReference(prog, [])    Expression(selectionArgs, [])  MethodCall(return prog.simpleQueryForBlobFileDescriptor(), [VariableReference(return prog, []), Expression(, [])])    VariableReference(return prog, [])    Expression(, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(SQLiteStatement prog, []), Expression(db.compileStatement(query), [])]), Statement(try {, []), Statement(return blobFileDescriptorForQuery(prog, selectionArgs), []), Statement(} finally {, []), MethodCall(prog.close(), [VariableReference(prog, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(SQLiteStatement prog, []), Expression(db.compileStatement(query), [])])    VariableReference(SQLiteStatement prog, [])    Expression(db.compileStatement(query), [])  Statement(try {, [])  Statement(return blobFileDescriptorForQuery(prog, selectionArgs), [])  Statement(} finally {, [])  MethodCall(prog.close(), [VariableReference(prog, []), Expression(, [])])    VariableReference(prog, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Utility method to run the pre-compiled query and return the blob value in the
 * first column of the first row.
 *
 * @return A read-only file descriptor for a copy of the blob value.
 */
","/**
 * Utility method to run the query on the db and return the blob value in the
 * first column of the first row.
 *
 * @return A read-only file descriptor for a copy of the blob value.
 */
",0,,,0,0,0,0,1,"1,2,4",1,"1,2,5","1,2",The code change between the two versions involves the following:,2. Exception handling statement changed: The late version introduces a `try-finally` block to ensure that the `SQLiteStatement` object `prog` is closed properly.
68,<android.webkit.WebSettings: void setDefaultFixedFontSize(int)>,15,16,<android.webkit.WebSettings: void setDefaultFixedFontSize(int)>,<android.webkit.WebSettings: void setDefaultFixedFontSize(int)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(size, []), Expression(pin(size), [])]), AssignmentExpression(=, [VariableReference(if (mDefaultFixedFontSize !, []), Expression(size) {, [])]), AssignmentExpression(=, [VariableReference(mDefaultFixedFontSize, []), Expression(size, [])]), Statement(postSync(), []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(size, []), Expression(pin(size), [])])    VariableReference(size, [])    Expression(pin(size), [])  AssignmentExpression(=, [VariableReference(if (mDefaultFixedFontSize !, []), Expression(size) {, [])])    VariableReference(if (mDefaultFixedFontSize !, [])    Expression(size) {, [])  AssignmentExpression(=, [VariableReference(mDefaultFixedFontSize, []), Expression(size, [])])    VariableReference(mDefaultFixedFontSize, [])    Expression(size, [])  Statement(postSync(), [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(throw new MustOverrideException(), []), Statement(}, [])])  Statement({, [])  Statement(throw new MustOverrideException(), [])  Statement(}, [])",1,"/**
 * Set the default fixed font size.
 * @param size A non-negative integer between 1 and 72.
 * Any number outside the specified range will be pinned.
 */
","/**
 * Sets the default fixed font size. The default is 16.
 *
 * @param size a non-negative integer between 1 and 72. Any number outside
 * the specified range will be pinned.
 */
",1,,,0,0,0,0,1,"2,3,4",2,2,2,"The implementation of the method `setDefaultFixedFontSize(int)` has been changed from early version to late version. The early version implementation has a logic to check if the input `size` is within the range of 1 to 72 and then assign it to `mDefaultFixedFontSize` variable. However, in the late version implementation, the method is throwing a `MustOverrideException` exception instead of the previous logic.","The change in the implementation of the method `setDefaultFixedFontSize(int)` from early version to late version can cause a compatibility issue as the method is no longer performing the same functionality as before. The method in the late version is throwing a `MustOverrideException` exception, which can cause unexpected behavior in the applications that were using the previous implementation of the method. The applications that were using the previous implementation of the method will have to override the method in their own classes to avoid the exception."
69,<android.webkit.WebView: void setHorizontalScrollbarOverlay(boolean)>,15,16,<android.webkit.WebView: void setHorizontalScrollbarOverlay(boolean)>,<android.webkit.WebView: void setHorizontalScrollbarOverlay(boolean)>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(checkThread(), []), AssignmentExpression(=, [VariableReference(mOverlayHorizontalScrollbar, []), Expression(overlay, [])]), Statement(}, [])])  Statement({, [])  Statement(checkThread(), [])  AssignmentExpression(=, [VariableReference(mOverlayHorizontalScrollbar, []), Expression(overlay, [])])    VariableReference(mOverlayHorizontalScrollbar, [])    Expression(overlay, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(checkThread(), []), MethodCall(mProvider.setHorizontalScrollbarOverlay(overlay), [VariableReference(mProvider, []), Expression(overlay, [])]), Statement(}, [])])  Statement({, [])  Statement(checkThread(), [])  MethodCall(mProvider.setHorizontalScrollbarOverlay(overlay), [VariableReference(mProvider, []), Expression(overlay, [])])    VariableReference(mProvider, [])    Expression(overlay, [])  Statement(}, [])",1,"/**
 * Specify whether the horizontal scrollbar has overlay style.
 * @param overlay TRUE if horizontal scrollbar should have overlay style.
 */
","/**
 * Specifies whether the horizontal scrollbar has overlay style.
 *
 * @param overlay true if horizontal scrollbar should have overlay style
 */
",0,,,0,0,0,0,1,4,0,5,1,The AssignmentExpression for the variable mOverlayHorizontalScrollbar in the early version has been replaced with a MethodCall on mProvider in the late version. This change affects how the horizontal scrollbar overlay is set and could potentially lead to different behavior.,"The Compatibility Issue is caused by the potential for different return values or types. In the early version, the value of mOverlayHorizontalScrollbar is directly set, while in the late version, the value is set indirectly through a method call on mProvider. This change could result in the horizontal scrollbar overlay being set differently in the two versions, leading to a Compatibility Issue."
70,<android.database.sqlite.SQLiteDatabase: boolean isOpen()>,15,16,<android.database.sqlite.SQLiteDatabase: boolean isOpen()>,<android.database.sqlite.SQLiteDatabase: boolean isOpen()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(return mNativeHandle !, []), Expression(0, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(return mNativeHandle !, []), Expression(0, [])])    VariableReference(return mNativeHandle !, [])    Expression(0, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(synchronized (mLock) {, []), AssignmentExpression(=, [VariableReference(return mConnectionPoolLocked !, []), Expression(null, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(synchronized (mLock) {, [])  AssignmentExpression(=, [VariableReference(return mConnectionPoolLocked !, []), Expression(null, [])])    VariableReference(return mConnectionPoolLocked !, [])    Expression(null, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * @return true if the DB is currently open (has not been closed)
 */
","/**
 * Returns true if the database is currently open.
 *
 * @return True if the database is currently open (has not been closed).
 */
",1,,,0,0,0,0,1,"1,4",1,"3,5",1,"The implementation of the method has been changed significantly, including the addition of a synchronized block and the change of the variable being returned. In the early version, the method returns the value of `mNativeHandle`, while in the late version, the method returns the value of `mConnectionPoolLocked`.","The change in the variable being returned can potentially lead to a compatibility issue, as the behavior of the method has been changed. In the early version, the method checks if the database is open by checking the value of `mNativeHandle`, while in the late version, the method checks the value of `mConnectionPoolLocked`. This means that if an application is written to work with the early version of the method, it may not work correctly with the late version, as the value of `mNativeHandle` and `mConnectionPoolLocked` may not always be the same."
72,"<android.app.FragmentManagerImpl: void attachFragment(Fragment,int,int)>",15,16,"<android.app.FragmentManagerImpl: void attachFragment(Fragment,int,int)>","<android.app.FragmentManagerImpl: void attachFragment(Fragment,int,int)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(if (DEBUG), []), MethodCall(Log.v(TAG, ""attach: "" + fragment), [VariableReference(Log, []), Expression(TAG, []), Expression(""attach: "" + fragment, [])]), AssignmentExpression(=, [VariableReference(fragment.mDetached, []), Expression(false, [])]), MethodCall(mAdded.add(fragment), [VariableReference(mAdded, []), Expression(fragment, [])]), AssignmentExpression(=, [VariableReference(fragment.mAdded, []), Expression(true, [])]), AssignmentExpression(=, [VariableReference(mNeedMenuInvalidate, []), Expression(true, [])]), Statement(}, []), Statement(moveToState(fragment, mCurState, transition, transitionStyle), []), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(if (DEBUG), [])  MethodCall(Log.v(TAG, ""attach: "" + fragment), [VariableReference(Log, []), Expression(TAG, []), Expression(""attach: "" + fragment, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""attach: "" + fragment, [])  AssignmentExpression(=, [VariableReference(fragment.mDetached, []), Expression(false, [])])    VariableReference(fragment.mDetached, [])    Expression(false, [])  MethodCall(mAdded.add(fragment), [VariableReference(mAdded, []), Expression(fragment, [])])    VariableReference(mAdded, [])    Expression(fragment, [])  AssignmentExpression(=, [VariableReference(fragment.mAdded, []), Expression(true, [])])    VariableReference(fragment.mAdded, [])    Expression(true, [])  AssignmentExpression(=, [VariableReference(mNeedMenuInvalidate, []), Expression(true, [])])    VariableReference(mNeedMenuInvalidate, [])    Expression(true, [])  Statement(}, [])  Statement(moveToState(fragment, mCurState, transition, transitionStyle), [])  Statement(}, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (DEBUG), []), MethodCall(Log.v(TAG, ""attach: "" + fragment), [VariableReference(Log, []), Expression(TAG, []), Expression(""attach: "" + fragment, [])]), AssignmentExpression(=, [VariableReference(fragment.mDetached, []), Expression(false, [])]), AssignmentExpression(=, [VariableReference(if (mAdded, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(mAdded, []), Expression(new ArrayList<Fragment>(), [])]), Statement(}, []), MethodCall(mAdded.add(fragment), [VariableReference(mAdded, []), Expression(fragment, [])]), AssignmentExpression(=, [VariableReference(fragment.mAdded, []), Expression(true, [])]), AssignmentExpression(=, [VariableReference(mNeedMenuInvalidate, []), Expression(true, [])]), Statement(}, []), Statement(moveToState(fragment, mCurState, transition, transitionStyle, false), []), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(if (DEBUG), [])  MethodCall(Log.v(TAG, ""attach: "" + fragment), [VariableReference(Log, []), Expression(TAG, []), Expression(""attach: "" + fragment, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""attach: "" + fragment, [])  AssignmentExpression(=, [VariableReference(fragment.mDetached, []), Expression(false, [])])    VariableReference(fragment.mDetached, [])    Expression(false, [])  AssignmentExpression(=, [VariableReference(if (mAdded, []), Expression(, [])])    VariableReference(if (mAdded, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(mAdded, []), Expression(new ArrayList<Fragment>(), [])])    VariableReference(mAdded, [])    Expression(new ArrayList<Fragment>(), [])  Statement(}, [])  MethodCall(mAdded.add(fragment), [VariableReference(mAdded, []), Expression(fragment, [])])    VariableReference(mAdded, [])    Expression(fragment, [])  AssignmentExpression(=, [VariableReference(fragment.mAdded, []), Expression(true, [])])    VariableReference(fragment.mAdded, [])    Expression(true, [])  AssignmentExpression(=, [VariableReference(mNeedMenuInvalidate, []), Expression(true, [])])    VariableReference(mNeedMenuInvalidate, [])    Expression(true, [])  Statement(}, [])  Statement(moveToState(fragment, mCurState, transition, transitionStyle, false), [])  Statement(}, [])  Statement(}, [])  Statement(}, [])",1,,,0,,,0,0,0,0,"1,2","3,4,5",0,"3,5","1,2","The control dependency change involves the if statement for mAdded and the initialization of mAdded. The method signature for moveToState has also changed, which is a dependent API change.",The control dependency change can potentially lead to different behavior when mAdded is null or not null. The different exception handling is due to the potential NullPointerException that can be thrown in the early version but not in the late version. The dependent API change can also lead to different behavior as the additional boolean parameter in the late version can affect the state transition of the fragment.
74,<android.view.View: void getLocationInWindow(int[])>,15,16,<android.view.View: void getLocationInWindow(int[])>,<android.view.View: void getLocationInWindow(int[])>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(// When the view is not attached to a window, this method does not make sense, []), AssignmentExpression(=, [VariableReference(if (mAttachInfo, []), Expression(, [])]), Statement(return, []), AssignmentExpression(=, [VariableReference(if (location, []), Expression(, [])]), Statement(throw new IllegalArgumentException(""location must be an array of two integers""), []), Statement(}, []), AssignmentExpression(=, [VariableReference(float[] position, []), Expression(mAttachInfo.mTmpTransformLocation, [])]), AssignmentExpression(=, [VariableReference(position[0], []), Expression(position[1], [])]), Statement(if (!hasIdentityMatrix()) {, []), MethodCall(getMatrix().mapPoints(position), [VariableReference(getMatrix(), []), Expression(position, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(position[0] +, []), Expression(mLeft, [])]), AssignmentExpression(=, [VariableReference(position[1] +, []), Expression(mTop, [])]), AssignmentExpression(=, [VariableReference(ViewParent viewParent, []), Expression(mParent, [])]), Statement(while (viewParent instanceof View) {, []), AssignmentExpression(=, [VariableReference(final View view, []), Expression((View) viewParent, [])]), AssignmentExpression(=, [VariableReference(position[0] -, []), Expression(view.mScrollX, [])]), AssignmentExpression(=, [VariableReference(position[1] -, []), Expression(view.mScrollY, [])]), MethodCall(if (!view.hasIdentityMatrix()), [VariableReference(if (!view, []), Expression(), [])]), MethodCall(view.getMatrix().mapPoints(position), [VariableReference(view, []), Expression().mapPoints(position, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(position[0] +, []), Expression(view.mLeft, [])]), AssignmentExpression(=, [VariableReference(position[1] +, []), Expression(view.mTop, [])]), AssignmentExpression(=, [VariableReference(viewParent, []), Expression(view.mParent, [])]), Statement(}, []), Statement(if (viewParent instanceof ViewRootImpl) {, []), Statement(// *cough*, []), AssignmentExpression(=, [VariableReference(final ViewRootImpl vr, []), Expression((ViewRootImpl) viewParent, [])]), AssignmentExpression(=, [VariableReference(position[1] -, []), Expression(vr.mCurScrollY, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(location[0], []), Expression((int) (position[0] + 0.5f), [])]), AssignmentExpression(=, [VariableReference(location[1], []), Expression((int) (position[1] + 0.5f), [])]), Statement(}, [])])  Statement({, [])  Statement(// When the view is not attached to a window, this method does not make sense, [])  AssignmentExpression(=, [VariableReference(if (mAttachInfo, []), Expression(, [])])    VariableReference(if (mAttachInfo, [])    Expression(, [])  Statement(return, [])  AssignmentExpression(=, [VariableReference(if (location, []), Expression(, [])])    VariableReference(if (location, [])    Expression(, [])  Statement(throw new IllegalArgumentException(""location must be an array of two integers""), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(float[] position, []), Expression(mAttachInfo.mTmpTransformLocation, [])])    VariableReference(float[] position, [])    Expression(mAttachInfo.mTmpTransformLocation, [])  AssignmentExpression(=, [VariableReference(position[0], []), Expression(position[1], [])])    VariableReference(position[0], [])    Expression(position[1], [])  Statement(if (!hasIdentityMatrix()) {, [])  MethodCall(getMatrix().mapPoints(position), [VariableReference(getMatrix(), []), Expression(position, [])])    VariableReference(getMatrix(), [])    Expression(position, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(position[0] +, []), Expression(mLeft, [])])    VariableReference(position[0] +, [])    Expression(mLeft, [])  AssignmentExpression(=, [VariableReference(position[1] +, []), Expression(mTop, [])])    VariableReference(position[1] +, [])    Expression(mTop, [])  AssignmentExpression(=, [VariableReference(ViewParent viewParent, []), Expression(mParent, [])])    VariableReference(ViewParent viewParent, [])    Expression(mParent, [])  Statement(while (viewParent instanceof View) {, [])  AssignmentExpression(=, [VariableReference(final View view, []), Expression((View) viewParent, [])])    VariableReference(final View view, [])    Expression((View) viewParent, [])  AssignmentExpression(=, [VariableReference(position[0] -, []), Expression(view.mScrollX, [])])    VariableReference(position[0] -, [])    Expression(view.mScrollX, [])  AssignmentExpression(=, [VariableReference(position[1] -, []), Expression(view.mScrollY, [])])    VariableReference(position[1] -, [])    Expression(view.mScrollY, [])  MethodCall(if (!view.hasIdentityMatrix()), [VariableReference(if (!view, []), Expression(), [])])    VariableReference(if (!view, [])    Expression(), [])  MethodCall(view.getMatrix().mapPoints(position), [VariableReference(view, []), Expression().mapPoints(position, [])])    VariableReference(view, [])    Expression().mapPoints(position, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(position[0] +, []), Expression(view.mLeft, [])])    VariableReference(position[0] +, [])    Expression(view.mLeft, [])  AssignmentExpression(=, [VariableReference(position[1] +, []), Expression(view.mTop, [])])    VariableReference(position[1] +, [])    Expression(view.mTop, [])  AssignmentExpression(=, [VariableReference(viewParent, []), Expression(view.mParent, [])])    VariableReference(viewParent, [])    Expression(view.mParent, [])  Statement(}, [])  Statement(if (viewParent instanceof ViewRootImpl) {, [])  Statement(// *cough*, [])  AssignmentExpression(=, [VariableReference(final ViewRootImpl vr, []), Expression((ViewRootImpl) viewParent, [])])    VariableReference(final ViewRootImpl vr, [])    Expression((ViewRootImpl) viewParent, [])  AssignmentExpression(=, [VariableReference(position[1] -, []), Expression(vr.mCurScrollY, [])])    VariableReference(position[1] -, [])    Expression(vr.mCurScrollY, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(location[0], []), Expression((int) (position[0] + 0.5f), [])])    VariableReference(location[0], [])    Expression((int) (position[0] + 0.5f), [])  AssignmentExpression(=, [VariableReference(location[1], []), Expression((int) (position[1] + 0.5f), [])])    VariableReference(location[1], [])    Expression((int) (position[1] + 0.5f), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (location, []), Expression(, [])]), Statement(throw new IllegalArgumentException(""location must be an array of two integers""), []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mAttachInfo, []), Expression(, [])]), Statement(// When the view is not attached to a window, this method does not make sense, []), AssignmentExpression(=, [VariableReference(location[0], []), Expression(location[1], [])]), Statement(return, []), Statement(}, []), AssignmentExpression(=, [VariableReference(float[] position, []), Expression(mAttachInfo.mTmpTransformLocation, [])]), AssignmentExpression(=, [VariableReference(position[0], []), Expression(position[1], [])]), Statement(if (!hasIdentityMatrix()) {, []), MethodCall(getMatrix().mapPoints(position), [VariableReference(getMatrix(), []), Expression(position, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(position[0] +, []), Expression(mLeft, [])]), AssignmentExpression(=, [VariableReference(position[1] +, []), Expression(mTop, [])]), AssignmentExpression(=, [VariableReference(ViewParent viewParent, []), Expression(mParent, [])]), Statement(while (viewParent instanceof View) {, []), AssignmentExpression(=, [VariableReference(final View view, []), Expression((View) viewParent, [])]), AssignmentExpression(=, [VariableReference(position[0] -, []), Expression(view.mScrollX, [])]), AssignmentExpression(=, [VariableReference(position[1] -, []), Expression(view.mScrollY, [])]), MethodCall(if (!view.hasIdentityMatrix()), [VariableReference(if (!view, []), Expression(), [])]), MethodCall(view.getMatrix().mapPoints(position), [VariableReference(view, []), Expression().mapPoints(position, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(position[0] +, []), Expression(view.mLeft, [])]), AssignmentExpression(=, [VariableReference(position[1] +, []), Expression(view.mTop, [])]), AssignmentExpression(=, [VariableReference(viewParent, []), Expression(view.mParent, [])]), Statement(}, []), Statement(if (viewParent instanceof ViewRootImpl) {, []), Statement(// *cough*, []), AssignmentExpression(=, [VariableReference(final ViewRootImpl vr, []), Expression((ViewRootImpl) viewParent, [])]), AssignmentExpression(=, [VariableReference(position[1] -, []), Expression(vr.mCurScrollY, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(location[0], []), Expression((int) (position[0] + 0.5f), [])]), AssignmentExpression(=, [VariableReference(location[1], []), Expression((int) (position[1] + 0.5f), [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (location, []), Expression(, [])])    VariableReference(if (location, [])    Expression(, [])  Statement(throw new IllegalArgumentException(""location must be an array of two integers""), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mAttachInfo, []), Expression(, [])])    VariableReference(if (mAttachInfo, [])    Expression(, [])  Statement(// When the view is not attached to a window, this method does not make sense, [])  AssignmentExpression(=, [VariableReference(location[0], []), Expression(location[1], [])])    VariableReference(location[0], [])    Expression(location[1], [])  Statement(return, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(float[] position, []), Expression(mAttachInfo.mTmpTransformLocation, [])])    VariableReference(float[] position, [])    Expression(mAttachInfo.mTmpTransformLocation, [])  AssignmentExpression(=, [VariableReference(position[0], []), Expression(position[1], [])])    VariableReference(position[0], [])    Expression(position[1], [])  Statement(if (!hasIdentityMatrix()) {, [])  MethodCall(getMatrix().mapPoints(position), [VariableReference(getMatrix(), []), Expression(position, [])])    VariableReference(getMatrix(), [])    Expression(position, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(position[0] +, []), Expression(mLeft, [])])    VariableReference(position[0] +, [])    Expression(mLeft, [])  AssignmentExpression(=, [VariableReference(position[1] +, []), Expression(mTop, [])])    VariableReference(position[1] +, [])    Expression(mTop, [])  AssignmentExpression(=, [VariableReference(ViewParent viewParent, []), Expression(mParent, [])])    VariableReference(ViewParent viewParent, [])    Expression(mParent, [])  Statement(while (viewParent instanceof View) {, [])  AssignmentExpression(=, [VariableReference(final View view, []), Expression((View) viewParent, [])])    VariableReference(final View view, [])    Expression((View) viewParent, [])  AssignmentExpression(=, [VariableReference(position[0] -, []), Expression(view.mScrollX, [])])    VariableReference(position[0] -, [])    Expression(view.mScrollX, [])  AssignmentExpression(=, [VariableReference(position[1] -, []), Expression(view.mScrollY, [])])    VariableReference(position[1] -, [])    Expression(view.mScrollY, [])  MethodCall(if (!view.hasIdentityMatrix()), [VariableReference(if (!view, []), Expression(), [])])    VariableReference(if (!view, [])    Expression(), [])  MethodCall(view.getMatrix().mapPoints(position), [VariableReference(view, []), Expression().mapPoints(position, [])])    VariableReference(view, [])    Expression().mapPoints(position, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(position[0] +, []), Expression(view.mLeft, [])])    VariableReference(position[0] +, [])    Expression(view.mLeft, [])  AssignmentExpression(=, [VariableReference(position[1] +, []), Expression(view.mTop, [])])    VariableReference(position[1] +, [])    Expression(view.mTop, [])  AssignmentExpression(=, [VariableReference(viewParent, []), Expression(view.mParent, [])])    VariableReference(viewParent, [])    Expression(view.mParent, [])  Statement(}, [])  Statement(if (viewParent instanceof ViewRootImpl) {, [])  Statement(// *cough*, [])  AssignmentExpression(=, [VariableReference(final ViewRootImpl vr, []), Expression((ViewRootImpl) viewParent, [])])    VariableReference(final ViewRootImpl vr, [])    Expression((ViewRootImpl) viewParent, [])  AssignmentExpression(=, [VariableReference(position[1] -, []), Expression(vr.mCurScrollY, [])])    VariableReference(position[1] -, [])    Expression(vr.mCurScrollY, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(location[0], []), Expression((int) (position[0] + 0.5f), [])])    VariableReference(location[0], [])    Expression((int) (position[0] + 0.5f), [])  AssignmentExpression(=, [VariableReference(location[1], []), Expression((int) (position[1] + 0.5f), [])])    VariableReference(location[1], [])    Expression((int) (position[1] + 0.5f), [])  Statement(}, [])",1,"/**
 * <p>Computes the coordinates of this view in its window. The argument
 * must be an array of two integers. After the method returns, the array
 * contains the x and y location in that order.</p>
 *
 * @param location an array of two integers in which to hold the coordinates
 */
","/**
 * <p>Computes the coordinates of this view in its window. The argument
 * must be an array of two integers. After the method returns, the array
 * contains the x and y location in that order.</p>
 *
 * @param location an array of two integers in which to hold the coordinates
 */
",0,,,0,0,0,0,1,"1,3",1,1,0,2. Think about how the change (especially the control dependency change) effects the potential behaviours of the API (will the API return a differerent values? or throw a different exception?),"5. The Compatibility Issue situation can belong to multiple classes except 0). If it does, please separate the class numbers by comma."
76,"<android.widget.ExpandableListView: ContextMenuInfo createContextMenuInfo(View,int,long)>",15,16,"<android.widget.ExpandableListView: ContextMenuInfo createContextMenuInfo(View,int,long)>","<android.widget.ExpandableListView: ContextMenuInfo createContextMenuInfo(View,int,long)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(if (isHeaderOrFooterPosition(flatListPosition)) {, []), Statement(// Return normal info for header/footer view context menus, []), Statement(return new AdapterContextMenuInfo(view, flatListPosition, id), []), Statement(}, []), AssignmentExpression(=, [VariableReference(final int adjustedPosition, []), Expression(getFlatPositionForConnector(flatListPosition), [])]), AssignmentExpression(=, [VariableReference(PositionMetadata pm, []), Expression(mConnector.getUnflattenedPos(adjustedPosition), [])]), AssignmentExpression(=, [VariableReference(ExpandableListPosition pos, []), Expression(pm.position, [])]), MethodCall(pm.recycle(), [VariableReference(pm, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(id, []), Expression(getChildOrGroupId(pos), [])]), AssignmentExpression(=, [VariableReference(long packedPosition, []), Expression(pos.getPackedPosition(), [])]), MethodCall(pos.recycle(), [VariableReference(pos, []), Expression(, [])]), Statement(return new ExpandableListContextMenuInfo(view, packedPosition, id), []), Statement(}, [])])  Statement({, [])  Statement(if (isHeaderOrFooterPosition(flatListPosition)) {, [])  Statement(// Return normal info for header/footer view context menus, [])  Statement(return new AdapterContextMenuInfo(view, flatListPosition, id), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(final int adjustedPosition, []), Expression(getFlatPositionForConnector(flatListPosition), [])])    VariableReference(final int adjustedPosition, [])    Expression(getFlatPositionForConnector(flatListPosition), [])  AssignmentExpression(=, [VariableReference(PositionMetadata pm, []), Expression(mConnector.getUnflattenedPos(adjustedPosition), [])])    VariableReference(PositionMetadata pm, [])    Expression(mConnector.getUnflattenedPos(adjustedPosition), [])  AssignmentExpression(=, [VariableReference(ExpandableListPosition pos, []), Expression(pm.position, [])])    VariableReference(ExpandableListPosition pos, [])    Expression(pm.position, [])  MethodCall(pm.recycle(), [VariableReference(pm, []), Expression(, [])])    VariableReference(pm, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(id, []), Expression(getChildOrGroupId(pos), [])])    VariableReference(id, [])    Expression(getChildOrGroupId(pos), [])  AssignmentExpression(=, [VariableReference(long packedPosition, []), Expression(pos.getPackedPosition(), [])])    VariableReference(long packedPosition, [])    Expression(pos.getPackedPosition(), [])  MethodCall(pos.recycle(), [VariableReference(pos, []), Expression(, [])])    VariableReference(pos, [])    Expression(, [])  Statement(return new ExpandableListContextMenuInfo(view, packedPosition, id), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (isHeaderOrFooterPosition(flatListPosition)) {, []), Statement(// Return normal info for header/footer view context menus, []), Statement(return new AdapterContextMenuInfo(view, flatListPosition, id), []), Statement(}, []), AssignmentExpression(=, [VariableReference(final int adjustedPosition, []), Expression(getFlatPositionForConnector(flatListPosition), [])]), AssignmentExpression(=, [VariableReference(PositionMetadata pm, []), Expression(mConnector.getUnflattenedPos(adjustedPosition), [])]), AssignmentExpression(=, [VariableReference(ExpandableListPosition pos, []), Expression(pm.position, [])]), AssignmentExpression(=, [VariableReference(id, []), Expression(getChildOrGroupId(pos), [])]), AssignmentExpression(=, [VariableReference(long packedPosition, []), Expression(pos.getPackedPosition(), [])]), MethodCall(pm.recycle(), [VariableReference(pm, []), Expression(, [])]), Statement(return new ExpandableListContextMenuInfo(view, packedPosition, id), []), Statement(}, [])])  Statement({, [])  Statement(if (isHeaderOrFooterPosition(flatListPosition)) {, [])  Statement(// Return normal info for header/footer view context menus, [])  Statement(return new AdapterContextMenuInfo(view, flatListPosition, id), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(final int adjustedPosition, []), Expression(getFlatPositionForConnector(flatListPosition), [])])    VariableReference(final int adjustedPosition, [])    Expression(getFlatPositionForConnector(flatListPosition), [])  AssignmentExpression(=, [VariableReference(PositionMetadata pm, []), Expression(mConnector.getUnflattenedPos(adjustedPosition), [])])    VariableReference(PositionMetadata pm, [])    Expression(mConnector.getUnflattenedPos(adjustedPosition), [])  AssignmentExpression(=, [VariableReference(ExpandableListPosition pos, []), Expression(pm.position, [])])    VariableReference(ExpandableListPosition pos, [])    Expression(pm.position, [])  AssignmentExpression(=, [VariableReference(id, []), Expression(getChildOrGroupId(pos), [])])    VariableReference(id, [])    Expression(getChildOrGroupId(pos), [])  AssignmentExpression(=, [VariableReference(long packedPosition, []), Expression(pos.getPackedPosition(), [])])    VariableReference(long packedPosition, [])    Expression(pos.getPackedPosition(), [])  MethodCall(pm.recycle(), [VariableReference(pm, []), Expression(, [])])    VariableReference(pm, [])    Expression(, [])  Statement(return new ExpandableListContextMenuInfo(view, packedPosition, id), [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,0,0,0,1,4,0,0,0,"There is no difference between the early and the late version of the implementation of the method `createContextMenuInfo(View,int,long)` in `android.widget.ExpandableListView`.","As there is no code change, it does not cause any Compatibility Issue."
78,<android.animation.KeyframeSet: KeyframeSet ofFloat(float)>,17,18,<android.animation.KeyframeSet: KeyframeSet ofFloat(float)>,<android.animation.KeyframeSet: KeyframeSet ofFloat(float)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(int numKeyframes, []), Expression(values.length, [])]), AssignmentExpression(=, [VariableReference(FloatKeyframe[] keyframes, []), Expression(new FloatKeyframe[Math.max(numKeyframes, 2)], [])]), AssignmentExpression(=, [VariableReference(if (numKeyframes, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(keyframes[0], []), Expression((FloatKeyframe) Keyframe.ofFloat(0f), [])]), AssignmentExpression(=, [VariableReference(keyframes[1], []), Expression((FloatKeyframe) Keyframe.ofFloat(1f, values[0]), [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(keyframes[0], []), Expression((FloatKeyframe) Keyframe.ofFloat(0f, values[0]), [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(1, [])]), Statement(i < numKeyframes, []), Statement(++i) {, []), AssignmentExpression(=, [VariableReference(keyframes[i], []), Expression((FloatKeyframe) Keyframe.ofFloat((float) i / (numKeyframes - 1), values[i]), [])]), Statement(}, []), Statement(}, []), Statement(return new FloatKeyframeSet(keyframes), []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(int numKeyframes, []), Expression(values.length, [])])    VariableReference(int numKeyframes, [])    Expression(values.length, [])  AssignmentExpression(=, [VariableReference(FloatKeyframe[] keyframes, []), Expression(new FloatKeyframe[Math.max(numKeyframes, 2)], [])])    VariableReference(FloatKeyframe[] keyframes, [])    Expression(new FloatKeyframe[Math.max(numKeyframes, 2)], [])  AssignmentExpression(=, [VariableReference(if (numKeyframes, []), Expression(, [])])    VariableReference(if (numKeyframes, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(keyframes[0], []), Expression((FloatKeyframe) Keyframe.ofFloat(0f), [])])    VariableReference(keyframes[0], [])    Expression((FloatKeyframe) Keyframe.ofFloat(0f), [])  AssignmentExpression(=, [VariableReference(keyframes[1], []), Expression((FloatKeyframe) Keyframe.ofFloat(1f, values[0]), [])])    VariableReference(keyframes[1], [])    Expression((FloatKeyframe) Keyframe.ofFloat(1f, values[0]), [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(keyframes[0], []), Expression((FloatKeyframe) Keyframe.ofFloat(0f, values[0]), [])])    VariableReference(keyframes[0], [])    Expression((FloatKeyframe) Keyframe.ofFloat(0f, values[0]), [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(1, [])])    VariableReference(for (int i, [])    Expression(1, [])  Statement(i < numKeyframes, [])  Statement(++i) {, [])  AssignmentExpression(=, [VariableReference(keyframes[i], []), Expression((FloatKeyframe) Keyframe.ofFloat((float) i / (numKeyframes - 1), values[i]), [])])    VariableReference(keyframes[i], [])    Expression((FloatKeyframe) Keyframe.ofFloat((float) i / (numKeyframes - 1), values[i]), [])  Statement(}, [])  Statement(}, [])  Statement(return new FloatKeyframeSet(keyframes), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(boolean badValue, []), Expression(false, [])]), AssignmentExpression(=, [VariableReference(int numKeyframes, []), Expression(values.length, [])]), AssignmentExpression(=, [VariableReference(FloatKeyframe[] keyframes, []), Expression(new FloatKeyframe[Math.max(numKeyframes, 2)], [])]), AssignmentExpression(=, [VariableReference(if (numKeyframes, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(keyframes[0], []), Expression((FloatKeyframe) Keyframe.ofFloat(0f), [])]), AssignmentExpression(=, [VariableReference(keyframes[1], []), Expression((FloatKeyframe) Keyframe.ofFloat(1f, values[0]), [])]), MethodCall(if (Float.isNaN(values[0])), [VariableReference(if (Float, []), Expression(values[0]), [])]), AssignmentExpression(=, [VariableReference(badValue, []), Expression(true, [])]), Statement(}, []), Statement(} else {, []), AssignmentExpression(=, [VariableReference(keyframes[0], []), Expression((FloatKeyframe) Keyframe.ofFloat(0f, values[0]), [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(1, [])]), Statement(i < numKeyframes, []), Statement(++i) {, []), AssignmentExpression(=, [VariableReference(keyframes[i], []), Expression((FloatKeyframe) Keyframe.ofFloat((float) i / (numKeyframes - 1), values[i]), [])]), MethodCall(if (Float.isNaN(values[i])), [VariableReference(if (Float, []), Expression(values[i]), [])]), AssignmentExpression(=, [VariableReference(badValue, []), Expression(true, [])]), Statement(}, []), Statement(}, []), Statement(}, []), Statement(if (badValue) {, []), MethodCall(Log.w(""Animator"", ""Bad value (NaN) in float animator""), [VariableReference(Log, []), Expression(""Animator"", []), Expression(""Bad value (NaN) in float animator"", [])]), Statement(}, []), Statement(return new FloatKeyframeSet(keyframes), []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(boolean badValue, []), Expression(false, [])])    VariableReference(boolean badValue, [])    Expression(false, [])  AssignmentExpression(=, [VariableReference(int numKeyframes, []), Expression(values.length, [])])    VariableReference(int numKeyframes, [])    Expression(values.length, [])  AssignmentExpression(=, [VariableReference(FloatKeyframe[] keyframes, []), Expression(new FloatKeyframe[Math.max(numKeyframes, 2)], [])])    VariableReference(FloatKeyframe[] keyframes, [])    Expression(new FloatKeyframe[Math.max(numKeyframes, 2)], [])  AssignmentExpression(=, [VariableReference(if (numKeyframes, []), Expression(, [])])    VariableReference(if (numKeyframes, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(keyframes[0], []), Expression((FloatKeyframe) Keyframe.ofFloat(0f), [])])    VariableReference(keyframes[0], [])    Expression((FloatKeyframe) Keyframe.ofFloat(0f), [])  AssignmentExpression(=, [VariableReference(keyframes[1], []), Expression((FloatKeyframe) Keyframe.ofFloat(1f, values[0]), [])])    VariableReference(keyframes[1], [])    Expression((FloatKeyframe) Keyframe.ofFloat(1f, values[0]), [])  MethodCall(if (Float.isNaN(values[0])), [VariableReference(if (Float, []), Expression(values[0]), [])])    VariableReference(if (Float, [])    Expression(values[0]), [])  AssignmentExpression(=, [VariableReference(badValue, []), Expression(true, [])])    VariableReference(badValue, [])    Expression(true, [])  Statement(}, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(keyframes[0], []), Expression((FloatKeyframe) Keyframe.ofFloat(0f, values[0]), [])])    VariableReference(keyframes[0], [])    Expression((FloatKeyframe) Keyframe.ofFloat(0f, values[0]), [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(1, [])])    VariableReference(for (int i, [])    Expression(1, [])  Statement(i < numKeyframes, [])  Statement(++i) {, [])  AssignmentExpression(=, [VariableReference(keyframes[i], []), Expression((FloatKeyframe) Keyframe.ofFloat((float) i / (numKeyframes - 1), values[i]), [])])    VariableReference(keyframes[i], [])    Expression((FloatKeyframe) Keyframe.ofFloat((float) i / (numKeyframes - 1), values[i]), [])  MethodCall(if (Float.isNaN(values[i])), [VariableReference(if (Float, []), Expression(values[i]), [])])    VariableReference(if (Float, [])    Expression(values[i]), [])  AssignmentExpression(=, [VariableReference(badValue, []), Expression(true, [])])    VariableReference(badValue, [])    Expression(true, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(if (badValue) {, [])  MethodCall(Log.w(""Animator"", ""Bad value (NaN) in float animator""), [VariableReference(Log, []), Expression(""Animator"", []), Expression(""Bad value (NaN) in float animator"", [])])    VariableReference(Log, [])    Expression(""Animator"", [])    Expression(""Bad value (NaN) in float animator"", [])  Statement(}, [])  Statement(return new FloatKeyframeSet(keyframes), [])  Statement(}, [])",1,,,0,,,0,0,0,0,1,"3,4",0,"2,4",2,"- In the late version, a boolean variable ""badValue"" is initialized to false.","- An if-statement is added at the end of the method in the late version to check if ""badValue"" is true. If it is, a warning is logged using the ""Log.w"" method."
79,<android.view.ViewGroup.MarginLayoutParams: void resolveLayoutDirection(int)>,17,18,<android.view.ViewGroup.MarginLayoutParams: void resolveLayoutDirection(int)>,<android.view.ViewGroup.MarginLayoutParams: void resolveLayoutDirection(int)>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(setLayoutDirection(layoutDirection), []), Statement(if (!isMarginRelative()), []), Statement(return, []), Statement(switch(layoutDirection) {, []), Statement(case View.LAYOUT_DIRECTION_RTL:, []), AssignmentExpression(=, [VariableReference(leftMargin, []), Expression((endMargin > DEFAULT_RELATIVE) ? endMargin : initialLeftMargin, [])]), AssignmentExpression(=, [VariableReference(rightMargin, []), Expression((startMargin > DEFAULT_RELATIVE) ? startMargin : initialRightMargin, [])]), Statement(break, []), Statement(case View.LAYOUT_DIRECTION_LTR:, []), Statement(default:, []), AssignmentExpression(=, [VariableReference(leftMargin, []), Expression((startMargin > DEFAULT_RELATIVE) ? startMargin : initialLeftMargin, [])]), AssignmentExpression(=, [VariableReference(rightMargin, []), Expression((endMargin > DEFAULT_RELATIVE) ? endMargin : initialRightMargin, [])]), Statement(break, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(setLayoutDirection(layoutDirection), [])  Statement(if (!isMarginRelative()), [])  Statement(return, [])  Statement(switch(layoutDirection) {, [])  Statement(case View.LAYOUT_DIRECTION_RTL:, [])  AssignmentExpression(=, [VariableReference(leftMargin, []), Expression((endMargin > DEFAULT_RELATIVE) ? endMargin : initialLeftMargin, [])])    VariableReference(leftMargin, [])    Expression((endMargin > DEFAULT_RELATIVE) ? endMargin : initialLeftMargin, [])  AssignmentExpression(=, [VariableReference(rightMargin, []), Expression((startMargin > DEFAULT_RELATIVE) ? startMargin : initialRightMargin, [])])    VariableReference(rightMargin, [])    Expression((startMargin > DEFAULT_RELATIVE) ? startMargin : initialRightMargin, [])  Statement(break, [])  Statement(case View.LAYOUT_DIRECTION_LTR:, [])  Statement(default:, [])  AssignmentExpression(=, [VariableReference(leftMargin, []), Expression((startMargin > DEFAULT_RELATIVE) ? startMargin : initialLeftMargin, [])])    VariableReference(leftMargin, [])    Expression((startMargin > DEFAULT_RELATIVE) ? startMargin : initialLeftMargin, [])  AssignmentExpression(=, [VariableReference(rightMargin, []), Expression((endMargin > DEFAULT_RELATIVE) ? endMargin : initialRightMargin, [])])    VariableReference(rightMargin, [])    Expression((endMargin > DEFAULT_RELATIVE) ? endMargin : initialRightMargin, [])  Statement(break, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(setLayoutDirection(layoutDirection), []), Statement(// Will use the left and right margins if no relative margin is defined., []), AssignmentExpression(=, [VariableReference(if (!isMarginRelative() || (mMarginFlags & NEED_RESOLUTION_MASK) !, []), Expression(NEED_RESOLUTION_MASK), [])]), Statement(return, []), Statement(// Proceed with resolution, []), Statement(doResolveMargins(), []), Statement(}, [])])  Statement({, [])  Statement(setLayoutDirection(layoutDirection), [])  Statement(// Will use the left and right margins if no relative margin is defined., [])  AssignmentExpression(=, [VariableReference(if (!isMarginRelative() || (mMarginFlags & NEED_RESOLUTION_MASK) !, []), Expression(NEED_RESOLUTION_MASK), [])])    VariableReference(if (!isMarginRelative() || (mMarginFlags & NEED_RESOLUTION_MASK) !, [])    Expression(NEED_RESOLUTION_MASK), [])  Statement(return, [])  Statement(// Proceed with resolution, [])  Statement(doResolveMargins(), [])  Statement(}, [])",1,"/**
 * This will be called by {@link android.view.View#requestLayout()}. Left and Right margins
 * may be overridden depending on layout direction.
 */
","/**
 * This will be called by {@link android.view.View#requestLayout()}. Left and Right margins
 * may be overridden depending on layout direction.
 */
",0,[@Override],[@Override],0,0,0,0,1,"1,3",1,"4,5",1,"The implementation of the API has changed from using a switch statement to using a method call to resolve the margins. Additionally, the condition for the if statement has been updated to include a check for the NEED\_RESOLUTION\_MASK flag.","The change in the implementation could lead to compatibility issues as the behavior of the API may have changed. The new condition for the if statement could also cause the API to behave differently in certain cases, potentially causing a different return value."
81,"<android.appwidget.AppWidgetHost: AppWidgetHostView createView(Context,int,AppWidgetProviderInfo)>",17,18,"<android.appwidget.AppWidgetHost: AppWidgetHostView createView(Context,int,AppWidgetProviderInfo)>","<android.appwidget.AppWidgetHost: AppWidgetHostView createView(Context,int,AppWidgetProviderInfo)>",0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(AppWidgetHostView view, []), Expression(onCreateView(context, appWidgetId, appWidget), [])]), MethodCall(view.setOnClickHandler(mOnClickHandler), [VariableReference(view, []), Expression(mOnClickHandler, [])]), MethodCall(view.setAppWidget(appWidgetId, appWidget), [VariableReference(view, []), Expression(appWidgetId, []), Expression(appWidget, [])]), Statement(synchronized (mViews) {, []), MethodCall(mViews.put(appWidgetId, view), [VariableReference(mViews, []), Expression(appWidgetId, []), Expression(view, [])]), Statement(}, []), Statement(RemoteViews views, []), Statement(try {, []), AssignmentExpression(=, [VariableReference(views, []), Expression(sService.getAppWidgetViews(appWidgetId), [])]), Statement(} catch (RemoteException e) {, []), Statement(throw new RuntimeException(""system server dead?"", e), []), Statement(}, []), MethodCall(view.updateAppWidget(views), [VariableReference(view, []), Expression(views, [])]), Statement(return view, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(AppWidgetHostView view, []), Expression(onCreateView(context, appWidgetId, appWidget), [])])    VariableReference(AppWidgetHostView view, [])    Expression(onCreateView(context, appWidgetId, appWidget), [])  MethodCall(view.setOnClickHandler(mOnClickHandler), [VariableReference(view, []), Expression(mOnClickHandler, [])])    VariableReference(view, [])    Expression(mOnClickHandler, [])  MethodCall(view.setAppWidget(appWidgetId, appWidget), [VariableReference(view, []), Expression(appWidgetId, []), Expression(appWidget, [])])    VariableReference(view, [])    Expression(appWidgetId, [])    Expression(appWidget, [])  Statement(synchronized (mViews) {, [])  MethodCall(mViews.put(appWidgetId, view), [VariableReference(mViews, []), Expression(appWidgetId, []), Expression(view, [])])    VariableReference(mViews, [])    Expression(appWidgetId, [])    Expression(view, [])  Statement(}, [])  Statement(RemoteViews views, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(views, []), Expression(sService.getAppWidgetViews(appWidgetId), [])])    VariableReference(views, [])    Expression(sService.getAppWidgetViews(appWidgetId), [])  Statement(} catch (RemoteException e) {, [])  Statement(throw new RuntimeException(""system server dead?"", e), [])  Statement(}, [])  MethodCall(view.updateAppWidget(views), [VariableReference(view, []), Expression(views, [])])    VariableReference(view, [])    Expression(views, [])  Statement(return view, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final int userId, []), Expression(mContext.getUserId(), [])]), AssignmentExpression(=, [VariableReference(AppWidgetHostView view, []), Expression(onCreateView(mContext, appWidgetId, appWidget), [])]), MethodCall(view.setUserId(userId), [VariableReference(view, []), Expression(userId, [])]), MethodCall(view.setOnClickHandler(mOnClickHandler), [VariableReference(view, []), Expression(mOnClickHandler, [])]), MethodCall(view.setAppWidget(appWidgetId, appWidget), [VariableReference(view, []), Expression(appWidgetId, []), Expression(appWidget, [])]), Statement(synchronized (mViews) {, []), MethodCall(mViews.put(appWidgetId, view), [VariableReference(mViews, []), Expression(appWidgetId, []), Expression(view, [])]), Statement(}, []), Statement(RemoteViews views, []), Statement(try {, []), AssignmentExpression(=, [VariableReference(views, []), Expression(sService.getAppWidgetViews(appWidgetId, userId), [])]), AssignmentExpression(=, [VariableReference(if (views !, []), Expression(null) {, [])]), MethodCall(views.setUser(new UserHandle(mContext.getUserId())), [VariableReference(views, []), Expression(new UserHandle(mContext.getUserId()), [])]), Statement(}, []), Statement(} catch (RemoteException e) {, []), Statement(throw new RuntimeException(""system server dead?"", e), []), Statement(}, []), MethodCall(view.updateAppWidget(views), [VariableReference(view, []), Expression(views, [])]), Statement(return view, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final int userId, []), Expression(mContext.getUserId(), [])])    VariableReference(final int userId, [])    Expression(mContext.getUserId(), [])  AssignmentExpression(=, [VariableReference(AppWidgetHostView view, []), Expression(onCreateView(mContext, appWidgetId, appWidget), [])])    VariableReference(AppWidgetHostView view, [])    Expression(onCreateView(mContext, appWidgetId, appWidget), [])  MethodCall(view.setUserId(userId), [VariableReference(view, []), Expression(userId, [])])    VariableReference(view, [])    Expression(userId, [])  MethodCall(view.setOnClickHandler(mOnClickHandler), [VariableReference(view, []), Expression(mOnClickHandler, [])])    VariableReference(view, [])    Expression(mOnClickHandler, [])  MethodCall(view.setAppWidget(appWidgetId, appWidget), [VariableReference(view, []), Expression(appWidgetId, []), Expression(appWidget, [])])    VariableReference(view, [])    Expression(appWidgetId, [])    Expression(appWidget, [])  Statement(synchronized (mViews) {, [])  MethodCall(mViews.put(appWidgetId, view), [VariableReference(mViews, []), Expression(appWidgetId, []), Expression(view, [])])    VariableReference(mViews, [])    Expression(appWidgetId, [])    Expression(view, [])  Statement(}, [])  Statement(RemoteViews views, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(views, []), Expression(sService.getAppWidgetViews(appWidgetId, userId), [])])    VariableReference(views, [])    Expression(sService.getAppWidgetViews(appWidgetId, userId), [])  AssignmentExpression(=, [VariableReference(if (views !, []), Expression(null) {, [])])    VariableReference(if (views !, [])    Expression(null) {, [])  MethodCall(views.setUser(new UserHandle(mContext.getUserId())), [VariableReference(views, []), Expression(new UserHandle(mContext.getUserId()), [])])    VariableReference(views, [])    Expression(new UserHandle(mContext.getUserId()), [])  Statement(}, [])  Statement(} catch (RemoteException e) {, [])  Statement(throw new RuntimeException(""system server dead?"", e), [])  Statement(}, [])  MethodCall(view.updateAppWidget(views), [VariableReference(view, []), Expression(views, [])])    VariableReference(view, [])    Expression(views, [])  Statement(return view, [])  Statement(}, [])",1,"/**
 * Create the AppWidgetHostView for the given widget.
 * The AppWidgetHost retains a pointer to the newly-created View.
 */
","/**
 * Create the AppWidgetHostView for the given widget.
 * The AppWidgetHost retains a pointer to the newly-created View.
 */
",0,,,0,0,0,0,1|2,"1,3,4,5",1,"1,2,5","1,2",The changes between the two versions are as follows:,"2. Exception handling statement changed: In the late version, the `catch` block for `RemoteException` is modified to include a new statement `views.setUser(new UserHandle(mContext.getUserId()))` before the `throw` statement. This may cause the `views` object to have a different state when the exception is thrown."
82,<android.view.accessibility.AccessibilityNodeInfo: void setFocused(boolean)>,17,18,<android.view.accessibility.AccessibilityNodeInfo: void setFocused(boolean)>,<android.view.accessibility.AccessibilityNodeInfo: void setFocused(boolean)>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(setBooleanProperty(PROPERTY_FOCUSED, focused), []), Statement(}, [])])  Statement({, [])  Statement(setBooleanProperty(PROPERTY_FOCUSED, focused), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(setBooleanProperty(BOOLEAN_PROPERTY_FOCUSED, focused), []), Statement(}, [])])  Statement({, [])  Statement(setBooleanProperty(BOOLEAN_PROPERTY_FOCUSED, focused), [])  Statement(}, [])",1,"/**
 * Sets whether this node is focused.
 * <p>
 * <strong>Note:</strong> Cannot be called from an
 * {@link android.accessibilityservice.AccessibilityService}.
 * This class is made immutable before being delivered to an AccessibilityService.
 * </p>
 *
 * @param focused True if the node is focused.
 *
 * @throws IllegalStateException If called from an AccessibilityService.
 */
","/**
 * Sets whether this node is focused.
 * <p>
 * <strong>Note:</strong> Cannot be called from an
 * {@link android.accessibilityservice.AccessibilityService}.
 * This class is made immutable before being delivered to an AccessibilityService.
 * </p>
 *
 * @param focused True if the node is focused.
 *
 * @throws IllegalStateException If called from an AccessibilityService.
 */
",0,,,0,0,0,0,2,5,0,5,0,"The implementation of the method has changed in the way that the property ""PROPERTY\_FOCUSED"" in the early version is replaced by ""BOOLEAN\_PROPERTY\_FOCUSED"" in the late version. This change is not about return statement, exception handling statement, control dependency or other statement. It belongs to the class 5: Dependent API changed.","There is no Compatibility Issue existing in the given API. The change in the property name does not affect the behavior of the method, as long as the property ""BOOLEAN\_PROPERTY\_FOCUSED"" in the late version is used and implemented in the same way as ""PROPERTY\_FOCUSED"" in the early version."
83,<android.os.Looper: void quit()>,17,18,<android.os.Looper: void quit()>,<android.os.Looper: void quit()>,0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(mQueue.quit(), [VariableReference(mQueue, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  MethodCall(mQueue.quit(), [VariableReference(mQueue, []), Expression(, [])])    VariableReference(mQueue, [])    Expression(, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(mQueue.quit(false), [VariableReference(mQueue, []), Expression(false, [])]), Statement(}, [])])  Statement({, [])  MethodCall(mQueue.quit(false), [VariableReference(mQueue, []), Expression(false, [])])    VariableReference(mQueue, [])    Expression(false, [])  Statement(}, [])",1,"/**
 * Quits the looper.
 *
 * Causes the {@link #loop} method to terminate as soon as possible.
 */
","/**
 * Quits the looper.
 * <p>
 * Causes the {@link #loop} method to terminate without processing any
 * more messages in the message queue.
 * </p><p>
 * Any attempt to post messages to the queue after the looper is asked to quit will fail.
 * For example, the {@link Handler#sendMessage(Message)} method will return false.
 * </p><p class=""note"">
 * Using this method may be unsafe because some messages may not be delivered
 * before the looper terminates.  Consider using {@link #quitSafely} instead to ensure
 * that all pending work is completed in an orderly manner.
 * </p>
 *
 * @see #quitSafely
 */
",1,,,0,0,0,0,2,5,0,5,1,"The implementation of the method `quit()` in the class `android.os.Looper` has changed between version 17 and 18. The method call `mQueue.quit()` in the early version has been changed to `mQueue.quit(false)` in the late version. This is a change in the dependent API, as the method `quit()` of the `mQueue` object (which is of type `android.os.MessageQueue`) has been changed to include a boolean parameter.","The change in the dependent API could potentially lead to a compatibility issue of type 1, as it might cause the method `quit()` to behave differently in the late version compared to the early version. For example, the boolean parameter might determine whether or not to terminate the looper immediately, or it might affect the processing of messages that are already in the queue. This could result in different return values or types, or it could lead to different exceptions being thrown."
84,<android.os.Parcel: T readParcelable(ClassLoader)>,17,18,<android.os.Parcel: T readParcelable(ClassLoader)>,<android.os.Parcel: T readParcelable(ClassLoader)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(String name, []), Expression(readString(), [])]), AssignmentExpression(=, [VariableReference(if (name, []), Expression(, [])]), Statement(return null, []), Statement(}, []), Statement(Parcelable.Creator<T> creator, []), Statement(synchronized (mCreators) {, []), AssignmentExpression(=, [VariableReference(HashMap<String, Parcelable.Creator> map, []), Expression(mCreators.get(loader), [])]), AssignmentExpression(=, [VariableReference(if (map, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(map, []), Expression(new HashMap<String, Parcelable.Creator>(), [])]), MethodCall(mCreators.put(loader, map), [VariableReference(mCreators, []), Expression(loader, []), Expression(map, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(creator, []), Expression(map.get(name), [])]), AssignmentExpression(=, [VariableReference(if (creator, []), Expression(, [])]), Statement(try {, []), AssignmentExpression(=, [VariableReference(Class c, []), Expression(loader, [])]), AssignmentExpression(=, [VariableReference(Field f, []), Expression(c.getField(""CREATOR""), [])]), AssignmentExpression(=, [VariableReference(creator, []), Expression((Parcelable.Creator) f.get(null), [])]), Statement(} catch (IllegalAccessException e) {, []), MethodCall(Log.e(TAG, ""Class not found when unmarshalling: "" + name + "", e: "" + e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Class not found when unmarshalling: "" + name + "", []), Expression(e: "" + e, [])]), Statement(throw new BadParcelableException(""IllegalAccessException when unmarshalling: "" + name), []), Statement(} catch (ClassNotFoundException e) {, []), MethodCall(Log.e(TAG, ""Class not found when unmarshalling: "" + name + "", e: "" + e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Class not found when unmarshalling: "" + name + "", []), Expression(e: "" + e, [])]), Statement(throw new BadParcelableException(""ClassNotFoundException when unmarshalling: "" + name), []), Statement(} catch (ClassCastException e) {, []), Statement(} catch (NoSuchFieldException e) {, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (creator, []), Expression(, [])]), Statement(}, []), MethodCall(map.put(name, creator), [VariableReference(map, []), Expression(name, []), Expression(creator, [])]), Statement(}, []), Statement(}, []), Statement(}, []), MethodCall(return creator.createFromParcel(this), [VariableReference(return creator, []), Expression(this, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(String name, []), Expression(readString(), [])])    VariableReference(String name, [])    Expression(readString(), [])  AssignmentExpression(=, [VariableReference(if (name, []), Expression(, [])])    VariableReference(if (name, [])    Expression(, [])  Statement(return null, [])  Statement(}, [])  Statement(Parcelable.Creator<T> creator, [])  Statement(synchronized (mCreators) {, [])  AssignmentExpression(=, [VariableReference(HashMap<String, Parcelable.Creator> map, []), Expression(mCreators.get(loader), [])])    VariableReference(HashMap<String, Parcelable.Creator> map, [])    Expression(mCreators.get(loader), [])  AssignmentExpression(=, [VariableReference(if (map, []), Expression(, [])])    VariableReference(if (map, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(map, []), Expression(new HashMap<String, Parcelable.Creator>(), [])])    VariableReference(map, [])    Expression(new HashMap<String, Parcelable.Creator>(), [])  MethodCall(mCreators.put(loader, map), [VariableReference(mCreators, []), Expression(loader, []), Expression(map, [])])    VariableReference(mCreators, [])    Expression(loader, [])    Expression(map, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(creator, []), Expression(map.get(name), [])])    VariableReference(creator, [])    Expression(map.get(name), [])  AssignmentExpression(=, [VariableReference(if (creator, []), Expression(, [])])    VariableReference(if (creator, [])    Expression(, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(Class c, []), Expression(loader, [])])    VariableReference(Class c, [])    Expression(loader, [])  AssignmentExpression(=, [VariableReference(Field f, []), Expression(c.getField(""CREATOR""), [])])    VariableReference(Field f, [])    Expression(c.getField(""CREATOR""), [])  AssignmentExpression(=, [VariableReference(creator, []), Expression((Parcelable.Creator) f.get(null), [])])    VariableReference(creator, [])    Expression((Parcelable.Creator) f.get(null), [])  Statement(} catch (IllegalAccessException e) {, [])  MethodCall(Log.e(TAG, ""Class not found when unmarshalling: "" + name + "", e: "" + e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Class not found when unmarshalling: "" + name + "", []), Expression(e: "" + e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Class not found when unmarshalling: "" + name + "", [])    Expression(e: "" + e, [])  Statement(throw new BadParcelableException(""IllegalAccessException when unmarshalling: "" + name), [])  Statement(} catch (ClassNotFoundException e) {, [])  MethodCall(Log.e(TAG, ""Class not found when unmarshalling: "" + name + "", e: "" + e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Class not found when unmarshalling: "" + name + "", []), Expression(e: "" + e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Class not found when unmarshalling: "" + name + "", [])    Expression(e: "" + e, [])  Statement(throw new BadParcelableException(""ClassNotFoundException when unmarshalling: "" + name), [])  Statement(} catch (ClassCastException e) {, [])  Statement(} catch (NoSuchFieldException e) {, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (creator, []), Expression(, [])])    VariableReference(if (creator, [])    Expression(, [])  Statement(}, [])  MethodCall(map.put(name, creator), [VariableReference(map, []), Expression(name, []), Expression(creator, [])])    VariableReference(map, [])    Expression(name, [])    Expression(creator, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  MethodCall(return creator.createFromParcel(this), [VariableReference(return creator, []), Expression(this, [])])    VariableReference(return creator, [])    Expression(this, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(Parcelable.Creator<T> creator, []), Expression(readParcelableCreator(loader), [])]), AssignmentExpression(=, [VariableReference(if (creator, []), Expression(, [])]), Statement(return null, []), Statement(}, []), Statement(}, []), MethodCall(return creator.createFromParcel(this), [VariableReference(return creator, []), Expression(this, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(Parcelable.Creator<T> creator, []), Expression(readParcelableCreator(loader), [])])    VariableReference(Parcelable.Creator<T> creator, [])    Expression(readParcelableCreator(loader), [])  AssignmentExpression(=, [VariableReference(if (creator, []), Expression(, [])])    VariableReference(if (creator, [])    Expression(, [])  Statement(return null, [])  Statement(}, [])  Statement(}, [])  MethodCall(return creator.createFromParcel(this), [VariableReference(return creator, []), Expression(this, [])])    VariableReference(return creator, [])    Expression(this, [])  Statement(}, [])",1,"/**
 * Read and return a new Parcelable from the parcel.  The given class loader
 * will be used to load any enclosed Parcelables.  If it is null, the default
 * class loader will be used.
 * @param loader A ClassLoader from which to instantiate the Parcelable
 * object, or null for the default class loader.
 * @return Returns the newly created Parcelable, or null if a null
 * object has been written.
 * @throws BadParcelableException Throws BadParcelableException if there
 * was an error trying to instantiate the Parcelable.
 */
","/**
 * Read and return a new Parcelable from the parcel.  The given class loader
 * will be used to load any enclosed Parcelables.  If it is null, the default
 * class loader will be used.
 * @param loader A ClassLoader from which to instantiate the Parcelable
 * object, or null for the default class loader.
 * @return Returns the newly created Parcelable, or null if a null
 * object has been written.
 * @throws BadParcelableException Throws BadParcelableException if there
 * was an error trying to instantiate the Parcelable.
 */
",0,,,0,0,0,0,1,"2,3,4",2,"1,5",1,The implementation of reading Parcelable from the parcel has been changed from using a series of assignments and try-catch blocks to a single assignment that calls `readParcelableCreator(loader)`. This is a significant change in control dependency and also potentially leads to different behaviors.,"The new implementation of `readParcelable` uses `readParcelableCreator(loader)` to get the creator for the Parcelable. If the behavior of `readParcelableCreator(loader)` is different from the previous implementation, it may lead to a different creator being used, and as a result, a different Parcelable being created. This is a Compatibility Issue of type 1."
89,<android.widget.TextView: void onRtlPropertiesChanged(int)>,19,20,<android.widget.TextView: void onRtlPropertiesChanged(int)>,<android.widget.TextView: void onRtlPropertiesChanged(int)>,0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(super.onRtlPropertiesChanged(layoutDirection), [VariableReference(super, []), Expression(layoutDirection, [])]), AssignmentExpression(=, [VariableReference(mTextDir, []), Expression(getTextDirectionHeuristic(), [])]), Statement(}, [])])  Statement({, [])  MethodCall(super.onRtlPropertiesChanged(layoutDirection), [VariableReference(super, []), Expression(layoutDirection, [])])    VariableReference(super, [])    Expression(layoutDirection, [])  AssignmentExpression(=, [VariableReference(mTextDir, []), Expression(getTextDirectionHeuristic(), [])])    VariableReference(mTextDir, [])    Expression(getTextDirectionHeuristic(), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(super.onRtlPropertiesChanged(layoutDirection), [VariableReference(super, []), Expression(layoutDirection, [])]), AssignmentExpression(=, [VariableReference(mTextDir, []), Expression(getTextDirectionHeuristic(), [])]), AssignmentExpression(=, [VariableReference(if (mLayout !, []), Expression(null) {, [])]), Statement(checkForRelayout(), []), Statement(}, []), Statement(}, [])])  Statement({, [])  MethodCall(super.onRtlPropertiesChanged(layoutDirection), [VariableReference(super, []), Expression(layoutDirection, [])])    VariableReference(super, [])    Expression(layoutDirection, [])  AssignmentExpression(=, [VariableReference(mTextDir, []), Expression(getTextDirectionHeuristic(), [])])    VariableReference(mTextDir, [])    Expression(getTextDirectionHeuristic(), [])  AssignmentExpression(=, [VariableReference(if (mLayout !, []), Expression(null) {, [])])    VariableReference(if (mLayout !, [])    Expression(null) {, [])  Statement(checkForRelayout(), [])  Statement(}, [])  Statement(}, [])",1,,,-1,[@Override],[@Override],0,0,0,0,1,3,0,"1,3,4",1,The code change between the two versions is as follows:,"3. The control dependency has changed: the new assignment statement is under an `if` statement, and the new method call is after the assignment statements."
97,"<android.app.AlertDialog: void setButton3(CharSequence,Message)>",19,20,"<android.app.AlertDialog: void setButton3(CharSequence,Message)>","<android.app.AlertDialog: void setButton3(CharSequence,OnClickListener)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(setButton(BUTTON_NEUTRAL, text, msg), []), Statement(}, [])])  Statement({, [])  Statement(setButton(BUTTON_NEUTRAL, text, msg), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(setButton(BUTTON_NEUTRAL, text, listener), []), Statement(}, [])])  Statement({, [])  Statement(setButton(BUTTON_NEUTRAL, text, listener), [])  Statement(}, [])",1,"/**
 * @deprecated Use {@link #setButton(int, CharSequence, Message)} with
 * {@link DialogInterface#BUTTON_NEUTRAL}.
 */
","/**
 * Set a listener to be invoked when button 3 of the dialog is pressed.
 * @param text The text to display in button 3.
 * @param listener The {@link DialogInterface.OnClickListener} to use.
 * @deprecated Use
 * {@link #setButton(int, CharSequence, android.content.DialogInterface.OnClickListener)}
 * with {@link DialogInterface#BUTTON_POSITIVE}
 */
",1,[@Deprecated],[@Deprecated],0,0,0,0,1,5,0,1,1,The parameter type for the third argument of the setButton() method has been changed from android.os.Message to android.content.DialogInterface.OnClickListener.,This change in the parameter type can lead to compatibility issues as any code that was previously using the setButton() method with a Message object as the third argument will no longer work and will result in a compile-time error.
98,<android.speech.tts.TextToSpeech: Set<String> getFeatures(Locale)>,19,20,<android.speech.tts.TextToSpeech: Set<String> getFeatures(Locale)>,<android.speech.tts.TextToSpeech: Set<String> getFeatures(Locale)>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(return runAction(new Action<Set<String>>() {, []), Statement(@Override, []), Statement(public Set<String> run(ITextToSpeechService service) throws RemoteException {, []), AssignmentExpression(=, [VariableReference(String[] features, []), Expression(service.getFeaturesForLanguage(locale.getISO3Language(), locale.getISO3Country(), locale.getVariant()), [])]), AssignmentExpression(=, [VariableReference(if (features !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(final Set<String> featureSet, []), Expression(new HashSet<String>(), [])]), MethodCall(Collections.addAll(featureSet, features), [VariableReference(Collections, []), Expression(featureSet, []), Expression(features, [])]), Statement(return featureSet, []), Statement(}, []), Statement(return null, []), Statement(}, []), Statement(}, null, ""getFeatures""), []), Statement(}, [])])  Statement({, [])  Statement(return runAction(new Action<Set<String>>() {, [])  Statement(@Override, [])  Statement(public Set<String> run(ITextToSpeechService service) throws RemoteException {, [])  AssignmentExpression(=, [VariableReference(String[] features, []), Expression(service.getFeaturesForLanguage(locale.getISO3Language(), locale.getISO3Country(), locale.getVariant()), [])])    VariableReference(String[] features, [])    Expression(service.getFeaturesForLanguage(locale.getISO3Language(), locale.getISO3Country(), locale.getVariant()), [])  AssignmentExpression(=, [VariableReference(if (features !, []), Expression(null) {, [])])    VariableReference(if (features !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(final Set<String> featureSet, []), Expression(new HashSet<String>(), [])])    VariableReference(final Set<String> featureSet, [])    Expression(new HashSet<String>(), [])  MethodCall(Collections.addAll(featureSet, features), [VariableReference(Collections, []), Expression(featureSet, []), Expression(features, [])])    VariableReference(Collections, [])    Expression(featureSet, [])    Expression(features, [])  Statement(return featureSet, [])  Statement(}, [])  Statement(return null, [])  Statement(}, [])  Statement(}, null, ""getFeatures""), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return runAction(new Action<Set<String>>() {, []), Statement(@Override, []), Statement(public Set<String> run(ITextToSpeechService service) throws RemoteException {, []), AssignmentExpression(=, [VariableReference(String[] features, []), Expression(null, [])]), Statement(try {, []), AssignmentExpression(=, [VariableReference(features, []), Expression(service.getFeaturesForLanguage(locale.getISO3Language(), locale.getISO3Country(), locale.getVariant()), [])]), Statement(} catch (MissingResourceException e) {, []), MethodCall(Log.w(TAG, ""Couldn't retrieve 3 letter ISO 639-2/T language and/or ISO 3166 "" + ""country code for locale: "" + locale, e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Couldn't retrieve 3 letter ISO 639-2/T language and/or ISO 3166 "" + ""country code for locale: "" + locale, []), Expression(e, [])]), Statement(return null, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (features !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(final Set<String> featureSet, []), Expression(new HashSet<String>(), [])]), MethodCall(Collections.addAll(featureSet, features), [VariableReference(Collections, []), Expression(featureSet, []), Expression(features, [])]), Statement(return featureSet, []), Statement(}, []), Statement(return null, []), Statement(}, []), Statement(}, null, ""getFeatures""), []), Statement(}, [])])  Statement({, [])  Statement(return runAction(new Action<Set<String>>() {, [])  Statement(@Override, [])  Statement(public Set<String> run(ITextToSpeechService service) throws RemoteException {, [])  AssignmentExpression(=, [VariableReference(String[] features, []), Expression(null, [])])    VariableReference(String[] features, [])    Expression(null, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(features, []), Expression(service.getFeaturesForLanguage(locale.getISO3Language(), locale.getISO3Country(), locale.getVariant()), [])])    VariableReference(features, [])    Expression(service.getFeaturesForLanguage(locale.getISO3Language(), locale.getISO3Country(), locale.getVariant()), [])  Statement(} catch (MissingResourceException e) {, [])  MethodCall(Log.w(TAG, ""Couldn't retrieve 3 letter ISO 639-2/T language and/or ISO 3166 "" + ""country code for locale: "" + locale, e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Couldn't retrieve 3 letter ISO 639-2/T language and/or ISO 3166 "" + ""country code for locale: "" + locale, []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Couldn't retrieve 3 letter ISO 639-2/T language and/or ISO 3166 "" + ""country code for locale: "" + locale, [])    Expression(e, [])  Statement(return null, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (features !, []), Expression(null) {, [])])    VariableReference(if (features !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(final Set<String> featureSet, []), Expression(new HashSet<String>(), [])])    VariableReference(final Set<String> featureSet, [])    Expression(new HashSet<String>(), [])  MethodCall(Collections.addAll(featureSet, features), [VariableReference(Collections, []), Expression(featureSet, []), Expression(features, [])])    VariableReference(Collections, [])    Expression(featureSet, [])    Expression(features, [])  Statement(return featureSet, [])  Statement(}, [])  Statement(return null, [])  Statement(}, [])  Statement(}, null, ""getFeatures""), [])  Statement(}, [])",1,"/**
 * Queries the engine for the set of features it supports for a given locale.
 * Features can either be framework defined, e.g.
 * {@link TextToSpeech.Engine#KEY_FEATURE_NETWORK_SYNTHESIS} or engine specific.
 * Engine specific keys must be prefixed by the name of the engine they
 * are intended for. These keys can be used as parameters to
 * {@link TextToSpeech#speak(String, int, java.util.HashMap)} and
 * {@link TextToSpeech#synthesizeToFile(String, java.util.HashMap, String)}.
 *
 * Features are boolean flags, and their values in the synthesis parameters
 * must be behave as per {@link Boolean#parseBoolean(String)}.
 *
 * @param locale The locale to query features for.
 */
","/**
 * Queries the engine for the set of features it supports for a given locale.
 * Features can either be framework defined, e.g.
 * {@link TextToSpeech.Engine#KEY_FEATURE_NETWORK_SYNTHESIS} or engine specific.
 * Engine specific keys must be prefixed by the name of the engine they
 * are intended for. These keys can be used as parameters to
 * {@link TextToSpeech#speak(String, int, java.util.HashMap)} and
 * {@link TextToSpeech#synthesizeToFile(String, java.util.HashMap, String)}.
 *
 * Features are boolean flags, and their values in the synthesis parameters
 * must be behave as per {@link Boolean#parseBoolean(String)}.
 *
 * @param locale The locale to query features for.
 */
",1,,,0,0,0,0,1,"1,2,4","1,2","2,5",2,"A new exception handling statement is introduced in the late version, and the initialization of the ""features"" variable has been moved to before the try-catch block. Therefore, the code change type is 2,5.","As the exception handling statement has been changed, the potential behavior of the API could be different between the two versions. In the early version, when the method ""service.getFeaturesForLanguage(locale.getISO3Language(), locale.getISO3Country(), locale.getVariant())"" throws an exception, the variable ""features"" will not be initialized and it will return null. However, in the late version, the variable ""features"" is initialized before the try-catch block, so it will not be null even if the exception is thrown. Therefore, the Compatibility Issue type is 2."
100,"<android.app.ActivityThread.ApplicationThread: void dumpProvider(FileDescriptor,IBinder,String[])>",19,20,"<android.app.ActivityThread.ApplicationThread: void dumpProvider(FileDescriptor,IBinder,String[])>","<android.app.ActivityThread.ApplicationThread: void dumpProvider(FileDescriptor,IBinder,String[])>",0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(DumpComponentInfo data, []), Expression(new DumpComponentInfo(), [])]), Statement(try {, []), AssignmentExpression(=, [VariableReference(data.fd, []), Expression(ParcelFileDescriptor.dup(fd), [])]), AssignmentExpression(=, [VariableReference(data.token, []), Expression(providertoken, [])]), AssignmentExpression(=, [VariableReference(data.args, []), Expression(args, [])]), Statement(} catch (IOException e) {, []), MethodCall(Slog.w(TAG, ""dumpProvider failed"", e), [VariableReference(Slog, []), Expression(TAG, []), Expression(""dumpProvider failed"", []), Expression(e, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(DumpComponentInfo data, []), Expression(new DumpComponentInfo(), [])])    VariableReference(DumpComponentInfo data, [])    Expression(new DumpComponentInfo(), [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(data.fd, []), Expression(ParcelFileDescriptor.dup(fd), [])])    VariableReference(data.fd, [])    Expression(ParcelFileDescriptor.dup(fd), [])  AssignmentExpression(=, [VariableReference(data.token, []), Expression(providertoken, [])])    VariableReference(data.token, [])    Expression(providertoken, [])  AssignmentExpression(=, [VariableReference(data.args, []), Expression(args, [])])    VariableReference(data.args, [])    Expression(args, [])  Statement(} catch (IOException e) {, [])  MethodCall(Slog.w(TAG, ""dumpProvider failed"", e), [VariableReference(Slog, []), Expression(TAG, []), Expression(""dumpProvider failed"", []), Expression(e, [])])    VariableReference(Slog, [])    Expression(TAG, [])    Expression(""dumpProvider failed"", [])    Expression(e, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(DumpComponentInfo data, []), Expression(new DumpComponentInfo(), [])]), Statement(try {, []), AssignmentExpression(=, [VariableReference(data.fd, []), Expression(ParcelFileDescriptor.dup(fd), [])]), AssignmentExpression(=, [VariableReference(data.token, []), Expression(providertoken, [])]), AssignmentExpression(=, [VariableReference(data.args, []), Expression(args, [])]), Statement(} catch (IOException e) {, []), MethodCall(Slog.w(TAG, ""dumpProvider failed"", e), [VariableReference(Slog, []), Expression(TAG, []), Expression(""dumpProvider failed"", []), Expression(e, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(DumpComponentInfo data, []), Expression(new DumpComponentInfo(), [])])    VariableReference(DumpComponentInfo data, [])    Expression(new DumpComponentInfo(), [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(data.fd, []), Expression(ParcelFileDescriptor.dup(fd), [])])    VariableReference(data.fd, [])    Expression(ParcelFileDescriptor.dup(fd), [])  AssignmentExpression(=, [VariableReference(data.token, []), Expression(providertoken, [])])    VariableReference(data.token, [])    Expression(providertoken, [])  AssignmentExpression(=, [VariableReference(data.args, []), Expression(args, [])])    VariableReference(data.args, [])    Expression(args, [])  Statement(} catch (IOException e) {, [])  MethodCall(Slog.w(TAG, ""dumpProvider failed"", e), [VariableReference(Slog, []), Expression(TAG, []), Expression(""dumpProvider failed"", []), Expression(e, [])])    VariableReference(Slog, [])    Expression(TAG, [])    Expression(""dumpProvider failed"", [])    Expression(e, [])  Statement(}, [])  Statement(}, [])",1,,,0,,,0,0,0,0,1,4,0,0,0,There is no change between the early version and late version of the API.,There is no compatibility issue as there is no change between the early version and late version of the API.
101,<android.widget.PopupWindow.PopupDecorView: void requestEnterTransition(Transition)>,23,24,<android.widget.PopupWindow.PopupDecorView: void requestEnterTransition(Transition)>,<android.widget.PopupWindow.PopupDecorView: void requestEnterTransition(Transition)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final ViewTreeObserver observer, []), Expression(getViewTreeObserver(), [])]), AssignmentExpression(=, [VariableReference(if (observer !, []), Expression(null && transition !, [])]), AssignmentExpression(=, [VariableReference(final Transition enterTransition, []), Expression(transition.clone(), [])]), Statement(// Postpone the enter transition after the first layout pass., []), MethodCall(observer.addOnGlobalLayoutListener(new OnGlobalLayoutListener(), [VariableReference(observer, []), Expression(new OnGlobalLayoutListener(, [])]), Statement(@Override, []), Statement(public void onGlobalLayout() {, []), AssignmentExpression(=, [VariableReference(final ViewTreeObserver observer, []), Expression(getViewTreeObserver(), [])]), AssignmentExpression(=, [VariableReference(if (observer !, []), Expression(null) {, [])]), MethodCall(observer.removeOnGlobalLayoutListener(this), [VariableReference(observer, []), Expression(this, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(final Rect epicenter, []), Expression(getRelativeAnchorBounds(), [])]), MethodCall(enterTransition.setEpicenterCallback(new EpicenterCallback(), [VariableReference(enterTransition, []), Expression(new EpicenterCallback(, [])]), Statement(@Override, []), Statement(public Rect onGetEpicenter(Transition transition) {, []), Statement(return epicenter, []), Statement(}, []), Statement(}), []), Statement(startEnterTransition(enterTransition), []), Statement(}, []), Statement(}), []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final ViewTreeObserver observer, []), Expression(getViewTreeObserver(), [])])    VariableReference(final ViewTreeObserver observer, [])    Expression(getViewTreeObserver(), [])  AssignmentExpression(=, [VariableReference(if (observer !, []), Expression(null && transition !, [])])    VariableReference(if (observer !, [])    Expression(null && transition !, [])  AssignmentExpression(=, [VariableReference(final Transition enterTransition, []), Expression(transition.clone(), [])])    VariableReference(final Transition enterTransition, [])    Expression(transition.clone(), [])  Statement(// Postpone the enter transition after the first layout pass., [])  MethodCall(observer.addOnGlobalLayoutListener(new OnGlobalLayoutListener(), [VariableReference(observer, []), Expression(new OnGlobalLayoutListener(, [])])    VariableReference(observer, [])    Expression(new OnGlobalLayoutListener(, [])  Statement(@Override, [])  Statement(public void onGlobalLayout() {, [])  AssignmentExpression(=, [VariableReference(final ViewTreeObserver observer, []), Expression(getViewTreeObserver(), [])])    VariableReference(final ViewTreeObserver observer, [])    Expression(getViewTreeObserver(), [])  AssignmentExpression(=, [VariableReference(if (observer !, []), Expression(null) {, [])])    VariableReference(if (observer !, [])    Expression(null) {, [])  MethodCall(observer.removeOnGlobalLayoutListener(this), [VariableReference(observer, []), Expression(this, [])])    VariableReference(observer, [])    Expression(this, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(final Rect epicenter, []), Expression(getRelativeAnchorBounds(), [])])    VariableReference(final Rect epicenter, [])    Expression(getRelativeAnchorBounds(), [])  MethodCall(enterTransition.setEpicenterCallback(new EpicenterCallback(), [VariableReference(enterTransition, []), Expression(new EpicenterCallback(, [])])    VariableReference(enterTransition, [])    Expression(new EpicenterCallback(, [])  Statement(@Override, [])  Statement(public Rect onGetEpicenter(Transition transition) {, [])  Statement(return epicenter, [])  Statement(}, [])  Statement(}), [])  Statement(startEnterTransition(enterTransition), [])  Statement(}, [])  Statement(}), [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final ViewTreeObserver observer, []), Expression(getViewTreeObserver(), [])]), AssignmentExpression(=, [VariableReference(if (observer !, []), Expression(null && transition !, [])]), AssignmentExpression(=, [VariableReference(final Transition enterTransition, []), Expression(transition.clone(), [])]), Statement(// Postpone the enter transition after the first layout pass., []), MethodCall(observer.addOnGlobalLayoutListener(new OnGlobalLayoutListener(), [VariableReference(observer, []), Expression(new OnGlobalLayoutListener(, [])]), Statement(@Override, []), Statement(public void onGlobalLayout() {, []), AssignmentExpression(=, [VariableReference(final ViewTreeObserver observer, []), Expression(getViewTreeObserver(), [])]), AssignmentExpression(=, [VariableReference(if (observer !, []), Expression(null) {, [])]), MethodCall(observer.removeOnGlobalLayoutListener(this), [VariableReference(observer, []), Expression(this, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(final Rect epicenter, []), Expression(getTransitionEpicenter(), [])]), MethodCall(enterTransition.setEpicenterCallback(new EpicenterCallback(), [VariableReference(enterTransition, []), Expression(new EpicenterCallback(, [])]), Statement(@Override, []), Statement(public Rect onGetEpicenter(Transition transition) {, []), Statement(return epicenter, []), Statement(}, []), Statement(}), []), Statement(startEnterTransition(enterTransition), []), Statement(}, []), Statement(}), []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final ViewTreeObserver observer, []), Expression(getViewTreeObserver(), [])])    VariableReference(final ViewTreeObserver observer, [])    Expression(getViewTreeObserver(), [])  AssignmentExpression(=, [VariableReference(if (observer !, []), Expression(null && transition !, [])])    VariableReference(if (observer !, [])    Expression(null && transition !, [])  AssignmentExpression(=, [VariableReference(final Transition enterTransition, []), Expression(transition.clone(), [])])    VariableReference(final Transition enterTransition, [])    Expression(transition.clone(), [])  Statement(// Postpone the enter transition after the first layout pass., [])  MethodCall(observer.addOnGlobalLayoutListener(new OnGlobalLayoutListener(), [VariableReference(observer, []), Expression(new OnGlobalLayoutListener(, [])])    VariableReference(observer, [])    Expression(new OnGlobalLayoutListener(, [])  Statement(@Override, [])  Statement(public void onGlobalLayout() {, [])  AssignmentExpression(=, [VariableReference(final ViewTreeObserver observer, []), Expression(getViewTreeObserver(), [])])    VariableReference(final ViewTreeObserver observer, [])    Expression(getViewTreeObserver(), [])  AssignmentExpression(=, [VariableReference(if (observer !, []), Expression(null) {, [])])    VariableReference(if (observer !, [])    Expression(null) {, [])  MethodCall(observer.removeOnGlobalLayoutListener(this), [VariableReference(observer, []), Expression(this, [])])    VariableReference(observer, [])    Expression(this, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(final Rect epicenter, []), Expression(getTransitionEpicenter(), [])])    VariableReference(final Rect epicenter, [])    Expression(getTransitionEpicenter(), [])  MethodCall(enterTransition.setEpicenterCallback(new EpicenterCallback(), [VariableReference(enterTransition, []), Expression(new EpicenterCallback(, [])])    VariableReference(enterTransition, [])    Expression(new EpicenterCallback(, [])  Statement(@Override, [])  Statement(public Rect onGetEpicenter(Transition transition) {, [])  Statement(return epicenter, [])  Statement(}, [])  Statement(}), [])  Statement(startEnterTransition(enterTransition), [])  Statement(}, [])  Statement(}), [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Requests that an enter transition run after the next layout pass.
 */","/**
 * Requests that an enter transition run after the next layout pass.
 */",0,,,0,,,,1,4,0,"4,5",1,"The method `getRelativeAnchorBounds()` in the early version has been changed to `getTransitionEpicenter()` in the late version. Additionally, the dependent API `Transition.clone()` in the early version has been changed to `Transition.create()` in the late version.","The change in the method name `getRelativeAnchorBounds()` to `getTransitionEpicenter()` could potentially lead to different return values, which would cause compatibility issues (CI type 1). The change in the dependent API `Transition.clone()` to `Transition.create()` could also potentially lead to different return values and behaviors, which would cause compatibility issues (CI type 1 and 5)."
102,<android.view.ViewRootImpl.ImeInputStage: int onProcess(QueuedInputEvent)>,23,24,<android.view.ViewRootImpl.ImeInputStage: int onProcess(QueuedInputEvent)>,<android.view.ViewRootImpl.ImeInputStage: int onProcess(QueuedInputEvent)>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(if (mLastWasImTarget && !isInLocalFocusMode()) {, []), AssignmentExpression(=, [VariableReference(InputMethodManager imm, []), Expression(InputMethodManager.peekInstance(), [])]), AssignmentExpression(=, [VariableReference(if (imm !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(final InputEvent event, []), Expression(q.mEvent, [])]), Statement(if (DEBUG_IMF), []), MethodCall(Log.v(TAG, ""Sending input event to IME: "" + event), [VariableReference(Log, []), Expression(TAG, []), Expression(""Sending input event to IME: "" + event, [])]), AssignmentExpression(=, [VariableReference(int result, []), Expression(imm.dispatchInputEvent(event, q, this, mHandler), [])]), AssignmentExpression(=, [VariableReference(if (result, []), Expression(, [])]), Statement(return FINISH_HANDLED, []), AssignmentExpression(=, [VariableReference(} else if (result, []), Expression(, [])]), Statement(// The IME could not handle it, so skip along to the next InputStage, []), Statement(return FORWARD, []), Statement(} else {, []), Statement(// callback will be invoked later, []), Statement(return DEFER, []), Statement(}, []), Statement(}, []), Statement(}, []), Statement(return FORWARD, []), Statement(}, [])])  Statement({, [])  Statement(if (mLastWasImTarget && !isInLocalFocusMode()) {, [])  AssignmentExpression(=, [VariableReference(InputMethodManager imm, []), Expression(InputMethodManager.peekInstance(), [])])    VariableReference(InputMethodManager imm, [])    Expression(InputMethodManager.peekInstance(), [])  AssignmentExpression(=, [VariableReference(if (imm !, []), Expression(null) {, [])])    VariableReference(if (imm !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(final InputEvent event, []), Expression(q.mEvent, [])])    VariableReference(final InputEvent event, [])    Expression(q.mEvent, [])  Statement(if (DEBUG_IMF), [])  MethodCall(Log.v(TAG, ""Sending input event to IME: "" + event), [VariableReference(Log, []), Expression(TAG, []), Expression(""Sending input event to IME: "" + event, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Sending input event to IME: "" + event, [])  AssignmentExpression(=, [VariableReference(int result, []), Expression(imm.dispatchInputEvent(event, q, this, mHandler), [])])    VariableReference(int result, [])    Expression(imm.dispatchInputEvent(event, q, this, mHandler), [])  AssignmentExpression(=, [VariableReference(if (result, []), Expression(, [])])    VariableReference(if (result, [])    Expression(, [])  Statement(return FINISH_HANDLED, [])  AssignmentExpression(=, [VariableReference(} else if (result, []), Expression(, [])])    VariableReference(} else if (result, [])    Expression(, [])  Statement(// The IME could not handle it, so skip along to the next InputStage, [])  Statement(return FORWARD, [])  Statement(} else {, [])  Statement(// callback will be invoked later, [])  Statement(return DEFER, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(return FORWARD, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (mLastWasImTarget && !isInLocalFocusMode()) {, []), AssignmentExpression(=, [VariableReference(InputMethodManager imm, []), Expression(InputMethodManager.peekInstance(), [])]), AssignmentExpression(=, [VariableReference(if (imm !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(final InputEvent event, []), Expression(q.mEvent, [])]), Statement(if (DEBUG_IMF), []), MethodCall(Log.v(mTag, ""Sending input event to IME: "" + event), [VariableReference(Log, []), Expression(mTag, []), Expression(""Sending input event to IME: "" + event, [])]), AssignmentExpression(=, [VariableReference(int result, []), Expression(imm.dispatchInputEvent(event, q, this, mHandler), [])]), AssignmentExpression(=, [VariableReference(if (result, []), Expression(, [])]), Statement(return FINISH_HANDLED, []), AssignmentExpression(=, [VariableReference(} else if (result, []), Expression(, [])]), Statement(// The IME could not handle it, so skip along to the next InputStage, []), Statement(return FORWARD, []), Statement(} else {, []), Statement(// callback will be invoked later, []), Statement(return DEFER, []), Statement(}, []), Statement(}, []), Statement(}, []), Statement(return FORWARD, []), Statement(}, [])])  Statement({, [])  Statement(if (mLastWasImTarget && !isInLocalFocusMode()) {, [])  AssignmentExpression(=, [VariableReference(InputMethodManager imm, []), Expression(InputMethodManager.peekInstance(), [])])    VariableReference(InputMethodManager imm, [])    Expression(InputMethodManager.peekInstance(), [])  AssignmentExpression(=, [VariableReference(if (imm !, []), Expression(null) {, [])])    VariableReference(if (imm !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(final InputEvent event, []), Expression(q.mEvent, [])])    VariableReference(final InputEvent event, [])    Expression(q.mEvent, [])  Statement(if (DEBUG_IMF), [])  MethodCall(Log.v(mTag, ""Sending input event to IME: "" + event), [VariableReference(Log, []), Expression(mTag, []), Expression(""Sending input event to IME: "" + event, [])])    VariableReference(Log, [])    Expression(mTag, [])    Expression(""Sending input event to IME: "" + event, [])  AssignmentExpression(=, [VariableReference(int result, []), Expression(imm.dispatchInputEvent(event, q, this, mHandler), [])])    VariableReference(int result, [])    Expression(imm.dispatchInputEvent(event, q, this, mHandler), [])  AssignmentExpression(=, [VariableReference(if (result, []), Expression(, [])])    VariableReference(if (result, [])    Expression(, [])  Statement(return FINISH_HANDLED, [])  AssignmentExpression(=, [VariableReference(} else if (result, []), Expression(, [])])    VariableReference(} else if (result, [])    Expression(, [])  Statement(// The IME could not handle it, so skip along to the next InputStage, [])  Statement(return FORWARD, [])  Statement(} else {, [])  Statement(// callback will be invoked later, [])  Statement(return DEFER, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(return FORWARD, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,,1,4,0,4,1,The only difference between the two versions is that the argument in the Log.v() method call has been changed from "TAG" to "mTag".,"Although the change is minor and does not affect the functionality of the method, it can still cause a Compatibility Issue (CI). The change of the argument in the Log.v() method call can potentially lead to different values being logged in the two versions. If a developer is relying on the logged values to debug or monitor the behavior of the application, this change can cause confusion and lead to incorrect conclusions. Therefore, this change should be classified as a CI with type 1 (Compatibility Issue caused by potential different return values or types)."
104,"<android.view.View: void scheduleDrawable(Drawable,Runnable,long)>",23,24,"<android.view.View: void scheduleDrawable(Drawable,Runnable,long)>","<android.view.View: void scheduleDrawable(Drawable,Runnable,long)>",0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (verifyDrawable(who) && what !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(final long delay, []), Expression(when - SystemClock.uptimeMillis(), [])]), AssignmentExpression(=, [VariableReference(if (mAttachInfo !, []), Expression(null) {, [])]), Statement(} else {, []), MethodCall(ViewRootImpl.getRunQueue().postDelayed(what, delay), [VariableReference(ViewRootImpl, []), Expression().postDelayed(what, []), Expression(delay, [])]), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (verifyDrawable(who) && what !, []), Expression(null) {, [])])    VariableReference(if (verifyDrawable(who) && what !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(final long delay, []), Expression(when - SystemClock.uptimeMillis(), [])])    VariableReference(final long delay, [])    Expression(when - SystemClock.uptimeMillis(), [])  AssignmentExpression(=, [VariableReference(if (mAttachInfo !, []), Expression(null) {, [])])    VariableReference(if (mAttachInfo !, [])    Expression(null) {, [])  Statement(} else {, [])  MethodCall(ViewRootImpl.getRunQueue().postDelayed(what, delay), [VariableReference(ViewRootImpl, []), Expression().postDelayed(what, []), Expression(delay, [])])    VariableReference(ViewRootImpl, [])    Expression().postDelayed(what, [])    Expression(delay, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (verifyDrawable(who) && what !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(final long delay, []), Expression(when - SystemClock.uptimeMillis(), [])]), AssignmentExpression(=, [VariableReference(if (mAttachInfo !, []), Expression(null) {, [])]), Statement(} else {, []), Statement(// Postpone the runnable until we know, []), Statement(// on which thread it needs to run., []), MethodCall(getRunQueue().postDelayed(what, delay), [VariableReference(getRunQueue(), []), Expression(what, []), Expression(delay, [])]), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (verifyDrawable(who) && what !, []), Expression(null) {, [])])    VariableReference(if (verifyDrawable(who) && what !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(final long delay, []), Expression(when - SystemClock.uptimeMillis(), [])])    VariableReference(final long delay, [])    Expression(when - SystemClock.uptimeMillis(), [])  AssignmentExpression(=, [VariableReference(if (mAttachInfo !, []), Expression(null) {, [])])    VariableReference(if (mAttachInfo !, [])    Expression(null) {, [])  Statement(} else {, [])  Statement(// Postpone the runnable until we know, [])  Statement(// on which thread it needs to run., [])  MethodCall(getRunQueue().postDelayed(what, delay), [VariableReference(getRunQueue(), []), Expression(what, []), Expression(delay, [])])    VariableReference(getRunQueue(), [])    Expression(what, [])    Expression(delay, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Schedules an action on a drawable to occur at a specified time.
 *
 * @param who the recipient of the action
 * @param what the action to run on the drawable
 * @param when the time at which the action must occur. Uses the
 * {@link SystemClock#uptimeMillis} timebase.
 */","/**
 * Schedules an action on a drawable to occur at a specified time.
 *
 * @param who the recipient of the action
 * @param what the action to run on the drawable
 * @param when the time at which the action must occur. Uses the
 * {@link SystemClock#uptimeMillis} timebase.
 */",0,[@Override],[@Override],0,,,,1,3,0,3,1,"The implementation of the method has changed from `ViewRootImpl.getRunQueue().postDelayed(what, delay)` to `getRunQueue().postDelayed(what, delay)`. This is a change in the control dependency of the method, as the way the `Runnable` is scheduled has been modified.","The Compatibility Issue arises due to the potential for different behavior in the way the `Runnable` is scheduled. This could lead to the `Runnable` not being executed at the correct time, or not at all, which could cause issues in the application's functionality."
105,"<android.widget.RemoteViewsAdapter.RemoteViewsFrameLayout: void onRemoteViewsLoaded(RemoteViews,OnClickHandler)>",23,24,"<android.widget.RemoteViewsAdapter.RemoteViewsFrameLayout: void onRemoteViewsLoaded(RemoteViews,OnClickHandler)>","<android.widget.RemoteViewsAdapter.RemoteViewsFrameLayout: void onRemoteViewsLoaded(RemoteViews,OnClickHandler)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), Statement(// Remove all the children of this layout first, []), Statement(removeAllViews(), []), MethodCall(addView(view.apply(getContext(), this, handler)), [VariableReference(addView(view, []), Expression(getContext(), []), Expression(this, []), Expression(handler), [])]), Statement(} catch (Exception e) {, []), MethodCall(Log.e(TAG, ""Failed to apply RemoteViews.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Failed to apply RemoteViews."", [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  Statement(// Remove all the children of this layout first, [])  Statement(removeAllViews(), [])  MethodCall(addView(view.apply(getContext(), this, handler)), [VariableReference(addView(view, []), Expression(getContext(), []), Expression(this, []), Expression(handler), [])])    VariableReference(addView(view, [])    Expression(getContext(), [])    Expression(this, [])    Expression(handler), [])  Statement(} catch (Exception e) {, [])  MethodCall(Log.e(TAG, ""Failed to apply RemoteViews.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Failed to apply RemoteViews."", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Failed to apply RemoteViews."", [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(setOnClickHandler(handler), []), Statement(applyRemoteViews(view), []), Statement(}, [])])  Statement({, [])  Statement(setOnClickHandler(handler), [])  Statement(applyRemoteViews(view), [])  Statement(}, [])",1,"/**
 * Updates this RemoteViewsFrameLayout depending on the view that was loaded.
 * @param view the RemoteViews that was loaded. If null, the RemoteViews was not loaded
 * successfully.
 */","/**
 * Updates this RemoteViewsFrameLayout depending on the view that was loaded.
 * @param view the RemoteViews that was loaded. If null, the RemoteViews was not loaded
 * successfully.
 */",0,,,0,,,,1,"2,4",2,"1,4",1,"The original implementation of the method has been completely changed. In the early version, the method body first removes all children of the layout, then adds the remote view view to the layout, and finally catches exceptions. In the late version, the method body first sets the onClick handler, then applies the remote view view to the layout, and no longer catches exceptions.","Compatibility Issue is caused by potential different return values or types. The return type of the method has not changed, but the behavior of the method has changed. In the early version, the method will remove all the children of the layout first, while the late version will not. This change may cause the layout to display abnormally when the method is called. In addition, the late version no longer catches exceptions, which may cause the program to crash when an exception occurs."
107,<android.text.style.TtsSpan.DecimalBuilder: DecimalBuilder setIntegerPart(String)>,23,24,<android.text.style.TtsSpan.DecimalBuilder: DecimalBuilder setIntegerPart(String)>,<android.text.style.TtsSpan.DecimalBuilder: DecimalBuilder setIntegerPart(String)>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(}, [])])  Statement({, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(return setIntegerPart(String.valueOf(integerPart)), [VariableReference(return setIntegerPart(String, []), Expression(integerPart), [])]), Statement(}, [])])  Statement({, [])  MethodCall(return setIntegerPart(String.valueOf(integerPart)), [VariableReference(return setIntegerPart(String, []), Expression(integerPart), [])])    VariableReference(return setIntegerPart(String, [])    Expression(integerPart), [])  Statement(}, [])",1,"/**
 * Sets the {@link #ARG_INTEGER_PART} argument.
 * @param integerPart A non-empty string of digits with an optional
 * leading + or -.
 * @return This instance.
 */","/**
 * Convenience method that converts the number to a String and sets it
 * to the value for {@link #ARG_INTEGER_PART}.
 * @param integerPart The integer part of the decimal.
 * @return This instance.
 */",1,,,0,,,,1,1,1,1,1,"The implementation of the `setIntegerPart` method has been changed in the late version. In the early version, the method body only contains two statements, while in the late version, the method body contains three statements. The new statement in the late version is a method call `return setIntegerPart(String.valueOf(integerPart))`, which converts the `integerPart` argument to a string and then calls the `setIntegerPart` method with the string representation.","The change in the `setIntegerPart` method implementation could potentially lead to compatibility issues. The method in the late version expects a string representation of the integer, while in the early version, it expects the integer itself. Therefore, if a client application is using the early version of the API and passes an integer to the `setIntegerPart` method, it could result in unexpected behavior in the late version."
109,"<android.accounts.AccountManager: void setAuthToken(Account,String,String)>",23,24,"<android.accounts.AccountManager: void setAuthToken(Account,String,String)>","<android.accounts.AccountManager: void setAuthToken(Account,String,String)>",0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (account, []), Expression(, [])]), Statement(throw new IllegalArgumentException(""account is null""), []), AssignmentExpression(=, [VariableReference(if (authTokenType, []), Expression(, [])]), Statement(throw new IllegalArgumentException(""authTokenType is null""), []), Statement(try {, []), MethodCall(mService.setAuthToken(account, authTokenType, authToken), [VariableReference(mService, []), Expression(account, []), Expression(authTokenType, []), Expression(authToken, [])]), Statement(} catch (RemoteException e) {, []), Statement(// won't ever happen, []), Statement(throw new RuntimeException(e), []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (account, []), Expression(, [])])    VariableReference(if (account, [])    Expression(, [])  Statement(throw new IllegalArgumentException(""account is null""), [])  AssignmentExpression(=, [VariableReference(if (authTokenType, []), Expression(, [])])    VariableReference(if (authTokenType, [])    Expression(, [])  Statement(throw new IllegalArgumentException(""authTokenType is null""), [])  Statement(try {, [])  MethodCall(mService.setAuthToken(account, authTokenType, authToken), [VariableReference(mService, []), Expression(account, []), Expression(authTokenType, []), Expression(authToken, [])])    VariableReference(mService, [])    Expression(account, [])    Expression(authTokenType, [])    Expression(authToken, [])  Statement(} catch (RemoteException e) {, [])  Statement(// won't ever happen, [])  Statement(throw new RuntimeException(e), [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (account, []), Expression(, [])]), Statement(throw new IllegalArgumentException(""account is null""), []), AssignmentExpression(=, [VariableReference(if (authTokenType, []), Expression(, [])]), Statement(throw new IllegalArgumentException(""authTokenType is null""), []), Statement(try {, []), MethodCall(mService.setAuthToken(account, authTokenType, authToken), [VariableReference(mService, []), Expression(account, []), Expression(authTokenType, []), Expression(authToken, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (account, []), Expression(, [])])    VariableReference(if (account, [])    Expression(, [])  Statement(throw new IllegalArgumentException(""account is null""), [])  AssignmentExpression(=, [VariableReference(if (authTokenType, []), Expression(, [])])    VariableReference(if (authTokenType, [])    Expression(, [])  Statement(throw new IllegalArgumentException(""authTokenType is null""), [])  Statement(try {, [])  MethodCall(mService.setAuthToken(account, authTokenType, authToken), [VariableReference(mService, []), Expression(account, []), Expression(authTokenType, []), Expression(authToken, [])])    VariableReference(mService, [])    Expression(account, [])    Expression(authTokenType, [])    Expression(authToken, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Adds an auth token to the AccountManager cache for an account.
 * If the account does not exist then this call has no effect.
 * Replaces any previous auth token for this account and auth token type.
 * Intended for use by the authenticator, not directly by applications.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>This method requires the caller to have a signature match with the
 * authenticator that manages the specified account.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * AUTHENTICATE_ACCOUNTS permission and same UID as account's authenticator
 * is needed for those platforms. See docs for this function in API level 22.
 *
 * @param account The account to set an auth token for
 * @param authTokenType The type of the auth token, see {#getAuthToken}
 * @param authToken The auth token to add to the cache
 */","/**
 * Adds an auth token to the AccountManager cache for an account.
 * If the account does not exist then this call has no effect.
 * Replaces any previous auth token for this account and auth token type.
 * Intended for use by the authenticator, not directly by applications.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>This method requires the caller to have a signature match with the
 * authenticator that manages the specified account.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * AUTHENTICATE_ACCOUNTS permission and same UID as account's authenticator
 * is needed for those platforms. See docs for this function in API level 22.
 *
 * @param account The account to set an auth token for
 * @param authTokenType The type of the auth token, see {#getAuthToken}
 * @param authToken The auth token to add to the cache
 */",0,,,0,,,,1,2,2,2,2,"In the late implementation, the statement for handling the RemoteException exception has been changed from `throw new RuntimeException(e)` to `throw e.rethrowFromSystemServer()`.","The change in exception handling can potentially lead to a compatibility issue, as the late version will throw a different exception (i.e., a subtype of RemoteException) compared to the early version (i.e., a RuntimeException). This may cause unexpected behavior in client code that catches and handles exceptions differently based on their types."
115,<android.hardware.camera2.impl.CameraCaptureSessionImpl: void close()>,24,25,<android.hardware.camera2.impl.CameraCaptureSessionImpl: void close()>,<android.hardware.camera2.impl.CameraCaptureSessionImpl: void close()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(if (mClosed) {, []), Statement(if (DEBUG), []), MethodCall(Log.v(TAG, mIdString + ""close - reentering""), [VariableReference(Log, []), Expression(TAG, []), Expression(mIdString + ""close - reentering"", [])]), Statement(return, []), Statement(}, []), Statement(if (DEBUG), []), MethodCall(Log.v(TAG, mIdString + ""close - first time""), [VariableReference(Log, []), Expression(TAG, []), Expression(mIdString + ""close - first time"", [])]), AssignmentExpression(=, [VariableReference(mClosed, []), Expression(true, [])]), Statement(/*, []), Statement(* Flush out any repeating request. Since camera is closed, no new requests, []), Statement(* can be queued, and eventually the entire request queue will be drained., []), Statement(*, []), Statement(* If the camera device was already closed, short circuit and do nothing, []), Statement(since, []), Statement(* no more internal device callbacks will fire anyway., []), Statement(*, []), Statement(* Otherwise, once stopRepeating is done, wait for camera to idle, then unconfigure the, []), Statement(* camera. Once that's done, fire #onClosed., []), Statement(*/, []), Statement(try {, []), MethodCall(mDeviceImpl.stopRepeating(), [VariableReference(mDeviceImpl, []), Expression(, [])]), Statement(} catch (IllegalStateException e) {, []), Statement(// OK: Camera device may already be closed, nothing else to do, []), Statement(// TODO: Fire onClosed anytime we get the device onClosed or the ISE?, []), Statement(// or just suppress the ISE only and rely onClosed., []), Statement(// Also skip any of the draining work if this is already closed., []), Statement(// Short-circuit, []), Statement(queue callback immediately and return, []), MethodCall(mStateCallback.onClosed(this), [VariableReference(mStateCallback, []), Expression(this, [])]), Statement(return, []), Statement(} catch (CameraAccessException e) {, []), Statement(// OK: close does not throw checked exceptions., []), MethodCall(Log.e(TAG, mIdString + ""Exception while stopping repeating: "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(mIdString + ""Exception while stopping repeating: "", []), Expression(e, [])]), Statement(// TODO: call onError instead of onClosed if this happens, []), Statement(}, []), Statement(// If no sequences are pending, fire #onClosed immediately, []), MethodCall(mSequenceDrainer.beginDrain(), [VariableReference(mSequenceDrainer, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  Statement(if (mClosed) {, [])  Statement(if (DEBUG), [])  MethodCall(Log.v(TAG, mIdString + ""close - reentering""), [VariableReference(Log, []), Expression(TAG, []), Expression(mIdString + ""close - reentering"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(mIdString + ""close - reentering"", [])  Statement(return, [])  Statement(}, [])  Statement(if (DEBUG), [])  MethodCall(Log.v(TAG, mIdString + ""close - first time""), [VariableReference(Log, []), Expression(TAG, []), Expression(mIdString + ""close - first time"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(mIdString + ""close - first time"", [])  AssignmentExpression(=, [VariableReference(mClosed, []), Expression(true, [])])    VariableReference(mClosed, [])    Expression(true, [])  Statement(/*, [])  Statement(* Flush out any repeating request. Since camera is closed, no new requests, [])  Statement(* can be queued, and eventually the entire request queue will be drained., [])  Statement(*, [])  Statement(* If the camera device was already closed, short circuit and do nothing, [])  Statement(since, [])  Statement(* no more internal device callbacks will fire anyway., [])  Statement(*, [])  Statement(* Otherwise, once stopRepeating is done, wait for camera to idle, then unconfigure the, [])  Statement(* camera. Once that's done, fire #onClosed., [])  Statement(*/, [])  Statement(try {, [])  MethodCall(mDeviceImpl.stopRepeating(), [VariableReference(mDeviceImpl, []), Expression(, [])])    VariableReference(mDeviceImpl, [])    Expression(, [])  Statement(} catch (IllegalStateException e) {, [])  Statement(// OK: Camera device may already be closed, nothing else to do, [])  Statement(// TODO: Fire onClosed anytime we get the device onClosed or the ISE?, [])  Statement(// or just suppress the ISE only and rely onClosed., [])  Statement(// Also skip any of the draining work if this is already closed., [])  Statement(// Short-circuit, [])  Statement(queue callback immediately and return, [])  MethodCall(mStateCallback.onClosed(this), [VariableReference(mStateCallback, []), Expression(this, [])])    VariableReference(mStateCallback, [])    Expression(this, [])  Statement(return, [])  Statement(} catch (CameraAccessException e) {, [])  Statement(// OK: close does not throw checked exceptions., [])  MethodCall(Log.e(TAG, mIdString + ""Exception while stopping repeating: "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(mIdString + ""Exception while stopping repeating: "", []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(mIdString + ""Exception while stopping repeating: "", [])    Expression(e, [])  Statement(// TODO: call onError instead of onClosed if this happens, [])  Statement(}, [])  Statement(// If no sequences are pending, fire #onClosed immediately, [])  MethodCall(mSequenceDrainer.beginDrain(), [VariableReference(mSequenceDrainer, []), Expression(, [])])    VariableReference(mSequenceDrainer, [])    Expression(, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(synchronized (this) {, []), Statement(if (mClosed) {, []), Statement(if (DEBUG), []), MethodCall(Log.v(TAG, mIdString + ""close - reentering""), [VariableReference(Log, []), Expression(TAG, []), Expression(mIdString + ""close - reentering"", [])]), Statement(return, []), Statement(}, []), Statement(if (DEBUG), []), MethodCall(Log.v(TAG, mIdString + ""close - first time""), [VariableReference(Log, []), Expression(TAG, []), Expression(mIdString + ""close - first time"", [])]), AssignmentExpression(=, [VariableReference(mClosed, []), Expression(true, [])]), Statement(}, []), Statement(synchronized (this) {, []), Statement(/*, []), Statement(* Flush out any repeating request. Since camera is closed, no new requests, []), Statement(* can be queued, and eventually the entire request queue will be drained., []), Statement(*, []), Statement(* If the camera device was already closed, short circuit and do nothing, []), Statement(since, []), Statement(* no more internal device callbacks will fire anyway., []), Statement(*, []), Statement(* Otherwise, once stopRepeating is done, wait for camera to idle, then unconfigure, []), Statement(* the camera. Once that's done, fire #onClosed., []), Statement(*/, []), Statement(try {, []), MethodCall(mDeviceImpl.stopRepeating(), [VariableReference(mDeviceImpl, []), Expression(, [])]), Statement(} catch (IllegalStateException e) {, []), Statement(// OK: Camera device may already be closed, nothing else to do, []), Statement(// TODO: Fire onClosed anytime we get the device onClosed or the ISE?, []), Statement(// or just suppress the ISE only and rely onClosed., []), Statement(// Also skip any of the draining work if this is already closed., []), Statement(// Short-circuit, []), Statement(queue callback immediately and return, []), MethodCall(mStateCallback.onClosed(this), [VariableReference(mStateCallback, []), Expression(this, [])]), Statement(return, []), Statement(} catch (CameraAccessException e) {, []), Statement(// OK: close does not throw checked exceptions., []), MethodCall(Log.e(TAG, mIdString + ""Exception while stopping repeating: "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(mIdString + ""Exception while stopping repeating: "", []), Expression(e, [])]), Statement(// TODO: call onError instead of onClosed if this happens, []), Statement(}, []), Statement(}, []), Statement(}, []), Statement(synchronized (this) {, []), Statement(// If no sequences are pending, fire #onClosed immediately, []), MethodCall(mSequenceDrainer.beginDrain(), [VariableReference(mSequenceDrainer, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(synchronized (this) {, [])  Statement(if (mClosed) {, [])  Statement(if (DEBUG), [])  MethodCall(Log.v(TAG, mIdString + ""close - reentering""), [VariableReference(Log, []), Expression(TAG, []), Expression(mIdString + ""close - reentering"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(mIdString + ""close - reentering"", [])  Statement(return, [])  Statement(}, [])  Statement(if (DEBUG), [])  MethodCall(Log.v(TAG, mIdString + ""close - first time""), [VariableReference(Log, []), Expression(TAG, []), Expression(mIdString + ""close - first time"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(mIdString + ""close - first time"", [])  AssignmentExpression(=, [VariableReference(mClosed, []), Expression(true, [])])    VariableReference(mClosed, [])    Expression(true, [])  Statement(}, [])  Statement(synchronized (this) {, [])  Statement(/*, [])  Statement(* Flush out any repeating request. Since camera is closed, no new requests, [])  Statement(* can be queued, and eventually the entire request queue will be drained., [])  Statement(*, [])  Statement(* If the camera device was already closed, short circuit and do nothing, [])  Statement(since, [])  Statement(* no more internal device callbacks will fire anyway., [])  Statement(*, [])  Statement(* Otherwise, once stopRepeating is done, wait for camera to idle, then unconfigure, [])  Statement(* the camera. Once that's done, fire #onClosed., [])  Statement(*/, [])  Statement(try {, [])  MethodCall(mDeviceImpl.stopRepeating(), [VariableReference(mDeviceImpl, []), Expression(, [])])    VariableReference(mDeviceImpl, [])    Expression(, [])  Statement(} catch (IllegalStateException e) {, [])  Statement(// OK: Camera device may already be closed, nothing else to do, [])  Statement(// TODO: Fire onClosed anytime we get the device onClosed or the ISE?, [])  Statement(// or just suppress the ISE only and rely onClosed., [])  Statement(// Also skip any of the draining work if this is already closed., [])  Statement(// Short-circuit, [])  Statement(queue callback immediately and return, [])  MethodCall(mStateCallback.onClosed(this), [VariableReference(mStateCallback, []), Expression(this, [])])    VariableReference(mStateCallback, [])    Expression(this, [])  Statement(return, [])  Statement(} catch (CameraAccessException e) {, [])  Statement(// OK: close does not throw checked exceptions., [])  MethodCall(Log.e(TAG, mIdString + ""Exception while stopping repeating: "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(mIdString + ""Exception while stopping repeating: "", []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(mIdString + ""Exception while stopping repeating: "", [])    Expression(e, [])  Statement(// TODO: call onError instead of onClosed if this happens, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(synchronized (this) {, [])  Statement(// If no sequences are pending, fire #onClosed immediately, [])  MethodCall(mSequenceDrainer.beginDrain(), [VariableReference(mSequenceDrainer, []), Expression(, [])])    VariableReference(mSequenceDrainer, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,,1,"1,3,4",1,3,1,"The early version implementation and late version implementation are different in control dependency. The late version implementation introduces a new ""synchronized (this) {"" block that wraps some of the code inside the method. This new block can potentially change the behavior of the method, as it ensures that only one thread can execute the code inside the block at a time, while in the early version, multiple threads could potentially execute the code simultaneously.","The new ""synchronized (this) {"" block in the late version implementation can potentially cause a compatibility issue, as it can change the method's behavior in a multi-threaded context. In the early version, multiple threads could potentially execute the code inside the method simultaneously, while in the late version, only one thread can execute the code inside the new ""synchronized (this) {"" block at a time. This can potentially lead to different return values or types in the late version, as the execution order of the threads can affect the method's result."
120,<android.app.usage.NetworkStats: void finalize()>,25,26,<android.app.usage.NetworkStats: void finalize()>,<android.app.usage.NetworkStats: void finalize()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), AssignmentExpression(=, [VariableReference(if (mCloseGuard !, []), Expression(null) {, [])]), MethodCall(mCloseGuard.warnIfOpen(), [VariableReference(mCloseGuard, []), Expression(, [])]), Statement(}, []), Statement(close(), []), Statement(} finally {, []), MethodCall(super.finalize(), [VariableReference(super, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(if (mCloseGuard !, []), Expression(null) {, [])])    VariableReference(if (mCloseGuard !, [])    Expression(null) {, [])  MethodCall(mCloseGuard.warnIfOpen(), [VariableReference(mCloseGuard, []), Expression(, [])])    VariableReference(mCloseGuard, [])    Expression(, [])  Statement(}, [])  Statement(close(), [])  Statement(} finally {, [])  MethodCall(super.finalize(), [VariableReference(super, []), Expression(, [])])    VariableReference(super, [])    Expression(, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), AssignmentExpression(=, [VariableReference(if (mCloseGuard !, []), Expression(null) {, [])]), MethodCall(mCloseGuard.warnIfOpen(), [VariableReference(mCloseGuard, []), Expression(, [])]), Statement(}, []), Statement(close(), []), Statement(} finally {, []), MethodCall(super.finalize(), [VariableReference(super, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(if (mCloseGuard !, []), Expression(null) {, [])])    VariableReference(if (mCloseGuard !, [])    Expression(null) {, [])  MethodCall(mCloseGuard.warnIfOpen(), [VariableReference(mCloseGuard, []), Expression(, [])])    VariableReference(mCloseGuard, [])    Expression(, [])  Statement(}, [])  Statement(close(), [])  Statement(} finally {, [])  MethodCall(super.finalize(), [VariableReference(super, []), Expression(, [])])    VariableReference(super, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",0,,,0,[@Override],[@Override],0,,,,0,0,0,0,0,"The AST nodes for the method declaration, the try-catch block, the assignment statement, the method call, and the super.finalize() call are identical between the early and late versions.","There are no changes that could lead to different behaviors in the API. Hence, there is no Compatibility Issue."
123,<android.view.ContextThemeWrapper: Theme getTheme()>,25,26,<android.view.ContextThemeWrapper: Theme getTheme()>,<android.view.ContextThemeWrapper: Theme getTheme()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mTheme !, []), Expression(null) {, [])]), Statement(return mTheme, []), Statement(}, []), AssignmentExpression(=, [VariableReference(mThemeResource, []), Expression(Resources.selectDefaultTheme(mThemeResource, getApplicationInfo().targetSdkVersion), [])]), Statement(initializeTheme(), []), Statement(return mTheme, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mTheme !, []), Expression(null) {, [])])    VariableReference(if (mTheme !, [])    Expression(null) {, [])  Statement(return mTheme, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mThemeResource, []), Expression(Resources.selectDefaultTheme(mThemeResource, getApplicationInfo().targetSdkVersion), [])])    VariableReference(mThemeResource, [])    Expression(Resources.selectDefaultTheme(mThemeResource, getApplicationInfo().targetSdkVersion), [])  Statement(initializeTheme(), [])  Statement(return mTheme, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mTheme !, []), Expression(null) {, [])]), Statement(return mTheme, []), Statement(}, []), AssignmentExpression(=, [VariableReference(mThemeResource, []), Expression(Resources.selectDefaultTheme(mThemeResource, getApplicationInfo().targetSdkVersion), [])]), Statement(initializeTheme(), []), Statement(return mTheme, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mTheme !, []), Expression(null) {, [])])    VariableReference(if (mTheme !, [])    Expression(null) {, [])  Statement(return mTheme, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mThemeResource, []), Expression(Resources.selectDefaultTheme(mThemeResource, getApplicationInfo().targetSdkVersion), [])])    VariableReference(mThemeResource, [])    Expression(Resources.selectDefaultTheme(mThemeResource, getApplicationInfo().targetSdkVersion), [])  Statement(initializeTheme(), [])  Statement(return mTheme, [])  Statement(}, [])",0,,,0,[@Override],[@Override],0,,,,0,0,0,0,0,There is no change between the early and late implementation AST nodes of the method `getTheme()` in the class `ContextThemeWrapper`.,There is no compatibility issue as there is no change in the implementation of the method.
130,"<android.net.ConnectivityManager: void requestNetwork(NetworkRequest,PendingIntent)>",26,27,"<android.net.ConnectivityManager: void requestNetwork(NetworkRequest,PendingIntent)>","<android.net.ConnectivityManager: void requestNetwork(NetworkRequest,PendingIntent)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(checkPendingIntent(operation), []), Statement(try {, []), MethodCall(mService.pendingRequestForNetwork(request.networkCapabilities, operation), [VariableReference(mService, []), Expression(request.networkCapabilities, []), Expression(operation, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(checkPendingIntent(operation), [])  Statement(try {, [])  MethodCall(mService.pendingRequestForNetwork(request.networkCapabilities, operation), [VariableReference(mService, []), Expression(request.networkCapabilities, []), Expression(operation, [])])    VariableReference(mService, [])    Expression(request.networkCapabilities, [])    Expression(operation, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(checkPendingIntentNotNull(operation), []), Statement(try {, []), MethodCall(mService.pendingRequestForNetwork(request.networkCapabilities, operation), [VariableReference(mService, []), Expression(request.networkCapabilities, []), Expression(operation, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(} catch (ServiceSpecificException e) {, []), Statement(throw convertServiceException(e), []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(checkPendingIntentNotNull(operation), [])  Statement(try {, [])  MethodCall(mService.pendingRequestForNetwork(request.networkCapabilities, operation), [VariableReference(mService, []), Expression(request.networkCapabilities, []), Expression(operation, [])])    VariableReference(mService, [])    Expression(request.networkCapabilities, [])    Expression(operation, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(} catch (ServiceSpecificException e) {, [])  Statement(throw convertServiceException(e), [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Request a network to satisfy a set of {@link android.net.NetworkCapabilities}.
 *
 * This function behaves identically to the version that takes a NetworkCallback, but instead
 * of {@link NetworkCallback} a {@link PendingIntent} is used.  This means
 * the request may outlive the calling application and get called back when a suitable
 * network is found.
 * <p>
 * The operation is an Intent broadcast that goes to a broadcast receiver that
 * you registered with {@link Context#registerReceiver} or through the
 * &lt;receiver&gt; tag in an AndroidManifest.xml file
 * <p>
 * The operation Intent is delivered with two extras, a {@link Network} typed
 * extra called {@link #EXTRA_NETWORK} and a {@link NetworkRequest}
 * typed extra called {@link #EXTRA_NETWORK_REQUEST} containing
 * the original requests parameters.  It is important to create a new,
 * {@link NetworkCallback} based request before completing the processing of the
 * Intent to reserve the network or it will be released shortly after the Intent
 * is processed.
 * <p>
 * If there is already a request for this Intent registered (with the equality of
 * two Intents defined by {@link Intent#filterEquals}), then it will be removed and
 * replaced by this one, effectively releasing the previous {@link NetworkRequest}.
 * <p>
 * The request may be released normally by calling
 * {@link #releaseNetworkRequest(android.app.PendingIntent)}.
 * <p>It is presently unsupported to request a network with either
 * {@link NetworkCapabilities#NET_CAPABILITY_VALIDATED} or
 * {@link NetworkCapabilities#NET_CAPABILITY_CAPTIVE_PORTAL}
 * as these {@code NetworkCapabilities} represent states that a particular
 * network may never attain, and whether a network will attain these states
 * is unknown prior to bringing up the network so the framework does not
 * know how to go about satisfing a request with these capabilities.
 *
 * <p>This method requires the caller to hold either the
 * {@link android.Manifest.permission#CHANGE_NETWORK_STATE} permission
 * or the ability to modify system settings as determined by
 * {@link android.provider.Settings.System#canWrite}.</p>
 *
 * @param request {@link NetworkRequest} describing this request.
 * @param operation Action to perform when the network is available (corresponds
 * to the {@link NetworkCallback#onAvailable} call.  Typically
 * comes from {@link PendingIntent#getBroadcast}. Cannot be null.
 * @throws IllegalArgumentException if {@code request} contains either
 * {@link NetworkCapabilities#NET_CAPABILITY_VALIDATED} or
 * {@link NetworkCapabilities#NET_CAPABILITY_CAPTIVE_PORTAL}.
 */","/**
 * Request a network to satisfy a set of {@link android.net.NetworkCapabilities}.
 *
 * This function behaves identically to the version that takes a NetworkCallback, but instead
 * of {@link NetworkCallback} a {@link PendingIntent} is used.  This means
 * the request may outlive the calling application and get called back when a suitable
 * network is found.
 * <p>
 * The operation is an Intent broadcast that goes to a broadcast receiver that
 * you registered with {@link Context#registerReceiver} or through the
 * &lt;receiver&gt; tag in an AndroidManifest.xml file
 * <p>
 * The operation Intent is delivered with two extras, a {@link Network} typed
 * extra called {@link #EXTRA_NETWORK} and a {@link NetworkRequest}
 * typed extra called {@link #EXTRA_NETWORK_REQUEST} containing
 * the original requests parameters.  It is important to create a new,
 * {@link NetworkCallback} based request before completing the processing of the
 * Intent to reserve the network or it will be released shortly after the Intent
 * is processed.
 * <p>
 * If there is already a request for this Intent registered (with the equality of
 * two Intents defined by {@link Intent#filterEquals}), then it will be removed and
 * replaced by this one, effectively releasing the previous {@link NetworkRequest}.
 * <p>
 * The request may be released normally by calling
 * {@link #releaseNetworkRequest(android.app.PendingIntent)}.
 * <p>It is presently unsupported to request a network with either
 * {@link NetworkCapabilities#NET_CAPABILITY_VALIDATED} or
 * {@link NetworkCapabilities#NET_CAPABILITY_CAPTIVE_PORTAL}
 * as these {@code NetworkCapabilities} represent states that a particular
 * network may never attain, and whether a network will attain these states
 * is unknown prior to bringing up the network so the framework does not
 * know how to go about satisfing a request with these capabilities.
 *
 * <p>This method requires the caller to hold either the
 * {@link android.Manifest.permission#CHANGE_NETWORK_STATE} permission
 * or the ability to modify system settings as determined by
 * {@link android.provider.Settings.System#canWrite}.</p>
 *
 * @param request {@link NetworkRequest} describing this request.
 * @param operation Action to perform when the network is available (corresponds
 * to the {@link NetworkCallback#onAvailable} call.  Typically
 * comes from {@link PendingIntent#getBroadcast}. Cannot be null.
 * @throws IllegalArgumentException if {@code request} contains either
 * {@link NetworkCapabilities#NET_CAPABILITY_VALIDATED} or
 * {@link NetworkCapabilities#NET_CAPABILITY_CAPTIVE_PORTAL}.
 */",0,,,0,,,,1,2,2,"2,5","1,2",The first change is that the method name `checkPendingIntent(operation)` has been changed to `checkPendingIntentNotNull(operation)` in the late version. This is a dependent API change (class 5).,
131,"<android.app.FragmentManagerImpl: void dispatchOnFragmentActivityCreated(Fragment,Bundle,boolean)>",26,27,"<android.app.FragmentManagerImpl: void dispatchOnFragmentActivityCreated(Fragment,Bundle,boolean)>","<android.app.FragmentManagerImpl: void dispatchOnFragmentActivityCreated(Fragment,Bundle,boolean)>",0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mParent !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(FragmentManager parentManager, []), Expression(mParent.getFragmentManager(), [])]), Statement(if (parentManager instanceof FragmentManagerImpl) {, []), MethodCall(((FragmentManagerImpl) parentManager).dispatchOnFragmentActivityCreated(f, savedInstanceState, true), [VariableReference(((FragmentManagerImpl) parentManager), []), Expression(f, []), Expression(savedInstanceState, []), Expression(true, [])]), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mLifecycleCallbacks, []), Expression(, [])]), Statement(return, []), Statement(}, []), Statement(for (Pair<FragmentLifecycleCallbacks, Boolean> p : mLifecycleCallbacks) {, []), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mParent !, []), Expression(null) {, [])])    VariableReference(if (mParent !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(FragmentManager parentManager, []), Expression(mParent.getFragmentManager(), [])])    VariableReference(FragmentManager parentManager, [])    Expression(mParent.getFragmentManager(), [])  Statement(if (parentManager instanceof FragmentManagerImpl) {, [])  MethodCall(((FragmentManagerImpl) parentManager).dispatchOnFragmentActivityCreated(f, savedInstanceState, true), [VariableReference(((FragmentManagerImpl) parentManager), []), Expression(f, []), Expression(savedInstanceState, []), Expression(true, [])])    VariableReference(((FragmentManagerImpl) parentManager), [])    Expression(f, [])    Expression(savedInstanceState, [])    Expression(true, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mLifecycleCallbacks, []), Expression(, [])])    VariableReference(if (mLifecycleCallbacks, [])    Expression(, [])  Statement(return, [])  Statement(}, [])  Statement(for (Pair<FragmentLifecycleCallbacks, Boolean> p : mLifecycleCallbacks) {, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mParent !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(FragmentManager parentManager, []), Expression(mParent.getFragmentManager(), [])]), Statement(if (parentManager instanceof FragmentManagerImpl) {, []), MethodCall(((FragmentManagerImpl) parentManager).dispatchOnFragmentActivityCreated(f, savedInstanceState, true), [VariableReference(((FragmentManagerImpl) parentManager), []), Expression(f, []), Expression(savedInstanceState, []), Expression(true, [])]), Statement(}, []), Statement(}, []), Statement(for (Pair<FragmentLifecycleCallbacks, Boolean> p : mLifecycleCallbacks) {, []), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mParent !, []), Expression(null) {, [])])    VariableReference(if (mParent !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(FragmentManager parentManager, []), Expression(mParent.getFragmentManager(), [])])    VariableReference(FragmentManager parentManager, [])    Expression(mParent.getFragmentManager(), [])  Statement(if (parentManager instanceof FragmentManagerImpl) {, [])  MethodCall(((FragmentManagerImpl) parentManager).dispatchOnFragmentActivityCreated(f, savedInstanceState, true), [VariableReference(((FragmentManagerImpl) parentManager), []), Expression(f, []), Expression(savedInstanceState, []), Expression(true, [])])    VariableReference(((FragmentManagerImpl) parentManager), [])    Expression(f, [])    Expression(savedInstanceState, [])    Expression(true, [])  Statement(}, [])  Statement(}, [])  Statement(for (Pair<FragmentLifecycleCallbacks, Boolean> p : mLifecycleCallbacks) {, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])",1,,,0,,,0,,,,1,"1,3",1,0,0,"There is no difference in the AST nodes between the early and late versions of the method, so there is no code change.","Since there is no code change, there is no compatibility issue."
132,<android.service.autofill.SaveInfo.Builder: Builder setDescription(CharSequence)>,26,27,<android.service.autofill.SaveInfo.Builder: Builder setDescription(CharSequence)>,<android.service.autofill.SaveInfo.Builder: Builder setDescription(CharSequence)>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(throwIfDestroyed(), []), AssignmentExpression(=, [VariableReference(mDescription, []), Expression(description, [])]), Statement(return this, []), Statement(}, [])])  Statement({, [])  Statement(throwIfDestroyed(), [])  AssignmentExpression(=, [VariableReference(mDescription, []), Expression(description, [])])    VariableReference(mDescription, [])    Expression(description, [])  Statement(return this, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(throwIfDestroyed(), []), AssignmentExpression(=, [VariableReference(Preconditions.checkState(mCustomDescription, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(mDescription, []), Expression(description, [])]), Statement(return this, []), Statement(}, [])])  Statement({, [])  Statement(throwIfDestroyed(), [])  AssignmentExpression(=, [VariableReference(Preconditions.checkState(mCustomDescription, []), Expression(, [])])    VariableReference(Preconditions.checkState(mCustomDescription, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(mDescription, []), Expression(description, [])])    VariableReference(mDescription, [])    Expression(description, [])  Statement(return this, [])  Statement(}, [])",1,"/**
 * Sets an optional description to be shown in the UI when the user is asked to save.
 *
 * <p>Typically, it describes how the data will be stored by the service, so it can help
 * users to decide whether they can trust the service to save their data.
 *
 * @param description a succint description.
 * @return This Builder.
 */","/**
 * Sets an optional description to be shown in the UI when the user is asked to save.
 *
 * <p>Typically, it describes how the data will be stored by the service, so it can help
 * users to decide whether they can trust the service to save their data.
 *
 * @param description a succint description.
 * @return This Builder.
 *
 * @throws IllegalStateException if this call was made after calling
 * {@link #setCustomDescription(CustomDescription)}.
 */",1,[@NonNull],[@NonNull],0,,,,1,4,0,5,2,"The code change between the two versions is that a new statement has been added to the method body, which is a call to the `Preconditions.checkState()` method. This new statement checks the state of the `mCustomDescription` field and throws an `IllegalStateException` if it is not `null`.","The Compatibility Issue (CI) that arises from this code change is that the method may now throw an `IllegalStateException` in cases where it previously did not. This can cause problems for any code that calls this method and does not expect or handle this exception. This is a CI of type 2, which is related to potential different exception handlings."
137,<android.view.textclassifier.TextSelection.Builder: TextSelection build()>,26,27,<android.view.textclassifier.TextSelection.Builder: TextSelection build()>,<android.view.textclassifier.TextSelection.Builder: TextSelection build()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(return new TextSelection(mStartIndex, mEndIndex, mEntityConfidence, mLogSource), []), Statement(}, [])])  Statement({, [])  Statement(return new TextSelection(mStartIndex, mEndIndex, mEntityConfidence, mLogSource), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return new TextSelection(mStartIndex, mEndIndex, mEntityConfidence, mLogSource, mVersionInfo), []), Statement(}, [])])  Statement({, [])  Statement(return new TextSelection(mStartIndex, mEndIndex, mEntityConfidence, mLogSource, mVersionInfo), [])  Statement(}, [])",1,"/**
 * Builds and returns {@link TextSelection} object.
 */","/**
 * Builds and returns {@link TextSelection} object.
 */",0,,,0,,,,"1,2","1,5",1,1,1,"The return statement in the implementation of the API has changed between the two versions. In the early version, the method returns a new TextSelection object with four parameters, while in the late version, the method returns a new TextSelection object with five parameters, including an additional mVersionInfo parameter.","The change in the return statement of the API could lead to different behaviors when the API is used in different versions. If a client application is written to expect a TextSelection object with four parameters in the early version, it may not be able to handle the object with five parameters returned by the late version, resulting in a compatibility issue. This issue is classified as type 1 - Compatibility Issue caused by potential different return values or types."
138,"<android.app.Notification.BigTextStyle: void applyBigTextContentView(Builder,RemoteViews,CharSequence)>",26,27,"<android.app.Notification.BigTextStyle: void applyBigTextContentView(Builder,RemoteViews,CharSequence)>","<android.app.Notification.BigTextStyle: void applyBigTextContentView(Builder,RemoteViews,CharSequence)>",0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(contentView.setTextViewText(R.id.big_text, bigTextText), [VariableReference(contentView, []), Expression(R.id.big_text, []), Expression(bigTextText, [])]), MethodCall(builder.setTextViewColorSecondary(contentView, R.id.big_text), [VariableReference(builder, []), Expression(contentView, []), Expression(R.id.big_text, [])]), MethodCall(contentView.setViewVisibility(R.id.big_text, TextUtils.isEmpty(bigTextText) ? View.GONE : View.VISIBLE), [VariableReference(contentView, []), Expression(R.id.big_text, []), Expression(TextUtils.isEmpty(bigTextText) ? View.GONE : View.VISIBLE, [])]), MethodCall(contentView.setBoolean(R.id.big_text, ""setHasImage"", builder.mN.hasLargeIcon()), [VariableReference(contentView, []), Expression(R.id.big_text, []), Expression(""setHasImage"", []), Expression(builder.mN.hasLargeIcon(), [])]), Statement(}, [])])  Statement({, [])  MethodCall(contentView.setTextViewText(R.id.big_text, bigTextText), [VariableReference(contentView, []), Expression(R.id.big_text, []), Expression(bigTextText, [])])    VariableReference(contentView, [])    Expression(R.id.big_text, [])    Expression(bigTextText, [])  MethodCall(builder.setTextViewColorSecondary(contentView, R.id.big_text), [VariableReference(builder, []), Expression(contentView, []), Expression(R.id.big_text, [])])    VariableReference(builder, [])    Expression(contentView, [])    Expression(R.id.big_text, [])  MethodCall(contentView.setViewVisibility(R.id.big_text, TextUtils.isEmpty(bigTextText) ? View.GONE : View.VISIBLE), [VariableReference(contentView, []), Expression(R.id.big_text, []), Expression(TextUtils.isEmpty(bigTextText) ? View.GONE : View.VISIBLE, [])])    VariableReference(contentView, [])    Expression(R.id.big_text, [])    Expression(TextUtils.isEmpty(bigTextText) ? View.GONE : View.VISIBLE, [])  MethodCall(contentView.setBoolean(R.id.big_text, ""setHasImage"", builder.mN.hasLargeIcon()), [VariableReference(contentView, []), Expression(R.id.big_text, []), Expression(""setHasImage"", []), Expression(builder.mN.hasLargeIcon(), [])])    VariableReference(contentView, [])    Expression(R.id.big_text, [])    Expression(""setHasImage"", [])    Expression(builder.mN.hasLargeIcon(), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(contentView.setTextViewText(R.id.big_text, builder.processTextSpans(bigTextText)), [VariableReference(contentView, []), Expression(R.id.big_text, []), Expression(builder.processTextSpans(bigTextText), [])]), MethodCall(builder.setTextViewColorSecondary(contentView, R.id.big_text), [VariableReference(builder, []), Expression(contentView, []), Expression(R.id.big_text, [])]), MethodCall(contentView.setViewVisibility(R.id.big_text, TextUtils.isEmpty(bigTextText) ? View.GONE : View.VISIBLE), [VariableReference(contentView, []), Expression(R.id.big_text, []), Expression(TextUtils.isEmpty(bigTextText) ? View.GONE : View.VISIBLE, [])]), MethodCall(contentView.setBoolean(R.id.big_text, ""setHasImage"", builder.mN.hasLargeIcon()), [VariableReference(contentView, []), Expression(R.id.big_text, []), Expression(""setHasImage"", []), Expression(builder.mN.hasLargeIcon(), [])]), Statement(}, [])])  Statement({, [])  MethodCall(contentView.setTextViewText(R.id.big_text, builder.processTextSpans(bigTextText)), [VariableReference(contentView, []), Expression(R.id.big_text, []), Expression(builder.processTextSpans(bigTextText), [])])    VariableReference(contentView, [])    Expression(R.id.big_text, [])    Expression(builder.processTextSpans(bigTextText), [])  MethodCall(builder.setTextViewColorSecondary(contentView, R.id.big_text), [VariableReference(builder, []), Expression(contentView, []), Expression(R.id.big_text, [])])    VariableReference(builder, [])    Expression(contentView, [])    Expression(R.id.big_text, [])  MethodCall(contentView.setViewVisibility(R.id.big_text, TextUtils.isEmpty(bigTextText) ? View.GONE : View.VISIBLE), [VariableReference(contentView, []), Expression(R.id.big_text, []), Expression(TextUtils.isEmpty(bigTextText) ? View.GONE : View.VISIBLE, [])])    VariableReference(contentView, [])    Expression(R.id.big_text, [])    Expression(TextUtils.isEmpty(bigTextText) ? View.GONE : View.VISIBLE, [])  MethodCall(contentView.setBoolean(R.id.big_text, ""setHasImage"", builder.mN.hasLargeIcon()), [VariableReference(contentView, []), Expression(R.id.big_text, []), Expression(""setHasImage"", []), Expression(builder.mN.hasLargeIcon(), [])])    VariableReference(contentView, [])    Expression(R.id.big_text, [])    Expression(""setHasImage"", [])    Expression(builder.mN.hasLargeIcon(), [])  Statement(}, [])",1,,,0,,,0,,,,"1,2",5,0,1,1,"In the late version, the argument passed to the method `setTextViewText` has changed from `bigTextText` to `builder.processTextSpans(bigTextText)`. This change means that the text displayed in the big text view will be processed and potentially modified by the `processTextSpans` method in the late version.","The change in the argument passed to the `setTextViewText` method can lead to a compatibility issue of type 1, where the API potentially returns different values. In this case, the text displayed in the big text view can be different between the early and late versions of the API if the `processTextSpans` method modifies the text."
139,<android.widget.Editor.HandleView: void show()>,26,27,<android.widget.Editor.HandleView: void show()>,<android.widget.Editor.HandleView: void show()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(if (isShowing()), []), Statement(return, []), MethodCall(getPositionListener().addSubscriber(this, true), [VariableReference(getPositionListener(), []), Expression(this, []), Expression(true, [])]), Statement(// Make sure the offset is always considered new, even when focusing at same position, []), AssignmentExpression(=, [VariableReference(mPreviousOffset, []), Expression(-1, [])]), Statement(positionAtCursorOffset(getCurrentCursorOffset(), false), []), Statement(}, [])])  Statement({, [])  Statement(if (isShowing()), [])  Statement(return, [])  MethodCall(getPositionListener().addSubscriber(this, true), [VariableReference(getPositionListener(), []), Expression(this, []), Expression(true, [])])    VariableReference(getPositionListener(), [])    Expression(this, [])    Expression(true, [])  Statement(// Make sure the offset is always considered new, even when focusing at same position, [])  AssignmentExpression(=, [VariableReference(mPreviousOffset, []), Expression(-1, [])])    VariableReference(mPreviousOffset, [])    Expression(-1, [])  Statement(positionAtCursorOffset(getCurrentCursorOffset(), false), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (isShowing()), []), Statement(return, []), MethodCall(getPositionListener().addSubscriber(this, true), [VariableReference(getPositionListener(), []), Expression(this, []), Expression(true, [])]), Statement(// Make sure the offset is always considered new, even when focusing at same position, []), AssignmentExpression(=, [VariableReference(mPreviousOffset, []), Expression(-1, [])]), Statement(positionAtCursorOffset(getCurrentCursorOffset(), false, false), []), Statement(}, [])])  Statement({, [])  Statement(if (isShowing()), [])  Statement(return, [])  MethodCall(getPositionListener().addSubscriber(this, true), [VariableReference(getPositionListener(), []), Expression(this, []), Expression(true, [])])    VariableReference(getPositionListener(), [])    Expression(this, [])    Expression(true, [])  Statement(// Make sure the offset is always considered new, even when focusing at same position, [])  AssignmentExpression(=, [VariableReference(mPreviousOffset, []), Expression(-1, [])])    VariableReference(mPreviousOffset, [])    Expression(-1, [])  Statement(positionAtCursorOffset(getCurrentCursorOffset(), false, false), [])  Statement(}, [])",1,,,0,,,0,,,,2,5,0,5,1,"In the late version, the method call ""positionAtCursorOffset(getCurrentCursorOffset(), false)"" has been changed to ""positionAtCursorOffset(getCurrentCursorOffset(), false, false)"", which indicates a change in the dependent API.","The change in the dependent API ""positionAtCursorOffset"" may cause the API ""show"" to behave differently, as the additional boolean parameter in the late version may affect the positioning of the cursor, leading to a potential compatibility issue of type 1."
140,<android.os.WorkSource: void clear()>,27,28,<android.os.WorkSource: void clear()>,<android.os.WorkSource: void clear()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(mNum, []), Expression(0, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(mNum, []), Expression(0, [])])    VariableReference(mNum, [])    Expression(0, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(mNum, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(if (mChains !, []), Expression(null) {, [])]), MethodCall(mChains.clear(), [VariableReference(mChains, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(mNum, []), Expression(0, [])])    VariableReference(mNum, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(if (mChains !, []), Expression(null) {, [])])    VariableReference(if (mChains !, [])    Expression(null) {, [])  MethodCall(mChains.clear(), [VariableReference(mChains, []), Expression(, [])])    VariableReference(mChains, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Clear this WorkSource to be empty.
 */","/**
 * Clear this WorkSource to be empty.
 */",0,,,0,,,,1,3,0,"1,3,4",1,Three changes have been made in the late version of the code:,3. Other statement changed: A new statement has been added in the late version to assign the mChains variable to null after it has been cleared.
141,<android.app.Notification.Action.Builder: Action build()>,27,28,<android.app.Notification.Action.Builder: Action build()>,<android.app.Notification.Action.Builder: Action build()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(ArrayList<RemoteInput> dataOnlyInputs, []), Expression(new ArrayList<>(), [])]), AssignmentExpression(=, [VariableReference(RemoteInput[] previousDataInputs, []), Expression((RemoteInput[]) mExtras.getParcelableArray(EXTRA_DATA_ONLY_INPUTS), [])]), AssignmentExpression(=, [VariableReference(if (previousDataInputs !, []), Expression(null) {, [])]), Statement(for (RemoteInput input : previousDataInputs) {, []), MethodCall(dataOnlyInputs.add(input), [VariableReference(dataOnlyInputs, []), Expression(input, [])]), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(List<RemoteInput> textInputs, []), Expression(new ArrayList<>(), [])]), AssignmentExpression(=, [VariableReference(if (mRemoteInputs !, []), Expression(null) {, [])]), Statement(for (RemoteInput input : mRemoteInputs) {, []), MethodCall(if (input.isDataOnly()), [VariableReference(if (input, []), Expression(), [])]), MethodCall(dataOnlyInputs.add(input), [VariableReference(dataOnlyInputs, []), Expression(input, [])]), Statement(} else {, []), MethodCall(textInputs.add(input), [VariableReference(textInputs, []), Expression(input, [])]), Statement(}, []), Statement(}, []), Statement(}, []), MethodCall(if (!dataOnlyInputs.isEmpty()), [VariableReference(if (!dataOnlyInputs, []), Expression(), [])]), AssignmentExpression(=, [VariableReference(RemoteInput[] dataInputsArr, []), Expression(dataOnlyInputs.toArray(new RemoteInput[dataOnlyInputs.size()]), [])]), MethodCall(mExtras.putParcelableArray(EXTRA_DATA_ONLY_INPUTS, dataInputsArr), [VariableReference(mExtras, []), Expression(EXTRA_DATA_ONLY_INPUTS, []), Expression(dataInputsArr, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(RemoteInput[] textInputsArr, []), Expression(textInputs.isEmpty() ? null : textInputs.toArray(new RemoteInput[textInputs.size()]), [])]), Statement(return new Action(mIcon, mTitle, mIntent, mExtras, textInputsArr, mAllowGeneratedReplies), []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(ArrayList<RemoteInput> dataOnlyInputs, []), Expression(new ArrayList<>(), [])])    VariableReference(ArrayList<RemoteInput> dataOnlyInputs, [])    Expression(new ArrayList<>(), [])  AssignmentExpression(=, [VariableReference(RemoteInput[] previousDataInputs, []), Expression((RemoteInput[]) mExtras.getParcelableArray(EXTRA_DATA_ONLY_INPUTS), [])])    VariableReference(RemoteInput[] previousDataInputs, [])    Expression((RemoteInput[]) mExtras.getParcelableArray(EXTRA_DATA_ONLY_INPUTS), [])  AssignmentExpression(=, [VariableReference(if (previousDataInputs !, []), Expression(null) {, [])])    VariableReference(if (previousDataInputs !, [])    Expression(null) {, [])  Statement(for (RemoteInput input : previousDataInputs) {, [])  MethodCall(dataOnlyInputs.add(input), [VariableReference(dataOnlyInputs, []), Expression(input, [])])    VariableReference(dataOnlyInputs, [])    Expression(input, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(List<RemoteInput> textInputs, []), Expression(new ArrayList<>(), [])])    VariableReference(List<RemoteInput> textInputs, [])    Expression(new ArrayList<>(), [])  AssignmentExpression(=, [VariableReference(if (mRemoteInputs !, []), Expression(null) {, [])])    VariableReference(if (mRemoteInputs !, [])    Expression(null) {, [])  Statement(for (RemoteInput input : mRemoteInputs) {, [])  MethodCall(if (input.isDataOnly()), [VariableReference(if (input, []), Expression(), [])])    VariableReference(if (input, [])    Expression(), [])  MethodCall(dataOnlyInputs.add(input), [VariableReference(dataOnlyInputs, []), Expression(input, [])])    VariableReference(dataOnlyInputs, [])    Expression(input, [])  Statement(} else {, [])  MethodCall(textInputs.add(input), [VariableReference(textInputs, []), Expression(input, [])])    VariableReference(textInputs, [])    Expression(input, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  MethodCall(if (!dataOnlyInputs.isEmpty()), [VariableReference(if (!dataOnlyInputs, []), Expression(), [])])    VariableReference(if (!dataOnlyInputs, [])    Expression(), [])  AssignmentExpression(=, [VariableReference(RemoteInput[] dataInputsArr, []), Expression(dataOnlyInputs.toArray(new RemoteInput[dataOnlyInputs.size()]), [])])    VariableReference(RemoteInput[] dataInputsArr, [])    Expression(dataOnlyInputs.toArray(new RemoteInput[dataOnlyInputs.size()]), [])  MethodCall(mExtras.putParcelableArray(EXTRA_DATA_ONLY_INPUTS, dataInputsArr), [VariableReference(mExtras, []), Expression(EXTRA_DATA_ONLY_INPUTS, []), Expression(dataInputsArr, [])])    VariableReference(mExtras, [])    Expression(EXTRA_DATA_ONLY_INPUTS, [])    Expression(dataInputsArr, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(RemoteInput[] textInputsArr, []), Expression(textInputs.isEmpty() ? null : textInputs.toArray(new RemoteInput[textInputs.size()]), [])])    VariableReference(RemoteInput[] textInputsArr, [])    Expression(textInputs.isEmpty() ? null : textInputs.toArray(new RemoteInput[textInputs.size()]), [])  Statement(return new Action(mIcon, mTitle, mIntent, mExtras, textInputsArr, mAllowGeneratedReplies), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(ArrayList<RemoteInput> dataOnlyInputs, []), Expression(new ArrayList<>(), [])]), AssignmentExpression(=, [VariableReference(RemoteInput[] previousDataInputs, []), Expression((RemoteInput[]) mExtras.getParcelableArray(EXTRA_DATA_ONLY_INPUTS), [])]), AssignmentExpression(=, [VariableReference(if (previousDataInputs !, []), Expression(null) {, [])]), Statement(for (RemoteInput input : previousDataInputs) {, []), MethodCall(dataOnlyInputs.add(input), [VariableReference(dataOnlyInputs, []), Expression(input, [])]), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(List<RemoteInput> textInputs, []), Expression(new ArrayList<>(), [])]), AssignmentExpression(=, [VariableReference(if (mRemoteInputs !, []), Expression(null) {, [])]), Statement(for (RemoteInput input : mRemoteInputs) {, []), MethodCall(if (input.isDataOnly()), [VariableReference(if (input, []), Expression(), [])]), MethodCall(dataOnlyInputs.add(input), [VariableReference(dataOnlyInputs, []), Expression(input, [])]), Statement(} else {, []), MethodCall(textInputs.add(input), [VariableReference(textInputs, []), Expression(input, [])]), Statement(}, []), Statement(}, []), Statement(}, []), MethodCall(if (!dataOnlyInputs.isEmpty()), [VariableReference(if (!dataOnlyInputs, []), Expression(), [])]), AssignmentExpression(=, [VariableReference(RemoteInput[] dataInputsArr, []), Expression(dataOnlyInputs.toArray(new RemoteInput[dataOnlyInputs.size()]), [])]), MethodCall(mExtras.putParcelableArray(EXTRA_DATA_ONLY_INPUTS, dataInputsArr), [VariableReference(mExtras, []), Expression(EXTRA_DATA_ONLY_INPUTS, []), Expression(dataInputsArr, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(RemoteInput[] textInputsArr, []), Expression(textInputs.isEmpty() ? null : textInputs.toArray(new RemoteInput[textInputs.size()]), [])]), Statement(return new Action(mIcon, mTitle, mIntent, mExtras, textInputsArr, mAllowGeneratedReplies, mSemanticAction), []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(ArrayList<RemoteInput> dataOnlyInputs, []), Expression(new ArrayList<>(), [])])    VariableReference(ArrayList<RemoteInput> dataOnlyInputs, [])    Expression(new ArrayList<>(), [])  AssignmentExpression(=, [VariableReference(RemoteInput[] previousDataInputs, []), Expression((RemoteInput[]) mExtras.getParcelableArray(EXTRA_DATA_ONLY_INPUTS), [])])    VariableReference(RemoteInput[] previousDataInputs, [])    Expression((RemoteInput[]) mExtras.getParcelableArray(EXTRA_DATA_ONLY_INPUTS), [])  AssignmentExpression(=, [VariableReference(if (previousDataInputs !, []), Expression(null) {, [])])    VariableReference(if (previousDataInputs !, [])    Expression(null) {, [])  Statement(for (RemoteInput input : previousDataInputs) {, [])  MethodCall(dataOnlyInputs.add(input), [VariableReference(dataOnlyInputs, []), Expression(input, [])])    VariableReference(dataOnlyInputs, [])    Expression(input, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(List<RemoteInput> textInputs, []), Expression(new ArrayList<>(), [])])    VariableReference(List<RemoteInput> textInputs, [])    Expression(new ArrayList<>(), [])  AssignmentExpression(=, [VariableReference(if (mRemoteInputs !, []), Expression(null) {, [])])    VariableReference(if (mRemoteInputs !, [])    Expression(null) {, [])  Statement(for (RemoteInput input : mRemoteInputs) {, [])  MethodCall(if (input.isDataOnly()), [VariableReference(if (input, []), Expression(), [])])    VariableReference(if (input, [])    Expression(), [])  MethodCall(dataOnlyInputs.add(input), [VariableReference(dataOnlyInputs, []), Expression(input, [])])    VariableReference(dataOnlyInputs, [])    Expression(input, [])  Statement(} else {, [])  MethodCall(textInputs.add(input), [VariableReference(textInputs, []), Expression(input, [])])    VariableReference(textInputs, [])    Expression(input, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  MethodCall(if (!dataOnlyInputs.isEmpty()), [VariableReference(if (!dataOnlyInputs, []), Expression(), [])])    VariableReference(if (!dataOnlyInputs, [])    Expression(), [])  AssignmentExpression(=, [VariableReference(RemoteInput[] dataInputsArr, []), Expression(dataOnlyInputs.toArray(new RemoteInput[dataOnlyInputs.size()]), [])])    VariableReference(RemoteInput[] dataInputsArr, [])    Expression(dataOnlyInputs.toArray(new RemoteInput[dataOnlyInputs.size()]), [])  MethodCall(mExtras.putParcelableArray(EXTRA_DATA_ONLY_INPUTS, dataInputsArr), [VariableReference(mExtras, []), Expression(EXTRA_DATA_ONLY_INPUTS, []), Expression(dataInputsArr, [])])    VariableReference(mExtras, [])    Expression(EXTRA_DATA_ONLY_INPUTS, [])    Expression(dataInputsArr, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(RemoteInput[] textInputsArr, []), Expression(textInputs.isEmpty() ? null : textInputs.toArray(new RemoteInput[textInputs.size()]), [])])    VariableReference(RemoteInput[] textInputsArr, [])    Expression(textInputs.isEmpty() ? null : textInputs.toArray(new RemoteInput[textInputs.size()]), [])  Statement(return new Action(mIcon, mTitle, mIntent, mExtras, textInputsArr, mAllowGeneratedReplies, mSemanticAction), [])  Statement(}, [])",1,"/**
 * Combine all of the options that have been set and return a new {@link Action}
 * object.
 * @return the built action
 */","/**
 * Combine all of the options that have been set and return a new {@link Action}
 * object.
 * @return the built action
 */",0,,,0,,,,2,"1,5",1,4,0,"The implementation of the method `build()` has been changed by adding an additional parameter `mSemanticAction` to the constructor of the `Action` class. However, this change does not affect the behavior of the method as it only adds an additional field to the `Action` object.",There is no compatibility issue in this change as it does not affect the behavior of the method. The additional field added to the `Action` object is only used for providing additional information and does not affect the functionality of the method.
142,"<android.net.NetworkCapabilities: void writeToParcel(Parcel,int)>",27,28,"<android.net.NetworkCapabilities: void writeToParcel(Parcel,int)>","<android.net.NetworkCapabilities: void writeToParcel(Parcel,int)>",0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(dest.writeLong(mNetworkCapabilities), [VariableReference(dest, []), Expression(mNetworkCapabilities, [])]), MethodCall(dest.writeLong(mTransportTypes), [VariableReference(dest, []), Expression(mTransportTypes, [])]), MethodCall(dest.writeInt(mLinkUpBandwidthKbps), [VariableReference(dest, []), Expression(mLinkUpBandwidthKbps, [])]), MethodCall(dest.writeInt(mLinkDownBandwidthKbps), [VariableReference(dest, []), Expression(mLinkDownBandwidthKbps, [])]), MethodCall(dest.writeParcelable((Parcelable) mNetworkSpecifier, flags), [VariableReference(dest, []), Expression((Parcelable) mNetworkSpecifier, []), Expression(flags, [])]), MethodCall(dest.writeInt(mSignalStrength), [VariableReference(dest, []), Expression(mSignalStrength, [])]), Statement(}, [])])  Statement({, [])  MethodCall(dest.writeLong(mNetworkCapabilities), [VariableReference(dest, []), Expression(mNetworkCapabilities, [])])    VariableReference(dest, [])    Expression(mNetworkCapabilities, [])  MethodCall(dest.writeLong(mTransportTypes), [VariableReference(dest, []), Expression(mTransportTypes, [])])    VariableReference(dest, [])    Expression(mTransportTypes, [])  MethodCall(dest.writeInt(mLinkUpBandwidthKbps), [VariableReference(dest, []), Expression(mLinkUpBandwidthKbps, [])])    VariableReference(dest, [])    Expression(mLinkUpBandwidthKbps, [])  MethodCall(dest.writeInt(mLinkDownBandwidthKbps), [VariableReference(dest, []), Expression(mLinkDownBandwidthKbps, [])])    VariableReference(dest, [])    Expression(mLinkDownBandwidthKbps, [])  MethodCall(dest.writeParcelable((Parcelable) mNetworkSpecifier, flags), [VariableReference(dest, []), Expression((Parcelable) mNetworkSpecifier, []), Expression(flags, [])])    VariableReference(dest, [])    Expression((Parcelable) mNetworkSpecifier, [])    Expression(flags, [])  MethodCall(dest.writeInt(mSignalStrength), [VariableReference(dest, []), Expression(mSignalStrength, [])])    VariableReference(dest, [])    Expression(mSignalStrength, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(dest.writeLong(mNetworkCapabilities), [VariableReference(dest, []), Expression(mNetworkCapabilities, [])]), MethodCall(dest.writeLong(mUnwantedNetworkCapabilities), [VariableReference(dest, []), Expression(mUnwantedNetworkCapabilities, [])]), MethodCall(dest.writeLong(mTransportTypes), [VariableReference(dest, []), Expression(mTransportTypes, [])]), MethodCall(dest.writeInt(mLinkUpBandwidthKbps), [VariableReference(dest, []), Expression(mLinkUpBandwidthKbps, [])]), MethodCall(dest.writeInt(mLinkDownBandwidthKbps), [VariableReference(dest, []), Expression(mLinkDownBandwidthKbps, [])]), MethodCall(dest.writeParcelable((Parcelable) mNetworkSpecifier, flags), [VariableReference(dest, []), Expression((Parcelable) mNetworkSpecifier, []), Expression(flags, [])]), MethodCall(dest.writeInt(mSignalStrength), [VariableReference(dest, []), Expression(mSignalStrength, [])]), MethodCall(dest.writeArraySet(mUids), [VariableReference(dest, []), Expression(mUids, [])]), MethodCall(dest.writeString(mSSID), [VariableReference(dest, []), Expression(mSSID, [])]), Statement(}, [])])  Statement({, [])  MethodCall(dest.writeLong(mNetworkCapabilities), [VariableReference(dest, []), Expression(mNetworkCapabilities, [])])    VariableReference(dest, [])    Expression(mNetworkCapabilities, [])  MethodCall(dest.writeLong(mUnwantedNetworkCapabilities), [VariableReference(dest, []), Expression(mUnwantedNetworkCapabilities, [])])    VariableReference(dest, [])    Expression(mUnwantedNetworkCapabilities, [])  MethodCall(dest.writeLong(mTransportTypes), [VariableReference(dest, []), Expression(mTransportTypes, [])])    VariableReference(dest, [])    Expression(mTransportTypes, [])  MethodCall(dest.writeInt(mLinkUpBandwidthKbps), [VariableReference(dest, []), Expression(mLinkUpBandwidthKbps, [])])    VariableReference(dest, [])    Expression(mLinkUpBandwidthKbps, [])  MethodCall(dest.writeInt(mLinkDownBandwidthKbps), [VariableReference(dest, []), Expression(mLinkDownBandwidthKbps, [])])    VariableReference(dest, [])    Expression(mLinkDownBandwidthKbps, [])  MethodCall(dest.writeParcelable((Parcelable) mNetworkSpecifier, flags), [VariableReference(dest, []), Expression((Parcelable) mNetworkSpecifier, []), Expression(flags, [])])    VariableReference(dest, [])    Expression((Parcelable) mNetworkSpecifier, [])    Expression(flags, [])  MethodCall(dest.writeInt(mSignalStrength), [VariableReference(dest, []), Expression(mSignalStrength, [])])    VariableReference(dest, [])    Expression(mSignalStrength, [])  MethodCall(dest.writeArraySet(mUids), [VariableReference(dest, []), Expression(mUids, [])])    VariableReference(dest, [])    Expression(mUids, [])  MethodCall(dest.writeString(mSSID), [VariableReference(dest, []), Expression(mSSID, [])])    VariableReference(dest, [])    Expression(mSSID, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,,1,4,0,5,1,"In the late version of the implementation, two new statements are added, and the order of some statements has changed. The two new statements are MethodCall(dest.writeLong(mUnwantedNetworkCapabilities)) and MethodCall(dest.writeArraySet(mUids)). This is a Dependent API change, as the new statements are invoking different methods.","The Compatibility Issue is caused by the potential for different return values or types. The addition of the new statements in the late version means that the Parcel object being written to will contain additional information. This could potentially result in a different object being created when the Parcel is later read, leading to a Compatibility Issue."
143,<android.view.textclassifier.TextClassification: String toString()>,27,28,<android.view.textclassifier.TextClassification: String toString()>,<android.view.textclassifier.TextClassification: String toString()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(return String.format(""TextClassification {"" + ""text, []), Expression(%s, entities, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(return String.format(""TextClassification {"" + ""text, []), Expression(%s, entities, [])])    VariableReference(return String.format(""TextClassification {"" + ""text, [])    Expression(%s, entities, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(return String.format(Locale.US, ""TextClassification {text, []), Expression(%s, entities, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(return String.format(Locale.US, ""TextClassification {text, []), Expression(%s, entities, [])])    VariableReference(return String.format(Locale.US, ""TextClassification {text, [])    Expression(%s, entities, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,,"1,2","1,5",1,4,1,"The change in the code is that the `String.format()` method in the return statement of the `toString()` method has been modified to include the `Locale.US` parameter. This is considered an ""Other statement changed"" type of change (code change type 4), as it does not involve a change in the return statement itself, exception handling, control dependency, or dependent API.","The modification of the `String.format()` method to include the `Locale.US` parameter can potentially lead to a Compatibility Issue (CI) of type 1, which is a CI caused by potential different return values or types. This is because the behavior of the `String.format()` method can vary depending on the locale, and thus the inclusion of the `Locale.US` parameter can result in a different string being returned by the `toString()` method in certain cases. For example, if the device's default locale uses a different decimal separator than the US locale (e.g., a comma instead of a period), then formatting a number with `String.format()` may result in a different string in the early version (without `Locale.US`) compared to the late version (with `Locale.US`)."
145,"<android.util.proto.ProtoOutputStream: void writeRepeatedObject(long,byte[])>",27,28,"<android.util.proto.ProtoOutputStream: void writeRepeatedObject(long,byte[])>","<android.util.proto.ProtoOutputStream: void writeRepeatedObject(long,byte[])>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(assertNotCompacted(), []), AssignmentExpression(=, [VariableReference(final int id, []), Expression(checkFieldId(fieldId, FIELD_COUNT_REPEATED | FIELD_TYPE_OBJECT), [])]), Statement(writeRepeatedObjectImpl(id, value), []), Statement(}, [])])  Statement({, [])  Statement(assertNotCompacted(), [])  AssignmentExpression(=, [VariableReference(final int id, []), Expression(checkFieldId(fieldId, FIELD_COUNT_REPEATED | FIELD_TYPE_OBJECT), [])])    VariableReference(final int id, [])    Expression(checkFieldId(fieldId, FIELD_COUNT_REPEATED | FIELD_TYPE_OBJECT), [])  Statement(writeRepeatedObjectImpl(id, value), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(assertNotCompacted(), []), AssignmentExpression(=, [VariableReference(final int id, []), Expression(checkFieldId(fieldId, FIELD_COUNT_REPEATED | FIELD_TYPE_MESSAGE), [])]), Statement(writeRepeatedObjectImpl(id, value), []), Statement(}, [])])  Statement({, [])  Statement(assertNotCompacted(), [])  AssignmentExpression(=, [VariableReference(final int id, []), Expression(checkFieldId(fieldId, FIELD_COUNT_REPEATED | FIELD_TYPE_MESSAGE), [])])    VariableReference(final int id, [])    Expression(checkFieldId(fieldId, FIELD_COUNT_REPEATED | FIELD_TYPE_MESSAGE), [])  Statement(writeRepeatedObjectImpl(id, value), [])  Statement(}, [])",1,"/**
 * Write an object that has already been flattend.
 *
 * @deprecated Use #write instead.
 */","/**
 * Write an object that has already been flattend.
 *
 * @deprecated Use #write instead.
 */",0,[@Deprecated],[@Deprecated],0,,,,2,5,0,5,1,"In the late version, the parameter type in the method `checkFieldId` has changed from `FIELD_TYPE_OBJECT` to `FIELD_TYPE_MESSAGE`. This change might potentially lead to different return values in the method `writeRepeatedObject`.","As the parameter type in the method `checkFieldId` has changed, it might cause the method `writeRepeatedObject` to return different values in the late version, which is a Compatibility Issue."
146,<android.view.textclassifier.TextClassification: int getEntityCount()>,27,28,<android.view.textclassifier.TextClassification: int getEntityCount()>,<android.view.textclassifier.TextClassification: int getEntityCount()>,0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(return mEntities.size(), [VariableReference(return mEntities, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return mEntities.size(), [VariableReference(return mEntities, []), Expression(, [])])    VariableReference(return mEntities, [])    Expression(, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(return mEntityConfidence.getEntities().size(), [VariableReference(return mEntityConfidence, []), Expression().size(, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return mEntityConfidence.getEntities().size(), [VariableReference(return mEntityConfidence, []), Expression().size(, [])])    VariableReference(return mEntityConfidence, [])    Expression().size(, [])  Statement(}, [])",1,"/**
 * Returns the number of entities found in the classified text.
 */","/**
 * Returns the number of entities found in the classified text.
 */",1,[@IntRange(from = 0)],[@IntRange(from = 0)],0,,,,1.2,"1,5",1,1,1,"The return statement of the method has changed from ""return mEntities.size()"" to ""return mEntityConfidence.getEntities().size()"". This indicates that the source of the data being returned has changed, potentially leading to different values being returned.",The Compatibility Issue arises due to the potential for different values being returned by the method in different versions. This could cause unexpected behavior in any code that relies on the value returned by this method.
147,<android.view.accessibility.AccessibilityWindowInfo: boolean isInPictureInPictureMode()>,27,28,<android.view.accessibility.AccessibilityWindowInfo: boolean isInPictureInPictureMode()>,<android.view.accessibility.AccessibilityWindowInfo: boolean isInPictureInPictureMode()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(return mInPictureInPicture, []), Statement(}, [])])  Statement({, [])  Statement(return mInPictureInPicture, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return getBooleanProperty(BOOLEAN_PROPERTY_PICTURE_IN_PICTURE), []), Statement(}, [])])  Statement({, [])  Statement(return getBooleanProperty(BOOLEAN_PROPERTY_PICTURE_IN_PICTURE), [])  Statement(}, [])",1,"/**
 * Check if the window is in picture-in-picture mode.
 *
 * @return {@code true} if the window is in picture-in-picture mode, {@code false} otherwise.
 */","/**
 * Check if the window is in picture-in-picture mode.
 *
 * @return {@code true} if the window is in picture-in-picture mode, {@code false} otherwise.
 */",0,,,0,,,,1,1,1,5,1,The implementation of the method has changed from using a member variable `mInPictureInPicture` to using a method call `getBooleanProperty(BOOLEAN_PROPERTY_PICTURE_IN_PICTURE)`. This is a change in the dependent API.,"The change in the dependent API can potentially cause the method to return a different value, as the implementation of `getBooleanProperty` may have changed or the value of the boolean property may be determined differently. Therefore, this is a compatibility issue caused by potential different return values."
149,<android.companion.CompanionDeviceManager.CallbackProxy: void onSuccess(PendingIntent)>,27,28,<android.companion.CompanionDeviceManager.CallbackProxy: void onSuccess(PendingIntent)>,<android.companion.CompanionDeviceManager.CallbackProxy: void onSuccess(PendingIntent)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(Handler handler, []), Expression(mHandler, [])]), AssignmentExpression(=, [VariableReference(if (handler, []), Expression(, [])]), Statement(return, []), MethodCall(handler.post((), [VariableReference(handler, []), Expression((, [])]), AssignmentExpression(=, [VariableReference(Callback callback, []), Expression(mCallback, [])]), AssignmentExpression(=, [VariableReference(if (callback, []), Expression(, [])]), Statement(return, []), MethodCall(callback.onDeviceFound(launcher.getIntentSender()), [VariableReference(callback, []), Expression(launcher.getIntentSender(), [])]), Statement(}), []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(Handler handler, []), Expression(mHandler, [])])    VariableReference(Handler handler, [])    Expression(mHandler, [])  AssignmentExpression(=, [VariableReference(if (handler, []), Expression(, [])])    VariableReference(if (handler, [])    Expression(, [])  Statement(return, [])  MethodCall(handler.post((), [VariableReference(handler, []), Expression((, [])])    VariableReference(handler, [])    Expression((, [])  AssignmentExpression(=, [VariableReference(Callback callback, []), Expression(mCallback, [])])    VariableReference(Callback callback, [])    Expression(mCallback, [])  AssignmentExpression(=, [VariableReference(if (callback, []), Expression(, [])])    VariableReference(if (callback, [])    Expression(, [])  Statement(return, [])  MethodCall(callback.onDeviceFound(launcher.getIntentSender()), [VariableReference(callback, []), Expression(launcher.getIntentSender(), [])])    VariableReference(callback, [])    Expression(launcher.getIntentSender(), [])  Statement(}), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(lockAndPost(Callback::onDeviceFound, launcher.getIntentSender()), [VariableReference(lockAndPost(Callback::onDeviceFound, launcher, []), Expression(), [])]), Statement(}, [])])  Statement({, [])  MethodCall(lockAndPost(Callback::onDeviceFound, launcher.getIntentSender()), [VariableReference(lockAndPost(Callback::onDeviceFound, launcher, []), Expression(), [])])    VariableReference(lockAndPost(Callback::onDeviceFound, launcher, [])    Expression(), [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,,1,"1,3,4",1,5,1,"The entire implementation of the method was changed between the early and late versions. The early version checks for the existence of a Handler object and a Callback object, and if they exist, it uses them to post a message or call a method respectively. If either object does not exist, the method simply returns.",
158,"<android.service.notification.ZenModeConfig.ZenRule: void writeToParcel(Parcel,int)>",28,29,"<android.service.notification.ZenModeConfig.ZenRule: void writeToParcel(Parcel,int)>","<android.service.notification.ZenModeConfig.ZenRule: void writeToParcel(Parcel,int)>",0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(dest.writeInt(enabled ? 1 : 0), [VariableReference(dest, []), Expression(enabled ? 1 : 0, [])]), MethodCall(dest.writeInt(snoozing ? 1 : 0), [VariableReference(dest, []), Expression(snoozing ? 1 : 0, [])]), AssignmentExpression(=, [VariableReference(if (name !, []), Expression(null) {, [])]), MethodCall(dest.writeInt(1), [VariableReference(dest, []), Expression(1, [])]), MethodCall(dest.writeString(name), [VariableReference(dest, []), Expression(name, [])]), Statement(} else {, []), MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])]), Statement(}, []), MethodCall(dest.writeInt(zenMode), [VariableReference(dest, []), Expression(zenMode, [])]), MethodCall(dest.writeParcelable(conditionId, 0), [VariableReference(dest, []), Expression(conditionId, []), Expression(0, [])]), MethodCall(dest.writeParcelable(condition, 0), [VariableReference(dest, []), Expression(condition, []), Expression(0, [])]), MethodCall(dest.writeParcelable(component, 0), [VariableReference(dest, []), Expression(component, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(if (id !, []), Expression(null) {, [])]), MethodCall(dest.writeInt(1), [VariableReference(dest, []), Expression(1, [])]), MethodCall(dest.writeString(id), [VariableReference(dest, []), Expression(id, [])]), Statement(} else {, []), MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])]), Statement(}, []), MethodCall(dest.writeLong(creationTime), [VariableReference(dest, []), Expression(creationTime, [])]), AssignmentExpression(=, [VariableReference(if (enabler !, []), Expression(null) {, [])]), MethodCall(dest.writeInt(1), [VariableReference(dest, []), Expression(1, [])]), MethodCall(dest.writeString(enabler), [VariableReference(dest, []), Expression(enabler, [])]), Statement(} else {, []), MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  MethodCall(dest.writeInt(enabled ? 1 : 0), [VariableReference(dest, []), Expression(enabled ? 1 : 0, [])])    VariableReference(dest, [])    Expression(enabled ? 1 : 0, [])  MethodCall(dest.writeInt(snoozing ? 1 : 0), [VariableReference(dest, []), Expression(snoozing ? 1 : 0, [])])    VariableReference(dest, [])    Expression(snoozing ? 1 : 0, [])  AssignmentExpression(=, [VariableReference(if (name !, []), Expression(null) {, [])])    VariableReference(if (name !, [])    Expression(null) {, [])  MethodCall(dest.writeInt(1), [VariableReference(dest, []), Expression(1, [])])    VariableReference(dest, [])    Expression(1, [])  MethodCall(dest.writeString(name), [VariableReference(dest, []), Expression(name, [])])    VariableReference(dest, [])    Expression(name, [])  Statement(} else {, [])  MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])])    VariableReference(dest, [])    Expression(0, [])  Statement(}, [])  MethodCall(dest.writeInt(zenMode), [VariableReference(dest, []), Expression(zenMode, [])])    VariableReference(dest, [])    Expression(zenMode, [])  MethodCall(dest.writeParcelable(conditionId, 0), [VariableReference(dest, []), Expression(conditionId, []), Expression(0, [])])    VariableReference(dest, [])    Expression(conditionId, [])    Expression(0, [])  MethodCall(dest.writeParcelable(condition, 0), [VariableReference(dest, []), Expression(condition, []), Expression(0, [])])    VariableReference(dest, [])    Expression(condition, [])    Expression(0, [])  MethodCall(dest.writeParcelable(component, 0), [VariableReference(dest, []), Expression(component, []), Expression(0, [])])    VariableReference(dest, [])    Expression(component, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(if (id !, []), Expression(null) {, [])])    VariableReference(if (id !, [])    Expression(null) {, [])  MethodCall(dest.writeInt(1), [VariableReference(dest, []), Expression(1, [])])    VariableReference(dest, [])    Expression(1, [])  MethodCall(dest.writeString(id), [VariableReference(dest, []), Expression(id, [])])    VariableReference(dest, [])    Expression(id, [])  Statement(} else {, [])  MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])])    VariableReference(dest, [])    Expression(0, [])  Statement(}, [])  MethodCall(dest.writeLong(creationTime), [VariableReference(dest, []), Expression(creationTime, [])])    VariableReference(dest, [])    Expression(creationTime, [])  AssignmentExpression(=, [VariableReference(if (enabler !, []), Expression(null) {, [])])    VariableReference(if (enabler !, [])    Expression(null) {, [])  MethodCall(dest.writeInt(1), [VariableReference(dest, []), Expression(1, [])])    VariableReference(dest, [])    Expression(1, [])  MethodCall(dest.writeString(enabler), [VariableReference(dest, []), Expression(enabler, [])])    VariableReference(dest, [])    Expression(enabler, [])  Statement(} else {, [])  MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])])    VariableReference(dest, [])    Expression(0, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(dest.writeInt(enabled ? 1 : 0), [VariableReference(dest, []), Expression(enabled ? 1 : 0, [])]), MethodCall(dest.writeInt(snoozing ? 1 : 0), [VariableReference(dest, []), Expression(snoozing ? 1 : 0, [])]), AssignmentExpression(=, [VariableReference(if (name !, []), Expression(null) {, [])]), MethodCall(dest.writeInt(1), [VariableReference(dest, []), Expression(1, [])]), MethodCall(dest.writeString(name), [VariableReference(dest, []), Expression(name, [])]), Statement(} else {, []), MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])]), Statement(}, []), MethodCall(dest.writeInt(zenMode), [VariableReference(dest, []), Expression(zenMode, [])]), MethodCall(dest.writeParcelable(conditionId, 0), [VariableReference(dest, []), Expression(conditionId, []), Expression(0, [])]), MethodCall(dest.writeParcelable(condition, 0), [VariableReference(dest, []), Expression(condition, []), Expression(0, [])]), MethodCall(dest.writeParcelable(component, 0), [VariableReference(dest, []), Expression(component, []), Expression(0, [])]), MethodCall(dest.writeParcelable(configurationActivity, 0), [VariableReference(dest, []), Expression(configurationActivity, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(if (id !, []), Expression(null) {, [])]), MethodCall(dest.writeInt(1), [VariableReference(dest, []), Expression(1, [])]), MethodCall(dest.writeString(id), [VariableReference(dest, []), Expression(id, [])]), Statement(} else {, []), MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])]), Statement(}, []), MethodCall(dest.writeLong(creationTime), [VariableReference(dest, []), Expression(creationTime, [])]), AssignmentExpression(=, [VariableReference(if (enabler !, []), Expression(null) {, [])]), MethodCall(dest.writeInt(1), [VariableReference(dest, []), Expression(1, [])]), MethodCall(dest.writeString(enabler), [VariableReference(dest, []), Expression(enabler, [])]), Statement(} else {, []), MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])]), Statement(}, []), MethodCall(dest.writeParcelable(zenPolicy, 0), [VariableReference(dest, []), Expression(zenPolicy, []), Expression(0, [])]), MethodCall(dest.writeInt(modified ? 1 : 0), [VariableReference(dest, []), Expression(modified ? 1 : 0, [])]), MethodCall(dest.writeString(pkg), [VariableReference(dest, []), Expression(pkg, [])]), Statement(}, [])])  Statement({, [])  MethodCall(dest.writeInt(enabled ? 1 : 0), [VariableReference(dest, []), Expression(enabled ? 1 : 0, [])])    VariableReference(dest, [])    Expression(enabled ? 1 : 0, [])  MethodCall(dest.writeInt(snoozing ? 1 : 0), [VariableReference(dest, []), Expression(snoozing ? 1 : 0, [])])    VariableReference(dest, [])    Expression(snoozing ? 1 : 0, [])  AssignmentExpression(=, [VariableReference(if (name !, []), Expression(null) {, [])])    VariableReference(if (name !, [])    Expression(null) {, [])  MethodCall(dest.writeInt(1), [VariableReference(dest, []), Expression(1, [])])    VariableReference(dest, [])    Expression(1, [])  MethodCall(dest.writeString(name), [VariableReference(dest, []), Expression(name, [])])    VariableReference(dest, [])    Expression(name, [])  Statement(} else {, [])  MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])])    VariableReference(dest, [])    Expression(0, [])  Statement(}, [])  MethodCall(dest.writeInt(zenMode), [VariableReference(dest, []), Expression(zenMode, [])])    VariableReference(dest, [])    Expression(zenMode, [])  MethodCall(dest.writeParcelable(conditionId, 0), [VariableReference(dest, []), Expression(conditionId, []), Expression(0, [])])    VariableReference(dest, [])    Expression(conditionId, [])    Expression(0, [])  MethodCall(dest.writeParcelable(condition, 0), [VariableReference(dest, []), Expression(condition, []), Expression(0, [])])    VariableReference(dest, [])    Expression(condition, [])    Expression(0, [])  MethodCall(dest.writeParcelable(component, 0), [VariableReference(dest, []), Expression(component, []), Expression(0, [])])    VariableReference(dest, [])    Expression(component, [])    Expression(0, [])  MethodCall(dest.writeParcelable(configurationActivity, 0), [VariableReference(dest, []), Expression(configurationActivity, []), Expression(0, [])])    VariableReference(dest, [])    Expression(configurationActivity, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(if (id !, []), Expression(null) {, [])])    VariableReference(if (id !, [])    Expression(null) {, [])  MethodCall(dest.writeInt(1), [VariableReference(dest, []), Expression(1, [])])    VariableReference(dest, [])    Expression(1, [])  MethodCall(dest.writeString(id), [VariableReference(dest, []), Expression(id, [])])    VariableReference(dest, [])    Expression(id, [])  Statement(} else {, [])  MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])])    VariableReference(dest, [])    Expression(0, [])  Statement(}, [])  MethodCall(dest.writeLong(creationTime), [VariableReference(dest, []), Expression(creationTime, [])])    VariableReference(dest, [])    Expression(creationTime, [])  AssignmentExpression(=, [VariableReference(if (enabler !, []), Expression(null) {, [])])    VariableReference(if (enabler !, [])    Expression(null) {, [])  MethodCall(dest.writeInt(1), [VariableReference(dest, []), Expression(1, [])])    VariableReference(dest, [])    Expression(1, [])  MethodCall(dest.writeString(enabler), [VariableReference(dest, []), Expression(enabler, [])])    VariableReference(dest, [])    Expression(enabler, [])  Statement(} else {, [])  MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])])    VariableReference(dest, [])    Expression(0, [])  Statement(}, [])  MethodCall(dest.writeParcelable(zenPolicy, 0), [VariableReference(dest, []), Expression(zenPolicy, []), Expression(0, [])])    VariableReference(dest, [])    Expression(zenPolicy, [])    Expression(0, [])  MethodCall(dest.writeInt(modified ? 1 : 0), [VariableReference(dest, []), Expression(modified ? 1 : 0, [])])    VariableReference(dest, [])    Expression(modified ? 1 : 0, [])  MethodCall(dest.writeString(pkg), [VariableReference(dest, []), Expression(pkg, [])])    VariableReference(dest, [])    Expression(pkg, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,,1,4,0,"3,5",1,"Three method calls have been added to the late version implementation: `dest.writeParcelable(configurationActivity, 0)`, `dest.writeParcelable(zenPolicy, 0)`, and `dest.writeInt(modified ? 1 : 0)`. Also, the method `dest.writeString(pkg)` is called in the late version but not in the early version. This means that the parcelable data being written to in the late version contains more information than in the early version.",
159,<android.view.View: void setAutofillId(AutofillId)>,28,29,<android.view.View: void setAutofillId(AutofillId)>,<android.view.View: void setAutofillId(AutofillId)>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(// TODO(b/37566627): add unit / CTS test for all possible combinations below, []), MethodCall(Log.v(VIEW_LOG_TAG, ""setAutofill(): from "" + mAutofillId + "" to "" + id), [VariableReference(Log, []), Expression(VIEW_LOG_TAG, []), Expression(""setAutofill(): from "" + mAutofillId + "" to "" + id, [])]), Statement(}, []), Statement(if (isAttachedToWindow()) {, []), Statement(throw new IllegalStateException(""Cannot set autofill id when view is attached""), []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (id !, []), Expression(null && id.isVirtual()) {, [])]), Statement(throw new IllegalStateException(""Cannot set autofill id assigned to virtual views""), []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (id, []), Expression(, [])]), Statement(// Ignore reset because it was never explicitly set before., []), Statement(return, []), Statement(}, []), AssignmentExpression(=, [VariableReference(mAutofillId, []), Expression(id, [])]), AssignmentExpression(=, [VariableReference(if (id !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(mAutofillViewId, []), Expression(id.getViewId(), [])]), AssignmentExpression(=, [VariableReference(mPrivateFlags3 |, []), Expression(PFLAG3_AUTOFILLID_EXPLICITLY_SET, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mAutofillViewId, []), Expression(NO_ID, [])]), AssignmentExpression(=, [VariableReference(mPrivateFlags3 &, []), Expression(~PFLAG3_AUTOFILLID_EXPLICITLY_SET, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(// TODO(b/37566627): add unit / CTS test for all possible combinations below, [])  MethodCall(Log.v(VIEW_LOG_TAG, ""setAutofill(): from "" + mAutofillId + "" to "" + id), [VariableReference(Log, []), Expression(VIEW_LOG_TAG, []), Expression(""setAutofill(): from "" + mAutofillId + "" to "" + id, [])])    VariableReference(Log, [])    Expression(VIEW_LOG_TAG, [])    Expression(""setAutofill(): from "" + mAutofillId + "" to "" + id, [])  Statement(}, [])  Statement(if (isAttachedToWindow()) {, [])  Statement(throw new IllegalStateException(""Cannot set autofill id when view is attached""), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (id !, []), Expression(null && id.isVirtual()) {, [])])    VariableReference(if (id !, [])    Expression(null && id.isVirtual()) {, [])  Statement(throw new IllegalStateException(""Cannot set autofill id assigned to virtual views""), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (id, []), Expression(, [])])    VariableReference(if (id, [])    Expression(, [])  Statement(// Ignore reset because it was never explicitly set before., [])  Statement(return, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mAutofillId, []), Expression(id, [])])    VariableReference(mAutofillId, [])    Expression(id, [])  AssignmentExpression(=, [VariableReference(if (id !, []), Expression(null) {, [])])    VariableReference(if (id !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(mAutofillViewId, []), Expression(id.getViewId(), [])])    VariableReference(mAutofillViewId, [])    Expression(id.getViewId(), [])  AssignmentExpression(=, [VariableReference(mPrivateFlags3 |, []), Expression(PFLAG3_AUTOFILLID_EXPLICITLY_SET, [])])    VariableReference(mPrivateFlags3 |, [])    Expression(PFLAG3_AUTOFILLID_EXPLICITLY_SET, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mAutofillViewId, []), Expression(NO_ID, [])])    VariableReference(mAutofillViewId, [])    Expression(NO_ID, [])  AssignmentExpression(=, [VariableReference(mPrivateFlags3 &, []), Expression(~PFLAG3_AUTOFILLID_EXPLICITLY_SET, [])])    VariableReference(mPrivateFlags3 &, [])    Expression(~PFLAG3_AUTOFILLID_EXPLICITLY_SET, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(// TODO(b/37566627): add unit / CTS test for all possible combinations below, []), MethodCall(if (Log.isLoggable(AUTOFILL_LOG_TAG, Log.VERBOSE)), [VariableReference(if (Log, []), Expression(AUTOFILL_LOG_TAG, []), Expression(Log.VERBOSE), [])]), MethodCall(Log.v(AUTOFILL_LOG_TAG, ""setAutofill(): from "" + mAutofillId + "" to "" + id), [VariableReference(Log, []), Expression(AUTOFILL_LOG_TAG, []), Expression(""setAutofill(): from "" + mAutofillId + "" to "" + id, [])]), Statement(}, []), Statement(if (isAttachedToWindow()) {, []), Statement(throw new IllegalStateException(""Cannot set autofill id when view is attached""), []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (id !, []), Expression(null && !id.isNonVirtual()) {, [])]), Statement(throw new IllegalStateException(""Cannot set autofill id assigned to virtual views""), []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (id, []), Expression(, [])]), Statement(// Ignore reset because it was never explicitly set before., []), Statement(return, []), Statement(}, []), AssignmentExpression(=, [VariableReference(mAutofillId, []), Expression(id, [])]), AssignmentExpression(=, [VariableReference(if (id !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(mAutofillViewId, []), Expression(id.getViewId(), [])]), AssignmentExpression(=, [VariableReference(mPrivateFlags3 |, []), Expression(PFLAG3_AUTOFILLID_EXPLICITLY_SET, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mAutofillViewId, []), Expression(NO_ID, [])]), AssignmentExpression(=, [VariableReference(mPrivateFlags3 &, []), Expression(~PFLAG3_AUTOFILLID_EXPLICITLY_SET, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(// TODO(b/37566627): add unit / CTS test for all possible combinations below, [])  MethodCall(if (Log.isLoggable(AUTOFILL_LOG_TAG, Log.VERBOSE)), [VariableReference(if (Log, []), Expression(AUTOFILL_LOG_TAG, []), Expression(Log.VERBOSE), [])])    VariableReference(if (Log, [])    Expression(AUTOFILL_LOG_TAG, [])    Expression(Log.VERBOSE), [])  MethodCall(Log.v(AUTOFILL_LOG_TAG, ""setAutofill(): from "" + mAutofillId + "" to "" + id), [VariableReference(Log, []), Expression(AUTOFILL_LOG_TAG, []), Expression(""setAutofill(): from "" + mAutofillId + "" to "" + id, [])])    VariableReference(Log, [])    Expression(AUTOFILL_LOG_TAG, [])    Expression(""setAutofill(): from "" + mAutofillId + "" to "" + id, [])  Statement(}, [])  Statement(if (isAttachedToWindow()) {, [])  Statement(throw new IllegalStateException(""Cannot set autofill id when view is attached""), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (id !, []), Expression(null && !id.isNonVirtual()) {, [])])    VariableReference(if (id !, [])    Expression(null && !id.isNonVirtual()) {, [])  Statement(throw new IllegalStateException(""Cannot set autofill id assigned to virtual views""), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (id, []), Expression(, [])])    VariableReference(if (id, [])    Expression(, [])  Statement(// Ignore reset because it was never explicitly set before., [])  Statement(return, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mAutofillId, []), Expression(id, [])])    VariableReference(mAutofillId, [])    Expression(id, [])  AssignmentExpression(=, [VariableReference(if (id !, []), Expression(null) {, [])])    VariableReference(if (id !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(mAutofillViewId, []), Expression(id.getViewId(), [])])    VariableReference(mAutofillViewId, [])    Expression(id.getViewId(), [])  AssignmentExpression(=, [VariableReference(mPrivateFlags3 |, []), Expression(PFLAG3_AUTOFILLID_EXPLICITLY_SET, [])])    VariableReference(mPrivateFlags3 |, [])    Expression(PFLAG3_AUTOFILLID_EXPLICITLY_SET, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mAutofillViewId, []), Expression(NO_ID, [])])    VariableReference(mAutofillViewId, [])    Expression(NO_ID, [])  AssignmentExpression(=, [VariableReference(mPrivateFlags3 &, []), Expression(~PFLAG3_AUTOFILLID_EXPLICITLY_SET, [])])    VariableReference(mPrivateFlags3 &, [])    Expression(~PFLAG3_AUTOFILLID_EXPLICITLY_SET, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Sets the unique, logical identifier of this view in the activity, for autofill purposes.
 *
 * <p>The autofill id is created on demand, and this method should only be called when a view is
 * reused after {@link #dispatchProvideAutofillStructure(ViewStructure, int)} is called, as
 * that method creates a snapshot of the view that is passed along to the autofill service.
 *
 * <p>This method is typically used when view subtrees are recycled to represent different
 * content* &mdash;in this case, the autofill id can be saved before the view content is swapped
 * out, and restored later when it's swapped back in. For example:
 *
 * <pre>
 * EditText reusableView = ...;
 * ViewGroup parentView = ...;
 * AutofillManager afm = ...;
 *
 * // Swap out the view and change its contents
 * AutofillId oldId = reusableView.getAutofillId();
 * CharSequence oldText = reusableView.getText();
 * parentView.removeView(reusableView);
 * AutofillId newId = afm.getNextAutofillId();
 * reusableView.setText(""New I am"");
 * reusableView.setAutofillId(newId);
 * parentView.addView(reusableView);
 *
 * // Later, swap the old content back in
 * parentView.removeView(reusableView);
 * reusableView.setAutofillId(oldId);
 * reusableView.setText(oldText);
 * parentView.addView(reusableView);
 * </pre>
 *
 * @param id an autofill ID that is unique in the {@link android.app.Activity} hosting the view,
 * or {@code null} to reset it. Usually it's an id previously allocated to another view (and
 * obtained through {@link #getAutofillId()}), or a new value obtained through
 * {@link AutofillManager#getNextAutofillId()}.
 *
 * @throws IllegalStateException if the view is already {@link #isAttachedToWindow() attached to
 * a window}.
 *
 * @throws IllegalArgumentException if the id is an autofill id associated with a virtual view.
 */","/**
 * Sets the unique, logical identifier of this view in the activity, for autofill purposes.
 *
 * <p>The autofill id is created on demand, and this method should only be called when a view is
 * reused after {@link #dispatchProvideAutofillStructure(ViewStructure, int)} is called, as
 * that method creates a snapshot of the view that is passed along to the autofill service.
 *
 * <p>This method is typically used when view subtrees are recycled to represent different
 * content* &mdash;in this case, the autofill id can be saved before the view content is swapped
 * out, and restored later when it's swapped back in. For example:
 *
 * <pre>
 * EditText reusableView = ...;
 * ViewGroup parentView = ...;
 * AutofillManager afm = ...;
 *
 * // Swap out the view and change its contents
 * AutofillId oldId = reusableView.getAutofillId();
 * CharSequence oldText = reusableView.getText();
 * parentView.removeView(reusableView);
 * AutofillId newId = afm.getNextAutofillId();
 * reusableView.setText(""New I am"");
 * reusableView.setAutofillId(newId);
 * parentView.addView(reusableView);
 *
 * // Later, swap the old content back in
 * parentView.removeView(reusableView);
 * reusableView.setAutofillId(oldId);
 * reusableView.setText(oldText);
 * parentView.addView(reusableView);
 * </pre>
 *
 * @param id an autofill ID that is unique in the {@link android.app.Activity} hosting the view,
 * or {@code null} to reset it. Usually it's an id previously allocated to another view (and
 * obtained through {@link #getAutofillId()}), or a new value obtained through
 * {@link AutofillManager#getNextAutofillId()}.
 *
 * @throws IllegalStateException if the view is already {@link #isAttachedToWindow() attached to
 * a window}.
 *
 * @throws IllegalArgumentException if the id is an autofill id associated with a virtual view.
 */",0,,,0,,,,1,3,2,4,1,The implementation of the method has changed in the following ways:,3. The comment for the method has been updated to include an additional example usage.
160,<android.companion.WifiDeviceFilter.Builder: WifiDeviceFilter build()>,29,30,<android.companion.WifiDeviceFilter.Builder: WifiDeviceFilter build()>,<android.companion.WifiDeviceFilter.Builder: WifiDeviceFilter build()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(markUsed(), []), Statement(return new WifiDeviceFilter(mNamePattern), []), Statement(}, [])])  Statement({, [])  Statement(markUsed(), [])  Statement(return new WifiDeviceFilter(mNamePattern), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(checkNotUsed(), []), Statement(// Mark builder used, []), AssignmentExpression(=, [VariableReference(mBuilderFieldsSet |, []), Expression(0x8, [])]), AssignmentExpression(=, [VariableReference(if ((mBuilderFieldsSet & 0x1), []), Expression(, [])]), AssignmentExpression(=, [VariableReference(mNamePattern, []), Expression(null, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if ((mBuilderFieldsSet & 0x2), []), Expression(, [])]), AssignmentExpression(=, [VariableReference(mBssid, []), Expression(null, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if ((mBuilderFieldsSet & 0x4), []), Expression(, [])]), AssignmentExpression(=, [VariableReference(mBssidMask, []), Expression(MacAddress.BROADCAST_ADDRESS, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(WifiDeviceFilter o, []), Expression(new WifiDeviceFilter(mNamePattern, mBssid, mBssidMask), [])]), Statement(return o, []), Statement(}, [])])  Statement({, [])  Statement(checkNotUsed(), [])  Statement(// Mark builder used, [])  AssignmentExpression(=, [VariableReference(mBuilderFieldsSet |, []), Expression(0x8, [])])    VariableReference(mBuilderFieldsSet |, [])    Expression(0x8, [])  AssignmentExpression(=, [VariableReference(if ((mBuilderFieldsSet & 0x1), []), Expression(, [])])    VariableReference(if ((mBuilderFieldsSet & 0x1), [])    Expression(, [])  AssignmentExpression(=, [VariableReference(mNamePattern, []), Expression(null, [])])    VariableReference(mNamePattern, [])    Expression(null, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if ((mBuilderFieldsSet & 0x2), []), Expression(, [])])    VariableReference(if ((mBuilderFieldsSet & 0x2), [])    Expression(, [])  AssignmentExpression(=, [VariableReference(mBssid, []), Expression(null, [])])    VariableReference(mBssid, [])    Expression(null, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if ((mBuilderFieldsSet & 0x4), []), Expression(, [])])    VariableReference(if ((mBuilderFieldsSet & 0x4), [])    Expression(, [])  AssignmentExpression(=, [VariableReference(mBssidMask, []), Expression(MacAddress.BROADCAST_ADDRESS, [])])    VariableReference(mBssidMask, [])    Expression(MacAddress.BROADCAST_ADDRESS, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(WifiDeviceFilter o, []), Expression(new WifiDeviceFilter(mNamePattern, mBssid, mBssidMask), [])])    VariableReference(WifiDeviceFilter o, [])    Expression(new WifiDeviceFilter(mNamePattern, mBssid, mBssidMask), [])  Statement(return o, [])  Statement(}, [])",1,"/**
 * @inheritDoc
 */","/**
 * Builds the instance. This builder should not be touched after calling this!
 */",1,"[@Override, @NonNull]",[@NonNull],1,,,,"1,2","1,3,4,5",1,"1,3,4",1,"- The return statement has changed: in the early version, the method returns a new WifiDeviceFilter object with only one parameter (mNamePattern), while in the late version, it returns a new WifiDeviceFilter object with three parameters (mNamePattern, mBssid, mBssidMask).",
161,<android.hardware.camera2.impl.CameraDeviceImpl: void tearDown(Surface)>,29,30,<android.hardware.camera2.impl.CameraDeviceImpl: void tearDown(Surface)>,<android.hardware.camera2.impl.CameraDeviceImpl: void tearDown(Surface)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (surface, []), Expression(, [])]), Statement(throw new IllegalArgumentException(""Surface is null""), []), Statement(synchronized (mInterfaceLock) {, []), AssignmentExpression(=, [VariableReference(int streamId, []), Expression(-1, [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), MethodCall(i < mConfiguredOutputs.size(), [VariableReference(i < mConfiguredOutputs, []), Expression(, [])]), Statement(i++) {, []), AssignmentExpression(=, [VariableReference(if (surface, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(streamId, []), Expression(mConfiguredOutputs.keyAt(i), [])]), Statement(break, []), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (streamId, []), Expression(, [])]), Statement(throw new IllegalArgumentException(""Surface is not part of this session""), []), Statement(}, []), MethodCall(mRemoteDevice.tearDown(streamId), [VariableReference(mRemoteDevice, []), Expression(streamId, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (surface, []), Expression(, [])])    VariableReference(if (surface, [])    Expression(, [])  Statement(throw new IllegalArgumentException(""Surface is null""), [])  Statement(synchronized (mInterfaceLock) {, [])  AssignmentExpression(=, [VariableReference(int streamId, []), Expression(-1, [])])    VariableReference(int streamId, [])    Expression(-1, [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  MethodCall(i < mConfiguredOutputs.size(), [VariableReference(i < mConfiguredOutputs, []), Expression(, [])])    VariableReference(i < mConfiguredOutputs, [])    Expression(, [])  Statement(i++) {, [])  AssignmentExpression(=, [VariableReference(if (surface, []), Expression(, [])])    VariableReference(if (surface, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(streamId, []), Expression(mConfiguredOutputs.keyAt(i), [])])    VariableReference(streamId, [])    Expression(mConfiguredOutputs.keyAt(i), [])  Statement(break, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (streamId, []), Expression(, [])])    VariableReference(if (streamId, [])    Expression(, [])  Statement(throw new IllegalArgumentException(""Surface is not part of this session""), [])  Statement(}, [])  MethodCall(mRemoteDevice.tearDown(streamId), [VariableReference(mRemoteDevice, []), Expression(streamId, [])])    VariableReference(mRemoteDevice, [])    Expression(streamId, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (surface, []), Expression(, [])]), Statement(throw new IllegalArgumentException(""Surface is null""), []), Statement(synchronized (mInterfaceLock) {, []), Statement(checkIfCameraClosedOrInError(), []), AssignmentExpression(=, [VariableReference(int streamId, []), Expression(-1, [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), MethodCall(i < mConfiguredOutputs.size(), [VariableReference(i < mConfiguredOutputs, []), Expression(, [])]), Statement(i++) {, []), AssignmentExpression(=, [VariableReference(if (surface, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(streamId, []), Expression(mConfiguredOutputs.keyAt(i), [])]), Statement(break, []), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (streamId, []), Expression(, [])]), Statement(throw new IllegalArgumentException(""Surface is not part of this session""), []), Statement(}, []), MethodCall(mRemoteDevice.tearDown(streamId), [VariableReference(mRemoteDevice, []), Expression(streamId, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (surface, []), Expression(, [])])    VariableReference(if (surface, [])    Expression(, [])  Statement(throw new IllegalArgumentException(""Surface is null""), [])  Statement(synchronized (mInterfaceLock) {, [])  Statement(checkIfCameraClosedOrInError(), [])  AssignmentExpression(=, [VariableReference(int streamId, []), Expression(-1, [])])    VariableReference(int streamId, [])    Expression(-1, [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  MethodCall(i < mConfiguredOutputs.size(), [VariableReference(i < mConfiguredOutputs, []), Expression(, [])])    VariableReference(i < mConfiguredOutputs, [])    Expression(, [])  Statement(i++) {, [])  AssignmentExpression(=, [VariableReference(if (surface, []), Expression(, [])])    VariableReference(if (surface, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(streamId, []), Expression(mConfiguredOutputs.keyAt(i), [])])    VariableReference(streamId, [])    Expression(mConfiguredOutputs.keyAt(i), [])  Statement(break, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (streamId, []), Expression(, [])])    VariableReference(if (streamId, [])    Expression(, [])  Statement(throw new IllegalArgumentException(""Surface is not part of this session""), [])  Statement(}, [])  MethodCall(mRemoteDevice.tearDown(streamId), [VariableReference(mRemoteDevice, []), Expression(streamId, [])])    VariableReference(mRemoteDevice, [])    Expression(streamId, [])  Statement(}, [])  Statement(}, [])",1,,,0,,,0,,,,1,4,0,"2,5",2,"The code change between the two versions is the addition of a new statement ""checkIfCameraClosedOrInError()"" inside the synchronized block and the control dependency change of the for-loop. The new statement is an exception handling statement, so the code change type is 2. Additionally, the control dependency of the for-loop has changed because the new statement is added before the for-loop, so the code change type is also 5.","The Compatibility Issue (CI) exists in this case because the new statement ""checkIfCameraClosedOrInError()"" is an exception handling statement, and it can potentially throw an exception, which could lead to different behaviors between the two versions. Therefore, the CI type is 2. The control dependency change of the for-loop does not cause a CI because it does not affect the return value or the exception handling of the method."
163,<android.view.DisplayCutout: boolean equals(Object)>,29,30,<android.view.DisplayCutout: boolean equals(Object)>,<android.view.DisplayCutout: boolean equals(Object)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (o, []), Expression(, [])]), Statement(return true, []), Statement(}, []), Statement(if (o instanceof DisplayCutout) {, []), AssignmentExpression(=, [VariableReference(DisplayCutout c, []), Expression((DisplayCutout) o, [])]), MethodCall(return mSafeInsets.equals(c.mSafeInsets) && mBounds.equals(c.mBounds), [VariableReference(return mSafeInsets, []), Expression(c.mSafeInsets) && mBounds.equals(c.mBounds, [])]), Statement(}, []), Statement(return false, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (o, []), Expression(, [])])    VariableReference(if (o, [])    Expression(, [])  Statement(return true, [])  Statement(}, [])  Statement(if (o instanceof DisplayCutout) {, [])  AssignmentExpression(=, [VariableReference(DisplayCutout c, []), Expression((DisplayCutout) o, [])])    VariableReference(DisplayCutout c, [])    Expression((DisplayCutout) o, [])  MethodCall(return mSafeInsets.equals(c.mSafeInsets) && mBounds.equals(c.mBounds), [VariableReference(return mSafeInsets, []), Expression(c.mSafeInsets) && mBounds.equals(c.mBounds, [])])    VariableReference(return mSafeInsets, [])    Expression(c.mSafeInsets) && mBounds.equals(c.mBounds, [])  Statement(}, [])  Statement(return false, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (o, []), Expression(, [])]), Statement(return true, []), Statement(}, []), Statement(if (o instanceof DisplayCutout) {, []), AssignmentExpression(=, [VariableReference(DisplayCutout c, []), Expression((DisplayCutout) o, [])]), MethodCall(return mSafeInsets.equals(c.mSafeInsets) && mBounds.equals(c.mBounds) && mWaterfallInsets.equals(c.mWaterfallInsets), [VariableReference(return mSafeInsets, []), Expression(c.mSafeInsets) && mBounds.equals(c.mBounds) && mWaterfallInsets.equals(c.mWaterfallInsets, [])]), Statement(}, []), Statement(return false, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (o, []), Expression(, [])])    VariableReference(if (o, [])    Expression(, [])  Statement(return true, [])  Statement(}, [])  Statement(if (o instanceof DisplayCutout) {, [])  AssignmentExpression(=, [VariableReference(DisplayCutout c, []), Expression((DisplayCutout) o, [])])    VariableReference(DisplayCutout c, [])    Expression((DisplayCutout) o, [])  MethodCall(return mSafeInsets.equals(c.mSafeInsets) && mBounds.equals(c.mBounds) && mWaterfallInsets.equals(c.mWaterfallInsets), [VariableReference(return mSafeInsets, []), Expression(c.mSafeInsets) && mBounds.equals(c.mBounds) && mWaterfallInsets.equals(c.mWaterfallInsets, [])])    VariableReference(return mSafeInsets, [])    Expression(c.mSafeInsets) && mBounds.equals(c.mBounds) && mWaterfallInsets.equals(c.mWaterfallInsets, [])  Statement(}, [])  Statement(return false, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,,1,1,1,"1,3",1,The code change is a combination of return statement change and control dependency change. A new condition `mWaterfallInsets.equals(c.mWaterfallInsets)` is added to the return statement `return mSafeInsets.equals(c.mSafeInsets) && mBounds.equals(c.mBounds)` in the late version. This new condition is inside the control dependency of `if (o instanceof DisplayCutout)`.,"The Compatibility Issue is caused by the potential different return values. In the early version, the `equals` method of `DisplayCutout` class only checks the equality of `mSafeInsets` and `mBounds`. However, in the late version, it also checks the equality of `mWaterfallInsets`. This means that if two `DisplayCutout` objects have the same `mSafeInsets` and `mBounds` but different `mWaterfallInsets`, the `equals` method will return `true` in the early version but `false` in the late version."
165,<android.net.TrafficStats: long getUidTxPackets(int)>,29,30,<android.net.TrafficStats: long getUidTxPackets(int)>,<android.net.TrafficStats: long getUidTxPackets(int)>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(// This isn't actually enforcing any security, []), Statement(it just returns the, []), Statement(// unsupported value. The real filtering is done at the kernel level., []), AssignmentExpression(=, [VariableReference(final int callingUid, []), Expression(android.os.Process.myUid(), [])]), AssignmentExpression(=, [VariableReference(if (callingUid, []), Expression(, [])]), Statement(try {, []), MethodCall(return getStatsService().getUidStats(uid, TYPE_TX_PACKETS), [VariableReference(return getStatsService(), []), Expression(uid, []), Expression(TYPE_TX_PACKETS, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(} else {, []), Statement(return UNSUPPORTED, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(// This isn't actually enforcing any security, [])  Statement(it just returns the, [])  Statement(// unsupported value. The real filtering is done at the kernel level., [])  AssignmentExpression(=, [VariableReference(final int callingUid, []), Expression(android.os.Process.myUid(), [])])    VariableReference(final int callingUid, [])    Expression(android.os.Process.myUid(), [])  AssignmentExpression(=, [VariableReference(if (callingUid, []), Expression(, [])])    VariableReference(if (callingUid, [])    Expression(, [])  Statement(try {, [])  MethodCall(return getStatsService().getUidStats(uid, TYPE_TX_PACKETS), [VariableReference(return getStatsService(), []), Expression(uid, []), Expression(TYPE_TX_PACKETS, [])])    VariableReference(return getStatsService(), [])    Expression(uid, [])    Expression(TYPE_TX_PACKETS, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(} else {, [])  Statement(return UNSUPPORTED, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(return getStatsService().getUidStats(uid, TYPE_TX_PACKETS), [VariableReference(return getStatsService(), []), Expression(uid, []), Expression(TYPE_TX_PACKETS, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(return getStatsService().getUidStats(uid, TYPE_TX_PACKETS), [VariableReference(return getStatsService(), []), Expression(uid, []), Expression(TYPE_TX_PACKETS, [])])    VariableReference(return getStatsService(), [])    Expression(uid, [])    Expression(TYPE_TX_PACKETS, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Return number of packets transmitted by the given UID since device boot.
 * Counts packets across all network interfaces, and always increases
 * monotonically since device boot. Statistics are measured at the network
 * layer, so they include both TCP and UDP usage.
 * <p>
 * Before {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, this may return
 * {@link #UNSUPPORTED} on devices where statistics aren't available.
 * <p>
 * Starting in {@link android.os.Build.VERSION_CODES#N} this will only
 * report traffic statistics for the calling UID. It will return
 * {@link #UNSUPPORTED} for all other UIDs for privacy reasons. To access
 * historical network statistics belonging to other UIDs, use
 * {@link NetworkStatsManager}.
 *
 * @see android.os.Process#myUid()
 * @see android.content.pm.ApplicationInfo#uid
 */","/**
 * Return number of packets transmitted by the given UID since device boot.
 * Counts packets across all network interfaces, and always increases
 * monotonically since device boot. Statistics are measured at the network
 * layer, so they include both TCP and UDP usage.
 * <p>
 * Before {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, this may return
 * {@link #UNSUPPORTED} on devices where statistics aren't available.
 * <p>
 * Starting in {@link android.os.Build.VERSION_CODES#N} this will only
 * report traffic statistics for the calling UID. It will return
 * {@link #UNSUPPORTED} for all other UIDs for privacy reasons. To access
 * historical network statistics belonging to other UIDs, use
 * {@link NetworkStatsManager}.
 *
 * @see android.os.Process#myUid()
 * @see android.content.pm.ApplicationInfo#uid
 */",0,,,0,,,,"1,2","1,2,3,4","1,2",2,2,"The code change is in the exception handling statement. The early version has a statement ""if (callingUid == android.os.Process.myUid()) {"" before the try-catch block, which is removed in the late version. This can potentially lead to different exception handling behavior.","The compatibility issue is caused by potential different exception handling. The early version has a condition to check the calling UID before the try-catch block, which is removed in the late version. This can potentially lead to different exception handling behavior when the calling UID is not the same as the current process UID."
166,<android.security.keystore.recovery.KeyChainProtectionParams.Builder: KeyChainProtectionParams build()>,29,30,<android.security.keystore.recovery.KeyChainProtectionParams.Builder: KeyChainProtectionParams build()>,<android.security.keystore.recovery.KeyChainProtectionParams.Builder: KeyChainProtectionParams build()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mInstance.mUserSecretType, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(mInstance.mUserSecretType, []), Expression(TYPE_LOCKSCREEN, [])]), Statement(}, []), MethodCall(Preconditions.checkNotNull(mInstance.mLockScreenUiFormat), [VariableReference(Preconditions, []), Expression(mInstance.mLockScreenUiFormat, [])]), MethodCall(Preconditions.checkNotNull(mInstance.mKeyDerivationParams), [VariableReference(Preconditions, []), Expression(mInstance.mKeyDerivationParams, [])]), AssignmentExpression(=, [VariableReference(if (mInstance.mSecret, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(mInstance.mSecret, []), Expression(new byte[] {}, [])]), Statement(}, []), Statement(return mInstance, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mInstance.mUserSecretType, []), Expression(, [])])    VariableReference(if (mInstance.mUserSecretType, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(mInstance.mUserSecretType, []), Expression(TYPE_LOCKSCREEN, [])])    VariableReference(mInstance.mUserSecretType, [])    Expression(TYPE_LOCKSCREEN, [])  Statement(}, [])  MethodCall(Preconditions.checkNotNull(mInstance.mLockScreenUiFormat), [VariableReference(Preconditions, []), Expression(mInstance.mLockScreenUiFormat, [])])    VariableReference(Preconditions, [])    Expression(mInstance.mLockScreenUiFormat, [])  MethodCall(Preconditions.checkNotNull(mInstance.mKeyDerivationParams), [VariableReference(Preconditions, []), Expression(mInstance.mKeyDerivationParams, [])])    VariableReference(Preconditions, [])    Expression(mInstance.mKeyDerivationParams, [])  AssignmentExpression(=, [VariableReference(if (mInstance.mSecret, []), Expression(, [])])    VariableReference(if (mInstance.mSecret, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(mInstance.mSecret, []), Expression(new byte[] {}, [])])    VariableReference(mInstance.mSecret, [])    Expression(new byte[] {}, [])  Statement(}, [])  Statement(return mInstance, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mInstance.mUserSecretType, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(mInstance.mUserSecretType, []), Expression(TYPE_LOCKSCREEN, [])]), Statement(}, []), MethodCall(Objects.requireNonNull(mInstance.mLockScreenUiFormat), [VariableReference(Objects, []), Expression(mInstance.mLockScreenUiFormat, [])]), MethodCall(Objects.requireNonNull(mInstance.mKeyDerivationParams), [VariableReference(Objects, []), Expression(mInstance.mKeyDerivationParams, [])]), AssignmentExpression(=, [VariableReference(if (mInstance.mSecret, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(mInstance.mSecret, []), Expression(new byte[] {}, [])]), Statement(}, []), Statement(return mInstance, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mInstance.mUserSecretType, []), Expression(, [])])    VariableReference(if (mInstance.mUserSecretType, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(mInstance.mUserSecretType, []), Expression(TYPE_LOCKSCREEN, [])])    VariableReference(mInstance.mUserSecretType, [])    Expression(TYPE_LOCKSCREEN, [])  Statement(}, [])  MethodCall(Objects.requireNonNull(mInstance.mLockScreenUiFormat), [VariableReference(Objects, []), Expression(mInstance.mLockScreenUiFormat, [])])    VariableReference(Objects, [])    Expression(mInstance.mLockScreenUiFormat, [])  MethodCall(Objects.requireNonNull(mInstance.mKeyDerivationParams), [VariableReference(Objects, []), Expression(mInstance.mKeyDerivationParams, [])])    VariableReference(Objects, [])    Expression(mInstance.mKeyDerivationParams, [])  AssignmentExpression(=, [VariableReference(if (mInstance.mSecret, []), Expression(, [])])    VariableReference(if (mInstance.mSecret, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(mInstance.mSecret, []), Expression(new byte[] {}, [])])    VariableReference(mInstance.mSecret, [])    Expression(new byte[] {}, [])  Statement(}, [])  Statement(return mInstance, [])  Statement(}, [])",1,"/**
 * Creates a new {@link KeyChainProtectionParams} instance.
 * The instance will include default values, if {@link #setSecret}
 * or {@link #setUserSecretType} were not called.
 *
 * @return new instance
 * @throws NullPointerException if some required fields were not set.
 */
","/**
 * Creates a new {@link KeyChainProtectionParams} instance.
 * The instance will include default values, if {@link #setSecret}
 * or {@link #setUserSecretType} were not called.
 *
 * @return new instance
 * @throws NullPointerException if some required fields were not set.
 */
",0,[@NonNull],[@NonNull],0,,,,1,5,0,2,2,"The two methods ""Preconditions.checkNotNull"" in the early version have been replaced with ""Objects.requireNonNull"" in the late version. These methods are used to check if a given object reference is null, and throw a NullPointerException if it is.","The change in the methods used for null checking can potentially lead to a different behavior in case of a null reference. If the ""Objects.requireNonNull"" method in the late version behaves differently from the ""Preconditions.checkNotNull"" method in the early version (e.g. throws a different exception), it can cause a compatibility issue."
167,<android.app.ContextImpl: Context createContextForSplit(String)>,29,30,<android.app.ContextImpl: Context createContextForSplit(String)>,<android.app.ContextImpl: Context createContextForSplit(String)>,0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(if (!mPackageInfo.getApplicationInfo().requestsIsolatedSplitLoading()), [VariableReference(if (!mPackageInfo, []), Expression().requestsIsolatedSplitLoading(), [])]), Statement(// All Splits are always loaded., []), Statement(return this, []), Statement(}, []), AssignmentExpression(=, [VariableReference(final ClassLoader classLoader, []), Expression(mPackageInfo.getSplitClassLoader(splitName), [])]), AssignmentExpression(=, [VariableReference(final String[] paths, []), Expression(mPackageInfo.getSplitPaths(splitName), [])]), AssignmentExpression(=, [VariableReference(final ContextImpl context, []), Expression(new ContextImpl(this, mMainThread, mPackageInfo, splitName, mActivityToken, mUser, mFlags, classLoader, null), [])]), AssignmentExpression(=, [VariableReference(final int displayId, []), Expression(getDisplayId(), [])]), MethodCall(context.setResources(ResourcesManager.getInstance().getResources(mActivityToken, mPackageInfo.getResDir(), paths, mPackageInfo.getOverlayDirs(), mPackageInfo.getApplicationInfo().sharedLibraryFiles, displayId, null, mPackageInfo.getCompatibilityInfo(), classLoader)), [VariableReference(context, []), Expression(ResourcesManager.getInstance().getResources(mActivityToken, []), Expression(mPackageInfo.getResDir(), []), Expression(paths, []), Expression(mPackageInfo.getOverlayDirs(), []), Expression(mPackageInfo.getApplicationInfo().sharedLibraryFiles, []), Expression(displayId, []), Expression(null, []), Expression(mPackageInfo.getCompatibilityInfo(), []), Expression(classLoader), [])]), Statement(return context, []), Statement(}, [])])  Statement({, [])  MethodCall(if (!mPackageInfo.getApplicationInfo().requestsIsolatedSplitLoading()), [VariableReference(if (!mPackageInfo, []), Expression().requestsIsolatedSplitLoading(), [])])    VariableReference(if (!mPackageInfo, [])    Expression().requestsIsolatedSplitLoading(), [])  Statement(// All Splits are always loaded., [])  Statement(return this, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(final ClassLoader classLoader, []), Expression(mPackageInfo.getSplitClassLoader(splitName), [])])    VariableReference(final ClassLoader classLoader, [])    Expression(mPackageInfo.getSplitClassLoader(splitName), [])  AssignmentExpression(=, [VariableReference(final String[] paths, []), Expression(mPackageInfo.getSplitPaths(splitName), [])])    VariableReference(final String[] paths, [])    Expression(mPackageInfo.getSplitPaths(splitName), [])  AssignmentExpression(=, [VariableReference(final ContextImpl context, []), Expression(new ContextImpl(this, mMainThread, mPackageInfo, splitName, mActivityToken, mUser, mFlags, classLoader, null), [])])    VariableReference(final ContextImpl context, [])    Expression(new ContextImpl(this, mMainThread, mPackageInfo, splitName, mActivityToken, mUser, mFlags, classLoader, null), [])  AssignmentExpression(=, [VariableReference(final int displayId, []), Expression(getDisplayId(), [])])    VariableReference(final int displayId, [])    Expression(getDisplayId(), [])  MethodCall(context.setResources(ResourcesManager.getInstance().getResources(mActivityToken, mPackageInfo.getResDir(), paths, mPackageInfo.getOverlayDirs(), mPackageInfo.getApplicationInfo().sharedLibraryFiles, displayId, null, mPackageInfo.getCompatibilityInfo(), classLoader)), [VariableReference(context, []), Expression(ResourcesManager.getInstance().getResources(mActivityToken, []), Expression(mPackageInfo.getResDir(), []), Expression(paths, []), Expression(mPackageInfo.getOverlayDirs(), []), Expression(mPackageInfo.getApplicationInfo().sharedLibraryFiles, []), Expression(displayId, []), Expression(null, []), Expression(mPackageInfo.getCompatibilityInfo(), []), Expression(classLoader), [])])    VariableReference(context, [])    Expression(ResourcesManager.getInstance().getResources(mActivityToken, [])    Expression(mPackageInfo.getResDir(), [])    Expression(paths, [])    Expression(mPackageInfo.getOverlayDirs(), [])    Expression(mPackageInfo.getApplicationInfo().sharedLibraryFiles, [])    Expression(displayId, [])    Expression(null, [])    Expression(mPackageInfo.getCompatibilityInfo(), [])    Expression(classLoader), [])  Statement(return context, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(if (!mPackageInfo.getApplicationInfo().requestsIsolatedSplitLoading()), [VariableReference(if (!mPackageInfo, []), Expression().requestsIsolatedSplitLoading(), [])]), Statement(// All Splits are always loaded., []), Statement(return this, []), Statement(}, []), AssignmentExpression(=, [VariableReference(final ClassLoader classLoader, []), Expression(mPackageInfo.getSplitClassLoader(splitName), [])]), AssignmentExpression(=, [VariableReference(final String[] paths, []), Expression(mPackageInfo.getSplitPaths(splitName), [])]), AssignmentExpression(=, [VariableReference(final ContextImpl context, []), Expression(new ContextImpl(this, mMainThread, mPackageInfo, mAttributionTag, splitName, mToken, mUser, mFlags, classLoader, null), [])]), AssignmentExpression(=, [VariableReference(final int displayId, []), Expression(getDisplayId(), [])]), MethodCall(context.setResources(ResourcesManager.getInstance().getResources(mToken, mPackageInfo.getResDir(), paths, mPackageInfo.getOverlayDirs(), mPackageInfo.getApplicationInfo().sharedLibraryFiles, displayId, null, mPackageInfo.getCompatibilityInfo(), classLoader, mResources.getLoaders())), [VariableReference(context, []), Expression(ResourcesManager.getInstance().getResources(mToken, []), Expression(mPackageInfo.getResDir(), []), Expression(paths, []), Expression(mPackageInfo.getOverlayDirs(), []), Expression(mPackageInfo.getApplicationInfo().sharedLibraryFiles, []), Expression(displayId, []), Expression(null, []), Expression(mPackageInfo.getCompatibilityInfo(), []), Expression(classLoader, []), Expression(mResources.getLoaders()), [])]), Statement(return context, []), Statement(}, [])])  Statement({, [])  MethodCall(if (!mPackageInfo.getApplicationInfo().requestsIsolatedSplitLoading()), [VariableReference(if (!mPackageInfo, []), Expression().requestsIsolatedSplitLoading(), [])])    VariableReference(if (!mPackageInfo, [])    Expression().requestsIsolatedSplitLoading(), [])  Statement(// All Splits are always loaded., [])  Statement(return this, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(final ClassLoader classLoader, []), Expression(mPackageInfo.getSplitClassLoader(splitName), [])])    VariableReference(final ClassLoader classLoader, [])    Expression(mPackageInfo.getSplitClassLoader(splitName), [])  AssignmentExpression(=, [VariableReference(final String[] paths, []), Expression(mPackageInfo.getSplitPaths(splitName), [])])    VariableReference(final String[] paths, [])    Expression(mPackageInfo.getSplitPaths(splitName), [])  AssignmentExpression(=, [VariableReference(final ContextImpl context, []), Expression(new ContextImpl(this, mMainThread, mPackageInfo, mAttributionTag, splitName, mToken, mUser, mFlags, classLoader, null), [])])    VariableReference(final ContextImpl context, [])    Expression(new ContextImpl(this, mMainThread, mPackageInfo, mAttributionTag, splitName, mToken, mUser, mFlags, classLoader, null), [])  AssignmentExpression(=, [VariableReference(final int displayId, []), Expression(getDisplayId(), [])])    VariableReference(final int displayId, [])    Expression(getDisplayId(), [])  MethodCall(context.setResources(ResourcesManager.getInstance().getResources(mToken, mPackageInfo.getResDir(), paths, mPackageInfo.getOverlayDirs(), mPackageInfo.getApplicationInfo().sharedLibraryFiles, displayId, null, mPackageInfo.getCompatibilityInfo(), classLoader, mResources.getLoaders())), [VariableReference(context, []), Expression(ResourcesManager.getInstance().getResources(mToken, []), Expression(mPackageInfo.getResDir(), []), Expression(paths, []), Expression(mPackageInfo.getOverlayDirs(), []), Expression(mPackageInfo.getApplicationInfo().sharedLibraryFiles, []), Expression(displayId, []), Expression(null, []), Expression(mPackageInfo.getCompatibilityInfo(), []), Expression(classLoader, []), Expression(mResources.getLoaders()), [])])    VariableReference(context, [])    Expression(ResourcesManager.getInstance().getResources(mToken, [])    Expression(mPackageInfo.getResDir(), [])    Expression(paths, [])    Expression(mPackageInfo.getOverlayDirs(), [])    Expression(mPackageInfo.getApplicationInfo().sharedLibraryFiles, [])    Expression(displayId, [])    Expression(null, [])    Expression(mPackageInfo.getCompatibilityInfo(), [])    Expression(classLoader, [])    Expression(mResources.getLoaders()), [])  Statement(return context, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,,"1,2",4,1,5,1,"The constructor of the ContextImpl class has been changed. In the early version, the constructor is `new ContextImpl(this, mMainThread, mPackageInfo, splitName, mActivityToken, mUser, mFlags, classLoader, null)`, while in the late version, it is `new ContextImpl(this, mMainThread, mPackageInfo, mAttributionTag, splitName, mToken, mUser, mFlags, classLoader, null)`. Also, the method `context.setResources()` has been changed. In the early version, the method is called with 9 arguments, while in the late version, it is called with 10 arguments. The last argument in the late version is `mResources.getLoaders()`.","The change in the constructor of the ContextImpl class may lead to different behaviors of the API. The `mActivityToken` and `mAttributionTag` variables may contain different values, which may affect the functionality of the API. Also, the addition of a new argument in the `context.setResources()` method may also lead to different behaviors. The `mResources.getLoaders()` variable may contain different values in different situations, which may affect the resources that are loaded for the split. Therefore, the Compatibility Issue is caused by potential different return values or types (1)."
168,"<android.content.ContentResolver: boolean refresh(Uri,Bundle,CancellationSignal)>",29,30,"<android.content.ContentResolver: boolean refresh(Uri,Bundle,CancellationSignal)>","<android.content.ContentResolver: boolean refresh(Uri,Bundle,CancellationSignal)>",0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(Preconditions.checkNotNull(url, ""url""), [VariableReference(Preconditions, []), Expression(url, []), Expression(""url"", [])]), Statement(try {, []), AssignmentExpression(=, [VariableReference(if (mWrapped !, []), Expression(null), [])]), MethodCall(return mWrapped.refresh(url, args, cancellationSignal), [VariableReference(return mWrapped, []), Expression(url, []), Expression(args, []), Expression(cancellationSignal, [])]), Statement(} catch (RemoteException e) {, []), Statement(return false, []), Statement(}, []), AssignmentExpression(=, [VariableReference(IContentProvider provider, []), Expression(acquireProvider(url), [])]), AssignmentExpression(=, [VariableReference(if (provider, []), Expression(, [])]), Statement(return false, []), Statement(}, []), Statement(try {, []), AssignmentExpression(=, [VariableReference(ICancellationSignal remoteCancellationSignal, []), Expression(null, [])]), AssignmentExpression(=, [VariableReference(if (cancellationSignal !, []), Expression(null) {, [])]), MethodCall(cancellationSignal.throwIfCanceled(), [VariableReference(cancellationSignal, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(remoteCancellationSignal, []), Expression(provider.createCancellationSignal(), [])]), MethodCall(cancellationSignal.setRemote(remoteCancellationSignal), [VariableReference(cancellationSignal, []), Expression(remoteCancellationSignal, [])]), Statement(}, []), MethodCall(return provider.refresh(mPackageName, url, args, remoteCancellationSignal), [VariableReference(return provider, []), Expression(mPackageName, []), Expression(url, []), Expression(args, []), Expression(remoteCancellationSignal, [])]), Statement(} catch (RemoteException e) {, []), Statement(// Manager will kill this process shortly anyway., []), Statement(return false, []), Statement(} finally {, []), Statement(releaseProvider(provider), []), Statement(}, []), Statement(}, [])])  Statement({, [])  MethodCall(Preconditions.checkNotNull(url, ""url""), [VariableReference(Preconditions, []), Expression(url, []), Expression(""url"", [])])    VariableReference(Preconditions, [])    Expression(url, [])    Expression(""url"", [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(if (mWrapped !, []), Expression(null), [])])    VariableReference(if (mWrapped !, [])    Expression(null), [])  MethodCall(return mWrapped.refresh(url, args, cancellationSignal), [VariableReference(return mWrapped, []), Expression(url, []), Expression(args, []), Expression(cancellationSignal, [])])    VariableReference(return mWrapped, [])    Expression(url, [])    Expression(args, [])    Expression(cancellationSignal, [])  Statement(} catch (RemoteException e) {, [])  Statement(return false, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(IContentProvider provider, []), Expression(acquireProvider(url), [])])    VariableReference(IContentProvider provider, [])    Expression(acquireProvider(url), [])  AssignmentExpression(=, [VariableReference(if (provider, []), Expression(, [])])    VariableReference(if (provider, [])    Expression(, [])  Statement(return false, [])  Statement(}, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(ICancellationSignal remoteCancellationSignal, []), Expression(null, [])])    VariableReference(ICancellationSignal remoteCancellationSignal, [])    Expression(null, [])  AssignmentExpression(=, [VariableReference(if (cancellationSignal !, []), Expression(null) {, [])])    VariableReference(if (cancellationSignal !, [])    Expression(null) {, [])  MethodCall(cancellationSignal.throwIfCanceled(), [VariableReference(cancellationSignal, []), Expression(, [])])    VariableReference(cancellationSignal, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(remoteCancellationSignal, []), Expression(provider.createCancellationSignal(), [])])    VariableReference(remoteCancellationSignal, [])    Expression(provider.createCancellationSignal(), [])  MethodCall(cancellationSignal.setRemote(remoteCancellationSignal), [VariableReference(cancellationSignal, []), Expression(remoteCancellationSignal, [])])    VariableReference(cancellationSignal, [])    Expression(remoteCancellationSignal, [])  Statement(}, [])  MethodCall(return provider.refresh(mPackageName, url, args, remoteCancellationSignal), [VariableReference(return provider, []), Expression(mPackageName, []), Expression(url, []), Expression(args, []), Expression(remoteCancellationSignal, [])])    VariableReference(return provider, [])    Expression(mPackageName, [])    Expression(url, [])    Expression(args, [])    Expression(remoteCancellationSignal, [])  Statement(} catch (RemoteException e) {, [])  Statement(// Manager will kill this process shortly anyway., [])  Statement(return false, [])  Statement(} finally {, [])  Statement(releaseProvider(provider), [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(Objects.requireNonNull(url, ""url""), [VariableReference(Objects, []), Expression(url, []), Expression(""url"", [])]), Statement(try {, []), AssignmentExpression(=, [VariableReference(if (mWrapped !, []), Expression(null), [])]), MethodCall(return mWrapped.refresh(url, extras, cancellationSignal), [VariableReference(return mWrapped, []), Expression(url, []), Expression(extras, []), Expression(cancellationSignal, [])]), Statement(} catch (RemoteException e) {, []), Statement(return false, []), Statement(}, []), AssignmentExpression(=, [VariableReference(IContentProvider provider, []), Expression(acquireProvider(url), [])]), AssignmentExpression(=, [VariableReference(if (provider, []), Expression(, [])]), Statement(return false, []), Statement(}, []), Statement(try {, []), AssignmentExpression(=, [VariableReference(ICancellationSignal remoteCancellationSignal, []), Expression(null, [])]), AssignmentExpression(=, [VariableReference(if (cancellationSignal !, []), Expression(null) {, [])]), MethodCall(cancellationSignal.throwIfCanceled(), [VariableReference(cancellationSignal, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(remoteCancellationSignal, []), Expression(provider.createCancellationSignal(), [])]), MethodCall(cancellationSignal.setRemote(remoteCancellationSignal), [VariableReference(cancellationSignal, []), Expression(remoteCancellationSignal, [])]), Statement(}, []), MethodCall(return provider.refresh(mPackageName, mAttributionTag, url, extras, remoteCancellationSignal), [VariableReference(return provider, []), Expression(mPackageName, []), Expression(mAttributionTag, []), Expression(url, []), Expression(extras, []), Expression(remoteCancellationSignal, [])]), Statement(} catch (RemoteException e) {, []), Statement(// Manager will kill this process shortly anyway., []), Statement(return false, []), Statement(} finally {, []), Statement(releaseProvider(provider), []), Statement(}, []), Statement(}, [])])  Statement({, [])  MethodCall(Objects.requireNonNull(url, ""url""), [VariableReference(Objects, []), Expression(url, []), Expression(""url"", [])])    VariableReference(Objects, [])    Expression(url, [])    Expression(""url"", [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(if (mWrapped !, []), Expression(null), [])])    VariableReference(if (mWrapped !, [])    Expression(null), [])  MethodCall(return mWrapped.refresh(url, extras, cancellationSignal), [VariableReference(return mWrapped, []), Expression(url, []), Expression(extras, []), Expression(cancellationSignal, [])])    VariableReference(return mWrapped, [])    Expression(url, [])    Expression(extras, [])    Expression(cancellationSignal, [])  Statement(} catch (RemoteException e) {, [])  Statement(return false, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(IContentProvider provider, []), Expression(acquireProvider(url), [])])    VariableReference(IContentProvider provider, [])    Expression(acquireProvider(url), [])  AssignmentExpression(=, [VariableReference(if (provider, []), Expression(, [])])    VariableReference(if (provider, [])    Expression(, [])  Statement(return false, [])  Statement(}, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(ICancellationSignal remoteCancellationSignal, []), Expression(null, [])])    VariableReference(ICancellationSignal remoteCancellationSignal, [])    Expression(null, [])  AssignmentExpression(=, [VariableReference(if (cancellationSignal !, []), Expression(null) {, [])])    VariableReference(if (cancellationSignal !, [])    Expression(null) {, [])  MethodCall(cancellationSignal.throwIfCanceled(), [VariableReference(cancellationSignal, []), Expression(, [])])    VariableReference(cancellationSignal, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(remoteCancellationSignal, []), Expression(provider.createCancellationSignal(), [])])    VariableReference(remoteCancellationSignal, [])    Expression(provider.createCancellationSignal(), [])  MethodCall(cancellationSignal.setRemote(remoteCancellationSignal), [VariableReference(cancellationSignal, []), Expression(remoteCancellationSignal, [])])    VariableReference(cancellationSignal, [])    Expression(remoteCancellationSignal, [])  Statement(}, [])  MethodCall(return provider.refresh(mPackageName, mAttributionTag, url, extras, remoteCancellationSignal), [VariableReference(return provider, []), Expression(mPackageName, []), Expression(mAttributionTag, []), Expression(url, []), Expression(extras, []), Expression(remoteCancellationSignal, [])])    VariableReference(return provider, [])    Expression(mPackageName, [])    Expression(mAttributionTag, [])    Expression(url, [])    Expression(extras, [])    Expression(remoteCancellationSignal, [])  Statement(} catch (RemoteException e) {, [])  Statement(// Manager will kill this process shortly anyway., [])  Statement(return false, [])  Statement(} finally {, [])  Statement(releaseProvider(provider), [])  Statement(}, [])  Statement(}, [])",1,"/**
 * This allows clients to request an explicit refresh of content identified by {@code uri}.
 * <p>
 * Client code should only invoke this method when there is a strong indication (such as a user
 * initiated pull to refresh gesture) that the content is stale.
 * <p>
 *
 * @param url The Uri identifying the data to refresh.
 * @param args Additional options from the client. The definitions of these are specific to the
 * content provider being called.
 * @param cancellationSignal A signal to cancel the operation in progress, or {@code null} if
 * none. For example, if you called refresh on a particular uri, you should call
 * {@link CancellationSignal#throwIfCanceled()} to check whether the client has
 * canceled the refresh request.
 * @return true if the provider actually tried refreshing.
 */
","/**
 * This allows clients to request an explicit refresh of content identified
 * by {@code uri}.
 * <p>
 * Client code should only invoke this method when there is a strong
 * indication (such as a user initiated pull to refresh gesture) that the
 * content is stale.
 * <p>
 *
 * @param url The Uri identifying the data to refresh.
 * @param extras Additional options from the client. The definitions of
 * these are specific to the content provider being called.
 * @param cancellationSignal A signal to cancel the operation in progress,
 * or {@code null} if none. For example, if you called refresh on
 * a particular uri, you should call
 * {@link CancellationSignal#throwIfCanceled()} to check whether
 * the client has canceled the refresh request.
 * @return true if the provider actually tried refreshing.
 */
",1,[@Override],[@Override],0,,,,"1,2","1,4,5",1,"1,5","1,2","The return statement has changed from `return mWrapped.refresh(url, args, cancellationSignal)` to `return mWrapped.refresh(url, extras, cancellationSignal)`, which potentially causes the API to return a different value, so the code change type is 1.","The dependent API has changed, the `refresh` method of `mWrapped` has a different parameter name `extras` instead of `args`, so the code change type is 5."
170,<android.database.sqlite.SQLiteQueryBuilder: boolean isStrict()>,29,30,<android.database.sqlite.SQLiteQueryBuilder: boolean isStrict()>,<android.database.sqlite.SQLiteQueryBuilder: boolean isStrict()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(return mStrict, []), Statement(}, [])])  Statement({, [])  Statement(return mStrict, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(return (mStrictFlags & STRICT_PARENTHESES) !, []), Expression(0, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(return (mStrictFlags & STRICT_PARENTHESES) !, []), Expression(0, [])])    VariableReference(return (mStrictFlags & STRICT_PARENTHESES) !, [])    Expression(0, [])  Statement(}, [])",1,"/**
 * Get if the query is marked as strict, as last configured by
 * {@link #setStrict(boolean)}.
 */
","/**
 * Get if the query is marked as strict, as last configured by
 * {@link #setStrict(boolean)}.
 */
",0,,,0,,,,1,1,1,1,1,"The return statement in early version is ""return mStrict"" while in late version it is ""return (mStrictFlags & STRICT\_PARENTHESES) != 0"". The mStrict variable in early version is a boolean, but in late version, it is replaced by a bitwise operation which returns a boolean value. This change could potentially cause different return values in the two versions.","The change in return statement could potentially cause different return values in the two versions, which could lead to different behaviors in the application that uses this API. Therefore, it is a Compatibility Issue caused by potential different return values or types."
171,<android.view.View: View getRootView()>,31,32,<android.view.View: View getRootView()>,<android.view.View: View getRootView()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mAttachInfo !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(final View v, []), Expression(mAttachInfo.mRootView, [])]), AssignmentExpression(=, [VariableReference(if (v !, []), Expression(null) {, [])]), Statement(return v, []), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(View parent, []), Expression(this, [])]), AssignmentExpression(=, [VariableReference(while (parent.mParent !, []), Expression(null && parent.mParent instanceof View) {, [])]), AssignmentExpression(=, [VariableReference(parent, []), Expression((View) parent.mParent, [])]), Statement(}, []), Statement(return parent, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mAttachInfo !, []), Expression(null) {, [])])    VariableReference(if (mAttachInfo !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(final View v, []), Expression(mAttachInfo.mRootView, [])])    VariableReference(final View v, [])    Expression(mAttachInfo.mRootView, [])  AssignmentExpression(=, [VariableReference(if (v !, []), Expression(null) {, [])])    VariableReference(if (v !, [])    Expression(null) {, [])  Statement(return v, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(View parent, []), Expression(this, [])])    VariableReference(View parent, [])    Expression(this, [])  AssignmentExpression(=, [VariableReference(while (parent.mParent !, []), Expression(null && parent.mParent instanceof View) {, [])])    VariableReference(while (parent.mParent !, [])    Expression(null && parent.mParent instanceof View) {, [])  AssignmentExpression(=, [VariableReference(parent, []), Expression((View) parent.mParent, [])])    VariableReference(parent, [])    Expression((View) parent.mParent, [])  Statement(}, [])  Statement(return parent, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mAttachInfo !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(final View v, []), Expression(mAttachInfo.mRootView, [])]), AssignmentExpression(=, [VariableReference(if (v !, []), Expression(null) {, [])]), Statement(return v, []), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(View parent, []), Expression(this, [])]), AssignmentExpression(=, [VariableReference(parent, []), Expression((View) parent.mParent, [])]), Statement(}, []), Statement(return parent, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mAttachInfo !, []), Expression(null) {, [])])    VariableReference(if (mAttachInfo !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(final View v, []), Expression(mAttachInfo.mRootView, [])])    VariableReference(final View v, [])    Expression(mAttachInfo.mRootView, [])  AssignmentExpression(=, [VariableReference(if (v !, []), Expression(null) {, [])])    VariableReference(if (v !, [])    Expression(null) {, [])  Statement(return v, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(View parent, []), Expression(this, [])])    VariableReference(View parent, [])    Expression(this, [])  AssignmentExpression(=, [VariableReference(parent, []), Expression((View) parent.mParent, [])])    VariableReference(parent, [])    Expression((View) parent.mParent, [])  Statement(}, [])  Statement(return parent, [])  Statement(}, [])",1,"/**
 * <p>Finds the topmost view in the current view hierarchy.</p>
 *
 * @return the topmost view containing this view
 */
","/**
 * <p>Finds the topmost view in the current view hierarchy.</p>
 *
 * @return the topmost view containing this view
 */
",0,,,0,,,,1,3,1,3,1,The early version of the API has an extra condition `(null && parent.mParent instanceof View)` in the while loop which is not present in the late version. This condition change affects the control flow of the API and can potentially lead to a different value being returned by the API.,"Since the control flow of the API can be different in the early and late versions due to the condition change in the while loop, the API can potentially return a different value in the two versions. Therefore, it is a compatibility issue caused by potential different return values or types."
172,<android.window.TaskSnapshot.Builder: TaskSnapshot build()>,31,32,<android.window.TaskSnapshot.Builder: TaskSnapshot build()>,<android.window.TaskSnapshot.Builder: TaskSnapshot build()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(false, /* isLowResolution */, []), Statement(mIsRealSnapshot, mWindowingMode, mAppearance, mIsTranslucent, mHasImeSurface), []), Statement(}, [])])  Statement({, [])  Statement(false, /* isLowResolution */, [])  Statement(mIsRealSnapshot, mWindowingMode, mAppearance, mIsTranslucent, mHasImeSurface), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(false, /* isLowResolution */, []), Statement(mIsRealSnapshot, mWindowingMode, mAppearance, mIsTranslucent, mHasImeSurface), []), Statement(}, [])])  Statement({, [])  Statement(false, /* isLowResolution */, [])  Statement(mIsRealSnapshot, mWindowingMode, mAppearance, mIsTranslucent, mHasImeSurface), [])  Statement(}, [])",1,,,0,,,0,,,,2,"1,5",1,0,0,"The AST nodes for the early and late versions of the implementation are exactly the same. Hence, there is no change in the code.","Since there is no change in the code, there is no compatibility issue that arises due to the change. The behavior of the API will remain the same in both the versions."
173,<android.companion.CompanionDeviceManager: List<String> getAssociations()>,32,33,<android.companion.CompanionDeviceManager: List<String> getAssociations()>,<android.companion.CompanionDeviceManager: List<String> getAssociations()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(if (!checkFeaturePresent()) {, []), MethodCall(return Collections.emptyList(), [VariableReference(return Collections, []), Expression(, [])]), Statement(}, []), Statement(try {, []), MethodCall(return mService.getAssociations(getCallingPackage(), mContext.getUserId()), [VariableReference(return mService, []), Expression(getCallingPackage(), []), Expression(mContext.getUserId(), [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(if (!checkFeaturePresent()) {, [])  MethodCall(return Collections.emptyList(), [VariableReference(return Collections, []), Expression(, [])])    VariableReference(return Collections, [])    Expression(, [])  Statement(}, [])  Statement(try {, [])  MethodCall(return mService.getAssociations(getCallingPackage(), mContext.getUserId()), [VariableReference(return mService, []), Expression(getCallingPackage(), []), Expression(mContext.getUserId(), [])])    VariableReference(return mService, [])    Expression(getCallingPackage(), [])    Expression(mContext.getUserId(), [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(return CollectionUtils.mapNotNull(getMyAssociations(), a -> a.isSelfManaged() ? null : a.getDeviceMacAddressAsString()), [VariableReference(return CollectionUtils, []), Expression(getMyAssociations(), []), Expression(a -> a.isSelfManaged() ? null : a.getDeviceMacAddressAsString(), [])]), Statement(}, [])])  Statement({, [])  MethodCall(return CollectionUtils.mapNotNull(getMyAssociations(), a -> a.isSelfManaged() ? null : a.getDeviceMacAddressAsString()), [VariableReference(return CollectionUtils, []), Expression(getMyAssociations(), []), Expression(a -> a.isSelfManaged() ? null : a.getDeviceMacAddressAsString(), [])])    VariableReference(return CollectionUtils, [])    Expression(getMyAssociations(), [])    Expression(a -> a.isSelfManaged() ? null : a.getDeviceMacAddressAsString(), [])  Statement(}, [])",1,"/**
 * <p>Calling this API requires a uses-feature
 * {@link PackageManager#FEATURE_COMPANION_DEVICE_SETUP} declaration in the manifest</p>
 *
 * @return a list of MAC addresses of devices that have been previously associated with the
 * current app. You can use these with {@link #disassociate}
 */
","/**
 * <p>Calling this API requires a uses-feature
 * {@link PackageManager#FEATURE_COMPANION_DEVICE_SETUP} declaration in the manifest</p>
 *
 * @return a list of MAC addresses of devices that have been previously associated with the
 * current app are managed by CompanionDeviceManager (ie. does not include devices managed by
 * application itself even if they have a MAC address).
 *
 * @deprecated use {@link #getMyAssociations()}
 */
",0,[@NonNull],"[@Deprecated, @UserHandleAware, @NonNull]",1,,,,1,"1,2,3","1,2","1,5","1,2","The implementation of the method getAssociations() has been completely changed between the early and late versions. The early version uses mService.getAssociations() to get the list of associations and returns it, whereas the late version uses CollectionUtils.mapNotNull() to get the list of associations and returns it. The late version also introduces a new method getMyAssociations(). Additionally, the exception handling statement in the early version has been removed in the late version.","The change in the implementation of the method getAssociations() can lead to different behaviors between the two versions. The early version returns the list of associations from mService.getAssociations(), while the late version returns the list of associations from CollectionUtils.mapNotNull() and a new method getMyAssociations(). This can potentially cause the API to return a different list of associations, which is a Compatibility Issue caused by potential different return values. Furthermore, the removal of the exception handling statement in the late version can also cause a Compatibility Issue, as the API may not handle the exception correctly in the late version, which is a Compatibility Issue caused by potential different exception handling."
174,android.hardware.camera2.CameraCharacteristics.get,31,32,<android.hardware.camera2.CameraCharacteristics: T get(Key<T>)>,<android.hardware.camera2.CameraCharacteristics: T get(Key<T>)>,0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(return mProperties.get(key), [VariableReference(return mProperties, []), Expression(key, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return mProperties.get(key), [VariableReference(return mProperties, []), Expression(key, [])])    VariableReference(return mProperties, [])    Expression(key, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(T propertyOverride, []), Expression(overrideProperty(key), [])]), AssignmentExpression(=, [VariableReference(return (propertyOverride !, []), Expression(null) ? propertyOverride : mProperties.get(key), [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(T propertyOverride, []), Expression(overrideProperty(key), [])])    VariableReference(T propertyOverride, [])    Expression(overrideProperty(key), [])  AssignmentExpression(=, [VariableReference(return (propertyOverride !, []), Expression(null) ? propertyOverride : mProperties.get(key), [])])    VariableReference(return (propertyOverride !, [])    Expression(null) ? propertyOverride : mProperties.get(key), [])  Statement(}, [])",1,"/**
 * Get a camera characteristics field value.
 *
 * <p>The field definitions can be
 * found in {@link CameraCharacteristics}.</p>
 *
 * <p>Querying the value for the same key more than once will return a value
 * which is equal to the previous queried value.</p>
 *
 * @throws IllegalArgumentException if the key was not valid
 *
 * @param key The characteristics field to read.
 * @return The value of that key, or {@code null} if the field is not set.
 */
","/**
 * Get a camera characteristics field value.
 *
 * <p>The field definitions can be
 * found in {@link CameraCharacteristics}.</p>
 *
 * <p>Querying the value for the same key more than once will return a value
 * which is equal to the previous queried value.</p>
 *
 * @throws IllegalArgumentException if the key was not valid
 *
 * @param key The characteristics field to read.
 * @return The value of that key, or {@code null} if the field is not set.
 */
",0,[@Nullable],[@Nullable],0,,,,1,"1,4",1,"1,5",1,The code change between the two versions is a combination of 1) Return statement changed and 5) Dependent API changed.,
175,android.accessibilityservice.AccessibilityService.createDisplayContext,31,32,<android.accessibilityservice.AccessibilityService: Context createDisplayContext(Display)>,<android.accessibilityservice.AccessibilityService: Context createDisplayContext(Display)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final Context context, []), Expression(super.createDisplayContext(display), [])]), AssignmentExpression(=, [VariableReference(final int displayId, []), Expression(display.getDisplayId(), [])]), Statement(setDefaultTokenInternal(context, displayId), []), Statement(return context, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final Context context, []), Expression(super.createDisplayContext(display), [])])    VariableReference(final Context context, [])    Expression(super.createDisplayContext(display), [])  AssignmentExpression(=, [VariableReference(final int displayId, []), Expression(display.getDisplayId(), [])])    VariableReference(final int displayId, [])    Expression(display.getDisplayId(), [])  Statement(setDefaultTokenInternal(context, displayId), [])  Statement(return context, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(return new AccessibilityContext(super.createDisplayContext(display), mConnectionId), [VariableReference(return new AccessibilityContext(super, []), Expression(display), []), Expression(mConnectionId, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return new AccessibilityContext(super.createDisplayContext(display), mConnectionId), [VariableReference(return new AccessibilityContext(super, []), Expression(display), []), Expression(mConnectionId, [])])    VariableReference(return new AccessibilityContext(super, [])    Expression(display), [])    Expression(mConnectionId, [])  Statement(}, [])",1,,,0,[@Override],"[@NonNull, @Override]",1,,,,1,"1,4",1,"1,5",1,The implementation of the createDisplayContext method has been changed from returning the context object directly to returning a new instance of AccessibilityContext with the context object and a connection ID.,"The change in the return statement could lead to compatibility issues as the client code may not be able to handle the new AccessibilityContext object and may be expecting the context object instead. Therefore, the Compatibility Issue type is 1."
176,android.app.ActivityThread.ProviderKey.hashCode,31,32,<android.app.ActivityThread.ProviderKey: int hashCode()>,<android.app.ActivityThread.ProviderKey: int hashCode()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(return hashCode(authority, userId), []), Statement(}, [])])  Statement({, [])  Statement(return hashCode(authority, userId), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(return ((authority !, []), Expression(null) ? authority.hashCode() : 0) ^ userId, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(return ((authority !, []), Expression(null) ? authority.hashCode() : 0) ^ userId, [])])    VariableReference(return ((authority !, [])    Expression(null) ? authority.hashCode() : 0) ^ userId, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,,1,"1,5",1,1,1,"The return statement has been changed from `hashCode(authority, userId)` to `((authority != null) ? authority.hashCode() : 0) ^ userId`. The new implementation uses the XOR (^) bitwise operator to calculate the hash code based on the authority and user ID.","The change in the return statement could lead to different hash code values being returned for the same input. This could cause compatibility issues if the hash code value is used in a way that depends on its value, such as in a hash table or a cache."
177,android.view.MotionEvent.PointerCoords.clear,31,32,<android.view.MotionEvent.PointerCoords: void clear()>,<android.view.MotionEvent.PointerCoords: void clear()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(mPackedAxisBits, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(x, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(y, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(pressure, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(size, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(touchMajor, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(touchMinor, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(toolMajor, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(toolMinor, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(orientation, []), Expression(0, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(mPackedAxisBits, []), Expression(0, [])])    VariableReference(mPackedAxisBits, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(x, []), Expression(0, [])])    VariableReference(x, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(y, []), Expression(0, [])])    VariableReference(y, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(pressure, []), Expression(0, [])])    VariableReference(pressure, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(size, []), Expression(0, [])])    VariableReference(size, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(touchMajor, []), Expression(0, [])])    VariableReference(touchMajor, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(touchMinor, []), Expression(0, [])])    VariableReference(touchMinor, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(toolMajor, []), Expression(0, [])])    VariableReference(toolMajor, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(toolMinor, []), Expression(0, [])])    VariableReference(toolMinor, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(orientation, []), Expression(0, [])])    VariableReference(orientation, [])    Expression(0, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(mPackedAxisBits, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(x, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(y, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(pressure, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(size, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(touchMajor, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(touchMinor, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(toolMajor, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(toolMinor, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(orientation, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(relativeX, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(relativeY, []), Expression(0, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(mPackedAxisBits, []), Expression(0, [])])    VariableReference(mPackedAxisBits, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(x, []), Expression(0, [])])    VariableReference(x, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(y, []), Expression(0, [])])    VariableReference(y, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(pressure, []), Expression(0, [])])    VariableReference(pressure, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(size, []), Expression(0, [])])    VariableReference(size, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(touchMajor, []), Expression(0, [])])    VariableReference(touchMajor, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(touchMinor, []), Expression(0, [])])    VariableReference(touchMinor, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(toolMajor, []), Expression(0, [])])    VariableReference(toolMajor, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(toolMinor, []), Expression(0, [])])    VariableReference(toolMinor, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(orientation, []), Expression(0, [])])    VariableReference(orientation, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(relativeX, []), Expression(0, [])])    VariableReference(relativeX, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(relativeY, []), Expression(0, [])])    VariableReference(relativeY, [])    Expression(0, [])  Statement(}, [])",1,"/**
 * Clears the contents of this object.
 * Resets all axes to zero.
 */
","/**
 * Clears the contents of this object.
 * Resets all axes to zero.
 */
",0,,,0,,,,1,4,0,4,0,"In the late version, two new assignment expressions have been added to the method declaration, which are ""AssignmentExpression(=, [VariableReference(relativeX, []), Expression(0, [])])"" and ""AssignmentExpression(=, [VariableReference(relativeY, []), Expression(0, [])])"". These expressions assign the value of 0 to the variables ""relativeX"" and ""relativeY"".","The added assignment expressions in the late version do not affect the return value or the exception handling of the method. Therefore, there is no compatibility issue caused by this code change."
1,<android.widget.TextView: void setInputType(int)>,30,31,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final boolean wasPassword, []), Expression(isPasswordInputType(getInputType()), [])]), AssignmentExpression(=, [VariableReference(final boolean wasVisiblePassword, []), Expression(isVisiblePasswordInputType(getInputType()), [])]), Statement(setInputType(type, false), []), AssignmentExpression(=, [VariableReference(final boolean isPassword, []), Expression(isPasswordInputType(type), [])]), AssignmentExpression(=, [VariableReference(final boolean isVisiblePassword, []), Expression(isVisiblePasswordInputType(type), [])]), AssignmentExpression(=, [VariableReference(boolean forceUpdate, []), Expression(false, [])]), Statement(if (isPassword) {, []), MethodCall(setTransformationMethod(PasswordTransformationMethod.getInstance()), [VariableReference(setTransformationMethod(PasswordTransformationMethod, []), Expression(), [])]), Statement(setTypefaceFromAttrs(null, /* fontTypeface */, []), Statement(null, /* fontFamily */, []), Statement(MONOSPACE, Typeface.NORMAL, -1), []), Statement(} else if (isVisiblePassword) {, []), AssignmentExpression(=, [VariableReference(if (mTransformation, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(forceUpdate, []), Expression(true, [])]), Statement(}, []), Statement(setTypefaceFromAttrs(null, /* fontTypeface */, []), Statement(null, /* fontFamily */, []), Statement(MONOSPACE, Typeface.NORMAL, -1), []), Statement(} else if (wasPassword || wasVisiblePassword) {, []), Statement(// not in password mode, clean up typeface and transformation, []), Statement(setTypefaceFromAttrs(null, /* fontTypeface */, []), Statement(null, /* fontFamily */, []), Statement(DEFAULT_TYPEFACE, /* typeface index */, []), Statement(Typeface.NORMAL, -1), []), AssignmentExpression(=, [VariableReference(if (mTransformation, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(forceUpdate, []), Expression(true, [])]), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(boolean singleLine, []), Expression(!isMultilineInputType(type), [])]), Statement(// were previously in password mode., []), AssignmentExpression(=, [VariableReference(if (mSingleLine !, []), Expression(singleLine || forceUpdate) {, [])]), Statement(// Change single line mode, but only change the transformation if, []), Statement(// we are not in password mode., []), Statement(applySingleLine(singleLine, !isPassword, true), []), Statement(}, []), Statement(if (!isSuggestionsEnabled()) {, []), Statement(setTextInternal(removeSuggestionSpans(mText)), []), Statement(}, []), AssignmentExpression(=, [VariableReference(InputMethodManager imm, []), Expression(getInputMethodManager(), [])]), AssignmentExpression(=, [VariableReference(if (imm !, []), Expression(null), [])]), MethodCall(imm.restartInput(this), [VariableReference(imm, []), Expression(this, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final boolean wasPassword, []), Expression(isPasswordInputType(getInputType()), [])])    VariableReference(final boolean wasPassword, [])    Expression(isPasswordInputType(getInputType()), [])  AssignmentExpression(=, [VariableReference(final boolean wasVisiblePassword, []), Expression(isVisiblePasswordInputType(getInputType()), [])])    VariableReference(final boolean wasVisiblePassword, [])    Expression(isVisiblePasswordInputType(getInputType()), [])  Statement(setInputType(type, false), [])  AssignmentExpression(=, [VariableReference(final boolean isPassword, []), Expression(isPasswordInputType(type), [])])    VariableReference(final boolean isPassword, [])    Expression(isPasswordInputType(type), [])  AssignmentExpression(=, [VariableReference(final boolean isVisiblePassword, []), Expression(isVisiblePasswordInputType(type), [])])    VariableReference(final boolean isVisiblePassword, [])    Expression(isVisiblePasswordInputType(type), [])  AssignmentExpression(=, [VariableReference(boolean forceUpdate, []), Expression(false, [])])    VariableReference(boolean forceUpdate, [])    Expression(false, [])  Statement(if (isPassword) {, [])  MethodCall(setTransformationMethod(PasswordTransformationMethod.getInstance()), [VariableReference(setTransformationMethod(PasswordTransformationMethod, []), Expression(), [])])    VariableReference(setTransformationMethod(PasswordTransformationMethod, [])    Expression(), [])  Statement(setTypefaceFromAttrs(null, /* fontTypeface */, [])  Statement(null, /* fontFamily */, [])  Statement(MONOSPACE, Typeface.NORMAL, -1), [])  Statement(} else if (isVisiblePassword) {, [])  AssignmentExpression(=, [VariableReference(if (mTransformation, []), Expression(, [])])    VariableReference(if (mTransformation, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(forceUpdate, []), Expression(true, [])])    VariableReference(forceUpdate, [])    Expression(true, [])  Statement(}, [])  Statement(setTypefaceFromAttrs(null, /* fontTypeface */, [])  Statement(null, /* fontFamily */, [])  Statement(MONOSPACE, Typeface.NORMAL, -1), [])  Statement(} else if (wasPassword || wasVisiblePassword) {, [])  Statement(// not in password mode, clean up typeface and transformation, [])  Statement(setTypefaceFromAttrs(null, /* fontTypeface */, [])  Statement(null, /* fontFamily */, [])  Statement(DEFAULT_TYPEFACE, /* typeface index */, [])  Statement(Typeface.NORMAL, -1), [])  AssignmentExpression(=, [VariableReference(if (mTransformation, []), Expression(, [])])    VariableReference(if (mTransformation, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(forceUpdate, []), Expression(true, [])])    VariableReference(forceUpdate, [])    Expression(true, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(boolean singleLine, []), Expression(!isMultilineInputType(type), [])])    VariableReference(boolean singleLine, [])    Expression(!isMultilineInputType(type), [])  Statement(// were previously in password mode., [])  AssignmentExpression(=, [VariableReference(if (mSingleLine !, []), Expression(singleLine || forceUpdate) {, [])])    VariableReference(if (mSingleLine !, [])    Expression(singleLine || forceUpdate) {, [])  Statement(// Change single line mode, but only change the transformation if, [])  Statement(// we are not in password mode., [])  Statement(applySingleLine(singleLine, !isPassword, true), [])  Statement(}, [])  Statement(if (!isSuggestionsEnabled()) {, [])  Statement(setTextInternal(removeSuggestionSpans(mText)), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(InputMethodManager imm, []), Expression(getInputMethodManager(), [])])    VariableReference(InputMethodManager imm, [])    Expression(getInputMethodManager(), [])  AssignmentExpression(=, [VariableReference(if (imm !, []), Expression(null), [])])    VariableReference(if (imm !, [])    Expression(null), [])  MethodCall(imm.restartInput(this), [VariableReference(imm, []), Expression(this, [])])    VariableReference(imm, [])    Expression(this, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final boolean wasPassword, []), Expression(isPasswordInputType(getInputType()), [])]), AssignmentExpression(=, [VariableReference(final boolean wasVisiblePassword, []), Expression(isVisiblePasswordInputType(getInputType()), [])]), Statement(setInputType(type, false), []), AssignmentExpression(=, [VariableReference(final boolean isPassword, []), Expression(isPasswordInputType(type), [])]), AssignmentExpression(=, [VariableReference(final boolean isVisiblePassword, []), Expression(isVisiblePasswordInputType(type), [])]), AssignmentExpression(=, [VariableReference(boolean forceUpdate, []), Expression(false, [])]), Statement(if (isPassword) {, []), MethodCall(setTransformationMethod(PasswordTransformationMethod.getInstance()), [VariableReference(setTransformationMethod(PasswordTransformationMethod, []), Expression(), [])]), Statement(setTypefaceFromAttrs(null, /* fontTypeface */, []), Statement(null, /* fontFamily */, []), Statement(MONOSPACE, Typeface.NORMAL, -1), []), Statement(} else if (isVisiblePassword) {, []), AssignmentExpression(=, [VariableReference(if (mTransformation, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(forceUpdate, []), Expression(true, [])]), Statement(}, []), Statement(setTypefaceFromAttrs(null, /* fontTypeface */, []), Statement(null, /* fontFamily */, []), Statement(MONOSPACE, Typeface.NORMAL, -1), []), Statement(} else if (wasPassword || wasVisiblePassword) {, []), Statement(// not in password mode, clean up typeface and transformation, []), Statement(setTypefaceFromAttrs(null, /* fontTypeface */, []), Statement(null, /* fontFamily */, []), Statement(DEFAULT_TYPEFACE, /* typeface index */, []), Statement(Typeface.NORMAL, -1), []), AssignmentExpression(=, [VariableReference(if (mTransformation, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(forceUpdate, []), Expression(true, [])]), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(boolean singleLine, []), Expression(!isMultilineInputType(type), [])]), Statement(// were previously in password mode., []), AssignmentExpression(=, [VariableReference(if (mSingleLine !, []), Expression(singleLine || forceUpdate) {, [])]), Statement(// Change single line mode, but only change the transformation if, []), Statement(// we are not in password mode., []), Statement(applySingleLine(singleLine, !isPassword, true, true), []), Statement(}, []), Statement(if (!isSuggestionsEnabled()) {, []), Statement(setTextInternal(removeSuggestionSpans(mText)), []), Statement(}, []), AssignmentExpression(=, [VariableReference(InputMethodManager imm, []), Expression(getInputMethodManager(), [])]), AssignmentExpression(=, [VariableReference(if (imm !, []), Expression(null), [])]), MethodCall(imm.restartInput(this), [VariableReference(imm, []), Expression(this, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final boolean wasPassword, []), Expression(isPasswordInputType(getInputType()), [])])    VariableReference(final boolean wasPassword, [])    Expression(isPasswordInputType(getInputType()), [])  AssignmentExpression(=, [VariableReference(final boolean wasVisiblePassword, []), Expression(isVisiblePasswordInputType(getInputType()), [])])    VariableReference(final boolean wasVisiblePassword, [])    Expression(isVisiblePasswordInputType(getInputType()), [])  Statement(setInputType(type, false), [])  AssignmentExpression(=, [VariableReference(final boolean isPassword, []), Expression(isPasswordInputType(type), [])])    VariableReference(final boolean isPassword, [])    Expression(isPasswordInputType(type), [])  AssignmentExpression(=, [VariableReference(final boolean isVisiblePassword, []), Expression(isVisiblePasswordInputType(type), [])])    VariableReference(final boolean isVisiblePassword, [])    Expression(isVisiblePasswordInputType(type), [])  AssignmentExpression(=, [VariableReference(boolean forceUpdate, []), Expression(false, [])])    VariableReference(boolean forceUpdate, [])    Expression(false, [])  Statement(if (isPassword) {, [])  MethodCall(setTransformationMethod(PasswordTransformationMethod.getInstance()), [VariableReference(setTransformationMethod(PasswordTransformationMethod, []), Expression(), [])])    VariableReference(setTransformationMethod(PasswordTransformationMethod, [])    Expression(), [])  Statement(setTypefaceFromAttrs(null, /* fontTypeface */, [])  Statement(null, /* fontFamily */, [])  Statement(MONOSPACE, Typeface.NORMAL, -1), [])  Statement(} else if (isVisiblePassword) {, [])  AssignmentExpression(=, [VariableReference(if (mTransformation, []), Expression(, [])])    VariableReference(if (mTransformation, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(forceUpdate, []), Expression(true, [])])    VariableReference(forceUpdate, [])    Expression(true, [])  Statement(}, [])  Statement(setTypefaceFromAttrs(null, /* fontTypeface */, [])  Statement(null, /* fontFamily */, [])  Statement(MONOSPACE, Typeface.NORMAL, -1), [])  Statement(} else if (wasPassword || wasVisiblePassword) {, [])  Statement(// not in password mode, clean up typeface and transformation, [])  Statement(setTypefaceFromAttrs(null, /* fontTypeface */, [])  Statement(null, /* fontFamily */, [])  Statement(DEFAULT_TYPEFACE, /* typeface index */, [])  Statement(Typeface.NORMAL, -1), [])  AssignmentExpression(=, [VariableReference(if (mTransformation, []), Expression(, [])])    VariableReference(if (mTransformation, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(forceUpdate, []), Expression(true, [])])    VariableReference(forceUpdate, [])    Expression(true, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(boolean singleLine, []), Expression(!isMultilineInputType(type), [])])    VariableReference(boolean singleLine, [])    Expression(!isMultilineInputType(type), [])  Statement(// were previously in password mode., [])  AssignmentExpression(=, [VariableReference(if (mSingleLine !, []), Expression(singleLine || forceUpdate) {, [])])    VariableReference(if (mSingleLine !, [])    Expression(singleLine || forceUpdate) {, [])  Statement(// Change single line mode, but only change the transformation if, [])  Statement(// we are not in password mode., [])  Statement(applySingleLine(singleLine, !isPassword, true, true), [])  Statement(}, [])  Statement(if (!isSuggestionsEnabled()) {, [])  Statement(setTextInternal(removeSuggestionSpans(mText)), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(InputMethodManager imm, []), Expression(getInputMethodManager(), [])])    VariableReference(InputMethodManager imm, [])    Expression(getInputMethodManager(), [])  AssignmentExpression(=, [VariableReference(if (imm !, []), Expression(null), [])])    VariableReference(if (imm !, [])    Expression(null), [])  MethodCall(imm.restartInput(this), [VariableReference(imm, []), Expression(this, [])])    VariableReference(imm, [])    Expression(this, [])  Statement(}, [])",1,"/**
 * Set the type of the content with a constant as defined for {@link EditorInfo#inputType}. This
 * will take care of changing the key listener, by calling {@link #setKeyListener(KeyListener)},
 * to match the given content type.  If the given content type is {@link EditorInfo#TYPE_NULL}
 * then a soft keyboard will not be displayed for this text view.
 *
 * Note that the maximum number of displayed lines (see {@link #setMaxLines(int)}) will be
 * modified if you change the {@link EditorInfo#TYPE_TEXT_FLAG_MULTI_LINE} flag of the input
 * type.
 *
 * @see #getInputType()
 * @see #setRawInputType(int)
 * @see android.text.InputType
 * @attr ref android.R.styleable#TextView_inputType
 */
","/**
 * Set the type of the content with a constant as defined for {@link EditorInfo#inputType}. This
 * will take care of changing the key listener, by calling {@link #setKeyListener(KeyListener)},
 * to match the given content type.  If the given content type is {@link EditorInfo#TYPE_NULL}
 * then a soft keyboard will not be displayed for this text view.
 *
 * Note that the maximum number of displayed lines (see {@link #setMaxLines(int)}) will be
 * modified if you change the {@link EditorInfo#TYPE_TEXT_FLAG_MULTI_LINE} flag of the input
 * type.
 *
 * @see #getInputType()
 * @see #setRawInputType(int)
 * @see android.text.InputType
 * @attr ref android.R.styleable#TextView_inputType
 */
",0,,,0,,,,2,5,0,4,1,The method "applySingleLine" in the late version implementation has an additional parameter "true" compared to the early version implementation. This additional parameter may affect the behavior of the method and potentially cause compatibility issues.,"The compatibility issue arises from the potential different behavior of the ""applySingleLine"" method in the late version implementation. If the method behaves differently, it may lead to different visual or functional effects for the TextView, which may not be expected by the developers or users. Therefore, the compatibility issue is classified as type 1 - Compatibility Issue caused by potential different return values or types."
2,<android.os.UserManager: boolean isUserUnlocked(UserHandle)>,30,31,,,,"MethodDeclaration(method_body, [Statement({, []), MethodCall(return isUserUnlocked(user.getIdentifier()), [VariableReference(return isUserUnlocked(user, []), Expression(), [])]), Statement(}, [])])  Statement({, [])  MethodCall(return isUserUnlocked(user.getIdentifier()), [VariableReference(return isUserUnlocked(user, []), Expression(), [])])    VariableReference(return isUserUnlocked(user, [])    Expression(), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(return isUserUnlocked(user.getIdentifier()), [VariableReference(return isUserUnlocked(user, []), Expression(), [])]), Statement(}, [])])  Statement({, [])  MethodCall(return isUserUnlocked(user.getIdentifier()), [VariableReference(return isUserUnlocked(user, []), Expression(), [])])    VariableReference(return isUserUnlocked(user, [])    Expression(), [])  Statement(}, [])",0,"/**
 * Return whether the given user is running in an ""unlocked"" state.
 * <p>
 * On devices with direct boot, a user is unlocked only after they've
 * entered their credentials (such as a lock pattern or PIN). On devices
 * without direct boot, a user is unlocked as soon as it starts.
 * <p>
 * When a user is locked, only device-protected data storage is available.
 * When a user is unlocked, both device-protected and credential-protected
 * private app data storage is available.
 * <p>Requires {@code android.permission.MANAGE_USERS} or
 * {@code android.permission.INTERACT_ACROSS_USERS}, otherwise specified {@link UserHandle user}
 * must be the calling user or a managed profile associated with it.
 *
 * @param user to retrieve the unlocked state for.
 * @see Intent#ACTION_USER_UNLOCKED
 * @see Context#createDeviceProtectedStorageContext()
 */
","/**
 * Return whether the given user is running in an ""unlocked"" state.
 * <p>
 * On devices with direct boot, a user is unlocked only after they've
 * entered their credentials (such as a lock pattern or PIN). On devices
 * without direct boot, a user is unlocked as soon as it starts.
 * <p>
 * When a user is locked, only device-protected data storage is available.
 * When a user is unlocked, both device-protected and credential-protected
 * private app data storage is available.
 * <p>Requires {@code android.permission.MANAGE_USERS} or
 * {@code android.permission.INTERACT_ACROSS_USERS}, otherwise specified {@link UserHandle user}
 * must be the calling user or a profile associated with it.
 *
 * @param user to retrieve the unlocked state for.
 * @see Intent#ACTION_USER_UNLOCKED
 * @see Context#createDeviceProtectedStorageContext()
 */
",1,"[@RequiresPermission(anyOf = { Manifest.permission.MANAGE_USERS, Manifest.permission.INTERACT_ACROSS_USERS }, conditional = true)]","[@RequiresPermission(anyOf = { Manifest.permission.MANAGE_USERS, Manifest.permission.INTERACT_ACROSS_USERS }, conditional = true)]",0,,,,0,0,0,0,0,"The implementation and the annotations of the API ""isUserUnlocked(UserHandle)"" in the early version and the late version are exactly the same. And the only difference between the two versions is the comment, where the phrase ""managed profile"" is changed to ""profile"". However, this change in the comment does not affect the behavior of the API.","As there is no code change between the two versions of the API, there is no Compatibility Issue (CI) existing in the given method between the two continuous versions."
3,<android.widget.HorizontalScrollView: boolean onTouchEvent(MotionEvent)>,30,31,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(initVelocityTrackerIfNotExists(), []), MethodCall(mVelocityTracker.addMovement(ev), [VariableReference(mVelocityTracker, []), Expression(ev, [])]), AssignmentExpression(=, [VariableReference(final int action, []), Expression(ev.getAction(), [])]), Statement(case MotionEvent.ACTION_DOWN:, []), Statement({, []), AssignmentExpression(=, [VariableReference(if (getChildCount(), []), Expression(, [])]), Statement(return false, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if ((mIsBeingDragged, []), Expression(!mScroller.isFinished())) {, [])]), AssignmentExpression(=, [VariableReference(final ViewParent parent, []), Expression(getParent(), [])]), AssignmentExpression(=, [VariableReference(if (parent !, []), Expression(null) {, [])]), MethodCall(parent.requestDisallowInterceptTouchEvent(true), [VariableReference(parent, []), Expression(true, [])]), Statement(}, []), Statement(}, []), Statement(/*, []), Statement(* If being flinged and user touches, stop the fling. isFinished, []), Statement(* will be false if being flinged., []), Statement(*/, []), MethodCall(if (!mScroller.isFinished()), [VariableReference(if (!mScroller, []), Expression(), [])]), MethodCall(mScroller.abortAnimation(), [VariableReference(mScroller, []), Expression(, [])]), Statement(}, []), Statement(// Remember where the motion event started, []), AssignmentExpression(=, [VariableReference(mLastMotionX, []), Expression((int) ev.getX(), [])]), AssignmentExpression(=, [VariableReference(mActivePointerId, []), Expression(ev.getPointerId(0), [])]), Statement(break, []), Statement(}, []), Statement(case MotionEvent.ACTION_MOVE:, []), AssignmentExpression(=, [VariableReference(final int activePointerIndex, []), Expression(ev.findPointerIndex(mActivePointerId), [])]), AssignmentExpression(=, [VariableReference(if (activePointerIndex, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(Log.e(TAG, ""Invalid pointerId, []), Expression("" + mActivePointerId + "" in onTouchEvent""), [])]), Statement(break, []), Statement(}, []), AssignmentExpression(=, [VariableReference(final int x, []), Expression((int) ev.getX(activePointerIndex), [])]), AssignmentExpression(=, [VariableReference(int deltaX, []), Expression(mLastMotionX - x, [])]), MethodCall(if (!mIsBeingDragged && Math.abs(deltaX) > mTouchSlop), [VariableReference(if (!mIsBeingDragged && Math, []), Expression(deltaX) > mTouchSlop, [])]), AssignmentExpression(=, [VariableReference(final ViewParent parent, []), Expression(getParent(), [])]), AssignmentExpression(=, [VariableReference(if (parent !, []), Expression(null) {, [])]), MethodCall(parent.requestDisallowInterceptTouchEvent(true), [VariableReference(parent, []), Expression(true, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(mIsBeingDragged, []), Expression(true, [])]), Statement(if (deltaX > 0) {, []), AssignmentExpression(=, [VariableReference(deltaX -, []), Expression(mTouchSlop, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(deltaX +, []), Expression(mTouchSlop, [])]), Statement(}, []), Statement(}, []), Statement(if (mIsBeingDragged) {, []), Statement(// Scroll to follow the motion event, []), AssignmentExpression(=, [VariableReference(mLastMotionX, []), Expression(x, [])]), AssignmentExpression(=, [VariableReference(final int oldX, []), Expression(mScrollX, [])]), AssignmentExpression(=, [VariableReference(final int oldY, []), Expression(mScrollY, [])]), AssignmentExpression(=, [VariableReference(final int range, []), Expression(getScrollRange(), [])]), AssignmentExpression(=, [VariableReference(final int overscrollMode, []), Expression(getOverScrollMode(), [])]), AssignmentExpression(=, [VariableReference(final boolean canOverscroll, []), Expression(overscrollMode, [])]), Statement(// calls onScrollChanged if applicable., []), Statement(if (overScrollBy(deltaX, 0, mScrollX, 0, range, 0, mOverscrollDistance, 0, true)) {, []), Statement(// Break our velocity if we hit a scroll barrier., []), MethodCall(mVelocityTracker.clear(), [VariableReference(mVelocityTracker, []), Expression(, [])]), Statement(}, []), Statement(if (canOverscroll) {, []), AssignmentExpression(=, [VariableReference(final int pulledToX, []), Expression(oldX + deltaX, [])]), Statement(if (pulledToX < 0) {, []), MethodCall(mEdgeGlowLeft.onPull((float) deltaX / getWidth(), 1.f - ev.getY(activePointerIndex) / getHeight()), [VariableReference(mEdgeGlowLeft, []), Expression((float) deltaX / getWidth(), []), Expression(1.f - ev.getY(activePointerIndex) / getHeight(), [])]), MethodCall(if (!mEdgeGlowRight.isFinished()), [VariableReference(if (!mEdgeGlowRight, []), Expression(), [])]), MethodCall(mEdgeGlowRight.onRelease(), [VariableReference(mEdgeGlowRight, []), Expression(, [])]), Statement(}, []), Statement(} else if (pulledToX > range) {, []), MethodCall(mEdgeGlowRight.onPull((float) deltaX / getWidth(), ev.getY(activePointerIndex) / getHeight()), [VariableReference(mEdgeGlowRight, []), Expression((float) deltaX / getWidth(), []), Expression(ev.getY(activePointerIndex) / getHeight(), [])]), MethodCall(if (!mEdgeGlowLeft.isFinished()), [VariableReference(if (!mEdgeGlowLeft, []), Expression(), [])]), MethodCall(mEdgeGlowLeft.onRelease(), [VariableReference(mEdgeGlowLeft, []), Expression(, [])]), Statement(}, []), Statement(}, []), MethodCall(if (shouldDisplayEdgeEffects() && (!mEdgeGlowLeft.isFinished() || !mEdgeGlowRight.isFinished())), [VariableReference(if (shouldDisplayEdgeEffects() && (!mEdgeGlowLeft, []), Expression() || !mEdgeGlowRight.isFinished()), [])]), Statement(postInvalidateOnAnimation(), []), Statement(}, []), Statement(}, []), Statement(}, []), Statement(break, []), Statement(case MotionEvent.ACTION_UP:, []), Statement(if (mIsBeingDragged) {, []), AssignmentExpression(=, [VariableReference(final VelocityTracker velocityTracker, []), Expression(mVelocityTracker, [])]), MethodCall(velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity), [VariableReference(velocityTracker, []), Expression(1000, []), Expression(mMaximumVelocity, [])]), AssignmentExpression(=, [VariableReference(int initialVelocity, []), Expression((int) velocityTracker.getXVelocity(mActivePointerId), [])]), Statement(if (getChildCount() > 0) {, []), MethodCall(if ((Math.abs(initialVelocity) > mMinimumVelocity)), [VariableReference(if ((Math, []), Expression(initialVelocity) > mMinimumVelocity), [])]), Statement(fling(-initialVelocity), []), Statement(} else {, []), MethodCall(if (mScroller.springBack(mScrollX, mScrollY, 0, getScrollRange(), 0, 0)), [VariableReference(if (mScroller, []), Expression(mScrollX, []), Expression(mScrollY, []), Expression(0, []), Expression(getScrollRange(), []), Expression(0, []), Expression(0), [])]), Statement(postInvalidateOnAnimation(), []), Statement(}, []), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(mActivePointerId, []), Expression(INVALID_POINTER, [])]), AssignmentExpression(=, [VariableReference(mIsBeingDragged, []), Expression(false, [])]), Statement(recycleVelocityTracker(), []), Statement(if (shouldDisplayEdgeEffects()) {, []), MethodCall(mEdgeGlowLeft.onRelease(), [VariableReference(mEdgeGlowLeft, []), Expression(, [])]), MethodCall(mEdgeGlowRight.onRelease(), [VariableReference(mEdgeGlowRight, []), Expression(, [])]), Statement(}, []), Statement(}, []), Statement(break, []), Statement(case MotionEvent.ACTION_CANCEL:, []), Statement(if (mIsBeingDragged && getChildCount() > 0) {, []), MethodCall(if (mScroller.springBack(mScrollX, mScrollY, 0, getScrollRange(), 0, 0)), [VariableReference(if (mScroller, []), Expression(mScrollX, []), Expression(mScrollY, []), Expression(0, []), Expression(getScrollRange(), []), Expression(0, []), Expression(0), [])]), Statement(postInvalidateOnAnimation(), []), Statement(}, []), AssignmentExpression(=, [VariableReference(mActivePointerId, []), Expression(INVALID_POINTER, [])]), AssignmentExpression(=, [VariableReference(mIsBeingDragged, []), Expression(false, [])]), Statement(recycleVelocityTracker(), []), Statement(if (shouldDisplayEdgeEffects()) {, []), MethodCall(mEdgeGlowLeft.onRelease(), [VariableReference(mEdgeGlowLeft, []), Expression(, [])]), MethodCall(mEdgeGlowRight.onRelease(), [VariableReference(mEdgeGlowRight, []), Expression(, [])]), Statement(}, []), Statement(}, []), Statement(break, []), Statement(case MotionEvent.ACTION_POINTER_UP:, []), Statement(onSecondaryPointerUp(ev), []), Statement(break, []), Statement(}, []), Statement(return true, []), Statement(}, [])])  Statement({, [])  Statement(initVelocityTrackerIfNotExists(), [])  MethodCall(mVelocityTracker.addMovement(ev), [VariableReference(mVelocityTracker, []), Expression(ev, [])])    VariableReference(mVelocityTracker, [])    Expression(ev, [])  AssignmentExpression(=, [VariableReference(final int action, []), Expression(ev.getAction(), [])])    VariableReference(final int action, [])    Expression(ev.getAction(), [])  Statement(case MotionEvent.ACTION_DOWN:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (getChildCount(), []), Expression(, [])])    VariableReference(if (getChildCount(), [])    Expression(, [])  Statement(return false, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if ((mIsBeingDragged, []), Expression(!mScroller.isFinished())) {, [])])    VariableReference(if ((mIsBeingDragged, [])    Expression(!mScroller.isFinished())) {, [])  AssignmentExpression(=, [VariableReference(final ViewParent parent, []), Expression(getParent(), [])])    VariableReference(final ViewParent parent, [])    Expression(getParent(), [])  AssignmentExpression(=, [VariableReference(if (parent !, []), Expression(null) {, [])])    VariableReference(if (parent !, [])    Expression(null) {, [])  MethodCall(parent.requestDisallowInterceptTouchEvent(true), [VariableReference(parent, []), Expression(true, [])])    VariableReference(parent, [])    Expression(true, [])  Statement(}, [])  Statement(}, [])  Statement(/*, [])  Statement(* If being flinged and user touches, stop the fling. isFinished, [])  Statement(* will be false if being flinged., [])  Statement(*/, [])  MethodCall(if (!mScroller.isFinished()), [VariableReference(if (!mScroller, []), Expression(), [])])    VariableReference(if (!mScroller, [])    Expression(), [])  MethodCall(mScroller.abortAnimation(), [VariableReference(mScroller, []), Expression(, [])])    VariableReference(mScroller, [])    Expression(, [])  Statement(}, [])  Statement(// Remember where the motion event started, [])  AssignmentExpression(=, [VariableReference(mLastMotionX, []), Expression((int) ev.getX(), [])])    VariableReference(mLastMotionX, [])    Expression((int) ev.getX(), [])  AssignmentExpression(=, [VariableReference(mActivePointerId, []), Expression(ev.getPointerId(0), [])])    VariableReference(mActivePointerId, [])    Expression(ev.getPointerId(0), [])  Statement(break, [])  Statement(}, [])  Statement(case MotionEvent.ACTION_MOVE:, [])  AssignmentExpression(=, [VariableReference(final int activePointerIndex, []), Expression(ev.findPointerIndex(mActivePointerId), [])])    VariableReference(final int activePointerIndex, [])    Expression(ev.findPointerIndex(mActivePointerId), [])  AssignmentExpression(=, [VariableReference(if (activePointerIndex, []), Expression(, [])])    VariableReference(if (activePointerIndex, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(Log.e(TAG, ""Invalid pointerId, []), Expression("" + mActivePointerId + "" in onTouchEvent""), [])])    VariableReference(Log.e(TAG, ""Invalid pointerId, [])    Expression("" + mActivePointerId + "" in onTouchEvent""), [])  Statement(break, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(final int x, []), Expression((int) ev.getX(activePointerIndex), [])])    VariableReference(final int x, [])    Expression((int) ev.getX(activePointerIndex), [])  AssignmentExpression(=, [VariableReference(int deltaX, []), Expression(mLastMotionX - x, [])])    VariableReference(int deltaX, [])    Expression(mLastMotionX - x, [])  MethodCall(if (!mIsBeingDragged && Math.abs(deltaX) > mTouchSlop), [VariableReference(if (!mIsBeingDragged && Math, []), Expression(deltaX) > mTouchSlop, [])])    VariableReference(if (!mIsBeingDragged && Math, [])    Expression(deltaX) > mTouchSlop, [])  AssignmentExpression(=, [VariableReference(final ViewParent parent, []), Expression(getParent(), [])])    VariableReference(final ViewParent parent, [])    Expression(getParent(), [])  AssignmentExpression(=, [VariableReference(if (parent !, []), Expression(null) {, [])])    VariableReference(if (parent !, [])    Expression(null) {, [])  MethodCall(parent.requestDisallowInterceptTouchEvent(true), [VariableReference(parent, []), Expression(true, [])])    VariableReference(parent, [])    Expression(true, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mIsBeingDragged, []), Expression(true, [])])    VariableReference(mIsBeingDragged, [])    Expression(true, [])  Statement(if (deltaX > 0) {, [])  AssignmentExpression(=, [VariableReference(deltaX -, []), Expression(mTouchSlop, [])])    VariableReference(deltaX -, [])    Expression(mTouchSlop, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(deltaX +, []), Expression(mTouchSlop, [])])    VariableReference(deltaX +, [])    Expression(mTouchSlop, [])  Statement(}, [])  Statement(}, [])  Statement(if (mIsBeingDragged) {, [])  Statement(// Scroll to follow the motion event, [])  AssignmentExpression(=, [VariableReference(mLastMotionX, []), Expression(x, [])])    VariableReference(mLastMotionX, [])    Expression(x, [])  AssignmentExpression(=, [VariableReference(final int oldX, []), Expression(mScrollX, [])])    VariableReference(final int oldX, [])    Expression(mScrollX, [])  AssignmentExpression(=, [VariableReference(final int oldY, []), Expression(mScrollY, [])])    VariableReference(final int oldY, [])    Expression(mScrollY, [])  AssignmentExpression(=, [VariableReference(final int range, []), Expression(getScrollRange(), [])])    VariableReference(final int range, [])    Expression(getScrollRange(), [])  AssignmentExpression(=, [VariableReference(final int overscrollMode, []), Expression(getOverScrollMode(), [])])    VariableReference(final int overscrollMode, [])    Expression(getOverScrollMode(), [])  AssignmentExpression(=, [VariableReference(final boolean canOverscroll, []), Expression(overscrollMode, [])])    VariableReference(final boolean canOverscroll, [])    Expression(overscrollMode, [])  Statement(// calls onScrollChanged if applicable., [])  Statement(if (overScrollBy(deltaX, 0, mScrollX, 0, range, 0, mOverscrollDistance, 0, true)) {, [])  Statement(// Break our velocity if we hit a scroll barrier., [])  MethodCall(mVelocityTracker.clear(), [VariableReference(mVelocityTracker, []), Expression(, [])])    VariableReference(mVelocityTracker, [])    Expression(, [])  Statement(}, [])  Statement(if (canOverscroll) {, [])  AssignmentExpression(=, [VariableReference(final int pulledToX, []), Expression(oldX + deltaX, [])])    VariableReference(final int pulledToX, [])    Expression(oldX + deltaX, [])  Statement(if (pulledToX < 0) {, [])  MethodCall(mEdgeGlowLeft.onPull((float) deltaX / getWidth(), 1.f - ev.getY(activePointerIndex) / getHeight()), [VariableReference(mEdgeGlowLeft, []), Expression((float) deltaX / getWidth(), []), Expression(1.f - ev.getY(activePointerIndex) / getHeight(), [])])    VariableReference(mEdgeGlowLeft, [])    Expression((float) deltaX / getWidth(), [])    Expression(1.f - ev.getY(activePointerIndex) / getHeight(), [])  MethodCall(if (!mEdgeGlowRight.isFinished()), [VariableReference(if (!mEdgeGlowRight, []), Expression(), [])])    VariableReference(if (!mEdgeGlowRight, [])    Expression(), [])  MethodCall(mEdgeGlowRight.onRelease(), [VariableReference(mEdgeGlowRight, []), Expression(, [])])    VariableReference(mEdgeGlowRight, [])    Expression(, [])  Statement(}, [])  Statement(} else if (pulledToX > range) {, [])  MethodCall(mEdgeGlowRight.onPull((float) deltaX / getWidth(), ev.getY(activePointerIndex) / getHeight()), [VariableReference(mEdgeGlowRight, []), Expression((float) deltaX / getWidth(), []), Expression(ev.getY(activePointerIndex) / getHeight(), [])])    VariableReference(mEdgeGlowRight, [])    Expression((float) deltaX / getWidth(), [])    Expression(ev.getY(activePointerIndex) / getHeight(), [])  MethodCall(if (!mEdgeGlowLeft.isFinished()), [VariableReference(if (!mEdgeGlowLeft, []), Expression(), [])])    VariableReference(if (!mEdgeGlowLeft, [])    Expression(), [])  MethodCall(mEdgeGlowLeft.onRelease(), [VariableReference(mEdgeGlowLeft, []), Expression(, [])])    VariableReference(mEdgeGlowLeft, [])    Expression(, [])  Statement(}, [])  Statement(}, [])  MethodCall(if (shouldDisplayEdgeEffects() && (!mEdgeGlowLeft.isFinished() || !mEdgeGlowRight.isFinished())), [VariableReference(if (shouldDisplayEdgeEffects() && (!mEdgeGlowLeft, []), Expression() || !mEdgeGlowRight.isFinished()), [])])    VariableReference(if (shouldDisplayEdgeEffects() && (!mEdgeGlowLeft, [])    Expression() || !mEdgeGlowRight.isFinished()), [])  Statement(postInvalidateOnAnimation(), [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(break, [])  Statement(case MotionEvent.ACTION_UP:, [])  Statement(if (mIsBeingDragged) {, [])  AssignmentExpression(=, [VariableReference(final VelocityTracker velocityTracker, []), Expression(mVelocityTracker, [])])    VariableReference(final VelocityTracker velocityTracker, [])    Expression(mVelocityTracker, [])  MethodCall(velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity), [VariableReference(velocityTracker, []), Expression(1000, []), Expression(mMaximumVelocity, [])])    VariableReference(velocityTracker, [])    Expression(1000, [])    Expression(mMaximumVelocity, [])  AssignmentExpression(=, [VariableReference(int initialVelocity, []), Expression((int) velocityTracker.getXVelocity(mActivePointerId), [])])    VariableReference(int initialVelocity, [])    Expression((int) velocityTracker.getXVelocity(mActivePointerId), [])  Statement(if (getChildCount() > 0) {, [])  MethodCall(if ((Math.abs(initialVelocity) > mMinimumVelocity)), [VariableReference(if ((Math, []), Expression(initialVelocity) > mMinimumVelocity), [])])    VariableReference(if ((Math, [])    Expression(initialVelocity) > mMinimumVelocity), [])  Statement(fling(-initialVelocity), [])  Statement(} else {, [])  MethodCall(if (mScroller.springBack(mScrollX, mScrollY, 0, getScrollRange(), 0, 0)), [VariableReference(if (mScroller, []), Expression(mScrollX, []), Expression(mScrollY, []), Expression(0, []), Expression(getScrollRange(), []), Expression(0, []), Expression(0), [])])    VariableReference(if (mScroller, [])    Expression(mScrollX, [])    Expression(mScrollY, [])    Expression(0, [])    Expression(getScrollRange(), [])    Expression(0, [])    Expression(0), [])  Statement(postInvalidateOnAnimation(), [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mActivePointerId, []), Expression(INVALID_POINTER, [])])    VariableReference(mActivePointerId, [])    Expression(INVALID_POINTER, [])  AssignmentExpression(=, [VariableReference(mIsBeingDragged, []), Expression(false, [])])    VariableReference(mIsBeingDragged, [])    Expression(false, [])  Statement(recycleVelocityTracker(), [])  Statement(if (shouldDisplayEdgeEffects()) {, [])  MethodCall(mEdgeGlowLeft.onRelease(), [VariableReference(mEdgeGlowLeft, []), Expression(, [])])    VariableReference(mEdgeGlowLeft, [])    Expression(, [])  MethodCall(mEdgeGlowRight.onRelease(), [VariableReference(mEdgeGlowRight, []), Expression(, [])])    VariableReference(mEdgeGlowRight, [])    Expression(, [])  Statement(}, [])  Statement(}, [])  Statement(break, [])  Statement(case MotionEvent.ACTION_CANCEL:, [])  Statement(if (mIsBeingDragged && getChildCount() > 0) {, [])  MethodCall(if (mScroller.springBack(mScrollX, mScrollY, 0, getScrollRange(), 0, 0)), [VariableReference(if (mScroller, []), Expression(mScrollX, []), Expression(mScrollY, []), Expression(0, []), Expression(getScrollRange(), []), Expression(0, []), Expression(0), [])])    VariableReference(if (mScroller, [])    Expression(mScrollX, [])    Expression(mScrollY, [])    Expression(0, [])    Expression(getScrollRange(), [])    Expression(0, [])    Expression(0), [])  Statement(postInvalidateOnAnimation(), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mActivePointerId, []), Expression(INVALID_POINTER, [])])    VariableReference(mActivePointerId, [])    Expression(INVALID_POINTER, [])  AssignmentExpression(=, [VariableReference(mIsBeingDragged, []), Expression(false, [])])    VariableReference(mIsBeingDragged, [])    Expression(false, [])  Statement(recycleVelocityTracker(), [])  Statement(if (shouldDisplayEdgeEffects()) {, [])  MethodCall(mEdgeGlowLeft.onRelease(), [VariableReference(mEdgeGlowLeft, []), Expression(, [])])    VariableReference(mEdgeGlowLeft, [])    Expression(, [])  MethodCall(mEdgeGlowRight.onRelease(), [VariableReference(mEdgeGlowRight, []), Expression(, [])])    VariableReference(mEdgeGlowRight, [])    Expression(, [])  Statement(}, [])  Statement(}, [])  Statement(break, [])  Statement(case MotionEvent.ACTION_POINTER_UP:, [])  Statement(onSecondaryPointerUp(ev), [])  Statement(break, [])  Statement(}, [])  Statement(return true, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(initVelocityTrackerIfNotExists(), []), MethodCall(mVelocityTracker.addMovement(ev), [VariableReference(mVelocityTracker, []), Expression(ev, [])]), AssignmentExpression(=, [VariableReference(final int action, []), Expression(ev.getAction(), [])]), Statement(case MotionEvent.ACTION_DOWN:, []), Statement({, []), AssignmentExpression(=, [VariableReference(if (getChildCount(), []), Expression(, [])]), Statement(return false, []), Statement(}, []), MethodCall(if (!mScroller.isFinished()), [VariableReference(if (!mScroller, []), Expression(), [])]), AssignmentExpression(=, [VariableReference(final ViewParent parent, []), Expression(getParent(), [])]), AssignmentExpression(=, [VariableReference(if (parent !, []), Expression(null) {, [])]), MethodCall(parent.requestDisallowInterceptTouchEvent(true), [VariableReference(parent, []), Expression(true, [])]), Statement(}, []), Statement(}, []), Statement(/*, []), Statement(* If being flinged and user touches, stop the fling. isFinished, []), Statement(* will be false if being flinged., []), Statement(*/, []), MethodCall(if (!mScroller.isFinished()), [VariableReference(if (!mScroller, []), Expression(), [])]), MethodCall(mScroller.abortAnimation(), [VariableReference(mScroller, []), Expression(, [])]), Statement(}, []), Statement(// Remember where the motion event started, []), AssignmentExpression(=, [VariableReference(mLastMotionX, []), Expression((int) ev.getX(), [])]), AssignmentExpression(=, [VariableReference(mActivePointerId, []), Expression(ev.getPointerId(0), [])]), Statement(break, []), Statement(}, []), Statement(case MotionEvent.ACTION_MOVE:, []), AssignmentExpression(=, [VariableReference(final int activePointerIndex, []), Expression(ev.findPointerIndex(mActivePointerId), [])]), AssignmentExpression(=, [VariableReference(if (activePointerIndex, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(Log.e(TAG, ""Invalid pointerId, []), Expression("" + mActivePointerId + "" in onTouchEvent""), [])]), Statement(break, []), Statement(}, []), AssignmentExpression(=, [VariableReference(final int x, []), Expression((int) ev.getX(activePointerIndex), [])]), AssignmentExpression(=, [VariableReference(int deltaX, []), Expression(mLastMotionX - x, [])]), MethodCall(if (!mIsBeingDragged && Math.abs(deltaX) > mTouchSlop), [VariableReference(if (!mIsBeingDragged && Math, []), Expression(deltaX) > mTouchSlop, [])]), AssignmentExpression(=, [VariableReference(final ViewParent parent, []), Expression(getParent(), [])]), AssignmentExpression(=, [VariableReference(if (parent !, []), Expression(null) {, [])]), MethodCall(parent.requestDisallowInterceptTouchEvent(true), [VariableReference(parent, []), Expression(true, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(mIsBeingDragged, []), Expression(true, [])]), Statement(if (deltaX > 0) {, []), AssignmentExpression(=, [VariableReference(deltaX -, []), Expression(mTouchSlop, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(deltaX +, []), Expression(mTouchSlop, [])]), Statement(}, []), Statement(}, []), Statement(if (mIsBeingDragged) {, []), Statement(// Scroll to follow the motion event, []), AssignmentExpression(=, [VariableReference(mLastMotionX, []), Expression(x, [])]), AssignmentExpression(=, [VariableReference(final int oldX, []), Expression(mScrollX, [])]), AssignmentExpression(=, [VariableReference(final int range, []), Expression(getScrollRange(), [])]), AssignmentExpression(=, [VariableReference(final int overscrollMode, []), Expression(getOverScrollMode(), [])]), AssignmentExpression(=, [VariableReference(final boolean canOverscroll, []), Expression(overscrollMode, [])]), AssignmentExpression(=, [VariableReference(final float displacement, []), Expression(ev.getY(activePointerIndex) / getHeight(), [])]), Statement(if (canOverscroll) {, []), AssignmentExpression(=, [VariableReference(int consumed, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(if (deltaX < 0 && mEdgeGlowRight.getDistance() !, []), Expression(0f) {, [])]), AssignmentExpression(=, [VariableReference(consumed, []), Expression(Math.round(getWidth() * mEdgeGlowRight.onPullDistance((float) deltaX / getWidth(), displacement)), [])]), AssignmentExpression(=, [VariableReference(} else if (deltaX > 0 && mEdgeGlowLeft.getDistance() !, []), Expression(0f) {, [])]), AssignmentExpression(=, [VariableReference(consumed, []), Expression(Math.round(-getWidth() * mEdgeGlowLeft.onPullDistance((float) -deltaX / getWidth(), 1 - displacement)), [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(deltaX -, []), Expression(consumed, [])]), Statement(}, []), Statement(// Calling overScrollBy will call onOverScrolled, which, []), Statement(// calls onScrollChanged if applicable., []), Statement(overScrollBy(deltaX, 0, mScrollX, 0, range, 0, mOverscrollDistance, 0, true), []), AssignmentExpression(=, [VariableReference(if (canOverscroll && deltaX !, []), Expression(0f) {, [])]), AssignmentExpression(=, [VariableReference(final int pulledToX, []), Expression(oldX + deltaX, [])]), Statement(if (pulledToX < 0) {, []), MethodCall(mEdgeGlowLeft.onPullDistance((float) -deltaX / getWidth(), 1.f - displacement), [VariableReference(mEdgeGlowLeft, []), Expression((float) -deltaX / getWidth(), []), Expression(1.f - displacement, [])]), MethodCall(if (!mEdgeGlowRight.isFinished()), [VariableReference(if (!mEdgeGlowRight, []), Expression(), [])]), MethodCall(mEdgeGlowRight.onRelease(), [VariableReference(mEdgeGlowRight, []), Expression(, [])]), Statement(}, []), Statement(} else if (pulledToX > range) {, []), MethodCall(mEdgeGlowRight.onPullDistance((float) deltaX / getWidth(), displacement), [VariableReference(mEdgeGlowRight, []), Expression((float) deltaX / getWidth(), []), Expression(displacement, [])]), MethodCall(if (!mEdgeGlowLeft.isFinished()), [VariableReference(if (!mEdgeGlowLeft, []), Expression(), [])]), MethodCall(mEdgeGlowLeft.onRelease(), [VariableReference(mEdgeGlowLeft, []), Expression(, [])]), Statement(}, []), Statement(}, []), MethodCall(if (shouldDisplayEdgeEffects() && (!mEdgeGlowLeft.isFinished() || !mEdgeGlowRight.isFinished())), [VariableReference(if (shouldDisplayEdgeEffects() && (!mEdgeGlowLeft, []), Expression() || !mEdgeGlowRight.isFinished()), [])]), Statement(postInvalidateOnAnimation(), []), Statement(}, []), Statement(}, []), Statement(}, []), Statement(break, []), Statement(case MotionEvent.ACTION_UP:, []), Statement(if (mIsBeingDragged) {, []), AssignmentExpression(=, [VariableReference(final VelocityTracker velocityTracker, []), Expression(mVelocityTracker, [])]), MethodCall(velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity), [VariableReference(velocityTracker, []), Expression(1000, []), Expression(mMaximumVelocity, [])]), AssignmentExpression(=, [VariableReference(int initialVelocity, []), Expression((int) velocityTracker.getXVelocity(mActivePointerId), [])]), Statement(if (getChildCount() > 0) {, []), MethodCall(if ((Math.abs(initialVelocity) > mMinimumVelocity)), [VariableReference(if ((Math, []), Expression(initialVelocity) > mMinimumVelocity), [])]), Statement(fling(-initialVelocity), []), Statement(} else {, []), MethodCall(if (mScroller.springBack(mScrollX, mScrollY, 0, getScrollRange(), 0, 0)), [VariableReference(if (mScroller, []), Expression(mScrollX, []), Expression(mScrollY, []), Expression(0, []), Expression(getScrollRange(), []), Expression(0, []), Expression(0), [])]), Statement(postInvalidateOnAnimation(), []), Statement(}, []), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(mActivePointerId, []), Expression(INVALID_POINTER, [])]), AssignmentExpression(=, [VariableReference(mIsBeingDragged, []), Expression(false, [])]), Statement(recycleVelocityTracker(), []), Statement(if (shouldDisplayEdgeEffects()) {, []), MethodCall(mEdgeGlowLeft.onRelease(), [VariableReference(mEdgeGlowLeft, []), Expression(, [])]), MethodCall(mEdgeGlowRight.onRelease(), [VariableReference(mEdgeGlowRight, []), Expression(, [])]), Statement(}, []), Statement(}, []), Statement(break, []), Statement(case MotionEvent.ACTION_CANCEL:, []), Statement(if (mIsBeingDragged && getChildCount() > 0) {, []), MethodCall(if (mScroller.springBack(mScrollX, mScrollY, 0, getScrollRange(), 0, 0)), [VariableReference(if (mScroller, []), Expression(mScrollX, []), Expression(mScrollY, []), Expression(0, []), Expression(getScrollRange(), []), Expression(0, []), Expression(0), [])]), Statement(postInvalidateOnAnimation(), []), Statement(}, []), AssignmentExpression(=, [VariableReference(mActivePointerId, []), Expression(INVALID_POINTER, [])]), AssignmentExpression(=, [VariableReference(mIsBeingDragged, []), Expression(false, [])]), Statement(recycleVelocityTracker(), []), Statement(if (shouldDisplayEdgeEffects()) {, []), MethodCall(mEdgeGlowLeft.onRelease(), [VariableReference(mEdgeGlowLeft, []), Expression(, [])]), MethodCall(mEdgeGlowRight.onRelease(), [VariableReference(mEdgeGlowRight, []), Expression(, [])]), Statement(}, []), Statement(}, []), Statement(break, []), Statement(case MotionEvent.ACTION_POINTER_UP:, []), Statement(onSecondaryPointerUp(ev), []), Statement(break, []), Statement(}, []), Statement(return true, []), Statement(}, [])])  Statement({, [])  Statement(initVelocityTrackerIfNotExists(), [])  MethodCall(mVelocityTracker.addMovement(ev), [VariableReference(mVelocityTracker, []), Expression(ev, [])])    VariableReference(mVelocityTracker, [])    Expression(ev, [])  AssignmentExpression(=, [VariableReference(final int action, []), Expression(ev.getAction(), [])])    VariableReference(final int action, [])    Expression(ev.getAction(), [])  Statement(case MotionEvent.ACTION_DOWN:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (getChildCount(), []), Expression(, [])])    VariableReference(if (getChildCount(), [])    Expression(, [])  Statement(return false, [])  Statement(}, [])  MethodCall(if (!mScroller.isFinished()), [VariableReference(if (!mScroller, []), Expression(), [])])    VariableReference(if (!mScroller, [])    Expression(), [])  AssignmentExpression(=, [VariableReference(final ViewParent parent, []), Expression(getParent(), [])])    VariableReference(final ViewParent parent, [])    Expression(getParent(), [])  AssignmentExpression(=, [VariableReference(if (parent !, []), Expression(null) {, [])])    VariableReference(if (parent !, [])    Expression(null) {, [])  MethodCall(parent.requestDisallowInterceptTouchEvent(true), [VariableReference(parent, []), Expression(true, [])])    VariableReference(parent, [])    Expression(true, [])  Statement(}, [])  Statement(}, [])  Statement(/*, [])  Statement(* If being flinged and user touches, stop the fling. isFinished, [])  Statement(* will be false if being flinged., [])  Statement(*/, [])  MethodCall(if (!mScroller.isFinished()), [VariableReference(if (!mScroller, []), Expression(), [])])    VariableReference(if (!mScroller, [])    Expression(), [])  MethodCall(mScroller.abortAnimation(), [VariableReference(mScroller, []), Expression(, [])])    VariableReference(mScroller, [])    Expression(, [])  Statement(}, [])  Statement(// Remember where the motion event started, [])  AssignmentExpression(=, [VariableReference(mLastMotionX, []), Expression((int) ev.getX(), [])])    VariableReference(mLastMotionX, [])    Expression((int) ev.getX(), [])  AssignmentExpression(=, [VariableReference(mActivePointerId, []), Expression(ev.getPointerId(0), [])])    VariableReference(mActivePointerId, [])    Expression(ev.getPointerId(0), [])  Statement(break, [])  Statement(}, [])  Statement(case MotionEvent.ACTION_MOVE:, [])  AssignmentExpression(=, [VariableReference(final int activePointerIndex, []), Expression(ev.findPointerIndex(mActivePointerId), [])])    VariableReference(final int activePointerIndex, [])    Expression(ev.findPointerIndex(mActivePointerId), [])  AssignmentExpression(=, [VariableReference(if (activePointerIndex, []), Expression(, [])])    VariableReference(if (activePointerIndex, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(Log.e(TAG, ""Invalid pointerId, []), Expression("" + mActivePointerId + "" in onTouchEvent""), [])])    VariableReference(Log.e(TAG, ""Invalid pointerId, [])    Expression("" + mActivePointerId + "" in onTouchEvent""), [])  Statement(break, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(final int x, []), Expression((int) ev.getX(activePointerIndex), [])])    VariableReference(final int x, [])    Expression((int) ev.getX(activePointerIndex), [])  AssignmentExpression(=, [VariableReference(int deltaX, []), Expression(mLastMotionX - x, [])])    VariableReference(int deltaX, [])    Expression(mLastMotionX - x, [])  MethodCall(if (!mIsBeingDragged && Math.abs(deltaX) > mTouchSlop), [VariableReference(if (!mIsBeingDragged && Math, []), Expression(deltaX) > mTouchSlop, [])])    VariableReference(if (!mIsBeingDragged && Math, [])    Expression(deltaX) > mTouchSlop, [])  AssignmentExpression(=, [VariableReference(final ViewParent parent, []), Expression(getParent(), [])])    VariableReference(final ViewParent parent, [])    Expression(getParent(), [])  AssignmentExpression(=, [VariableReference(if (parent !, []), Expression(null) {, [])])    VariableReference(if (parent !, [])    Expression(null) {, [])  MethodCall(parent.requestDisallowInterceptTouchEvent(true), [VariableReference(parent, []), Expression(true, [])])    VariableReference(parent, [])    Expression(true, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mIsBeingDragged, []), Expression(true, [])])    VariableReference(mIsBeingDragged, [])    Expression(true, [])  Statement(if (deltaX > 0) {, [])  AssignmentExpression(=, [VariableReference(deltaX -, []), Expression(mTouchSlop, [])])    VariableReference(deltaX -, [])    Expression(mTouchSlop, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(deltaX +, []), Expression(mTouchSlop, [])])    VariableReference(deltaX +, [])    Expression(mTouchSlop, [])  Statement(}, [])  Statement(}, [])  Statement(if (mIsBeingDragged) {, [])  Statement(// Scroll to follow the motion event, [])  AssignmentExpression(=, [VariableReference(mLastMotionX, []), Expression(x, [])])    VariableReference(mLastMotionX, [])    Expression(x, [])  AssignmentExpression(=, [VariableReference(final int oldX, []), Expression(mScrollX, [])])    VariableReference(final int oldX, [])    Expression(mScrollX, [])  AssignmentExpression(=, [VariableReference(final int range, []), Expression(getScrollRange(), [])])    VariableReference(final int range, [])    Expression(getScrollRange(), [])  AssignmentExpression(=, [VariableReference(final int overscrollMode, []), Expression(getOverScrollMode(), [])])    VariableReference(final int overscrollMode, [])    Expression(getOverScrollMode(), [])  AssignmentExpression(=, [VariableReference(final boolean canOverscroll, []), Expression(overscrollMode, [])])    VariableReference(final boolean canOverscroll, [])    Expression(overscrollMode, [])  AssignmentExpression(=, [VariableReference(final float displacement, []), Expression(ev.getY(activePointerIndex) / getHeight(), [])])    VariableReference(final float displacement, [])    Expression(ev.getY(activePointerIndex) / getHeight(), [])  Statement(if (canOverscroll) {, [])  AssignmentExpression(=, [VariableReference(int consumed, []), Expression(0, [])])    VariableReference(int consumed, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(if (deltaX < 0 && mEdgeGlowRight.getDistance() !, []), Expression(0f) {, [])])    VariableReference(if (deltaX < 0 && mEdgeGlowRight.getDistance() !, [])    Expression(0f) {, [])  AssignmentExpression(=, [VariableReference(consumed, []), Expression(Math.round(getWidth() * mEdgeGlowRight.onPullDistance((float) deltaX / getWidth(), displacement)), [])])    VariableReference(consumed, [])    Expression(Math.round(getWidth() * mEdgeGlowRight.onPullDistance((float) deltaX / getWidth(), displacement)), [])  AssignmentExpression(=, [VariableReference(} else if (deltaX > 0 && mEdgeGlowLeft.getDistance() !, []), Expression(0f) {, [])])    VariableReference(} else if (deltaX > 0 && mEdgeGlowLeft.getDistance() !, [])    Expression(0f) {, [])  AssignmentExpression(=, [VariableReference(consumed, []), Expression(Math.round(-getWidth() * mEdgeGlowLeft.onPullDistance((float) -deltaX / getWidth(), 1 - displacement)), [])])    VariableReference(consumed, [])    Expression(Math.round(-getWidth() * mEdgeGlowLeft.onPullDistance((float) -deltaX / getWidth(), 1 - displacement)), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(deltaX -, []), Expression(consumed, [])])    VariableReference(deltaX -, [])    Expression(consumed, [])  Statement(}, [])  Statement(// Calling overScrollBy will call onOverScrolled, which, [])  Statement(// calls onScrollChanged if applicable., [])  Statement(overScrollBy(deltaX, 0, mScrollX, 0, range, 0, mOverscrollDistance, 0, true), [])  AssignmentExpression(=, [VariableReference(if (canOverscroll && deltaX !, []), Expression(0f) {, [])])    VariableReference(if (canOverscroll && deltaX !, [])    Expression(0f) {, [])  AssignmentExpression(=, [VariableReference(final int pulledToX, []), Expression(oldX + deltaX, [])])    VariableReference(final int pulledToX, [])    Expression(oldX + deltaX, [])  Statement(if (pulledToX < 0) {, [])  MethodCall(mEdgeGlowLeft.onPullDistance((float) -deltaX / getWidth(), 1.f - displacement), [VariableReference(mEdgeGlowLeft, []), Expression((float) -deltaX / getWidth(), []), Expression(1.f - displacement, [])])    VariableReference(mEdgeGlowLeft, [])    Expression((float) -deltaX / getWidth(), [])    Expression(1.f - displacement, [])  MethodCall(if (!mEdgeGlowRight.isFinished()), [VariableReference(if (!mEdgeGlowRight, []), Expression(), [])])    VariableReference(if (!mEdgeGlowRight, [])    Expression(), [])  MethodCall(mEdgeGlowRight.onRelease(), [VariableReference(mEdgeGlowRight, []), Expression(, [])])    VariableReference(mEdgeGlowRight, [])    Expression(, [])  Statement(}, [])  Statement(} else if (pulledToX > range) {, [])  MethodCall(mEdgeGlowRight.onPullDistance((float) deltaX / getWidth(), displacement), [VariableReference(mEdgeGlowRight, []), Expression((float) deltaX / getWidth(), []), Expression(displacement, [])])    VariableReference(mEdgeGlowRight, [])    Expression((float) deltaX / getWidth(), [])    Expression(displacement, [])  MethodCall(if (!mEdgeGlowLeft.isFinished()), [VariableReference(if (!mEdgeGlowLeft, []), Expression(), [])])    VariableReference(if (!mEdgeGlowLeft, [])    Expression(), [])  MethodCall(mEdgeGlowLeft.onRelease(), [VariableReference(mEdgeGlowLeft, []), Expression(, [])])    VariableReference(mEdgeGlowLeft, [])    Expression(, [])  Statement(}, [])  Statement(}, [])  MethodCall(if (shouldDisplayEdgeEffects() && (!mEdgeGlowLeft.isFinished() || !mEdgeGlowRight.isFinished())), [VariableReference(if (shouldDisplayEdgeEffects() && (!mEdgeGlowLeft, []), Expression() || !mEdgeGlowRight.isFinished()), [])])    VariableReference(if (shouldDisplayEdgeEffects() && (!mEdgeGlowLeft, [])    Expression() || !mEdgeGlowRight.isFinished()), [])  Statement(postInvalidateOnAnimation(), [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(break, [])  Statement(case MotionEvent.ACTION_UP:, [])  Statement(if (mIsBeingDragged) {, [])  AssignmentExpression(=, [VariableReference(final VelocityTracker velocityTracker, []), Expression(mVelocityTracker, [])])    VariableReference(final VelocityTracker velocityTracker, [])    Expression(mVelocityTracker, [])  MethodCall(velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity), [VariableReference(velocityTracker, []), Expression(1000, []), Expression(mMaximumVelocity, [])])    VariableReference(velocityTracker, [])    Expression(1000, [])    Expression(mMaximumVelocity, [])  AssignmentExpression(=, [VariableReference(int initialVelocity, []), Expression((int) velocityTracker.getXVelocity(mActivePointerId), [])])    VariableReference(int initialVelocity, [])    Expression((int) velocityTracker.getXVelocity(mActivePointerId), [])  Statement(if (getChildCount() > 0) {, [])  MethodCall(if ((Math.abs(initialVelocity) > mMinimumVelocity)), [VariableReference(if ((Math, []), Expression(initialVelocity) > mMinimumVelocity), [])])    VariableReference(if ((Math, [])    Expression(initialVelocity) > mMinimumVelocity), [])  Statement(fling(-initialVelocity), [])  Statement(} else {, [])  MethodCall(if (mScroller.springBack(mScrollX, mScrollY, 0, getScrollRange(), 0, 0)), [VariableReference(if (mScroller, []), Expression(mScrollX, []), Expression(mScrollY, []), Expression(0, []), Expression(getScrollRange(), []), Expression(0, []), Expression(0), [])])    VariableReference(if (mScroller, [])    Expression(mScrollX, [])    Expression(mScrollY, [])    Expression(0, [])    Expression(getScrollRange(), [])    Expression(0, [])    Expression(0), [])  Statement(postInvalidateOnAnimation(), [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mActivePointerId, []), Expression(INVALID_POINTER, [])])    VariableReference(mActivePointerId, [])    Expression(INVALID_POINTER, [])  AssignmentExpression(=, [VariableReference(mIsBeingDragged, []), Expression(false, [])])    VariableReference(mIsBeingDragged, [])    Expression(false, [])  Statement(recycleVelocityTracker(), [])  Statement(if (shouldDisplayEdgeEffects()) {, [])  MethodCall(mEdgeGlowLeft.onRelease(), [VariableReference(mEdgeGlowLeft, []), Expression(, [])])    VariableReference(mEdgeGlowLeft, [])    Expression(, [])  MethodCall(mEdgeGlowRight.onRelease(), [VariableReference(mEdgeGlowRight, []), Expression(, [])])    VariableReference(mEdgeGlowRight, [])    Expression(, [])  Statement(}, [])  Statement(}, [])  Statement(break, [])  Statement(case MotionEvent.ACTION_CANCEL:, [])  Statement(if (mIsBeingDragged && getChildCount() > 0) {, [])  MethodCall(if (mScroller.springBack(mScrollX, mScrollY, 0, getScrollRange(), 0, 0)), [VariableReference(if (mScroller, []), Expression(mScrollX, []), Expression(mScrollY, []), Expression(0, []), Expression(getScrollRange(), []), Expression(0, []), Expression(0), [])])    VariableReference(if (mScroller, [])    Expression(mScrollX, [])    Expression(mScrollY, [])    Expression(0, [])    Expression(getScrollRange(), [])    Expression(0, [])    Expression(0), [])  Statement(postInvalidateOnAnimation(), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mActivePointerId, []), Expression(INVALID_POINTER, [])])    VariableReference(mActivePointerId, [])    Expression(INVALID_POINTER, [])  AssignmentExpression(=, [VariableReference(mIsBeingDragged, []), Expression(false, [])])    VariableReference(mIsBeingDragged, [])    Expression(false, [])  Statement(recycleVelocityTracker(), [])  Statement(if (shouldDisplayEdgeEffects()) {, [])  MethodCall(mEdgeGlowLeft.onRelease(), [VariableReference(mEdgeGlowLeft, []), Expression(, [])])    VariableReference(mEdgeGlowLeft, [])    Expression(, [])  MethodCall(mEdgeGlowRight.onRelease(), [VariableReference(mEdgeGlowRight, []), Expression(, [])])    VariableReference(mEdgeGlowRight, [])    Expression(, [])  Statement(}, [])  Statement(}, [])  Statement(break, [])  Statement(case MotionEvent.ACTION_POINTER_UP:, [])  Statement(onSecondaryPointerUp(ev), [])  Statement(break, [])  Statement(}, [])  Statement(return true, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,,"1,2","3,4,5",0,"3,4","1,2",The method implementation has changed in the following ways:,2. The `overScrollBy()` method call has been moved outside of the `if (mIsBeingDragged)` block.
4,<android.view.textclassifier.TextClassificationSession: TextLanguage detectLanguage(Request)>,30,31,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(checkDestroyed(), []), MethodCall(return mDelegate.detectLanguage(request), [VariableReference(return mDelegate, []), Expression(request, [])]), Statement(}, [])])  Statement({, [])  Statement(checkDestroyed(), [])  MethodCall(return mDelegate.detectLanguage(request), [VariableReference(return mDelegate, []), Expression(request, [])])    VariableReference(return mDelegate, [])    Expression(request, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(return checkDestroyedAndRun(() -> mDelegate.detectLanguage(request)), [VariableReference(return checkDestroyedAndRun(() -> mDelegate, []), Expression(request), [])]), Statement(}, [])])  Statement({, [])  MethodCall(return checkDestroyedAndRun(() -> mDelegate.detectLanguage(request)), [VariableReference(return checkDestroyedAndRun(() -> mDelegate, []), Expression(request), [])])    VariableReference(return checkDestroyedAndRun(() -> mDelegate, [])    Expression(request), [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,,2,"1,5",1,2,2,The implementation of the method `detectLanguage` has been changed from `return mDelegate.detectLanguage(request)` to `return checkDestroyedAndRun(() -> mDelegate.detectLanguage(request))`. This is a change in the exception handling statement as the new implementation adds a check for the object being destroyed before executing the delegate method.,"The change in the implementation can potentially lead to a different exception being thrown. In the early version, if the `mDelegate` object is destroyed, a `NullPointerException` may be thrown. However, in the late version, the `checkDestroyedAndRun` method may throw a different exception (e.g., `IllegalStateException`) if the object is destroyed. This can impact the code that calls this method and expects a specific exception to be thrown in certain scenarios."
5,<android.inputmethodservice.InputMethodService: void requestShowSelf(int)>,30,31,,,,"MethodDeclaration(method_body, [Statement({, []), MethodCall(mPrivOps.showMySoftInput(flags), [VariableReference(mPrivOps, []), Expression(flags, [])]), Statement(}, [])])  Statement({, [])  MethodCall(mPrivOps.showMySoftInput(flags), [VariableReference(mPrivOps, []), Expression(flags, [])])    VariableReference(mPrivOps, [])    Expression(flags, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(ImeTracing.getInstance().triggerServiceDump(""InputMethodService#requestShowSelf"", this, null), [VariableReference(ImeTracing, []), Expression().triggerServiceDump(""InputMethodService#requestShowSelf"", []), Expression(this, []), Expression(null, [])]), MethodCall(mPrivOps.showMySoftInput(flags), [VariableReference(mPrivOps, []), Expression(flags, [])]), Statement(}, [])])  Statement({, [])  MethodCall(ImeTracing.getInstance().triggerServiceDump(""InputMethodService#requestShowSelf"", this, null), [VariableReference(ImeTracing, []), Expression().triggerServiceDump(""InputMethodService#requestShowSelf"", []), Expression(this, []), Expression(null, [])])    VariableReference(ImeTracing, [])    Expression().triggerServiceDump(""InputMethodService#requestShowSelf"", [])    Expression(this, [])    Expression(null, [])  MethodCall(mPrivOps.showMySoftInput(flags), [VariableReference(mPrivOps, []), Expression(flags, [])])    VariableReference(mPrivOps, [])    Expression(flags, [])  Statement(}, [])",1,"/**
 * Show the input method's soft input area, so the user sees the input method window and can
 * interact with it.
 *
 * @see InputMethodManager#SHOW_IMPLICIT
 * @see InputMethodManager#SHOW_FORCED
 * @param flags Provides additional operating flags.
 */
","/**
 * Show the input method's soft input area, so the user sees the input method window and can
 * interact with it.
 *
 * @see InputMethodManager#SHOW_IMPLICIT
 * @see InputMethodManager#SHOW_FORCED
 * @param flags Provides additional operating flags.
 */
",0,,,0,,,,"1,2",4,0,4,0,"A new method call statement has been added before the method call of mPrivOps.showMySoftInput(flags). The new statement is ImeTracing.getInstance().triggerServiceDump(""InputMethodService#requestShowSelf"", this, null), which is used for tracing the input method service.","The added method call statement does not affect the return value or exception handling of the API requestShowSelf(int), so there is no compatibility issue."
7,<android.app.admin.DevicePolicyManager: DevicePolicyManager getParentProfileInstance(ComponentName)>,30,31,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(throwIfParentInstance(""getParentProfileInstance""), []), Statement(try {, []), MethodCall(if (!mService.isManagedProfile(admin)), [VariableReference(if (!mService, []), Expression(admin), [])]), Statement(}, []), Statement(return new DevicePolicyManager(mContext, mService, true), []), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(throwIfParentInstance(""getParentProfileInstance""), [])  Statement(try {, [])  MethodCall(if (!mService.isManagedProfile(admin)), [VariableReference(if (!mService, []), Expression(admin), [])])    VariableReference(if (!mService, [])    Expression(admin), [])  Statement(}, [])  Statement(return new DevicePolicyManager(mContext, mService, true), [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(throwIfParentInstance(""getParentProfileInstance""), []), Statement(try {, []), MethodCall(if (!mService.isManagedProfile(admin)), [VariableReference(if (!mService, []), Expression(admin), [])]), Statement(}, []), Statement(return new DevicePolicyManager(mContext, mService, true), []), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(throwIfParentInstance(""getParentProfileInstance""), [])  Statement(try {, [])  MethodCall(if (!mService.isManagedProfile(admin)), [VariableReference(if (!mService, []), Expression(admin), [])])    VariableReference(if (!mService, [])    Expression(admin), [])  Statement(}, [])  Statement(return new DevicePolicyManager(mContext, mService, true), [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",0,"/**
 * Called by the profile owner of a managed profile to obtain a {@link DevicePolicyManager}
 * whose calls act on the parent profile.
 *
 * <p>The following methods are supported for the parent instance, all other methods will
 * throw a SecurityException when called on the parent instance:
 * <ul>
 * <li>{@link #getPasswordQuality}</li>
 * <li>{@link #setPasswordQuality}</li>
 * <li>{@link #getPasswordMinimumLength}</li>
 * <li>{@link #setPasswordMinimumLength}</li>
 * <li>{@link #getPasswordMinimumUpperCase}</li>
 * <li>{@link #setPasswordMinimumUpperCase}</li>
 * <li>{@link #getPasswordMinimumLowerCase}</li>
 * <li>{@link #setPasswordMinimumLowerCase}</li>
 * <li>{@link #getPasswordMinimumLetters}</li>
 * <li>{@link #setPasswordMinimumLetters}</li>
 * <li>{@link #getPasswordMinimumNumeric}</li>
 * <li>{@link #setPasswordMinimumNumeric}</li>
 * <li>{@link #getPasswordMinimumSymbols}</li>
 * <li>{@link #setPasswordMinimumSymbols}</li>
 * <li>{@link #getPasswordMinimumNonLetter}</li>
 * <li>{@link #setPasswordMinimumNonLetter}</li>
 * <li>{@link #getPasswordHistoryLength}</li>
 * <li>{@link #setPasswordHistoryLength}</li>
 * <li>{@link #getPasswordExpirationTimeout}</li>
 * <li>{@link #setPasswordExpirationTimeout}</li>
 * <li>{@link #getPasswordExpiration}</li>
 * <li>{@link #getPasswordMaximumLength}</li>
 * <li>{@link #isActivePasswordSufficient}</li>
 * <li>{@link #getCurrentFailedPasswordAttempts}</li>
 * <li>{@link #getMaximumFailedPasswordsForWipe}</li>
 * <li>{@link #setMaximumFailedPasswordsForWipe}</li>
 * <li>{@link #getMaximumTimeToLock}</li>
 * <li>{@link #setMaximumTimeToLock}</li>
 * <li>{@link #lockNow}</li>
 * <li>{@link #getKeyguardDisabledFeatures}</li>
 * <li>{@link #setKeyguardDisabledFeatures}</li>
 * <li>{@link #getTrustAgentConfiguration}</li>
 * <li>{@link #setTrustAgentConfiguration}</li>
 * <li>{@link #getRequiredStrongAuthTimeout}</li>
 * <li>{@link #setRequiredStrongAuthTimeout}</li>
 * <li>{@link #getAccountTypesWithManagementDisabled}</li>
 * </ul>
 * <p>
 * The following methods are supported for the parent instance but can only be called by the
 * profile owner of a managed profile that was created during the device provisioning flow:
 * <ul>
 * <li>{@link #getPasswordComplexity}</li>
 * <li>{@link #setCameraDisabled}</li>
 * <li>{@link #getCameraDisabled}</li>
 * <li>{@link #setAccountManagementDisabled(ComponentName, String, boolean)}</li>
 * </ul>
 *
 * <p>The following methods can be called by the profile owner of a managed profile
 * on an organization-owned device:
 * <ul>
 * <li>{@link #wipeData}</li>
 * </ul>
 *
 * @return a new instance of {@link DevicePolicyManager} that acts on the parent profile.
 * @throws SecurityException if {@code admin} is not a profile owner.
 */
","/**
 * Called by the profile owner of a managed profile to obtain a {@link DevicePolicyManager}
 * whose calls act on the parent profile.
 *
 * <p>The following methods are supported for the parent instance, all other methods will
 * throw a SecurityException when called on the parent instance:
 * <ul>
 * <li>{@link #getPasswordQuality}</li>
 * <li>{@link #setPasswordQuality}</li>
 * <li>{@link #getPasswordMinimumLength}</li>
 * <li>{@link #setPasswordMinimumLength}</li>
 * <li>{@link #getPasswordMinimumUpperCase}</li>
 * <li>{@link #setPasswordMinimumUpperCase}</li>
 * <li>{@link #getPasswordMinimumLowerCase}</li>
 * <li>{@link #setPasswordMinimumLowerCase}</li>
 * <li>{@link #getPasswordMinimumLetters}</li>
 * <li>{@link #setPasswordMinimumLetters}</li>
 * <li>{@link #getPasswordMinimumNumeric}</li>
 * <li>{@link #setPasswordMinimumNumeric}</li>
 * <li>{@link #getPasswordMinimumSymbols}</li>
 * <li>{@link #setPasswordMinimumSymbols}</li>
 * <li>{@link #getPasswordMinimumNonLetter}</li>
 * <li>{@link #setPasswordMinimumNonLetter}</li>
 * <li>{@link #getPasswordHistoryLength}</li>
 * <li>{@link #setPasswordHistoryLength}</li>
 * <li>{@link #getPasswordExpirationTimeout}</li>
 * <li>{@link #setPasswordExpirationTimeout}</li>
 * <li>{@link #getPasswordExpiration}</li>
 * <li>{@link #getPasswordMaximumLength}</li>
 * <li>{@link #isActivePasswordSufficient}</li>
 * <li>{@link #getCurrentFailedPasswordAttempts}</li>
 * <li>{@link #getMaximumFailedPasswordsForWipe}</li>
 * <li>{@link #setMaximumFailedPasswordsForWipe}</li>
 * <li>{@link #getMaximumTimeToLock}</li>
 * <li>{@link #setMaximumTimeToLock}</li>
 * <li>{@link #lockNow}</li>
 * <li>{@link #getKeyguardDisabledFeatures}</li>
 * <li>{@link #setKeyguardDisabledFeatures}</li>
 * <li>{@link #getTrustAgentConfiguration}</li>
 * <li>{@link #setTrustAgentConfiguration}</li>
 * <li>{@link #getRequiredStrongAuthTimeout}</li>
 * <li>{@link #setRequiredStrongAuthTimeout}</li>
 * <li>{@link #getAccountTypesWithManagementDisabled}</li>
 * <li>{@link #setRequiredPasswordComplexity(int)} </li>
 * <li>{@link #getRequiredPasswordComplexity()}</li>
 * </ul>
 * <p>
 * The following methods are supported for the parent instance but can only be called by the
 * profile owner of a managed profile that was created during the device provisioning flow:
 * <ul>
 * <li>{@link #getPasswordComplexity}</li>
 * <li>{@link #setCameraDisabled}</li>
 * <li>{@link #getCameraDisabled}</li>
 * <li>{@link #setAccountManagementDisabled(ComponentName, String, boolean)}</li>
 * <li>{@link #setPermittedInputMethods}</li>
 * <li>{@link #getPermittedInputMethods}</li>
 * </ul>
 *
 * <p>The following methods can be called by the profile owner of a managed profile
 * on an organization-owned device:
 * <ul>
 * <li>{@link #wipeData}</li>
 * </ul>
 *
 * @return a new instance of {@link DevicePolicyManager} that acts on the parent profile.
 * @throws SecurityException if {@code admin} is not a profile owner.
 */
",1,[@NonNull],[@NonNull],0,,,,0,0,0,0,0,"There is no code change between the two versions. Only the comment has changed, with additional methods being included in the list of supported methods for the parent instance and the list of methods that can be called by the profile owner of a managed profile that was created during the device provisioning flow.","There is no Compatibility Issue exist. Only the comment has changed, and the actual implementation of the method remains the same. Therefore, the behavior of the method will not differ between the two versions."
8,"<android.app.backup.BackupAgent.BackupServiceBinder: void doFullBackup(ParcelFileDescriptor,long,int,IBackupManager,int)>",30,31,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(// Ensure that we're running with the app's normal permission level, []), AssignmentExpression(=, [VariableReference(long ident, []), Expression(Binder.clearCallingIdentity(), [])]), Statement(if (DEBUG), []), MethodCall(Log.v(TAG, ""doFullBackup() invoked""), [VariableReference(Log, []), Expression(TAG, []), Expression(""doFullBackup() invoked"", [])]), Statement(// Ensure that any SharedPreferences writes have landed *before*, []), Statement(// we potentially try to back up the underlying files directly., []), Statement(waitForSharedPrefs(), []), Statement(try {, []), Statement(} catch (IOException ex) {, []), MethodCall(Log.d(TAG, ""onFullBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", ex), [VariableReference(Log, []), Expression(TAG, []), Expression(""onFullBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", []), Expression(ex, [])]), Statement(throw new RuntimeException(ex), []), Statement(} catch (RuntimeException ex) {, []), MethodCall(Log.d(TAG, ""onFullBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", ex), [VariableReference(Log, []), Expression(TAG, []), Expression(""onFullBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", []), Expression(ex, [])]), Statement(throw ex, []), Statement(} finally {, []), Statement(waitForSharedPrefs(), []), Statement(// forthcoming from this agent., []), Statement(try {, []), AssignmentExpression(=, [VariableReference(FileOutputStream out, []), Expression(new FileOutputStream(data.getFileDescriptor()), [])]), AssignmentExpression(=, [VariableReference(byte[] buf, []), Expression(new byte[4], [])]), MethodCall(out.write(buf), [VariableReference(out, []), Expression(buf, [])]), Statement(} catch (IOException e) {, []), MethodCall(Log.e(TAG, ""Unable to finalize backup stream!""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Unable to finalize backup stream!"", [])]), Statement(}, []), MethodCall(Binder.restoreCallingIdentity(ident), [VariableReference(Binder, []), Expression(ident, [])]), Statement(try {, []), MethodCall(callbackBinder.opCompleteForUser(getBackupUserId(), token, 0), [VariableReference(callbackBinder, []), Expression(getBackupUserId(), []), Expression(token, []), Expression(0, [])]), Statement(} catch (RemoteException e) {, []), Statement(// we'll time out anyway, so we're safe, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (Binder.getCallingPid() !, []), Expression(Process.myPid()) {, [])]), MethodCall(IoUtils.closeQuietly(data), [VariableReference(IoUtils, []), Expression(data, [])]), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(// Ensure that we're running with the app's normal permission level, [])  AssignmentExpression(=, [VariableReference(long ident, []), Expression(Binder.clearCallingIdentity(), [])])    VariableReference(long ident, [])    Expression(Binder.clearCallingIdentity(), [])  Statement(if (DEBUG), [])  MethodCall(Log.v(TAG, ""doFullBackup() invoked""), [VariableReference(Log, []), Expression(TAG, []), Expression(""doFullBackup() invoked"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""doFullBackup() invoked"", [])  Statement(// Ensure that any SharedPreferences writes have landed *before*, [])  Statement(// we potentially try to back up the underlying files directly., [])  Statement(waitForSharedPrefs(), [])  Statement(try {, [])  Statement(} catch (IOException ex) {, [])  MethodCall(Log.d(TAG, ""onFullBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", ex), [VariableReference(Log, []), Expression(TAG, []), Expression(""onFullBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", []), Expression(ex, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""onFullBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", [])    Expression(ex, [])  Statement(throw new RuntimeException(ex), [])  Statement(} catch (RuntimeException ex) {, [])  MethodCall(Log.d(TAG, ""onFullBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", ex), [VariableReference(Log, []), Expression(TAG, []), Expression(""onFullBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", []), Expression(ex, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""onFullBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", [])    Expression(ex, [])  Statement(throw ex, [])  Statement(} finally {, [])  Statement(waitForSharedPrefs(), [])  Statement(// forthcoming from this agent., [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(FileOutputStream out, []), Expression(new FileOutputStream(data.getFileDescriptor()), [])])    VariableReference(FileOutputStream out, [])    Expression(new FileOutputStream(data.getFileDescriptor()), [])  AssignmentExpression(=, [VariableReference(byte[] buf, []), Expression(new byte[4], [])])    VariableReference(byte[] buf, [])    Expression(new byte[4], [])  MethodCall(out.write(buf), [VariableReference(out, []), Expression(buf, [])])    VariableReference(out, [])    Expression(buf, [])  Statement(} catch (IOException e) {, [])  MethodCall(Log.e(TAG, ""Unable to finalize backup stream!""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Unable to finalize backup stream!"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Unable to finalize backup stream!"", [])  Statement(}, [])  MethodCall(Binder.restoreCallingIdentity(ident), [VariableReference(Binder, []), Expression(ident, [])])    VariableReference(Binder, [])    Expression(ident, [])  Statement(try {, [])  MethodCall(callbackBinder.opCompleteForUser(getBackupUserId(), token, 0), [VariableReference(callbackBinder, []), Expression(getBackupUserId(), []), Expression(token, []), Expression(0, [])])    VariableReference(callbackBinder, [])    Expression(getBackupUserId(), [])    Expression(token, [])    Expression(0, [])  Statement(} catch (RemoteException e) {, [])  Statement(// we'll time out anyway, so we're safe, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (Binder.getCallingPid() !, []), Expression(Process.myPid()) {, [])])    VariableReference(if (Binder.getCallingPid() !, [])    Expression(Process.myPid()) {, [])  MethodCall(IoUtils.closeQuietly(data), [VariableReference(IoUtils, []), Expression(data, [])])    VariableReference(IoUtils, [])    Expression(data, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (DEBUG), []), MethodCall(Log.v(TAG, ""doFullBackup() invoked""), [VariableReference(Log, []), Expression(TAG, []), Expression(""doFullBackup() invoked"", [])]), Statement(// Ensure that any SharedPreferences writes have landed *before*, []), Statement(// we potentially try to back up the underlying files directly., []), Statement(waitForSharedPrefs(), []), Statement(// Ensure that we're running with the app's normal permission level, []), AssignmentExpression(=, [VariableReference(final long ident, []), Expression(Binder.clearCallingIdentity(), [])]), Statement(try {, []), Statement(} catch (IOException ex) {, []), MethodCall(Log.d(TAG, ""onFullBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", ex), [VariableReference(Log, []), Expression(TAG, []), Expression(""onFullBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", []), Expression(ex, [])]), Statement(throw new RuntimeException(ex), []), Statement(} catch (RuntimeException ex) {, []), MethodCall(Log.d(TAG, ""onFullBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", ex), [VariableReference(Log, []), Expression(TAG, []), Expression(""onFullBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", []), Expression(ex, [])]), Statement(throw ex, []), Statement(} finally {, []), Statement(waitForSharedPrefs(), []), Statement(// forthcoming from this agent., []), Statement(try {, []), AssignmentExpression(=, [VariableReference(FileOutputStream out, []), Expression(new FileOutputStream(data.getFileDescriptor()), [])]), AssignmentExpression(=, [VariableReference(byte[] buf, []), Expression(new byte[4], [])]), MethodCall(out.write(buf), [VariableReference(out, []), Expression(buf, [])]), Statement(} catch (IOException e) {, []), MethodCall(Log.e(TAG, ""Unable to finalize backup stream!""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Unable to finalize backup stream!"", [])]), Statement(}, []), MethodCall(Binder.restoreCallingIdentity(ident), [VariableReference(Binder, []), Expression(ident, [])]), Statement(try {, []), MethodCall(callbackBinder.opCompleteForUser(getBackupUserId(), token, 0), [VariableReference(callbackBinder, []), Expression(getBackupUserId(), []), Expression(token, []), Expression(0, [])]), Statement(} catch (RemoteException e) {, []), Statement(// we'll time out anyway, so we're safe, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (Binder.getCallingPid() !, []), Expression(Process.myPid()) {, [])]), MethodCall(IoUtils.closeQuietly(data), [VariableReference(IoUtils, []), Expression(data, [])]), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(if (DEBUG), [])  MethodCall(Log.v(TAG, ""doFullBackup() invoked""), [VariableReference(Log, []), Expression(TAG, []), Expression(""doFullBackup() invoked"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""doFullBackup() invoked"", [])  Statement(// Ensure that any SharedPreferences writes have landed *before*, [])  Statement(// we potentially try to back up the underlying files directly., [])  Statement(waitForSharedPrefs(), [])  Statement(// Ensure that we're running with the app's normal permission level, [])  AssignmentExpression(=, [VariableReference(final long ident, []), Expression(Binder.clearCallingIdentity(), [])])    VariableReference(final long ident, [])    Expression(Binder.clearCallingIdentity(), [])  Statement(try {, [])  Statement(} catch (IOException ex) {, [])  MethodCall(Log.d(TAG, ""onFullBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", ex), [VariableReference(Log, []), Expression(TAG, []), Expression(""onFullBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", []), Expression(ex, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""onFullBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", [])    Expression(ex, [])  Statement(throw new RuntimeException(ex), [])  Statement(} catch (RuntimeException ex) {, [])  MethodCall(Log.d(TAG, ""onFullBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", ex), [VariableReference(Log, []), Expression(TAG, []), Expression(""onFullBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", []), Expression(ex, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""onFullBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", [])    Expression(ex, [])  Statement(throw ex, [])  Statement(} finally {, [])  Statement(waitForSharedPrefs(), [])  Statement(// forthcoming from this agent., [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(FileOutputStream out, []), Expression(new FileOutputStream(data.getFileDescriptor()), [])])    VariableReference(FileOutputStream out, [])    Expression(new FileOutputStream(data.getFileDescriptor()), [])  AssignmentExpression(=, [VariableReference(byte[] buf, []), Expression(new byte[4], [])])    VariableReference(byte[] buf, [])    Expression(new byte[4], [])  MethodCall(out.write(buf), [VariableReference(out, []), Expression(buf, [])])    VariableReference(out, [])    Expression(buf, [])  Statement(} catch (IOException e) {, [])  MethodCall(Log.e(TAG, ""Unable to finalize backup stream!""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Unable to finalize backup stream!"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Unable to finalize backup stream!"", [])  Statement(}, [])  MethodCall(Binder.restoreCallingIdentity(ident), [VariableReference(Binder, []), Expression(ident, [])])    VariableReference(Binder, [])    Expression(ident, [])  Statement(try {, [])  MethodCall(callbackBinder.opCompleteForUser(getBackupUserId(), token, 0), [VariableReference(callbackBinder, []), Expression(getBackupUserId(), []), Expression(token, []), Expression(0, [])])    VariableReference(callbackBinder, [])    Expression(getBackupUserId(), [])    Expression(token, [])    Expression(0, [])  Statement(} catch (RemoteException e) {, [])  Statement(// we'll time out anyway, so we're safe, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (Binder.getCallingPid() !, []), Expression(Process.myPid()) {, [])])    VariableReference(if (Binder.getCallingPid() !, [])    Expression(Process.myPid()) {, [])  MethodCall(IoUtils.closeQuietly(data), [VariableReference(IoUtils, []), Expression(data, [])])    VariableReference(IoUtils, [])    Expression(data, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,,1,"3,4",0,0,0,There is no difference between the given Early\_Version and Late\_Version AST nodes for the doFullBackup method of BackupAgent.BackupServiceBinder class.,There is no Compatibility Issue for the given doFullBackup method of BackupAgent.BackupServiceBinder class as there is no difference between the given Early\_Version and Late\_Version AST nodes.
9,"<android.text.method.NumberKeyListener: boolean addAmPmChars(Collection<Character>,Locale)>",30,31,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (locale, []), Expression(, [])]), Statement(return false, []), Statement(}, []), AssignmentExpression(=, [VariableReference(final String[] amPm, []), Expression(LocaleData.get(locale).amPm, [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < amPm.length, []), Statement(i++) {, []), AssignmentExpression(=, [VariableReference(for (int j, []), Expression(0, [])]), MethodCall(j < amPm[i].length(), [VariableReference(j < amPm[i], []), Expression(, [])]), Statement(j++) {, []), AssignmentExpression(=, [VariableReference(final char ch, []), Expression(amPm[i].charAt(j), [])]), MethodCall(if (Character.isBmpCodePoint(ch)), [VariableReference(if (Character, []), Expression(ch), [])]), MethodCall(collection.add(Character.valueOf(ch)), [VariableReference(collection, []), Expression(Character.valueOf(ch), [])]), Statement(} else {, []), Statement(// We don't support non-BMP characters., []), Statement(return false, []), Statement(}, []), Statement(}, []), Statement(}, []), Statement(return true, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (locale, []), Expression(, [])])    VariableReference(if (locale, [])    Expression(, [])  Statement(return false, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(final String[] amPm, []), Expression(LocaleData.get(locale).amPm, [])])    VariableReference(final String[] amPm, [])    Expression(LocaleData.get(locale).amPm, [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < amPm.length, [])  Statement(i++) {, [])  AssignmentExpression(=, [VariableReference(for (int j, []), Expression(0, [])])    VariableReference(for (int j, [])    Expression(0, [])  MethodCall(j < amPm[i].length(), [VariableReference(j < amPm[i], []), Expression(, [])])    VariableReference(j < amPm[i], [])    Expression(, [])  Statement(j++) {, [])  AssignmentExpression(=, [VariableReference(final char ch, []), Expression(amPm[i].charAt(j), [])])    VariableReference(final char ch, [])    Expression(amPm[i].charAt(j), [])  MethodCall(if (Character.isBmpCodePoint(ch)), [VariableReference(if (Character, []), Expression(ch), [])])    VariableReference(if (Character, [])    Expression(ch), [])  MethodCall(collection.add(Character.valueOf(ch)), [VariableReference(collection, []), Expression(Character.valueOf(ch), [])])    VariableReference(collection, [])    Expression(Character.valueOf(ch), [])  Statement(} else {, [])  Statement(// We don't support non-BMP characters., [])  Statement(return false, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(return true, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (locale, []), Expression(, [])]), Statement(return false, []), Statement(}, []), AssignmentExpression(=, [VariableReference(final String[] amPm, []), Expression(DateFormat.getIcuDateFormatSymbols(locale).getAmPmStrings(), [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < amPm.length, []), Statement(i++) {, []), AssignmentExpression(=, [VariableReference(for (int j, []), Expression(0, [])]), MethodCall(j < amPm[i].length(), [VariableReference(j < amPm[i], []), Expression(, [])]), Statement(j++) {, []), AssignmentExpression(=, [VariableReference(final char ch, []), Expression(amPm[i].charAt(j), [])]), MethodCall(if (Character.isBmpCodePoint(ch)), [VariableReference(if (Character, []), Expression(ch), [])]), MethodCall(collection.add(Character.valueOf(ch)), [VariableReference(collection, []), Expression(Character.valueOf(ch), [])]), Statement(} else {, []), Statement(// We don't support non-BMP characters., []), Statement(return false, []), Statement(}, []), Statement(}, []), Statement(}, []), Statement(return true, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (locale, []), Expression(, [])])    VariableReference(if (locale, [])    Expression(, [])  Statement(return false, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(final String[] amPm, []), Expression(DateFormat.getIcuDateFormatSymbols(locale).getAmPmStrings(), [])])    VariableReference(final String[] amPm, [])    Expression(DateFormat.getIcuDateFormatSymbols(locale).getAmPmStrings(), [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < amPm.length, [])  Statement(i++) {, [])  AssignmentExpression(=, [VariableReference(for (int j, []), Expression(0, [])])    VariableReference(for (int j, [])    Expression(0, [])  MethodCall(j < amPm[i].length(), [VariableReference(j < amPm[i], []), Expression(, [])])    VariableReference(j < amPm[i], [])    Expression(, [])  Statement(j++) {, [])  AssignmentExpression(=, [VariableReference(final char ch, []), Expression(amPm[i].charAt(j), [])])    VariableReference(final char ch, [])    Expression(amPm[i].charAt(j), [])  MethodCall(if (Character.isBmpCodePoint(ch)), [VariableReference(if (Character, []), Expression(ch), [])])    VariableReference(if (Character, [])    Expression(ch), [])  MethodCall(collection.add(Character.valueOf(ch)), [VariableReference(collection, []), Expression(Character.valueOf(ch), [])])    VariableReference(collection, [])    Expression(Character.valueOf(ch), [])  Statement(} else {, [])  Statement(// We don't support non-BMP characters., [])  Statement(return false, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(return true, [])  Statement(}, [])",1,"/* package */
","/* package */
",0,,,0,,,,2,"4,5",0,5,1,"In the early implementation, the `final String[] amPm` variable is assigned the value of `LocaleData.get(locale).amPm`. However, in the late implementation, `amPm` is assigned the value of `DateFormat.getIcuDateFormatSymbols(locale).getAmPmStrings()`. This change in the assignment represents a dependent API change, as the source of the `amPm` data has been altered.","The Compatibility Issue arises due to the potential for different return values. The change in the data source for `amPm` could lead to variations in the characters added to the `collection` object. Consequently, this may result in the method returning `true` in the early version and `false` in the late version, or vice versa, depending on the input `locale` and `collection` parameters."
10,<android.app.UiAutomation: void clearWindowAnimationFrameStats()>,30,31,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(synchronized (mLock) {, []), Statement(throwIfNotConnectedLocked(), []), Statement(}, []), Statement(try {, []), Statement(if (DEBUG) {, []), MethodCall(Log.i(LOG_TAG, ""Clearing window animation frame stats""), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""Clearing window animation frame stats"", [])]), Statement(}, []), Statement(// Calling out without a lock held., []), MethodCall(mUiAutomationConnection.clearWindowAnimationFrameStats(), [VariableReference(mUiAutomationConnection, []), Expression(, [])]), Statement(} catch (RemoteException re) {, []), MethodCall(Log.e(LOG_TAG, ""Error clearing window animation frame stats!"", re), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""Error clearing window animation frame stats!"", []), Expression(re, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(synchronized (mLock) {, [])  Statement(throwIfNotConnectedLocked(), [])  Statement(}, [])  Statement(try {, [])  Statement(if (DEBUG) {, [])  MethodCall(Log.i(LOG_TAG, ""Clearing window animation frame stats""), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""Clearing window animation frame stats"", [])])    VariableReference(Log, [])    Expression(LOG_TAG, [])    Expression(""Clearing window animation frame stats"", [])  Statement(}, [])  Statement(// Calling out without a lock held., [])  MethodCall(mUiAutomationConnection.clearWindowAnimationFrameStats(), [VariableReference(mUiAutomationConnection, []), Expression(, [])])    VariableReference(mUiAutomationConnection, [])    Expression(, [])  Statement(} catch (RemoteException re) {, [])  MethodCall(Log.e(LOG_TAG, ""Error clearing window animation frame stats!"", re), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""Error clearing window animation frame stats!"", []), Expression(re, [])])    VariableReference(Log, [])    Expression(LOG_TAG, [])    Expression(""Error clearing window animation frame stats!"", [])    Expression(re, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), Statement(if (DEBUG) {, []), MethodCall(Log.i(LOG_TAG, ""Clearing window animation frame stats""), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""Clearing window animation frame stats"", [])]), Statement(}, []), Statement(// Calling out without a lock held., []), MethodCall(mUiAutomationConnection.clearWindowAnimationFrameStats(), [VariableReference(mUiAutomationConnection, []), Expression(, [])]), Statement(} catch (RemoteException re) {, []), MethodCall(Log.e(LOG_TAG, ""Error clearing window animation frame stats!"", re), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""Error clearing window animation frame stats!"", []), Expression(re, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  Statement(if (DEBUG) {, [])  MethodCall(Log.i(LOG_TAG, ""Clearing window animation frame stats""), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""Clearing window animation frame stats"", [])])    VariableReference(Log, [])    Expression(LOG_TAG, [])    Expression(""Clearing window animation frame stats"", [])  Statement(}, [])  Statement(// Calling out without a lock held., [])  MethodCall(mUiAutomationConnection.clearWindowAnimationFrameStats(), [VariableReference(mUiAutomationConnection, []), Expression(, [])])    VariableReference(mUiAutomationConnection, [])    Expression(, [])  Statement(} catch (RemoteException re) {, [])  MethodCall(Log.e(LOG_TAG, ""Error clearing window animation frame stats!"", re), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""Error clearing window animation frame stats!"", []), Expression(re, [])])    VariableReference(Log, [])    Expression(LOG_TAG, [])    Expression(""Error clearing window animation frame stats!"", [])    Expression(re, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Clears the window animation rendering statistics. These statistics contain
 * information about the most recently rendered window animation frames, i.e.
 * for window transition animations.
 *
 * @see android.view.WindowAnimationFrameStats
 * @see #getWindowAnimationFrameStats()
 * @see android.R.styleable#WindowAnimation
 */
","/**
 * Clears the window animation rendering statistics. These statistics contain
 * information about the most recently rendered window animation frames, i.e.
 * for window transition animations.
 *
 * @see android.view.WindowAnimationFrameStats
 * @see #getWindowAnimationFrameStats()
 * @see android.R.styleable#WindowAnimation
 */
",0,,,0,,,,"1,2",4,2,4,0,"The code change between the two versions of the API is that two statements, `Statement(synchronized (mLock) {, [])` and `Statement(throwIfNotConnectedLocked(), [])`, have been removed from the early version. This change can be classified as ""Other statement changed"" as per the given instructions.","The Compatibility Issue (CI) arises when the code change between two continuous versions of the same API could lead to different behaviours. In this case, the removal of the two statements `synchronized (mLock)` and `throwIfNotConnectedLocked()` does not seem to affect the overall behaviour of the API. The `synchronized` block was used to ensure that the method was executed atomically, but its removal does not necessarily mean that the method will behave differently. Similarly, the `throwIfNotConnectedLocked()` method was used to check if the UI automation connection was active, but its removal does not affect the functionality of the `clearWindowAnimationFrameStats()` method. Therefore, it can be concluded that no Compatibility Issue exists for the API."
11,"<android.view.ViewGroup: boolean requestFocus(int,Rect)>",30,31,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(if (DBG) {, []), AssignmentExpression(=, [VariableReference(System.out.println(this + "" ViewGroup.requestFocus direction, []), Expression("" + direction), [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(int descendantFocusability, []), Expression(getDescendantFocusability(), [])]), Statement(boolean result, []), Statement(switch(descendantFocusability) {, []), Statement(case FOCUS_BLOCK_DESCENDANTS:, []), AssignmentExpression(=, [VariableReference(result, []), Expression(super.requestFocus(direction, previouslyFocusedRect), [])]), Statement(break, []), Statement(case FOCUS_BEFORE_DESCENDANTS:, []), Statement({, []), AssignmentExpression(=, [VariableReference(final boolean took, []), Expression(super.requestFocus(direction, previouslyFocusedRect), [])]), AssignmentExpression(=, [VariableReference(result, []), Expression(took ? took : onRequestFocusInDescendants(direction, previouslyFocusedRect), [])]), Statement(break, []), Statement(}, []), Statement(case FOCUS_AFTER_DESCENDANTS:, []), Statement({, []), AssignmentExpression(=, [VariableReference(final boolean took, []), Expression(onRequestFocusInDescendants(direction, previouslyFocusedRect), [])]), AssignmentExpression(=, [VariableReference(result, []), Expression(took ? took : super.requestFocus(direction, previouslyFocusedRect), [])]), Statement(break, []), Statement(}, []), Statement(default:, []), Statement(throw new IllegalStateException(""descendant focusability must be one of FOCUS_BEFORE_DESCENDANTS,"" + "" FOCUS_AFTER_DESCENDANTS, FOCUS_BLOCK_DESCENDANTS but is "" + descendantFocusability), []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (result && !isLayoutValid() && ((mPrivateFlags & PFLAG_WANTS_FOCUS), []), Expression(, [])]), AssignmentExpression(=, [VariableReference(mPrivateFlags |, []), Expression(PFLAG_WANTS_FOCUS, [])]), Statement(}, []), Statement(return result, []), Statement(}, [])])  Statement({, [])  Statement(if (DBG) {, [])  AssignmentExpression(=, [VariableReference(System.out.println(this + "" ViewGroup.requestFocus direction, []), Expression("" + direction), [])])    VariableReference(System.out.println(this + "" ViewGroup.requestFocus direction, [])    Expression("" + direction), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(int descendantFocusability, []), Expression(getDescendantFocusability(), [])])    VariableReference(int descendantFocusability, [])    Expression(getDescendantFocusability(), [])  Statement(boolean result, [])  Statement(switch(descendantFocusability) {, [])  Statement(case FOCUS_BLOCK_DESCENDANTS:, [])  AssignmentExpression(=, [VariableReference(result, []), Expression(super.requestFocus(direction, previouslyFocusedRect), [])])    VariableReference(result, [])    Expression(super.requestFocus(direction, previouslyFocusedRect), [])  Statement(break, [])  Statement(case FOCUS_BEFORE_DESCENDANTS:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(final boolean took, []), Expression(super.requestFocus(direction, previouslyFocusedRect), [])])    VariableReference(final boolean took, [])    Expression(super.requestFocus(direction, previouslyFocusedRect), [])  AssignmentExpression(=, [VariableReference(result, []), Expression(took ? took : onRequestFocusInDescendants(direction, previouslyFocusedRect), [])])    VariableReference(result, [])    Expression(took ? took : onRequestFocusInDescendants(direction, previouslyFocusedRect), [])  Statement(break, [])  Statement(}, [])  Statement(case FOCUS_AFTER_DESCENDANTS:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(final boolean took, []), Expression(onRequestFocusInDescendants(direction, previouslyFocusedRect), [])])    VariableReference(final boolean took, [])    Expression(onRequestFocusInDescendants(direction, previouslyFocusedRect), [])  AssignmentExpression(=, [VariableReference(result, []), Expression(took ? took : super.requestFocus(direction, previouslyFocusedRect), [])])    VariableReference(result, [])    Expression(took ? took : super.requestFocus(direction, previouslyFocusedRect), [])  Statement(break, [])  Statement(}, [])  Statement(default:, [])  Statement(throw new IllegalStateException(""descendant focusability must be one of FOCUS_BEFORE_DESCENDANTS,"" + "" FOCUS_AFTER_DESCENDANTS, FOCUS_BLOCK_DESCENDANTS but is "" + descendantFocusability), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (result && !isLayoutValid() && ((mPrivateFlags & PFLAG_WANTS_FOCUS), []), Expression(, [])])    VariableReference(if (result && !isLayoutValid() && ((mPrivateFlags & PFLAG_WANTS_FOCUS), [])    Expression(, [])  AssignmentExpression(=, [VariableReference(mPrivateFlags |, []), Expression(PFLAG_WANTS_FOCUS, [])])    VariableReference(mPrivateFlags |, [])    Expression(PFLAG_WANTS_FOCUS, [])  Statement(}, [])  Statement(return result, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (DBG) {, []), AssignmentExpression(=, [VariableReference(System.out.println(this + "" ViewGroup.requestFocus direction, []), Expression("" + direction), [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(int descendantFocusability, []), Expression(getDescendantFocusability(), [])]), Statement(boolean result, []), Statement(switch(descendantFocusability) {, []), Statement(case FOCUS_BLOCK_DESCENDANTS:, []), AssignmentExpression(=, [VariableReference(result, []), Expression(super.requestFocus(direction, previouslyFocusedRect), [])]), Statement(break, []), Statement(case FOCUS_BEFORE_DESCENDANTS:, []), Statement({, []), AssignmentExpression(=, [VariableReference(final boolean took, []), Expression(super.requestFocus(direction, previouslyFocusedRect), [])]), AssignmentExpression(=, [VariableReference(result, []), Expression(took ? took : onRequestFocusInDescendants(direction, previouslyFocusedRect), [])]), Statement(break, []), Statement(}, []), Statement(case FOCUS_AFTER_DESCENDANTS:, []), Statement({, []), AssignmentExpression(=, [VariableReference(final boolean took, []), Expression(onRequestFocusInDescendants(direction, previouslyFocusedRect), [])]), AssignmentExpression(=, [VariableReference(result, []), Expression(took ? took : super.requestFocus(direction, previouslyFocusedRect), [])]), Statement(break, []), Statement(}, []), Statement(default:, []), Statement(throw new IllegalStateException(""descendant focusability must be "" + ""one of FOCUS_BEFORE_DESCENDANTS, FOCUS_AFTER_DESCENDANTS, FOCUS_BLOCK_DESCENDANTS "" + ""but is "" + descendantFocusability), []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (result && !isLayoutValid() && ((mPrivateFlags & PFLAG_WANTS_FOCUS), []), Expression(, [])]), AssignmentExpression(=, [VariableReference(mPrivateFlags |, []), Expression(PFLAG_WANTS_FOCUS, [])]), Statement(}, []), Statement(return result, []), Statement(}, [])])  Statement({, [])  Statement(if (DBG) {, [])  AssignmentExpression(=, [VariableReference(System.out.println(this + "" ViewGroup.requestFocus direction, []), Expression("" + direction), [])])    VariableReference(System.out.println(this + "" ViewGroup.requestFocus direction, [])    Expression("" + direction), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(int descendantFocusability, []), Expression(getDescendantFocusability(), [])])    VariableReference(int descendantFocusability, [])    Expression(getDescendantFocusability(), [])  Statement(boolean result, [])  Statement(switch(descendantFocusability) {, [])  Statement(case FOCUS_BLOCK_DESCENDANTS:, [])  AssignmentExpression(=, [VariableReference(result, []), Expression(super.requestFocus(direction, previouslyFocusedRect), [])])    VariableReference(result, [])    Expression(super.requestFocus(direction, previouslyFocusedRect), [])  Statement(break, [])  Statement(case FOCUS_BEFORE_DESCENDANTS:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(final boolean took, []), Expression(super.requestFocus(direction, previouslyFocusedRect), [])])    VariableReference(final boolean took, [])    Expression(super.requestFocus(direction, previouslyFocusedRect), [])  AssignmentExpression(=, [VariableReference(result, []), Expression(took ? took : onRequestFocusInDescendants(direction, previouslyFocusedRect), [])])    VariableReference(result, [])    Expression(took ? took : onRequestFocusInDescendants(direction, previouslyFocusedRect), [])  Statement(break, [])  Statement(}, [])  Statement(case FOCUS_AFTER_DESCENDANTS:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(final boolean took, []), Expression(onRequestFocusInDescendants(direction, previouslyFocusedRect), [])])    VariableReference(final boolean took, [])    Expression(onRequestFocusInDescendants(direction, previouslyFocusedRect), [])  AssignmentExpression(=, [VariableReference(result, []), Expression(took ? took : super.requestFocus(direction, previouslyFocusedRect), [])])    VariableReference(result, [])    Expression(took ? took : super.requestFocus(direction, previouslyFocusedRect), [])  Statement(break, [])  Statement(}, [])  Statement(default:, [])  Statement(throw new IllegalStateException(""descendant focusability must be "" + ""one of FOCUS_BEFORE_DESCENDANTS, FOCUS_AFTER_DESCENDANTS, FOCUS_BLOCK_DESCENDANTS "" + ""but is "" + descendantFocusability), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (result && !isLayoutValid() && ((mPrivateFlags & PFLAG_WANTS_FOCUS), []), Expression(, [])])    VariableReference(if (result && !isLayoutValid() && ((mPrivateFlags & PFLAG_WANTS_FOCUS), [])    Expression(, [])  AssignmentExpression(=, [VariableReference(mPrivateFlags |, []), Expression(PFLAG_WANTS_FOCUS, [])])    VariableReference(mPrivateFlags |, [])    Expression(PFLAG_WANTS_FOCUS, [])  Statement(}, [])  Statement(return result, [])  Statement(}, [])",1,"/**
 * {@inheritDoc}
 *
 * Looks for a view to give focus to respecting the setting specified by
 * {@link #getDescendantFocusability()}.
 *
 * Uses {@link #onRequestFocusInDescendants(int, android.graphics.Rect)} to
 * find focus within the children of this group when appropriate.
 *
 * @see #FOCUS_BEFORE_DESCENDANTS
 * @see #FOCUS_AFTER_DESCENDANTS
 * @see #FOCUS_BLOCK_DESCENDANTS
 * @see #onRequestFocusInDescendants(int, android.graphics.Rect)
 */
","/**
 * {@inheritDoc}
 *
 * Looks for a view to give focus to respecting the setting specified by
 * {@link #getDescendantFocusability()}.
 *
 * Uses {@link #onRequestFocusInDescendants(int, android.graphics.Rect)} to
 * find focus within the children of this group when appropriate.
 *
 * @see #FOCUS_BEFORE_DESCENDANTS
 * @see #FOCUS_AFTER_DESCENDANTS
 * @see #FOCUS_BLOCK_DESCENDANTS
 * @see #onRequestFocusInDescendants(int, android.graphics.Rect)
 */
",0,[@Override],[@Override],0,,,,1,2,2,3,1,The change between the two versions is that the error message in the "throw new IllegalStateException" statement has been modified.,The modification of the error message in the "throw new IllegalStateException" statement will not cause compatibility issues since it only affects the error message that is displayed when the illegal state exception is thrown. The behavior of the API remains the same.
12,<android.os.Parcel: void setDataSize(int)>,30,31,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(updateNativeSize(nativeSetDataSize(mNativePtr, size)), []), Statement(}, [])])  Statement({, [])  Statement(updateNativeSize(nativeSetDataSize(mNativePtr, size)), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(nativeSetDataSize(mNativePtr, size), []), Statement(}, [])])  Statement({, [])  Statement(nativeSetDataSize(mNativePtr, size), [])  Statement(}, [])",1,"/**
 * Change the amount of data in the parcel.  Can be either smaller or
 * larger than the current size.  If larger than the current capacity,
 * more memory will be allocated.
 *
 * @param size The new number of bytes in the Parcel.
 */
","/**
 * Change the amount of data in the parcel.  Can be either smaller or
 * larger than the current size.  If larger than the current capacity,
 * more memory will be allocated.
 *
 * @param size The new number of bytes in the Parcel.
 */
",0,,,0,,,,2,5,0,4,1,"The implementation of the method ""setDataSize"" has changed from the early version to the late version. In the early version, the method body contains three statements: an empty block statement, a statement that calls the method ""updateNativeSize"" with the result of the method ""nativeSetDataSize"", and another empty block statement. In the late version, the method body only contains two statements: an empty block statement and a statement that calls the method ""nativeSetDataSize"". The statement that calls ""updateNativeSize"" has been removed.","The removal of the statement that calls ""updateNativeSize"" in the late version of the method ""setDataSize"" can potentially lead to a compatibility issue of type 1, where the method may return a different value or type. The ""updateNativeSize"" method is responsible for updating the size of the native memory buffer used by the Parcel object. If this method is not called, the native memory buffer may not be correctly updated, which can cause unexpected behavior when the Parcel is used in inter-process communication. For example, the receiving process may not be able to correctly read the data from the Parcel, or may crash due to a memory access violation."
13,"<android.view.inputmethod.InlineSuggestionsRequest: void writeToParcel(Parcel,int)>",30,31,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(// You can override field parcelling by defining methods like:, []), AssignmentExpression(=, [VariableReference(byte flg, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(if (mHostInputToken !, []), Expression(null), [])]), AssignmentExpression(=, [VariableReference(flg |, []), Expression(0x20, [])]), MethodCall(dest.writeByte(flg), [VariableReference(dest, []), Expression(flg, [])]), MethodCall(dest.writeInt(mMaxSuggestionCount), [VariableReference(dest, []), Expression(mMaxSuggestionCount, [])]), MethodCall(dest.writeParcelableList(mInlinePresentationSpecs, flags), [VariableReference(dest, []), Expression(mInlinePresentationSpecs, []), Expression(flags, [])]), MethodCall(dest.writeString(mHostPackageName), [VariableReference(dest, []), Expression(mHostPackageName, [])]), MethodCall(dest.writeTypedObject(mSupportedLocales, flags), [VariableReference(dest, []), Expression(mSupportedLocales, []), Expression(flags, [])]), MethodCall(dest.writeBundle(mExtras), [VariableReference(dest, []), Expression(mExtras, [])]), Statement(parcelHostInputToken(dest, flags), []), MethodCall(dest.writeInt(mHostDisplayId), [VariableReference(dest, []), Expression(mHostDisplayId, [])]), Statement(}, [])])  Statement({, [])  Statement(// You can override field parcelling by defining methods like:, [])  AssignmentExpression(=, [VariableReference(byte flg, []), Expression(0, [])])    VariableReference(byte flg, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(if (mHostInputToken !, []), Expression(null), [])])    VariableReference(if (mHostInputToken !, [])    Expression(null), [])  AssignmentExpression(=, [VariableReference(flg |, []), Expression(0x20, [])])    VariableReference(flg |, [])    Expression(0x20, [])  MethodCall(dest.writeByte(flg), [VariableReference(dest, []), Expression(flg, [])])    VariableReference(dest, [])    Expression(flg, [])  MethodCall(dest.writeInt(mMaxSuggestionCount), [VariableReference(dest, []), Expression(mMaxSuggestionCount, [])])    VariableReference(dest, [])    Expression(mMaxSuggestionCount, [])  MethodCall(dest.writeParcelableList(mInlinePresentationSpecs, flags), [VariableReference(dest, []), Expression(mInlinePresentationSpecs, []), Expression(flags, [])])    VariableReference(dest, [])    Expression(mInlinePresentationSpecs, [])    Expression(flags, [])  MethodCall(dest.writeString(mHostPackageName), [VariableReference(dest, []), Expression(mHostPackageName, [])])    VariableReference(dest, [])    Expression(mHostPackageName, [])  MethodCall(dest.writeTypedObject(mSupportedLocales, flags), [VariableReference(dest, []), Expression(mSupportedLocales, []), Expression(flags, [])])    VariableReference(dest, [])    Expression(mSupportedLocales, [])    Expression(flags, [])  MethodCall(dest.writeBundle(mExtras), [VariableReference(dest, []), Expression(mExtras, [])])    VariableReference(dest, [])    Expression(mExtras, [])  Statement(parcelHostInputToken(dest, flags), [])  MethodCall(dest.writeInt(mHostDisplayId), [VariableReference(dest, []), Expression(mHostDisplayId, [])])    VariableReference(dest, [])    Expression(mHostDisplayId, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(// You can override field parcelling by defining methods like:, []), AssignmentExpression(=, [VariableReference(int flg, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(if (mHostInputToken !, []), Expression(null), [])]), AssignmentExpression(=, [VariableReference(flg |, []), Expression(0x20, [])]), AssignmentExpression(=, [VariableReference(if (mInlineTooltipPresentationSpec !, []), Expression(null), [])]), AssignmentExpression(=, [VariableReference(flg |, []), Expression(0x80, [])]), MethodCall(dest.writeInt(flg), [VariableReference(dest, []), Expression(flg, [])]), MethodCall(dest.writeInt(mMaxSuggestionCount), [VariableReference(dest, []), Expression(mMaxSuggestionCount, [])]), MethodCall(dest.writeParcelableList(mInlinePresentationSpecs, flags), [VariableReference(dest, []), Expression(mInlinePresentationSpecs, []), Expression(flags, [])]), MethodCall(dest.writeString(mHostPackageName), [VariableReference(dest, []), Expression(mHostPackageName, [])]), MethodCall(dest.writeTypedObject(mSupportedLocales, flags), [VariableReference(dest, []), Expression(mSupportedLocales, []), Expression(flags, [])]), MethodCall(dest.writeBundle(mExtras), [VariableReference(dest, []), Expression(mExtras, [])]), Statement(parcelHostInputToken(dest, flags), []), MethodCall(dest.writeInt(mHostDisplayId), [VariableReference(dest, []), Expression(mHostDisplayId, [])]), AssignmentExpression(=, [VariableReference(if (mInlineTooltipPresentationSpec !, []), Expression(null), [])]), MethodCall(dest.writeTypedObject(mInlineTooltipPresentationSpec, flags), [VariableReference(dest, []), Expression(mInlineTooltipPresentationSpec, []), Expression(flags, [])]), Statement(}, [])])  Statement({, [])  Statement(// You can override field parcelling by defining methods like:, [])  AssignmentExpression(=, [VariableReference(int flg, []), Expression(0, [])])    VariableReference(int flg, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(if (mHostInputToken !, []), Expression(null), [])])    VariableReference(if (mHostInputToken !, [])    Expression(null), [])  AssignmentExpression(=, [VariableReference(flg |, []), Expression(0x20, [])])    VariableReference(flg |, [])    Expression(0x20, [])  AssignmentExpression(=, [VariableReference(if (mInlineTooltipPresentationSpec !, []), Expression(null), [])])    VariableReference(if (mInlineTooltipPresentationSpec !, [])    Expression(null), [])  AssignmentExpression(=, [VariableReference(flg |, []), Expression(0x80, [])])    VariableReference(flg |, [])    Expression(0x80, [])  MethodCall(dest.writeInt(flg), [VariableReference(dest, []), Expression(flg, [])])    VariableReference(dest, [])    Expression(flg, [])  MethodCall(dest.writeInt(mMaxSuggestionCount), [VariableReference(dest, []), Expression(mMaxSuggestionCount, [])])    VariableReference(dest, [])    Expression(mMaxSuggestionCount, [])  MethodCall(dest.writeParcelableList(mInlinePresentationSpecs, flags), [VariableReference(dest, []), Expression(mInlinePresentationSpecs, []), Expression(flags, [])])    VariableReference(dest, [])    Expression(mInlinePresentationSpecs, [])    Expression(flags, [])  MethodCall(dest.writeString(mHostPackageName), [VariableReference(dest, []), Expression(mHostPackageName, [])])    VariableReference(dest, [])    Expression(mHostPackageName, [])  MethodCall(dest.writeTypedObject(mSupportedLocales, flags), [VariableReference(dest, []), Expression(mSupportedLocales, []), Expression(flags, [])])    VariableReference(dest, [])    Expression(mSupportedLocales, [])    Expression(flags, [])  MethodCall(dest.writeBundle(mExtras), [VariableReference(dest, []), Expression(mExtras, [])])    VariableReference(dest, [])    Expression(mExtras, [])  Statement(parcelHostInputToken(dest, flags), [])  MethodCall(dest.writeInt(mHostDisplayId), [VariableReference(dest, []), Expression(mHostDisplayId, [])])    VariableReference(dest, [])    Expression(mHostDisplayId, [])  AssignmentExpression(=, [VariableReference(if (mInlineTooltipPresentationSpec !, []), Expression(null), [])])    VariableReference(if (mInlineTooltipPresentationSpec !, [])    Expression(null), [])  MethodCall(dest.writeTypedObject(mInlineTooltipPresentationSpec, flags), [VariableReference(dest, []), Expression(mInlineTooltipPresentationSpec, []), Expression(flags, [])])    VariableReference(dest, [])    Expression(mInlineTooltipPresentationSpec, [])    Expression(flags, [])  Statement(}, [])",1,,,0,"[@Override, @DataClass.Generated.Member]","[@Override, @DataClass.Generated.Member]",0,,,,"1,2","3,4,5",0,"3,5","1,2","The implementation of the method has changed. There are new assignment expressions and a new method call (`dest.writeTypedObject(mInlineTooltipPresentationSpec, flags)`) added in the late version. Also, the type of variable `flg` has changed from `byte` to `int`.","The new assignment expressions and method call can potentially lead to different return values or types. Also, the change of variable type can also cause potential different return values or types. The new method call can potentially throw an exception if `mInlineTooltipPresentationSpec` is null, which is not the case in the early version. Therefore, the Compatibility Issue exists for the API."
14,<android.service.voice.VoiceInteractionSession: void onHandleAssist(AssistState)>,31,32,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (state.getAssistData(), []), Expression(, [])]), Statement(return, []), AssignmentExpression(=, [VariableReference(} else if (state.getIndex(), []), Expression(, [])]), MethodCall(onHandleAssist(state.getAssistData(), state.getAssistStructure(), state.getAssistContent()), [VariableReference(onHandleAssist(state, []), Expression(), []), Expression(state.getAssistStructure(), []), Expression(state.getAssistContent(), [])]), Statement(} else {, []), MethodCall(onHandleAssistSecondary(state.getAssistData(), state.getAssistStructure(), state.getAssistContent(), state.getIndex(), state.getCount()), [VariableReference(onHandleAssistSecondary(state, []), Expression(), []), Expression(state.getAssistStructure(), []), Expression(state.getAssistContent(), []), Expression(state.getIndex(), []), Expression(state.getCount(), [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (state.getAssistData(), []), Expression(, [])])    VariableReference(if (state.getAssistData(), [])    Expression(, [])  Statement(return, [])  AssignmentExpression(=, [VariableReference(} else if (state.getIndex(), []), Expression(, [])])    VariableReference(} else if (state.getIndex(), [])    Expression(, [])  MethodCall(onHandleAssist(state.getAssistData(), state.getAssistStructure(), state.getAssistContent()), [VariableReference(onHandleAssist(state, []), Expression(), []), Expression(state.getAssistStructure(), []), Expression(state.getAssistContent(), [])])    VariableReference(onHandleAssist(state, [])    Expression(), [])    Expression(state.getAssistStructure(), [])    Expression(state.getAssistContent(), [])  Statement(} else {, [])  MethodCall(onHandleAssistSecondary(state.getAssistData(), state.getAssistStructure(), state.getAssistContent(), state.getIndex(), state.getCount()), [VariableReference(onHandleAssistSecondary(state, []), Expression(), []), Expression(state.getAssistStructure(), []), Expression(state.getAssistContent(), []), Expression(state.getIndex(), []), Expression(state.getCount(), [])])    VariableReference(onHandleAssistSecondary(state, [])    Expression(), [])    Expression(state.getAssistStructure(), [])    Expression(state.getAssistContent(), [])    Expression(state.getIndex(), [])    Expression(state.getCount(), [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (state.getAssistData(), []), Expression(, [])]), Statement(return, []), AssignmentExpression(=, [VariableReference(} else if (state.getIndex(), []), Expression(, [])]), MethodCall(onHandleAssist(state.getAssistData(), state.getAssistStructure(), state.getAssistContent()), [VariableReference(onHandleAssist(state, []), Expression(), []), Expression(state.getAssistStructure(), []), Expression(state.getAssistContent(), [])]), Statement(} else {, []), MethodCall(onHandleAssistSecondary(state.getAssistData(), state.getAssistStructure(), state.getAssistContent(), state.getIndex(), state.getCount()), [VariableReference(onHandleAssistSecondary(state, []), Expression(), []), Expression(state.getAssistStructure(), []), Expression(state.getAssistContent(), []), Expression(state.getIndex(), []), Expression(state.getCount(), [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (state.getAssistData(), []), Expression(, [])])    VariableReference(if (state.getAssistData(), [])    Expression(, [])  Statement(return, [])  AssignmentExpression(=, [VariableReference(} else if (state.getIndex(), []), Expression(, [])])    VariableReference(} else if (state.getIndex(), [])    Expression(, [])  MethodCall(onHandleAssist(state.getAssistData(), state.getAssistStructure(), state.getAssistContent()), [VariableReference(onHandleAssist(state, []), Expression(), []), Expression(state.getAssistStructure(), []), Expression(state.getAssistContent(), [])])    VariableReference(onHandleAssist(state, [])    Expression(), [])    Expression(state.getAssistStructure(), [])    Expression(state.getAssistContent(), [])  Statement(} else {, [])  MethodCall(onHandleAssistSecondary(state.getAssistData(), state.getAssistStructure(), state.getAssistContent(), state.getIndex(), state.getCount()), [VariableReference(onHandleAssistSecondary(state, []), Expression(), []), Expression(state.getAssistStructure(), []), Expression(state.getAssistContent(), []), Expression(state.getIndex(), []), Expression(state.getCount(), [])])    VariableReference(onHandleAssistSecondary(state, [])    Expression(), [])    Expression(state.getAssistStructure(), [])    Expression(state.getAssistContent(), [])    Expression(state.getIndex(), [])    Expression(state.getCount(), [])  Statement(}, [])  Statement(}, [])",0,"/**
 * Called to receive data from the application that the user was currently viewing when
 * an assist session is started. If the original show request did not specify
 * {@link #SHOW_WITH_ASSIST}, {@link AssistState} parameter will only provide
 * {@link ActivityId}.
 *
 * <p>This method is called for all activities along with an index and count that indicates
 * which activity the data is for. {@code index} will be between 0 and {@code count}-1 and
 * this method is called once for each activity in no particular order. The {@code count}
 * indicates how many activities to expect assist data for, including the top focused one.
 * The focused activity can be determined by calling {@link AssistState#isFocused()}.
 *
 * <p>To be responsive to assist requests, process assist data as soon as it is received,
 * without waiting for all queued activities to return assist data.
 *
 * @param state The state object capturing the state of an activity.
 */
","/**
 * Called to receive data from the application that the user was currently viewing when
 * an assist session is started. If the original show request did not specify
 * {@link #SHOW_WITH_ASSIST}, {@link AssistState} parameter will only provide
 * {@link ActivityId}. If there was a failure to write the assist data to
 * {@link AssistStructure}, the {@link AssistState#getAssistStructure()} will return null.
 *
 * <p>This method is called for all activities along with an index and count that indicates
 * which activity the data is for. {@code index} will be between 0 and {@code count}-1 and
 * this method is called once for each activity in no particular order. The {@code count}
 * indicates how many activities to expect assist data for, including the top focused one.
 * The focused activity can be determined by calling {@link AssistState#isFocused()}.
 *
 * <p>To be responsive to assist requests, process assist data as soon as it is received,
 * without waiting for all queued activities to return assist data.
 *
 * @param state The state object capturing the state of an activity.
 */
",1,,,0,,,,0,0,0,0,0,"There is no difference between the early and late implementation AST nodes. The only difference is in the late comment, which mentions that if there was a failure to write the assist data to AssistStructure, the AssistState#getAssistStructure() will return null. However, this does not affect the code implementation or behavior.",There is no compatibility issue as the code implementation and behavior have not changed between the two versions.
15,<android.view.contentcapture.ContentCaptureManager: ComponentName getServiceComponentName()>,31,32,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(return null, []), AssignmentExpression(=, [VariableReference(final SyncResultReceiver resultReceiver, []), Expression(new SyncResultReceiver(SYNC_CALLS_TIMEOUT_MS), [])]), Statement(try {, []), MethodCall(mService.getServiceComponentName(resultReceiver), [VariableReference(mService, []), Expression(resultReceiver, [])]), MethodCall(return resultReceiver.getParcelableResult(), [VariableReference(return resultReceiver, []), Expression(, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(return null, [])  AssignmentExpression(=, [VariableReference(final SyncResultReceiver resultReceiver, []), Expression(new SyncResultReceiver(SYNC_CALLS_TIMEOUT_MS), [])])    VariableReference(final SyncResultReceiver resultReceiver, [])    Expression(new SyncResultReceiver(SYNC_CALLS_TIMEOUT_MS), [])  Statement(try {, [])  MethodCall(mService.getServiceComponentName(resultReceiver), [VariableReference(mService, []), Expression(resultReceiver, [])])    VariableReference(mService, [])    Expression(resultReceiver, [])  MethodCall(return resultReceiver.getParcelableResult(), [VariableReference(return resultReceiver, []), Expression(, [])])    VariableReference(return resultReceiver, [])    Expression(, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return null, []), AssignmentExpression(=, [VariableReference(final SyncResultReceiver resultReceiver, []), Expression(new SyncResultReceiver(SYNC_CALLS_TIMEOUT_MS), [])]), Statement(try {, []), MethodCall(mService.getServiceComponentName(resultReceiver), [VariableReference(mService, []), Expression(resultReceiver, [])]), MethodCall(return resultReceiver.getParcelableResult(), [VariableReference(return resultReceiver, []), Expression(, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(return null, [])  AssignmentExpression(=, [VariableReference(final SyncResultReceiver resultReceiver, []), Expression(new SyncResultReceiver(SYNC_CALLS_TIMEOUT_MS), [])])    VariableReference(final SyncResultReceiver resultReceiver, [])    Expression(new SyncResultReceiver(SYNC_CALLS_TIMEOUT_MS), [])  Statement(try {, [])  MethodCall(mService.getServiceComponentName(resultReceiver), [VariableReference(mService, []), Expression(resultReceiver, [])])    VariableReference(mService, [])    Expression(resultReceiver, [])  MethodCall(return resultReceiver.getParcelableResult(), [VariableReference(return resultReceiver, []), Expression(, [])])    VariableReference(return resultReceiver, [])    Expression(, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",0,"/**
 * Returns the component name of the system service that is consuming the captured events for
 * the current user.
 */
","/**
 * Returns the component name of the system service that is consuming the captured events for
 * the current user.
 *
 * @throws RuntimeException if getting the component name is timed out.
 */
",1,[@Nullable],[@Nullable],0,,,,0,0,0,0,0,There is no change between the early and late version of the implementation AST nodes.,"As there is no change in the implementation, there is no compatibility issue."
16,<android.view.translation.TranslationResponseValue: CharSequence getTransliteration()>,31,32,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(return mTransliteration, []), Statement(}, [])])  Statement({, [])  Statement(return mTransliteration, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return mTransliteration, []), Statement(}, [])])  Statement({, [])  Statement(return mTransliteration, [])  Statement(}, [])",0,"/**
 * The transliteration result of the translated text.
 * TODO: Describe the result structure.
 */
","/**
 * The transliteration result of the translated text.
 *
 * <p>This returns a CharSequence representation of the transliteration of the translated text.
 */
",1,"[@DataClass.Generated.Member, @Nullable]","[@DataClass.Generated.Member, @Nullable]",0,,,,0,0,0,0,0,"The AST nodes of the method implementation in both the early and late versions are identical, indicating that there are no changes in the method's implementation. However, there is a slight change in the method's comment, where the late version provides a more detailed description of the method's functionality.",There are no Compatibility Issues (CI) as the method's implementation has not been changed between the two versions. The method will behave the same way in both versions. The difference in the method's comment is also not a factor for CI as it only provides additional information about the method's functionality.
17,<android.view.contentcapture.ContentCaptureContext: void dump(PrintWriter)>,31,32,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mComponentName !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(pw.print(""activity, []), Expression(""), [])]), MethodCall(pw.print(mComponentName.flattenToShortString()), [VariableReference(pw, []), Expression(mComponentName.flattenToShortString(), [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mId !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(pw.print("", id, []), Expression(""), [])]), MethodCall(mId.dump(pw), [VariableReference(mId, []), Expression(pw, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(pw.print("", activityId, []), Expression(""), [])]), MethodCall(pw.print(mActivityId), [VariableReference(pw, []), Expression(mActivityId, [])]), AssignmentExpression(=, [VariableReference(pw.print("", displayId, []), Expression(""), [])]), MethodCall(pw.print(mDisplayId), [VariableReference(pw, []), Expression(mDisplayId, [])]), AssignmentExpression(=, [VariableReference(if (mParentSessionId !, []), Expression(NO_SESSION_ID) {, [])]), AssignmentExpression(=, [VariableReference(pw.print("", parentId, []), Expression(""), [])]), MethodCall(pw.print(mParentSessionId), [VariableReference(pw, []), Expression(mParentSessionId, [])]), Statement(}, []), Statement(if (mFlags > 0) {, []), AssignmentExpression(=, [VariableReference(pw.print("", flags, []), Expression(""), [])]), MethodCall(pw.print(mFlags), [VariableReference(pw, []), Expression(mFlags, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mExtras !, []), Expression(null) {, [])]), Statement(// NOTE: cannot dump because it could contain PII, []), MethodCall(pw.print("", hasExtras""), [VariableReference(pw, []), Expression("", []), Expression(hasExtras"", [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mComponentName !, []), Expression(null) {, [])])    VariableReference(if (mComponentName !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(pw.print(""activity, []), Expression(""), [])])    VariableReference(pw.print(""activity, [])    Expression(""), [])  MethodCall(pw.print(mComponentName.flattenToShortString()), [VariableReference(pw, []), Expression(mComponentName.flattenToShortString(), [])])    VariableReference(pw, [])    Expression(mComponentName.flattenToShortString(), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mId !, []), Expression(null) {, [])])    VariableReference(if (mId !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(pw.print("", id, []), Expression(""), [])])    VariableReference(pw.print("", id, [])    Expression(""), [])  MethodCall(mId.dump(pw), [VariableReference(mId, []), Expression(pw, [])])    VariableReference(mId, [])    Expression(pw, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(pw.print("", activityId, []), Expression(""), [])])    VariableReference(pw.print("", activityId, [])    Expression(""), [])  MethodCall(pw.print(mActivityId), [VariableReference(pw, []), Expression(mActivityId, [])])    VariableReference(pw, [])    Expression(mActivityId, [])  AssignmentExpression(=, [VariableReference(pw.print("", displayId, []), Expression(""), [])])    VariableReference(pw.print("", displayId, [])    Expression(""), [])  MethodCall(pw.print(mDisplayId), [VariableReference(pw, []), Expression(mDisplayId, [])])    VariableReference(pw, [])    Expression(mDisplayId, [])  AssignmentExpression(=, [VariableReference(if (mParentSessionId !, []), Expression(NO_SESSION_ID) {, [])])    VariableReference(if (mParentSessionId !, [])    Expression(NO_SESSION_ID) {, [])  AssignmentExpression(=, [VariableReference(pw.print("", parentId, []), Expression(""), [])])    VariableReference(pw.print("", parentId, [])    Expression(""), [])  MethodCall(pw.print(mParentSessionId), [VariableReference(pw, []), Expression(mParentSessionId, [])])    VariableReference(pw, [])    Expression(mParentSessionId, [])  Statement(}, [])  Statement(if (mFlags > 0) {, [])  AssignmentExpression(=, [VariableReference(pw.print("", flags, []), Expression(""), [])])    VariableReference(pw.print("", flags, [])    Expression(""), [])  MethodCall(pw.print(mFlags), [VariableReference(pw, []), Expression(mFlags, [])])    VariableReference(pw, [])    Expression(mFlags, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mExtras !, []), Expression(null) {, [])])    VariableReference(if (mExtras !, [])    Expression(null) {, [])  Statement(// NOTE: cannot dump because it could contain PII, [])  MethodCall(pw.print("", hasExtras""), [VariableReference(pw, []), Expression("", []), Expression(hasExtras"", [])])    VariableReference(pw, [])    Expression("", [])    Expression(hasExtras"", [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mComponentName !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(pw.print(""activity, []), Expression(""), [])]), MethodCall(pw.print(mComponentName.flattenToShortString()), [VariableReference(pw, []), Expression(mComponentName.flattenToShortString(), [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mId !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(pw.print("", id, []), Expression(""), [])]), MethodCall(mId.dump(pw), [VariableReference(mId, []), Expression(pw, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(pw.print("", activityId, []), Expression(""), [])]), MethodCall(pw.print(mActivityId), [VariableReference(pw, []), Expression(mActivityId, [])]), AssignmentExpression(=, [VariableReference(pw.print("", displayId, []), Expression(""), [])]), MethodCall(pw.print(mDisplayId), [VariableReference(pw, []), Expression(mDisplayId, [])]), AssignmentExpression(=, [VariableReference(pw.print("", windowToken, []), Expression(""), [])]), MethodCall(pw.print(mWindowToken), [VariableReference(pw, []), Expression(mWindowToken, [])]), AssignmentExpression(=, [VariableReference(if (mParentSessionId !, []), Expression(NO_SESSION_ID) {, [])]), AssignmentExpression(=, [VariableReference(pw.print("", parentId, []), Expression(""), [])]), MethodCall(pw.print(mParentSessionId), [VariableReference(pw, []), Expression(mParentSessionId, [])]), Statement(}, []), Statement(if (mFlags > 0) {, []), AssignmentExpression(=, [VariableReference(pw.print("", flags, []), Expression(""), [])]), MethodCall(pw.print(mFlags), [VariableReference(pw, []), Expression(mFlags, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mExtras !, []), Expression(null) {, [])]), Statement(// NOTE: cannot dump because it could contain PII, []), MethodCall(pw.print("", hasExtras""), [VariableReference(pw, []), Expression("", []), Expression(hasExtras"", [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mComponentName !, []), Expression(null) {, [])])    VariableReference(if (mComponentName !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(pw.print(""activity, []), Expression(""), [])])    VariableReference(pw.print(""activity, [])    Expression(""), [])  MethodCall(pw.print(mComponentName.flattenToShortString()), [VariableReference(pw, []), Expression(mComponentName.flattenToShortString(), [])])    VariableReference(pw, [])    Expression(mComponentName.flattenToShortString(), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mId !, []), Expression(null) {, [])])    VariableReference(if (mId !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(pw.print("", id, []), Expression(""), [])])    VariableReference(pw.print("", id, [])    Expression(""), [])  MethodCall(mId.dump(pw), [VariableReference(mId, []), Expression(pw, [])])    VariableReference(mId, [])    Expression(pw, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(pw.print("", activityId, []), Expression(""), [])])    VariableReference(pw.print("", activityId, [])    Expression(""), [])  MethodCall(pw.print(mActivityId), [VariableReference(pw, []), Expression(mActivityId, [])])    VariableReference(pw, [])    Expression(mActivityId, [])  AssignmentExpression(=, [VariableReference(pw.print("", displayId, []), Expression(""), [])])    VariableReference(pw.print("", displayId, [])    Expression(""), [])  MethodCall(pw.print(mDisplayId), [VariableReference(pw, []), Expression(mDisplayId, [])])    VariableReference(pw, [])    Expression(mDisplayId, [])  AssignmentExpression(=, [VariableReference(pw.print("", windowToken, []), Expression(""), [])])    VariableReference(pw.print("", windowToken, [])    Expression(""), [])  MethodCall(pw.print(mWindowToken), [VariableReference(pw, []), Expression(mWindowToken, [])])    VariableReference(pw, [])    Expression(mWindowToken, [])  AssignmentExpression(=, [VariableReference(if (mParentSessionId !, []), Expression(NO_SESSION_ID) {, [])])    VariableReference(if (mParentSessionId !, [])    Expression(NO_SESSION_ID) {, [])  AssignmentExpression(=, [VariableReference(pw.print("", parentId, []), Expression(""), [])])    VariableReference(pw.print("", parentId, [])    Expression(""), [])  MethodCall(pw.print(mParentSessionId), [VariableReference(pw, []), Expression(mParentSessionId, [])])    VariableReference(pw, [])    Expression(mParentSessionId, [])  Statement(}, [])  Statement(if (mFlags > 0) {, [])  AssignmentExpression(=, [VariableReference(pw.print("", flags, []), Expression(""), [])])    VariableReference(pw.print("", flags, [])    Expression(""), [])  MethodCall(pw.print(mFlags), [VariableReference(pw, []), Expression(mFlags, [])])    VariableReference(pw, [])    Expression(mFlags, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mExtras !, []), Expression(null) {, [])])    VariableReference(if (mExtras !, [])    Expression(null) {, [])  Statement(// NOTE: cannot dump because it could contain PII, [])  MethodCall(pw.print("", hasExtras""), [VariableReference(pw, []), Expression("", []), Expression(hasExtras"", [])])    VariableReference(pw, [])    Expression("", [])    Expression(hasExtras"", [])  Statement(}, [])  Statement(}, [])",1,"// TODO(b/111276913): dump to proto as well
","// TODO(b/111276913): dump to proto as well
",0,,,0,,,,"1,2","4,5",0,4,0,"A new statement `AssignmentExpression(=, [VariableReference(pw.print("", windowToken, []), Expression(""), [])])` and `MethodCall(pw.print(mWindowToken), [VariableReference(pw, []), Expression(mWindowToken, [])])` has been added in the late version.","The newly added statements only print the value of a new field `mWindowToken` in the late version. It does not change the behavior of the API, thus no compatibility issue exists."
18,<android.appwidget.AppWidgetHostView.ViewApplyListener: void onViewApplied(View)>,31,32,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(AppWidgetHostView.this.mLayoutId, []), Expression(mLayoutId, [])]), AssignmentExpression(=, [VariableReference(mViewMode, []), Expression(VIEW_MODE_CONTENT, [])]), Statement(applyContent(v, mIsReapply, null), []), AssignmentExpression(=, [VariableReference(mLastInflatedRemoteViewsId, []), Expression(mViews.computeUniqueId(mLastInflatedRemoteViews), [])]), Statement(restoreInstanceState(), []), AssignmentExpression(=, [VariableReference(mLastExecutionSignal, []), Expression(null, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(AppWidgetHostView.this.mLayoutId, []), Expression(mLayoutId, [])])    VariableReference(AppWidgetHostView.this.mLayoutId, [])    Expression(mLayoutId, [])  AssignmentExpression(=, [VariableReference(mViewMode, []), Expression(VIEW_MODE_CONTENT, [])])    VariableReference(mViewMode, [])    Expression(VIEW_MODE_CONTENT, [])  Statement(applyContent(v, mIsReapply, null), [])  AssignmentExpression(=, [VariableReference(mLastInflatedRemoteViewsId, []), Expression(mViews.computeUniqueId(mLastInflatedRemoteViews), [])])    VariableReference(mLastInflatedRemoteViewsId, [])    Expression(mViews.computeUniqueId(mLastInflatedRemoteViews), [])  Statement(restoreInstanceState(), [])  AssignmentExpression(=, [VariableReference(mLastExecutionSignal, []), Expression(null, [])])    VariableReference(mLastExecutionSignal, [])    Expression(null, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(mViewMode, []), Expression(VIEW_MODE_CONTENT, [])]), Statement(applyContent(v, mIsReapply, null), []), AssignmentExpression(=, [VariableReference(mLastInflatedRemoteViewsId, []), Expression(mViews.computeUniqueId(mLastInflatedRemoteViews), [])]), Statement(restoreInstanceState(), []), AssignmentExpression(=, [VariableReference(mLastExecutionSignal, []), Expression(null, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(mViewMode, []), Expression(VIEW_MODE_CONTENT, [])])    VariableReference(mViewMode, [])    Expression(VIEW_MODE_CONTENT, [])  Statement(applyContent(v, mIsReapply, null), [])  AssignmentExpression(=, [VariableReference(mLastInflatedRemoteViewsId, []), Expression(mViews.computeUniqueId(mLastInflatedRemoteViews), [])])    VariableReference(mLastInflatedRemoteViewsId, [])    Expression(mViews.computeUniqueId(mLastInflatedRemoteViews), [])  Statement(restoreInstanceState(), [])  AssignmentExpression(=, [VariableReference(mLastExecutionSignal, []), Expression(null, [])])    VariableReference(mLastExecutionSignal, [])    Expression(null, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,,"1,2",4,0,4,0,"The assignment statement ""AppWidgetHostView.this.mLayoutId = mLayoutId;"" has been removed from the early version to the late version. This change affects the value of the variable ""mLayoutId"" in the late version, but it does not lead to any compatibility issue.","This code change does not lead to any compatibility issue, as it does not affect the return value or exception handling of the API. The variable ""mLayoutId"" is only used within the scope of the method and does not have any impact on the external behavior of the API."
19,"<android.app.admin.DevicePolicyManager: void setPasswordMinimumLowerCase(ComponentName,int)>",31,32,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mService !, []), Expression(null) {, [])]), Statement(try {, []), MethodCall(mService.setPasswordMinimumLowerCase(admin, length, mParentInstance), [VariableReference(mService, []), Expression(admin, []), Expression(length, []), Expression(mParentInstance, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mService !, []), Expression(null) {, [])])    VariableReference(if (mService !, [])    Expression(null) {, [])  Statement(try {, [])  MethodCall(mService.setPasswordMinimumLowerCase(admin, length, mParentInstance), [VariableReference(mService, []), Expression(admin, []), Expression(length, []), Expression(mParentInstance, [])])    VariableReference(mService, [])    Expression(admin, [])    Expression(length, [])    Expression(mParentInstance, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mService !, []), Expression(null) {, [])]), Statement(try {, []), MethodCall(mService.setPasswordMinimumLowerCase(admin, length, mParentInstance), [VariableReference(mService, []), Expression(admin, []), Expression(length, []), Expression(mParentInstance, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mService !, []), Expression(null) {, [])])    VariableReference(if (mService !, [])    Expression(null) {, [])  Statement(try {, [])  MethodCall(mService.setPasswordMinimumLowerCase(admin, length, mParentInstance), [VariableReference(mService, []), Expression(admin, []), Expression(length, []), Expression(mParentInstance, [])])    VariableReference(mService, [])    Expression(admin, [])    Expression(length, [])    Expression(mParentInstance, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])",0,"/**
 * Called by an application that is administering the device to set the minimum number of lower
 * case letters required in the password. After setting this, the user will not be able to enter
 * a new password that is not at least as restrictive as what has been set. Note that the
 * current password will remain until the user has set a new one, so the change does not take
 * place immediately. To prompt the user for a new password, use
 * {@link #ACTION_SET_NEW_PASSWORD} or {@link #ACTION_SET_NEW_PARENT_PROFILE_PASSWORD} after
 * setting this value. This constraint is only imposed if the administrator has also requested
 * {@link #PASSWORD_QUALITY_COMPLEX} with {@link #setPasswordQuality}. If an app targeting
 * SDK level {@link android.os.Build.VERSION_CODES#R} and above enforces this constraint without
 * settings password quality to {@link #PASSWORD_QUALITY_COMPLEX} first, this method will throw
 * {@link IllegalStateException}. The default value is 0.
 * <p>
 * On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the
 * password is always treated as empty.
 * <p>
 * The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call this method; if it has
 * not, a security exception will be thrown.
 * <p>
 *
 * Apps targeting {@link android.os.Build.VERSION_CODES#R} and below can call this method on the
 * {@link DevicePolicyManager} instance returned by
 * {@link #getParentProfileInstance(ComponentName)} in order to set restrictions on the parent
 * profile.
 *
 * @deprecated see {@link #setPasswordQuality(ComponentName, int)} for details.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param length The new desired minimum number of lower case letters required in the password.
 * A value of 0 means there is no restriction.
 * @throws SecurityException if {@code admin} is not an active administrator or {@code admin}
 * does not use {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD}
 * @throws IllegalStateException if the calling app is targeting SDK level
 * {@link android.os.Build.VERSION_CODES#R} and above and didn't set a sufficient password
 * quality requirement prior to calling this method.
 */
","/**
 * Called by an application that is administering the device to set the minimum number of lower
 * case letters required in the password. After setting this, the user will not be able to enter
 * a new password that is not at least as restrictive as what has been set. Note that the
 * current password will remain until the user has set a new one, so the change does not take
 * place immediately. To prompt the user for a new password, use
 * {@link #ACTION_SET_NEW_PASSWORD} or {@link #ACTION_SET_NEW_PARENT_PROFILE_PASSWORD} after
 * setting this value. This constraint is only imposed if the administrator has also requested
 * {@link #PASSWORD_QUALITY_COMPLEX} with {@link #setPasswordQuality}. If an app targeting
 * SDK level {@link android.os.Build.VERSION_CODES#R} and above enforces this constraint without
 * settings password quality to {@link #PASSWORD_QUALITY_COMPLEX} first, this method will throw
 * {@link IllegalStateException}. The default value is 0.
 * <p>
 * On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the
 * password is always treated as empty.
 * <p>
 * The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call this method; if it has
 * not, a security exception will be thrown.
 * <p>
 * Apps targeting {@link android.os.Build.VERSION_CODES#R} and below can call this method on the
 * {@link DevicePolicyManager} instance returned by
 * {@link #getParentProfileInstance(ComponentName)} in order to set restrictions on the parent
 * profile.
 *
 * <p><string>Note:</strong> this method is ignored on
 * {PackageManager#FEATURE_AUTOMOTIVE automotive builds}.
 *
 * @deprecated see {@link #setPasswordQuality(ComponentName, int)} for details.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param length The new desired minimum number of lower case letters required in the password.
 * A value of 0 means there is no restriction.
 * @throws SecurityException if {@code admin} is not an active administrator or {@code admin}
 * does not use {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD}
 * @throws IllegalStateException if the calling app is targeting SDK level
 * {@link android.os.Build.VERSION_CODES#R} and above and didn't set a sufficient password
 * quality requirement prior to calling this method.
 */
",1,[@Deprecated],[@Deprecated],0,,,,0,0,0,0,0,"The given AST nodes for the early and late implementations are exactly the same. The only difference is in the comments, where a note has been added in the late version about the method being ignored on automotive builds. However, this change in the comment does not affect the functionality or behavior of the API.","As there are no changes in the implementation of the API that could lead to different behaviors, there are no Compatibility Issues (CI) in this case."
20,<android.inputmethodservice.IInputMethodWrapper: void executeMessage(Message)>,31,32,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(InputMethod inputMethod, []), Expression(mInputMethod.get(), [])]), Statement(// Need a valid reference to the inputMethod for everything except a dump., []), AssignmentExpression(=, [VariableReference(if (inputMethod, []), Expression(, [])]), MethodCall(Log.w(TAG, ""Input method reference was null, ignoring message: "" + msg.what), [VariableReference(Log, []), Expression(TAG, []), Expression(""Input method reference was null, []), Expression(ignoring message: "" + msg.what, [])]), Statement(return, []), Statement(}, []), Statement(case DO_DUMP:, []), Statement({, []), AssignmentExpression(=, [VariableReference(AbstractInputMethodService target, []), Expression(mTarget.get(), [])]), AssignmentExpression(=, [VariableReference(if (target, []), Expression(, [])]), Statement(return, []), Statement(}, []), AssignmentExpression(=, [VariableReference(SomeArgs args, []), Expression((SomeArgs) msg.obj, [])]), Statement(try {, []), MethodCall(target.dump((FileDescriptor) args.arg1, (PrintWriter) args.arg2, (String[]) args.arg3), [VariableReference(target, []), Expression((FileDescriptor) args.arg1, []), Expression((PrintWriter) args.arg2, []), Expression((String[]) args.arg3, [])]), Statement(} catch (RuntimeException e) {, []), Statement(}, []), Statement(}, []), MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])]), Statement(return, []), Statement(}, []), Statement(case DO_INITIALIZE_INTERNAL:, []), Statement({, []), AssignmentExpression(=, [VariableReference(SomeArgs args, []), Expression((SomeArgs) msg.obj, [])]), Statement(try {, []), MethodCall(inputMethod.initializeInternal((IBinder) args.arg1, msg.arg1, (IInputMethodPrivilegedOperations) args.arg2, (int) args.arg3), [VariableReference(inputMethod, []), Expression((IBinder) args.arg1, []), Expression(msg.arg1, []), Expression((IInputMethodPrivilegedOperations) args.arg2, []), Expression((int) args.arg3, [])]), Statement(} finally {, []), MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])]), Statement(}, []), Statement(return, []), Statement(}, []), Statement(case DO_SET_INPUT_CONTEXT:, []), Statement({, []), MethodCall(inputMethod.bindInput((InputBinding) msg.obj), [VariableReference(inputMethod, []), Expression((InputBinding) msg.obj, [])]), Statement(return, []), Statement(}, []), Statement(case DO_UNSET_INPUT_CONTEXT:, []), MethodCall(inputMethod.unbindInput(), [VariableReference(inputMethod, []), Expression(, [])]), Statement(return, []), Statement(case DO_START_INPUT:, []), Statement({, []), AssignmentExpression(=, [VariableReference(final SomeArgs args, []), Expression((SomeArgs) msg.obj, [])]), AssignmentExpression(=, [VariableReference(final IBinder startInputToken, []), Expression((IBinder) args.arg1, [])]), AssignmentExpression(=, [VariableReference(final IInputContext inputContext, []), Expression((IInputContext) args.arg2, [])]), AssignmentExpression(=, [VariableReference(final EditorInfo info, []), Expression((EditorInfo) args.arg3, [])]), AssignmentExpression(=, [VariableReference(final CancellationGroup cancellationGroup, []), Expression((CancellationGroup) args.arg4, [])]), AssignmentExpression(=, [VariableReference(SomeArgs moreArgs, []), Expression((SomeArgs) args.arg5, [])]), AssignmentExpression(=, [VariableReference(final InputConnection ic, []), Expression(inputContext !, [])]), MethodCall(info.makeCompatible(mTargetSdkVersion), [VariableReference(info, []), Expression(mTargetSdkVersion, [])]), AssignmentExpression(=, [VariableReference(inputMethod.dispatchStartInputWithToken(ic, info, moreArgs.argi1, []), Expression(, [])]), Statement(startInputToken), []), MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])]), MethodCall(moreArgs.recycle(), [VariableReference(moreArgs, []), Expression(, [])]), Statement(return, []), Statement(}, []), Statement(case DO_CREATE_SESSION:, []), Statement({, []), AssignmentExpression(=, [VariableReference(SomeArgs args, []), Expression((SomeArgs) msg.obj, [])]), MethodCall(inputMethod.createSession(new InputMethodSessionCallbackWrapper(mContext, (InputChannel) args.arg1, (IInputSessionCallback) args.arg2)), [VariableReference(inputMethod, []), Expression(new InputMethodSessionCallbackWrapper(mContext, []), Expression((InputChannel) args.arg1, []), Expression((IInputSessionCallback) args.arg2), [])]), MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])]), Statement(return, []), Statement(}, []), Statement(case DO_SET_SESSION_ENABLED:, []), AssignmentExpression(=, [VariableReference(inputMethod.setSessionEnabled((InputMethodSession) msg.obj, msg.arg1 !, []), Expression(0), [])]), Statement(return, []), Statement(case DO_REVOKE_SESSION:, []), MethodCall(inputMethod.revokeSession((InputMethodSession) msg.obj), [VariableReference(inputMethod, []), Expression((InputMethodSession) msg.obj, [])]), Statement(return, []), Statement(case DO_SHOW_SOFT_INPUT:, []), Statement({, []), AssignmentExpression(=, [VariableReference(final SomeArgs args, []), Expression((SomeArgs) msg.obj, [])]), MethodCall(inputMethod.showSoftInputWithToken(msg.arg1, (ResultReceiver) args.arg2, (IBinder) args.arg1), [VariableReference(inputMethod, []), Expression(msg.arg1, []), Expression((ResultReceiver) args.arg2, []), Expression((IBinder) args.arg1, [])]), MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])]), Statement(return, []), Statement(}, []), Statement(case DO_HIDE_SOFT_INPUT:, []), Statement({, []), AssignmentExpression(=, [VariableReference(final SomeArgs args, []), Expression((SomeArgs) msg.obj, [])]), MethodCall(inputMethod.hideSoftInputWithToken(msg.arg1, (ResultReceiver) args.arg2, (IBinder) args.arg1), [VariableReference(inputMethod, []), Expression(msg.arg1, []), Expression((ResultReceiver) args.arg2, []), Expression((IBinder) args.arg1, [])]), MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])]), Statement(return, []), Statement(}, []), Statement(case DO_CHANGE_INPUTMETHOD_SUBTYPE:, []), MethodCall(inputMethod.changeInputMethodSubtype((InputMethodSubtype) msg.obj), [VariableReference(inputMethod, []), Expression((InputMethodSubtype) msg.obj, [])]), Statement(return, []), Statement(case DO_CREATE_INLINE_SUGGESTIONS_REQUEST:, []), AssignmentExpression(=, [VariableReference(final SomeArgs args, []), Expression((SomeArgs) msg.obj, [])]), MethodCall(inputMethod.onCreateInlineSuggestionsRequest((InlineSuggestionsRequestInfo) args.arg1, (IInlineSuggestionsRequestCallback) args.arg2), [VariableReference(inputMethod, []), Expression((InlineSuggestionsRequestInfo) args.arg1, []), Expression((IInlineSuggestionsRequestCallback) args.arg2, [])]), MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])]), Statement(return, []), Statement(}, []), MethodCall(Log.w(TAG, ""Unhandled message code: "" + msg.what), [VariableReference(Log, []), Expression(TAG, []), Expression(""Unhandled message code: "" + msg.what, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(InputMethod inputMethod, []), Expression(mInputMethod.get(), [])])    VariableReference(InputMethod inputMethod, [])    Expression(mInputMethod.get(), [])  Statement(// Need a valid reference to the inputMethod for everything except a dump., [])  AssignmentExpression(=, [VariableReference(if (inputMethod, []), Expression(, [])])    VariableReference(if (inputMethod, [])    Expression(, [])  MethodCall(Log.w(TAG, ""Input method reference was null, ignoring message: "" + msg.what), [VariableReference(Log, []), Expression(TAG, []), Expression(""Input method reference was null, []), Expression(ignoring message: "" + msg.what, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Input method reference was null, [])    Expression(ignoring message: "" + msg.what, [])  Statement(return, [])  Statement(}, [])  Statement(case DO_DUMP:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(AbstractInputMethodService target, []), Expression(mTarget.get(), [])])    VariableReference(AbstractInputMethodService target, [])    Expression(mTarget.get(), [])  AssignmentExpression(=, [VariableReference(if (target, []), Expression(, [])])    VariableReference(if (target, [])    Expression(, [])  Statement(return, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(SomeArgs args, []), Expression((SomeArgs) msg.obj, [])])    VariableReference(SomeArgs args, [])    Expression((SomeArgs) msg.obj, [])  Statement(try {, [])  MethodCall(target.dump((FileDescriptor) args.arg1, (PrintWriter) args.arg2, (String[]) args.arg3), [VariableReference(target, []), Expression((FileDescriptor) args.arg1, []), Expression((PrintWriter) args.arg2, []), Expression((String[]) args.arg3, [])])    VariableReference(target, [])    Expression((FileDescriptor) args.arg1, [])    Expression((PrintWriter) args.arg2, [])    Expression((String[]) args.arg3, [])  Statement(} catch (RuntimeException e) {, [])  Statement(}, [])  Statement(}, [])  MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])])    VariableReference(args, [])    Expression(, [])  Statement(return, [])  Statement(}, [])  Statement(case DO_INITIALIZE_INTERNAL:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(SomeArgs args, []), Expression((SomeArgs) msg.obj, [])])    VariableReference(SomeArgs args, [])    Expression((SomeArgs) msg.obj, [])  Statement(try {, [])  MethodCall(inputMethod.initializeInternal((IBinder) args.arg1, msg.arg1, (IInputMethodPrivilegedOperations) args.arg2, (int) args.arg3), [VariableReference(inputMethod, []), Expression((IBinder) args.arg1, []), Expression(msg.arg1, []), Expression((IInputMethodPrivilegedOperations) args.arg2, []), Expression((int) args.arg3, [])])    VariableReference(inputMethod, [])    Expression((IBinder) args.arg1, [])    Expression(msg.arg1, [])    Expression((IInputMethodPrivilegedOperations) args.arg2, [])    Expression((int) args.arg3, [])  Statement(} finally {, [])  MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])])    VariableReference(args, [])    Expression(, [])  Statement(}, [])  Statement(return, [])  Statement(}, [])  Statement(case DO_SET_INPUT_CONTEXT:, [])  Statement({, [])  MethodCall(inputMethod.bindInput((InputBinding) msg.obj), [VariableReference(inputMethod, []), Expression((InputBinding) msg.obj, [])])    VariableReference(inputMethod, [])    Expression((InputBinding) msg.obj, [])  Statement(return, [])  Statement(}, [])  Statement(case DO_UNSET_INPUT_CONTEXT:, [])  MethodCall(inputMethod.unbindInput(), [VariableReference(inputMethod, []), Expression(, [])])    VariableReference(inputMethod, [])    Expression(, [])  Statement(return, [])  Statement(case DO_START_INPUT:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(final SomeArgs args, []), Expression((SomeArgs) msg.obj, [])])    VariableReference(final SomeArgs args, [])    Expression((SomeArgs) msg.obj, [])  AssignmentExpression(=, [VariableReference(final IBinder startInputToken, []), Expression((IBinder) args.arg1, [])])    VariableReference(final IBinder startInputToken, [])    Expression((IBinder) args.arg1, [])  AssignmentExpression(=, [VariableReference(final IInputContext inputContext, []), Expression((IInputContext) args.arg2, [])])    VariableReference(final IInputContext inputContext, [])    Expression((IInputContext) args.arg2, [])  AssignmentExpression(=, [VariableReference(final EditorInfo info, []), Expression((EditorInfo) args.arg3, [])])    VariableReference(final EditorInfo info, [])    Expression((EditorInfo) args.arg3, [])  AssignmentExpression(=, [VariableReference(final CancellationGroup cancellationGroup, []), Expression((CancellationGroup) args.arg4, [])])    VariableReference(final CancellationGroup cancellationGroup, [])    Expression((CancellationGroup) args.arg4, [])  AssignmentExpression(=, [VariableReference(SomeArgs moreArgs, []), Expression((SomeArgs) args.arg5, [])])    VariableReference(SomeArgs moreArgs, [])    Expression((SomeArgs) args.arg5, [])  AssignmentExpression(=, [VariableReference(final InputConnection ic, []), Expression(inputContext !, [])])    VariableReference(final InputConnection ic, [])    Expression(inputContext !, [])  MethodCall(info.makeCompatible(mTargetSdkVersion), [VariableReference(info, []), Expression(mTargetSdkVersion, [])])    VariableReference(info, [])    Expression(mTargetSdkVersion, [])  AssignmentExpression(=, [VariableReference(inputMethod.dispatchStartInputWithToken(ic, info, moreArgs.argi1, []), Expression(, [])])    VariableReference(inputMethod.dispatchStartInputWithToken(ic, info, moreArgs.argi1, [])    Expression(, [])  Statement(startInputToken), [])  MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])])    VariableReference(args, [])    Expression(, [])  MethodCall(moreArgs.recycle(), [VariableReference(moreArgs, []), Expression(, [])])    VariableReference(moreArgs, [])    Expression(, [])  Statement(return, [])  Statement(}, [])  Statement(case DO_CREATE_SESSION:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(SomeArgs args, []), Expression((SomeArgs) msg.obj, [])])    VariableReference(SomeArgs args, [])    Expression((SomeArgs) msg.obj, [])  MethodCall(inputMethod.createSession(new InputMethodSessionCallbackWrapper(mContext, (InputChannel) args.arg1, (IInputSessionCallback) args.arg2)), [VariableReference(inputMethod, []), Expression(new InputMethodSessionCallbackWrapper(mContext, []), Expression((InputChannel) args.arg1, []), Expression((IInputSessionCallback) args.arg2), [])])    VariableReference(inputMethod, [])    Expression(new InputMethodSessionCallbackWrapper(mContext, [])    Expression((InputChannel) args.arg1, [])    Expression((IInputSessionCallback) args.arg2), [])  MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])])    VariableReference(args, [])    Expression(, [])  Statement(return, [])  Statement(}, [])  Statement(case DO_SET_SESSION_ENABLED:, [])  AssignmentExpression(=, [VariableReference(inputMethod.setSessionEnabled((InputMethodSession) msg.obj, msg.arg1 !, []), Expression(0), [])])    VariableReference(inputMethod.setSessionEnabled((InputMethodSession) msg.obj, msg.arg1 !, [])    Expression(0), [])  Statement(return, [])  Statement(case DO_REVOKE_SESSION:, [])  MethodCall(inputMethod.revokeSession((InputMethodSession) msg.obj), [VariableReference(inputMethod, []), Expression((InputMethodSession) msg.obj, [])])    VariableReference(inputMethod, [])    Expression((InputMethodSession) msg.obj, [])  Statement(return, [])  Statement(case DO_SHOW_SOFT_INPUT:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(final SomeArgs args, []), Expression((SomeArgs) msg.obj, [])])    VariableReference(final SomeArgs args, [])    Expression((SomeArgs) msg.obj, [])  MethodCall(inputMethod.showSoftInputWithToken(msg.arg1, (ResultReceiver) args.arg2, (IBinder) args.arg1), [VariableReference(inputMethod, []), Expression(msg.arg1, []), Expression((ResultReceiver) args.arg2, []), Expression((IBinder) args.arg1, [])])    VariableReference(inputMethod, [])    Expression(msg.arg1, [])    Expression((ResultReceiver) args.arg2, [])    Expression((IBinder) args.arg1, [])  MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])])    VariableReference(args, [])    Expression(, [])  Statement(return, [])  Statement(}, [])  Statement(case DO_HIDE_SOFT_INPUT:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(final SomeArgs args, []), Expression((SomeArgs) msg.obj, [])])    VariableReference(final SomeArgs args, [])    Expression((SomeArgs) msg.obj, [])  MethodCall(inputMethod.hideSoftInputWithToken(msg.arg1, (ResultReceiver) args.arg2, (IBinder) args.arg1), [VariableReference(inputMethod, []), Expression(msg.arg1, []), Expression((ResultReceiver) args.arg2, []), Expression((IBinder) args.arg1, [])])    VariableReference(inputMethod, [])    Expression(msg.arg1, [])    Expression((ResultReceiver) args.arg2, [])    Expression((IBinder) args.arg1, [])  MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])])    VariableReference(args, [])    Expression(, [])  Statement(return, [])  Statement(}, [])  Statement(case DO_CHANGE_INPUTMETHOD_SUBTYPE:, [])  MethodCall(inputMethod.changeInputMethodSubtype((InputMethodSubtype) msg.obj), [VariableReference(inputMethod, []), Expression((InputMethodSubtype) msg.obj, [])])    VariableReference(inputMethod, [])    Expression((InputMethodSubtype) msg.obj, [])  Statement(return, [])  Statement(case DO_CREATE_INLINE_SUGGESTIONS_REQUEST:, [])  AssignmentExpression(=, [VariableReference(final SomeArgs args, []), Expression((SomeArgs) msg.obj, [])])    VariableReference(final SomeArgs args, [])    Expression((SomeArgs) msg.obj, [])  MethodCall(inputMethod.onCreateInlineSuggestionsRequest((InlineSuggestionsRequestInfo) args.arg1, (IInlineSuggestionsRequestCallback) args.arg2), [VariableReference(inputMethod, []), Expression((InlineSuggestionsRequestInfo) args.arg1, []), Expression((IInlineSuggestionsRequestCallback) args.arg2, [])])    VariableReference(inputMethod, [])    Expression((InlineSuggestionsRequestInfo) args.arg1, [])    Expression((IInlineSuggestionsRequestCallback) args.arg2, [])  MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])])    VariableReference(args, [])    Expression(, [])  Statement(return, [])  Statement(}, [])  MethodCall(Log.w(TAG, ""Unhandled message code: "" + msg.what), [VariableReference(Log, []), Expression(TAG, []), Expression(""Unhandled message code: "" + msg.what, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Unhandled message code: "" + msg.what, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(InputMethod inputMethod, []), Expression(mInputMethod.get(), [])]), Statement(// Need a valid reference to the inputMethod for everything except a dump., []), AssignmentExpression(=, [VariableReference(if (inputMethod, []), Expression(, [])]), MethodCall(Log.w(TAG, ""Input method reference was null, ignoring message: "" + msg.what), [VariableReference(Log, []), Expression(TAG, []), Expression(""Input method reference was null, []), Expression(ignoring message: "" + msg.what, [])]), Statement(return, []), Statement(}, []), Statement(case DO_DUMP:, []), Statement({, []), AssignmentExpression(=, [VariableReference(AbstractInputMethodService target, []), Expression(mTarget.get(), [])]), AssignmentExpression(=, [VariableReference(if (target, []), Expression(, [])]), Statement(return, []), Statement(}, []), AssignmentExpression(=, [VariableReference(SomeArgs args, []), Expression((SomeArgs) msg.obj, [])]), Statement(try {, []), MethodCall(target.dump((FileDescriptor) args.arg1, (PrintWriter) args.arg2, (String[]) args.arg3), [VariableReference(target, []), Expression((FileDescriptor) args.arg1, []), Expression((PrintWriter) args.arg2, []), Expression((String[]) args.arg3, [])]), Statement(} catch (RuntimeException e) {, []), Statement(}, []), Statement(}, []), MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])]), Statement(return, []), Statement(}, []), Statement(case DO_INITIALIZE_INTERNAL:, []), Statement({, []), AssignmentExpression(=, [VariableReference(SomeArgs args, []), Expression((SomeArgs) msg.obj, [])]), Statement(try {, []), MethodCall(inputMethod.initializeInternal((IBinder) args.arg1, (IInputMethodPrivilegedOperations) args.arg2, msg.arg1), [VariableReference(inputMethod, []), Expression((IBinder) args.arg1, []), Expression((IInputMethodPrivilegedOperations) args.arg2, []), Expression(msg.arg1, [])]), Statement(} finally {, []), MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])]), Statement(}, []), Statement(return, []), Statement(}, []), Statement(case DO_SET_INPUT_CONTEXT:, []), Statement({, []), MethodCall(inputMethod.bindInput((InputBinding) msg.obj), [VariableReference(inputMethod, []), Expression((InputBinding) msg.obj, [])]), Statement(return, []), Statement(}, []), Statement(case DO_UNSET_INPUT_CONTEXT:, []), MethodCall(inputMethod.unbindInput(), [VariableReference(inputMethod, []), Expression(, [])]), Statement(return, []), Statement(case DO_START_INPUT:, []), Statement({, []), AssignmentExpression(=, [VariableReference(final SomeArgs args, []), Expression((SomeArgs) msg.obj, [])]), AssignmentExpression(=, [VariableReference(final IBinder startInputToken, []), Expression((IBinder) args.arg1, [])]), AssignmentExpression(=, [VariableReference(final IInputContext inputContext, []), Expression((IInputContext) args.arg2, [])]), AssignmentExpression(=, [VariableReference(final EditorInfo info, []), Expression((EditorInfo) args.arg3, [])]), AssignmentExpression(=, [VariableReference(final CancellationGroup cancellationGroup, []), Expression((CancellationGroup) args.arg4, [])]), AssignmentExpression(=, [VariableReference(SomeArgs moreArgs, []), Expression((SomeArgs) args.arg5, [])]), AssignmentExpression(=, [VariableReference(final InputConnection ic, []), Expression(inputContext !, [])]), MethodCall(info.makeCompatible(mTargetSdkVersion), [VariableReference(info, []), Expression(mTargetSdkVersion, [])]), AssignmentExpression(=, [VariableReference(inputMethod.dispatchStartInputWithToken(ic, info, moreArgs.argi1, []), Expression(, [])]), Statement(startInputToken), []), MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])]), MethodCall(moreArgs.recycle(), [VariableReference(moreArgs, []), Expression(, [])]), Statement(return, []), Statement(}, []), Statement(case DO_CREATE_SESSION:, []), Statement({, []), AssignmentExpression(=, [VariableReference(SomeArgs args, []), Expression((SomeArgs) msg.obj, [])]), MethodCall(inputMethod.createSession(new InputMethodSessionCallbackWrapper(mContext, (InputChannel) args.arg1, (IInputSessionCallback) args.arg2)), [VariableReference(inputMethod, []), Expression(new InputMethodSessionCallbackWrapper(mContext, []), Expression((InputChannel) args.arg1, []), Expression((IInputSessionCallback) args.arg2), [])]), MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])]), Statement(return, []), Statement(}, []), Statement(case DO_SET_SESSION_ENABLED:, []), AssignmentExpression(=, [VariableReference(inputMethod.setSessionEnabled((InputMethodSession) msg.obj, msg.arg1 !, []), Expression(0), [])]), Statement(return, []), Statement(case DO_REVOKE_SESSION:, []), MethodCall(inputMethod.revokeSession((InputMethodSession) msg.obj), [VariableReference(inputMethod, []), Expression((InputMethodSession) msg.obj, [])]), Statement(return, []), Statement(case DO_SHOW_SOFT_INPUT:, []), Statement({, []), AssignmentExpression(=, [VariableReference(final SomeArgs args, []), Expression((SomeArgs) msg.obj, [])]), MethodCall(inputMethod.showSoftInputWithToken(msg.arg1, (ResultReceiver) args.arg2, (IBinder) args.arg1), [VariableReference(inputMethod, []), Expression(msg.arg1, []), Expression((ResultReceiver) args.arg2, []), Expression((IBinder) args.arg1, [])]), MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])]), Statement(return, []), Statement(}, []), Statement(case DO_HIDE_SOFT_INPUT:, []), Statement({, []), AssignmentExpression(=, [VariableReference(final SomeArgs args, []), Expression((SomeArgs) msg.obj, [])]), MethodCall(inputMethod.hideSoftInputWithToken(msg.arg1, (ResultReceiver) args.arg2, (IBinder) args.arg1), [VariableReference(inputMethod, []), Expression(msg.arg1, []), Expression((ResultReceiver) args.arg2, []), Expression((IBinder) args.arg1, [])]), MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])]), Statement(return, []), Statement(}, []), Statement(case DO_CHANGE_INPUTMETHOD_SUBTYPE:, []), MethodCall(inputMethod.changeInputMethodSubtype((InputMethodSubtype) msg.obj), [VariableReference(inputMethod, []), Expression((InputMethodSubtype) msg.obj, [])]), Statement(return, []), Statement(case DO_CREATE_INLINE_SUGGESTIONS_REQUEST:, []), AssignmentExpression(=, [VariableReference(final SomeArgs args, []), Expression((SomeArgs) msg.obj, [])]), MethodCall(inputMethod.onCreateInlineSuggestionsRequest((InlineSuggestionsRequestInfo) args.arg1, (IInlineSuggestionsRequestCallback) args.arg2), [VariableReference(inputMethod, []), Expression((InlineSuggestionsRequestInfo) args.arg1, []), Expression((IInlineSuggestionsRequestCallback) args.arg2, [])]), MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])]), Statement(return, []), Statement(}, []), MethodCall(Log.w(TAG, ""Unhandled message code: "" + msg.what), [VariableReference(Log, []), Expression(TAG, []), Expression(""Unhandled message code: "" + msg.what, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(InputMethod inputMethod, []), Expression(mInputMethod.get(), [])])    VariableReference(InputMethod inputMethod, [])    Expression(mInputMethod.get(), [])  Statement(// Need a valid reference to the inputMethod for everything except a dump., [])  AssignmentExpression(=, [VariableReference(if (inputMethod, []), Expression(, [])])    VariableReference(if (inputMethod, [])    Expression(, [])  MethodCall(Log.w(TAG, ""Input method reference was null, ignoring message: "" + msg.what), [VariableReference(Log, []), Expression(TAG, []), Expression(""Input method reference was null, []), Expression(ignoring message: "" + msg.what, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Input method reference was null, [])    Expression(ignoring message: "" + msg.what, [])  Statement(return, [])  Statement(}, [])  Statement(case DO_DUMP:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(AbstractInputMethodService target, []), Expression(mTarget.get(), [])])    VariableReference(AbstractInputMethodService target, [])    Expression(mTarget.get(), [])  AssignmentExpression(=, [VariableReference(if (target, []), Expression(, [])])    VariableReference(if (target, [])    Expression(, [])  Statement(return, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(SomeArgs args, []), Expression((SomeArgs) msg.obj, [])])    VariableReference(SomeArgs args, [])    Expression((SomeArgs) msg.obj, [])  Statement(try {, [])  MethodCall(target.dump((FileDescriptor) args.arg1, (PrintWriter) args.arg2, (String[]) args.arg3), [VariableReference(target, []), Expression((FileDescriptor) args.arg1, []), Expression((PrintWriter) args.arg2, []), Expression((String[]) args.arg3, [])])    VariableReference(target, [])    Expression((FileDescriptor) args.arg1, [])    Expression((PrintWriter) args.arg2, [])    Expression((String[]) args.arg3, [])  Statement(} catch (RuntimeException e) {, [])  Statement(}, [])  Statement(}, [])  MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])])    VariableReference(args, [])    Expression(, [])  Statement(return, [])  Statement(}, [])  Statement(case DO_INITIALIZE_INTERNAL:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(SomeArgs args, []), Expression((SomeArgs) msg.obj, [])])    VariableReference(SomeArgs args, [])    Expression((SomeArgs) msg.obj, [])  Statement(try {, [])  MethodCall(inputMethod.initializeInternal((IBinder) args.arg1, (IInputMethodPrivilegedOperations) args.arg2, msg.arg1), [VariableReference(inputMethod, []), Expression((IBinder) args.arg1, []), Expression((IInputMethodPrivilegedOperations) args.arg2, []), Expression(msg.arg1, [])])    VariableReference(inputMethod, [])    Expression((IBinder) args.arg1, [])    Expression((IInputMethodPrivilegedOperations) args.arg2, [])    Expression(msg.arg1, [])  Statement(} finally {, [])  MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])])    VariableReference(args, [])    Expression(, [])  Statement(}, [])  Statement(return, [])  Statement(}, [])  Statement(case DO_SET_INPUT_CONTEXT:, [])  Statement({, [])  MethodCall(inputMethod.bindInput((InputBinding) msg.obj), [VariableReference(inputMethod, []), Expression((InputBinding) msg.obj, [])])    VariableReference(inputMethod, [])    Expression((InputBinding) msg.obj, [])  Statement(return, [])  Statement(}, [])  Statement(case DO_UNSET_INPUT_CONTEXT:, [])  MethodCall(inputMethod.unbindInput(), [VariableReference(inputMethod, []), Expression(, [])])    VariableReference(inputMethod, [])    Expression(, [])  Statement(return, [])  Statement(case DO_START_INPUT:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(final SomeArgs args, []), Expression((SomeArgs) msg.obj, [])])    VariableReference(final SomeArgs args, [])    Expression((SomeArgs) msg.obj, [])  AssignmentExpression(=, [VariableReference(final IBinder startInputToken, []), Expression((IBinder) args.arg1, [])])    VariableReference(final IBinder startInputToken, [])    Expression((IBinder) args.arg1, [])  AssignmentExpression(=, [VariableReference(final IInputContext inputContext, []), Expression((IInputContext) args.arg2, [])])    VariableReference(final IInputContext inputContext, [])    Expression((IInputContext) args.arg2, [])  AssignmentExpression(=, [VariableReference(final EditorInfo info, []), Expression((EditorInfo) args.arg3, [])])    VariableReference(final EditorInfo info, [])    Expression((EditorInfo) args.arg3, [])  AssignmentExpression(=, [VariableReference(final CancellationGroup cancellationGroup, []), Expression((CancellationGroup) args.arg4, [])])    VariableReference(final CancellationGroup cancellationGroup, [])    Expression((CancellationGroup) args.arg4, [])  AssignmentExpression(=, [VariableReference(SomeArgs moreArgs, []), Expression((SomeArgs) args.arg5, [])])    VariableReference(SomeArgs moreArgs, [])    Expression((SomeArgs) args.arg5, [])  AssignmentExpression(=, [VariableReference(final InputConnection ic, []), Expression(inputContext !, [])])    VariableReference(final InputConnection ic, [])    Expression(inputContext !, [])  MethodCall(info.makeCompatible(mTargetSdkVersion), [VariableReference(info, []), Expression(mTargetSdkVersion, [])])    VariableReference(info, [])    Expression(mTargetSdkVersion, [])  AssignmentExpression(=, [VariableReference(inputMethod.dispatchStartInputWithToken(ic, info, moreArgs.argi1, []), Expression(, [])])    VariableReference(inputMethod.dispatchStartInputWithToken(ic, info, moreArgs.argi1, [])    Expression(, [])  Statement(startInputToken), [])  MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])])    VariableReference(args, [])    Expression(, [])  MethodCall(moreArgs.recycle(), [VariableReference(moreArgs, []), Expression(, [])])    VariableReference(moreArgs, [])    Expression(, [])  Statement(return, [])  Statement(}, [])  Statement(case DO_CREATE_SESSION:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(SomeArgs args, []), Expression((SomeArgs) msg.obj, [])])    VariableReference(SomeArgs args, [])    Expression((SomeArgs) msg.obj, [])  MethodCall(inputMethod.createSession(new InputMethodSessionCallbackWrapper(mContext, (InputChannel) args.arg1, (IInputSessionCallback) args.arg2)), [VariableReference(inputMethod, []), Expression(new InputMethodSessionCallbackWrapper(mContext, []), Expression((InputChannel) args.arg1, []), Expression((IInputSessionCallback) args.arg2), [])])    VariableReference(inputMethod, [])    Expression(new InputMethodSessionCallbackWrapper(mContext, [])    Expression((InputChannel) args.arg1, [])    Expression((IInputSessionCallback) args.arg2), [])  MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])])    VariableReference(args, [])    Expression(, [])  Statement(return, [])  Statement(}, [])  Statement(case DO_SET_SESSION_ENABLED:, [])  AssignmentExpression(=, [VariableReference(inputMethod.setSessionEnabled((InputMethodSession) msg.obj, msg.arg1 !, []), Expression(0), [])])    VariableReference(inputMethod.setSessionEnabled((InputMethodSession) msg.obj, msg.arg1 !, [])    Expression(0), [])  Statement(return, [])  Statement(case DO_REVOKE_SESSION:, [])  MethodCall(inputMethod.revokeSession((InputMethodSession) msg.obj), [VariableReference(inputMethod, []), Expression((InputMethodSession) msg.obj, [])])    VariableReference(inputMethod, [])    Expression((InputMethodSession) msg.obj, [])  Statement(return, [])  Statement(case DO_SHOW_SOFT_INPUT:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(final SomeArgs args, []), Expression((SomeArgs) msg.obj, [])])    VariableReference(final SomeArgs args, [])    Expression((SomeArgs) msg.obj, [])  MethodCall(inputMethod.showSoftInputWithToken(msg.arg1, (ResultReceiver) args.arg2, (IBinder) args.arg1), [VariableReference(inputMethod, []), Expression(msg.arg1, []), Expression((ResultReceiver) args.arg2, []), Expression((IBinder) args.arg1, [])])    VariableReference(inputMethod, [])    Expression(msg.arg1, [])    Expression((ResultReceiver) args.arg2, [])    Expression((IBinder) args.arg1, [])  MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])])    VariableReference(args, [])    Expression(, [])  Statement(return, [])  Statement(}, [])  Statement(case DO_HIDE_SOFT_INPUT:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(final SomeArgs args, []), Expression((SomeArgs) msg.obj, [])])    VariableReference(final SomeArgs args, [])    Expression((SomeArgs) msg.obj, [])  MethodCall(inputMethod.hideSoftInputWithToken(msg.arg1, (ResultReceiver) args.arg2, (IBinder) args.arg1), [VariableReference(inputMethod, []), Expression(msg.arg1, []), Expression((ResultReceiver) args.arg2, []), Expression((IBinder) args.arg1, [])])    VariableReference(inputMethod, [])    Expression(msg.arg1, [])    Expression((ResultReceiver) args.arg2, [])    Expression((IBinder) args.arg1, [])  MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])])    VariableReference(args, [])    Expression(, [])  Statement(return, [])  Statement(}, [])  Statement(case DO_CHANGE_INPUTMETHOD_SUBTYPE:, [])  MethodCall(inputMethod.changeInputMethodSubtype((InputMethodSubtype) msg.obj), [VariableReference(inputMethod, []), Expression((InputMethodSubtype) msg.obj, [])])    VariableReference(inputMethod, [])    Expression((InputMethodSubtype) msg.obj, [])  Statement(return, [])  Statement(case DO_CREATE_INLINE_SUGGESTIONS_REQUEST:, [])  AssignmentExpression(=, [VariableReference(final SomeArgs args, []), Expression((SomeArgs) msg.obj, [])])    VariableReference(final SomeArgs args, [])    Expression((SomeArgs) msg.obj, [])  MethodCall(inputMethod.onCreateInlineSuggestionsRequest((InlineSuggestionsRequestInfo) args.arg1, (IInlineSuggestionsRequestCallback) args.arg2), [VariableReference(inputMethod, []), Expression((InlineSuggestionsRequestInfo) args.arg1, []), Expression((IInlineSuggestionsRequestCallback) args.arg2, [])])    VariableReference(inputMethod, [])    Expression((InlineSuggestionsRequestInfo) args.arg1, [])    Expression((IInlineSuggestionsRequestCallback) args.arg2, [])  MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])])    VariableReference(args, [])    Expression(, [])  Statement(return, [])  Statement(}, [])  MethodCall(Log.w(TAG, ""Unhandled message code: "" + msg.what), [VariableReference(Log, []), Expression(TAG, []), Expression(""Unhandled message code: "" + msg.what, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Unhandled message code: "" + msg.what, [])  Statement(}, [])",1,,,0,"[@MainThread, @Override]","[@MainThread, @Override]",0,,,,2,5,0,"1,4","1,2",The implementation of the method `executeMessage(Message)` has changed in the late version. There are two main changes:,"2. The addition of the statement `info.makeCompatible(mTargetSdkVersion)` in the late version is an other statement change. It is being called before the method `inputMethod.dispatchStartInputWithToken(ic, info, moreArgs.argi1,[])`, which may affect the behavior of the method."
21,<android.text.style.StyleSpan: void updateMeasureState(TextPaint)>,31,32,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(apply(paint, mStyle), []), Statement(}, [])])  Statement({, [])  Statement(apply(paint, mStyle), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(apply(paint, mStyle, mFontWeightAdjustment), []), Statement(}, [])])  Statement({, [])  Statement(apply(paint, mStyle, mFontWeightAdjustment), [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,,2,5,0,4,0,"In the late version, the method call in the second statement of the method body has an additional argument ""mFontWeightAdjustment"" compared to the early version.","The change in the method call does not affect the return value or exception handling of the API, so there is no compatibility issue."
22,"<android.app.DisabledWallpaperManager: int setBitmap(Bitmap,Rect,boolean,int)>",31,32,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(return unsupported(), []), Statement(}, [])])  Statement({, [])  Statement(return unsupported(), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(unsupported(), []), Statement(return 0, []), Statement(}, [])])  Statement({, [])  Statement(unsupported(), [])  Statement(return 0, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,,1,"1,4",1,"1,4",1,"The early version implementation of the method contains a return statement with a call to the ""unsupported()"" method, while the late version implementation replaces this with a simple ""return 0"" statement. Additionally, there is an extra curly brace ""{}"" in the AST node representation of the early version that is not present in the late version.","The change in the return statement could potentially lead to compatibility issues. In the early version, the ""unsupported()"" method is called and its return value is used as the return value of the method. If any client code is relying on the specific behavior or return value of the ""unsupported()"" method, it could break when the method is updated to simply return 0 in the late version."
23,"<android.view.View: boolean startDragAndDrop(ClipData,DragShadowBuilder,Object,int)>",31,32,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(Log.d(VIEW_LOG_TAG, ""startDragAndDrop: data, []), Expression("" + data + "" flags, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mAttachInfo, []), Expression(, [])]), MethodCall(Log.w(VIEW_LOG_TAG, ""startDragAndDrop called on a detached view.""), [VariableReference(Log, []), Expression(VIEW_LOG_TAG, []), Expression(""startDragAndDrop called on a detached view."", [])]), Statement(return false, []), Statement(}, []), MethodCall(Log.w(VIEW_LOG_TAG, ""startDragAndDrop called with an invalid surface.""), [VariableReference(Log, []), Expression(VIEW_LOG_TAG, []), Expression(""startDragAndDrop called with an invalid surface."", [])]), Statement(return false, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (data !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(data.prepareToLeaveProcess((flags & View.DRAG_FLAG_GLOBAL) !, []), Expression(0), [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(Point shadowSize, []), Expression(new Point(), [])]), AssignmentExpression(=, [VariableReference(Point shadowTouchPoint, []), Expression(new Point(), [])]), MethodCall(shadowBuilder.onProvideShadowMetrics(shadowSize, shadowTouchPoint), [VariableReference(shadowBuilder, []), Expression(shadowSize, []), Expression(shadowTouchPoint, [])]), Statement(throw new IllegalStateException(""Drag shadow dimensions must not be negative""), []), Statement(}, []), Statement(// does not accept zero size surface., []), AssignmentExpression(=, [VariableReference(if (shadowSize.x, []), Expression(, [])]), Statement(if (!sAcceptZeroSizeDragShadow) {, []), Statement(throw new IllegalStateException(""Drag shadow dimensions must be positive""), []), Statement(}, []), AssignmentExpression(=, [VariableReference(shadowSize.x, []), Expression(1, [])]), AssignmentExpression(=, [VariableReference(shadowSize.y, []), Expression(1, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(Log.d(VIEW_LOG_TAG, ""drag shadow: width, []), Expression("" + shadowSize.x + "" height, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(final ViewRootImpl root, []), Expression(mAttachInfo.mViewRootImpl, [])]), AssignmentExpression(=, [VariableReference(final SurfaceSession session, []), Expression(new SurfaceSession(), [])]), AssignmentExpression(=, [VariableReference(final SurfaceControl surfaceControl, []), Expression(new SurfaceControl.Builder(session).setName(""drag surface"").setParent(root.getSurfaceControl()).setBufferSize(shadowSize.x, shadowSize.y).setFormat(PixelFormat.TRANSLUCENT).setCallsite(""View.startDragAndDrop"").build(), [])]), AssignmentExpression(=, [VariableReference(final Surface surface, []), Expression(new Surface(), [])]), MethodCall(surface.copyFrom(surfaceControl), [VariableReference(surface, []), Expression(surfaceControl, [])]), AssignmentExpression(=, [VariableReference(IBinder token, []), Expression(null, [])]), Statement(try {, []), AssignmentExpression(=, [VariableReference(final Canvas canvas, []), Expression(isHardwareAccelerated() ? surface.lockHardwareCanvas() : surface.lockCanvas(null), [])]), Statement(try {, []), MethodCall(canvas.drawColor(0, PorterDuff.Mode.CLEAR), [VariableReference(canvas, []), Expression(0, []), Expression(PorterDuff.Mode.CLEAR, [])]), MethodCall(shadowBuilder.onDrawShadow(canvas), [VariableReference(shadowBuilder, []), Expression(canvas, [])]), Statement(} finally {, []), MethodCall(surface.unlockCanvasAndPost(canvas), [VariableReference(surface, []), Expression(canvas, [])]), Statement(}, []), Statement(// repurpose 'shadowSize' for the last touch point, []), MethodCall(root.getLastTouchPoint(shadowSize), [VariableReference(root, []), Expression(shadowSize, [])]), AssignmentExpression(=, [VariableReference(token, []), Expression(mAttachInfo.mSession.performDrag(mAttachInfo.mWindow, flags, surfaceControl, root.getLastTouchSource(), shadowSize.x, shadowSize.y, shadowTouchPoint.x, shadowTouchPoint.y, data), [])]), MethodCall(Log.d(VIEW_LOG_TAG, ""performDrag returned "" + token), [VariableReference(Log, []), Expression(VIEW_LOG_TAG, []), Expression(""performDrag returned "" + token, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (token !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(if (mAttachInfo.mDragSurface !, []), Expression(null) {, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(mAttachInfo.mDragSurface, []), Expression(surface, [])]), AssignmentExpression(=, [VariableReference(mAttachInfo.mDragToken, []), Expression(token, [])]), Statement(// Cache the local state object for delivery with DragEvents, []), MethodCall(root.setLocalDragState(myLocalState), [VariableReference(root, []), Expression(myLocalState, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(return token !, []), Expression(null, [])]), Statement(} catch (Exception e) {, []), MethodCall(Log.e(VIEW_LOG_TAG, ""Unable to initiate drag"", e), [VariableReference(Log, []), Expression(VIEW_LOG_TAG, []), Expression(""Unable to initiate drag"", []), Expression(e, [])]), Statement(return false, []), Statement(} finally {, []), AssignmentExpression(=, [VariableReference(if (token, []), Expression(, [])]), MethodCall(surface.destroy(), [VariableReference(surface, []), Expression(, [])]), Statement(}, []), MethodCall(session.kill(), [VariableReference(session, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(Log.d(VIEW_LOG_TAG, ""startDragAndDrop: data, []), Expression("" + data + "" flags, [])])    VariableReference(Log.d(VIEW_LOG_TAG, ""startDragAndDrop: data, [])    Expression("" + data + "" flags, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mAttachInfo, []), Expression(, [])])    VariableReference(if (mAttachInfo, [])    Expression(, [])  MethodCall(Log.w(VIEW_LOG_TAG, ""startDragAndDrop called on a detached view.""), [VariableReference(Log, []), Expression(VIEW_LOG_TAG, []), Expression(""startDragAndDrop called on a detached view."", [])])    VariableReference(Log, [])    Expression(VIEW_LOG_TAG, [])    Expression(""startDragAndDrop called on a detached view."", [])  Statement(return false, [])  Statement(}, [])  MethodCall(Log.w(VIEW_LOG_TAG, ""startDragAndDrop called with an invalid surface.""), [VariableReference(Log, []), Expression(VIEW_LOG_TAG, []), Expression(""startDragAndDrop called with an invalid surface."", [])])    VariableReference(Log, [])    Expression(VIEW_LOG_TAG, [])    Expression(""startDragAndDrop called with an invalid surface."", [])  Statement(return false, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (data !, []), Expression(null) {, [])])    VariableReference(if (data !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(data.prepareToLeaveProcess((flags & View.DRAG_FLAG_GLOBAL) !, []), Expression(0), [])])    VariableReference(data.prepareToLeaveProcess((flags & View.DRAG_FLAG_GLOBAL) !, [])    Expression(0), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(Point shadowSize, []), Expression(new Point(), [])])    VariableReference(Point shadowSize, [])    Expression(new Point(), [])  AssignmentExpression(=, [VariableReference(Point shadowTouchPoint, []), Expression(new Point(), [])])    VariableReference(Point shadowTouchPoint, [])    Expression(new Point(), [])  MethodCall(shadowBuilder.onProvideShadowMetrics(shadowSize, shadowTouchPoint), [VariableReference(shadowBuilder, []), Expression(shadowSize, []), Expression(shadowTouchPoint, [])])    VariableReference(shadowBuilder, [])    Expression(shadowSize, [])    Expression(shadowTouchPoint, [])  Statement(throw new IllegalStateException(""Drag shadow dimensions must not be negative""), [])  Statement(}, [])  Statement(// does not accept zero size surface., [])  AssignmentExpression(=, [VariableReference(if (shadowSize.x, []), Expression(, [])])    VariableReference(if (shadowSize.x, [])    Expression(, [])  Statement(if (!sAcceptZeroSizeDragShadow) {, [])  Statement(throw new IllegalStateException(""Drag shadow dimensions must be positive""), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(shadowSize.x, []), Expression(1, [])])    VariableReference(shadowSize.x, [])    Expression(1, [])  AssignmentExpression(=, [VariableReference(shadowSize.y, []), Expression(1, [])])    VariableReference(shadowSize.y, [])    Expression(1, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(Log.d(VIEW_LOG_TAG, ""drag shadow: width, []), Expression("" + shadowSize.x + "" height, [])])    VariableReference(Log.d(VIEW_LOG_TAG, ""drag shadow: width, [])    Expression("" + shadowSize.x + "" height, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(final ViewRootImpl root, []), Expression(mAttachInfo.mViewRootImpl, [])])    VariableReference(final ViewRootImpl root, [])    Expression(mAttachInfo.mViewRootImpl, [])  AssignmentExpression(=, [VariableReference(final SurfaceSession session, []), Expression(new SurfaceSession(), [])])    VariableReference(final SurfaceSession session, [])    Expression(new SurfaceSession(), [])  AssignmentExpression(=, [VariableReference(final SurfaceControl surfaceControl, []), Expression(new SurfaceControl.Builder(session).setName(""drag surface"").setParent(root.getSurfaceControl()).setBufferSize(shadowSize.x, shadowSize.y).setFormat(PixelFormat.TRANSLUCENT).setCallsite(""View.startDragAndDrop"").build(), [])])    VariableReference(final SurfaceControl surfaceControl, [])    Expression(new SurfaceControl.Builder(session).setName(""drag surface"").setParent(root.getSurfaceControl()).setBufferSize(shadowSize.x, shadowSize.y).setFormat(PixelFormat.TRANSLUCENT).setCallsite(""View.startDragAndDrop"").build(), [])  AssignmentExpression(=, [VariableReference(final Surface surface, []), Expression(new Surface(), [])])    VariableReference(final Surface surface, [])    Expression(new Surface(), [])  MethodCall(surface.copyFrom(surfaceControl), [VariableReference(surface, []), Expression(surfaceControl, [])])    VariableReference(surface, [])    Expression(surfaceControl, [])  AssignmentExpression(=, [VariableReference(IBinder token, []), Expression(null, [])])    VariableReference(IBinder token, [])    Expression(null, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(final Canvas canvas, []), Expression(isHardwareAccelerated() ? surface.lockHardwareCanvas() : surface.lockCanvas(null), [])])    VariableReference(final Canvas canvas, [])    Expression(isHardwareAccelerated() ? surface.lockHardwareCanvas() : surface.lockCanvas(null), [])  Statement(try {, [])  MethodCall(canvas.drawColor(0, PorterDuff.Mode.CLEAR), [VariableReference(canvas, []), Expression(0, []), Expression(PorterDuff.Mode.CLEAR, [])])    VariableReference(canvas, [])    Expression(0, [])    Expression(PorterDuff.Mode.CLEAR, [])  MethodCall(shadowBuilder.onDrawShadow(canvas), [VariableReference(shadowBuilder, []), Expression(canvas, [])])    VariableReference(shadowBuilder, [])    Expression(canvas, [])  Statement(} finally {, [])  MethodCall(surface.unlockCanvasAndPost(canvas), [VariableReference(surface, []), Expression(canvas, [])])    VariableReference(surface, [])    Expression(canvas, [])  Statement(}, [])  Statement(// repurpose 'shadowSize' for the last touch point, [])  MethodCall(root.getLastTouchPoint(shadowSize), [VariableReference(root, []), Expression(shadowSize, [])])    VariableReference(root, [])    Expression(shadowSize, [])  AssignmentExpression(=, [VariableReference(token, []), Expression(mAttachInfo.mSession.performDrag(mAttachInfo.mWindow, flags, surfaceControl, root.getLastTouchSource(), shadowSize.x, shadowSize.y, shadowTouchPoint.x, shadowTouchPoint.y, data), [])])    VariableReference(token, [])    Expression(mAttachInfo.mSession.performDrag(mAttachInfo.mWindow, flags, surfaceControl, root.getLastTouchSource(), shadowSize.x, shadowSize.y, shadowTouchPoint.x, shadowTouchPoint.y, data), [])  MethodCall(Log.d(VIEW_LOG_TAG, ""performDrag returned "" + token), [VariableReference(Log, []), Expression(VIEW_LOG_TAG, []), Expression(""performDrag returned "" + token, [])])    VariableReference(Log, [])    Expression(VIEW_LOG_TAG, [])    Expression(""performDrag returned "" + token, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (token !, []), Expression(null) {, [])])    VariableReference(if (token !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(if (mAttachInfo.mDragSurface !, []), Expression(null) {, [])])    VariableReference(if (mAttachInfo.mDragSurface !, [])    Expression(null) {, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mAttachInfo.mDragSurface, []), Expression(surface, [])])    VariableReference(mAttachInfo.mDragSurface, [])    Expression(surface, [])  AssignmentExpression(=, [VariableReference(mAttachInfo.mDragToken, []), Expression(token, [])])    VariableReference(mAttachInfo.mDragToken, [])    Expression(token, [])  Statement(// Cache the local state object for delivery with DragEvents, [])  MethodCall(root.setLocalDragState(myLocalState), [VariableReference(root, []), Expression(myLocalState, [])])    VariableReference(root, [])    Expression(myLocalState, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(return token !, []), Expression(null, [])])    VariableReference(return token !, [])    Expression(null, [])  Statement(} catch (Exception e) {, [])  MethodCall(Log.e(VIEW_LOG_TAG, ""Unable to initiate drag"", e), [VariableReference(Log, []), Expression(VIEW_LOG_TAG, []), Expression(""Unable to initiate drag"", []), Expression(e, [])])    VariableReference(Log, [])    Expression(VIEW_LOG_TAG, [])    Expression(""Unable to initiate drag"", [])    Expression(e, [])  Statement(return false, [])  Statement(} finally {, [])  AssignmentExpression(=, [VariableReference(if (token, []), Expression(, [])])    VariableReference(if (token, [])    Expression(, [])  MethodCall(surface.destroy(), [VariableReference(surface, []), Expression(, [])])    VariableReference(surface, [])    Expression(, [])  Statement(}, [])  MethodCall(session.kill(), [VariableReference(session, []), Expression(, [])])    VariableReference(session, [])    Expression(, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(Log.d(VIEW_LOG_TAG, ""startDragAndDrop: data, []), Expression("" + data + "" flags, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mAttachInfo, []), Expression(, [])]), MethodCall(Log.w(VIEW_LOG_TAG, ""startDragAndDrop called on a detached view.""), [VariableReference(Log, []), Expression(VIEW_LOG_TAG, []), Expression(""startDragAndDrop called on a detached view."", [])]), Statement(return false, []), Statement(}, []), MethodCall(Log.w(VIEW_LOG_TAG, ""startDragAndDrop called with an invalid surface.""), [VariableReference(Log, []), Expression(VIEW_LOG_TAG, []), Expression(""startDragAndDrop called with an invalid surface."", [])]), Statement(return false, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (data !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(data.prepareToLeaveProcess((flags & View.DRAG_FLAG_GLOBAL) !, []), Expression(0), [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(Rect bounds, []), Expression(new Rect(), [])]), Statement(getBoundsOnScreen(bounds, true), []), AssignmentExpression(=, [VariableReference(Point lastTouchPoint, []), Expression(new Point(), [])]), AssignmentExpression(=, [VariableReference(final ViewRootImpl root, []), Expression(mAttachInfo.mViewRootImpl, [])]), Statement(// Skip surface logic since shadows and animation are not required during the a11y drag, []), AssignmentExpression(=, [VariableReference(final boolean a11yEnabled, []), Expression(AccessibilityManager.getInstance(mContext).isEnabled(), [])]), AssignmentExpression(=, [VariableReference(if (a11yEnabled && (flags & View.DRAG_FLAG_ACCESSIBILITY_ACTION) !, []), Expression(0) {, [])]), Statement(try {, []), AssignmentExpression(=, [VariableReference(IBinder token, []), Expression(mAttachInfo.mSession.performDrag(mAttachInfo.mWindow, flags, null, mAttachInfo.mViewRootImpl.getLastTouchSource(), 0f, 0f, 0f, 0f, data), [])]), MethodCall(Log.d(VIEW_LOG_TAG, ""startDragAndDrop via a11y action returned "" + token), [VariableReference(Log, []), Expression(VIEW_LOG_TAG, []), Expression(""startDragAndDrop via a11y action returned "" + token, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (token !, []), Expression(null) {, [])]), MethodCall(root.setLocalDragState(myLocalState), [VariableReference(root, []), Expression(myLocalState, [])]), AssignmentExpression(=, [VariableReference(mAttachInfo.mDragToken, []), Expression(token, [])]), Statement(setAccessibilityDragStarted(true), []), Statement(}, []), AssignmentExpression(=, [VariableReference(return token !, []), Expression(null, [])]), Statement(} catch (Exception e) {, []), MethodCall(Log.e(VIEW_LOG_TAG, ""Unable to initiate a11y drag"", e), [VariableReference(Log, []), Expression(VIEW_LOG_TAG, []), Expression(""Unable to initiate a11y drag"", []), Expression(e, [])]), Statement(return false, []), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(Point shadowSize, []), Expression(new Point(), [])]), AssignmentExpression(=, [VariableReference(Point shadowTouchPoint, []), Expression(new Point(), [])]), MethodCall(shadowBuilder.onProvideShadowMetrics(shadowSize, shadowTouchPoint), [VariableReference(shadowBuilder, []), Expression(shadowSize, []), Expression(shadowTouchPoint, [])]), Statement(throw new IllegalStateException(""Drag shadow dimensions must not be negative""), []), Statement(}, []), Statement(// does not accept zero size surface., []), AssignmentExpression(=, [VariableReference(if (shadowSize.x, []), Expression(, [])]), Statement(if (!sAcceptZeroSizeDragShadow) {, []), Statement(throw new IllegalStateException(""Drag shadow dimensions must be positive""), []), Statement(}, []), AssignmentExpression(=, [VariableReference(shadowSize.x, []), Expression(1, [])]), AssignmentExpression(=, [VariableReference(shadowSize.y, []), Expression(1, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(Log.d(VIEW_LOG_TAG, ""drag shadow: width, []), Expression("" + shadowSize.x + "" height, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(final SurfaceSession session, []), Expression(new SurfaceSession(), [])]), AssignmentExpression(=, [VariableReference(final SurfaceControl surfaceControl, []), Expression(new SurfaceControl.Builder(session).setName(""drag surface"").setParent(root.getSurfaceControl()).setBufferSize(shadowSize.x, shadowSize.y).setFormat(PixelFormat.TRANSLUCENT).setCallsite(""View.startDragAndDrop"").build(), [])]), AssignmentExpression(=, [VariableReference(final Surface surface, []), Expression(new Surface(), [])]), MethodCall(surface.copyFrom(surfaceControl), [VariableReference(surface, []), Expression(surfaceControl, [])]), AssignmentExpression(=, [VariableReference(IBinder token, []), Expression(null, [])]), Statement(try {, []), AssignmentExpression(=, [VariableReference(final Canvas canvas, []), Expression(isHardwareAccelerated() ? surface.lockHardwareCanvas() : surface.lockCanvas(null), [])]), Statement(try {, []), MethodCall(canvas.drawColor(0, PorterDuff.Mode.CLEAR), [VariableReference(canvas, []), Expression(0, []), Expression(PorterDuff.Mode.CLEAR, [])]), MethodCall(shadowBuilder.onDrawShadow(canvas), [VariableReference(shadowBuilder, []), Expression(canvas, [])]), Statement(} finally {, []), MethodCall(surface.unlockCanvasAndPost(canvas), [VariableReference(surface, []), Expression(canvas, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(token, []), Expression(mAttachInfo.mSession.performDrag(mAttachInfo.mWindow, flags, surfaceControl, root.getLastTouchSource(), lastTouchPoint.x, lastTouchPoint.y, shadowTouchPoint.x, shadowTouchPoint.y, data), [])]), MethodCall(Log.d(VIEW_LOG_TAG, ""performDrag returned "" + token), [VariableReference(Log, []), Expression(VIEW_LOG_TAG, []), Expression(""performDrag returned "" + token, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (token !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(if (mAttachInfo.mDragSurface !, []), Expression(null) {, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(mAttachInfo.mDragSurface, []), Expression(surface, [])]), AssignmentExpression(=, [VariableReference(mAttachInfo.mDragToken, []), Expression(token, [])]), Statement(// Cache the local state object for delivery with DragEvents, []), MethodCall(root.setLocalDragState(myLocalState), [VariableReference(root, []), Expression(myLocalState, [])]), Statement(if (a11yEnabled) {, []), Statement(// Set for AccessibilityEvents, []), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(return token !, []), Expression(null, [])]), Statement(} catch (Exception e) {, []), MethodCall(Log.e(VIEW_LOG_TAG, ""Unable to initiate drag"", e), [VariableReference(Log, []), Expression(VIEW_LOG_TAG, []), Expression(""Unable to initiate drag"", []), Expression(e, [])]), Statement(return false, []), Statement(} finally {, []), AssignmentExpression(=, [VariableReference(if (token, []), Expression(, [])]), MethodCall(surface.destroy(), [VariableReference(surface, []), Expression(, [])]), Statement(}, []), MethodCall(session.kill(), [VariableReference(session, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(Log.d(VIEW_LOG_TAG, ""startDragAndDrop: data, []), Expression("" + data + "" flags, [])])    VariableReference(Log.d(VIEW_LOG_TAG, ""startDragAndDrop: data, [])    Expression("" + data + "" flags, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mAttachInfo, []), Expression(, [])])    VariableReference(if (mAttachInfo, [])    Expression(, [])  MethodCall(Log.w(VIEW_LOG_TAG, ""startDragAndDrop called on a detached view.""), [VariableReference(Log, []), Expression(VIEW_LOG_TAG, []), Expression(""startDragAndDrop called on a detached view."", [])])    VariableReference(Log, [])    Expression(VIEW_LOG_TAG, [])    Expression(""startDragAndDrop called on a detached view."", [])  Statement(return false, [])  Statement(}, [])  MethodCall(Log.w(VIEW_LOG_TAG, ""startDragAndDrop called with an invalid surface.""), [VariableReference(Log, []), Expression(VIEW_LOG_TAG, []), Expression(""startDragAndDrop called with an invalid surface."", [])])    VariableReference(Log, [])    Expression(VIEW_LOG_TAG, [])    Expression(""startDragAndDrop called with an invalid surface."", [])  Statement(return false, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (data !, []), Expression(null) {, [])])    VariableReference(if (data !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(data.prepareToLeaveProcess((flags & View.DRAG_FLAG_GLOBAL) !, []), Expression(0), [])])    VariableReference(data.prepareToLeaveProcess((flags & View.DRAG_FLAG_GLOBAL) !, [])    Expression(0), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(Rect bounds, []), Expression(new Rect(), [])])    VariableReference(Rect bounds, [])    Expression(new Rect(), [])  Statement(getBoundsOnScreen(bounds, true), [])  AssignmentExpression(=, [VariableReference(Point lastTouchPoint, []), Expression(new Point(), [])])    VariableReference(Point lastTouchPoint, [])    Expression(new Point(), [])  AssignmentExpression(=, [VariableReference(final ViewRootImpl root, []), Expression(mAttachInfo.mViewRootImpl, [])])    VariableReference(final ViewRootImpl root, [])    Expression(mAttachInfo.mViewRootImpl, [])  Statement(// Skip surface logic since shadows and animation are not required during the a11y drag, [])  AssignmentExpression(=, [VariableReference(final boolean a11yEnabled, []), Expression(AccessibilityManager.getInstance(mContext).isEnabled(), [])])    VariableReference(final boolean a11yEnabled, [])    Expression(AccessibilityManager.getInstance(mContext).isEnabled(), [])  AssignmentExpression(=, [VariableReference(if (a11yEnabled && (flags & View.DRAG_FLAG_ACCESSIBILITY_ACTION) !, []), Expression(0) {, [])])    VariableReference(if (a11yEnabled && (flags & View.DRAG_FLAG_ACCESSIBILITY_ACTION) !, [])    Expression(0) {, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(IBinder token, []), Expression(mAttachInfo.mSession.performDrag(mAttachInfo.mWindow, flags, null, mAttachInfo.mViewRootImpl.getLastTouchSource(), 0f, 0f, 0f, 0f, data), [])])    VariableReference(IBinder token, [])    Expression(mAttachInfo.mSession.performDrag(mAttachInfo.mWindow, flags, null, mAttachInfo.mViewRootImpl.getLastTouchSource(), 0f, 0f, 0f, 0f, data), [])  MethodCall(Log.d(VIEW_LOG_TAG, ""startDragAndDrop via a11y action returned "" + token), [VariableReference(Log, []), Expression(VIEW_LOG_TAG, []), Expression(""startDragAndDrop via a11y action returned "" + token, [])])    VariableReference(Log, [])    Expression(VIEW_LOG_TAG, [])    Expression(""startDragAndDrop via a11y action returned "" + token, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (token !, []), Expression(null) {, [])])    VariableReference(if (token !, [])    Expression(null) {, [])  MethodCall(root.setLocalDragState(myLocalState), [VariableReference(root, []), Expression(myLocalState, [])])    VariableReference(root, [])    Expression(myLocalState, [])  AssignmentExpression(=, [VariableReference(mAttachInfo.mDragToken, []), Expression(token, [])])    VariableReference(mAttachInfo.mDragToken, [])    Expression(token, [])  Statement(setAccessibilityDragStarted(true), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(return token !, []), Expression(null, [])])    VariableReference(return token !, [])    Expression(null, [])  Statement(} catch (Exception e) {, [])  MethodCall(Log.e(VIEW_LOG_TAG, ""Unable to initiate a11y drag"", e), [VariableReference(Log, []), Expression(VIEW_LOG_TAG, []), Expression(""Unable to initiate a11y drag"", []), Expression(e, [])])    VariableReference(Log, [])    Expression(VIEW_LOG_TAG, [])    Expression(""Unable to initiate a11y drag"", [])    Expression(e, [])  Statement(return false, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(Point shadowSize, []), Expression(new Point(), [])])    VariableReference(Point shadowSize, [])    Expression(new Point(), [])  AssignmentExpression(=, [VariableReference(Point shadowTouchPoint, []), Expression(new Point(), [])])    VariableReference(Point shadowTouchPoint, [])    Expression(new Point(), [])  MethodCall(shadowBuilder.onProvideShadowMetrics(shadowSize, shadowTouchPoint), [VariableReference(shadowBuilder, []), Expression(shadowSize, []), Expression(shadowTouchPoint, [])])    VariableReference(shadowBuilder, [])    Expression(shadowSize, [])    Expression(shadowTouchPoint, [])  Statement(throw new IllegalStateException(""Drag shadow dimensions must not be negative""), [])  Statement(}, [])  Statement(// does not accept zero size surface., [])  AssignmentExpression(=, [VariableReference(if (shadowSize.x, []), Expression(, [])])    VariableReference(if (shadowSize.x, [])    Expression(, [])  Statement(if (!sAcceptZeroSizeDragShadow) {, [])  Statement(throw new IllegalStateException(""Drag shadow dimensions must be positive""), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(shadowSize.x, []), Expression(1, [])])    VariableReference(shadowSize.x, [])    Expression(1, [])  AssignmentExpression(=, [VariableReference(shadowSize.y, []), Expression(1, [])])    VariableReference(shadowSize.y, [])    Expression(1, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(Log.d(VIEW_LOG_TAG, ""drag shadow: width, []), Expression("" + shadowSize.x + "" height, [])])    VariableReference(Log.d(VIEW_LOG_TAG, ""drag shadow: width, [])    Expression("" + shadowSize.x + "" height, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(final SurfaceSession session, []), Expression(new SurfaceSession(), [])])    VariableReference(final SurfaceSession session, [])    Expression(new SurfaceSession(), [])  AssignmentExpression(=, [VariableReference(final SurfaceControl surfaceControl, []), Expression(new SurfaceControl.Builder(session).setName(""drag surface"").setParent(root.getSurfaceControl()).setBufferSize(shadowSize.x, shadowSize.y).setFormat(PixelFormat.TRANSLUCENT).setCallsite(""View.startDragAndDrop"").build(), [])])    VariableReference(final SurfaceControl surfaceControl, [])    Expression(new SurfaceControl.Builder(session).setName(""drag surface"").setParent(root.getSurfaceControl()).setBufferSize(shadowSize.x, shadowSize.y).setFormat(PixelFormat.TRANSLUCENT).setCallsite(""View.startDragAndDrop"").build(), [])  AssignmentExpression(=, [VariableReference(final Surface surface, []), Expression(new Surface(), [])])    VariableReference(final Surface surface, [])    Expression(new Surface(), [])  MethodCall(surface.copyFrom(surfaceControl), [VariableReference(surface, []), Expression(surfaceControl, [])])    VariableReference(surface, [])    Expression(surfaceControl, [])  AssignmentExpression(=, [VariableReference(IBinder token, []), Expression(null, [])])    VariableReference(IBinder token, [])    Expression(null, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(final Canvas canvas, []), Expression(isHardwareAccelerated() ? surface.lockHardwareCanvas() : surface.lockCanvas(null), [])])    VariableReference(final Canvas canvas, [])    Expression(isHardwareAccelerated() ? surface.lockHardwareCanvas() : surface.lockCanvas(null), [])  Statement(try {, [])  MethodCall(canvas.drawColor(0, PorterDuff.Mode.CLEAR), [VariableReference(canvas, []), Expression(0, []), Expression(PorterDuff.Mode.CLEAR, [])])    VariableReference(canvas, [])    Expression(0, [])    Expression(PorterDuff.Mode.CLEAR, [])  MethodCall(shadowBuilder.onDrawShadow(canvas), [VariableReference(shadowBuilder, []), Expression(canvas, [])])    VariableReference(shadowBuilder, [])    Expression(canvas, [])  Statement(} finally {, [])  MethodCall(surface.unlockCanvasAndPost(canvas), [VariableReference(surface, []), Expression(canvas, [])])    VariableReference(surface, [])    Expression(canvas, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(token, []), Expression(mAttachInfo.mSession.performDrag(mAttachInfo.mWindow, flags, surfaceControl, root.getLastTouchSource(), lastTouchPoint.x, lastTouchPoint.y, shadowTouchPoint.x, shadowTouchPoint.y, data), [])])    VariableReference(token, [])    Expression(mAttachInfo.mSession.performDrag(mAttachInfo.mWindow, flags, surfaceControl, root.getLastTouchSource(), lastTouchPoint.x, lastTouchPoint.y, shadowTouchPoint.x, shadowTouchPoint.y, data), [])  MethodCall(Log.d(VIEW_LOG_TAG, ""performDrag returned "" + token), [VariableReference(Log, []), Expression(VIEW_LOG_TAG, []), Expression(""performDrag returned "" + token, [])])    VariableReference(Log, [])    Expression(VIEW_LOG_TAG, [])    Expression(""performDrag returned "" + token, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (token !, []), Expression(null) {, [])])    VariableReference(if (token !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(if (mAttachInfo.mDragSurface !, []), Expression(null) {, [])])    VariableReference(if (mAttachInfo.mDragSurface !, [])    Expression(null) {, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mAttachInfo.mDragSurface, []), Expression(surface, [])])    VariableReference(mAttachInfo.mDragSurface, [])    Expression(surface, [])  AssignmentExpression(=, [VariableReference(mAttachInfo.mDragToken, []), Expression(token, [])])    VariableReference(mAttachInfo.mDragToken, [])    Expression(token, [])  Statement(// Cache the local state object for delivery with DragEvents, [])  MethodCall(root.setLocalDragState(myLocalState), [VariableReference(root, []), Expression(myLocalState, [])])    VariableReference(root, [])    Expression(myLocalState, [])  Statement(if (a11yEnabled) {, [])  Statement(// Set for AccessibilityEvents, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(return token !, []), Expression(null, [])])    VariableReference(return token !, [])    Expression(null, [])  Statement(} catch (Exception e) {, [])  MethodCall(Log.e(VIEW_LOG_TAG, ""Unable to initiate drag"", e), [VariableReference(Log, []), Expression(VIEW_LOG_TAG, []), Expression(""Unable to initiate drag"", []), Expression(e, [])])    VariableReference(Log, [])    Expression(VIEW_LOG_TAG, [])    Expression(""Unable to initiate drag"", [])    Expression(e, [])  Statement(return false, [])  Statement(} finally {, [])  AssignmentExpression(=, [VariableReference(if (token, []), Expression(, [])])    VariableReference(if (token, [])    Expression(, [])  MethodCall(surface.destroy(), [VariableReference(surface, []), Expression(, [])])    VariableReference(surface, [])    Expression(, [])  Statement(}, [])  MethodCall(session.kill(), [VariableReference(session, []), Expression(, [])])    VariableReference(session, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Starts a drag and drop operation. When your application calls this method, it passes a
 * {@link android.view.View.DragShadowBuilder} object to the system. The
 * system calls this object's {@link DragShadowBuilder#onProvideShadowMetrics(Point, Point)}
 * to get metrics for the drag shadow, and then calls the object's
 * {@link DragShadowBuilder#onDrawShadow(Canvas)} to draw the drag shadow itself.
 * <p>
 * Once the system has the drag shadow, it begins the drag and drop operation by sending
 * drag events to all the View objects in your application that are currently visible. It does
 * this either by calling the View object's drag listener (an implementation of
 * {@link android.view.View.OnDragListener#onDrag(View,DragEvent) onDrag()} or by calling the
 * View object's {@link android.view.View#onDragEvent(DragEvent) onDragEvent()} method.
 * Both are passed a {@link android.view.DragEvent} object that has a
 * {@link android.view.DragEvent#getAction()} value of
 * {@link android.view.DragEvent#ACTION_DRAG_STARTED}.
 * </p>
 * <p>
 * Your application can invoke {@link #startDragAndDrop(ClipData, DragShadowBuilder, Object,
 * int) startDragAndDrop()} on any attached View object. The View object does not need to be
 * the one used in {@link android.view.View.DragShadowBuilder}, nor does it need to be related
 * to the View the user selected for dragging.
 * </p>
 * @param data A {@link android.content.ClipData} object pointing to the data to be
 * transferred by the drag and drop operation.
 * @param shadowBuilder A {@link android.view.View.DragShadowBuilder} object for building the
 * drag shadow.
 * @param myLocalState An {@link java.lang.Object} containing local data about the drag and
 * drop operation. When dispatching drag events to views in the same activity this object
 * will be available through {@link android.view.DragEvent#getLocalState()}. Views in other
 * activities will not have access to this data ({@link android.view.DragEvent#getLocalState()}
 * will return null).
 * <p>
 * myLocalState is a lightweight mechanism for the sending information from the dragged View
 * to the target Views. For example, it can contain flags that differentiate between a
 * a copy operation and a move operation.
 * </p>
 * @param flags Flags that control the drag and drop operation. This can be set to 0 for no
 * flags, or any combination of the following:
 * <ul>
 * <li>{@link #DRAG_FLAG_GLOBAL}</li>
 * <li>{@link #DRAG_FLAG_GLOBAL_PERSISTABLE_URI_PERMISSION}</li>
 * <li>{@link #DRAG_FLAG_GLOBAL_PREFIX_URI_PERMISSION}</li>
 * <li>{@link #DRAG_FLAG_GLOBAL_URI_READ}</li>
 * <li>{@link #DRAG_FLAG_GLOBAL_URI_WRITE}</li>
 * <li>{@link #DRAG_FLAG_OPAQUE}</li>
 * </ul>
 * @return {@code true} if the method completes successfully, or
 * {@code false} if it fails anywhere. Returning {@code false} means the system was unable to
 * do a drag because of another ongoing operation or some other reasons.
 */
","/**
 * Starts a drag and drop operation. When your application calls this method, it passes a
 * {@link android.view.View.DragShadowBuilder} object to the system. The
 * system calls this object's {@link DragShadowBuilder#onProvideShadowMetrics(Point, Point)}
 * to get metrics for the drag shadow, and then calls the object's
 * {@link DragShadowBuilder#onDrawShadow(Canvas)} to draw the drag shadow itself.
 * <p>
 * Once the system has the drag shadow, it begins the drag and drop operation by sending
 * drag events to all the View objects in your application that are currently visible. It does
 * this either by calling the View object's drag listener (an implementation of
 * {@link android.view.View.OnDragListener#onDrag(View,DragEvent) onDrag()} or by calling the
 * View object's {@link android.view.View#onDragEvent(DragEvent) onDragEvent()} method.
 * Both are passed a {@link android.view.DragEvent} object that has a
 * {@link android.view.DragEvent#getAction()} value of
 * {@link android.view.DragEvent#ACTION_DRAG_STARTED}.
 * </p>
 * <p>
 * Your application can invoke {@link #startDragAndDrop(ClipData, DragShadowBuilder, Object,
 * int) startDragAndDrop()} on any attached View object. The View object does not need to be
 * the one used in {@link android.view.View.DragShadowBuilder}, nor does it need to be related
 * to the View the user selected for dragging.
 * </p>
 * @param data A {@link android.content.ClipData} object pointing to the data to be
 * transferred by the drag and drop operation.
 * @param shadowBuilder A {@link android.view.View.DragShadowBuilder} object for building the
 * drag shadow.
 * @param myLocalState An {@link java.lang.Object} containing local data about the drag and
 * drop operation. When dispatching drag events to views in the same activity this object
 * will be available through {@link android.view.DragEvent#getLocalState()}. Views in other
 * activities will not have access to this data ({@link android.view.DragEvent#getLocalState()}
 * will return null).
 * <p>
 * myLocalState is a lightweight mechanism for the sending information from the dragged View
 * to the target Views. For example, it can contain flags that differentiate between a
 * a copy operation and a move operation.
 * </p>
 * @param flags Flags that control the drag and drop operation. This can be set to 0 for no
 * flags, or any combination of the following:
 * <ul>
 * <li>{@link #DRAG_FLAG_GLOBAL}</li>
 * <li>{@link #DRAG_FLAG_GLOBAL_PERSISTABLE_URI_PERMISSION}</li>
 * <li>{@link #DRAG_FLAG_GLOBAL_PREFIX_URI_PERMISSION}</li>
 * <li>{@link #DRAG_FLAG_GLOBAL_URI_READ}</li>
 * <li>{@link #DRAG_FLAG_GLOBAL_URI_WRITE}</li>
 * <li>{@link #DRAG_FLAG_OPAQUE}</li>
 * <li>{@link #DRAG_FLAG_ACCESSIBILITY_ACTION}</li>
 * </ul>
 * @return {@code true} if the method completes successfully, or
 * {@code false} if it fails anywhere. Returning {@code false} means the system was unable to
 * do a drag because of another ongoing operation or some other reasons.
 */
",1,,,0,,,,"1,2","1,2,3,4,5","1,2","2,4","1,2","* Change type 4 (Other statement changed): There are several new or modified statements in the late implementation that do not belong to the other change types. For example, the addition of the `Rect bounds` and `Point lastTouchPoint` variables, the modification of the `mAttachInfo.mSession.performDrag` method call, and the addition of the `setAccessibilityDragStarted(true)` statement.","* Compatibility issue type 2 (Compatibility Issue caused by potential different exception handlings): The changes in the `mAttachInfo.mSession.performDrag` method call could potentially lead to different exceptions being thrown in the late version of the API, which may not be handled properly by the calling code."
24,"<android.content.Context: int[] checkUriPermissions(List<Uri>,int,int,int)>",31,32,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(}, [])])  Statement({, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(}, [])])  Statement({, [])  Statement(}, [])",0,"/**
 * Determine whether a particular process and user ID has been granted
 * permission to access a list of URIs.  This only checks for permissions
 * that have been explicitly granted -- if the given process/uid has
 * more general access to the URI's content provider then this check will
 * always fail.
 *
 * @param uris The list of URIs that is being checked.
 * @param pid The process ID being checked against.  Must be &gt; 0.
 * @param uid The user ID being checked against.  A uid of 0 is the root
 * user, which will pass every permission check.
 * @param modeFlags The access modes to check for the list of uris
 *
 * @return Array of permission grants corresponding to each entry in the list of uris.
 * {@link PackageManager#PERMISSION_GRANTED} if the given pid/uid is allowed to access that uri,
 * or {@link PackageManager#PERMISSION_DENIED} if it is not.
 *
 * @see #checkCallingUriPermission
 */
","/**
 * Determine whether a particular process and user ID has been granted
 * permission to access a list of URIs.  This only checks for permissions
 * that have been explicitly granted -- if the given process/uid has
 * more general access to the URI's content provider then this check will
 * always fail.
 *
 * <strong>Note:</strong> On SDK Version {@link android.os.Build.VERSION_CODES#S},
 * calling this method from a secondary-user's context will incorrectly return
 * {@link PackageManager#PERMISSION_DENIED} for all {code uris}.
 *
 * @param uris The list of URIs that is being checked.
 * @param pid The process ID being checked against.  Must be &gt; 0.
 * @param uid The user ID being checked against.  A uid of 0 is the root
 * user, which will pass every permission check.
 * @param modeFlags The access modes to check for the list of uris
 *
 * @return Array of permission grants corresponding to each entry in the list of uris.
 * {@link PackageManager#PERMISSION_GRANTED} if the given pid/uid is allowed to access that uri,
 * or {@link PackageManager#PERMISSION_DENIED} if it is not.
 *
 * @see #checkCallingUriPermission
 */
",1,"[@NonNull, @PackageManager.PermissionResult]","[@NonNull, @PackageManager.PermissionResult]",0,,,,0,0,0,0,0,change\_description: There are no changes in the method implementation between the early version and the late version.,* pred\_change: 0) No change
25,<android.content.res.TypedArray: ColorStateList getColorStateList(int)>,32,33,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(if (mRecycled) {, []), Statement(throw new RuntimeException(""Cannot make calls to a recycled instance!""), []), Statement(}, []), AssignmentExpression(=, [VariableReference(final TypedValue value, []), Expression(mValue, [])]), Statement(if (getValueAt(index * STYLE_NUM_ENTRIES, value)) {, []), AssignmentExpression(=, [VariableReference(if (value.type, []), Expression(, [])]), Statement(throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + index + "": "" + value), []), Statement(}, []), MethodCall(return mResources.loadColorStateList(value, value.resourceId, mTheme), [VariableReference(return mResources, []), Expression(value, []), Expression(value.resourceId, []), Expression(mTheme, [])]), Statement(}, []), Statement(return null, []), Statement(}, [])])  Statement({, [])  Statement(if (mRecycled) {, [])  Statement(throw new RuntimeException(""Cannot make calls to a recycled instance!""), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(final TypedValue value, []), Expression(mValue, [])])    VariableReference(final TypedValue value, [])    Expression(mValue, [])  Statement(if (getValueAt(index * STYLE_NUM_ENTRIES, value)) {, [])  AssignmentExpression(=, [VariableReference(if (value.type, []), Expression(, [])])    VariableReference(if (value.type, [])    Expression(, [])  Statement(throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + index + "": "" + value), [])  Statement(}, [])  MethodCall(return mResources.loadColorStateList(value, value.resourceId, mTheme), [VariableReference(return mResources, []), Expression(value, []), Expression(value.resourceId, []), Expression(mTheme, [])])    VariableReference(return mResources, [])    Expression(value, [])    Expression(value.resourceId, [])    Expression(mTheme, [])  Statement(}, [])  Statement(return null, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (mRecycled) {, []), Statement(throw new RuntimeException(""Cannot make calls to a recycled instance!""), []), Statement(}, []), AssignmentExpression(=, [VariableReference(final TypedValue value, []), Expression(mValue, [])]), Statement(if (getValueAt(index * STYLE_NUM_ENTRIES, value)) {, []), AssignmentExpression(=, [VariableReference(if (value.type, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + index + "": "" + value + "", theme, []), Expression("" + mTheme), [])]), Statement(}, []), MethodCall(return mResources.loadColorStateList(value, value.resourceId, mTheme), [VariableReference(return mResources, []), Expression(value, []), Expression(value.resourceId, []), Expression(mTheme, [])]), Statement(}, []), Statement(return null, []), Statement(}, [])])  Statement({, [])  Statement(if (mRecycled) {, [])  Statement(throw new RuntimeException(""Cannot make calls to a recycled instance!""), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(final TypedValue value, []), Expression(mValue, [])])    VariableReference(final TypedValue value, [])    Expression(mValue, [])  Statement(if (getValueAt(index * STYLE_NUM_ENTRIES, value)) {, [])  AssignmentExpression(=, [VariableReference(if (value.type, []), Expression(, [])])    VariableReference(if (value.type, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + index + "": "" + value + "", theme, []), Expression("" + mTheme), [])])    VariableReference(throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + index + "": "" + value + "", theme, [])    Expression("" + mTheme), [])  Statement(}, [])  MethodCall(return mResources.loadColorStateList(value, value.resourceId, mTheme), [VariableReference(return mResources, []), Expression(value, []), Expression(value.resourceId, []), Expression(mTheme, [])])    VariableReference(return mResources, [])    Expression(value, [])    Expression(value.resourceId, [])    Expression(mTheme, [])  Statement(}, [])  Statement(return null, [])  Statement(}, [])",1,"/**
 * Retrieve the ColorStateList for the attribute at <var>index</var>.
 * The value may be either a single solid color or a reference to
 * a color or complex {@link android.content.res.ColorStateList}
 * description.
 * <p>
 * This method will return {@code null} if the attribute is not defined or
 * is not an integer color or color state list.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return ColorStateList for the attribute, or {@code null} if not
 * defined.
 * @throws RuntimeException if the attribute if the TypedArray has already
 * been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not an integer color or color state list.
 */
","/**
 * Retrieve the ColorStateList for the attribute at <var>index</var>.
 * The value may be either a single solid color or a reference to
 * a color or complex {@link android.content.res.ColorStateList}
 * description.
 * <p>
 * This method will return {@code null} if the attribute is not defined or
 * is not an integer color or color state list.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return ColorStateList for the attribute, or {@code null} if not
 * defined.
 * @throws RuntimeException if the attribute if the TypedArray has already
 * been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not an integer color or color state list.
 */
",0,[@Nullable],[@Nullable],0,,,,2,5,0,"2,3","1,2",The code change between the two versions is as follows:,
26,<android.app.admin.DevicePolicyManager: int logoutUser(ComponentName)>,32,33,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(throwIfParentInstance(""logoutUser""), []), Statement(try {, []), MethodCall(return mService.logoutUser(admin), [VariableReference(return mService, []), Expression(admin, [])]), Statement(} catch (RemoteException re) {, []), MethodCall(throw re.rethrowFromSystemServer(), [VariableReference(throw re, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(throwIfParentInstance(""logoutUser""), [])  Statement(try {, [])  MethodCall(return mService.logoutUser(admin), [VariableReference(return mService, []), Expression(admin, [])])    VariableReference(return mService, [])    Expression(admin, [])  Statement(} catch (RemoteException re) {, [])  MethodCall(throw re.rethrowFromSystemServer(), [VariableReference(throw re, []), Expression(, [])])    VariableReference(throw re, [])    Expression(, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(throwIfParentInstance(""logoutUser""), []), Statement(try {, []), MethodCall(return mService.logoutUser(admin), [VariableReference(return mService, []), Expression(admin, [])]), Statement(} catch (RemoteException re) {, []), MethodCall(throw re.rethrowFromSystemServer(), [VariableReference(throw re, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(throwIfParentInstance(""logoutUser""), [])  Statement(try {, [])  MethodCall(return mService.logoutUser(admin), [VariableReference(return mService, []), Expression(admin, [])])    VariableReference(return mService, [])    Expression(admin, [])  Statement(} catch (RemoteException re) {, [])  MethodCall(throw re.rethrowFromSystemServer(), [VariableReference(throw re, []), Expression(, [])])    VariableReference(throw re, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",0,"/**
 * Called by a profile owner of secondary user that is affiliated with the device to stop the
 * calling user and switch back to primary user.
 *
 * <p>Notice that on devices running with
 * {@link UserManager#isHeadlessSystemUserMode() headless system user mode}, there is no primary
 * user, so it switches back to the user that was in the foreground before the first call to
 * {@link #switchUser(ComponentName, UserHandle)} (or fails with
 * {@link UserManager#USER_OPERATION_ERROR_UNKNOWN} if that method was not called prior to this
 * call).
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @return one of the following result codes:
 * {@link UserManager#USER_OPERATION_ERROR_UNKNOWN},
 * {@link UserManager#USER_OPERATION_SUCCESS},
 * {@link UserManager#USER_OPERATION_ERROR_MANAGED_PROFILE},
 * {@link UserManager#USER_OPERATION_ERROR_CURRENT_USER}
 * @throws SecurityException if {@code admin} is not a profile owner affiliated with the device.
 * @see #getSecondaryUsers(ComponentName)
 */
","/**
 * Called by a profile owner of secondary user that is affiliated with the device to stop the
 * calling user and switch back to primary user (when the user was
 * {@link #switchUser(ComponentName, UserHandle)} switched to) or stop the user (when it was
 * {@link #startUserInBackground(ComponentName, UserHandle) started in background}.
 *
 * <p>Notice that on devices running with
 * {@link UserManager#isHeadlessSystemUserMode() headless system user mode}, there is no primary
 * user, so it switches back to the user that was in the foreground before the first call to
 * {@link #switchUser(ComponentName, UserHandle)} (or fails with
 * {@link UserManager#USER_OPERATION_ERROR_UNKNOWN} if that method was not called prior to this
 * call).
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @return one of the following result codes:
 * {@link UserManager#USER_OPERATION_ERROR_UNKNOWN},
 * {@link UserManager#USER_OPERATION_SUCCESS},
 * {@link UserManager#USER_OPERATION_ERROR_MANAGED_PROFILE},
 * {@link UserManager#USER_OPERATION_ERROR_CURRENT_USER}
 * @throws SecurityException if {@code admin} is not a profile owner affiliated with the device.
 * @see #getSecondaryUsers(ComponentName)
 */
",1,[@UserOperationResult],[@UserOperationResult],0,,,,0,0,0,0,0,"There is no change in the implementation, comment and annotation between the two versions.","As there is no change in the implementation, comment and annotation between the two versions, the API will behave the same and there is no Compatibility Issue."
27,"<android.view.contentcapture.DataRemovalRequest.Builder: Builder addLocusId(LocusId,int)>",32,33,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(throwIfDestroyed(), []), MethodCall(Preconditions.checkState(!mForEverything, ""Already is for everything""), [VariableReference(Preconditions, []), Expression(!mForEverything, []), Expression(""Already is for everything"", [])]), MethodCall(Preconditions.checkNotNull(locusId), [VariableReference(Preconditions, []), Expression(locusId, [])]), AssignmentExpression(=, [VariableReference(if (mLocusIds, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(mLocusIds, []), Expression(new ArrayList<>(), [])]), AssignmentExpression(=, [VariableReference(mFlags, []), Expression(new IntArray(), [])]), Statement(}, []), MethodCall(mLocusIds.add(locusId), [VariableReference(mLocusIds, []), Expression(locusId, [])]), MethodCall(mFlags.add(flags), [VariableReference(mFlags, []), Expression(flags, [])]), Statement(return this, []), Statement(}, [])])  Statement({, [])  Statement(throwIfDestroyed(), [])  MethodCall(Preconditions.checkState(!mForEverything, ""Already is for everything""), [VariableReference(Preconditions, []), Expression(!mForEverything, []), Expression(""Already is for everything"", [])])    VariableReference(Preconditions, [])    Expression(!mForEverything, [])    Expression(""Already is for everything"", [])  MethodCall(Preconditions.checkNotNull(locusId), [VariableReference(Preconditions, []), Expression(locusId, [])])    VariableReference(Preconditions, [])    Expression(locusId, [])  AssignmentExpression(=, [VariableReference(if (mLocusIds, []), Expression(, [])])    VariableReference(if (mLocusIds, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(mLocusIds, []), Expression(new ArrayList<>(), [])])    VariableReference(mLocusIds, [])    Expression(new ArrayList<>(), [])  AssignmentExpression(=, [VariableReference(mFlags, []), Expression(new IntArray(), [])])    VariableReference(mFlags, [])    Expression(new IntArray(), [])  Statement(}, [])  MethodCall(mLocusIds.add(locusId), [VariableReference(mLocusIds, []), Expression(locusId, [])])    VariableReference(mLocusIds, [])    Expression(locusId, [])  MethodCall(mFlags.add(flags), [VariableReference(mFlags, []), Expression(flags, [])])    VariableReference(mFlags, [])    Expression(flags, [])  Statement(return this, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(throwIfDestroyed(), []), MethodCall(Preconditions.checkState(!mForEverything, ""Already is for everything""), [VariableReference(Preconditions, []), Expression(!mForEverything, []), Expression(""Already is for everything"", [])]), MethodCall(Objects.requireNonNull(locusId), [VariableReference(Objects, []), Expression(locusId, [])]), AssignmentExpression(=, [VariableReference(if (mLocusIds, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(mLocusIds, []), Expression(new ArrayList<>(), [])]), AssignmentExpression(=, [VariableReference(mFlags, []), Expression(new IntArray(), [])]), Statement(}, []), MethodCall(mLocusIds.add(locusId), [VariableReference(mLocusIds, []), Expression(locusId, [])]), MethodCall(mFlags.add(flags), [VariableReference(mFlags, []), Expression(flags, [])]), Statement(return this, []), Statement(}, [])])  Statement({, [])  Statement(throwIfDestroyed(), [])  MethodCall(Preconditions.checkState(!mForEverything, ""Already is for everything""), [VariableReference(Preconditions, []), Expression(!mForEverything, []), Expression(""Already is for everything"", [])])    VariableReference(Preconditions, [])    Expression(!mForEverything, [])    Expression(""Already is for everything"", [])  MethodCall(Objects.requireNonNull(locusId), [VariableReference(Objects, []), Expression(locusId, [])])    VariableReference(Objects, [])    Expression(locusId, [])  AssignmentExpression(=, [VariableReference(if (mLocusIds, []), Expression(, [])])    VariableReference(if (mLocusIds, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(mLocusIds, []), Expression(new ArrayList<>(), [])])    VariableReference(mLocusIds, [])    Expression(new ArrayList<>(), [])  AssignmentExpression(=, [VariableReference(mFlags, []), Expression(new IntArray(), [])])    VariableReference(mFlags, [])    Expression(new IntArray(), [])  Statement(}, [])  MethodCall(mLocusIds.add(locusId), [VariableReference(mLocusIds, []), Expression(locusId, [])])    VariableReference(mLocusIds, [])    Expression(locusId, [])  MethodCall(mFlags.add(flags), [VariableReference(mFlags, []), Expression(flags, [])])    VariableReference(mFlags, [])    Expression(flags, [])  Statement(return this, [])  Statement(}, [])",1,"/**
 * Request service to remove data associated with a given {@link LocusId}.
 *
 * @param locusId the {@link LocusId} being requested to be removed.
 * @param flags either {@link DataRemovalRequest#FLAG_IS_PREFIX} or {@code 0}
 *
 * @return this builder
 */
","/**
 * Request service to remove data associated with a given {@link LocusId}.
 *
 * @param locusId the {@link LocusId} being requested to be removed.
 * @param flags either {@link DataRemovalRequest#FLAG_IS_PREFIX} or {@code 0}
 *
 * @return this builder
 */
",0,[@NonNull],[@NonNull],0,,,,2,5,0,5,1,"The method used for null-checking the parameter `locusId` has been changed from `Preconditions.checkNotNull(locusId)` in the early version to `Objects.requireNonNull(locusId)` in the late version. This is a change in the dependent API, as the method used for null-checking has been changed.","The change in the null-checking method from `Preconditions.checkNotNull(locusId)` to `Objects.requireNonNull(locusId)` has the potential to cause a compatibility issue. While both methods are used for null-checking, they belong to different classes and may have different behaviors or requirements. For example, the `Preconditions` class is not available in the Android framework, and is instead part of the Guava library. If an app using the early version of the API was also using the Guava library, the null-checking would work as expected. However, if the app was only using the Android framework and did not have the Guava library, the null-checking would throw a `NoClassDefFoundError`. In the late version, the null-checking is done using the `Objects` class, which is part of the Android framework, so this issue would not occur. However, other differences in behavior or requirements between the two methods could potentially cause issues. For example, the `Preconditions.checkNotNull` method can be configured to use a custom `ErrorHandler`, which could be used to customize the error message or logging. If an app using the early version of the API was using a custom `ErrorHandler` and was then updated to the late version of the API, the custom error handling would no longer be used, as the `Objects.requireNonNull` method does not support this feature."
28,"<android.text.BoringLayout: BoringLayout replaceOrMake(CharSequence,TextPaint,int,Alignment,float,float,Metrics,boolean,TruncateAt,int)>",32,33,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(boolean trust, []), AssignmentExpression(=, [VariableReference(if (ellipsize, []), Expression(, [])]), Statement(replaceWith(source, paint, outerWidth, align, spacingMult, spacingAdd), []), AssignmentExpression(=, [VariableReference(mEllipsizedWidth, []), Expression(outerWidth, [])]), AssignmentExpression(=, [VariableReference(mEllipsizedStart, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(mEllipsizedCount, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(trust, []), Expression(true, [])]), Statement(} else {, []), MethodCall(replaceWith(TextUtils.ellipsize(source, paint, ellipsizedWidth, ellipsize, true, this), paint, outerWidth, align, spacingMult, spacingAdd), [VariableReference(replaceWith(TextUtils, []), Expression(source, []), Expression(paint, []), Expression(ellipsizedWidth, []), Expression(ellipsize, []), Expression(true, []), Expression(this), []), Expression(paint, []), Expression(outerWidth, []), Expression(align, []), Expression(spacingMult, []), Expression(spacingAdd, [])]), AssignmentExpression(=, [VariableReference(mEllipsizedWidth, []), Expression(ellipsizedWidth, [])]), AssignmentExpression(=, [VariableReference(trust, []), Expression(false, [])]), Statement(}, []), Statement(init(getText(), paint, align, metrics, includePad, trust), []), Statement(return this, []), Statement(}, [])])  Statement({, [])  Statement(boolean trust, [])  AssignmentExpression(=, [VariableReference(if (ellipsize, []), Expression(, [])])    VariableReference(if (ellipsize, [])    Expression(, [])  Statement(replaceWith(source, paint, outerWidth, align, spacingMult, spacingAdd), [])  AssignmentExpression(=, [VariableReference(mEllipsizedWidth, []), Expression(outerWidth, [])])    VariableReference(mEllipsizedWidth, [])    Expression(outerWidth, [])  AssignmentExpression(=, [VariableReference(mEllipsizedStart, []), Expression(0, [])])    VariableReference(mEllipsizedStart, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(mEllipsizedCount, []), Expression(0, [])])    VariableReference(mEllipsizedCount, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(trust, []), Expression(true, [])])    VariableReference(trust, [])    Expression(true, [])  Statement(} else {, [])  MethodCall(replaceWith(TextUtils.ellipsize(source, paint, ellipsizedWidth, ellipsize, true, this), paint, outerWidth, align, spacingMult, spacingAdd), [VariableReference(replaceWith(TextUtils, []), Expression(source, []), Expression(paint, []), Expression(ellipsizedWidth, []), Expression(ellipsize, []), Expression(true, []), Expression(this), []), Expression(paint, []), Expression(outerWidth, []), Expression(align, []), Expression(spacingMult, []), Expression(spacingAdd, [])])    VariableReference(replaceWith(TextUtils, [])    Expression(source, [])    Expression(paint, [])    Expression(ellipsizedWidth, [])    Expression(ellipsize, [])    Expression(true, [])    Expression(this), [])    Expression(paint, [])    Expression(outerWidth, [])    Expression(align, [])    Expression(spacingMult, [])    Expression(spacingAdd, [])  AssignmentExpression(=, [VariableReference(mEllipsizedWidth, []), Expression(ellipsizedWidth, [])])    VariableReference(mEllipsizedWidth, [])    Expression(ellipsizedWidth, [])  AssignmentExpression(=, [VariableReference(trust, []), Expression(false, [])])    VariableReference(trust, [])    Expression(false, [])  Statement(}, [])  Statement(init(getText(), paint, align, metrics, includePad, trust), [])  Statement(return this, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return replaceOrMake(source, paint, outerWidth, align, metrics, includePad, ellipsize, ellipsizedWidth, false), []), Statement(}, [])])  Statement({, [])  Statement(return replaceOrMake(source, paint, outerWidth, align, metrics, includePad, ellipsize, ellipsizedWidth, false), [])  Statement(}, [])",1,"/**
 * Returns a BoringLayout for the specified text, potentially reusing
 * this one if it is already suitable.  The caller must make sure that
 * no one is still using this Layout.
 *
 * @param source the text to render
 * @param paint the default paint for the layout
 * @param outerWidth the wrapping width for the text
 * @param align whether to left, right, or center the text
 * @param spacingMult this value is no longer used by BoringLayout
 * @param spacingAdd this value is no longer used by BoringLayout
 * @param metrics {@code #Metrics} instance that contains information about FontMetrics and
 * line width
 * @param includePad set whether to include extra space beyond font ascent and descent which is
 * needed to avoid clipping in some scripts
 * @param ellipsize whether to ellipsize the text if width of the text is longer than the
 * requested width
 * @param ellipsizedWidth the width to which this Layout is ellipsizing. If {@code ellipsize} is
 * {@code null}, or is {@link TextUtils.TruncateAt#MARQUEE} this value is
 * not used, {@code outerwidth} is used instead
 */
","/**
 * Returns a BoringLayout for the specified text, potentially reusing
 * this one if it is already suitable.  The caller must make sure that
 * no one is still using this Layout.
 *
 * @param source the text to render
 * @param paint the default paint for the layout
 * @param outerWidth the wrapping width for the text
 * @param align whether to left, right, or center the text
 * @param spacingMult this value is no longer used by BoringLayout
 * @param spacingAdd this value is no longer used by BoringLayout
 * @param metrics {@code #Metrics} instance that contains information about FontMetrics and
 * line width
 * @param includePad set whether to include extra space beyond font ascent and descent which is
 * needed to avoid clipping in some scripts
 * @param ellipsize whether to ellipsize the text if width of the text is longer than the
 * requested width
 * @param ellipsizedWidth the width to which this Layout is ellipsizing. If {@code ellipsize} is
 * {@code null}, or is {@link TextUtils.TruncateAt#MARQUEE} this value is
 * not used, {@code outerWidth} is used instead
 */
",1,,,0,,,,"1,2","1,3,4,5",1,"1,5",1,"The early version implementation of the API has been replaced with a single return statement in the late version. This new return statement calls a different method `replaceOrMake` with additional parameters `metrics`, `includePad`, `ellipsize`, and `ellipsizedWidth`. The control dependency has also changed as the conditional statement and the corresponding blocks have been removed.","The Compatibility Issue arises due to the potential of the API to return a different value in the late version. The new method `replaceOrMake` being called might have a different logic to generate the BoringLayout object, which could result in a different layout being returned for the same input parameters. This could impact the visual representation of the text in the applications using this API."
29,<android.service.dreams.DreamService: boolean isFullscreen()>,32,33,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(return mFullscreen, []), Statement(}, [])])  Statement({, [])  Statement(return mFullscreen, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return mFullscreen, []), Statement(}, [])])  Statement({, [])  Statement(return mFullscreen, [])  Statement(}, [])",0,"/**
 * Returns whether or not this dream is in fullscreen mode. Defaults to false.
 *
 * @see #setFullscreen(boolean)
 */
","/**
 * Returns whether this dream is in fullscreen mode. Defaults to false.
 *
 * @see #setFullscreen(boolean)
 */
",1,,,0,,,,0,0,0,0,0,"The implementation of the API `isFullscreen()` in both versions is the same. The only difference is in the comment, where the phrase ""or not"" has been removed in the late version.","The change in the comment does not affect the behavior of the API `isFullscreen()`. Therefore, there is no compatibility issue."
31,<android.view.ViewRootImpl.NativePreImeInputStage: int onProcess(QueuedInputEvent)>,32,33,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mInputQueue !, []), Expression(null && q.mEvent instanceof KeyEvent) {, [])]), MethodCall(mInputQueue.sendInputEvent(q.mEvent, q, true, this), [VariableReference(mInputQueue, []), Expression(q.mEvent, []), Expression(q, []), Expression(true, []), Expression(this, [])]), Statement(return DEFER, []), Statement(}, []), Statement(return FORWARD, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mInputQueue !, []), Expression(null && q.mEvent instanceof KeyEvent) {, [])])    VariableReference(if (mInputQueue !, [])    Expression(null && q.mEvent instanceof KeyEvent) {, [])  MethodCall(mInputQueue.sendInputEvent(q.mEvent, q, true, this), [VariableReference(mInputQueue, []), Expression(q.mEvent, []), Expression(q, []), Expression(true, []), Expression(this, [])])    VariableReference(mInputQueue, [])    Expression(q.mEvent, [])    Expression(q, [])    Expression(true, [])    Expression(this, [])  Statement(return DEFER, [])  Statement(}, [])  Statement(return FORWARD, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final KeyEvent event, []), Expression((KeyEvent) q.mEvent, [])]), Statement(// view tree or IME, and invoke the appropriate {@link OnBackInvokedCallback}., []), AssignmentExpression(=, [VariableReference(if (isBack(event) && mContext !, []), Expression(null && WindowOnBackInvokedDispatcher.isOnBackInvokedCallbackEnabled(mContext)) {, [])]), AssignmentExpression(=, [VariableReference(OnBackInvokedCallback topCallback, []), Expression(getOnBackInvokedDispatcher().getTopCallback(), [])]), AssignmentExpression(=, [VariableReference(if (event.getAction(), []), Expression(, [])]), AssignmentExpression(=, [VariableReference(if (topCallback !, []), Expression(null) {, [])]), MethodCall(topCallback.onBackInvoked(), [VariableReference(topCallback, []), Expression(, [])]), Statement(return FINISH_HANDLED, []), Statement(}, []), Statement(} else {, []), Statement(// Drop other actions such as {@link KeyEvent.ACTION_DOWN}., []), Statement(return FINISH_NOT_HANDLED, []), Statement(}, []), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mInputQueue !, []), Expression(null && q.mEvent instanceof KeyEvent) {, [])]), MethodCall(mInputQueue.sendInputEvent(q.mEvent, q, true, this), [VariableReference(mInputQueue, []), Expression(q.mEvent, []), Expression(q, []), Expression(true, []), Expression(this, [])]), Statement(return DEFER, []), Statement(}, []), Statement(return FORWARD, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final KeyEvent event, []), Expression((KeyEvent) q.mEvent, [])])    VariableReference(final KeyEvent event, [])    Expression((KeyEvent) q.mEvent, [])  Statement(// view tree or IME, and invoke the appropriate {@link OnBackInvokedCallback}., [])  AssignmentExpression(=, [VariableReference(if (isBack(event) && mContext !, []), Expression(null && WindowOnBackInvokedDispatcher.isOnBackInvokedCallbackEnabled(mContext)) {, [])])    VariableReference(if (isBack(event) && mContext !, [])    Expression(null && WindowOnBackInvokedDispatcher.isOnBackInvokedCallbackEnabled(mContext)) {, [])  AssignmentExpression(=, [VariableReference(OnBackInvokedCallback topCallback, []), Expression(getOnBackInvokedDispatcher().getTopCallback(), [])])    VariableReference(OnBackInvokedCallback topCallback, [])    Expression(getOnBackInvokedDispatcher().getTopCallback(), [])  AssignmentExpression(=, [VariableReference(if (event.getAction(), []), Expression(, [])])    VariableReference(if (event.getAction(), [])    Expression(, [])  AssignmentExpression(=, [VariableReference(if (topCallback !, []), Expression(null) {, [])])    VariableReference(if (topCallback !, [])    Expression(null) {, [])  MethodCall(topCallback.onBackInvoked(), [VariableReference(topCallback, []), Expression(, [])])    VariableReference(topCallback, [])    Expression(, [])  Statement(return FINISH_HANDLED, [])  Statement(}, [])  Statement(} else {, [])  Statement(// Drop other actions such as {@link KeyEvent.ACTION_DOWN}., [])  Statement(return FINISH_NOT_HANDLED, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mInputQueue !, []), Expression(null && q.mEvent instanceof KeyEvent) {, [])])    VariableReference(if (mInputQueue !, [])    Expression(null && q.mEvent instanceof KeyEvent) {, [])  MethodCall(mInputQueue.sendInputEvent(q.mEvent, q, true, this), [VariableReference(mInputQueue, []), Expression(q.mEvent, []), Expression(q, []), Expression(true, []), Expression(this, [])])    VariableReference(mInputQueue, [])    Expression(q.mEvent, [])    Expression(q, [])    Expression(true, [])    Expression(this, [])  Statement(return DEFER, [])  Statement(}, [])  Statement(return FORWARD, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,,"1,2","1,3,4,5",1,"1,2","1,2","The implementation of the method has been significantly changed. In the early version, the method only consists of a null-check and a method call. In the late version, there are additional null-checks, method calls, and return statements. Specifically, there are new return statements with the values `FINISH_HANDLED` and `FINISH_NOT_HANDLED`, which were not present in the early version. Additionally, there is a new exception handling statement in the form of a try-catch block.","The new return statements in the late version can lead to different behavior compared to the early version. Specifically, the method can now return `FINISH_HANDLED` or `FINISH_NOT_HANDLED`, which can affect the flow of the program. Additionally, the new exception handling statement can also lead to different behavior in case an exception is thrown. Therefore, this change can lead to compatibility issues of type 1 (different return values) and 2 (different exception handling)."
32,"<android.view.translation.UiTranslationManager: void registerUiTranslationStateCallback(Executor,UiTranslationStateCallback)>",32,33,,,,"MethodDeclaration(method_body, [Statement({, []), MethodCall(Objects.requireNonNull(executor), [VariableReference(Objects, []), Expression(executor, [])]), MethodCall(Objects.requireNonNull(callback), [VariableReference(Objects, []), Expression(callback, [])]), Statement(synchronized (mCallbacks) {, []), MethodCall(if (mCallbacks.containsKey(callback)), [VariableReference(if (mCallbacks, []), Expression(callback), [])]), Statement("" + "" ignoring.""), []), Statement(return, []), Statement(}, []), AssignmentExpression(=, [VariableReference(final IRemoteCallback remoteCallback, []), Expression(new UiTranslationStateRemoteCallback(executor, callback), [])]), Statement(try {, []), MethodCall(mService.registerUiTranslationStateCallback(remoteCallback, mContext.getUserId()), [VariableReference(mService, []), Expression(remoteCallback, []), Expression(mContext.getUserId(), [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), MethodCall(mCallbacks.put(callback, remoteCallback), [VariableReference(mCallbacks, []), Expression(callback, []), Expression(remoteCallback, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  MethodCall(Objects.requireNonNull(executor), [VariableReference(Objects, []), Expression(executor, [])])    VariableReference(Objects, [])    Expression(executor, [])  MethodCall(Objects.requireNonNull(callback), [VariableReference(Objects, []), Expression(callback, [])])    VariableReference(Objects, [])    Expression(callback, [])  Statement(synchronized (mCallbacks) {, [])  MethodCall(if (mCallbacks.containsKey(callback)), [VariableReference(if (mCallbacks, []), Expression(callback), [])])    VariableReference(if (mCallbacks, [])    Expression(callback), [])  Statement("" + "" ignoring.""), [])  Statement(return, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(final IRemoteCallback remoteCallback, []), Expression(new UiTranslationStateRemoteCallback(executor, callback), [])])    VariableReference(final IRemoteCallback remoteCallback, [])    Expression(new UiTranslationStateRemoteCallback(executor, callback), [])  Statement(try {, [])  MethodCall(mService.registerUiTranslationStateCallback(remoteCallback, mContext.getUserId()), [VariableReference(mService, []), Expression(remoteCallback, []), Expression(mContext.getUserId(), [])])    VariableReference(mService, [])    Expression(remoteCallback, [])    Expression(mContext.getUserId(), [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  MethodCall(mCallbacks.put(callback, remoteCallback), [VariableReference(mCallbacks, []), Expression(callback, []), Expression(remoteCallback, [])])    VariableReference(mCallbacks, [])    Expression(callback, [])    Expression(remoteCallback, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(Objects.requireNonNull(executor), [VariableReference(Objects, []), Expression(executor, [])]), MethodCall(Objects.requireNonNull(callback), [VariableReference(Objects, []), Expression(callback, [])]), Statement(synchronized (mCallbacks) {, []), MethodCall(if (mCallbacks.containsKey(callback)), [VariableReference(if (mCallbacks, []), Expression(callback), [])]), Statement("" + "" ignoring.""), []), Statement(return, []), Statement(}, []), AssignmentExpression(=, [VariableReference(final IRemoteCallback remoteCallback, []), Expression(new UiTranslationStateRemoteCallback(executor, callback), [])]), Statement(try {, []), MethodCall(mService.registerUiTranslationStateCallback(remoteCallback, mContext.getUserId()), [VariableReference(mService, []), Expression(remoteCallback, []), Expression(mContext.getUserId(), [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), MethodCall(mCallbacks.put(callback, remoteCallback), [VariableReference(mCallbacks, []), Expression(callback, []), Expression(remoteCallback, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  MethodCall(Objects.requireNonNull(executor), [VariableReference(Objects, []), Expression(executor, [])])    VariableReference(Objects, [])    Expression(executor, [])  MethodCall(Objects.requireNonNull(callback), [VariableReference(Objects, []), Expression(callback, [])])    VariableReference(Objects, [])    Expression(callback, [])  Statement(synchronized (mCallbacks) {, [])  MethodCall(if (mCallbacks.containsKey(callback)), [VariableReference(if (mCallbacks, []), Expression(callback), [])])    VariableReference(if (mCallbacks, [])    Expression(callback), [])  Statement("" + "" ignoring.""), [])  Statement(return, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(final IRemoteCallback remoteCallback, []), Expression(new UiTranslationStateRemoteCallback(executor, callback), [])])    VariableReference(final IRemoteCallback remoteCallback, [])    Expression(new UiTranslationStateRemoteCallback(executor, callback), [])  Statement(try {, [])  MethodCall(mService.registerUiTranslationStateCallback(remoteCallback, mContext.getUserId()), [VariableReference(mService, []), Expression(remoteCallback, []), Expression(mContext.getUserId(), [])])    VariableReference(mService, [])    Expression(remoteCallback, [])    Expression(mContext.getUserId(), [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  MethodCall(mCallbacks.put(callback, remoteCallback), [VariableReference(mCallbacks, []), Expression(callback, []), Expression(remoteCallback, [])])    VariableReference(mCallbacks, [])    Expression(callback, [])    Expression(remoteCallback, [])  Statement(}, [])  Statement(}, [])",0,"/**
 * Register for notifications of UI Translation state changes on the foreground activity. This
 * is available to the owning application itself and also the current input method.
 * <p>
 * The application whose UI is being translated can use this to customize the UI Translation
 * behavior in ways that aren't made easy by methods like
 * {@link View#onCreateViewTranslationRequest(int[], Consumer)}.
 *
 * <p>
 * Input methods can use this to offer complementary features to UI Translation; for example,
 * enabling outgoing message translation when the system is translating incoming messages in a
 * communication app.
 *
 * @param callback the callback to register for receiving the state change
 * notifications
 */
","/**
 * Register for notifications of UI Translation state changes on the foreground Activity. This
 * is available to the owning application itself and also the current input method.
 * <p>
 * The application whose UI is being translated can use this to customize the UI Translation
 * behavior in ways that aren't made easy by methods like
 * {@link View#onCreateViewTranslationRequest(int[], Consumer)}.
 * <p>
 * Input methods can use this to offer complementary features to UI Translation; for example,
 * enabling outgoing message translation when the system is translating incoming messages in a
 * communication app.
 * <p>
 * Starting from {@link android.os.Build.VERSION_CODES#TIRAMISU}, if Activities are already
 * being translated when a callback is registered, methods on the callback will be invoked for
 * each translated activity, depending on the state of translation:
 * <ul>
 * <li>If translation is <em>not</em> paused,
 * {@link UiTranslationStateCallback#onStarted} will be invoked.</li>
 * <li>If translation <em>is</em> paused, {@link UiTranslationStateCallback#onStarted}
 * will first be invoked, followed by {@link UiTranslationStateCallback#onPaused}.</li>
 * </ul>
 *
 * @param callback the callback to register for receiving the state change
 * notifications
 */
",1,,,0,,,,0,0,0,0,0,No change in the method implementation between the two versions.,No compatibility issues arise as the code remains the same between the two versions.
34,<android.view.autofill.AutofillManager.TrackedViews: void onVisibleForAutofillChangedLocked()>,32,33,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(// The visibility of the views might have changed while the client was not be visible,, []), Statement(// hence update the visibility state for all views., []), AssignmentExpression(=, [VariableReference(AutofillClient client, []), Expression(getClient(), [])]), AssignmentExpression(=, [VariableReference(ArraySet<AutofillId> updatedVisibleTrackedIds, []), Expression(null, [])]), AssignmentExpression(=, [VariableReference(ArraySet<AutofillId> updatedInvisibleTrackedIds, []), Expression(null, [])]), AssignmentExpression(=, [VariableReference(if (client !, []), Expression(null) {, [])]), Statement(if (sVerbose) {, []), AssignmentExpression(=, [VariableReference(Log.v(TAG, ""onVisibleForAutofillChangedLocked(): inv, []), Expression("" + mInvisibleTrackedIds + "" vis, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mInvisibleTrackedIds !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(final ArrayList<AutofillId> orderedInvisibleIds, []), Expression(new ArrayList<>(mInvisibleTrackedIds), [])]), AssignmentExpression(=, [VariableReference(final boolean[] isVisible, []), Expression(client.autofillClientGetViewVisibility(Helper.toArray(orderedInvisibleIds)), [])]), AssignmentExpression(=, [VariableReference(final int numInvisibleTrackedIds, []), Expression(orderedInvisibleIds.size(), [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < numInvisibleTrackedIds, []), Statement(i++) {, []), AssignmentExpression(=, [VariableReference(final AutofillId id, []), Expression(orderedInvisibleIds.get(i), [])]), Statement(if (isVisible[i]) {, []), AssignmentExpression(=, [VariableReference(updatedVisibleTrackedIds, []), Expression(addToSet(updatedVisibleTrackedIds, id), [])]), Statement(if (sDebug) {, []), MethodCall(Log.d(TAG, ""onVisibleForAutofill() "" + id + "" became visible""), [VariableReference(Log, []), Expression(TAG, []), Expression(""onVisibleForAutofill() "" + id + "" became visible"", [])]), Statement(}, []), Statement(} else {, []), AssignmentExpression(=, [VariableReference(updatedInvisibleTrackedIds, []), Expression(addToSet(updatedInvisibleTrackedIds, id), [])]), Statement(}, []), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mVisibleTrackedIds !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(final ArrayList<AutofillId> orderedVisibleIds, []), Expression(new ArrayList<>(mVisibleTrackedIds), [])]), AssignmentExpression(=, [VariableReference(final boolean[] isVisible, []), Expression(client.autofillClientGetViewVisibility(Helper.toArray(orderedVisibleIds)), [])]), AssignmentExpression(=, [VariableReference(final int numVisibleTrackedIds, []), Expression(orderedVisibleIds.size(), [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < numVisibleTrackedIds, []), Statement(i++) {, []), AssignmentExpression(=, [VariableReference(final AutofillId id, []), Expression(orderedVisibleIds.get(i), [])]), Statement(if (isVisible[i]) {, []), AssignmentExpression(=, [VariableReference(updatedVisibleTrackedIds, []), Expression(addToSet(updatedVisibleTrackedIds, id), [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(updatedInvisibleTrackedIds, []), Expression(addToSet(updatedInvisibleTrackedIds, id), [])]), Statement(if (sDebug) {, []), MethodCall(Log.d(TAG, ""onVisibleForAutofill() "" + id + "" became invisible""), [VariableReference(Log, []), Expression(TAG, []), Expression(""onVisibleForAutofill() "" + id + "" became invisible"", [])]), Statement(}, []), Statement(}, []), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(mInvisibleTrackedIds, []), Expression(updatedInvisibleTrackedIds, [])]), AssignmentExpression(=, [VariableReference(mVisibleTrackedIds, []), Expression(updatedVisibleTrackedIds, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mVisibleTrackedIds, []), Expression(, [])]), Statement(if (sVerbose) {, []), MethodCall(Log.v(TAG, ""onVisibleForAutofillChangedLocked(): no more visible ids""), [VariableReference(Log, []), Expression(TAG, []), Expression(""onVisibleForAutofillChangedLocked(): no more visible ids"", [])]), Statement(}, []), Statement(finishSessionLocked(), []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(// The visibility of the views might have changed while the client was not be visible,, [])  Statement(// hence update the visibility state for all views., [])  AssignmentExpression(=, [VariableReference(AutofillClient client, []), Expression(getClient(), [])])    VariableReference(AutofillClient client, [])    Expression(getClient(), [])  AssignmentExpression(=, [VariableReference(ArraySet<AutofillId> updatedVisibleTrackedIds, []), Expression(null, [])])    VariableReference(ArraySet<AutofillId> updatedVisibleTrackedIds, [])    Expression(null, [])  AssignmentExpression(=, [VariableReference(ArraySet<AutofillId> updatedInvisibleTrackedIds, []), Expression(null, [])])    VariableReference(ArraySet<AutofillId> updatedInvisibleTrackedIds, [])    Expression(null, [])  AssignmentExpression(=, [VariableReference(if (client !, []), Expression(null) {, [])])    VariableReference(if (client !, [])    Expression(null) {, [])  Statement(if (sVerbose) {, [])  AssignmentExpression(=, [VariableReference(Log.v(TAG, ""onVisibleForAutofillChangedLocked(): inv, []), Expression("" + mInvisibleTrackedIds + "" vis, [])])    VariableReference(Log.v(TAG, ""onVisibleForAutofillChangedLocked(): inv, [])    Expression("" + mInvisibleTrackedIds + "" vis, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mInvisibleTrackedIds !, []), Expression(null) {, [])])    VariableReference(if (mInvisibleTrackedIds !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(final ArrayList<AutofillId> orderedInvisibleIds, []), Expression(new ArrayList<>(mInvisibleTrackedIds), [])])    VariableReference(final ArrayList<AutofillId> orderedInvisibleIds, [])    Expression(new ArrayList<>(mInvisibleTrackedIds), [])  AssignmentExpression(=, [VariableReference(final boolean[] isVisible, []), Expression(client.autofillClientGetViewVisibility(Helper.toArray(orderedInvisibleIds)), [])])    VariableReference(final boolean[] isVisible, [])    Expression(client.autofillClientGetViewVisibility(Helper.toArray(orderedInvisibleIds)), [])  AssignmentExpression(=, [VariableReference(final int numInvisibleTrackedIds, []), Expression(orderedInvisibleIds.size(), [])])    VariableReference(final int numInvisibleTrackedIds, [])    Expression(orderedInvisibleIds.size(), [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < numInvisibleTrackedIds, [])  Statement(i++) {, [])  AssignmentExpression(=, [VariableReference(final AutofillId id, []), Expression(orderedInvisibleIds.get(i), [])])    VariableReference(final AutofillId id, [])    Expression(orderedInvisibleIds.get(i), [])  Statement(if (isVisible[i]) {, [])  AssignmentExpression(=, [VariableReference(updatedVisibleTrackedIds, []), Expression(addToSet(updatedVisibleTrackedIds, id), [])])    VariableReference(updatedVisibleTrackedIds, [])    Expression(addToSet(updatedVisibleTrackedIds, id), [])  Statement(if (sDebug) {, [])  MethodCall(Log.d(TAG, ""onVisibleForAutofill() "" + id + "" became visible""), [VariableReference(Log, []), Expression(TAG, []), Expression(""onVisibleForAutofill() "" + id + "" became visible"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""onVisibleForAutofill() "" + id + "" became visible"", [])  Statement(}, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(updatedInvisibleTrackedIds, []), Expression(addToSet(updatedInvisibleTrackedIds, id), [])])    VariableReference(updatedInvisibleTrackedIds, [])    Expression(addToSet(updatedInvisibleTrackedIds, id), [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mVisibleTrackedIds !, []), Expression(null) {, [])])    VariableReference(if (mVisibleTrackedIds !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(final ArrayList<AutofillId> orderedVisibleIds, []), Expression(new ArrayList<>(mVisibleTrackedIds), [])])    VariableReference(final ArrayList<AutofillId> orderedVisibleIds, [])    Expression(new ArrayList<>(mVisibleTrackedIds), [])  AssignmentExpression(=, [VariableReference(final boolean[] isVisible, []), Expression(client.autofillClientGetViewVisibility(Helper.toArray(orderedVisibleIds)), [])])    VariableReference(final boolean[] isVisible, [])    Expression(client.autofillClientGetViewVisibility(Helper.toArray(orderedVisibleIds)), [])  AssignmentExpression(=, [VariableReference(final int numVisibleTrackedIds, []), Expression(orderedVisibleIds.size(), [])])    VariableReference(final int numVisibleTrackedIds, [])    Expression(orderedVisibleIds.size(), [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < numVisibleTrackedIds, [])  Statement(i++) {, [])  AssignmentExpression(=, [VariableReference(final AutofillId id, []), Expression(orderedVisibleIds.get(i), [])])    VariableReference(final AutofillId id, [])    Expression(orderedVisibleIds.get(i), [])  Statement(if (isVisible[i]) {, [])  AssignmentExpression(=, [VariableReference(updatedVisibleTrackedIds, []), Expression(addToSet(updatedVisibleTrackedIds, id), [])])    VariableReference(updatedVisibleTrackedIds, [])    Expression(addToSet(updatedVisibleTrackedIds, id), [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(updatedInvisibleTrackedIds, []), Expression(addToSet(updatedInvisibleTrackedIds, id), [])])    VariableReference(updatedInvisibleTrackedIds, [])    Expression(addToSet(updatedInvisibleTrackedIds, id), [])  Statement(if (sDebug) {, [])  MethodCall(Log.d(TAG, ""onVisibleForAutofill() "" + id + "" became invisible""), [VariableReference(Log, []), Expression(TAG, []), Expression(""onVisibleForAutofill() "" + id + "" became invisible"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""onVisibleForAutofill() "" + id + "" became invisible"", [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mInvisibleTrackedIds, []), Expression(updatedInvisibleTrackedIds, [])])    VariableReference(mInvisibleTrackedIds, [])    Expression(updatedInvisibleTrackedIds, [])  AssignmentExpression(=, [VariableReference(mVisibleTrackedIds, []), Expression(updatedVisibleTrackedIds, [])])    VariableReference(mVisibleTrackedIds, [])    Expression(updatedVisibleTrackedIds, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mVisibleTrackedIds, []), Expression(, [])])    VariableReference(if (mVisibleTrackedIds, [])    Expression(, [])  Statement(if (sVerbose) {, [])  MethodCall(Log.v(TAG, ""onVisibleForAutofillChangedLocked(): no more visible ids""), [VariableReference(Log, []), Expression(TAG, []), Expression(""onVisibleForAutofillChangedLocked(): no more visible ids"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""onVisibleForAutofillChangedLocked(): no more visible ids"", [])  Statement(}, [])  Statement(finishSessionLocked(), [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(// The visibility of the views might have changed while the client was not be visible,, []), Statement(// hence update the visibility state for all views., []), AssignmentExpression(=, [VariableReference(AutofillClient client, []), Expression(getClient(), [])]), AssignmentExpression(=, [VariableReference(ArraySet<AutofillId> updatedVisibleTrackedIds, []), Expression(null, [])]), AssignmentExpression(=, [VariableReference(ArraySet<AutofillId> updatedInvisibleTrackedIds, []), Expression(null, [])]), AssignmentExpression(=, [VariableReference(if (client !, []), Expression(null) {, [])]), Statement(if (sVerbose) {, []), AssignmentExpression(=, [VariableReference(Log.v(TAG, ""onVisibleForAutofillChangedLocked(): inv, []), Expression("" + mInvisibleTrackedIds + "" vis, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mInvisibleTrackedIds !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(final ArrayList<AutofillId> orderedInvisibleIds, []), Expression(new ArrayList<>(mInvisibleTrackedIds), [])]), AssignmentExpression(=, [VariableReference(final boolean[] isVisible, []), Expression(client.autofillClientGetViewVisibility(Helper.toArray(orderedInvisibleIds)), [])]), AssignmentExpression(=, [VariableReference(final int numInvisibleTrackedIds, []), Expression(orderedInvisibleIds.size(), [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < numInvisibleTrackedIds, []), Statement(i++) {, []), AssignmentExpression(=, [VariableReference(final AutofillId id, []), Expression(orderedInvisibleIds.get(i), [])]), Statement(if (isVisible[i]) {, []), AssignmentExpression(=, [VariableReference(updatedVisibleTrackedIds, []), Expression(addToSet(updatedVisibleTrackedIds, id), [])]), Statement(if (sDebug) {, []), MethodCall(Log.d(TAG, ""onVisibleForAutofill() "" + id + "" became visible""), [VariableReference(Log, []), Expression(TAG, []), Expression(""onVisibleForAutofill() "" + id + "" became visible"", [])]), Statement(}, []), Statement(} else {, []), AssignmentExpression(=, [VariableReference(updatedInvisibleTrackedIds, []), Expression(addToSet(updatedInvisibleTrackedIds, id), [])]), Statement(}, []), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mVisibleTrackedIds !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(final ArrayList<AutofillId> orderedVisibleIds, []), Expression(new ArrayList<>(mVisibleTrackedIds), [])]), AssignmentExpression(=, [VariableReference(final boolean[] isVisible, []), Expression(client.autofillClientGetViewVisibility(Helper.toArray(orderedVisibleIds)), [])]), AssignmentExpression(=, [VariableReference(final int numVisibleTrackedIds, []), Expression(orderedVisibleIds.size(), [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < numVisibleTrackedIds, []), Statement(i++) {, []), AssignmentExpression(=, [VariableReference(final AutofillId id, []), Expression(orderedVisibleIds.get(i), [])]), Statement(if (isVisible[i]) {, []), AssignmentExpression(=, [VariableReference(updatedVisibleTrackedIds, []), Expression(addToSet(updatedVisibleTrackedIds, id), [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(updatedInvisibleTrackedIds, []), Expression(addToSet(updatedInvisibleTrackedIds, id), [])]), Statement(if (sDebug) {, []), MethodCall(Log.d(TAG, ""onVisibleForAutofill() "" + id + "" became invisible""), [VariableReference(Log, []), Expression(TAG, []), Expression(""onVisibleForAutofill() "" + id + "" became invisible"", [])]), Statement(}, []), Statement(}, []), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(mInvisibleTrackedIds, []), Expression(updatedInvisibleTrackedIds, [])]), AssignmentExpression(=, [VariableReference(mVisibleTrackedIds, []), Expression(updatedVisibleTrackedIds, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mVisibleTrackedIds, []), Expression(, [])]), Statement(if (sVerbose) {, []), MethodCall(Log.v(TAG, ""onVisibleForAutofillChangedLocked(): no more visible ids""), [VariableReference(Log, []), Expression(TAG, []), Expression(""onVisibleForAutofillChangedLocked(): no more visible ids"", [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(finishSessionLocked(/* commitReason, []), Expression(*/, [])]), Statement(COMMIT_REASON_VIEW_CHANGED), []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(// The visibility of the views might have changed while the client was not be visible,, [])  Statement(// hence update the visibility state for all views., [])  AssignmentExpression(=, [VariableReference(AutofillClient client, []), Expression(getClient(), [])])    VariableReference(AutofillClient client, [])    Expression(getClient(), [])  AssignmentExpression(=, [VariableReference(ArraySet<AutofillId> updatedVisibleTrackedIds, []), Expression(null, [])])    VariableReference(ArraySet<AutofillId> updatedVisibleTrackedIds, [])    Expression(null, [])  AssignmentExpression(=, [VariableReference(ArraySet<AutofillId> updatedInvisibleTrackedIds, []), Expression(null, [])])    VariableReference(ArraySet<AutofillId> updatedInvisibleTrackedIds, [])    Expression(null, [])  AssignmentExpression(=, [VariableReference(if (client !, []), Expression(null) {, [])])    VariableReference(if (client !, [])    Expression(null) {, [])  Statement(if (sVerbose) {, [])  AssignmentExpression(=, [VariableReference(Log.v(TAG, ""onVisibleForAutofillChangedLocked(): inv, []), Expression("" + mInvisibleTrackedIds + "" vis, [])])    VariableReference(Log.v(TAG, ""onVisibleForAutofillChangedLocked(): inv, [])    Expression("" + mInvisibleTrackedIds + "" vis, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mInvisibleTrackedIds !, []), Expression(null) {, [])])    VariableReference(if (mInvisibleTrackedIds !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(final ArrayList<AutofillId> orderedInvisibleIds, []), Expression(new ArrayList<>(mInvisibleTrackedIds), [])])    VariableReference(final ArrayList<AutofillId> orderedInvisibleIds, [])    Expression(new ArrayList<>(mInvisibleTrackedIds), [])  AssignmentExpression(=, [VariableReference(final boolean[] isVisible, []), Expression(client.autofillClientGetViewVisibility(Helper.toArray(orderedInvisibleIds)), [])])    VariableReference(final boolean[] isVisible, [])    Expression(client.autofillClientGetViewVisibility(Helper.toArray(orderedInvisibleIds)), [])  AssignmentExpression(=, [VariableReference(final int numInvisibleTrackedIds, []), Expression(orderedInvisibleIds.size(), [])])    VariableReference(final int numInvisibleTrackedIds, [])    Expression(orderedInvisibleIds.size(), [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < numInvisibleTrackedIds, [])  Statement(i++) {, [])  AssignmentExpression(=, [VariableReference(final AutofillId id, []), Expression(orderedInvisibleIds.get(i), [])])    VariableReference(final AutofillId id, [])    Expression(orderedInvisibleIds.get(i), [])  Statement(if (isVisible[i]) {, [])  AssignmentExpression(=, [VariableReference(updatedVisibleTrackedIds, []), Expression(addToSet(updatedVisibleTrackedIds, id), [])])    VariableReference(updatedVisibleTrackedIds, [])    Expression(addToSet(updatedVisibleTrackedIds, id), [])  Statement(if (sDebug) {, [])  MethodCall(Log.d(TAG, ""onVisibleForAutofill() "" + id + "" became visible""), [VariableReference(Log, []), Expression(TAG, []), Expression(""onVisibleForAutofill() "" + id + "" became visible"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""onVisibleForAutofill() "" + id + "" became visible"", [])  Statement(}, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(updatedInvisibleTrackedIds, []), Expression(addToSet(updatedInvisibleTrackedIds, id), [])])    VariableReference(updatedInvisibleTrackedIds, [])    Expression(addToSet(updatedInvisibleTrackedIds, id), [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mVisibleTrackedIds !, []), Expression(null) {, [])])    VariableReference(if (mVisibleTrackedIds !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(final ArrayList<AutofillId> orderedVisibleIds, []), Expression(new ArrayList<>(mVisibleTrackedIds), [])])    VariableReference(final ArrayList<AutofillId> orderedVisibleIds, [])    Expression(new ArrayList<>(mVisibleTrackedIds), [])  AssignmentExpression(=, [VariableReference(final boolean[] isVisible, []), Expression(client.autofillClientGetViewVisibility(Helper.toArray(orderedVisibleIds)), [])])    VariableReference(final boolean[] isVisible, [])    Expression(client.autofillClientGetViewVisibility(Helper.toArray(orderedVisibleIds)), [])  AssignmentExpression(=, [VariableReference(final int numVisibleTrackedIds, []), Expression(orderedVisibleIds.size(), [])])    VariableReference(final int numVisibleTrackedIds, [])    Expression(orderedVisibleIds.size(), [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < numVisibleTrackedIds, [])  Statement(i++) {, [])  AssignmentExpression(=, [VariableReference(final AutofillId id, []), Expression(orderedVisibleIds.get(i), [])])    VariableReference(final AutofillId id, [])    Expression(orderedVisibleIds.get(i), [])  Statement(if (isVisible[i]) {, [])  AssignmentExpression(=, [VariableReference(updatedVisibleTrackedIds, []), Expression(addToSet(updatedVisibleTrackedIds, id), [])])    VariableReference(updatedVisibleTrackedIds, [])    Expression(addToSet(updatedVisibleTrackedIds, id), [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(updatedInvisibleTrackedIds, []), Expression(addToSet(updatedInvisibleTrackedIds, id), [])])    VariableReference(updatedInvisibleTrackedIds, [])    Expression(addToSet(updatedInvisibleTrackedIds, id), [])  Statement(if (sDebug) {, [])  MethodCall(Log.d(TAG, ""onVisibleForAutofill() "" + id + "" became invisible""), [VariableReference(Log, []), Expression(TAG, []), Expression(""onVisibleForAutofill() "" + id + "" became invisible"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""onVisibleForAutofill() "" + id + "" became invisible"", [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mInvisibleTrackedIds, []), Expression(updatedInvisibleTrackedIds, [])])    VariableReference(mInvisibleTrackedIds, [])    Expression(updatedInvisibleTrackedIds, [])  AssignmentExpression(=, [VariableReference(mVisibleTrackedIds, []), Expression(updatedVisibleTrackedIds, [])])    VariableReference(mVisibleTrackedIds, [])    Expression(updatedVisibleTrackedIds, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mVisibleTrackedIds, []), Expression(, [])])    VariableReference(if (mVisibleTrackedIds, [])    Expression(, [])  Statement(if (sVerbose) {, [])  MethodCall(Log.v(TAG, ""onVisibleForAutofillChangedLocked(): no more visible ids""), [VariableReference(Log, []), Expression(TAG, []), Expression(""onVisibleForAutofillChangedLocked(): no more visible ids"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""onVisibleForAutofillChangedLocked(): no more visible ids"", [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(finishSessionLocked(/* commitReason, []), Expression(*/, [])])    VariableReference(finishSessionLocked(/* commitReason, [])    Expression(*/, [])  Statement(COMMIT_REASON_VIEW_CHANGED), [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Called once the client becomes visible.
 *
 * @see AutofillClient#autofillClientIsVisibleForAutofill()
 */
","/**
 * Called once the client becomes visible.
 *
 * @see AutofillClient#autofillClientIsVisibleForAutofill()
 */
",0,[@GuardedBy("mLock")],[@GuardedBy("mLock")],0,,,,2,5,0,3,1,"A new statement is added in the late version implementation: ""AssignmentExpression(=, [VariableReference(finishSessionLocked(/* commitReason, []), Expression(*/, [])])"". This statement sets the value of the ""finishSessionLocked"" variable to a new expression, which is not present in the early version.","The added statement in the late version implementation may potentially lead to a different return value for the ""onVisibleForAutofillChangedLocked"" method, as it sets the value of the ""finishSessionLocked"" variable to a new expression. This could cause a compatibility issue if the code that calls this method relies on a specific return value."
35,"<android.os.Vibrator: void vibrate(long[],int,AudioAttributes)>",32,33,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(// exceptions for compatibility purposes, []), AssignmentExpression(=, [VariableReference(if (repeat < -1 || repeat >, []), Expression(pattern.length) {, [])]), AssignmentExpression(=, [VariableReference(Log.e(TAG, ""vibrate called with repeat index out of bounds"" + "" (pattern.length, []), Expression("" + pattern.length + "", index, [])]), Statement(throw new ArrayIndexOutOfBoundsException(), []), Statement(}, []), Statement(try {, []), MethodCall(vibrate(VibrationEffect.createWaveform(pattern, repeat), attributes), [VariableReference(vibrate(VibrationEffect, []), Expression(pattern, []), Expression(repeat), []), Expression(attributes, [])]), Statement(} catch (IllegalArgumentException iae) {, []), MethodCall(Log.e(TAG, ""Failed to create VibrationEffect"", iae), [VariableReference(Log, []), Expression(TAG, []), Expression(""Failed to create VibrationEffect"", []), Expression(iae, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(// exceptions for compatibility purposes, [])  AssignmentExpression(=, [VariableReference(if (repeat < -1 || repeat >, []), Expression(pattern.length) {, [])])    VariableReference(if (repeat < -1 || repeat >, [])    Expression(pattern.length) {, [])  AssignmentExpression(=, [VariableReference(Log.e(TAG, ""vibrate called with repeat index out of bounds"" + "" (pattern.length, []), Expression("" + pattern.length + "", index, [])])    VariableReference(Log.e(TAG, ""vibrate called with repeat index out of bounds"" + "" (pattern.length, [])    Expression("" + pattern.length + "", index, [])  Statement(throw new ArrayIndexOutOfBoundsException(), [])  Statement(}, [])  Statement(try {, [])  MethodCall(vibrate(VibrationEffect.createWaveform(pattern, repeat), attributes), [VariableReference(vibrate(VibrationEffect, []), Expression(pattern, []), Expression(repeat), []), Expression(attributes, [])])    VariableReference(vibrate(VibrationEffect, [])    Expression(pattern, [])    Expression(repeat), [])    Expression(attributes, [])  Statement(} catch (IllegalArgumentException iae) {, [])  MethodCall(Log.e(TAG, ""Failed to create VibrationEffect"", iae), [VariableReference(Log, []), Expression(TAG, []), Expression(""Failed to create VibrationEffect"", []), Expression(iae, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Failed to create VibrationEffect"", [])    Expression(iae, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(// exceptions for compatibility purposes, []), AssignmentExpression(=, [VariableReference(if (repeat < -1 || repeat >, []), Expression(pattern.length) {, [])]), AssignmentExpression(=, [VariableReference(Log.e(TAG, ""vibrate called with repeat index out of bounds"" + "" (pattern.length, []), Expression("" + pattern.length + "", index, [])]), Statement(throw new ArrayIndexOutOfBoundsException(), []), Statement(}, []), Statement(try {, []), MethodCall(vibrate(VibrationEffect.createWaveform(pattern, repeat), attributes), [VariableReference(vibrate(VibrationEffect, []), Expression(pattern, []), Expression(repeat), []), Expression(attributes, [])]), Statement(} catch (IllegalArgumentException iae) {, []), MethodCall(Log.e(TAG, ""Failed to create VibrationEffect"", iae), [VariableReference(Log, []), Expression(TAG, []), Expression(""Failed to create VibrationEffect"", []), Expression(iae, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(// exceptions for compatibility purposes, [])  AssignmentExpression(=, [VariableReference(if (repeat < -1 || repeat >, []), Expression(pattern.length) {, [])])    VariableReference(if (repeat < -1 || repeat >, [])    Expression(pattern.length) {, [])  AssignmentExpression(=, [VariableReference(Log.e(TAG, ""vibrate called with repeat index out of bounds"" + "" (pattern.length, []), Expression("" + pattern.length + "", index, [])])    VariableReference(Log.e(TAG, ""vibrate called with repeat index out of bounds"" + "" (pattern.length, [])    Expression("" + pattern.length + "", index, [])  Statement(throw new ArrayIndexOutOfBoundsException(), [])  Statement(}, [])  Statement(try {, [])  MethodCall(vibrate(VibrationEffect.createWaveform(pattern, repeat), attributes), [VariableReference(vibrate(VibrationEffect, []), Expression(pattern, []), Expression(repeat), []), Expression(attributes, [])])    VariableReference(vibrate(VibrationEffect, [])    Expression(pattern, [])    Expression(repeat), [])    Expression(attributes, [])  Statement(} catch (IllegalArgumentException iae) {, [])  MethodCall(Log.e(TAG, ""Failed to create VibrationEffect"", iae), [VariableReference(Log, []), Expression(TAG, []), Expression(""Failed to create VibrationEffect"", []), Expression(iae, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Failed to create VibrationEffect"", [])    Expression(iae, [])  Statement(}, [])  Statement(}, [])",0,"/**
 * Vibrate with a given pattern.
 *
 * <p>
 * Pass in an array of ints that are the durations for which to turn on or off
 * the vibrator in milliseconds.  The first value indicates the number of milliseconds
 * to wait before turning the vibrator on.  The next value indicates the number of milliseconds
 * for which to keep the vibrator on before turning it off.  Subsequent values alternate
 * between durations in milliseconds to turn the vibrator off or to turn the vibrator on.
 * </p><p>
 * To cause the pattern to repeat, pass the index into the pattern array at which
 * to start the repeat, or -1 to disable repeating.
 * </p>
 *
 * @param pattern    an array of longs of times for which to turn the vibrator on or off.
 * @param repeat     the index into pattern at which to repeat, or -1 if
 * you don't want to repeat.
 * @param attributes {@link AudioAttributes} corresponding to the vibration. For example,
 * specify {@link AudioAttributes#USAGE_ALARM} for alarm vibrations or
 * {@link AudioAttributes#USAGE_NOTIFICATION_RINGTONE} for
 * vibrations associated with incoming calls.
 * @deprecated Use {@link #vibrate(VibrationEffect, AudioAttributes)} instead.
 */
","/**
 * Vibrate with a given pattern.
 *
 * <p>
 * Pass in an array of ints that are the durations for which to turn on or off
 * the vibrator in milliseconds.  The first value indicates the number of milliseconds
 * to wait before turning the vibrator on.  The next value indicates the number of milliseconds
 * for which to keep the vibrator on before turning it off.  Subsequent values alternate
 * between durations in milliseconds to turn the vibrator off or to turn the vibrator on.
 * </p><p>
 * To cause the pattern to repeat, pass the index into the pattern array at which
 * to start the repeat, or -1 to disable repeating.
 * </p>
 *
 * <p>The app should be in the foreground for the vibration to happen. Background apps should
 * specify a ringtone, notification or alarm usage in order to vibrate.</p>
 *
 * @param pattern    an array of longs of times for which to turn the vibrator on or off.
 * @param repeat     the index into pattern at which to repeat, or -1 if
 * you don't want to repeat.
 * @param attributes {@link AudioAttributes} corresponding to the vibration. For example,
 * specify {@link AudioAttributes#USAGE_ALARM} for alarm vibrations or
 * {@link AudioAttributes#USAGE_NOTIFICATION_RINGTONE} for
 * vibrations associated with incoming calls.
 * @deprecated Use {@link #vibrate(VibrationEffect, VibrationAttributes)} instead.
 */
",1,"[@Deprecated, @RequiresPermission(android.Manifest.permission.VIBRATE)]","[@Deprecated, @RequiresPermission(android.Manifest.permission.VIBRATE)]",0,,,,0,0,0,5,"1,2","The dependent API has changed. In the early version, the method `vibrate(VibrationEffect, AudioAttributes)` is called, while in the late version, the method `vibrate(VibrationEffect, VibrationAttributes)` is called.","This change can lead to compatibility issues for both return values and exception handling. The different method signatures may cause the application to pass in incorrect parameters, leading to unexpected behavior or exceptions. The application may also not be aware of the new VibrationAttributes class and its properties, which can affect the vibration behavior."
36,<android.companion.AssociationRequest.Builder: Builder setSingleDevice(boolean)>,32,33,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(checkNotUsed(), []), AssignmentExpression(=, [VariableReference(this.mSingleDevice, []), Expression(singleDevice, [])]), Statement(return this, []), Statement(}, [])])  Statement({, [])  Statement(checkNotUsed(), [])  AssignmentExpression(=, [VariableReference(this.mSingleDevice, []), Expression(singleDevice, [])])    VariableReference(this.mSingleDevice, [])    Expression(singleDevice, [])  Statement(return this, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(checkNotUsed(), []), AssignmentExpression(=, [VariableReference(this.mSingleDevice, []), Expression(singleDevice, [])]), Statement(return this, []), Statement(}, [])])  Statement({, [])  Statement(checkNotUsed(), [])  AssignmentExpression(=, [VariableReference(this.mSingleDevice, []), Expression(singleDevice, [])])    VariableReference(this.mSingleDevice, [])    Expression(singleDevice, [])  Statement(return this, [])  Statement(}, [])",0,"/**
 * Whether only a single device should match the provided filter.
 *
 * When scanning for a single device with a specifc {@link BluetoothDeviceFilter} mac
 * address, bonded devices are also searched among. This allows to obtain the necessary app
 * privileges even if the device is already paired.
 *
 * @param singleDevice if true, scanning for a device will stop as soon as at least one
 * fitting device is found
 */
","/**
 * Whether only a single device should match the provided filter.
 *
 * When scanning for a single device with a specific {@link BluetoothDeviceFilter} mac
 * address, bonded devices are also searched among. This allows to obtain the necessary app
 * privileges even if the device is already paired.
 *
 * @param singleDevice if true, scanning for a device will stop as soon as at least one
 * fitting device is found
 */
",1,[@NonNull],[@NonNull],0,,,,0,0,0,0,0,There is no change in the method implementation between the two versions.,There is no compatibility issue for the API as the method implementation has not changed.
37,<android.app.Activity: void onLowMemory()>,32,33,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(if (DEBUG_LIFECYCLE), []), MethodCall(Slog.v(TAG, ""onLowMemory "" + this), [VariableReference(Slog, []), Expression(TAG, []), Expression(""onLowMemory "" + this, [])]), AssignmentExpression(=, [VariableReference(mCalled, []), Expression(true, [])]), MethodCall(mFragments.dispatchLowMemory(), [VariableReference(mFragments, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  Statement(if (DEBUG_LIFECYCLE), [])  MethodCall(Slog.v(TAG, ""onLowMemory "" + this), [VariableReference(Slog, []), Expression(TAG, []), Expression(""onLowMemory "" + this, [])])    VariableReference(Slog, [])    Expression(TAG, [])    Expression(""onLowMemory "" + this, [])  AssignmentExpression(=, [VariableReference(mCalled, []), Expression(true, [])])    VariableReference(mCalled, [])    Expression(true, [])  MethodCall(mFragments.dispatchLowMemory(), [VariableReference(mFragments, []), Expression(, [])])    VariableReference(mFragments, [])    Expression(, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (DEBUG_LIFECYCLE), []), MethodCall(Slog.v(TAG, ""onLowMemory "" + this), [VariableReference(Slog, []), Expression(TAG, []), Expression(""onLowMemory "" + this, [])]), AssignmentExpression(=, [VariableReference(mCalled, []), Expression(true, [])]), MethodCall(mFragments.dispatchLowMemory(), [VariableReference(mFragments, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(if (mCallbacksController !, []), Expression(null) {, [])]), MethodCall(mCallbacksController.dispatchLowMemory(), [VariableReference(mCallbacksController, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(if (DEBUG_LIFECYCLE), [])  MethodCall(Slog.v(TAG, ""onLowMemory "" + this), [VariableReference(Slog, []), Expression(TAG, []), Expression(""onLowMemory "" + this, [])])    VariableReference(Slog, [])    Expression(TAG, [])    Expression(""onLowMemory "" + this, [])  AssignmentExpression(=, [VariableReference(mCalled, []), Expression(true, [])])    VariableReference(mCalled, [])    Expression(true, [])  MethodCall(mFragments.dispatchLowMemory(), [VariableReference(mFragments, []), Expression(, [])])    VariableReference(mFragments, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(if (mCallbacksController !, []), Expression(null) {, [])])    VariableReference(if (mCallbacksController !, [])    Expression(null) {, [])  MethodCall(mCallbacksController.dispatchLowMemory(), [VariableReference(mCallbacksController, []), Expression(, [])])    VariableReference(mCallbacksController, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",1,,,0,,,0,,,,"1,2","3,4",0,"3,5",1,The Late_Implementation_AST_Node includes two new statements that are not present in the Early_Implementation_AST_Node. The first new statement is an AssignmentExpression which assigns the value null to a variable if a condition (mCallbacksController != null) is not met. The second new statement is a MethodCall which invokes the dispatchLowMemory() method on mCallbacksController if the condition is met. These new statements are part of the control dependency change (3) and also involve a dependent API change (5).,"The Compatibility Issue (CI) arises from the control dependency change and the dependent API change. The new statements in the Late_Implementation_AST_Node can potentially cause the API to return different values (CI type 1) because the behavior of the API now depends on the value of the mCallbacksController variable. If mCallbacksController is not null, the dispatchLowMemory() method is invoked on it, which can affect the behavior of the API. If mCallbacksController is null, the behavior of the API is the same as in the Early_Implementation_AST_Node. Therefore, the compatibility issue is a potential one and depends on the value of the mCallbacksController variable."
38,"<android.hardware.camera2.params.OutputConfiguration: void writeToParcel(Parcel,int)>",32,33,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (dest, []), Expression(, [])]), Statement(throw new IllegalArgumentException(""dest must not be null""), []), Statement(}, []), MethodCall(dest.writeInt(mRotation), [VariableReference(dest, []), Expression(mRotation, [])]), MethodCall(dest.writeInt(mSurfaceGroupId), [VariableReference(dest, []), Expression(mSurfaceGroupId, [])]), MethodCall(dest.writeInt(mSurfaceType), [VariableReference(dest, []), Expression(mSurfaceType, [])]), MethodCall(dest.writeInt(mConfiguredSize.getWidth()), [VariableReference(dest, []), Expression(mConfiguredSize.getWidth(), [])]), MethodCall(dest.writeInt(mConfiguredSize.getHeight()), [VariableReference(dest, []), Expression(mConfiguredSize.getHeight(), [])]), MethodCall(dest.writeInt(mIsDeferredConfig ? 1 : 0), [VariableReference(dest, []), Expression(mIsDeferredConfig ? 1 : 0, [])]), MethodCall(dest.writeInt(mIsShared ? 1 : 0), [VariableReference(dest, []), Expression(mIsShared ? 1 : 0, [])]), MethodCall(dest.writeTypedList(mSurfaces), [VariableReference(dest, []), Expression(mSurfaces, [])]), MethodCall(dest.writeString(mPhysicalCameraId), [VariableReference(dest, []), Expression(mPhysicalCameraId, [])]), MethodCall(dest.writeInt(mIsMultiResolution ? 1 : 0), [VariableReference(dest, []), Expression(mIsMultiResolution ? 1 : 0, [])]), Statement(// writeList doesn't seem to work well with Integer list., []), MethodCall(dest.writeIntArray(convertIntegerToIntList(mSensorPixelModesUsed)), [VariableReference(dest, []), Expression(convertIntegerToIntList(mSensorPixelModesUsed), [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (dest, []), Expression(, [])])    VariableReference(if (dest, [])    Expression(, [])  Statement(throw new IllegalArgumentException(""dest must not be null""), [])  Statement(}, [])  MethodCall(dest.writeInt(mRotation), [VariableReference(dest, []), Expression(mRotation, [])])    VariableReference(dest, [])    Expression(mRotation, [])  MethodCall(dest.writeInt(mSurfaceGroupId), [VariableReference(dest, []), Expression(mSurfaceGroupId, [])])    VariableReference(dest, [])    Expression(mSurfaceGroupId, [])  MethodCall(dest.writeInt(mSurfaceType), [VariableReference(dest, []), Expression(mSurfaceType, [])])    VariableReference(dest, [])    Expression(mSurfaceType, [])  MethodCall(dest.writeInt(mConfiguredSize.getWidth()), [VariableReference(dest, []), Expression(mConfiguredSize.getWidth(), [])])    VariableReference(dest, [])    Expression(mConfiguredSize.getWidth(), [])  MethodCall(dest.writeInt(mConfiguredSize.getHeight()), [VariableReference(dest, []), Expression(mConfiguredSize.getHeight(), [])])    VariableReference(dest, [])    Expression(mConfiguredSize.getHeight(), [])  MethodCall(dest.writeInt(mIsDeferredConfig ? 1 : 0), [VariableReference(dest, []), Expression(mIsDeferredConfig ? 1 : 0, [])])    VariableReference(dest, [])    Expression(mIsDeferredConfig ? 1 : 0, [])  MethodCall(dest.writeInt(mIsShared ? 1 : 0), [VariableReference(dest, []), Expression(mIsShared ? 1 : 0, [])])    VariableReference(dest, [])    Expression(mIsShared ? 1 : 0, [])  MethodCall(dest.writeTypedList(mSurfaces), [VariableReference(dest, []), Expression(mSurfaces, [])])    VariableReference(dest, [])    Expression(mSurfaces, [])  MethodCall(dest.writeString(mPhysicalCameraId), [VariableReference(dest, []), Expression(mPhysicalCameraId, [])])    VariableReference(dest, [])    Expression(mPhysicalCameraId, [])  MethodCall(dest.writeInt(mIsMultiResolution ? 1 : 0), [VariableReference(dest, []), Expression(mIsMultiResolution ? 1 : 0, [])])    VariableReference(dest, [])    Expression(mIsMultiResolution ? 1 : 0, [])  Statement(// writeList doesn't seem to work well with Integer list., [])  MethodCall(dest.writeIntArray(convertIntegerToIntList(mSensorPixelModesUsed)), [VariableReference(dest, []), Expression(convertIntegerToIntList(mSensorPixelModesUsed), [])])    VariableReference(dest, [])    Expression(convertIntegerToIntList(mSensorPixelModesUsed), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (dest, []), Expression(, [])]), Statement(throw new IllegalArgumentException(""dest must not be null""), []), Statement(}, []), MethodCall(dest.writeInt(mRotation), [VariableReference(dest, []), Expression(mRotation, [])]), MethodCall(dest.writeInt(mSurfaceGroupId), [VariableReference(dest, []), Expression(mSurfaceGroupId, [])]), MethodCall(dest.writeInt(mSurfaceType), [VariableReference(dest, []), Expression(mSurfaceType, [])]), MethodCall(dest.writeInt(mConfiguredSize.getWidth()), [VariableReference(dest, []), Expression(mConfiguredSize.getWidth(), [])]), MethodCall(dest.writeInt(mConfiguredSize.getHeight()), [VariableReference(dest, []), Expression(mConfiguredSize.getHeight(), [])]), MethodCall(dest.writeInt(mIsDeferredConfig ? 1 : 0), [VariableReference(dest, []), Expression(mIsDeferredConfig ? 1 : 0, [])]), MethodCall(dest.writeInt(mIsShared ? 1 : 0), [VariableReference(dest, []), Expression(mIsShared ? 1 : 0, [])]), MethodCall(dest.writeTypedList(mSurfaces), [VariableReference(dest, []), Expression(mSurfaces, [])]), MethodCall(dest.writeString(mPhysicalCameraId), [VariableReference(dest, []), Expression(mPhysicalCameraId, [])]), MethodCall(dest.writeInt(mIsMultiResolution ? 1 : 0), [VariableReference(dest, []), Expression(mIsMultiResolution ? 1 : 0, [])]), Statement(// writeList doesn't seem to work well with Integer list., []), MethodCall(dest.writeIntArray(convertIntegerToIntList(mSensorPixelModesUsed)), [VariableReference(dest, []), Expression(convertIntegerToIntList(mSensorPixelModesUsed), [])]), MethodCall(dest.writeLong(mDynamicRangeProfile), [VariableReference(dest, []), Expression(mDynamicRangeProfile, [])]), MethodCall(dest.writeLong(mStreamUseCase), [VariableReference(dest, []), Expression(mStreamUseCase, [])]), MethodCall(dest.writeInt(mTimestampBase), [VariableReference(dest, []), Expression(mTimestampBase, [])]), MethodCall(dest.writeInt(mMirrorMode), [VariableReference(dest, []), Expression(mMirrorMode, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (dest, []), Expression(, [])])    VariableReference(if (dest, [])    Expression(, [])  Statement(throw new IllegalArgumentException(""dest must not be null""), [])  Statement(}, [])  MethodCall(dest.writeInt(mRotation), [VariableReference(dest, []), Expression(mRotation, [])])    VariableReference(dest, [])    Expression(mRotation, [])  MethodCall(dest.writeInt(mSurfaceGroupId), [VariableReference(dest, []), Expression(mSurfaceGroupId, [])])    VariableReference(dest, [])    Expression(mSurfaceGroupId, [])  MethodCall(dest.writeInt(mSurfaceType), [VariableReference(dest, []), Expression(mSurfaceType, [])])    VariableReference(dest, [])    Expression(mSurfaceType, [])  MethodCall(dest.writeInt(mConfiguredSize.getWidth()), [VariableReference(dest, []), Expression(mConfiguredSize.getWidth(), [])])    VariableReference(dest, [])    Expression(mConfiguredSize.getWidth(), [])  MethodCall(dest.writeInt(mConfiguredSize.getHeight()), [VariableReference(dest, []), Expression(mConfiguredSize.getHeight(), [])])    VariableReference(dest, [])    Expression(mConfiguredSize.getHeight(), [])  MethodCall(dest.writeInt(mIsDeferredConfig ? 1 : 0), [VariableReference(dest, []), Expression(mIsDeferredConfig ? 1 : 0, [])])    VariableReference(dest, [])    Expression(mIsDeferredConfig ? 1 : 0, [])  MethodCall(dest.writeInt(mIsShared ? 1 : 0), [VariableReference(dest, []), Expression(mIsShared ? 1 : 0, [])])    VariableReference(dest, [])    Expression(mIsShared ? 1 : 0, [])  MethodCall(dest.writeTypedList(mSurfaces), [VariableReference(dest, []), Expression(mSurfaces, [])])    VariableReference(dest, [])    Expression(mSurfaces, [])  MethodCall(dest.writeString(mPhysicalCameraId), [VariableReference(dest, []), Expression(mPhysicalCameraId, [])])    VariableReference(dest, [])    Expression(mPhysicalCameraId, [])  MethodCall(dest.writeInt(mIsMultiResolution ? 1 : 0), [VariableReference(dest, []), Expression(mIsMultiResolution ? 1 : 0, [])])    VariableReference(dest, [])    Expression(mIsMultiResolution ? 1 : 0, [])  Statement(// writeList doesn't seem to work well with Integer list., [])  MethodCall(dest.writeIntArray(convertIntegerToIntList(mSensorPixelModesUsed)), [VariableReference(dest, []), Expression(convertIntegerToIntList(mSensorPixelModesUsed), [])])    VariableReference(dest, [])    Expression(convertIntegerToIntList(mSensorPixelModesUsed), [])  MethodCall(dest.writeLong(mDynamicRangeProfile), [VariableReference(dest, []), Expression(mDynamicRangeProfile, [])])    VariableReference(dest, [])    Expression(mDynamicRangeProfile, [])  MethodCall(dest.writeLong(mStreamUseCase), [VariableReference(dest, []), Expression(mStreamUseCase, [])])    VariableReference(dest, [])    Expression(mStreamUseCase, [])  MethodCall(dest.writeInt(mTimestampBase), [VariableReference(dest, []), Expression(mTimestampBase, [])])    VariableReference(dest, [])    Expression(mTimestampBase, [])  MethodCall(dest.writeInt(mMirrorMode), [VariableReference(dest, []), Expression(mMirrorMode, [])])    VariableReference(dest, [])    Expression(mMirrorMode, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,,"1,2",4,0,5,0,"The late version implementation has added four new method calls to write additional data to the `Parcel` object. These new method calls are: `dest.writeLong(mDynamicRangeProfile)`, `dest.writeLong(mStreamUseCase)`, `dest.writeInt(mTimestampBase)`, and `dest.writeInt(mMirrorMode)`.","The added method calls in the late version implementation only write additional data to the `Parcel` object. They do not affect the existing behavior of the method or the data that was already being written to the `Parcel`. Therefore, there are no compatibility issues introduced by this change."
39,<android.os.BaseBundle: ArrayList<Integer> getIntegerArrayList(String)>,32,33,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(unparcel(), []), AssignmentExpression(=, [VariableReference(Object o, []), Expression(mMap.get(key), [])]), AssignmentExpression(=, [VariableReference(if (o, []), Expression(, [])]), Statement(return null, []), Statement(}, []), Statement(try {, []), Statement(return (ArrayList<Integer>) o, []), Statement(} catch (ClassCastException e) {, []), Statement(typeWarning(key, o, ""ArrayList<Integer>"", e), []), Statement(return null, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(unparcel(), [])  AssignmentExpression(=, [VariableReference(Object o, []), Expression(mMap.get(key), [])])    VariableReference(Object o, [])    Expression(mMap.get(key), [])  AssignmentExpression(=, [VariableReference(if (o, []), Expression(, [])])    VariableReference(if (o, [])    Expression(, [])  Statement(return null, [])  Statement(}, [])  Statement(try {, [])  Statement(return (ArrayList<Integer>) o, [])  Statement(} catch (ClassCastException e) {, [])  Statement(typeWarning(key, o, ""ArrayList<Integer>"", e), [])  Statement(return null, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(}, [])])  Statement({, [])  Statement(}, [])",1,"/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return an ArrayList<String> value, or null
 */
","/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return an ArrayList<String> value, or null
 */
",0,[@Nullable],[@Nullable],0,,,,"1,2","1,2,3,4,5","1,2",1,1,"The implementation of the method has been changed completely. The early version uses the 'mMap' object and several statements to get the value associated with the given key, while the late version only has an empty method body.","The code change between the two versions will definitely lead to different behaviors. In the early version, the method will return the value associated with the given key, or null if no mapping of the desired type exists for the given key or a null value is explicitly associated with the key. However, in the late version, the method will always return null, no matter what the given key is. This is a compatibility issue caused by potential different return values."
41,<android.service.dreams.DreamService: void onDreamingStarted()>,32,33,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(if (mDebug), []), MethodCall(Slog.v(TAG, ""onDreamingStarted()""), [VariableReference(Slog, []), Expression(TAG, []), Expression(""onDreamingStarted()"", [])]), Statement(// hook for subclasses, []), Statement(}, [])])  Statement({, [])  Statement(if (mDebug), [])  MethodCall(Slog.v(TAG, ""onDreamingStarted()""), [VariableReference(Slog, []), Expression(TAG, []), Expression(""onDreamingStarted()"", [])])    VariableReference(Slog, [])    Expression(TAG, [])    Expression(""onDreamingStarted()"", [])  Statement(// hook for subclasses, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (mDebug), []), MethodCall(Slog.v(mTag, ""onDreamingStarted()""), [VariableReference(Slog, []), Expression(mTag, []), Expression(""onDreamingStarted()"", [])]), Statement(// hook for subclasses, []), Statement(}, [])])  Statement({, [])  Statement(if (mDebug), [])  MethodCall(Slog.v(mTag, ""onDreamingStarted()""), [VariableReference(Slog, []), Expression(mTag, []), Expression(""onDreamingStarted()"", [])])    VariableReference(Slog, [])    Expression(mTag, [])    Expression(""onDreamingStarted()"", [])  Statement(// hook for subclasses, [])  Statement(}, [])",1,"/**
 * Called when the dream's window has been created and is visible and animation may now begin.
 */
","/**
 * Called when the dream's window has been created and is visible and animation may now begin.
 */
",0,,,0,,,,1,4,0,4,0,"The code change is a modification of a method call in the method body. The method call ""Slog.v(TAG, ""onDreamingStarted()"")"" in the early version has been changed to ""Slog.v(mTag, ""onDreamingStarted()"")"" in the late version. The change only involves a different variable used as an argument in the method call.",This change does not introduce any compatibility issues. The modification of the method call in the method body does not affect the return value or the exception handling of the API. It only changes the logging behavior of the method by using a different variable for the log tag.
42,<android.os.PowerComponents.Builder: double getTotalPower()>,32,33,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(double totalPowerMah, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(mPowerComponentsMah.length - 1, [])]), AssignmentExpression(=, [VariableReference(i >, []), Expression(0, [])]), Statement(i--) {, []), AssignmentExpression(=, [VariableReference(totalPowerMah +, []), Expression(mPowerComponentsMah[i], [])]), Statement(}, []), Statement(return totalPowerMah, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(double totalPowerMah, []), Expression(0, [])])    VariableReference(double totalPowerMah, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(mPowerComponentsMah.length - 1, [])])    VariableReference(for (int i, [])    Expression(mPowerComponentsMah.length - 1, [])  AssignmentExpression(=, [VariableReference(i >, []), Expression(0, [])])    VariableReference(i >, [])    Expression(0, [])  Statement(i--) {, [])  AssignmentExpression(=, [VariableReference(totalPowerMah +, []), Expression(mPowerComponentsMah[i], [])])    VariableReference(totalPowerMah +, [])    Expression(mPowerComponentsMah[i], [])  Statement(}, [])  Statement(return totalPowerMah, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(double totalPowerMah, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(for (int componentId, []), Expression(0, [])]), Statement(componentId < BatteryConsumer.POWER_COMPONENT_COUNT, []), Statement(componentId++) {, []), AssignmentExpression(=, [VariableReference(totalPowerMah +, []), Expression(mData.getDouble(mData.getKeyOrThrow(componentId, PROCESS_STATE_ANY).mPowerColumnIndex), [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < mData.layout.customPowerComponentCount, []), Statement(i++) {, []), AssignmentExpression(=, [VariableReference(totalPowerMah +, []), Expression(mData.getDouble(mData.layout.firstCustomConsumedPowerColumn + i), [])]), Statement(}, []), Statement(return totalPowerMah, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(double totalPowerMah, []), Expression(0, [])])    VariableReference(double totalPowerMah, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(for (int componentId, []), Expression(0, [])])    VariableReference(for (int componentId, [])    Expression(0, [])  Statement(componentId < BatteryConsumer.POWER_COMPONENT_COUNT, [])  Statement(componentId++) {, [])  AssignmentExpression(=, [VariableReference(totalPowerMah +, []), Expression(mData.getDouble(mData.getKeyOrThrow(componentId, PROCESS_STATE_ANY).mPowerColumnIndex), [])])    VariableReference(totalPowerMah +, [])    Expression(mData.getDouble(mData.getKeyOrThrow(componentId, PROCESS_STATE_ANY).mPowerColumnIndex), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < mData.layout.customPowerComponentCount, [])  Statement(i++) {, [])  AssignmentExpression(=, [VariableReference(totalPowerMah +, []), Expression(mData.getDouble(mData.layout.firstCustomConsumedPowerColumn + i), [])])    VariableReference(totalPowerMah +, [])    Expression(mData.getDouble(mData.layout.firstCustomConsumedPowerColumn + i), [])  Statement(}, [])  Statement(return totalPowerMah, [])  Statement(}, [])",1,"/**
 * Returns the total power accumulated by this builder so far. It may change
 * by the time the {@code build()} method is called.
 */
","/**
 * Returns the total power accumulated by this builder so far. It may change
 * by the time the {@code build()} method is called.
 */
",0,,,0,,,,"1,2","1,3,4",1,"3,5",1,The implementation of the method has been completely changed. The original method used a for loop to iterate through the elements of the mPowerComponentsMah array and added each element to the totalPowerMah variable. The new method uses two for loops to iterate through the elements of the mData array and adds the corresponding element to the totalPowerMah variable. The new method also uses the BatteryConsumer.POWER\_COMPONENT\_COUNT constant and the mData.layout.customPowerComponentCount variable to determine the range of the for loops.,"The new method may calculate the total power differently than the original method, which could potentially lead to compatibility issues. For example, if the mData array contains elements that are not present in the mPowerComponentsMah array, or if the mData array contains elements in a different order than the mPowerComponentsMah array, then the total power calculated by the new method may be different than the total power calculated by the original method. This could potentially cause issues for any code that relies on the total power value returned by the getTotalPower() method."
43,<android.hardware.camera2.CameraDevice: void createExtensionSession(ExtensionSessionConfiguration)>,32,33,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(throw new UnsupportedOperationException(""No default implementation""), []), Statement(}, [])])  Statement({, [])  Statement(throw new UnsupportedOperationException(""No default implementation""), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(throw new UnsupportedOperationException(""No default implementation""), []), Statement(}, [])])  Statement({, [])  Statement(throw new UnsupportedOperationException(""No default implementation""), [])  Statement(}, [])",0,"/**
 * Initialize a specific device-specific extension augmented camera capture
 * session.
 *
 * <p>Extension sessions can be used to enable device-specific operation modes like
 * {@link CameraExtensionCharacteristics#EXTENSION_NIGHT} or
 * {@link CameraExtensionCharacteristics#EXTENSION_HDR}. These modes are less flexible than the
 * full camera API, but enable access to more sophisticated processing algorithms that can
 * capture multi-frame bursts to generate single output images. To query for available
 * extensions on this device call
 * {@link CameraExtensionCharacteristics#getSupportedExtensions()}.</p>
 *
 * <p>This method will also trigger the setup of the internal
 * processing pipeline for extension augmented preview and multi-frame
 * still capture.</p>
 *
 * <p>If a prior CameraCaptureSession already exists when this method is called, the previous
 * session will no longer be able to accept new capture requests and will be closed. Any
 * in-progress capture requests made on the prior session will be completed before it's closed.
 * </p>
 *
 * <p>The CameraExtensionSession will be active until the client
 * either calls CameraExtensionSession.close() or creates a new camera
 * capture session. In both cases all internal resources will be
 * released, continuous repeating requests stopped and any pending
 * multi-frame capture requests flushed.</p>
 *
 * <p>Note that the CameraExtensionSession currently supports at most wo
 * multi frame capture surface formats: ImageFormat.JPEG will be supported
 * by all extensions and ImageFormat.YUV_420_888 may or may not be supported.
 * Clients must query the multi-frame capture format support using
 * {@link CameraExtensionCharacteristics#getExtensionSupportedSizes(int, int)}.
 * For repeating requests CameraExtensionSession supports only
 * {@link android.graphics.SurfaceTexture} as output. Clients can query the supported resolution
 * for the repeating request output using
 * {@link CameraExtensionCharacteristics#getExtensionSupportedSizes(int, Class)
 * getExtensionSupportedSizes(..., Class)}.</p>
 *
 * <p>At the very minimum the initialization expects either one valid output
 * surface for repeating or one valid output for high-quality single requests registered in the
 * outputs argument of the extension configuration argument. At the maximum the initialization
 * will accept two valid output surfaces, one for repeating and the other for single requests.
 * Additional unsupported surfaces passed to ExtensionSessionConfiguration will cause an
 * {@link IllegalArgumentException} to be thrown.</p>
 *
 * @param extensionConfiguration extension configuration
 * @throws IllegalArgumentException If both the preview and still
 * capture surfaces are not set or invalid, or if any of the
 * registered surfaces do not meet the device-specific
 * extension requirements such as dimensions and/or
 * (output format)/(surface type), or if the extension is not
 * supported.
 * @see CameraExtensionCharacteristics#getSupportedExtensions
 * @see CameraExtensionCharacteristics#getExtensionSupportedSizes
 */
","/**
 * Initialize a specific device-specific extension augmented camera capture
 * session.
 *
 * <p>Extension sessions can be used to enable device-specific operation modes like
 * {@link CameraExtensionCharacteristics#EXTENSION_NIGHT} or
 * {@link CameraExtensionCharacteristics#EXTENSION_HDR}. These modes are less flexible than the
 * full camera API, but enable access to more sophisticated processing algorithms that can
 * capture multi-frame bursts to generate single output images. To query for available
 * extensions on this device call
 * {@link CameraExtensionCharacteristics#getSupportedExtensions()}.</p>
 *
 * <p>This method will also trigger the setup of the internal
 * processing pipeline for extension augmented preview and multi-frame
 * still capture.</p>
 *
 * <p>If a prior CameraCaptureSession already exists when this method is called, the previous
 * session will no longer be able to accept new capture requests and will be closed. Any
 * in-progress capture requests made on the prior session will be completed before it's closed.
 * </p>
 *
 * <p>The CameraExtensionSession will be active until the client
 * either calls CameraExtensionSession.close() or creates a new camera
 * capture session. In both cases all internal resources will be
 * released, continuous repeating requests stopped and any pending
 * multi-frame capture requests flushed.</p>
 *
 * <p>Note that the CameraExtensionSession currently supports at most wo
 * multi frame capture surface formats: ImageFormat.JPEG will be supported
 * by all extensions and ImageFormat.YUV_420_888 may or may not be supported.
 * Clients must query the multi-frame capture format support using
 * {@link CameraExtensionCharacteristics#getExtensionSupportedSizes(int, int)}.
 * For repeating requests CameraExtensionSession supports only
 * {@link android.graphics.SurfaceTexture} as output. Clients can query the supported resolution
 * for the repeating request output using
 * {@link CameraExtensionCharacteristics#getExtensionSupportedSizes(int, Class)
 * getExtensionSupportedSizes(..., Class)}.</p>
 *
 * <p>At the very minimum the initialization expects either one valid output
 * surface for repeating or one valid output for high-quality single requests registered in the
 * outputs argument of the extension configuration argument. At the maximum the initialization
 * will accept two valid output surfaces, one for repeating and the other for single requests.
 * Additional unsupported surfaces passed to ExtensionSessionConfiguration will cause an
 * {@link IllegalArgumentException} to be thrown.</p>
 *
 * @param extensionConfiguration extension configuration
 * @throws IllegalArgumentException If both the preview and still
 * capture surfaces are not set or invalid, or if any of the
 * registered surfaces do not meet the device-specific
 * extension requirements such as dimensions and/or
 * (output format)/(surface type), or if the extension is not
 * supported, or if any of the output configurations select
 * a dynamic range different from
 * {@link android.hardware.camera2.params.DynamicRangeProfiles#STANDARD},
 * or if any of the output configurations sets a stream use
 * case different from {@link
 * android.hardware.camera2.CameraCharacteristics#SCALER_AVAILABLE_STREAM_USE_CASES_DEFAULT}.
 * @see CameraExtensionCharacteristics#getSupportedExtensions
 * @see CameraExtensionCharacteristics#getExtensionSupportedSizes
 */
",1,,,0,,,,0,0,0,5,2,"The exception handling statement has been changed. In the early version, the method throws an IllegalArgumentException if the extension is not supported. In the late version, the method throws an IllegalArgumentException if the extension is not supported, or if any of the output configurations select a dynamic range different from {@link android.hardware.camera2.params.DynamicRangeProfiles#STANDARD}, or if any of the output configurations sets a stream use case different from {@link android.hardware.camera2.CameraCharacteristics#SCALER_AVAILABLE_STREAM_USE_CASES_DEFAULT}.","The compatibility issue exists because the late version of the method has a more strict requirement for the output configurations. If the client code uses the output configurations that do not meet the requirements, the late version of the method will throw an IllegalArgumentException, while the early version of the method will not. This can cause the client code to fail to work correctly in the late version of the Android platform."
44,"<android.text.TextShaper: void shapeText(CharSequence,int,int,TextDirectionHeuristic,TextPaint,GlyphsConsumer)>",32,33,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(MeasuredParagraph mp, []), Expression(MeasuredParagraph.buildForBidi(text, start, start + count, dir, null), [])]), AssignmentExpression(=, [VariableReference(TextLine tl, []), Expression(TextLine.obtain(), [])]), Statement(try {, []), MethodCall(tl.set(paint, text, start, start + count, mp.getParagraphDir(), mp.getDirections(0, count), [VariableReference(tl, []), Expression(paint, []), Expression(text, []), Expression(start, []), Expression(start + count, []), Expression(mp.getParagraphDir(), []), Expression(mp.getDirections(0, []), Expression(count, [])]), Statement(null, // ellipsis is not supported., []), Statement(-1, // ellipsis is not supported., []), Statement(-1), []), MethodCall(tl.shape(consumer), [VariableReference(tl, []), Expression(consumer, [])]), Statement(} finally {, []), MethodCall(TextLine.recycle(tl), [VariableReference(TextLine, []), Expression(tl, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(MeasuredParagraph mp, []), Expression(MeasuredParagraph.buildForBidi(text, start, start + count, dir, null), [])])    VariableReference(MeasuredParagraph mp, [])    Expression(MeasuredParagraph.buildForBidi(text, start, start + count, dir, null), [])  AssignmentExpression(=, [VariableReference(TextLine tl, []), Expression(TextLine.obtain(), [])])    VariableReference(TextLine tl, [])    Expression(TextLine.obtain(), [])  Statement(try {, [])  MethodCall(tl.set(paint, text, start, start + count, mp.getParagraphDir(), mp.getDirections(0, count), [VariableReference(tl, []), Expression(paint, []), Expression(text, []), Expression(start, []), Expression(start + count, []), Expression(mp.getParagraphDir(), []), Expression(mp.getDirections(0, []), Expression(count, [])])    VariableReference(tl, [])    Expression(paint, [])    Expression(text, [])    Expression(start, [])    Expression(start + count, [])    Expression(mp.getParagraphDir(), [])    Expression(mp.getDirections(0, [])    Expression(count, [])  Statement(null, // ellipsis is not supported., [])  Statement(-1, // ellipsis is not supported., [])  Statement(-1), [])  MethodCall(tl.shape(consumer), [VariableReference(tl, []), Expression(consumer, [])])    VariableReference(tl, [])    Expression(consumer, [])  Statement(} finally {, [])  MethodCall(TextLine.recycle(tl), [VariableReference(TextLine, []), Expression(tl, [])])    VariableReference(TextLine, [])    Expression(tl, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(MeasuredParagraph mp, []), Expression(MeasuredParagraph.buildForBidi(text, start, start + count, dir, null), [])]), AssignmentExpression(=, [VariableReference(TextLine tl, []), Expression(TextLine.obtain(), [])]), Statement(try {, []), MethodCall(tl.set(paint, text, start, start + count, mp.getParagraphDir(), mp.getDirections(0, count), [VariableReference(tl, []), Expression(paint, []), Expression(text, []), Expression(start, []), Expression(start + count, []), Expression(mp.getParagraphDir(), []), Expression(mp.getDirections(0, []), Expression(count, [])]), Statement(null, // ellipsis is not supported., []), Statement(-1, // ellipsis is not supported., []), Statement(-1, false), []), MethodCall(tl.shape(consumer), [VariableReference(tl, []), Expression(consumer, [])]), Statement(} finally {, []), MethodCall(TextLine.recycle(tl), [VariableReference(TextLine, []), Expression(tl, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(MeasuredParagraph mp, []), Expression(MeasuredParagraph.buildForBidi(text, start, start + count, dir, null), [])])    VariableReference(MeasuredParagraph mp, [])    Expression(MeasuredParagraph.buildForBidi(text, start, start + count, dir, null), [])  AssignmentExpression(=, [VariableReference(TextLine tl, []), Expression(TextLine.obtain(), [])])    VariableReference(TextLine tl, [])    Expression(TextLine.obtain(), [])  Statement(try {, [])  MethodCall(tl.set(paint, text, start, start + count, mp.getParagraphDir(), mp.getDirections(0, count), [VariableReference(tl, []), Expression(paint, []), Expression(text, []), Expression(start, []), Expression(start + count, []), Expression(mp.getParagraphDir(), []), Expression(mp.getDirections(0, []), Expression(count, [])])    VariableReference(tl, [])    Expression(paint, [])    Expression(text, [])    Expression(start, [])    Expression(start + count, [])    Expression(mp.getParagraphDir(), [])    Expression(mp.getDirections(0, [])    Expression(count, [])  Statement(null, // ellipsis is not supported., [])  Statement(-1, // ellipsis is not supported., [])  Statement(-1, false), [])  MethodCall(tl.shape(consumer), [VariableReference(tl, []), Expression(consumer, [])])    VariableReference(tl, [])    Expression(consumer, [])  Statement(} finally {, [])  MethodCall(TextLine.recycle(tl), [VariableReference(TextLine, []), Expression(tl, [])])    VariableReference(TextLine, [])    Expression(tl, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Shape multi-styled text.
 *
 * In the LTR context, the shape result will go from left to right, thus you may want to draw
 * glyphs from left most position of the canvas. In the RTL context, the shape result will go
 * from right to left, thus you may want to draw glyphs from right most position of the canvas.
 *
 * @param text a styled text.
 * @param start a start index of shaping target in the text.
 * @param count a length of shaping target in the text.
 * @param dir a text direction.
 * @param paint a paint
 * @param consumer a consumer of the shape result.
 */
","/**
 * Shape multi-styled text.
 *
 * In the LTR context, the shape result will go from left to right, thus you may want to draw
 * glyphs from left most position of the canvas. In the RTL context, the shape result will go
 * from right to left, thus you may want to draw glyphs from right most position of the canvas.
 *
 * @param text a styled text.
 * @param start a start index of shaping target in the text.
 * @param count a length of shaping target in the text.
 * @param dir a text direction.
 * @param paint a paint
 * @param consumer a consumer of the shape result.
 */
",0,,,0,,,,2,5,0,5,0,"The code change is about the value of a constant in the method implementation. In the early version, the value is -1, while in the late version, the value is false. This constant is not used in any other part of the method, so it is a self-contained change.","The change of the value of a constant does not affect the behavior of the method, so there is no compatibility issue."
45,<android.app.admin.DevicePolicyManager: List<ApnSetting> getOverrideApns(ComponentName)>,32,33,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(throwIfParentInstance(""getOverrideApns""), []), AssignmentExpression(=, [VariableReference(if (mService !, []), Expression(null) {, [])]), Statement(try {, []), MethodCall(return mService.getOverrideApns(admin), [VariableReference(return mService, []), Expression(admin, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, []), MethodCall(return Collections.emptyList(), [VariableReference(return Collections, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  Statement(throwIfParentInstance(""getOverrideApns""), [])  AssignmentExpression(=, [VariableReference(if (mService !, []), Expression(null) {, [])])    VariableReference(if (mService !, [])    Expression(null) {, [])  Statement(try {, [])  MethodCall(return mService.getOverrideApns(admin), [VariableReference(return mService, []), Expression(admin, [])])    VariableReference(return mService, [])    Expression(admin, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])  MethodCall(return Collections.emptyList(), [VariableReference(return Collections, []), Expression(, [])])    VariableReference(return Collections, [])    Expression(, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(throwIfParentInstance(""getOverrideApns""), []), AssignmentExpression(=, [VariableReference(if (mService !, []), Expression(null) {, [])]), Statement(try {, []), MethodCall(return mService.getOverrideApns(admin), [VariableReference(return mService, []), Expression(admin, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, []), MethodCall(return Collections.emptyList(), [VariableReference(return Collections, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  Statement(throwIfParentInstance(""getOverrideApns""), [])  AssignmentExpression(=, [VariableReference(if (mService !, []), Expression(null) {, [])])    VariableReference(if (mService !, [])    Expression(null) {, [])  Statement(try {, [])  MethodCall(return mService.getOverrideApns(admin), [VariableReference(return mService, []), Expression(admin, [])])    VariableReference(return mService, [])    Expression(admin, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])  MethodCall(return Collections.emptyList(), [VariableReference(return Collections, []), Expression(, [])])    VariableReference(return Collections, [])    Expression(, [])  Statement(}, [])",0,"/**
 * Called by device owner to get all override APNs inserted by device owner.
 *
 * @param admin which {@link DeviceAdminReceiver} this request is associated with
 * @return A list of override APNs inserted by device owner.
 * @throws SecurityException if {@code admin} is not a device owner.
 *
 * @see #setOverrideApnsEnabled(ComponentName, boolean)
 */
","/**
 * Called by device owner or managed profile owner to get all override APNs inserted by
 * device owner or managed profile owner previously using {@link #addOverrideApn}.
 *
 * @param admin which {@link DeviceAdminReceiver} this request is associated with
 * @return A list of override APNs inserted by device owner.
 * @throws SecurityException if {@code admin} is not a device owner.
 *
 * @see #setOverrideApnsEnabled(ComponentName, boolean)
 */
",1,,,0,,,,0,0,0,0,0,There is no change between the two versions of the API 'getOverrideApns(ComponentName)'.,There is no compatibility issue between the two versions of the API 'getOverrideApns(ComponentName)'.
46,<android.app.admin.DevicePolicyManager: boolean isPreferentialNetworkServiceEnabled()>,32,33,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(throwIfParentInstance(""isPreferentialNetworkServiceEnabled""), []), AssignmentExpression(=, [VariableReference(if (mService, []), Expression(, [])]), Statement(return false, []), Statement(}, []), Statement(try {, []), MethodCall(return mService.isPreferentialNetworkServiceEnabled(myUserId()), [VariableReference(return mService, []), Expression(myUserId(), [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(throwIfParentInstance(""isPreferentialNetworkServiceEnabled""), [])  AssignmentExpression(=, [VariableReference(if (mService, []), Expression(, [])])    VariableReference(if (mService, [])    Expression(, [])  Statement(return false, [])  Statement(}, [])  Statement(try {, [])  MethodCall(return mService.isPreferentialNetworkServiceEnabled(myUserId()), [VariableReference(return mService, []), Expression(myUserId(), [])])    VariableReference(return mService, [])    Expression(myUserId(), [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(throwIfParentInstance(""isPreferentialNetworkServiceEnabled""), []), MethodCall(return getPreferentialNetworkServiceConfigs().stream().anyMatch(c -> c.isEnabled()), [VariableReference(return getPreferentialNetworkServiceConfigs(), []), Expression().anyMatch(c -> c.isEnabled(), [])]), Statement(}, [])])  Statement({, [])  Statement(throwIfParentInstance(""isPreferentialNetworkServiceEnabled""), [])  MethodCall(return getPreferentialNetworkServiceConfigs().stream().anyMatch(c -> c.isEnabled()), [VariableReference(return getPreferentialNetworkServiceConfigs(), []), Expression().anyMatch(c -> c.isEnabled(), [])])    VariableReference(return getPreferentialNetworkServiceConfigs(), [])    Expression().anyMatch(c -> c.isEnabled(), [])  Statement(}, [])",1,"/**
 * Indicates whether preferential network service is enabled.
 *
 * <p>This method can be called by the profile owner of a managed profile.
 *
 * @return whether preferential network service is enabled.
 * @throws SecurityException if the caller is not the profile owner.
 */
","/**
 * Indicates whether preferential network service is enabled.
 *
 * <p> Before Android version {@link android.os.Build.VERSION_CODES#TIRAMISU}:
 * This method can be called by the profile owner of a managed profile.
 * <p> Starting from Android version {@link android.os.Build.VERSION_CODES#TIRAMISU}:
 * This method can be called by the profile owner of a managed profile
 * or device owner.
 *
 * @return whether preferential network service is enabled.
 * @throws SecurityException if the caller is not the profile owner or device owner.
 */
",1,,,0,,,,"1,2","1,2,3,4","1,2","1,5","1,2","The return statement has changed from 'return mService.isPreferentialNetworkServiceEnabled(myUserId())' to 'return getPreferentialNetworkServiceConfigs().stream().anyMatch(c -> c.isEnabled())'. Also, the try-catch block has been removed, which indicates the exception handling statement has changed. The change of both return statement and exception handling statement will potentially lead to different behaviors in the late version.","The return statement in the late version uses a different approach to check whether preferential network service is enabled. It is possible that the new approach will return a different value from the old one. Additionally, the removal of the try-catch block means that the late version will not throw the exception 'RemoteException' anymore, which is a difference in exception handling behavior."
47,"<android.service.autofill.Dataset.Builder: Builder setValue(AutofillId,AutofillValue,RemoteViews,InlinePresentation)>",32,33,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(throwIfDestroyed(), []), MethodCall(Preconditions.checkNotNull(presentation, ""presentation cannot be null""), [VariableReference(Preconditions, []), Expression(presentation, []), Expression(""presentation cannot be null"", [])]), MethodCall(Preconditions.checkNotNull(inlinePresentation, ""inlinePresentation cannot be null""), [VariableReference(Preconditions, []), Expression(inlinePresentation, []), Expression(""inlinePresentation cannot be null"", [])]), Statement(setLifeTheUniverseAndEverything(id, value, presentation, inlinePresentation, null), []), Statement(return this, []), Statement(}, [])])  Statement({, [])  Statement(throwIfDestroyed(), [])  MethodCall(Preconditions.checkNotNull(presentation, ""presentation cannot be null""), [VariableReference(Preconditions, []), Expression(presentation, []), Expression(""presentation cannot be null"", [])])    VariableReference(Preconditions, [])    Expression(presentation, [])    Expression(""presentation cannot be null"", [])  MethodCall(Preconditions.checkNotNull(inlinePresentation, ""inlinePresentation cannot be null""), [VariableReference(Preconditions, []), Expression(inlinePresentation, []), Expression(""inlinePresentation cannot be null"", [])])    VariableReference(Preconditions, [])    Expression(inlinePresentation, [])    Expression(""inlinePresentation cannot be null"", [])  Statement(setLifeTheUniverseAndEverything(id, value, presentation, inlinePresentation, null), [])  Statement(return this, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(throwIfDestroyed(), []), MethodCall(Objects.requireNonNull(presentation, ""presentation cannot be null""), [VariableReference(Objects, []), Expression(presentation, []), Expression(""presentation cannot be null"", [])]), MethodCall(Objects.requireNonNull(inlinePresentation, ""inlinePresentation cannot be null""), [VariableReference(Objects, []), Expression(inlinePresentation, []), Expression(""inlinePresentation cannot be null"", [])]), Statement(setLifeTheUniverseAndEverything(id, value, presentation, inlinePresentation, null, null, null), []), Statement(return this, []), Statement(}, [])])  Statement({, [])  Statement(throwIfDestroyed(), [])  MethodCall(Objects.requireNonNull(presentation, ""presentation cannot be null""), [VariableReference(Objects, []), Expression(presentation, []), Expression(""presentation cannot be null"", [])])    VariableReference(Objects, [])    Expression(presentation, [])    Expression(""presentation cannot be null"", [])  MethodCall(Objects.requireNonNull(inlinePresentation, ""inlinePresentation cannot be null""), [VariableReference(Objects, []), Expression(inlinePresentation, []), Expression(""inlinePresentation cannot be null"", [])])    VariableReference(Objects, [])    Expression(inlinePresentation, [])    Expression(""inlinePresentation cannot be null"", [])  Statement(setLifeTheUniverseAndEverything(id, value, presentation, inlinePresentation, null, null, null), [])  Statement(return this, [])  Statement(}, [])",1,"/**
 * Sets the value of a field, using a custom {@link RemoteViews presentation} to
 * visualize it and an {@link InlinePresentation} to visualize it as an inline suggestion.
 *
 * <p><b>Note:</b> If the dataset requires authentication but the service knows its text
 * value it's easier to filter by calling
 * {@link #setValue(AutofillId, AutofillValue, RemoteViews)} and using the value to filter.
 *
 * @param id id returned by {@link
 * android.app.assist.AssistStructure.ViewNode#getAutofillId()}.
 * @param value the value to be autofilled. Pass {@code null} if you do not have the value
 * but the target view is a logical part of the dataset. For example, if
 * the dataset needs authentication and you have no access to the value.
 * @param presentation the presentation used to visualize this field.
 * @param inlinePresentation The {@link InlinePresentation} used to visualize this dataset
 * as inline suggestions. If the dataset supports inline suggestions,
 * this should not be null.
 *
 * @throws IllegalStateException if {@link #build()} was already called.
 *
 * @return this builder.
 */
","/**
 * Sets the value of a field, using a custom {@link RemoteViews presentation} to
 * visualize it and an {@link InlinePresentation} to visualize it as an inline suggestion.
 *
 * <p><b>Note:</b> If the dataset requires authentication but the service knows its text
 * value it's easier to filter by calling
 * {@link #setValue(AutofillId, AutofillValue, RemoteViews)} and using the value to filter.
 *
 * @param id id returned by {@link
 * android.app.assist.AssistStructure.ViewNode#getAutofillId()}.
 * @param value the value to be autofilled. Pass {@code null} if you do not have the value
 * but the target view is a logical part of the dataset. For example, if
 * the dataset needs authentication and you have no access to the value.
 * @param presentation the presentation used to visualize this field.
 * @param inlinePresentation The {@link InlinePresentation} used to visualize this dataset
 * as inline suggestions. If the dataset supports inline suggestions,
 * this should not be null.
 *
 * @throws IllegalStateException if {@link #build()} was already called.
 *
 * @return this builder.
 * @deprecated Use {@link #setField(AutofillId, Field)} instead.
 */
",1,[@NonNull],"[@Deprecated, @NonNull]",1,,,,2,"1,5",1,"1,4,5",1,- Two method calls using `Preconditions.checkNotNull()` have been replaced with `Objects.requireNonNull()`. This is a change in dependent API (change type 5).,
48,"<android.widget.RemoteViews.ViewGroupActionAdd: void apply(View,ViewGroup,InteractionHandler,ColorResources)>",32,33,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final Context context, []), Expression(root.getContext(), [])]), AssignmentExpression(=, [VariableReference(final ViewGroup target, []), Expression(root.findViewById(viewId), [])]), AssignmentExpression(=, [VariableReference(if (target, []), Expression(, [])]), Statement(return, []), Statement(}, []), Statement(// If removeAllViews was called, this returns the next potential recycled view., []), Statement(// If there are no more views to recycle (or removeAllViews was not called), this, []), Statement(// will return -1., []), AssignmentExpression(=, [VariableReference(final int nextChild, []), Expression(getNextRecyclableChild(target), [])]), AssignmentExpression(=, [VariableReference(RemoteViews rvToApply, []), Expression(mNestedViews.getRemoteViewsToApply(context), [])]), AssignmentExpression(=, [VariableReference(if (nextChild >, []), Expression(0 && mStableId !, [])]), Statement(// At that point, the views starting at index nextChild are the ones recyclable but, []), Statement(// not yet recycled. All views added on that round of application are placed before., []), Statement(// Find the next view with the same stable id, or -1., []), AssignmentExpression(=, [VariableReference(int recycledViewIndex, []), Expression(findViewIndexToRecycle(target, rvToApply), [])]), AssignmentExpression(=, [VariableReference(if (recycledViewIndex >, []), Expression(0) {, [])]), AssignmentExpression(=, [VariableReference(View child, []), Expression(target.getChildAt(recycledViewIndex), [])]), MethodCall(if (rvToApply.canRecycleView(child)), [VariableReference(if (rvToApply, []), Expression(child), [])]), Statement(if (nextChild < recycledViewIndex) {, []), MethodCall(target.removeViews(nextChild, recycledViewIndex - nextChild), [VariableReference(target, []), Expression(nextChild, []), Expression(recycledViewIndex - nextChild, [])]), Statement(}, []), MethodCall(setNextRecyclableChild(target, nextChild + 1, target.getChildCount()), [VariableReference(setNextRecyclableChild(target, nextChild + 1, target, []), Expression(), [])]), Statement(colorResources, false), []), Statement(return, []), Statement(}, []), Statement(// If we cannot recycle the views, we still remove all views in between to, []), Statement(// avoid weird behaviors and insert the new view in place of the old one., []), MethodCall(target.removeViews(nextChild, recycledViewIndex - nextChild + 1), [VariableReference(target, []), Expression(nextChild, []), Expression(recycledViewIndex - nextChild + 1, [])]), Statement(}, []), Statement(}, []), Statement(// If we cannot recycle, insert the new view before the next recyclable child., []), Statement(// Inflate nested views and add as children, []), AssignmentExpression(=, [VariableReference(View nestedView, []), Expression(rvToApply.apply(context, target, handler, null, /* size */, [])]), Statement(colorResources), []), AssignmentExpression(=, [VariableReference(if (mStableId !, []), Expression(NO_ID) {, [])]), Statement(setStableId(nestedView, mStableId), []), Statement(}, []), AssignmentExpression(=, [VariableReference(target.addView(nestedView, mIndex >, []), Expression(0 ? mIndex : nextChild), [])]), AssignmentExpression(=, [VariableReference(if (nextChild >, []), Expression(0) {, [])]), Statement(// If we are at the end, there is no reason to try to recycle anymore, []), MethodCall(setNextRecyclableChild(target, nextChild + 1, target.getChildCount()), [VariableReference(setNextRecyclableChild(target, nextChild + 1, target, []), Expression(), [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final Context context, []), Expression(root.getContext(), [])])    VariableReference(final Context context, [])    Expression(root.getContext(), [])  AssignmentExpression(=, [VariableReference(final ViewGroup target, []), Expression(root.findViewById(viewId), [])])    VariableReference(final ViewGroup target, [])    Expression(root.findViewById(viewId), [])  AssignmentExpression(=, [VariableReference(if (target, []), Expression(, [])])    VariableReference(if (target, [])    Expression(, [])  Statement(return, [])  Statement(}, [])  Statement(// If removeAllViews was called, this returns the next potential recycled view., [])  Statement(// If there are no more views to recycle (or removeAllViews was not called), this, [])  Statement(// will return -1., [])  AssignmentExpression(=, [VariableReference(final int nextChild, []), Expression(getNextRecyclableChild(target), [])])    VariableReference(final int nextChild, [])    Expression(getNextRecyclableChild(target), [])  AssignmentExpression(=, [VariableReference(RemoteViews rvToApply, []), Expression(mNestedViews.getRemoteViewsToApply(context), [])])    VariableReference(RemoteViews rvToApply, [])    Expression(mNestedViews.getRemoteViewsToApply(context), [])  AssignmentExpression(=, [VariableReference(if (nextChild >, []), Expression(0 && mStableId !, [])])    VariableReference(if (nextChild >, [])    Expression(0 && mStableId !, [])  Statement(// At that point, the views starting at index nextChild are the ones recyclable but, [])  Statement(// not yet recycled. All views added on that round of application are placed before., [])  Statement(// Find the next view with the same stable id, or -1., [])  AssignmentExpression(=, [VariableReference(int recycledViewIndex, []), Expression(findViewIndexToRecycle(target, rvToApply), [])])    VariableReference(int recycledViewIndex, [])    Expression(findViewIndexToRecycle(target, rvToApply), [])  AssignmentExpression(=, [VariableReference(if (recycledViewIndex >, []), Expression(0) {, [])])    VariableReference(if (recycledViewIndex >, [])    Expression(0) {, [])  AssignmentExpression(=, [VariableReference(View child, []), Expression(target.getChildAt(recycledViewIndex), [])])    VariableReference(View child, [])    Expression(target.getChildAt(recycledViewIndex), [])  MethodCall(if (rvToApply.canRecycleView(child)), [VariableReference(if (rvToApply, []), Expression(child), [])])    VariableReference(if (rvToApply, [])    Expression(child), [])  Statement(if (nextChild < recycledViewIndex) {, [])  MethodCall(target.removeViews(nextChild, recycledViewIndex - nextChild), [VariableReference(target, []), Expression(nextChild, []), Expression(recycledViewIndex - nextChild, [])])    VariableReference(target, [])    Expression(nextChild, [])    Expression(recycledViewIndex - nextChild, [])  Statement(}, [])  MethodCall(setNextRecyclableChild(target, nextChild + 1, target.getChildCount()), [VariableReference(setNextRecyclableChild(target, nextChild + 1, target, []), Expression(), [])])    VariableReference(setNextRecyclableChild(target, nextChild + 1, target, [])    Expression(), [])  Statement(colorResources, false), [])  Statement(return, [])  Statement(}, [])  Statement(// If we cannot recycle the views, we still remove all views in between to, [])  Statement(// avoid weird behaviors and insert the new view in place of the old one., [])  MethodCall(target.removeViews(nextChild, recycledViewIndex - nextChild + 1), [VariableReference(target, []), Expression(nextChild, []), Expression(recycledViewIndex - nextChild + 1, [])])    VariableReference(target, [])    Expression(nextChild, [])    Expression(recycledViewIndex - nextChild + 1, [])  Statement(}, [])  Statement(}, [])  Statement(// If we cannot recycle, insert the new view before the next recyclable child., [])  Statement(// Inflate nested views and add as children, [])  AssignmentExpression(=, [VariableReference(View nestedView, []), Expression(rvToApply.apply(context, target, handler, null, /* size */, [])])    VariableReference(View nestedView, [])    Expression(rvToApply.apply(context, target, handler, null, /* size */, [])  Statement(colorResources), [])  AssignmentExpression(=, [VariableReference(if (mStableId !, []), Expression(NO_ID) {, [])])    VariableReference(if (mStableId !, [])    Expression(NO_ID) {, [])  Statement(setStableId(nestedView, mStableId), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(target.addView(nestedView, mIndex >, []), Expression(0 ? mIndex : nextChild), [])])    VariableReference(target.addView(nestedView, mIndex >, [])    Expression(0 ? mIndex : nextChild), [])  AssignmentExpression(=, [VariableReference(if (nextChild >, []), Expression(0) {, [])])    VariableReference(if (nextChild >, [])    Expression(0) {, [])  Statement(// If we are at the end, there is no reason to try to recycle anymore, [])  MethodCall(setNextRecyclableChild(target, nextChild + 1, target.getChildCount()), [VariableReference(setNextRecyclableChild(target, nextChild + 1, target, []), Expression(), [])])    VariableReference(setNextRecyclableChild(target, nextChild + 1, target, [])    Expression(), [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final Context context, []), Expression(root.getContext(), [])]), AssignmentExpression(=, [VariableReference(final ViewGroup target, []), Expression(root.findViewById(viewId), [])]), AssignmentExpression(=, [VariableReference(if (target, []), Expression(, [])]), Statement(return, []), Statement(}, []), Statement(// If removeAllViews was called, this returns the next potential recycled view., []), Statement(// If there are no more views to recycle (or removeAllViews was not called), this, []), Statement(// will return -1., []), AssignmentExpression(=, [VariableReference(final int nextChild, []), Expression(getNextRecyclableChild(target), [])]), AssignmentExpression(=, [VariableReference(RemoteViews rvToApply, []), Expression(mNestedViews.getRemoteViewsToApply(context), [])]), AssignmentExpression(=, [VariableReference(int flagsToPropagate, []), Expression(mApplyFlags & FLAG_MASK_TO_PROPAGATE, [])]), AssignmentExpression(=, [VariableReference(if (flagsToPropagate !, []), Expression(0), [])]), MethodCall(rvToApply.addFlags(flagsToPropagate), [VariableReference(rvToApply, []), Expression(flagsToPropagate, [])]), AssignmentExpression(=, [VariableReference(if (nextChild >, []), Expression(0 && mStableId !, [])]), Statement(// At that point, the views starting at index nextChild are the ones recyclable but, []), Statement(// not yet recycled. All views added on that round of application are placed before., []), Statement(// Find the next view with the same stable id, or -1., []), AssignmentExpression(=, [VariableReference(int recycledViewIndex, []), Expression(findViewIndexToRecycle(target, rvToApply), [])]), AssignmentExpression(=, [VariableReference(if (recycledViewIndex >, []), Expression(0) {, [])]), AssignmentExpression(=, [VariableReference(View child, []), Expression(target.getChildAt(recycledViewIndex), [])]), MethodCall(if (rvToApply.canRecycleView(child)), [VariableReference(if (rvToApply, []), Expression(child), [])]), Statement(if (nextChild < recycledViewIndex) {, []), MethodCall(target.removeViews(nextChild, recycledViewIndex - nextChild), [VariableReference(target, []), Expression(nextChild, []), Expression(recycledViewIndex - nextChild, [])]), Statement(}, []), MethodCall(setNextRecyclableChild(target, nextChild + 1, target.getChildCount()), [VariableReference(setNextRecyclableChild(target, nextChild + 1, target, []), Expression(), [])]), Statement(colorResources), []), Statement(return, []), Statement(}, []), Statement(// If we cannot recycle the views, we still remove all views in between to, []), Statement(// avoid weird behaviors and insert the new view in place of the old one., []), MethodCall(target.removeViews(nextChild, recycledViewIndex - nextChild + 1), [VariableReference(target, []), Expression(nextChild, []), Expression(recycledViewIndex - nextChild + 1, [])]), Statement(}, []), Statement(}, []), Statement(// If we cannot recycle, insert the new view before the next recyclable child., []), Statement(// Inflate nested views and add as children, []), AssignmentExpression(=, [VariableReference(View nestedView, []), Expression(rvToApply.applyNestedViews(context, target, rootParent, handler, null, /* size */, [])]), Statement(colorResources), []), AssignmentExpression(=, [VariableReference(if (mStableId !, []), Expression(NO_ID) {, [])]), Statement(setStableId(nestedView, mStableId), []), Statement(}, []), AssignmentExpression(=, [VariableReference(target.addView(nestedView, mIndex >, []), Expression(0 ? mIndex : nextChild), [])]), AssignmentExpression(=, [VariableReference(if (nextChild >, []), Expression(0) {, [])]), Statement(// If we are at the end, there is no reason to try to recycle anymore, []), MethodCall(setNextRecyclableChild(target, nextChild + 1, target.getChildCount()), [VariableReference(setNextRecyclableChild(target, nextChild + 1, target, []), Expression(), [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final Context context, []), Expression(root.getContext(), [])])    VariableReference(final Context context, [])    Expression(root.getContext(), [])  AssignmentExpression(=, [VariableReference(final ViewGroup target, []), Expression(root.findViewById(viewId), [])])    VariableReference(final ViewGroup target, [])    Expression(root.findViewById(viewId), [])  AssignmentExpression(=, [VariableReference(if (target, []), Expression(, [])])    VariableReference(if (target, [])    Expression(, [])  Statement(return, [])  Statement(}, [])  Statement(// If removeAllViews was called, this returns the next potential recycled view., [])  Statement(// If there are no more views to recycle (or removeAllViews was not called), this, [])  Statement(// will return -1., [])  AssignmentExpression(=, [VariableReference(final int nextChild, []), Expression(getNextRecyclableChild(target), [])])    VariableReference(final int nextChild, [])    Expression(getNextRecyclableChild(target), [])  AssignmentExpression(=, [VariableReference(RemoteViews rvToApply, []), Expression(mNestedViews.getRemoteViewsToApply(context), [])])    VariableReference(RemoteViews rvToApply, [])    Expression(mNestedViews.getRemoteViewsToApply(context), [])  AssignmentExpression(=, [VariableReference(int flagsToPropagate, []), Expression(mApplyFlags & FLAG_MASK_TO_PROPAGATE, [])])    VariableReference(int flagsToPropagate, [])    Expression(mApplyFlags & FLAG_MASK_TO_PROPAGATE, [])  AssignmentExpression(=, [VariableReference(if (flagsToPropagate !, []), Expression(0), [])])    VariableReference(if (flagsToPropagate !, [])    Expression(0), [])  MethodCall(rvToApply.addFlags(flagsToPropagate), [VariableReference(rvToApply, []), Expression(flagsToPropagate, [])])    VariableReference(rvToApply, [])    Expression(flagsToPropagate, [])  AssignmentExpression(=, [VariableReference(if (nextChild >, []), Expression(0 && mStableId !, [])])    VariableReference(if (nextChild >, [])    Expression(0 && mStableId !, [])  Statement(// At that point, the views starting at index nextChild are the ones recyclable but, [])  Statement(// not yet recycled. All views added on that round of application are placed before., [])  Statement(// Find the next view with the same stable id, or -1., [])  AssignmentExpression(=, [VariableReference(int recycledViewIndex, []), Expression(findViewIndexToRecycle(target, rvToApply), [])])    VariableReference(int recycledViewIndex, [])    Expression(findViewIndexToRecycle(target, rvToApply), [])  AssignmentExpression(=, [VariableReference(if (recycledViewIndex >, []), Expression(0) {, [])])    VariableReference(if (recycledViewIndex >, [])    Expression(0) {, [])  AssignmentExpression(=, [VariableReference(View child, []), Expression(target.getChildAt(recycledViewIndex), [])])    VariableReference(View child, [])    Expression(target.getChildAt(recycledViewIndex), [])  MethodCall(if (rvToApply.canRecycleView(child)), [VariableReference(if (rvToApply, []), Expression(child), [])])    VariableReference(if (rvToApply, [])    Expression(child), [])  Statement(if (nextChild < recycledViewIndex) {, [])  MethodCall(target.removeViews(nextChild, recycledViewIndex - nextChild), [VariableReference(target, []), Expression(nextChild, []), Expression(recycledViewIndex - nextChild, [])])    VariableReference(target, [])    Expression(nextChild, [])    Expression(recycledViewIndex - nextChild, [])  Statement(}, [])  MethodCall(setNextRecyclableChild(target, nextChild + 1, target.getChildCount()), [VariableReference(setNextRecyclableChild(target, nextChild + 1, target, []), Expression(), [])])    VariableReference(setNextRecyclableChild(target, nextChild + 1, target, [])    Expression(), [])  Statement(colorResources), [])  Statement(return, [])  Statement(}, [])  Statement(// If we cannot recycle the views, we still remove all views in between to, [])  Statement(// avoid weird behaviors and insert the new view in place of the old one., [])  MethodCall(target.removeViews(nextChild, recycledViewIndex - nextChild + 1), [VariableReference(target, []), Expression(nextChild, []), Expression(recycledViewIndex - nextChild + 1, [])])    VariableReference(target, [])    Expression(nextChild, [])    Expression(recycledViewIndex - nextChild + 1, [])  Statement(}, [])  Statement(}, [])  Statement(// If we cannot recycle, insert the new view before the next recyclable child., [])  Statement(// Inflate nested views and add as children, [])  AssignmentExpression(=, [VariableReference(View nestedView, []), Expression(rvToApply.applyNestedViews(context, target, rootParent, handler, null, /* size */, [])])    VariableReference(View nestedView, [])    Expression(rvToApply.applyNestedViews(context, target, rootParent, handler, null, /* size */, [])  Statement(colorResources), [])  AssignmentExpression(=, [VariableReference(if (mStableId !, []), Expression(NO_ID) {, [])])    VariableReference(if (mStableId !, [])    Expression(NO_ID) {, [])  Statement(setStableId(nestedView, mStableId), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(target.addView(nestedView, mIndex >, []), Expression(0 ? mIndex : nextChild), [])])    VariableReference(target.addView(nestedView, mIndex >, [])    Expression(0 ? mIndex : nextChild), [])  AssignmentExpression(=, [VariableReference(if (nextChild >, []), Expression(0) {, [])])    VariableReference(if (nextChild >, [])    Expression(0) {, [])  Statement(// If we are at the end, there is no reason to try to recycle anymore, [])  MethodCall(setNextRecyclableChild(target, nextChild + 1, target.getChildCount()), [VariableReference(setNextRecyclableChild(target, nextChild + 1, target, []), Expression(), [])])    VariableReference(setNextRecyclableChild(target, nextChild + 1, target, [])    Expression(), [])  Statement(}, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,,"1,2","3,4,5",1,"1,3,4","1,2",The code change includes the following aspects:,"3. Control dependency changed: In the late version, a new variable ""flagsToPropagate"" is introduced, and the value of this variable will affect the execution of the method ""rvToApply.addFlags(flagsToPropagate)""."
49,<android.view.contentcapture.ContentCaptureSession: void notifyViewDisappeared(AutofillId)>,32,33,,,,"MethodDeclaration(method_body, [Statement({, []), MethodCall(Preconditions.checkNotNull(id), [VariableReference(Preconditions, []), Expression(id, [])]), Statement(if (!isContentCaptureEnabled()), []), Statement(return, []), Statement(internalNotifyViewDisappeared(id), []), Statement(}, [])])  Statement({, [])  MethodCall(Preconditions.checkNotNull(id), [VariableReference(Preconditions, []), Expression(id, [])])    VariableReference(Preconditions, [])    Expression(id, [])  Statement(if (!isContentCaptureEnabled()), [])  Statement(return, [])  Statement(internalNotifyViewDisappeared(id), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(Objects.requireNonNull(id), [VariableReference(Objects, []), Expression(id, [])]), Statement(if (!isContentCaptureEnabled()), []), Statement(return, []), Statement(internalNotifyViewDisappeared(id), []), Statement(}, [])])  Statement({, [])  MethodCall(Objects.requireNonNull(id), [VariableReference(Objects, []), Expression(id, [])])    VariableReference(Objects, [])    Expression(id, [])  Statement(if (!isContentCaptureEnabled()), [])  Statement(return, [])  Statement(internalNotifyViewDisappeared(id), [])  Statement(}, [])",1,"/**
 * Notifies the Content Capture Service that a node has been removed from the view structure.
 *
 * <p>Typically called ""manually"" by views that handle their own virtual view hierarchy, or
 * automatically by the Android System for standard views.
 *
 * @param id id of the node that has been removed.
 */
","/**
 * Notifies the Content Capture Service that a node has been removed from the view structure.
 *
 * <p>Typically called ""manually"" by views that handle their own virtual view hierarchy, or
 * automatically by the Android System for standard views.
 *
 * @param id id of the node that has been removed.
 */
",0,,,0,,,,2,5,0,5,0,The method call for null-checking the input parameter 'id' has been changed from 'Preconditions.checkNotNull(id)' to 'Objects.requireNonNull(id)'. This indicates that the null-checking library or method has been updated or changed in the later version.,"The change in null-checking method does not affect the functionality or behavior of the 'notifyViewDisappeared(AutofillId)' method. Therefore, there is no compatibility issue (CI) caused by this change."
50,"<android.webkit.WebView: String[] getHttpAuthUsernamePassword(String,String)>",27,28,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(checkThread(), []), MethodCall(return mProvider.getHttpAuthUsernamePassword(host, realm), [VariableReference(return mProvider, []), Expression(host, []), Expression(realm, [])]), Statement(}, [])])  Statement({, [])  Statement(checkThread(), [])  MethodCall(return mProvider.getHttpAuthUsernamePassword(host, realm), [VariableReference(return mProvider, []), Expression(host, []), Expression(realm, [])])    VariableReference(return mProvider, [])    Expression(host, [])    Expression(realm, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(checkThread(), []), MethodCall(return mProvider.getHttpAuthUsernamePassword(host, realm), [VariableReference(return mProvider, []), Expression(host, []), Expression(realm, [])]), Statement(}, [])])  Statement({, [])  Statement(checkThread(), [])  MethodCall(return mProvider.getHttpAuthUsernamePassword(host, realm), [VariableReference(return mProvider, []), Expression(host, []), Expression(realm, [])])    VariableReference(return mProvider, [])    Expression(host, [])    Expression(realm, [])  Statement(}, [])",0,"/**
 * Retrieves HTTP authentication credentials for a given host and realm from the {@link
 * WebViewDatabase} instance.
 * @param host the host to which the credentials apply
 * @param realm the realm to which the credentials apply
 * @return the credentials as a String array, if found. The first element
 * is the username and the second element is the password. Null if
 * no credentials are found.
 * @deprecated Use {@link WebViewDatabase#getHttpAuthUsernamePassword} instead
 */
","/**
 * Retrieves HTTP authentication credentials for a given host and realm from the {@link
 * WebViewDatabase} instance.
 * @param host the host to which the credentials apply
 * @param realm the realm to which the credentials apply
 * @return the credentials as a String array, if found. The first element
 * is the username and the second element is the password. {@code null} if
 * no credentials are found.
 * @deprecated Use {@link WebViewDatabase#getHttpAuthUsernamePassword} instead
 */
",1,[@Deprecated],"[@Deprecated, @Nullable]",1,,,,0,0,0,4,1,"The annotation of the API has changed from ""@Deprecated"" to ""@Deprecated, @Nullable"". This means that the return value of the API may be null in the late version, while it was not explicitly indicated in the early version.","The change in the annotation of the API may lead to different behaviors in the client code that uses this API. In the late version, the client code must handle the case where the API returns a null value, while in the early version, the client code may not have been designed to handle this case. This can cause compatibility issues if the client code is not updated to handle the null return value."
51,<android.widget.TextView: void setText(int)>,27,28,,,,"MethodDeclaration(method_body, [Statement({, []), MethodCall(setText(getContext().getResources().getText(resid)), [VariableReference(setText(getContext(), []), Expression().getText(resid), [])]), AssignmentExpression(=, [VariableReference(mTextFromResource, []), Expression(true, [])]), Statement(}, [])])  Statement({, [])  MethodCall(setText(getContext().getResources().getText(resid)), [VariableReference(setText(getContext(), []), Expression().getText(resid), [])])    VariableReference(setText(getContext(), [])    Expression().getText(resid), [])  AssignmentExpression(=, [VariableReference(mTextFromResource, []), Expression(true, [])])    VariableReference(mTextFromResource, [])    Expression(true, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(setText(getContext().getResources().getText(resid)), [VariableReference(setText(getContext(), []), Expression().getText(resid), [])]), AssignmentExpression(=, [VariableReference(mTextSetFromXmlOrResourceId, []), Expression(true, [])]), AssignmentExpression(=, [VariableReference(mTextId, []), Expression(resid, [])]), Statement(}, [])])  Statement({, [])  MethodCall(setText(getContext().getResources().getText(resid)), [VariableReference(setText(getContext(), []), Expression().getText(resid), [])])    VariableReference(setText(getContext(), [])    Expression().getText(resid), [])  AssignmentExpression(=, [VariableReference(mTextSetFromXmlOrResourceId, []), Expression(true, [])])    VariableReference(mTextSetFromXmlOrResourceId, [])    Expression(true, [])  AssignmentExpression(=, [VariableReference(mTextId, []), Expression(resid, [])])    VariableReference(mTextId, [])    Expression(resid, [])  Statement(}, [])",1,"/**
 * Sets the text to be displayed using a string resource identifier.
 *
 * @param resid the resource identifier of the string resource to be displayed
 *
 * @see #setText(CharSequence)
 *
 * @attr ref android.R.styleable#TextView_text
 */
","/**
 * Sets the text to be displayed using a string resource identifier.
 *
 * @param resid the resource identifier of the string resource to be displayed
 *
 * @see #setText(CharSequence)
 *
 * @attr ref android.R.styleable#TextView_text
 */
",0,[@android.view.RemotableViewMethod],[@android.view.RemotableViewMethod],0,,,,1,4,1,"4,5",1,"There are two assignment statements in the late version, while there is only one in the early version. The variables involved in the assignment statements are also different.","The different assignment statements may lead to different values of the variables, which may further affect the behavior of the API and cause compatibility issues."
52,<android.view.inputmethod.InputMethodManager: boolean switchToLastInputMethod(IBinder)>,27,28,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(synchronized (mH) {, []), Statement(try {, []), MethodCall(return mService.switchToLastInputMethod(imeToken), [VariableReference(return mService, []), Expression(imeToken, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(synchronized (mH) {, [])  Statement(try {, [])  MethodCall(return mService.switchToLastInputMethod(imeToken), [VariableReference(return mService, []), Expression(imeToken, [])])    VariableReference(return mService, [])    Expression(imeToken, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return switchToPreviousInputMethodInternal(imeToken), []), Statement(}, [])])  Statement({, [])  Statement(return switchToPreviousInputMethodInternal(imeToken), [])  Statement(}, [])",1,"/**
 * Force switch to the last used input method and subtype. If the last input method didn't have
 * any subtypes, the framework will simply switch to the last input method with no subtype
 * specified.
 * @param imeToken Supplies the identifying token given to an input method when it was started,
 * which allows it to perform this operation on itself.
 * @return true if the current input method and subtype was successfully switched to the last
 * used input method and subtype.
 */
","/**
 * Force switch to the last used input method and subtype. If the last input method didn't have
 * any subtypes, the framework will simply switch to the last input method with no subtype
 * specified.
 * @param imeToken Supplies the identifying token given to an input method when it was started,
 * which allows it to perform this operation on itself.
 * @return true if the current input method and subtype was successfully switched to the last
 * used input method and subtype.
 * @deprecated Use {@link InputMethodService#switchToPreviousInputMethod()} instead. This method
 * was intended for IME developers who should be accessing APIs through the service. APIs in
 * this class are intended for app developers interacting with the IME.
 */
",1,,[@Deprecated],1,,,,"1,2","1,2,5","1,2","1,5",1,"The early version uses the method ""mService.switchToLastInputMethod(imeToken)"" to switch to the last input method and subtype, while the late version uses the method ""switchToPreviousInputMethodInternal(imeToken)"" to achieve the same goal. This change is considered as a ""Dependent API changed"" since the method used to switch to the last input method and subtype has been changed. Additionally, the late version has been annotated with ""@Deprecated"" which indicates that this method is no longer recommended for use and may be removed in a future version.","This change may lead to compatibility issues if the app developer is still using the old method ""mService.switchToLastInputMethod(imeToken)"" to switch to the last input method and subtype. The app may not function as expected or may throw an exception if the old method is no longer available in a future version. Therefore, it is recommended for the app developer to use the new method ""InputMethodService#switchToPreviousInputMethod()"" instead."
53,<android.net.IpSecManager.UdpEncapsulationSocket: void close()>,27,28,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(mService.closeUdpEncapsulationSocket(mResourceId), [VariableReference(mService, []), Expression(mResourceId, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(try {, []), MethodCall(mPfd.close(), [VariableReference(mPfd, []), Expression(, [])]), Statement(} catch (IOException e) {, []), AssignmentExpression(=, [VariableReference(Log.e(TAG, ""Failed to close UDP Encapsulation Socket with Port, []), Expression("" + mPort), [])]), Statement(throw e, []), Statement(}, []), MethodCall(mCloseGuard.close(), [VariableReference(mCloseGuard, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(mService.closeUdpEncapsulationSocket(mResourceId), [VariableReference(mService, []), Expression(mResourceId, [])])    VariableReference(mService, [])    Expression(mResourceId, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(try {, [])  MethodCall(mPfd.close(), [VariableReference(mPfd, []), Expression(, [])])    VariableReference(mPfd, [])    Expression(, [])  Statement(} catch (IOException e) {, [])  AssignmentExpression(=, [VariableReference(Log.e(TAG, ""Failed to close UDP Encapsulation Socket with Port, []), Expression("" + mPort), [])])    VariableReference(Log.e(TAG, ""Failed to close UDP Encapsulation Socket with Port, [])    Expression("" + mPort), [])  Statement(throw e, [])  Statement(}, [])  MethodCall(mCloseGuard.close(), [VariableReference(mCloseGuard, []), Expression(, [])])    VariableReference(mCloseGuard, [])    Expression(, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(mService.closeUdpEncapsulationSocket(mResourceId), [VariableReference(mService, []), Expression(mResourceId, [])]), AssignmentExpression(=, [VariableReference(mResourceId, []), Expression(INVALID_RESOURCE_ID, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(} catch (Exception e) {, []), Statement(// On close we swallow all random exceptions since failure to close is not, []), Statement(// actionable by the user., []), AssignmentExpression(=, [VariableReference(Log.e(TAG, ""Failed to close "" + this + "", Exception, []), Expression("" + e), [])]), Statement(} finally {, []), AssignmentExpression(=, [VariableReference(mResourceId, []), Expression(INVALID_RESOURCE_ID, [])]), MethodCall(mCloseGuard.close(), [VariableReference(mCloseGuard, []), Expression(, [])]), Statement(}, []), Statement(try {, []), MethodCall(mPfd.close(), [VariableReference(mPfd, []), Expression(, [])]), Statement(} catch (IOException e) {, []), AssignmentExpression(=, [VariableReference(Log.e(TAG, ""Failed to close UDP Encapsulation Socket with Port, []), Expression("" + mPort), [])]), Statement(throw e, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(mService.closeUdpEncapsulationSocket(mResourceId), [VariableReference(mService, []), Expression(mResourceId, [])])    VariableReference(mService, [])    Expression(mResourceId, [])  AssignmentExpression(=, [VariableReference(mResourceId, []), Expression(INVALID_RESOURCE_ID, [])])    VariableReference(mResourceId, [])    Expression(INVALID_RESOURCE_ID, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(} catch (Exception e) {, [])  Statement(// On close we swallow all random exceptions since failure to close is not, [])  Statement(// actionable by the user., [])  AssignmentExpression(=, [VariableReference(Log.e(TAG, ""Failed to close "" + this + "", Exception, []), Expression("" + e), [])])    VariableReference(Log.e(TAG, ""Failed to close "" + this + "", Exception, [])    Expression("" + e), [])  Statement(} finally {, [])  AssignmentExpression(=, [VariableReference(mResourceId, []), Expression(INVALID_RESOURCE_ID, [])])    VariableReference(mResourceId, [])    Expression(INVALID_RESOURCE_ID, [])  MethodCall(mCloseGuard.close(), [VariableReference(mCloseGuard, []), Expression(, [])])    VariableReference(mCloseGuard, [])    Expression(, [])  Statement(}, [])  Statement(try {, [])  MethodCall(mPfd.close(), [VariableReference(mPfd, []), Expression(, [])])    VariableReference(mPfd, [])    Expression(, [])  Statement(} catch (IOException e) {, [])  AssignmentExpression(=, [VariableReference(Log.e(TAG, ""Failed to close UDP Encapsulation Socket with Port, []), Expression("" + mPort), [])])    VariableReference(Log.e(TAG, ""Failed to close UDP Encapsulation Socket with Port, [])    Expression("" + mPort), [])  Statement(throw e, [])  Statement(}, [])  Statement(}, [])",1,,"/**
 * Close this socket.
 *
 * <p>This closes the wrapped socket. Open encapsulation sockets count against a user's
 * resource limits, and forgetting to close them eventually will result in {@link
 * ResourceUnavailableException} being thrown.
 */
",1,[@Override],[@Override],0,,,,"1,2","2,4,5",2,"2,3,4",2,"The exception handling statement has changed, a new exception handling statement is introduced, and a new statement is added to the finally block.","The new exception handling statement swallows all exceptions, which means that any exception that occurs in this method will not be propagated to the caller. This can lead to different behaviors in the caller, as it might not be able to handle the exception or it might not be aware that an exception has occurred. Therefore, it is a compatibility issue."
54,<android.webkit.WebView: WebBackForwardList restoreState(Bundle)>,27,28,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(checkThread(), []), MethodCall(return mProvider.restoreState(inState), [VariableReference(return mProvider, []), Expression(inState, [])]), Statement(}, [])])  Statement({, [])  Statement(checkThread(), [])  MethodCall(return mProvider.restoreState(inState), [VariableReference(return mProvider, []), Expression(inState, [])])    VariableReference(return mProvider, [])    Expression(inState, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(checkThread(), []), MethodCall(return mProvider.restoreState(inState), [VariableReference(return mProvider, []), Expression(inState, [])]), Statement(}, [])])  Statement({, [])  Statement(checkThread(), [])  MethodCall(return mProvider.restoreState(inState), [VariableReference(return mProvider, []), Expression(inState, [])])    VariableReference(return mProvider, [])    Expression(inState, [])  Statement(}, [])",0,"/**
 * Restores the state of this WebView from the given Bundle. This method is
 * intended for use in {@link android.app.Activity#onRestoreInstanceState}
 * and should be called to restore the state of this WebView. If
 * it is called after this WebView has had a chance to build state (load
 * pages, create a back/forward list, etc.) there may be undesirable
 * side-effects. Please note that this method no longer restores the
 * display data for this WebView.
 *
 * @param inState the incoming Bundle of state
 * @return the restored back/forward list or null if restoreState failed
 */
","/**
 * Restores the state of this WebView from the given Bundle. This method is
 * intended for use in {@link android.app.Activity#onRestoreInstanceState}
 * and should be called to restore the state of this WebView. If
 * it is called after this WebView has had a chance to build state (load
 * pages, create a back/forward list, etc.) there may be undesirable
 * side-effects. Please note that this method no longer restores the
 * display data for this WebView.
 *
 * @param inState the incoming Bundle of state
 * @return the restored back/forward list or {@code null} if restoreState failed
 */
",1,,[@Nullable],1,,,,0,0,0,5,1,"The code change between the two versions is that the return type of the method has changed. In the early version, it is not annotated, while in the late version, it is annotated with `@Nullable`.","The change of the return type annotation could potentially lead to different behaviors. In the late version, if the method returns null, the caller will be aware of it and handle it accordingly. However, in the early version, the caller might not be aware of the null return and could encounter a NullPointerException."
55,<android.widget.TextView: void setElegantTextHeight(boolean)>,27,28,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (elegant !, []), Expression(mTextPaint.isElegantTextHeight()) {, [])]), MethodCall(mTextPaint.setElegantTextHeight(elegant), [VariableReference(mTextPaint, []), Expression(elegant, [])]), AssignmentExpression(=, [VariableReference(if (mLayout !, []), Expression(null) {, [])]), Statement(nullLayouts(), []), Statement(requestLayout(), []), Statement(invalidate(), []), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (elegant !, []), Expression(mTextPaint.isElegantTextHeight()) {, [])])    VariableReference(if (elegant !, [])    Expression(mTextPaint.isElegantTextHeight()) {, [])  MethodCall(mTextPaint.setElegantTextHeight(elegant), [VariableReference(mTextPaint, []), Expression(elegant, [])])    VariableReference(mTextPaint, [])    Expression(elegant, [])  AssignmentExpression(=, [VariableReference(if (mLayout !, []), Expression(null) {, [])])    VariableReference(if (mLayout !, [])    Expression(null) {, [])  Statement(nullLayouts(), [])  Statement(requestLayout(), [])  Statement(invalidate(), [])  Statement(}, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (elegant !, []), Expression(mTextPaint.isElegantTextHeight()) {, [])]), MethodCall(mTextPaint.setElegantTextHeight(elegant), [VariableReference(mTextPaint, []), Expression(elegant, [])]), AssignmentExpression(=, [VariableReference(if (mLayout !, []), Expression(null) {, [])]), Statement(nullLayouts(), []), Statement(requestLayout(), []), Statement(invalidate(), []), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (elegant !, []), Expression(mTextPaint.isElegantTextHeight()) {, [])])    VariableReference(if (elegant !, [])    Expression(mTextPaint.isElegantTextHeight()) {, [])  MethodCall(mTextPaint.setElegantTextHeight(elegant), [VariableReference(mTextPaint, []), Expression(elegant, [])])    VariableReference(mTextPaint, [])    Expression(elegant, [])  AssignmentExpression(=, [VariableReference(if (mLayout !, []), Expression(null) {, [])])    VariableReference(if (mLayout !, [])    Expression(null) {, [])  Statement(nullLayouts(), [])  Statement(requestLayout(), [])  Statement(invalidate(), [])  Statement(}, [])  Statement(}, [])  Statement(}, [])",0,"/**
 * Set the TextView's elegant height metrics flag. This setting selects font
 * variants that have not been compacted to fit Latin-based vertical
 * metrics, and also increases top and bottom bounds to provide more space.
 *
 * @param elegant set the paint's elegant metrics flag.
 *
 * @attr ref android.R.styleable#TextView_elegantTextHeight
 */
","/**
 * Set the TextView's elegant height metrics flag. This setting selects font
 * variants that have not been compacted to fit Latin-based vertical
 * metrics, and also increases top and bottom bounds to provide more space.
 *
 * @param elegant set the paint's elegant metrics flag.
 *
 * @see #isElegantTextHeight()
 * @see Paint#isElegantTextHeight()
 *
 * @attr ref android.R.styleable#TextView_elegantTextHeight
 */
",1,,,0,,,,0,0,0,0,0,"The implementation ASTs are the same, and the only difference is that the late version has added two lines of comments to the early version.","Since there are no changes in the implementation code, the behavior of the API in the two versions is the same, and no compatibility issues exist."
56,<android.widget.Toast.TN: void handleHide()>,27,28,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(if (localLOGV), []), AssignmentExpression(=, [VariableReference(Log.v(TAG, ""HANDLE HIDE: "" + this + "" mView, []), Expression("" + mView), [])]), AssignmentExpression(=, [VariableReference(if (mView !, []), Expression(null) {, [])]), Statement(// the view isn't yet added, so let's try not to crash., []), AssignmentExpression(=, [VariableReference(if (mView.getParent() !, []), Expression(null) {, [])]), Statement(if (localLOGV), []), MethodCall(Log.v(TAG, ""REMOVE! "" + mView + "" in "" + this), [VariableReference(Log, []), Expression(TAG, []), Expression(""REMOVE! "" + mView + "" in "" + this, [])]), MethodCall(mWM.removeViewImmediate(mView), [VariableReference(mWM, []), Expression(mView, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(mView, []), Expression(null, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(if (localLOGV), [])  AssignmentExpression(=, [VariableReference(Log.v(TAG, ""HANDLE HIDE: "" + this + "" mView, []), Expression("" + mView), [])])    VariableReference(Log.v(TAG, ""HANDLE HIDE: "" + this + "" mView, [])    Expression("" + mView), [])  AssignmentExpression(=, [VariableReference(if (mView !, []), Expression(null) {, [])])    VariableReference(if (mView !, [])    Expression(null) {, [])  Statement(// the view isn't yet added, so let's try not to crash., [])  AssignmentExpression(=, [VariableReference(if (mView.getParent() !, []), Expression(null) {, [])])    VariableReference(if (mView.getParent() !, [])    Expression(null) {, [])  Statement(if (localLOGV), [])  MethodCall(Log.v(TAG, ""REMOVE! "" + mView + "" in "" + this), [VariableReference(Log, []), Expression(TAG, []), Expression(""REMOVE! "" + mView + "" in "" + this, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""REMOVE! "" + mView + "" in "" + this, [])  MethodCall(mWM.removeViewImmediate(mView), [VariableReference(mWM, []), Expression(mView, [])])    VariableReference(mWM, [])    Expression(mView, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mView, []), Expression(null, [])])    VariableReference(mView, [])    Expression(null, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (localLOGV), []), AssignmentExpression(=, [VariableReference(Log.v(TAG, ""HANDLE HIDE: "" + this + "" mView, []), Expression("" + mView), [])]), AssignmentExpression(=, [VariableReference(if (mView !, []), Expression(null) {, [])]), Statement(// the view isn't yet added, so let's try not to crash., []), AssignmentExpression(=, [VariableReference(if (mView.getParent() !, []), Expression(null) {, [])]), Statement(if (localLOGV), []), MethodCall(Log.v(TAG, ""REMOVE! "" + mView + "" in "" + this), [VariableReference(Log, []), Expression(TAG, []), Expression(""REMOVE! "" + mView + "" in "" + this, [])]), MethodCall(mWM.removeViewImmediate(mView), [VariableReference(mWM, []), Expression(mView, [])]), Statement(}, []), Statement(// the resources., []), Statement(try {, []), MethodCall(getService().finishToken(mPackageName, this), [VariableReference(getService(), []), Expression(mPackageName, []), Expression(this, [])]), Statement(} catch (RemoteException e) {, []), Statement(}, []), AssignmentExpression(=, [VariableReference(mView, []), Expression(null, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(if (localLOGV), [])  AssignmentExpression(=, [VariableReference(Log.v(TAG, ""HANDLE HIDE: "" + this + "" mView, []), Expression("" + mView), [])])    VariableReference(Log.v(TAG, ""HANDLE HIDE: "" + this + "" mView, [])    Expression("" + mView), [])  AssignmentExpression(=, [VariableReference(if (mView !, []), Expression(null) {, [])])    VariableReference(if (mView !, [])    Expression(null) {, [])  Statement(// the view isn't yet added, so let's try not to crash., [])  AssignmentExpression(=, [VariableReference(if (mView.getParent() !, []), Expression(null) {, [])])    VariableReference(if (mView.getParent() !, [])    Expression(null) {, [])  Statement(if (localLOGV), [])  MethodCall(Log.v(TAG, ""REMOVE! "" + mView + "" in "" + this), [VariableReference(Log, []), Expression(TAG, []), Expression(""REMOVE! "" + mView + "" in "" + this, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""REMOVE! "" + mView + "" in "" + this, [])  MethodCall(mWM.removeViewImmediate(mView), [VariableReference(mWM, []), Expression(mView, [])])    VariableReference(mWM, [])    Expression(mView, [])  Statement(}, [])  Statement(// the resources., [])  Statement(try {, [])  MethodCall(getService().finishToken(mPackageName, this), [VariableReference(getService(), []), Expression(mPackageName, []), Expression(this, [])])    VariableReference(getService(), [])    Expression(mPackageName, [])    Expression(this, [])  Statement(} catch (RemoteException e) {, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mView, []), Expression(null, [])])    VariableReference(mView, [])    Expression(null, [])  Statement(}, [])  Statement(}, [])",1,,,0,,,0,,,,"1,2","2,4",2,"2,5","1,2","The code change between the early and late version involves the addition of a new try-catch block and a method call within it. This try-catch block is added after the method call to `mWM.removeViewImmediate(mView)` and before the assignment of `null` to `mView`. The method call added within the try-catch block is `getService().finishToken(mPackageName, this)`.","The addition of the new try-catch block and the method call `getService().finishToken(mPackageName, this)` can potentially lead to compatibility issues. If the `getService()` method or the `finishToken()` method undergoes any changes in their signatures or behaviors, it can result in the `handleHide()` method behaving differently or throwing different exceptions. Additionally, the introduction of the new try-catch block can also lead to different exception handling behaviors in the late version of the `handleHide()` method."
57,"<android.provider.Settings.System: boolean putString(ContentResolver,String,String)>",27,28,,,,"MethodDeclaration(method_body, [Statement({, []), MethodCall(return putStringForUser(resolver, name, value, UserHandle.myUserId()), [VariableReference(return putStringForUser(resolver, name, value, UserHandle, []), Expression(), [])]), Statement(}, [])])  Statement({, [])  MethodCall(return putStringForUser(resolver, name, value, UserHandle.myUserId()), [VariableReference(return putStringForUser(resolver, name, value, UserHandle, []), Expression(), [])])    VariableReference(return putStringForUser(resolver, name, value, UserHandle, [])    Expression(), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(return putStringForUser(resolver, name, value, resolver.getUserId()), [VariableReference(return putStringForUser(resolver, name, value, resolver, []), Expression(), [])]), Statement(}, [])])  Statement({, [])  MethodCall(return putStringForUser(resolver, name, value, resolver.getUserId()), [VariableReference(return putStringForUser(resolver, name, value, resolver, []), Expression(), [])])    VariableReference(return putStringForUser(resolver, name, value, resolver, [])    Expression(), [])  Statement(}, [])",1,"/**
 * Store a name/value pair into the database.
 * @param resolver to access the database with
 * @param name to store
 * @param value to associate with the name
 * @return true if the value was set, false on database errors
 */
","/**
 * Store a name/value pair into the database.
 * @param resolver to access the database with
 * @param name to store
 * @param value to associate with the name
 * @return true if the value was set, false on database errors
 */
",0,,,0,,,,"1,2","1,5",1,5,1,"The argument of the method ""putStringForUser"" has been changed from ""UserHandle.myUserId()"" to ""resolver.getUserId()"" in the return statement. As a result, the return value of the method may be different if the user IDs obtained by these two methods are not the same.","The Compatibility Issue is caused by the potential different return values or types, as the user IDs obtained by the two methods may not be the same, which may lead to the method storing the name/value pair into the database for different users."
58,"<android.webkit.WebChromeClient: void onReceivedTouchIconUrl(WebView,String,boolean)>",27,28,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(}, [])])  Statement({, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(}, [])])  Statement({, [])  Statement(}, [])",0,"/**
 * Notify the host application of the url for an apple-touch-icon.
 * @param view The WebView that initiated the callback.
 * @param url The icon url.
 * @param precomposed True if the url is for a precomposed touch icon.
 */
","/**
 * Notify the host application of the url for an apple-touch-icon.
 * @param view The WebView that initiated the callback.
 * @param url The icon url.
 * @param precomposed {@code true} if the url is for a precomposed touch icon.
 */
",1,,,0,,,,0,0,0,0,0,There is no code change between the two versions of the given API.,There is no Compatibility Issue that exists for the given API.
59,"<android.bluetooth.le.ScanFilter.Builder: Builder setServiceUuid(ParcelUuid,ParcelUuid)>",27,28,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mUuidMask !, []), Expression(null && mServiceUuid, [])]), Statement(throw new IllegalArgumentException(""uuid is null while uuidMask is not null!""), []), Statement(}, []), AssignmentExpression(=, [VariableReference(mServiceUuid, []), Expression(serviceUuid, [])]), AssignmentExpression(=, [VariableReference(mUuidMask, []), Expression(uuidMask, [])]), Statement(return this, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mUuidMask !, []), Expression(null && mServiceUuid, [])])    VariableReference(if (mUuidMask !, [])    Expression(null && mServiceUuid, [])  Statement(throw new IllegalArgumentException(""uuid is null while uuidMask is not null!""), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mServiceUuid, []), Expression(serviceUuid, [])])    VariableReference(mServiceUuid, [])    Expression(serviceUuid, [])  AssignmentExpression(=, [VariableReference(mUuidMask, []), Expression(uuidMask, [])])    VariableReference(mUuidMask, [])    Expression(uuidMask, [])  Statement(return this, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mUuidMask !, []), Expression(null && mServiceUuid, [])]), Statement(throw new IllegalArgumentException(""uuid is null while uuidMask is not null!""), []), Statement(}, []), AssignmentExpression(=, [VariableReference(mServiceUuid, []), Expression(serviceUuid, [])]), AssignmentExpression(=, [VariableReference(mUuidMask, []), Expression(uuidMask, [])]), Statement(return this, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mUuidMask !, []), Expression(null && mServiceUuid, [])])    VariableReference(if (mUuidMask !, [])    Expression(null && mServiceUuid, [])  Statement(throw new IllegalArgumentException(""uuid is null while uuidMask is not null!""), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mServiceUuid, []), Expression(serviceUuid, [])])    VariableReference(mServiceUuid, [])    Expression(serviceUuid, [])  AssignmentExpression(=, [VariableReference(mUuidMask, []), Expression(uuidMask, [])])    VariableReference(mUuidMask, [])    Expression(uuidMask, [])  Statement(return this, [])  Statement(}, [])",0,"/**
 * Set filter on partial service uuid. The {@code uuidMask} is the bit mask for the
 * {@code serviceUuid}. Set any bit in the mask to 1 to indicate a match is needed for the
 * bit in {@code serviceUuid}, and 0 to ignore that bit.
 *
 * @throws IllegalArgumentException If {@code serviceUuid} is {@code null} but
 * {@code uuidMask} is not {@code null}.
 */
","/**
 * Set filter on partial service uuid. The {@code uuidMask} is the bit mask for the
 * {@code serviceUuid}. Set any bit in the mask to 1 to indicate a match is needed for the
 * bit in {@code serviceUuid}, and 0 to ignore that bit.
 *
 * @throws IllegalArgumentException If {@code serviceUuid} is {@code null} but {@code
 * uuidMask} is not {@code null}.
 */
",1,,,0,,,,0,0,0,0,0,"There is no change in the code, comments, and annotations of the API.","Since there is no change in the code, comments, and annotations of the API, there are no compatibility issues."
60,"<android.app.usage.NetworkStatsManager: NetworkStats queryDetailsForUid(int,String,long,long,int)>",27,28,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(}, [])])  Statement({, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(}, [])])  Statement({, [])  Statement(}, [])",1,"/**
 * Query network usage statistics details for a given uid.
 *
 * #see queryDetailsForUidTag(int, String, long, long, int, int)
 */
","/**
 * Query network usage statistics details for a given uid.
 *
 * #see queryDetailsForUidTagState(int, String, long, long, int, int, int)
 */
",1,,,0,,,,"1,2","1,5",1,5,0,"The comment has changed, from 'queryDetailsForUidTag(int, String, long, long, int, int)' to 'queryDetailsForUidTagState(int, String, long, long, int, int, int)'. This indicates that the dependent API of the current method has changed, specifically, the method name and the number of parameters.",No Compatibility Issue exists for the API. The change of the dependent API does not have an impact on the current API's return values or exception handlings.
61,<android.net.NetworkStats.Entry: String toString()>,27,28,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final StringBuilder builder, []), Expression(new StringBuilder(), [])]), AssignmentExpression(=, [VariableReference(builder.append(""iface, []), Expression("").append(iface), [])]), AssignmentExpression(=, [VariableReference(builder.append("" uid, []), Expression("").append(uid), [])]), AssignmentExpression(=, [VariableReference(builder.append("" set, []), Expression("").append(setToString(set)), [])]), AssignmentExpression(=, [VariableReference(builder.append("" tag, []), Expression("").append(tagToString(tag)), [])]), AssignmentExpression(=, [VariableReference(builder.append("" metered, []), Expression("").append(meteredToString(metered)), [])]), AssignmentExpression(=, [VariableReference(builder.append("" roaming, []), Expression("").append(roamingToString(roaming)), [])]), AssignmentExpression(=, [VariableReference(builder.append("" rxBytes, []), Expression("").append(rxBytes), [])]), AssignmentExpression(=, [VariableReference(builder.append("" rxPackets, []), Expression("").append(rxPackets), [])]), AssignmentExpression(=, [VariableReference(builder.append("" txBytes, []), Expression("").append(txBytes), [])]), AssignmentExpression(=, [VariableReference(builder.append("" txPackets, []), Expression("").append(txPackets), [])]), AssignmentExpression(=, [VariableReference(builder.append("" operations, []), Expression("").append(operations), [])]), MethodCall(return builder.toString(), [VariableReference(return builder, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final StringBuilder builder, []), Expression(new StringBuilder(), [])])    VariableReference(final StringBuilder builder, [])    Expression(new StringBuilder(), [])  AssignmentExpression(=, [VariableReference(builder.append(""iface, []), Expression("").append(iface), [])])    VariableReference(builder.append(""iface, [])    Expression("").append(iface), [])  AssignmentExpression(=, [VariableReference(builder.append("" uid, []), Expression("").append(uid), [])])    VariableReference(builder.append("" uid, [])    Expression("").append(uid), [])  AssignmentExpression(=, [VariableReference(builder.append("" set, []), Expression("").append(setToString(set)), [])])    VariableReference(builder.append("" set, [])    Expression("").append(setToString(set)), [])  AssignmentExpression(=, [VariableReference(builder.append("" tag, []), Expression("").append(tagToString(tag)), [])])    VariableReference(builder.append("" tag, [])    Expression("").append(tagToString(tag)), [])  AssignmentExpression(=, [VariableReference(builder.append("" metered, []), Expression("").append(meteredToString(metered)), [])])    VariableReference(builder.append("" metered, [])    Expression("").append(meteredToString(metered)), [])  AssignmentExpression(=, [VariableReference(builder.append("" roaming, []), Expression("").append(roamingToString(roaming)), [])])    VariableReference(builder.append("" roaming, [])    Expression("").append(roamingToString(roaming)), [])  AssignmentExpression(=, [VariableReference(builder.append("" rxBytes, []), Expression("").append(rxBytes), [])])    VariableReference(builder.append("" rxBytes, [])    Expression("").append(rxBytes), [])  AssignmentExpression(=, [VariableReference(builder.append("" rxPackets, []), Expression("").append(rxPackets), [])])    VariableReference(builder.append("" rxPackets, [])    Expression("").append(rxPackets), [])  AssignmentExpression(=, [VariableReference(builder.append("" txBytes, []), Expression("").append(txBytes), [])])    VariableReference(builder.append("" txBytes, [])    Expression("").append(txBytes), [])  AssignmentExpression(=, [VariableReference(builder.append("" txPackets, []), Expression("").append(txPackets), [])])    VariableReference(builder.append("" txPackets, [])    Expression("").append(txPackets), [])  AssignmentExpression(=, [VariableReference(builder.append("" operations, []), Expression("").append(operations), [])])    VariableReference(builder.append("" operations, [])    Expression("").append(operations), [])  MethodCall(return builder.toString(), [VariableReference(return builder, []), Expression(, [])])    VariableReference(return builder, [])    Expression(, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final StringBuilder builder, []), Expression(new StringBuilder(), [])]), AssignmentExpression(=, [VariableReference(builder.append(""iface, []), Expression("").append(iface), [])]), AssignmentExpression(=, [VariableReference(builder.append("" uid, []), Expression("").append(uid), [])]), AssignmentExpression(=, [VariableReference(builder.append("" set, []), Expression("").append(setToString(set)), [])]), AssignmentExpression(=, [VariableReference(builder.append("" tag, []), Expression("").append(tagToString(tag)), [])]), AssignmentExpression(=, [VariableReference(builder.append("" metered, []), Expression("").append(meteredToString(metered)), [])]), AssignmentExpression(=, [VariableReference(builder.append("" roaming, []), Expression("").append(roamingToString(roaming)), [])]), AssignmentExpression(=, [VariableReference(builder.append("" defaultNetwork, []), Expression("").append(defaultNetworkToString(defaultNetwork)), [])]), AssignmentExpression(=, [VariableReference(builder.append("" rxBytes, []), Expression("").append(rxBytes), [])]), AssignmentExpression(=, [VariableReference(builder.append("" rxPackets, []), Expression("").append(rxPackets), [])]), AssignmentExpression(=, [VariableReference(builder.append("" txBytes, []), Expression("").append(txBytes), [])]), AssignmentExpression(=, [VariableReference(builder.append("" txPackets, []), Expression("").append(txPackets), [])]), AssignmentExpression(=, [VariableReference(builder.append("" operations, []), Expression("").append(operations), [])]), MethodCall(return builder.toString(), [VariableReference(return builder, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final StringBuilder builder, []), Expression(new StringBuilder(), [])])    VariableReference(final StringBuilder builder, [])    Expression(new StringBuilder(), [])  AssignmentExpression(=, [VariableReference(builder.append(""iface, []), Expression("").append(iface), [])])    VariableReference(builder.append(""iface, [])    Expression("").append(iface), [])  AssignmentExpression(=, [VariableReference(builder.append("" uid, []), Expression("").append(uid), [])])    VariableReference(builder.append("" uid, [])    Expression("").append(uid), [])  AssignmentExpression(=, [VariableReference(builder.append("" set, []), Expression("").append(setToString(set)), [])])    VariableReference(builder.append("" set, [])    Expression("").append(setToString(set)), [])  AssignmentExpression(=, [VariableReference(builder.append("" tag, []), Expression("").append(tagToString(tag)), [])])    VariableReference(builder.append("" tag, [])    Expression("").append(tagToString(tag)), [])  AssignmentExpression(=, [VariableReference(builder.append("" metered, []), Expression("").append(meteredToString(metered)), [])])    VariableReference(builder.append("" metered, [])    Expression("").append(meteredToString(metered)), [])  AssignmentExpression(=, [VariableReference(builder.append("" roaming, []), Expression("").append(roamingToString(roaming)), [])])    VariableReference(builder.append("" roaming, [])    Expression("").append(roamingToString(roaming)), [])  AssignmentExpression(=, [VariableReference(builder.append("" defaultNetwork, []), Expression("").append(defaultNetworkToString(defaultNetwork)), [])])    VariableReference(builder.append("" defaultNetwork, [])    Expression("").append(defaultNetworkToString(defaultNetwork)), [])  AssignmentExpression(=, [VariableReference(builder.append("" rxBytes, []), Expression("").append(rxBytes), [])])    VariableReference(builder.append("" rxBytes, [])    Expression("").append(rxBytes), [])  AssignmentExpression(=, [VariableReference(builder.append("" rxPackets, []), Expression("").append(rxPackets), [])])    VariableReference(builder.append("" rxPackets, [])    Expression("").append(rxPackets), [])  AssignmentExpression(=, [VariableReference(builder.append("" txBytes, []), Expression("").append(txBytes), [])])    VariableReference(builder.append("" txBytes, [])    Expression("").append(txBytes), [])  AssignmentExpression(=, [VariableReference(builder.append("" txPackets, []), Expression("").append(txPackets), [])])    VariableReference(builder.append("" txPackets, [])    Expression("").append(txPackets), [])  AssignmentExpression(=, [VariableReference(builder.append("" operations, []), Expression("").append(operations), [])])    VariableReference(builder.append("" operations, [])    Expression("").append(operations), [])  MethodCall(return builder.toString(), [VariableReference(return builder, []), Expression(, [])])    VariableReference(return builder, [])    Expression(, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,,"1,2","1,4",1,4,1,The late version has added an additional statement to append "defaultNetwork" information to the StringBuilder "builder" object. This new line is:,#CI\_description
62,<android.webkit.WebChromeClient: boolean onConsoleMessage(ConsoleMessage)>,27,28,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(// Call the old version of this function for backwards compatability., []), MethodCall(onConsoleMessage(consoleMessage.message(), consoleMessage.lineNumber(), consoleMessage.sourceId()), [VariableReference(onConsoleMessage(consoleMessage, []), Expression(), []), Expression(consoleMessage.lineNumber(), []), Expression(consoleMessage.sourceId(), [])]), Statement(return false, []), Statement(}, [])])  Statement({, [])  Statement(// Call the old version of this function for backwards compatability., [])  MethodCall(onConsoleMessage(consoleMessage.message(), consoleMessage.lineNumber(), consoleMessage.sourceId()), [VariableReference(onConsoleMessage(consoleMessage, []), Expression(), []), Expression(consoleMessage.lineNumber(), []), Expression(consoleMessage.sourceId(), [])])    VariableReference(onConsoleMessage(consoleMessage, [])    Expression(), [])    Expression(consoleMessage.lineNumber(), [])    Expression(consoleMessage.sourceId(), [])  Statement(return false, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(// Call the old version of this function for backwards compatability., []), MethodCall(onConsoleMessage(consoleMessage.message(), consoleMessage.lineNumber(), consoleMessage.sourceId()), [VariableReference(onConsoleMessage(consoleMessage, []), Expression(), []), Expression(consoleMessage.lineNumber(), []), Expression(consoleMessage.sourceId(), [])]), Statement(return false, []), Statement(}, [])])  Statement({, [])  Statement(// Call the old version of this function for backwards compatability., [])  MethodCall(onConsoleMessage(consoleMessage.message(), consoleMessage.lineNumber(), consoleMessage.sourceId()), [VariableReference(onConsoleMessage(consoleMessage, []), Expression(), []), Expression(consoleMessage.lineNumber(), []), Expression(consoleMessage.sourceId(), [])])    VariableReference(onConsoleMessage(consoleMessage, [])    Expression(), [])    Expression(consoleMessage.lineNumber(), [])    Expression(consoleMessage.sourceId(), [])  Statement(return false, [])  Statement(}, [])",0,"/**
 * Report a JavaScript console message to the host application. The ChromeClient
 * should override this to process the log message as they see fit.
 * @param consoleMessage Object containing details of the console message.
 * @return true if the message is handled by the client.
 */
","/**
 * Report a JavaScript console message to the host application. The ChromeClient
 * should override this to process the log message as they see fit.
 * @param consoleMessage Object containing details of the console message.
 * @return {@code true} if the message is handled by the client.
 */
",1,,,0,,,,0,0,0,0,0,"There is no change in the code between the two versions, as the AST nodes provided are identical.","As there is no change in the code, there is no potential for different behavior or compatibility issues."
63,"<android.hardware.radio.RadioManager.ModuleProperties: void writeToParcel(Parcel,int)>",26,27,,,,"MethodDeclaration(method_body, [Statement({, []), MethodCall(dest.writeInt(mId), [VariableReference(dest, []), Expression(mId, [])]), MethodCall(dest.writeInt(mClassId), [VariableReference(dest, []), Expression(mClassId, [])]), MethodCall(dest.writeString(mImplementor), [VariableReference(dest, []), Expression(mImplementor, [])]), MethodCall(dest.writeString(mProduct), [VariableReference(dest, []), Expression(mProduct, [])]), MethodCall(dest.writeString(mVersion), [VariableReference(dest, []), Expression(mVersion, [])]), MethodCall(dest.writeString(mSerial), [VariableReference(dest, []), Expression(mSerial, [])]), MethodCall(dest.writeInt(mNumTuners), [VariableReference(dest, []), Expression(mNumTuners, [])]), MethodCall(dest.writeInt(mNumAudioSources), [VariableReference(dest, []), Expression(mNumAudioSources, [])]), MethodCall(dest.writeInt(mIsCaptureSupported ? 1 : 0), [VariableReference(dest, []), Expression(mIsCaptureSupported ? 1 : 0, [])]), MethodCall(dest.writeParcelableArray(mBands, flags), [VariableReference(dest, []), Expression(mBands, []), Expression(flags, [])]), Statement(}, [])])  Statement({, [])  MethodCall(dest.writeInt(mId), [VariableReference(dest, []), Expression(mId, [])])    VariableReference(dest, [])    Expression(mId, [])  MethodCall(dest.writeInt(mClassId), [VariableReference(dest, []), Expression(mClassId, [])])    VariableReference(dest, [])    Expression(mClassId, [])  MethodCall(dest.writeString(mImplementor), [VariableReference(dest, []), Expression(mImplementor, [])])    VariableReference(dest, [])    Expression(mImplementor, [])  MethodCall(dest.writeString(mProduct), [VariableReference(dest, []), Expression(mProduct, [])])    VariableReference(dest, [])    Expression(mProduct, [])  MethodCall(dest.writeString(mVersion), [VariableReference(dest, []), Expression(mVersion, [])])    VariableReference(dest, [])    Expression(mVersion, [])  MethodCall(dest.writeString(mSerial), [VariableReference(dest, []), Expression(mSerial, [])])    VariableReference(dest, [])    Expression(mSerial, [])  MethodCall(dest.writeInt(mNumTuners), [VariableReference(dest, []), Expression(mNumTuners, [])])    VariableReference(dest, [])    Expression(mNumTuners, [])  MethodCall(dest.writeInt(mNumAudioSources), [VariableReference(dest, []), Expression(mNumAudioSources, [])])    VariableReference(dest, [])    Expression(mNumAudioSources, [])  MethodCall(dest.writeInt(mIsCaptureSupported ? 1 : 0), [VariableReference(dest, []), Expression(mIsCaptureSupported ? 1 : 0, [])])    VariableReference(dest, [])    Expression(mIsCaptureSupported ? 1 : 0, [])  MethodCall(dest.writeParcelableArray(mBands, flags), [VariableReference(dest, []), Expression(mBands, []), Expression(flags, [])])    VariableReference(dest, [])    Expression(mBands, [])    Expression(flags, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(dest.writeInt(mId), [VariableReference(dest, []), Expression(mId, [])]), MethodCall(dest.writeString(mServiceName), [VariableReference(dest, []), Expression(mServiceName, [])]), MethodCall(dest.writeInt(mClassId), [VariableReference(dest, []), Expression(mClassId, [])]), MethodCall(dest.writeString(mImplementor), [VariableReference(dest, []), Expression(mImplementor, [])]), MethodCall(dest.writeString(mProduct), [VariableReference(dest, []), Expression(mProduct, [])]), MethodCall(dest.writeString(mVersion), [VariableReference(dest, []), Expression(mVersion, [])]), MethodCall(dest.writeString(mSerial), [VariableReference(dest, []), Expression(mSerial, [])]), MethodCall(dest.writeInt(mNumTuners), [VariableReference(dest, []), Expression(mNumTuners, [])]), MethodCall(dest.writeInt(mNumAudioSources), [VariableReference(dest, []), Expression(mNumAudioSources, [])]), MethodCall(dest.writeInt(mIsCaptureSupported ? 1 : 0), [VariableReference(dest, []), Expression(mIsCaptureSupported ? 1 : 0, [])]), MethodCall(dest.writeParcelableArray(mBands, flags), [VariableReference(dest, []), Expression(mBands, []), Expression(flags, [])]), MethodCall(dest.writeInt(mIsBgScanSupported ? 1 : 0), [VariableReference(dest, []), Expression(mIsBgScanSupported ? 1 : 0, [])]), MethodCall(dest.writeIntArray(setToArray(mSupportedProgramTypes)), [VariableReference(dest, []), Expression(setToArray(mSupportedProgramTypes), [])]), MethodCall(dest.writeIntArray(setToArray(mSupportedIdentifierTypes)), [VariableReference(dest, []), Expression(setToArray(mSupportedIdentifierTypes), [])]), Statement(writeStringMap(dest, mVendorInfo), []), Statement(}, [])])  Statement({, [])  MethodCall(dest.writeInt(mId), [VariableReference(dest, []), Expression(mId, [])])    VariableReference(dest, [])    Expression(mId, [])  MethodCall(dest.writeString(mServiceName), [VariableReference(dest, []), Expression(mServiceName, [])])    VariableReference(dest, [])    Expression(mServiceName, [])  MethodCall(dest.writeInt(mClassId), [VariableReference(dest, []), Expression(mClassId, [])])    VariableReference(dest, [])    Expression(mClassId, [])  MethodCall(dest.writeString(mImplementor), [VariableReference(dest, []), Expression(mImplementor, [])])    VariableReference(dest, [])    Expression(mImplementor, [])  MethodCall(dest.writeString(mProduct), [VariableReference(dest, []), Expression(mProduct, [])])    VariableReference(dest, [])    Expression(mProduct, [])  MethodCall(dest.writeString(mVersion), [VariableReference(dest, []), Expression(mVersion, [])])    VariableReference(dest, [])    Expression(mVersion, [])  MethodCall(dest.writeString(mSerial), [VariableReference(dest, []), Expression(mSerial, [])])    VariableReference(dest, [])    Expression(mSerial, [])  MethodCall(dest.writeInt(mNumTuners), [VariableReference(dest, []), Expression(mNumTuners, [])])    VariableReference(dest, [])    Expression(mNumTuners, [])  MethodCall(dest.writeInt(mNumAudioSources), [VariableReference(dest, []), Expression(mNumAudioSources, [])])    VariableReference(dest, [])    Expression(mNumAudioSources, [])  MethodCall(dest.writeInt(mIsCaptureSupported ? 1 : 0), [VariableReference(dest, []), Expression(mIsCaptureSupported ? 1 : 0, [])])    VariableReference(dest, [])    Expression(mIsCaptureSupported ? 1 : 0, [])  MethodCall(dest.writeParcelableArray(mBands, flags), [VariableReference(dest, []), Expression(mBands, []), Expression(flags, [])])    VariableReference(dest, [])    Expression(mBands, [])    Expression(flags, [])  MethodCall(dest.writeInt(mIsBgScanSupported ? 1 : 0), [VariableReference(dest, []), Expression(mIsBgScanSupported ? 1 : 0, [])])    VariableReference(dest, [])    Expression(mIsBgScanSupported ? 1 : 0, [])  MethodCall(dest.writeIntArray(setToArray(mSupportedProgramTypes)), [VariableReference(dest, []), Expression(setToArray(mSupportedProgramTypes), [])])    VariableReference(dest, [])    Expression(setToArray(mSupportedProgramTypes), [])  MethodCall(dest.writeIntArray(setToArray(mSupportedIdentifierTypes)), [VariableReference(dest, []), Expression(setToArray(mSupportedIdentifierTypes), [])])    VariableReference(dest, [])    Expression(setToArray(mSupportedIdentifierTypes), [])  Statement(writeStringMap(dest, mVendorInfo), [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,,"1,2","1,4",1,5,1,"There are new method calls and a new statement added in the late version implementation of the API, specifically, ""MethodCall(dest.writeString(mServiceName), [VariableReference(dest, []), Expression(mServiceName, [])])"", ""MethodCall(dest.writeInt(mIsBgScanSupported ? 1 : 0), [VariableReference(dest, []), Expression(mIsBgScanSupported ? 1 : 0, [])])"", ""MethodCall(dest.writeIntArray(setToArray(mSupportedProgramTypes)), [VariableReference(dest, []), Expression(setToArray(mSupportedProgramTypes), [])])"", ""MethodCall(dest.writeIntArray(setToArray(mSupportedIdentifierTypes)), [VariableReference(dest, []), Expression(setToArray(mSupportedIdentifierTypes), [])])"", and ""Statement(writeStringMap(dest, mVendorInfo), [])"". These changes are not related to the return statement, exception handling, or control dependency, so they are classified as ""Other statement changed"".","The new method calls and statement added in the late version implementation write additional data to the Parcel. This could lead to different behavior if the Parcel is used differently in the late version, such as if the Parcel is expected to contain the additional data in the late version but not in the early version. Therefore, the compatibility issue is classified as ""Compatibility Issue caused by potential different return values or types""."
64,<android.app.Notification.Builder: Builder setGroupAlertBehavior(int)>,26,27,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(mN.mGroupAlertBehavior, []), Expression(groupAlertBehavior, [])]), Statement(return this, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(mN.mGroupAlertBehavior, []), Expression(groupAlertBehavior, [])])    VariableReference(mN.mGroupAlertBehavior, [])    Expression(groupAlertBehavior, [])  Statement(return this, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(mN.mGroupAlertBehavior, []), Expression(groupAlertBehavior, [])]), Statement(return this, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(mN.mGroupAlertBehavior, []), Expression(groupAlertBehavior, [])])    VariableReference(mN.mGroupAlertBehavior, [])    Expression(groupAlertBehavior, [])  Statement(return this, [])  Statement(}, [])",0,"/**
 * Sets the group alert behavior for this notification. Use this method to mute this
 * notification if alerts for this notification's group should be handled by a different
 * notification. This is only applicable for notifications that belong to a
 * {@link #setGroup(String) group}.
 *
 * <p> The default value is {@link #GROUP_ALERT_ALL}.</p>
 */
","/**
 * Sets the group alert behavior for this notification. Use this method to mute this
 * notification if alerts for this notification's group should be handled by a different
 * notification. This is only applicable for notifications that belong to a
 * {@link #setGroup(String) group}. This must be called on all notifications you want to
 * mute. For example, if you want only the summary of your group to make noise, all
 * children in the group should have the group alert behavior {@link #GROUP_ALERT_SUMMARY}.
 *
 * <p> The default value is {@link #GROUP_ALERT_ALL}.</p>
 */
",1,,,0,,,,0,0,0,0,0,"The implementation of the API has not changed between the two versions. The only difference is the comment, where some additional information has been added in the late version.","Since there is no code change, there is no Compatibility Issue."
65,"<android.app.FragmentManagerImpl: void dispatchOnFragmentPreAttached(Fragment,Context,boolean)>",26,27,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mParent !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(FragmentManager parentManager, []), Expression(mParent.getFragmentManager(), [])]), Statement(if (parentManager instanceof FragmentManagerImpl) {, []), MethodCall(((FragmentManagerImpl) parentManager).dispatchOnFragmentPreAttached(f, context, true), [VariableReference(((FragmentManagerImpl) parentManager), []), Expression(f, []), Expression(context, []), Expression(true, [])]), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mLifecycleCallbacks, []), Expression(, [])]), Statement(return, []), Statement(}, []), Statement(for (Pair<FragmentLifecycleCallbacks, Boolean> p : mLifecycleCallbacks) {, []), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mParent !, []), Expression(null) {, [])])    VariableReference(if (mParent !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(FragmentManager parentManager, []), Expression(mParent.getFragmentManager(), [])])    VariableReference(FragmentManager parentManager, [])    Expression(mParent.getFragmentManager(), [])  Statement(if (parentManager instanceof FragmentManagerImpl) {, [])  MethodCall(((FragmentManagerImpl) parentManager).dispatchOnFragmentPreAttached(f, context, true), [VariableReference(((FragmentManagerImpl) parentManager), []), Expression(f, []), Expression(context, []), Expression(true, [])])    VariableReference(((FragmentManagerImpl) parentManager), [])    Expression(f, [])    Expression(context, [])    Expression(true, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mLifecycleCallbacks, []), Expression(, [])])    VariableReference(if (mLifecycleCallbacks, [])    Expression(, [])  Statement(return, [])  Statement(}, [])  Statement(for (Pair<FragmentLifecycleCallbacks, Boolean> p : mLifecycleCallbacks) {, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mParent !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(FragmentManager parentManager, []), Expression(mParent.getFragmentManager(), [])]), Statement(if (parentManager instanceof FragmentManagerImpl) {, []), MethodCall(((FragmentManagerImpl) parentManager).dispatchOnFragmentPreAttached(f, context, true), [VariableReference(((FragmentManagerImpl) parentManager), []), Expression(f, []), Expression(context, []), Expression(true, [])]), Statement(}, []), Statement(}, []), Statement(for (Pair<FragmentLifecycleCallbacks, Boolean> p : mLifecycleCallbacks) {, []), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mParent !, []), Expression(null) {, [])])    VariableReference(if (mParent !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(FragmentManager parentManager, []), Expression(mParent.getFragmentManager(), [])])    VariableReference(FragmentManager parentManager, [])    Expression(mParent.getFragmentManager(), [])  Statement(if (parentManager instanceof FragmentManagerImpl) {, [])  MethodCall(((FragmentManagerImpl) parentManager).dispatchOnFragmentPreAttached(f, context, true), [VariableReference(((FragmentManagerImpl) parentManager), []), Expression(f, []), Expression(context, []), Expression(true, [])])    VariableReference(((FragmentManagerImpl) parentManager), [])    Expression(f, [])    Expression(context, [])    Expression(true, [])  Statement(}, [])  Statement(}, [])  Statement(for (Pair<FragmentLifecycleCallbacks, Boolean> p : mLifecycleCallbacks) {, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])",1,,,0,,,0,,,,1,"1,3",1,0,0,There were no changes between the early and late implementation AST nodes.,"There were no changes between the early and late implementation AST nodes, so there are no compatibility issues."
66,<android.widget.ArrayAdapter: CharSequence[] getAutofillOptions()>,26,27,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (!mObjectsFromResources || mObjects, []), Expression(, [])]), Statement(return null, []), Statement(}, []), AssignmentExpression(=, [VariableReference(final int size, []), Expression(mObjects.size(), [])]), AssignmentExpression(=, [VariableReference(final CharSequence[] options, []), Expression(new CharSequence[size], [])]), MethodCall(mObjects.toArray(options), [VariableReference(mObjects, []), Expression(options, [])]), Statement(return options, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (!mObjectsFromResources || mObjects, []), Expression(, [])])    VariableReference(if (!mObjectsFromResources || mObjects, [])    Expression(, [])  Statement(return null, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(final int size, []), Expression(mObjects.size(), [])])    VariableReference(final int size, [])    Expression(mObjects.size(), [])  AssignmentExpression(=, [VariableReference(final CharSequence[] options, []), Expression(new CharSequence[size], [])])    VariableReference(final CharSequence[] options, [])    Expression(new CharSequence[size], [])  MethodCall(mObjects.toArray(options), [VariableReference(mObjects, []), Expression(options, [])])    VariableReference(mObjects, [])    Expression(options, [])  Statement(return options, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(// First check if app developer explicitly set them., []), AssignmentExpression(=, [VariableReference(final CharSequence[] explicitOptions, []), Expression(super.getAutofillOptions(), [])]), AssignmentExpression(=, [VariableReference(if (explicitOptions !, []), Expression(null) {, [])]), Statement(return explicitOptions, []), Statement(}, []), Statement(// Otherwise, only return options that came from static resources., []), AssignmentExpression(=, [VariableReference(if (!mObjectsFromResources || mObjects, []), Expression(, [])]), Statement(return null, []), Statement(}, []), AssignmentExpression(=, [VariableReference(final int size, []), Expression(mObjects.size(), [])]), AssignmentExpression(=, [VariableReference(final CharSequence[] options, []), Expression(new CharSequence[size], [])]), MethodCall(mObjects.toArray(options), [VariableReference(mObjects, []), Expression(options, [])]), Statement(return options, []), Statement(}, [])])  Statement({, [])  Statement(// First check if app developer explicitly set them., [])  AssignmentExpression(=, [VariableReference(final CharSequence[] explicitOptions, []), Expression(super.getAutofillOptions(), [])])    VariableReference(final CharSequence[] explicitOptions, [])    Expression(super.getAutofillOptions(), [])  AssignmentExpression(=, [VariableReference(if (explicitOptions !, []), Expression(null) {, [])])    VariableReference(if (explicitOptions !, [])    Expression(null) {, [])  Statement(return explicitOptions, [])  Statement(}, [])  Statement(// Otherwise, only return options that came from static resources., [])  AssignmentExpression(=, [VariableReference(if (!mObjectsFromResources || mObjects, []), Expression(, [])])    VariableReference(if (!mObjectsFromResources || mObjects, [])    Expression(, [])  Statement(return null, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(final int size, []), Expression(mObjects.size(), [])])    VariableReference(final int size, [])    Expression(mObjects.size(), [])  AssignmentExpression(=, [VariableReference(final CharSequence[] options, []), Expression(new CharSequence[size], [])])    VariableReference(final CharSequence[] options, [])    Expression(new CharSequence[size], [])  MethodCall(mObjects.toArray(options), [VariableReference(mObjects, []), Expression(options, [])])    VariableReference(mObjects, [])    Expression(options, [])  Statement(return options, [])  Statement(}, [])",1,"/**
 * {@inheritDoc}
 *
 * @return values from the string array used by {@link #createFromResource(Context, int, int)},
 * or {@code null} if object was created otherwsie or if contents were dynamically changed after
 * creation.
 */
","/**
 * {@inheritDoc}
 *
 * @return values from the string array used by {@link #createFromResource(Context, int, int)},
 * or {@code null} if object was created otherwsie or if contents were dynamically changed after
 * creation.
 */
",0,[@Override],[@Override],0,,,,"1,2","1,3,4",1,"1,2,3","1,2",The code changes are as follows:,"3. Control dependency changed: In late version, there's an additional condition `explicitOptions != null` before the logic of early version."
68,<android.service.vr.VrListenerService.VrListenerHandler: void handleMessage(Message)>,26,27,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(case MSG_ON_CURRENT_VR_ACTIVITY_CHANGED:, []), Statement({, []), Statement(}, []), Statement(break, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(case MSG_ON_CURRENT_VR_ACTIVITY_CHANGED:, [])  Statement({, [])  Statement(}, [])  Statement(break, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(case MSG_ON_CURRENT_VR_ACTIVITY_CHANGED:, []), Statement({, []), AssignmentExpression(=, [VariableReference(VrListenerService.this.onCurrentVrActivityChanged((ComponentName) msg.obj, msg.arg1, []), Expression(, [])]), Statement(}, []), Statement(break, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(case MSG_ON_CURRENT_VR_ACTIVITY_CHANGED:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(VrListenerService.this.onCurrentVrActivityChanged((ComponentName) msg.obj, msg.arg1, []), Expression(, [])])    VariableReference(VrListenerService.this.onCurrentVrActivityChanged((ComponentName) msg.obj, msg.arg1, [])    Expression(, [])  Statement(}, [])  Statement(break, [])  Statement(}, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,,2,5,0,3,0,3. Control dependency changed: No,
69,<android.hardware.usb.UsbConfiguration: String getName()>,25,26,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(return mName, []), Statement(}, [])])  Statement({, [])  Statement(return mName, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return mName, []), Statement(}, [])])  Statement({, [])  Statement(return mName, [])  Statement(}, [])",0,"/**
 * Returns the configuration's name.
 *
 * @return the configuration's name
 */
","/**
 * Returns the configuration's name.
 *
 * @return the configuration's name, or {@code null} if the property could not be read
 */
",1,,[@Nullable],1,,,,0,0,0,4,0,"The only change between the two versions is the addition of the @Nullable annotation to the return type of the method, which indicates that the method may return null. This change does not affect the behavior of the method, as it only provides information to the caller about the possible values that the method can return.","Since the addition of the @Nullable annotation does not affect the behavior of the method, there is no compatibility issue caused by this change. The method will continue to return the same value in both versions, and the caller can use the same code to handle the returned value, regardless of whether it is null or not."
70,"<android.hardware.usb.UsbDeviceConnection: int bulkTransfer(UsbEndpoint,byte[],int,int)>",25,26,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(return bulkTransfer(endpoint, buffer, 0, length, timeout), []), Statement(}, [])])  Statement({, [])  Statement(return bulkTransfer(endpoint, buffer, 0, length, timeout), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return bulkTransfer(endpoint, buffer, 0, length, timeout), []), Statement(}, [])])  Statement({, [])  Statement(return bulkTransfer(endpoint, buffer, 0, length, timeout), [])  Statement(}, [])",0,"/**
 * Performs a bulk transaction on the given endpoint.
 * The direction of the transfer is determined by the direction of the endpoint.
 * <p>
 * This method transfers data starting from index 0 in the buffer.
 * To specify a different offset, use
 * {@link #bulkTransfer(UsbEndpoint, byte[], int, int, int)}.
 * </p>
 *
 * @param endpoint the endpoint for this transaction
 * @param buffer buffer for data to send or receive
 * @param length the length of the data to send or receive
 * @param timeout in milliseconds
 * @return length of data transferred (or zero) for success,
 * or negative value for failure
 */
","/**
 * Performs a bulk transaction on the given endpoint.
 * The direction of the transfer is determined by the direction of the endpoint.
 * <p>
 * This method transfers data starting from index 0 in the buffer.
 * To specify a different offset, use
 * {@link #bulkTransfer(UsbEndpoint, byte[], int, int, int)}.
 * </p>
 *
 * @param endpoint the endpoint for this transaction
 * @param buffer buffer for data to send or receive; can be {@code null} to wait for next
 * transaction without reading data
 * @param length the length of the data to send or receive
 * @param timeout in milliseconds, 0 is infinite
 * @return length of data transferred (or zero) for success,
 * or negative value for failure
 */
",1,,,0,,,,0,0,0,0,0,There is no difference between the two versions of the implementation. Only the documentation comment has been updated with more details about the usage of the method.,"Since there is no change in the implementation, the behavior of the method remains the same and there are no compatibility issues."
71,<android.app.Fragment: boolean getAllowEnterTransitionOverlap()>,25,26,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(return (mAllowEnterTransitionOverlap, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(return (mAllowEnterTransitionOverlap, []), Expression(, [])])    VariableReference(return (mAllowEnterTransitionOverlap, [])    Expression(, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(return (mAnimationInfo, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(return (mAnimationInfo, []), Expression(, [])])    VariableReference(return (mAnimationInfo, [])    Expression(, [])  Statement(}, [])",1,"/**
 * Returns whether the the exit transition and enter transition overlap or not.
 * When true, the enter transition will start as soon as possible. When false, the
 * enter transition will wait until the exit transition completes before starting.
 *
 * @return true when the enter transition should start as soon as possible or false to
 * when it should wait until the exiting transition completes.
 * @attr ref android.R.styleable#Fragment_fragmentAllowEnterTransitionOverlap
 */
","/**
 * Returns whether the the exit transition and enter transition overlap or not.
 * When true, the enter transition will start as soon as possible. When false, the
 * enter transition will wait until the exit transition completes before starting.
 *
 * @return true when the enter transition should start as soon as possible or false to
 * when it should wait until the exiting transition completes.
 * @attr ref android.R.styleable#Fragment_fragmentAllowEnterTransitionOverlap
 */
",0,,,0,,,,"1,2","1,5",1,1,1,"In the late version, the variable being returned has changed from 'mAllowEnterTransitionOverlap' to 'mAnimationInfo'.","The change in the variable being returned can lead to different behaviors as the value of 'mAnimationInfo' may not be the same as 'mAllowEnterTransitionOverlap', potentially causing the enter transition to start at an incorrect time."
72,<android.content.pm.ShortcutManager: boolean setDynamicShortcuts(List<ShortcutInfo>)>,25,26,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(return mService.setDynamicShortcuts(mContext.getPackageName(), new ParceledListSlice(shortcutInfoList), injectMyUserId()), [VariableReference(return mService, []), Expression(mContext.getPackageName(), []), Expression(new ParceledListSlice(shortcutInfoList), []), Expression(injectMyUserId(), [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(return mService.setDynamicShortcuts(mContext.getPackageName(), new ParceledListSlice(shortcutInfoList), injectMyUserId()), [VariableReference(return mService, []), Expression(mContext.getPackageName(), []), Expression(new ParceledListSlice(shortcutInfoList), []), Expression(injectMyUserId(), [])])    VariableReference(return mService, [])    Expression(mContext.getPackageName(), [])    Expression(new ParceledListSlice(shortcutInfoList), [])    Expression(injectMyUserId(), [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(return mService.setDynamicShortcuts(mContext.getPackageName(), new ParceledListSlice(shortcutInfoList), injectMyUserId()), [VariableReference(return mService, []), Expression(mContext.getPackageName(), []), Expression(new ParceledListSlice(shortcutInfoList), []), Expression(injectMyUserId(), [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(return mService.setDynamicShortcuts(mContext.getPackageName(), new ParceledListSlice(shortcutInfoList), injectMyUserId()), [VariableReference(return mService, []), Expression(mContext.getPackageName(), []), Expression(new ParceledListSlice(shortcutInfoList), []), Expression(injectMyUserId(), [])])    VariableReference(return mService, [])    Expression(mContext.getPackageName(), [])    Expression(new ParceledListSlice(shortcutInfoList), [])    Expression(injectMyUserId(), [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",0,"/**
 * Publish the list of shortcuts.  All existing dynamic shortcuts from the caller application
 * will be replaced.  If there are already pinned shortcuts with the same IDs,
 * the mutable pinned shortcuts are updated.
 *
 * <p>This API will be rate-limited.
 *
 * @return {@code true} if the call has succeeded. {@code false} if the call is rate-limited.
 *
 * @throws IllegalArgumentException if {@link #getMaxShortcutCountPerActivity()} is exceeded,
 * or when trying to update immutable shortcuts.
 *
 * @throws IllegalStateException when the user is locked.
 */
","/**
 * Publish the list of shortcuts.  All existing dynamic shortcuts from the caller app
 * will be replaced.  If there are already pinned shortcuts with the same IDs,
 * the mutable pinned shortcuts are updated.
 *
 * <p>This API will be rate-limited.
 *
 * @return {@code true} if the call has succeeded. {@code false} if the call is rate-limited.
 *
 * @throws IllegalArgumentException if {@link #getMaxShortcutCountPerActivity()} is exceeded,
 * or when trying to update immutable shortcuts.
 *
 * @throws IllegalStateException when the user is locked.
 */
",1,,,0,,,,0,0,0,0,0,"The given early and late version implementations are exactly the same, hence there is no code change.","There is no code change, hence there is no Compatibility Issue."
74,<android.app.FragmentManagerImpl: void dispatchDestroy()>,25,26,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(mDestroyed, []), Expression(true, [])]), Statement(execPendingActions(), []), AssignmentExpression(=, [VariableReference(mHost, []), Expression(null, [])]), AssignmentExpression(=, [VariableReference(mContainer, []), Expression(null, [])]), AssignmentExpression(=, [VariableReference(mParent, []), Expression(null, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(mDestroyed, []), Expression(true, [])])    VariableReference(mDestroyed, [])    Expression(true, [])  Statement(execPendingActions(), [])  AssignmentExpression(=, [VariableReference(mHost, []), Expression(null, [])])    VariableReference(mHost, [])    Expression(null, [])  AssignmentExpression(=, [VariableReference(mContainer, []), Expression(null, [])])    VariableReference(mContainer, [])    Expression(null, [])  AssignmentExpression(=, [VariableReference(mParent, []), Expression(null, [])])    VariableReference(mParent, [])    Expression(null, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(mDestroyed, []), Expression(true, [])]), Statement(execPendingActions(), []), AssignmentExpression(=, [VariableReference(mHost, []), Expression(null, [])]), AssignmentExpression(=, [VariableReference(mContainer, []), Expression(null, [])]), AssignmentExpression(=, [VariableReference(mParent, []), Expression(null, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(mDestroyed, []), Expression(true, [])])    VariableReference(mDestroyed, [])    Expression(true, [])  Statement(execPendingActions(), [])  AssignmentExpression(=, [VariableReference(mHost, []), Expression(null, [])])    VariableReference(mHost, [])    Expression(null, [])  AssignmentExpression(=, [VariableReference(mContainer, []), Expression(null, [])])    VariableReference(mContainer, [])    Expression(null, [])  AssignmentExpression(=, [VariableReference(mParent, []), Expression(null, [])])    VariableReference(mParent, [])    Expression(null, [])  Statement(}, [])",1,,,0,,,0,,,,2,5,1,0,0,"The AST nodes of the early and late versions of the API are identical, indicating that there is no code change between the two versions.","As there is no code change between the two versions, there is no compatibility issue arising from potential different return values or types or different exception handlings."
75,"<android.content.res.ResourcesImpl.ThemeImpl: TypedArray obtainStyledAttributes(Theme,AttributeSet,int[],int,int)>",25,26,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(synchronized (mKey) {, []), AssignmentExpression(=, [VariableReference(final int len, []), Expression(attrs.length, [])]), AssignmentExpression(=, [VariableReference(final TypedArray array, []), Expression(TypedArray.obtain(wrapper.getResources(), len), [])]), Statement(// XXX note that for now we only work with compiled XML files., []), Statement(// To support generic XML files we will need to manually parse, []), Statement(// out the attributes from the XML file (applying type information, []), Statement(// contained in the resources and such)., []), AssignmentExpression(=, [VariableReference(final XmlBlock.Parser parser, []), Expression((XmlBlock.Parser) set, [])]), AssignmentExpression(=, [VariableReference(AssetManager.applyStyle(mTheme, defStyleAttr, defStyleRes, parser !, []), Expression(null ? parser.mParseState : 0, attrs, array.mData, array.mIndices), [])]), AssignmentExpression(=, [VariableReference(array.mTheme, []), Expression(wrapper, [])]), AssignmentExpression(=, [VariableReference(array.mXml, []), Expression(parser, [])]), Statement(return array, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(synchronized (mKey) {, [])  AssignmentExpression(=, [VariableReference(final int len, []), Expression(attrs.length, [])])    VariableReference(final int len, [])    Expression(attrs.length, [])  AssignmentExpression(=, [VariableReference(final TypedArray array, []), Expression(TypedArray.obtain(wrapper.getResources(), len), [])])    VariableReference(final TypedArray array, [])    Expression(TypedArray.obtain(wrapper.getResources(), len), [])  Statement(// XXX note that for now we only work with compiled XML files., [])  Statement(// To support generic XML files we will need to manually parse, [])  Statement(// out the attributes from the XML file (applying type information, [])  Statement(// contained in the resources and such)., [])  AssignmentExpression(=, [VariableReference(final XmlBlock.Parser parser, []), Expression((XmlBlock.Parser) set, [])])    VariableReference(final XmlBlock.Parser parser, [])    Expression((XmlBlock.Parser) set, [])  AssignmentExpression(=, [VariableReference(AssetManager.applyStyle(mTheme, defStyleAttr, defStyleRes, parser !, []), Expression(null ? parser.mParseState : 0, attrs, array.mData, array.mIndices), [])])    VariableReference(AssetManager.applyStyle(mTheme, defStyleAttr, defStyleRes, parser !, [])    Expression(null ? parser.mParseState : 0, attrs, array.mData, array.mIndices), [])  AssignmentExpression(=, [VariableReference(array.mTheme, []), Expression(wrapper, [])])    VariableReference(array.mTheme, [])    Expression(wrapper, [])  AssignmentExpression(=, [VariableReference(array.mXml, []), Expression(parser, [])])    VariableReference(array.mXml, [])    Expression(parser, [])  Statement(return array, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(synchronized (mKey) {, []), AssignmentExpression(=, [VariableReference(final int len, []), Expression(attrs.length, [])]), AssignmentExpression(=, [VariableReference(final TypedArray array, []), Expression(TypedArray.obtain(wrapper.getResources(), len), [])]), Statement(// XXX note that for now we only work with compiled XML files., []), Statement(// To support generic XML files we will need to manually parse, []), Statement(// out the attributes from the XML file (applying type information, []), Statement(// contained in the resources and such)., []), AssignmentExpression(=, [VariableReference(final XmlBlock.Parser parser, []), Expression((XmlBlock.Parser) set, [])]), AssignmentExpression(=, [VariableReference(AssetManager.applyStyle(mTheme, defStyleAttr, defStyleRes, parser !, []), Expression(null ? parser.mParseState : 0, attrs, attrs.length, array.mDataAddress, array.mIndicesAddress), [])]), AssignmentExpression(=, [VariableReference(array.mTheme, []), Expression(wrapper, [])]), AssignmentExpression(=, [VariableReference(array.mXml, []), Expression(parser, [])]), Statement(return array, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(synchronized (mKey) {, [])  AssignmentExpression(=, [VariableReference(final int len, []), Expression(attrs.length, [])])    VariableReference(final int len, [])    Expression(attrs.length, [])  AssignmentExpression(=, [VariableReference(final TypedArray array, []), Expression(TypedArray.obtain(wrapper.getResources(), len), [])])    VariableReference(final TypedArray array, [])    Expression(TypedArray.obtain(wrapper.getResources(), len), [])  Statement(// XXX note that for now we only work with compiled XML files., [])  Statement(// To support generic XML files we will need to manually parse, [])  Statement(// out the attributes from the XML file (applying type information, [])  Statement(// contained in the resources and such)., [])  AssignmentExpression(=, [VariableReference(final XmlBlock.Parser parser, []), Expression((XmlBlock.Parser) set, [])])    VariableReference(final XmlBlock.Parser parser, [])    Expression((XmlBlock.Parser) set, [])  AssignmentExpression(=, [VariableReference(AssetManager.applyStyle(mTheme, defStyleAttr, defStyleRes, parser !, []), Expression(null ? parser.mParseState : 0, attrs, attrs.length, array.mDataAddress, array.mIndicesAddress), [])])    VariableReference(AssetManager.applyStyle(mTheme, defStyleAttr, defStyleRes, parser !, [])    Expression(null ? parser.mParseState : 0, attrs, attrs.length, array.mDataAddress, array.mIndicesAddress), [])  AssignmentExpression(=, [VariableReference(array.mTheme, []), Expression(wrapper, [])])    VariableReference(array.mTheme, [])    Expression(wrapper, [])  AssignmentExpression(=, [VariableReference(array.mXml, []), Expression(parser, [])])    VariableReference(array.mXml, [])    Expression(parser, [])  Statement(return array, [])  Statement(}, [])  Statement(}, [])",1,,,0,[@NonNull],[@NonNull],0,,,,2,5,1,5,1,"The code change between the two versions is that the method `AssetManager.applyStyle` has changed its parameters. In the early version, the parameters are `mTheme, defStyleAttr, defStyleRes, parser !, null ? parser.mParseState : 0, attrs, array.mData, array.mIndices`. However, in the late version, the parameters are `mTheme, defStyleAttr, defStyleRes, parser !, null ? parser.mParseState : 0, attrs, attrs.length, array.mDataAddress, array.mIndicesAddress`. It can be seen that the last four parameters have changed. This is a dependent API change, so the code change type is 5.","The change of the parameters in the method `AssetManager.applyStyle` may potentially lead to different return values or types. This is because the method's behavior and output are determined by its input parameters. As a result, the Compatibility Issue type is 1."
76,<android.app.admin.DevicePolicyManager: int getPermissionPolicy(ComponentName)>,25,26,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(throwIfParentInstance(""getPermissionPolicy""), []), Statement(try {, []), MethodCall(return mService.getPermissionPolicy(admin), [VariableReference(return mService, []), Expression(admin, [])]), Statement(} catch (RemoteException re) {, []), MethodCall(throw re.rethrowFromSystemServer(), [VariableReference(throw re, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(throwIfParentInstance(""getPermissionPolicy""), [])  Statement(try {, [])  MethodCall(return mService.getPermissionPolicy(admin), [VariableReference(return mService, []), Expression(admin, [])])    VariableReference(return mService, [])    Expression(admin, [])  Statement(} catch (RemoteException re) {, [])  MethodCall(throw re.rethrowFromSystemServer(), [VariableReference(throw re, []), Expression(, [])])    VariableReference(throw re, [])    Expression(, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(throwIfParentInstance(""getPermissionPolicy""), []), Statement(try {, []), MethodCall(return mService.getPermissionPolicy(admin), [VariableReference(return mService, []), Expression(admin, [])]), Statement(} catch (RemoteException re) {, []), MethodCall(throw re.rethrowFromSystemServer(), [VariableReference(throw re, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(throwIfParentInstance(""getPermissionPolicy""), [])  Statement(try {, [])  MethodCall(return mService.getPermissionPolicy(admin), [VariableReference(return mService, []), Expression(admin, [])])    VariableReference(return mService, [])    Expression(admin, [])  Statement(} catch (RemoteException re) {, [])  MethodCall(throw re.rethrowFromSystemServer(), [VariableReference(throw re, []), Expression(, [])])    VariableReference(throw re, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",0,"/**
 * Returns the current runtime permission policy set by the device or profile owner. The
 * default is {@link #PERMISSION_POLICY_PROMPT}.
 * @param admin Which profile or device owner this request is associated with.
 * @return the current policy for future permission requests.
 */
","/**
 * Returns the current runtime permission policy set by the device or profile owner. The
 * default is {@link #PERMISSION_POLICY_PROMPT}.
 *
 * @param admin Which profile or device owner this request is associated with.
 * @return the current policy for future permission requests.
 */
",1,,,0,,,,0,0,0,0,0,There is no change between the early and late version implementation.,"The behavior of the API remains the same between the two versions, so there are no compatibility issues."
77,"<android.app.Notification.Builder: Builder setSound(Uri,int)>",25,26,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(mN.sound, []), Expression(sound, [])]), AssignmentExpression(=, [VariableReference(mN.audioStreamType, []), Expression(streamType, [])]), Statement(return this, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(mN.sound, []), Expression(sound, [])])    VariableReference(mN.sound, [])    Expression(sound, [])  AssignmentExpression(=, [VariableReference(mN.audioStreamType, []), Expression(streamType, [])])    VariableReference(mN.audioStreamType, [])    Expression(streamType, [])  Statement(return this, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(PlayerBase.deprecateStreamTypeForPlayback(streamType, ""Notification"", ""setSound()""), [VariableReference(PlayerBase, []), Expression(streamType, []), Expression(""Notification"", []), Expression(""setSound()"", [])]), AssignmentExpression(=, [VariableReference(mN.sound, []), Expression(sound, [])]), AssignmentExpression(=, [VariableReference(mN.audioStreamType, []), Expression(streamType, [])]), Statement(return this, []), Statement(}, [])])  Statement({, [])  MethodCall(PlayerBase.deprecateStreamTypeForPlayback(streamType, ""Notification"", ""setSound()""), [VariableReference(PlayerBase, []), Expression(streamType, []), Expression(""Notification"", []), Expression(""setSound()"", [])])    VariableReference(PlayerBase, [])    Expression(streamType, [])    Expression(""Notification"", [])    Expression(""setSound()"", [])  AssignmentExpression(=, [VariableReference(mN.sound, []), Expression(sound, [])])    VariableReference(mN.sound, [])    Expression(sound, [])  AssignmentExpression(=, [VariableReference(mN.audioStreamType, []), Expression(streamType, [])])    VariableReference(mN.audioStreamType, [])    Expression(streamType, [])  Statement(return this, [])  Statement(}, [])",1,"/**
 * Set the sound to play, along with a specific stream on which to play it.
 *
 * See {@link android.media.AudioManager} for the <code>STREAM_</code> constants.
 *
 * <p>
 * A notification that is noisy is more likely to be presented as a heads-up notification.
 * </p>
 * @deprecated use {@link #setSound(Uri, AudioAttributes)} instead.
 * @see Notification#sound
 */
","/**
 * Set the sound to play, along with a specific stream on which to play it.
 *
 * See {@link android.media.AudioManager} for the <code>STREAM_</code> constants.
 *
 * @deprecated use {@link NotificationChannel#setSound(Uri, AudioAttributes)}.
 */
",1,[@Deprecated],[@Deprecated],0,,,,2,4,0,5,2,"In the late version, a new method call is added before the assignment expressions, which is not present in the early version. The new method call is `PlayerBase.deprecateStreamTypeForPlayback(streamType, ""Notification"", ""setSound()"")`.","The new method call `PlayerBase.deprecateStreamTypeForPlayback(streamType, ""Notification"", ""setSound()"")` in the late version could potentially change the behavior of the API. It is not clear from the provided information what this method does, but its name suggests that it might deprecate a certain stream type, which could lead to a different exception being thrown when the API is invoked in the late version compared to the early version. Therefore, this is a Compatibility Issue caused by potential different exception handlings."
78,"<android.provider.DocumentsProvider: String renameDocument(String,String)>",25,26,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(throw new UnsupportedOperationException(""Rename not supported""), []), Statement(}, [])])  Statement({, [])  Statement(throw new UnsupportedOperationException(""Rename not supported""), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(throw new UnsupportedOperationException(""Rename not supported""), []), Statement(}, [])])  Statement({, [])  Statement(throw new UnsupportedOperationException(""Rename not supported""), [])  Statement(}, [])",0,"/**
 * Rename an existing document.
 * <p>
 * If a different {@link Document#COLUMN_DOCUMENT_ID} must be used to
 * represent the renamed document, generate and return it. Any outstanding
 * URI permission grants will be updated to point at the new document. If
 * the original {@link Document#COLUMN_DOCUMENT_ID} is still valid after the
 * rename, return {@code null}.
 *
 * @param documentId the document to rename.
 * @param displayName the updated display name of the document. The provider
 * may alter this name to meet any internal constraints, such as
 * avoiding conflicting names.
 */
","/**
 * Rename an existing document.
 * <p>
 * If a different {@link Document#COLUMN_DOCUMENT_ID} must be used to
 * represent the renamed document, generate and return it. Any outstanding
 * URI permission grants will be updated to point at the new document. If
 * the original {@link Document#COLUMN_DOCUMENT_ID} is still valid after the
 * rename, return {@code null}.
 *
 * @param documentId the document to rename.
 * @param displayName the updated display name of the document. The provider
 * may alter this name to meet any internal constraints, such as
 * avoiding conflicting names.
 * @throws AuthenticationRequiredException If authentication is required from
 * the user (such as login credentials), but it is not guaranteed
 * that the client will handle this properly.
 */
",1,[@SuppressWarnings("unused")],[@SuppressWarnings("unused")],0,,,,0,0,0,2,2,A new exception handling statement has been introduced (throw new AuthenticationRequiredException(...)) in the late version API implementation.,"The introduced exception handling statement could lead to different behaviour when the late version API is invoked, thus the CI type is 2."
79,"<android.app.admin.DevicePolicyManager: boolean isPackageSuspended(ComponentName,String)>",25,26,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(throwIfParentInstance(""isPackageSuspended""), []), AssignmentExpression(=, [VariableReference(if (mService !, []), Expression(null) {, [])]), Statement(try {, []), MethodCall(return mService.isPackageSuspended(admin, packageName), [VariableReference(return mService, []), Expression(admin, []), Expression(packageName, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(} catch (IllegalArgumentException ex) {, []), Statement(throw new NameNotFoundException(packageName), []), Statement(}, []), Statement(}, []), Statement(return false, []), Statement(}, [])])  Statement({, [])  Statement(throwIfParentInstance(""isPackageSuspended""), [])  AssignmentExpression(=, [VariableReference(if (mService !, []), Expression(null) {, [])])    VariableReference(if (mService !, [])    Expression(null) {, [])  Statement(try {, [])  MethodCall(return mService.isPackageSuspended(admin, packageName), [VariableReference(return mService, []), Expression(admin, []), Expression(packageName, [])])    VariableReference(return mService, [])    Expression(admin, [])    Expression(packageName, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(} catch (IllegalArgumentException ex) {, [])  Statement(throw new NameNotFoundException(packageName), [])  Statement(}, [])  Statement(}, [])  Statement(return false, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(throwIfParentInstance(""isPackageSuspended""), []), AssignmentExpression(=, [VariableReference(if (mService !, []), Expression(null) {, [])]), Statement(try {, []), MethodCall(return mService.isPackageSuspended(admin, mContext.getPackageName(), packageName), [VariableReference(return mService, []), Expression(admin, []), Expression(mContext.getPackageName(), []), Expression(packageName, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(} catch (IllegalArgumentException ex) {, []), Statement(throw new NameNotFoundException(packageName), []), Statement(}, []), Statement(}, []), Statement(return false, []), Statement(}, [])])  Statement({, [])  Statement(throwIfParentInstance(""isPackageSuspended""), [])  AssignmentExpression(=, [VariableReference(if (mService !, []), Expression(null) {, [])])    VariableReference(if (mService !, [])    Expression(null) {, [])  Statement(try {, [])  MethodCall(return mService.isPackageSuspended(admin, mContext.getPackageName(), packageName), [VariableReference(return mService, []), Expression(admin, []), Expression(mContext.getPackageName(), []), Expression(packageName, [])])    VariableReference(return mService, [])    Expression(admin, [])    Expression(mContext.getPackageName(), [])    Expression(packageName, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(} catch (IllegalArgumentException ex) {, [])  Statement(throw new NameNotFoundException(packageName), [])  Statement(}, [])  Statement(}, [])  Statement(return false, [])  Statement(}, [])",1,"/**
 * Called by device or profile owners to determine if a package is suspended.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param packageName The name of the package to retrieve the suspended status of.
 * @return {@code true} if the package is suspended or {@code false} if the package is not
 * suspended, could not be found or an error occurred.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 * @throws NameNotFoundException if the package could not be found.
 */
","/**
 * Determine if a package is suspended. This function can be called by a device owner, profile
 * owner, or by a delegate given the {@link #DELEGATION_PACKAGE_ACCESS} scope via
 * {@link #setDelegatedScopes}.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or
 * {@code null} if the caller is a package access delegate.
 * @param packageName The name of the package to retrieve the suspended status of.
 * @return {@code true} if the package is suspended or {@code false} if the package is not
 * suspended, could not be found or an error occurred.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 * @throws NameNotFoundException if the package could not be found.
 * @see #setDelegatedScopes
 * @see #DELEGATION_PACKAGE_ACCESS
 */
",1,,,0,,,,2,"1,5",1,5,1,The number of parameters in the method call "mService.isPackageSuspended" has changed from 2 to 3 in the late version implementation. The additional parameter is "mContext.getPackageName()".,"The change in the number of parameters in the method call can potentially lead to different return values or types. The additional parameter ""mContext.getPackageName()"" may affect the logic of the ""isPackageSuspended"" method in the late version, which may result in a different boolean value being returned compared to the early version. Therefore, this is a Compatibility Issue caused by potential different return values or types."
80,<android.app.UiAutomation: AccessibilityNodeInfo findFocus(int)>,25,26,,,,"MethodDeclaration(method_body, [Statement({, []), MethodCall(return AccessibilityInteractionClient.getInstance().findFocus(mConnectionId, AccessibilityNodeInfo.ANY_WINDOW_ID, AccessibilityNodeInfo.ROOT_NODE_ID, focus), [VariableReference(return AccessibilityInteractionClient, []), Expression().findFocus(mConnectionId, []), Expression(AccessibilityNodeInfo.ANY_WINDOW_ID, []), Expression(AccessibilityNodeInfo.ROOT_NODE_ID, []), Expression(focus, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return AccessibilityInteractionClient.getInstance().findFocus(mConnectionId, AccessibilityNodeInfo.ANY_WINDOW_ID, AccessibilityNodeInfo.ROOT_NODE_ID, focus), [VariableReference(return AccessibilityInteractionClient, []), Expression().findFocus(mConnectionId, []), Expression(AccessibilityNodeInfo.ANY_WINDOW_ID, []), Expression(AccessibilityNodeInfo.ROOT_NODE_ID, []), Expression(focus, [])])    VariableReference(return AccessibilityInteractionClient, [])    Expression().findFocus(mConnectionId, [])    Expression(AccessibilityNodeInfo.ANY_WINDOW_ID, [])    Expression(AccessibilityNodeInfo.ROOT_NODE_ID, [])    Expression(focus, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(return AccessibilityInteractionClient.getInstance().findFocus(mConnectionId, AccessibilityWindowInfo.ANY_WINDOW_ID, AccessibilityNodeInfo.ROOT_NODE_ID, focus), [VariableReference(return AccessibilityInteractionClient, []), Expression().findFocus(mConnectionId, []), Expression(AccessibilityWindowInfo.ANY_WINDOW_ID, []), Expression(AccessibilityNodeInfo.ROOT_NODE_ID, []), Expression(focus, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return AccessibilityInteractionClient.getInstance().findFocus(mConnectionId, AccessibilityWindowInfo.ANY_WINDOW_ID, AccessibilityNodeInfo.ROOT_NODE_ID, focus), [VariableReference(return AccessibilityInteractionClient, []), Expression().findFocus(mConnectionId, []), Expression(AccessibilityWindowInfo.ANY_WINDOW_ID, []), Expression(AccessibilityNodeInfo.ROOT_NODE_ID, []), Expression(focus, [])])    VariableReference(return AccessibilityInteractionClient, [])    Expression().findFocus(mConnectionId, [])    Expression(AccessibilityWindowInfo.ANY_WINDOW_ID, [])    Expression(AccessibilityNodeInfo.ROOT_NODE_ID, [])    Expression(focus, [])  Statement(}, [])",1,"/**
 * Find the view that has the specified focus type. The search is performed
 * across all windows.
 * <p>
 * <strong>Note:</strong> In order to access the windows you have to opt-in
 * to retrieve the interactive windows by setting the
 * {@link AccessibilityServiceInfo#FLAG_RETRIEVE_INTERACTIVE_WINDOWS} flag.
 * Otherwise, the search will be performed only in the active window.
 * </p>
 *
 * @param focus The focus to find. One of {@link AccessibilityNodeInfo#FOCUS_INPUT} or
 * {@link AccessibilityNodeInfo#FOCUS_ACCESSIBILITY}.
 * @return The node info of the focused view or null.
 *
 * @see AccessibilityNodeInfo#FOCUS_INPUT
 * @see AccessibilityNodeInfo#FOCUS_ACCESSIBILITY
 */
","/**
 * Find the view that has the specified focus type. The search is performed
 * across all windows.
 * <p>
 * <strong>Note:</strong> In order to access the windows you have to opt-in
 * to retrieve the interactive windows by setting the
 * {@link AccessibilityServiceInfo#FLAG_RETRIEVE_INTERACTIVE_WINDOWS} flag.
 * Otherwise, the search will be performed only in the active window.
 * </p>
 *
 * @param focus The focus to find. One of {@link AccessibilityNodeInfo#FOCUS_INPUT} or
 * {@link AccessibilityNodeInfo#FOCUS_ACCESSIBILITY}.
 * @return The node info of the focused view or null.
 *
 * @see AccessibilityNodeInfo#FOCUS_INPUT
 * @see AccessibilityNodeInfo#FOCUS_ACCESSIBILITY
 */
",0,,,0,,,,"1,2","1,5",1,5,1,"The code change is that the parameter `AccessibilityNodeInfo.ANY_WINDOW_ID` in the early version is replaced with `AccessibilityWindowInfo.ANY_WINDOW_ID` in the late version. This change is classified as 5) Dependent API changed, since the replacement of the parameter value from a constant of `AccessibilityNodeInfo` class to a constant of `AccessibilityWindowInfo` class is considered as a change of the dependent API.","The Compatibility Issue is caused by the potential different return values or types (classified as 1). The reason is that the replacement of the parameter value from `AccessibilityNodeInfo.ANY_WINDOW_ID` to `AccessibilityWindowInfo.ANY_WINDOW_ID` may lead to different search results in the `findFocus` method, and thus, the returned `AccessibilityNodeInfo` object (or null) may be different between the two versions."
81,"<android.net.nsd.NsdServiceInfo: Map<String, byte[]> getAttributes()>",25,26,,,,"MethodDeclaration(method_body, [Statement({, []), MethodCall(return Collections.unmodifiableMap(mTxtRecord), [VariableReference(return Collections, []), Expression(mTxtRecord, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return Collections.unmodifiableMap(mTxtRecord), [VariableReference(return Collections, []), Expression(mTxtRecord, [])])    VariableReference(return Collections, [])    Expression(mTxtRecord, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(return Collections.unmodifiableMap(mTxtRecord), [VariableReference(return Collections, []), Expression(mTxtRecord, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return Collections.unmodifiableMap(mTxtRecord), [VariableReference(return Collections, []), Expression(mTxtRecord, [])])    VariableReference(return Collections, [])    Expression(mTxtRecord, [])  Statement(}, [])",0,"/**
 * Retrive attributes as a map of String keys to byte[] values.
 *
 * <p> The returned map is unmodifiable; changes must be made through {@link #setAttribute} and
 * {@link #removeAttribute}.
 */
","/**
 * Retrieve attributes as a map of String keys to byte[] values. The attributes map is only
 * valid for a resolved service.
 *
 * <p> The returned map is unmodifiable; changes must be made through {@link #setAttribute} and
 * {@link #removeAttribute}.
 */
",1,,,0,,,,0,0,0,0,0,"There are no changes in the implementation of the method, the comments or the annotations.",There are no Compatibility Issues as there are no changes that could lead to different behaviours.
82,"<android.content.pm.PackageInstaller.SessionParams: void writeToParcel(Parcel,int)>",25,26,,,,"MethodDeclaration(method_body, [Statement({, []), MethodCall(dest.writeInt(mode), [VariableReference(dest, []), Expression(mode, [])]), MethodCall(dest.writeInt(installFlags), [VariableReference(dest, []), Expression(installFlags, [])]), MethodCall(dest.writeInt(installLocation), [VariableReference(dest, []), Expression(installLocation, [])]), MethodCall(dest.writeLong(sizeBytes), [VariableReference(dest, []), Expression(sizeBytes, [])]), MethodCall(dest.writeString(appPackageName), [VariableReference(dest, []), Expression(appPackageName, [])]), MethodCall(dest.writeParcelable(appIcon, flags), [VariableReference(dest, []), Expression(appIcon, []), Expression(flags, [])]), MethodCall(dest.writeString(appLabel), [VariableReference(dest, []), Expression(appLabel, [])]), MethodCall(dest.writeParcelable(originatingUri, flags), [VariableReference(dest, []), Expression(originatingUri, []), Expression(flags, [])]), MethodCall(dest.writeInt(originatingUid), [VariableReference(dest, []), Expression(originatingUid, [])]), MethodCall(dest.writeParcelable(referrerUri, flags), [VariableReference(dest, []), Expression(referrerUri, []), Expression(flags, [])]), MethodCall(dest.writeString(abiOverride), [VariableReference(dest, []), Expression(abiOverride, [])]), MethodCall(dest.writeString(volumeUuid), [VariableReference(dest, []), Expression(volumeUuid, [])]), MethodCall(dest.writeStringArray(grantedRuntimePermissions), [VariableReference(dest, []), Expression(grantedRuntimePermissions, [])]), Statement(}, [])])  Statement({, [])  MethodCall(dest.writeInt(mode), [VariableReference(dest, []), Expression(mode, [])])    VariableReference(dest, [])    Expression(mode, [])  MethodCall(dest.writeInt(installFlags), [VariableReference(dest, []), Expression(installFlags, [])])    VariableReference(dest, [])    Expression(installFlags, [])  MethodCall(dest.writeInt(installLocation), [VariableReference(dest, []), Expression(installLocation, [])])    VariableReference(dest, [])    Expression(installLocation, [])  MethodCall(dest.writeLong(sizeBytes), [VariableReference(dest, []), Expression(sizeBytes, [])])    VariableReference(dest, [])    Expression(sizeBytes, [])  MethodCall(dest.writeString(appPackageName), [VariableReference(dest, []), Expression(appPackageName, [])])    VariableReference(dest, [])    Expression(appPackageName, [])  MethodCall(dest.writeParcelable(appIcon, flags), [VariableReference(dest, []), Expression(appIcon, []), Expression(flags, [])])    VariableReference(dest, [])    Expression(appIcon, [])    Expression(flags, [])  MethodCall(dest.writeString(appLabel), [VariableReference(dest, []), Expression(appLabel, [])])    VariableReference(dest, [])    Expression(appLabel, [])  MethodCall(dest.writeParcelable(originatingUri, flags), [VariableReference(dest, []), Expression(originatingUri, []), Expression(flags, [])])    VariableReference(dest, [])    Expression(originatingUri, [])    Expression(flags, [])  MethodCall(dest.writeInt(originatingUid), [VariableReference(dest, []), Expression(originatingUid, [])])    VariableReference(dest, [])    Expression(originatingUid, [])  MethodCall(dest.writeParcelable(referrerUri, flags), [VariableReference(dest, []), Expression(referrerUri, []), Expression(flags, [])])    VariableReference(dest, [])    Expression(referrerUri, [])    Expression(flags, [])  MethodCall(dest.writeString(abiOverride), [VariableReference(dest, []), Expression(abiOverride, [])])    VariableReference(dest, [])    Expression(abiOverride, [])  MethodCall(dest.writeString(volumeUuid), [VariableReference(dest, []), Expression(volumeUuid, [])])    VariableReference(dest, [])    Expression(volumeUuid, [])  MethodCall(dest.writeStringArray(grantedRuntimePermissions), [VariableReference(dest, []), Expression(grantedRuntimePermissions, [])])    VariableReference(dest, [])    Expression(grantedRuntimePermissions, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(dest.writeInt(mode), [VariableReference(dest, []), Expression(mode, [])]), MethodCall(dest.writeInt(installFlags), [VariableReference(dest, []), Expression(installFlags, [])]), MethodCall(dest.writeInt(installLocation), [VariableReference(dest, []), Expression(installLocation, [])]), MethodCall(dest.writeInt(installReason), [VariableReference(dest, []), Expression(installReason, [])]), MethodCall(dest.writeLong(sizeBytes), [VariableReference(dest, []), Expression(sizeBytes, [])]), MethodCall(dest.writeString(appPackageName), [VariableReference(dest, []), Expression(appPackageName, [])]), MethodCall(dest.writeParcelable(appIcon, flags), [VariableReference(dest, []), Expression(appIcon, []), Expression(flags, [])]), MethodCall(dest.writeString(appLabel), [VariableReference(dest, []), Expression(appLabel, [])]), MethodCall(dest.writeParcelable(originatingUri, flags), [VariableReference(dest, []), Expression(originatingUri, []), Expression(flags, [])]), MethodCall(dest.writeInt(originatingUid), [VariableReference(dest, []), Expression(originatingUid, [])]), MethodCall(dest.writeParcelable(referrerUri, flags), [VariableReference(dest, []), Expression(referrerUri, []), Expression(flags, [])]), MethodCall(dest.writeString(abiOverride), [VariableReference(dest, []), Expression(abiOverride, [])]), MethodCall(dest.writeString(volumeUuid), [VariableReference(dest, []), Expression(volumeUuid, [])]), MethodCall(dest.writeStringArray(grantedRuntimePermissions), [VariableReference(dest, []), Expression(grantedRuntimePermissions, [])]), Statement(}, [])])  Statement({, [])  MethodCall(dest.writeInt(mode), [VariableReference(dest, []), Expression(mode, [])])    VariableReference(dest, [])    Expression(mode, [])  MethodCall(dest.writeInt(installFlags), [VariableReference(dest, []), Expression(installFlags, [])])    VariableReference(dest, [])    Expression(installFlags, [])  MethodCall(dest.writeInt(installLocation), [VariableReference(dest, []), Expression(installLocation, [])])    VariableReference(dest, [])    Expression(installLocation, [])  MethodCall(dest.writeInt(installReason), [VariableReference(dest, []), Expression(installReason, [])])    VariableReference(dest, [])    Expression(installReason, [])  MethodCall(dest.writeLong(sizeBytes), [VariableReference(dest, []), Expression(sizeBytes, [])])    VariableReference(dest, [])    Expression(sizeBytes, [])  MethodCall(dest.writeString(appPackageName), [VariableReference(dest, []), Expression(appPackageName, [])])    VariableReference(dest, [])    Expression(appPackageName, [])  MethodCall(dest.writeParcelable(appIcon, flags), [VariableReference(dest, []), Expression(appIcon, []), Expression(flags, [])])    VariableReference(dest, [])    Expression(appIcon, [])    Expression(flags, [])  MethodCall(dest.writeString(appLabel), [VariableReference(dest, []), Expression(appLabel, [])])    VariableReference(dest, [])    Expression(appLabel, [])  MethodCall(dest.writeParcelable(originatingUri, flags), [VariableReference(dest, []), Expression(originatingUri, []), Expression(flags, [])])    VariableReference(dest, [])    Expression(originatingUri, [])    Expression(flags, [])  MethodCall(dest.writeInt(originatingUid), [VariableReference(dest, []), Expression(originatingUid, [])])    VariableReference(dest, [])    Expression(originatingUid, [])  MethodCall(dest.writeParcelable(referrerUri, flags), [VariableReference(dest, []), Expression(referrerUri, []), Expression(flags, [])])    VariableReference(dest, [])    Expression(referrerUri, [])    Expression(flags, [])  MethodCall(dest.writeString(abiOverride), [VariableReference(dest, []), Expression(abiOverride, [])])    VariableReference(dest, [])    Expression(abiOverride, [])  MethodCall(dest.writeString(volumeUuid), [VariableReference(dest, []), Expression(volumeUuid, [])])    VariableReference(dest, [])    Expression(volumeUuid, [])  MethodCall(dest.writeStringArray(grantedRuntimePermissions), [VariableReference(dest, []), Expression(grantedRuntimePermissions, [])])    VariableReference(dest, [])    Expression(grantedRuntimePermissions, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,,1,4,1,5,1,"A new statement ""MethodCall(dest.writeInt(installReason), [VariableReference(dest, []), Expression(installReason, [])])"" has been added in the Late\_Implementation\_AST\_Node. This change belongs to the ""Other statement changed"" category.","The new statement added in the Late\_Implementation\_AST\_Node writes an additional integer value ""installReason"" to the Parcel object. This additional value may not be expected by the code that reads the Parcel object in the same or a different version of the Android OS. Therefore, this change has the potential to cause a compatibility issue by leading to different behaviors in the code that reads the Parcel object. The compatibility issue type is ""1) Compatibility Issue caused by potential different return values or types""."
83,<android.os.ParcelFileDescriptor.AutoCloseOutputStream: void close()>,28,29,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(mPfd.close(), [VariableReference(mPfd, []), Expression(, [])]), Statement(} finally {, []), MethodCall(super.close(), [VariableReference(super, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(mPfd.close(), [VariableReference(mPfd, []), Expression(, [])])    VariableReference(mPfd, [])    Expression(, [])  Statement(} finally {, [])  MethodCall(super.close(), [VariableReference(super, []), Expression(, [])])    VariableReference(super, [])    Expression(, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(super.close(), [VariableReference(super, []), Expression(, [])]), Statement(} finally {, []), MethodCall(mPfd.close(), [VariableReference(mPfd, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(super.close(), [VariableReference(super, []), Expression(, [])])    VariableReference(super, [])    Expression(, [])  Statement(} finally {, [])  MethodCall(mPfd.close(), [VariableReference(mPfd, []), Expression(, [])])    VariableReference(mPfd, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,,1,3,0,"2,5","1,2","The order of two method calls has changed in the late version implementation. In the early version, ""mPfd.close()"" is called before ""super.close()"", while in the late version, ""super.close()"" is called before ""mPfd.close()"". Moreover, two new statements ""Statement({, []), Statement(}, [])"" are added in the late version implementation, which may affect the control dependency.","The change in the order of method calls may lead to different behaviors and result in compatibility issues. Specifically, if ""super.close()"" has side-effects that affect the state of ""mPfd"", or if ""mPfd.close()"" may throw exceptions that are supposed to be handled by ""super.close()"", this change can cause the API to return different values or types, or throw different exceptions, which are both classified as CI."
84,"<android.app.usage.UsageStatsManager: List<UsageStats> queryUsageStats(int,long,long)>",28,29,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), AssignmentExpression(=, [VariableReference(@SuppressWarnings(""unchecked"") ParceledListSlice<UsageStats> slice, []), Expression(mService.queryUsageStats(intervalType, beginTime, endTime, mContext.getOpPackageName()), [])]), AssignmentExpression(=, [VariableReference(if (slice !, []), Expression(null) {, [])]), MethodCall(return slice.getList(), [VariableReference(return slice, []), Expression(, [])]), Statement(}, []), Statement(} catch (RemoteException e) {, []), Statement(// fallthrough and return the empty list., []), Statement(}, []), MethodCall(return Collections.emptyList(), [VariableReference(return Collections, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(@SuppressWarnings(""unchecked"") ParceledListSlice<UsageStats> slice, []), Expression(mService.queryUsageStats(intervalType, beginTime, endTime, mContext.getOpPackageName()), [])])    VariableReference(@SuppressWarnings(""unchecked"") ParceledListSlice<UsageStats> slice, [])    Expression(mService.queryUsageStats(intervalType, beginTime, endTime, mContext.getOpPackageName()), [])  AssignmentExpression(=, [VariableReference(if (slice !, []), Expression(null) {, [])])    VariableReference(if (slice !, [])    Expression(null) {, [])  MethodCall(return slice.getList(), [VariableReference(return slice, []), Expression(, [])])    VariableReference(return slice, [])    Expression(, [])  Statement(}, [])  Statement(} catch (RemoteException e) {, [])  Statement(// fallthrough and return the empty list., [])  Statement(}, [])  MethodCall(return Collections.emptyList(), [VariableReference(return Collections, []), Expression(, [])])    VariableReference(return Collections, [])    Expression(, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), AssignmentExpression(=, [VariableReference(@SuppressWarnings(""unchecked"") ParceledListSlice<UsageStats> slice, []), Expression(mService.queryUsageStats(intervalType, beginTime, endTime, mContext.getOpPackageName()), [])]), AssignmentExpression(=, [VariableReference(if (slice !, []), Expression(null) {, [])]), MethodCall(return slice.getList(), [VariableReference(return slice, []), Expression(, [])]), Statement(}, []), Statement(} catch (RemoteException e) {, []), Statement(// fallthrough and return the empty list., []), Statement(}, []), MethodCall(return Collections.emptyList(), [VariableReference(return Collections, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(@SuppressWarnings(""unchecked"") ParceledListSlice<UsageStats> slice, []), Expression(mService.queryUsageStats(intervalType, beginTime, endTime, mContext.getOpPackageName()), [])])    VariableReference(@SuppressWarnings(""unchecked"") ParceledListSlice<UsageStats> slice, [])    Expression(mService.queryUsageStats(intervalType, beginTime, endTime, mContext.getOpPackageName()), [])  AssignmentExpression(=, [VariableReference(if (slice !, []), Expression(null) {, [])])    VariableReference(if (slice !, [])    Expression(null) {, [])  MethodCall(return slice.getList(), [VariableReference(return slice, []), Expression(, [])])    VariableReference(return slice, [])    Expression(, [])  Statement(}, [])  Statement(} catch (RemoteException e) {, [])  Statement(// fallthrough and return the empty list., [])  Statement(}, [])  MethodCall(return Collections.emptyList(), [VariableReference(return Collections, []), Expression(, [])])    VariableReference(return Collections, [])    Expression(, [])  Statement(}, [])",0,"/**
 * Gets application usage stats for the given time range, aggregated by the specified interval.
 * <p>The returned list will contain a {@link UsageStats} object for each package that
 * has data for an interval that is a subset of the time range given. To illustrate:</p>
 * <pre>
 * intervalType = INTERVAL_YEARLY
 * beginTime = 2013
 * endTime = 2015 (exclusive)
 *
 * Results:
 * 2013 - com.example.alpha
 * 2013 - com.example.beta
 * 2014 - com.example.alpha
 * 2014 - com.example.beta
 * 2014 - com.example.charlie
 * </pre>
 *
 * <p> The caller must have {@link android.Manifest.permission#PACKAGE_USAGE_STATS} </p>
 *
 * @param intervalType The time interval by which the stats are aggregated.
 * @param beginTime The inclusive beginning of the range of stats to include in the results.
 * @param endTime The exclusive end of the range of stats to include in the results.
 * @return A list of {@link UsageStats}
 *
 * @see #INTERVAL_DAILY
 * @see #INTERVAL_WEEKLY
 * @see #INTERVAL_MONTHLY
 * @see #INTERVAL_YEARLY
 * @see #INTERVAL_BEST
 */
","/**
 * Gets application usage stats for the given time range, aggregated by the specified interval.
 *
 * <p>
 * The returned list will contain one or more {@link UsageStats} objects for each package, with
 * usage data that covers at least the given time range.
 * Note: The begin and end times of the time range may be expanded to the nearest whole interval
 * period.
 * </p>
 *
 * <p> The caller must have {@link android.Manifest.permission#PACKAGE_USAGE_STATS} </p>
 *
 * @param intervalType The time interval by which the stats are aggregated.
 * @param beginTime The inclusive beginning of the range of stats to include in the results.
 * Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime The exclusive end of the range of stats to include in the results. Defined
 * in terms of ""Unix time"", see {@link java.lang.System#currentTimeMillis}.
 * @return A list of {@link UsageStats}
 *
 * @see #INTERVAL_DAILY
 * @see #INTERVAL_WEEKLY
 * @see #INTERVAL_MONTHLY
 * @see #INTERVAL_YEARLY
 * @see #INTERVAL_BEST
 */
",1,,,0,,,,0,0,0,0,0,There is no change between the two versions of the API implementation.,There is no compatibility issue between the two versions of the API. The behavior of the API remains the same.
86,"<android.view.textclassifier.TextLinks.Builder: Builder addLink(int,int,Map<String, Float>)>",28,29,,,,"MethodDeclaration(method_body, [Statement({, []), MethodCall(mLinks.add(new TextLink(start, end, entityScores, null)), [VariableReference(mLinks, []), Expression(new TextLink(start, []), Expression(end, []), Expression(entityScores, []), Expression(null), [])]), Statement(return this, []), Statement(}, [])])  Statement({, [])  MethodCall(mLinks.add(new TextLink(start, end, entityScores, null)), [VariableReference(mLinks, []), Expression(new TextLink(start, []), Expression(end, []), Expression(entityScores, []), Expression(null), [])])    VariableReference(mLinks, [])    Expression(new TextLink(start, [])    Expression(end, [])    Expression(entityScores, [])    Expression(null), [])  Statement(return this, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(}, [])])  Statement({, [])  Statement(}, [])",1,"/**
 * Adds a TextLink.
 *
 * @param start The start index of the identified subsequence
 * @param end The end index of the identified subsequence
 * @param entityScores A mapping of entity type to confidence score
 *
 * @throws IllegalArgumentException if entityScores is null or empty.
 */
","/**
 * Adds a TextLink.
 *
 * @param start The start index of the identified subsequence
 * @param end The end index of the identified subsequence
 * @param entityScores A mapping of entity type to confidence score
 *
 * @throws IllegalArgumentException if entityScores is null or empty.
 */
",0,[@NonNull],[@NonNull],0,,,,"1,2","1,5",1,4,1,"The implementation of the method in the late version has been completely removed, which means that the method will not perform any action. This is a change in Other statement.","The method in the early version adds a new TextLink object to the mLinks list, while the method in the late version does not perform any action. This means that the behavior of the method has changed, and it may cause compatibility issues if the code that uses this method relies on the fact that a new TextLink object is added to the mLinks list. This is a Compatibility Issue caused by potential different return values or types."
87,<android.view.inputmethod.InputMethodManager: InputMethodSubtype getLastInputMethodSubtype()>,28,29,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(synchronized (mH) {, []), Statement(try {, []), MethodCall(return mService.getLastInputMethodSubtype(), [VariableReference(return mService, []), Expression(, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(synchronized (mH) {, [])  Statement(try {, [])  MethodCall(return mService.getLastInputMethodSubtype(), [VariableReference(return mService, []), Expression(, [])])    VariableReference(return mService, [])    Expression(, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(return mService.getLastInputMethodSubtype(), [VariableReference(return mService, []), Expression(, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(return mService.getLastInputMethodSubtype(), [VariableReference(return mService, []), Expression(, [])])    VariableReference(return mService, [])    Expression(, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",1,,,0,,,0,,,,1,4,0,2,2,"A change occurred between the early and late versions of the given method, specifically in the exception handling statement. In the early version, the synchronized block is present with the try-catch block inside it. However, in the late version, the synchronized block is removed, and the try-catch block is directly placed inside the method. This change can potentially lead to different exception handling behavior.","The Compatibility Issue (CI) arises due to the potential different exception handling behavior caused by the change in the exception handling statement. As the synchronized block is removed in the late version, the exception handling behavior can be different compared to the early version, leading to CI."
88,<android.util.ArrayMap: String toString()>,28,29,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(if (isEmpty()) {, []), Statement(return ""{}"", []), Statement(}, []), AssignmentExpression(=, [VariableReference(StringBuilder buffer, []), Expression(new StringBuilder(mSize * 28), [])]), MethodCall(buffer.append('{'), [VariableReference(buffer, []), Expression('{', [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < mSize, []), Statement(i++) {, []), Statement(if (i > 0) {, []), MethodCall(buffer.append("", ""), [VariableReference(buffer, []), Expression("", []), Expression("", [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(Object key, []), Expression(keyAt(i), [])]), AssignmentExpression(=, [VariableReference(if (key !, []), Expression(this) {, [])]), MethodCall(buffer.append(key), [VariableReference(buffer, []), Expression(key, [])]), Statement(} else {, []), MethodCall(buffer.append(""(this Map)""), [VariableReference(buffer, []), Expression(""(this Map)"", [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(buffer.append(', []), Expression('), [])]), AssignmentExpression(=, [VariableReference(Object value, []), Expression(valueAt(i), [])]), AssignmentExpression(=, [VariableReference(if (value !, []), Expression(this) {, [])]), MethodCall(buffer.append(value), [VariableReference(buffer, []), Expression(value, [])]), Statement(} else {, []), MethodCall(buffer.append(""(this Map)""), [VariableReference(buffer, []), Expression(""(this Map)"", [])]), Statement(}, []), Statement(}, []), MethodCall(buffer.append('}'), [VariableReference(buffer, []), Expression('}', [])]), MethodCall(return buffer.toString(), [VariableReference(return buffer, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  Statement(if (isEmpty()) {, [])  Statement(return ""{}"", [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(StringBuilder buffer, []), Expression(new StringBuilder(mSize * 28), [])])    VariableReference(StringBuilder buffer, [])    Expression(new StringBuilder(mSize * 28), [])  MethodCall(buffer.append('{'), [VariableReference(buffer, []), Expression('{', [])])    VariableReference(buffer, [])    Expression('{', [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < mSize, [])  Statement(i++) {, [])  Statement(if (i > 0) {, [])  MethodCall(buffer.append("", ""), [VariableReference(buffer, []), Expression("", []), Expression("", [])])    VariableReference(buffer, [])    Expression("", [])    Expression("", [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(Object key, []), Expression(keyAt(i), [])])    VariableReference(Object key, [])    Expression(keyAt(i), [])  AssignmentExpression(=, [VariableReference(if (key !, []), Expression(this) {, [])])    VariableReference(if (key !, [])    Expression(this) {, [])  MethodCall(buffer.append(key), [VariableReference(buffer, []), Expression(key, [])])    VariableReference(buffer, [])    Expression(key, [])  Statement(} else {, [])  MethodCall(buffer.append(""(this Map)""), [VariableReference(buffer, []), Expression(""(this Map)"", [])])    VariableReference(buffer, [])    Expression(""(this Map)"", [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(buffer.append(', []), Expression('), [])])    VariableReference(buffer.append(', [])    Expression('), [])  AssignmentExpression(=, [VariableReference(Object value, []), Expression(valueAt(i), [])])    VariableReference(Object value, [])    Expression(valueAt(i), [])  AssignmentExpression(=, [VariableReference(if (value !, []), Expression(this) {, [])])    VariableReference(if (value !, [])    Expression(this) {, [])  MethodCall(buffer.append(value), [VariableReference(buffer, []), Expression(value, [])])    VariableReference(buffer, [])    Expression(value, [])  Statement(} else {, [])  MethodCall(buffer.append(""(this Map)""), [VariableReference(buffer, []), Expression(""(this Map)"", [])])    VariableReference(buffer, [])    Expression(""(this Map)"", [])  Statement(}, [])  Statement(}, [])  MethodCall(buffer.append('}'), [VariableReference(buffer, []), Expression('}', [])])    VariableReference(buffer, [])    Expression('}', [])  MethodCall(return buffer.toString(), [VariableReference(return buffer, []), Expression(, [])])    VariableReference(return buffer, [])    Expression(, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (isEmpty()) {, []), Statement(return ""{}"", []), Statement(}, []), AssignmentExpression(=, [VariableReference(StringBuilder buffer, []), Expression(new StringBuilder(mSize * 28), [])]), MethodCall(buffer.append('{'), [VariableReference(buffer, []), Expression('{', [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < mSize, []), Statement(i++) {, []), Statement(if (i > 0) {, []), MethodCall(buffer.append("", ""), [VariableReference(buffer, []), Expression("", []), Expression("", [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(Object key, []), Expression(keyAt(i), [])]), AssignmentExpression(=, [VariableReference(if (key !, []), Expression(this) {, [])]), MethodCall(buffer.append(key), [VariableReference(buffer, []), Expression(key, [])]), Statement(} else {, []), MethodCall(buffer.append(""(this Map)""), [VariableReference(buffer, []), Expression(""(this Map)"", [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(buffer.append(', []), Expression('), [])]), AssignmentExpression(=, [VariableReference(Object value, []), Expression(valueAt(i), [])]), AssignmentExpression(=, [VariableReference(if (value !, []), Expression(this) {, [])]), MethodCall(buffer.append(ArrayUtils.deepToString(value)), [VariableReference(buffer, []), Expression(ArrayUtils.deepToString(value), [])]), Statement(} else {, []), MethodCall(buffer.append(""(this Map)""), [VariableReference(buffer, []), Expression(""(this Map)"", [])]), Statement(}, []), Statement(}, []), MethodCall(buffer.append('}'), [VariableReference(buffer, []), Expression('}', [])]), MethodCall(return buffer.toString(), [VariableReference(return buffer, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  Statement(if (isEmpty()) {, [])  Statement(return ""{}"", [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(StringBuilder buffer, []), Expression(new StringBuilder(mSize * 28), [])])    VariableReference(StringBuilder buffer, [])    Expression(new StringBuilder(mSize * 28), [])  MethodCall(buffer.append('{'), [VariableReference(buffer, []), Expression('{', [])])    VariableReference(buffer, [])    Expression('{', [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < mSize, [])  Statement(i++) {, [])  Statement(if (i > 0) {, [])  MethodCall(buffer.append("", ""), [VariableReference(buffer, []), Expression("", []), Expression("", [])])    VariableReference(buffer, [])    Expression("", [])    Expression("", [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(Object key, []), Expression(keyAt(i), [])])    VariableReference(Object key, [])    Expression(keyAt(i), [])  AssignmentExpression(=, [VariableReference(if (key !, []), Expression(this) {, [])])    VariableReference(if (key !, [])    Expression(this) {, [])  MethodCall(buffer.append(key), [VariableReference(buffer, []), Expression(key, [])])    VariableReference(buffer, [])    Expression(key, [])  Statement(} else {, [])  MethodCall(buffer.append(""(this Map)""), [VariableReference(buffer, []), Expression(""(this Map)"", [])])    VariableReference(buffer, [])    Expression(""(this Map)"", [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(buffer.append(', []), Expression('), [])])    VariableReference(buffer.append(', [])    Expression('), [])  AssignmentExpression(=, [VariableReference(Object value, []), Expression(valueAt(i), [])])    VariableReference(Object value, [])    Expression(valueAt(i), [])  AssignmentExpression(=, [VariableReference(if (value !, []), Expression(this) {, [])])    VariableReference(if (value !, [])    Expression(this) {, [])  MethodCall(buffer.append(ArrayUtils.deepToString(value)), [VariableReference(buffer, []), Expression(ArrayUtils.deepToString(value), [])])    VariableReference(buffer, [])    Expression(ArrayUtils.deepToString(value), [])  Statement(} else {, [])  MethodCall(buffer.append(""(this Map)""), [VariableReference(buffer, []), Expression(""(this Map)"", [])])    VariableReference(buffer, [])    Expression(""(this Map)"", [])  Statement(}, [])  Statement(}, [])  MethodCall(buffer.append('}'), [VariableReference(buffer, []), Expression('}', [])])    VariableReference(buffer, [])    Expression('}', [])  MethodCall(return buffer.toString(), [VariableReference(return buffer, []), Expression(, [])])    VariableReference(return buffer, [])    Expression(, [])  Statement(}, [])",1,"/**
 * {@inheritDoc}
 *
 * <p>This implementation composes a string by iterating over its mappings. If
 * this map contains itself as a key or a value, the string ""(this Map)""
 * will appear in its place.
 */
","/**
 * {@inheritDoc}
 *
 * <p>This implementation composes a string by iterating over its mappings. If
 * this map contains itself as a key or a value, the string ""(this Map)""
 * will appear in its place.
 */
",0,[@Override],[@Override],0,,,,"1,2",4,1,4,1,"The code change is in the method call statement. In the early version, the method call is ""buffer.append(value)"", while in the late version, the method call is ""buffer.append(ArrayUtils.deepToString(value))"". This is a change in the method being called, which affects the behavior of the code.","The Compatibility Issue is caused by potential different return values or types. The change in the method call affects the value being appended to the ""buffer"" variable. In the early version, the value of the map is directly appended to the buffer, while in the late version, the value is first converted to a string using the ""deepToString"" method and then appended to the buffer. This can lead to different behaviors in the code, such as differences in the output string, especially if the values in the map are complex objects or arrays."
89,<android.hardware.camera2.CameraMetadata: List<TKey> getKeys()>,28,29,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(Class<CameraMetadata<TKey>> thisClass, []), Expression((Class<CameraMetadata<TKey>>) getClass(), [])]), MethodCall(return Collections.unmodifiableList(getKeys(thisClass, getKeyClass(), [VariableReference(return Collections, []), Expression(getKeys(thisClass, []), Expression(getKeyClass(, [])]), Statement(null)), []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(Class<CameraMetadata<TKey>> thisClass, []), Expression((Class<CameraMetadata<TKey>>) getClass(), [])])    VariableReference(Class<CameraMetadata<TKey>> thisClass, [])    Expression((Class<CameraMetadata<TKey>>) getClass(), [])  MethodCall(return Collections.unmodifiableList(getKeys(thisClass, getKeyClass(), [VariableReference(return Collections, []), Expression(getKeys(thisClass, []), Expression(getKeyClass(, [])])    VariableReference(return Collections, [])    Expression(getKeys(thisClass, [])    Expression(getKeyClass(, [])  Statement(null)), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(Class<CameraMetadata<TKey>> thisClass, []), Expression((Class<CameraMetadata<TKey>>) getClass(), [])]), MethodCall(return Collections.unmodifiableList(getKeys(thisClass, getKeyClass(), [VariableReference(return Collections, []), Expression(getKeys(thisClass, []), Expression(getKeyClass(, [])]), Statement(null, /*includeSynthetic*/, []), Statement(true)), []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(Class<CameraMetadata<TKey>> thisClass, []), Expression((Class<CameraMetadata<TKey>>) getClass(), [])])    VariableReference(Class<CameraMetadata<TKey>> thisClass, [])    Expression((Class<CameraMetadata<TKey>>) getClass(), [])  MethodCall(return Collections.unmodifiableList(getKeys(thisClass, getKeyClass(), [VariableReference(return Collections, []), Expression(getKeys(thisClass, []), Expression(getKeyClass(, [])])    VariableReference(return Collections, [])    Expression(getKeys(thisClass, [])    Expression(getKeyClass(, [])  Statement(null, /*includeSynthetic*/, [])  Statement(true)), [])  Statement(}, [])",1,"/**
 * Returns a list of the keys contained in this map.
 *
 * <p>The list returned is not modifiable, so any attempts to modify it will throw
 * a {@code UnsupportedOperationException}.</p>
 *
 * <p>All values retrieved by a key from this list with {@code #get} are guaranteed to be
 * non-{@code null}. Each key is only listed once in the list. The order of the keys
 * is undefined.</p>
 *
 * @return List of the keys contained in this map.
 */
","/**
 * Returns a list of the keys contained in this map.
 *
 * <p>The list returned is not modifiable, so any attempts to modify it will throw
 * a {@code UnsupportedOperationException}.</p>
 *
 * <p>All values retrieved by a key from this list with {@code #get} are guaranteed to be
 * non-{@code null}. Each key is only listed once in the list. The order of the keys
 * is undefined.</p>
 *
 * @return List of the keys contained in this map.
 */
",0,"[@SuppressWarnings(""unchecked""), @NonNull]","[@SuppressWarnings(""unchecked""), @NonNull]",0,,,,2,"1,5",1,"1,5",0,"The reason for this classification is that there is no actual change in the implementation code between the early and late versions. The only difference is the presence of two additional statements in the late version's AST node, `Statement(null, /*includeSynthetic*/, [])` and `Statement(true)`, but these statements do not have any effect on the behavior of the API.","The reason for this classification is that there is no actual change in the implementation code between the early and late versions, which means that the API's behavior remains the same. Therefore, there is no potential for any compatibility issues to arise."
90,<android.app.Activity: int getRequestedOrientation()>,28,29,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mParent, []), Expression(, [])]), Statement(try {, []), MethodCall(return ActivityManager.getService().getRequestedOrientation(mToken), [VariableReference(return ActivityManager, []), Expression().getRequestedOrientation(mToken, [])]), Statement(} catch (RemoteException e) {, []), Statement(// Empty, []), Statement(}, []), Statement(} else {, []), MethodCall(return mParent.getRequestedOrientation(), [VariableReference(return mParent, []), Expression(, [])]), Statement(}, []), Statement(return ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mParent, []), Expression(, [])])    VariableReference(if (mParent, [])    Expression(, [])  Statement(try {, [])  MethodCall(return ActivityManager.getService().getRequestedOrientation(mToken), [VariableReference(return ActivityManager, []), Expression().getRequestedOrientation(mToken, [])])    VariableReference(return ActivityManager, [])    Expression().getRequestedOrientation(mToken, [])  Statement(} catch (RemoteException e) {, [])  Statement(// Empty, [])  Statement(}, [])  Statement(} else {, [])  MethodCall(return mParent.getRequestedOrientation(), [VariableReference(return mParent, []), Expression(, [])])    VariableReference(return mParent, [])    Expression(, [])  Statement(}, [])  Statement(return ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mParent, []), Expression(, [])]), Statement(try {, []), MethodCall(return ActivityTaskManager.getService().getRequestedOrientation(mToken), [VariableReference(return ActivityTaskManager, []), Expression().getRequestedOrientation(mToken, [])]), Statement(} catch (RemoteException e) {, []), Statement(// Empty, []), Statement(}, []), Statement(} else {, []), MethodCall(return mParent.getRequestedOrientation(), [VariableReference(return mParent, []), Expression(, [])]), Statement(}, []), Statement(return ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mParent, []), Expression(, [])])    VariableReference(if (mParent, [])    Expression(, [])  Statement(try {, [])  MethodCall(return ActivityTaskManager.getService().getRequestedOrientation(mToken), [VariableReference(return ActivityTaskManager, []), Expression().getRequestedOrientation(mToken, [])])    VariableReference(return ActivityTaskManager, [])    Expression().getRequestedOrientation(mToken, [])  Statement(} catch (RemoteException e) {, [])  Statement(// Empty, [])  Statement(}, [])  Statement(} else {, [])  MethodCall(return mParent.getRequestedOrientation(), [VariableReference(return mParent, []), Expression(, [])])    VariableReference(return mParent, [])    Expression(, [])  Statement(}, [])  Statement(return ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED, [])  Statement(}, [])",1,"/**
 * Return the current requested orientation of the activity.  This will
 * either be the orientation requested in its component's manifest, or
 * the last requested orientation given to
 * {@link #setRequestedOrientation(int)}.
 *
 * @return Returns an orientation constant as used in
 * {@link ActivityInfo#screenOrientation ActivityInfo.screenOrientation}.
 */
","/**
 * Return the current requested orientation of the activity.  This will
 * either be the orientation requested in its component's manifest, or
 * the last requested orientation given to
 * {@link #setRequestedOrientation(int)}.
 *
 * @return Returns an orientation constant as used in
 * {@link ActivityInfo#screenOrientation ActivityInfo.screenOrientation}.
 */
",0,[@ActivityInfo.ScreenOrientation],[@ActivityInfo.ScreenOrientation],0,,,,2,"1,5",1,5,1,The implementation of the method `getRequestedOrientation()` has been changed from using `ActivityManager.getService().getRequestedOrientation(mToken)` to `ActivityTaskManager.getService().getRequestedOrientation(mToken)`. This means that the API is now relying on a different dependent API.,"The change in the dependent API could potentially lead to different behaviors. The `ActivityTaskManager` and `ActivityManager` may not always return the same value for the requested orientation, which could cause compatibility issues in apps that rely on the consistency of this value. Therefore, the CI type is 1 - Compatibility Issue caused by potential different return values or types."
91,<android.view.MenuItem: Mode getIconTintMode()>,28,29,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(return null, []), Statement(}, [])])  Statement({, [])  Statement(return null, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return null, []), Statement(}, [])])  Statement({, [])  Statement(return null, [])  Statement(}, [])",0,"/**
 * Returns the blending mode used to apply the tint to this item's icon, if specified.
 *
 * @return the blending mode used to apply the tint to this item's icon
 * @attr ref android.R.styleable#MenuItem_iconTintMode
 * @see #setIconTintMode(PorterDuff.Mode)
 */
","/**
 * Returns the blending mode used to apply the tint to this item's icon, if specified.
 *
 * @return the blending mode used to apply the tint to this item's icon
 * @attr ref android.R.styleable#MenuItem_iconTintMode
 * @see #setIconTintMode(PorterDuff.Mode)
 * @see #setIconTintBlendMode(BlendMode)
 */
",1,[@Nullable],[@Nullable],0,,,,0,0,0,0,0,"There is no change in the implementation, only a new ""see"" tag is added to the late version comment.","Since there is no change in the implementation, there is no compatibility issue."
92,<android.view.ViewTreeObserver: void merge(ViewTreeObserver)>,28,29,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (observer.mOnWindowAttachListeners !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(if (mOnWindowAttachListeners !, []), Expression(null) {, [])]), MethodCall(mOnWindowAttachListeners.addAll(observer.mOnWindowAttachListeners), [VariableReference(mOnWindowAttachListeners, []), Expression(observer.mOnWindowAttachListeners, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mOnWindowAttachListeners, []), Expression(observer.mOnWindowAttachListeners, [])]), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (observer.mOnWindowFocusListeners !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(if (mOnWindowFocusListeners !, []), Expression(null) {, [])]), MethodCall(mOnWindowFocusListeners.addAll(observer.mOnWindowFocusListeners), [VariableReference(mOnWindowFocusListeners, []), Expression(observer.mOnWindowFocusListeners, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mOnWindowFocusListeners, []), Expression(observer.mOnWindowFocusListeners, [])]), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (observer.mOnGlobalFocusListeners !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(if (mOnGlobalFocusListeners !, []), Expression(null) {, [])]), MethodCall(mOnGlobalFocusListeners.addAll(observer.mOnGlobalFocusListeners), [VariableReference(mOnGlobalFocusListeners, []), Expression(observer.mOnGlobalFocusListeners, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mOnGlobalFocusListeners, []), Expression(observer.mOnGlobalFocusListeners, [])]), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (observer.mOnGlobalLayoutListeners !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(if (mOnGlobalLayoutListeners !, []), Expression(null) {, [])]), MethodCall(mOnGlobalLayoutListeners.addAll(observer.mOnGlobalLayoutListeners), [VariableReference(mOnGlobalLayoutListeners, []), Expression(observer.mOnGlobalLayoutListeners, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mOnGlobalLayoutListeners, []), Expression(observer.mOnGlobalLayoutListeners, [])]), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (observer.mOnPreDrawListeners !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(if (mOnPreDrawListeners !, []), Expression(null) {, [])]), MethodCall(mOnPreDrawListeners.addAll(observer.mOnPreDrawListeners), [VariableReference(mOnPreDrawListeners, []), Expression(observer.mOnPreDrawListeners, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mOnPreDrawListeners, []), Expression(observer.mOnPreDrawListeners, [])]), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (observer.mOnDrawListeners !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(if (mOnDrawListeners !, []), Expression(null) {, [])]), MethodCall(mOnDrawListeners.addAll(observer.mOnDrawListeners), [VariableReference(mOnDrawListeners, []), Expression(observer.mOnDrawListeners, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mOnDrawListeners, []), Expression(observer.mOnDrawListeners, [])]), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (observer.mOnTouchModeChangeListeners !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(if (mOnTouchModeChangeListeners !, []), Expression(null) {, [])]), MethodCall(mOnTouchModeChangeListeners.addAll(observer.mOnTouchModeChangeListeners), [VariableReference(mOnTouchModeChangeListeners, []), Expression(observer.mOnTouchModeChangeListeners, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mOnTouchModeChangeListeners, []), Expression(observer.mOnTouchModeChangeListeners, [])]), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (observer.mOnComputeInternalInsetsListeners !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(if (mOnComputeInternalInsetsListeners !, []), Expression(null) {, [])]), MethodCall(mOnComputeInternalInsetsListeners.addAll(observer.mOnComputeInternalInsetsListeners), [VariableReference(mOnComputeInternalInsetsListeners, []), Expression(observer.mOnComputeInternalInsetsListeners, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mOnComputeInternalInsetsListeners, []), Expression(observer.mOnComputeInternalInsetsListeners, [])]), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (observer.mOnScrollChangedListeners !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(if (mOnScrollChangedListeners !, []), Expression(null) {, [])]), MethodCall(mOnScrollChangedListeners.addAll(observer.mOnScrollChangedListeners), [VariableReference(mOnScrollChangedListeners, []), Expression(observer.mOnScrollChangedListeners, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mOnScrollChangedListeners, []), Expression(observer.mOnScrollChangedListeners, [])]), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (observer.mOnWindowShownListeners !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(if (mOnWindowShownListeners !, []), Expression(null) {, [])]), MethodCall(mOnWindowShownListeners.addAll(observer.mOnWindowShownListeners), [VariableReference(mOnWindowShownListeners, []), Expression(observer.mOnWindowShownListeners, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mOnWindowShownListeners, []), Expression(observer.mOnWindowShownListeners, [])]), Statement(}, []), Statement(}, []), MethodCall(observer.kill(), [VariableReference(observer, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (observer.mOnWindowAttachListeners !, []), Expression(null) {, [])])    VariableReference(if (observer.mOnWindowAttachListeners !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(if (mOnWindowAttachListeners !, []), Expression(null) {, [])])    VariableReference(if (mOnWindowAttachListeners !, [])    Expression(null) {, [])  MethodCall(mOnWindowAttachListeners.addAll(observer.mOnWindowAttachListeners), [VariableReference(mOnWindowAttachListeners, []), Expression(observer.mOnWindowAttachListeners, [])])    VariableReference(mOnWindowAttachListeners, [])    Expression(observer.mOnWindowAttachListeners, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mOnWindowAttachListeners, []), Expression(observer.mOnWindowAttachListeners, [])])    VariableReference(mOnWindowAttachListeners, [])    Expression(observer.mOnWindowAttachListeners, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (observer.mOnWindowFocusListeners !, []), Expression(null) {, [])])    VariableReference(if (observer.mOnWindowFocusListeners !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(if (mOnWindowFocusListeners !, []), Expression(null) {, [])])    VariableReference(if (mOnWindowFocusListeners !, [])    Expression(null) {, [])  MethodCall(mOnWindowFocusListeners.addAll(observer.mOnWindowFocusListeners), [VariableReference(mOnWindowFocusListeners, []), Expression(observer.mOnWindowFocusListeners, [])])    VariableReference(mOnWindowFocusListeners, [])    Expression(observer.mOnWindowFocusListeners, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mOnWindowFocusListeners, []), Expression(observer.mOnWindowFocusListeners, [])])    VariableReference(mOnWindowFocusListeners, [])    Expression(observer.mOnWindowFocusListeners, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (observer.mOnGlobalFocusListeners !, []), Expression(null) {, [])])    VariableReference(if (observer.mOnGlobalFocusListeners !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(if (mOnGlobalFocusListeners !, []), Expression(null) {, [])])    VariableReference(if (mOnGlobalFocusListeners !, [])    Expression(null) {, [])  MethodCall(mOnGlobalFocusListeners.addAll(observer.mOnGlobalFocusListeners), [VariableReference(mOnGlobalFocusListeners, []), Expression(observer.mOnGlobalFocusListeners, [])])    VariableReference(mOnGlobalFocusListeners, [])    Expression(observer.mOnGlobalFocusListeners, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mOnGlobalFocusListeners, []), Expression(observer.mOnGlobalFocusListeners, [])])    VariableReference(mOnGlobalFocusListeners, [])    Expression(observer.mOnGlobalFocusListeners, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (observer.mOnGlobalLayoutListeners !, []), Expression(null) {, [])])    VariableReference(if (observer.mOnGlobalLayoutListeners !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(if (mOnGlobalLayoutListeners !, []), Expression(null) {, [])])    VariableReference(if (mOnGlobalLayoutListeners !, [])    Expression(null) {, [])  MethodCall(mOnGlobalLayoutListeners.addAll(observer.mOnGlobalLayoutListeners), [VariableReference(mOnGlobalLayoutListeners, []), Expression(observer.mOnGlobalLayoutListeners, [])])    VariableReference(mOnGlobalLayoutListeners, [])    Expression(observer.mOnGlobalLayoutListeners, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mOnGlobalLayoutListeners, []), Expression(observer.mOnGlobalLayoutListeners, [])])    VariableReference(mOnGlobalLayoutListeners, [])    Expression(observer.mOnGlobalLayoutListeners, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (observer.mOnPreDrawListeners !, []), Expression(null) {, [])])    VariableReference(if (observer.mOnPreDrawListeners !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(if (mOnPreDrawListeners !, []), Expression(null) {, [])])    VariableReference(if (mOnPreDrawListeners !, [])    Expression(null) {, [])  MethodCall(mOnPreDrawListeners.addAll(observer.mOnPreDrawListeners), [VariableReference(mOnPreDrawListeners, []), Expression(observer.mOnPreDrawListeners, [])])    VariableReference(mOnPreDrawListeners, [])    Expression(observer.mOnPreDrawListeners, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mOnPreDrawListeners, []), Expression(observer.mOnPreDrawListeners, [])])    VariableReference(mOnPreDrawListeners, [])    Expression(observer.mOnPreDrawListeners, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (observer.mOnDrawListeners !, []), Expression(null) {, [])])    VariableReference(if (observer.mOnDrawListeners !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(if (mOnDrawListeners !, []), Expression(null) {, [])])    VariableReference(if (mOnDrawListeners !, [])    Expression(null) {, [])  MethodCall(mOnDrawListeners.addAll(observer.mOnDrawListeners), [VariableReference(mOnDrawListeners, []), Expression(observer.mOnDrawListeners, [])])    VariableReference(mOnDrawListeners, [])    Expression(observer.mOnDrawListeners, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mOnDrawListeners, []), Expression(observer.mOnDrawListeners, [])])    VariableReference(mOnDrawListeners, [])    Expression(observer.mOnDrawListeners, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (observer.mOnTouchModeChangeListeners !, []), Expression(null) {, [])])    VariableReference(if (observer.mOnTouchModeChangeListeners !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(if (mOnTouchModeChangeListeners !, []), Expression(null) {, [])])    VariableReference(if (mOnTouchModeChangeListeners !, [])    Expression(null) {, [])  MethodCall(mOnTouchModeChangeListeners.addAll(observer.mOnTouchModeChangeListeners), [VariableReference(mOnTouchModeChangeListeners, []), Expression(observer.mOnTouchModeChangeListeners, [])])    VariableReference(mOnTouchModeChangeListeners, [])    Expression(observer.mOnTouchModeChangeListeners, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mOnTouchModeChangeListeners, []), Expression(observer.mOnTouchModeChangeListeners, [])])    VariableReference(mOnTouchModeChangeListeners, [])    Expression(observer.mOnTouchModeChangeListeners, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (observer.mOnComputeInternalInsetsListeners !, []), Expression(null) {, [])])    VariableReference(if (observer.mOnComputeInternalInsetsListeners !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(if (mOnComputeInternalInsetsListeners !, []), Expression(null) {, [])])    VariableReference(if (mOnComputeInternalInsetsListeners !, [])    Expression(null) {, [])  MethodCall(mOnComputeInternalInsetsListeners.addAll(observer.mOnComputeInternalInsetsListeners), [VariableReference(mOnComputeInternalInsetsListeners, []), Expression(observer.mOnComputeInternalInsetsListeners, [])])    VariableReference(mOnComputeInternalInsetsListeners, [])    Expression(observer.mOnComputeInternalInsetsListeners, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mOnComputeInternalInsetsListeners, []), Expression(observer.mOnComputeInternalInsetsListeners, [])])    VariableReference(mOnComputeInternalInsetsListeners, [])    Expression(observer.mOnComputeInternalInsetsListeners, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (observer.mOnScrollChangedListeners !, []), Expression(null) {, [])])    VariableReference(if (observer.mOnScrollChangedListeners !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(if (mOnScrollChangedListeners !, []), Expression(null) {, [])])    VariableReference(if (mOnScrollChangedListeners !, [])    Expression(null) {, [])  MethodCall(mOnScrollChangedListeners.addAll(observer.mOnScrollChangedListeners), [VariableReference(mOnScrollChangedListeners, []), Expression(observer.mOnScrollChangedListeners, [])])    VariableReference(mOnScrollChangedListeners, [])    Expression(observer.mOnScrollChangedListeners, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mOnScrollChangedListeners, []), Expression(observer.mOnScrollChangedListeners, [])])    VariableReference(mOnScrollChangedListeners, [])    Expression(observer.mOnScrollChangedListeners, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (observer.mOnWindowShownListeners !, []), Expression(null) {, [])])    VariableReference(if (observer.mOnWindowShownListeners !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(if (mOnWindowShownListeners !, []), Expression(null) {, [])])    VariableReference(if (mOnWindowShownListeners !, [])    Expression(null) {, [])  MethodCall(mOnWindowShownListeners.addAll(observer.mOnWindowShownListeners), [VariableReference(mOnWindowShownListeners, []), Expression(observer.mOnWindowShownListeners, [])])    VariableReference(mOnWindowShownListeners, [])    Expression(observer.mOnWindowShownListeners, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mOnWindowShownListeners, []), Expression(observer.mOnWindowShownListeners, [])])    VariableReference(mOnWindowShownListeners, [])    Expression(observer.mOnWindowShownListeners, [])  Statement(}, [])  Statement(}, [])  MethodCall(observer.kill(), [VariableReference(observer, []), Expression(, [])])    VariableReference(observer, [])    Expression(, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (observer.mOnWindowAttachListeners !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(if (mOnWindowAttachListeners !, []), Expression(null) {, [])]), MethodCall(mOnWindowAttachListeners.addAll(observer.mOnWindowAttachListeners), [VariableReference(mOnWindowAttachListeners, []), Expression(observer.mOnWindowAttachListeners, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mOnWindowAttachListeners, []), Expression(observer.mOnWindowAttachListeners, [])]), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (observer.mOnWindowFocusListeners !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(if (mOnWindowFocusListeners !, []), Expression(null) {, [])]), MethodCall(mOnWindowFocusListeners.addAll(observer.mOnWindowFocusListeners), [VariableReference(mOnWindowFocusListeners, []), Expression(observer.mOnWindowFocusListeners, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mOnWindowFocusListeners, []), Expression(observer.mOnWindowFocusListeners, [])]), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (observer.mOnGlobalFocusListeners !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(if (mOnGlobalFocusListeners !, []), Expression(null) {, [])]), MethodCall(mOnGlobalFocusListeners.addAll(observer.mOnGlobalFocusListeners), [VariableReference(mOnGlobalFocusListeners, []), Expression(observer.mOnGlobalFocusListeners, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mOnGlobalFocusListeners, []), Expression(observer.mOnGlobalFocusListeners, [])]), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (observer.mOnGlobalLayoutListeners !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(if (mOnGlobalLayoutListeners !, []), Expression(null) {, [])]), MethodCall(mOnGlobalLayoutListeners.addAll(observer.mOnGlobalLayoutListeners), [VariableReference(mOnGlobalLayoutListeners, []), Expression(observer.mOnGlobalLayoutListeners, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mOnGlobalLayoutListeners, []), Expression(observer.mOnGlobalLayoutListeners, [])]), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (observer.mOnPreDrawListeners !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(if (mOnPreDrawListeners !, []), Expression(null) {, [])]), MethodCall(mOnPreDrawListeners.addAll(observer.mOnPreDrawListeners), [VariableReference(mOnPreDrawListeners, []), Expression(observer.mOnPreDrawListeners, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mOnPreDrawListeners, []), Expression(observer.mOnPreDrawListeners, [])]), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (observer.mOnDrawListeners !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(if (mOnDrawListeners !, []), Expression(null) {, [])]), MethodCall(mOnDrawListeners.addAll(observer.mOnDrawListeners), [VariableReference(mOnDrawListeners, []), Expression(observer.mOnDrawListeners, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mOnDrawListeners, []), Expression(observer.mOnDrawListeners, [])]), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (observer.mOnFrameCommitListeners !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(if (mOnFrameCommitListeners !, []), Expression(null) {, [])]), MethodCall(mOnFrameCommitListeners.addAll(observer.captureFrameCommitCallbacks()), [VariableReference(mOnFrameCommitListeners, []), Expression(observer.captureFrameCommitCallbacks(), [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mOnFrameCommitListeners, []), Expression(observer.captureFrameCommitCallbacks(), [])]), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (observer.mOnTouchModeChangeListeners !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(if (mOnTouchModeChangeListeners !, []), Expression(null) {, [])]), MethodCall(mOnTouchModeChangeListeners.addAll(observer.mOnTouchModeChangeListeners), [VariableReference(mOnTouchModeChangeListeners, []), Expression(observer.mOnTouchModeChangeListeners, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mOnTouchModeChangeListeners, []), Expression(observer.mOnTouchModeChangeListeners, [])]), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (observer.mOnComputeInternalInsetsListeners !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(if (mOnComputeInternalInsetsListeners !, []), Expression(null) {, [])]), MethodCall(mOnComputeInternalInsetsListeners.addAll(observer.mOnComputeInternalInsetsListeners), [VariableReference(mOnComputeInternalInsetsListeners, []), Expression(observer.mOnComputeInternalInsetsListeners, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mOnComputeInternalInsetsListeners, []), Expression(observer.mOnComputeInternalInsetsListeners, [])]), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (observer.mOnScrollChangedListeners !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(if (mOnScrollChangedListeners !, []), Expression(null) {, [])]), MethodCall(mOnScrollChangedListeners.addAll(observer.mOnScrollChangedListeners), [VariableReference(mOnScrollChangedListeners, []), Expression(observer.mOnScrollChangedListeners, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mOnScrollChangedListeners, []), Expression(observer.mOnScrollChangedListeners, [])]), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (observer.mOnWindowShownListeners !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(if (mOnWindowShownListeners !, []), Expression(null) {, [])]), MethodCall(mOnWindowShownListeners.addAll(observer.mOnWindowShownListeners), [VariableReference(mOnWindowShownListeners, []), Expression(observer.mOnWindowShownListeners, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mOnWindowShownListeners, []), Expression(observer.mOnWindowShownListeners, [])]), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (observer.mGestureExclusionListeners !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(if (mGestureExclusionListeners !, []), Expression(null) {, [])]), MethodCall(mGestureExclusionListeners.addAll(observer.mGestureExclusionListeners), [VariableReference(mGestureExclusionListeners, []), Expression(observer.mGestureExclusionListeners, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mGestureExclusionListeners, []), Expression(observer.mGestureExclusionListeners, [])]), Statement(}, []), Statement(}, []), MethodCall(observer.kill(), [VariableReference(observer, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (observer.mOnWindowAttachListeners !, []), Expression(null) {, [])])    VariableReference(if (observer.mOnWindowAttachListeners !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(if (mOnWindowAttachListeners !, []), Expression(null) {, [])])    VariableReference(if (mOnWindowAttachListeners !, [])    Expression(null) {, [])  MethodCall(mOnWindowAttachListeners.addAll(observer.mOnWindowAttachListeners), [VariableReference(mOnWindowAttachListeners, []), Expression(observer.mOnWindowAttachListeners, [])])    VariableReference(mOnWindowAttachListeners, [])    Expression(observer.mOnWindowAttachListeners, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mOnWindowAttachListeners, []), Expression(observer.mOnWindowAttachListeners, [])])    VariableReference(mOnWindowAttachListeners, [])    Expression(observer.mOnWindowAttachListeners, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (observer.mOnWindowFocusListeners !, []), Expression(null) {, [])])    VariableReference(if (observer.mOnWindowFocusListeners !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(if (mOnWindowFocusListeners !, []), Expression(null) {, [])])    VariableReference(if (mOnWindowFocusListeners !, [])    Expression(null) {, [])  MethodCall(mOnWindowFocusListeners.addAll(observer.mOnWindowFocusListeners), [VariableReference(mOnWindowFocusListeners, []), Expression(observer.mOnWindowFocusListeners, [])])    VariableReference(mOnWindowFocusListeners, [])    Expression(observer.mOnWindowFocusListeners, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mOnWindowFocusListeners, []), Expression(observer.mOnWindowFocusListeners, [])])    VariableReference(mOnWindowFocusListeners, [])    Expression(observer.mOnWindowFocusListeners, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (observer.mOnGlobalFocusListeners !, []), Expression(null) {, [])])    VariableReference(if (observer.mOnGlobalFocusListeners !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(if (mOnGlobalFocusListeners !, []), Expression(null) {, [])])    VariableReference(if (mOnGlobalFocusListeners !, [])    Expression(null) {, [])  MethodCall(mOnGlobalFocusListeners.addAll(observer.mOnGlobalFocusListeners), [VariableReference(mOnGlobalFocusListeners, []), Expression(observer.mOnGlobalFocusListeners, [])])    VariableReference(mOnGlobalFocusListeners, [])    Expression(observer.mOnGlobalFocusListeners, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mOnGlobalFocusListeners, []), Expression(observer.mOnGlobalFocusListeners, [])])    VariableReference(mOnGlobalFocusListeners, [])    Expression(observer.mOnGlobalFocusListeners, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (observer.mOnGlobalLayoutListeners !, []), Expression(null) {, [])])    VariableReference(if (observer.mOnGlobalLayoutListeners !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(if (mOnGlobalLayoutListeners !, []), Expression(null) {, [])])    VariableReference(if (mOnGlobalLayoutListeners !, [])    Expression(null) {, [])  MethodCall(mOnGlobalLayoutListeners.addAll(observer.mOnGlobalLayoutListeners), [VariableReference(mOnGlobalLayoutListeners, []), Expression(observer.mOnGlobalLayoutListeners, [])])    VariableReference(mOnGlobalLayoutListeners, [])    Expression(observer.mOnGlobalLayoutListeners, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mOnGlobalLayoutListeners, []), Expression(observer.mOnGlobalLayoutListeners, [])])    VariableReference(mOnGlobalLayoutListeners, [])    Expression(observer.mOnGlobalLayoutListeners, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (observer.mOnPreDrawListeners !, []), Expression(null) {, [])])    VariableReference(if (observer.mOnPreDrawListeners !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(if (mOnPreDrawListeners !, []), Expression(null) {, [])])    VariableReference(if (mOnPreDrawListeners !, [])    Expression(null) {, [])  MethodCall(mOnPreDrawListeners.addAll(observer.mOnPreDrawListeners), [VariableReference(mOnPreDrawListeners, []), Expression(observer.mOnPreDrawListeners, [])])    VariableReference(mOnPreDrawListeners, [])    Expression(observer.mOnPreDrawListeners, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mOnPreDrawListeners, []), Expression(observer.mOnPreDrawListeners, [])])    VariableReference(mOnPreDrawListeners, [])    Expression(observer.mOnPreDrawListeners, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (observer.mOnDrawListeners !, []), Expression(null) {, [])])    VariableReference(if (observer.mOnDrawListeners !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(if (mOnDrawListeners !, []), Expression(null) {, [])])    VariableReference(if (mOnDrawListeners !, [])    Expression(null) {, [])  MethodCall(mOnDrawListeners.addAll(observer.mOnDrawListeners), [VariableReference(mOnDrawListeners, []), Expression(observer.mOnDrawListeners, [])])    VariableReference(mOnDrawListeners, [])    Expression(observer.mOnDrawListeners, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mOnDrawListeners, []), Expression(observer.mOnDrawListeners, [])])    VariableReference(mOnDrawListeners, [])    Expression(observer.mOnDrawListeners, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (observer.mOnFrameCommitListeners !, []), Expression(null) {, [])])    VariableReference(if (observer.mOnFrameCommitListeners !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(if (mOnFrameCommitListeners !, []), Expression(null) {, [])])    VariableReference(if (mOnFrameCommitListeners !, [])    Expression(null) {, [])  MethodCall(mOnFrameCommitListeners.addAll(observer.captureFrameCommitCallbacks()), [VariableReference(mOnFrameCommitListeners, []), Expression(observer.captureFrameCommitCallbacks(), [])])    VariableReference(mOnFrameCommitListeners, [])    Expression(observer.captureFrameCommitCallbacks(), [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mOnFrameCommitListeners, []), Expression(observer.captureFrameCommitCallbacks(), [])])    VariableReference(mOnFrameCommitListeners, [])    Expression(observer.captureFrameCommitCallbacks(), [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (observer.mOnTouchModeChangeListeners !, []), Expression(null) {, [])])    VariableReference(if (observer.mOnTouchModeChangeListeners !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(if (mOnTouchModeChangeListeners !, []), Expression(null) {, [])])    VariableReference(if (mOnTouchModeChangeListeners !, [])    Expression(null) {, [])  MethodCall(mOnTouchModeChangeListeners.addAll(observer.mOnTouchModeChangeListeners), [VariableReference(mOnTouchModeChangeListeners, []), Expression(observer.mOnTouchModeChangeListeners, [])])    VariableReference(mOnTouchModeChangeListeners, [])    Expression(observer.mOnTouchModeChangeListeners, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mOnTouchModeChangeListeners, []), Expression(observer.mOnTouchModeChangeListeners, [])])    VariableReference(mOnTouchModeChangeListeners, [])    Expression(observer.mOnTouchModeChangeListeners, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (observer.mOnComputeInternalInsetsListeners !, []), Expression(null) {, [])])    VariableReference(if (observer.mOnComputeInternalInsetsListeners !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(if (mOnComputeInternalInsetsListeners !, []), Expression(null) {, [])])    VariableReference(if (mOnComputeInternalInsetsListeners !, [])    Expression(null) {, [])  MethodCall(mOnComputeInternalInsetsListeners.addAll(observer.mOnComputeInternalInsetsListeners), [VariableReference(mOnComputeInternalInsetsListeners, []), Expression(observer.mOnComputeInternalInsetsListeners, [])])    VariableReference(mOnComputeInternalInsetsListeners, [])    Expression(observer.mOnComputeInternalInsetsListeners, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mOnComputeInternalInsetsListeners, []), Expression(observer.mOnComputeInternalInsetsListeners, [])])    VariableReference(mOnComputeInternalInsetsListeners, [])    Expression(observer.mOnComputeInternalInsetsListeners, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (observer.mOnScrollChangedListeners !, []), Expression(null) {, [])])    VariableReference(if (observer.mOnScrollChangedListeners !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(if (mOnScrollChangedListeners !, []), Expression(null) {, [])])    VariableReference(if (mOnScrollChangedListeners !, [])    Expression(null) {, [])  MethodCall(mOnScrollChangedListeners.addAll(observer.mOnScrollChangedListeners), [VariableReference(mOnScrollChangedListeners, []), Expression(observer.mOnScrollChangedListeners, [])])    VariableReference(mOnScrollChangedListeners, [])    Expression(observer.mOnScrollChangedListeners, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mOnScrollChangedListeners, []), Expression(observer.mOnScrollChangedListeners, [])])    VariableReference(mOnScrollChangedListeners, [])    Expression(observer.mOnScrollChangedListeners, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (observer.mOnWindowShownListeners !, []), Expression(null) {, [])])    VariableReference(if (observer.mOnWindowShownListeners !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(if (mOnWindowShownListeners !, []), Expression(null) {, [])])    VariableReference(if (mOnWindowShownListeners !, [])    Expression(null) {, [])  MethodCall(mOnWindowShownListeners.addAll(observer.mOnWindowShownListeners), [VariableReference(mOnWindowShownListeners, []), Expression(observer.mOnWindowShownListeners, [])])    VariableReference(mOnWindowShownListeners, [])    Expression(observer.mOnWindowShownListeners, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mOnWindowShownListeners, []), Expression(observer.mOnWindowShownListeners, [])])    VariableReference(mOnWindowShownListeners, [])    Expression(observer.mOnWindowShownListeners, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (observer.mGestureExclusionListeners !, []), Expression(null) {, [])])    VariableReference(if (observer.mGestureExclusionListeners !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(if (mGestureExclusionListeners !, []), Expression(null) {, [])])    VariableReference(if (mGestureExclusionListeners !, [])    Expression(null) {, [])  MethodCall(mGestureExclusionListeners.addAll(observer.mGestureExclusionListeners), [VariableReference(mGestureExclusionListeners, []), Expression(observer.mGestureExclusionListeners, [])])    VariableReference(mGestureExclusionListeners, [])    Expression(observer.mGestureExclusionListeners, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mGestureExclusionListeners, []), Expression(observer.mGestureExclusionListeners, [])])    VariableReference(mGestureExclusionListeners, [])    Expression(observer.mGestureExclusionListeners, [])  Statement(}, [])  Statement(}, [])  MethodCall(observer.kill(), [VariableReference(observer, []), Expression(, [])])    VariableReference(observer, [])    Expression(, [])  Statement(}, [])",1,"/**
 * Merges all the listeners registered on the specified observer with the listeners
 * registered on this object. After this method is invoked, the specified observer
 * will return false in {@link #isAlive()} and should not be used anymore.
 *
 * @param observer The ViewTreeObserver whose listeners must be added to this observer
 */
","/**
 * Merges all the listeners registered on the specified observer with the listeners
 * registered on this object. After this method is invoked, the specified observer
 * will return false in {@link #isAlive()} and should not be used anymore.
 *
 * @param observer The ViewTreeObserver whose listeners must be added to this observer
 */
",0,,,0,,,,"1,2","3,4",1,3,1,"A new `if-else` control dependency statement has been added, which is used to merge the `mOnFrameCommitListeners` of the specified observer with the `mOnFrameCommitListeners` of this observer.","The new control dependency statement may potentially lead to different return values or types. Because the behavior of the method `captureFrameCommitCallbacks()` is unclear, it may return a different type of object or a different number of objects, which may cause the `mOnFrameCommitListeners` of this observer to be different from the previous version."
93,<android.os.StrictMode.AndroidBlockGuardPolicy: int getPolicyMask()>,28,29,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(return mPolicyMask, []), Statement(}, [])])  Statement({, [])  Statement(return mPolicyMask, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return mThreadPolicyMask, []), Statement(}, [])])  Statement({, [])  Statement(return mThreadPolicyMask, [])  Statement(}, [])",1,"// Part of BlockGuard.Policy interface:
","// Part of BlockGuard.Policy interface:
",0,,,0,,,,"1,2","1,5",1,1,1,"The return statement in the method implementation of `getPolicyMask()` has changed between the two versions. In version 28, the method returns `mPolicyMask`, while in version 29, the method returns `mThreadPolicyMask`.","The change in the return statement of `getPolicyMask()` between the two versions could potentially lead to compatibility issues. If an application or library is using the `getPolicyMask()` method to retrieve the current policy mask and relies on the value being consistent across different versions of the Android OS, then this change could cause the application or library to behave differently on devices running version 29 compared to devices running version 28. For example, if the application or library uses the policy mask to enable or disable certain features, then those features could be incorrectly enabled or disabled on devices running version 29."
94,<android.net.ConnectivityManager: boolean isActiveNetworkMetered()>,22,23,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(return mService.isActiveNetworkMetered(), [VariableReference(return mService, []), Expression(, [])]), Statement(} catch (RemoteException e) {, []), Statement(return false, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(return mService.isActiveNetworkMetered(), [VariableReference(return mService, []), Expression(, [])])    VariableReference(return mService, [])    Expression(, [])  Statement(} catch (RemoteException e) {, [])  Statement(return false, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(return mService.isActiveNetworkMetered(), [VariableReference(return mService, []), Expression(, [])]), Statement(} catch (RemoteException e) {, []), Statement(return false, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(return mService.isActiveNetworkMetered(), [VariableReference(return mService, []), Expression(, [])])    VariableReference(return mService, [])    Expression(, [])  Statement(} catch (RemoteException e) {, [])  Statement(return false, [])  Statement(}, [])  Statement(}, [])",0,"/**
 * Returns if the currently active data network is metered. A network is
 * classified as metered when the user is sensitive to heavy data usage on
 * that connection due to monetary costs, data limitations or
 * battery/performance issues. You should check this before doing large
 * data transfers, and warn the user or delay the operation until another
 * network is available.
 *
 * @return {@code true} if large transfers should be avoided, otherwise
 * {@code false}.
 *
 * <p>This method requires the call to hold the permission
 * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
 */
","/**
 * Returns if the currently active data network is metered. A network is
 * classified as metered when the user is sensitive to heavy data usage on
 * that connection due to monetary costs, data limitations or
 * battery/performance issues. You should check this before doing large
 * data transfers, and warn the user or delay the operation until another
 * network is available.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
 *
 * @return {@code true} if large transfers should be avoided, otherwise
 * {@code false}.
 */
",1,,,0,,,,0,0,0,0,0,There is no code change between the two versions.,"As there is no code change, there is no Compatibility Issue exist."
95,<android.view.InputDevice: String toString()>,22,23,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(StringBuilder description, []), Expression(new StringBuilder(), [])]), MethodCall(description.append(""Input Device "").append(mId).append("": "").append(mName).append(""\n""), [VariableReference(description, []), Expression(""Input Device "").append(mId).append("": "").append(mName).append(""\n"", [])]), MethodCall(description.append(""  Descriptor: "").append(mDescriptor).append(""\n""), [VariableReference(description, []), Expression(""  Descriptor: "").append(mDescriptor).append(""\n"", [])]), MethodCall(description.append(""  Generation: "").append(mGeneration).append(""\n""), [VariableReference(description, []), Expression(""  Generation: "").append(mGeneration).append(""\n"", [])]), MethodCall(description.append(""  Location: "").append(mIsExternal ? ""external"" : ""built-in"").append(""\n""), [VariableReference(description, []), Expression(""  Location: "").append(mIsExternal ? ""external"" : ""built-in"").append(""\n"", [])]), MethodCall(description.append(""  Keyboard Type: ""), [VariableReference(description, []), Expression(""  Keyboard Type: "", [])]), Statement(switch(mKeyboardType) {, []), Statement(case KEYBOARD_TYPE_NONE:, []), MethodCall(description.append(""none""), [VariableReference(description, []), Expression(""none"", [])]), Statement(break, []), Statement(case KEYBOARD_TYPE_NON_ALPHABETIC:, []), MethodCall(description.append(""non-alphabetic""), [VariableReference(description, []), Expression(""non-alphabetic"", [])]), Statement(break, []), Statement(case KEYBOARD_TYPE_ALPHABETIC:, []), MethodCall(description.append(""alphabetic""), [VariableReference(description, []), Expression(""alphabetic"", [])]), Statement(break, []), Statement(}, []), MethodCall(description.append(""\n""), [VariableReference(description, []), Expression(""\n"", [])]), MethodCall(description.append(""  Has Vibrator: "").append(mHasVibrator).append(""\n""), [VariableReference(description, []), Expression(""  Has Vibrator: "").append(mHasVibrator).append(""\n"", [])]), MethodCall(description.append(""  Sources: 0x"").append(Integer.toHexString(mSources)).append("" (""), [VariableReference(description, []), Expression(""  Sources: 0x"").append(Integer.toHexString(mSources)).append("" ("", [])]), Statement(appendSourceDescriptionIfApplicable(description, SOURCE_KEYBOARD, ""keyboard""), []), Statement(appendSourceDescriptionIfApplicable(description, SOURCE_DPAD, ""dpad""), []), Statement(appendSourceDescriptionIfApplicable(description, SOURCE_TOUCHSCREEN, ""touchscreen""), []), Statement(appendSourceDescriptionIfApplicable(description, SOURCE_MOUSE, ""mouse""), []), Statement(appendSourceDescriptionIfApplicable(description, SOURCE_STYLUS, ""stylus""), []), Statement(appendSourceDescriptionIfApplicable(description, SOURCE_TRACKBALL, ""trackball""), []), Statement(appendSourceDescriptionIfApplicable(description, SOURCE_TOUCHPAD, ""touchpad""), []), Statement(appendSourceDescriptionIfApplicable(description, SOURCE_JOYSTICK, ""joystick""), []), Statement(appendSourceDescriptionIfApplicable(description, SOURCE_GAMEPAD, ""gamepad""), []), MethodCall(description.append("" )\n""), [VariableReference(description, []), Expression("" )\n"", [])]), AssignmentExpression(=, [VariableReference(final int numAxes, []), Expression(mMotionRanges.size(), [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < numAxes, []), Statement(i++) {, []), AssignmentExpression(=, [VariableReference(MotionRange range, []), Expression(mMotionRanges.get(i), [])]), MethodCall(description.append(""    "").append(MotionEvent.axisToString(range.mAxis)), [VariableReference(description, []), Expression(""    "").append(MotionEvent.axisToString(range.mAxis), [])]), AssignmentExpression(=, [VariableReference(description.append("": source, []), Expression(0x"").append(Integer.toHexString(range.mSource)), [])]), AssignmentExpression(=, [VariableReference(description.append("" min, []), Expression("").append(range.mMin), [])]), AssignmentExpression(=, [VariableReference(description.append("" max, []), Expression("").append(range.mMax), [])]), AssignmentExpression(=, [VariableReference(description.append("" flat, []), Expression("").append(range.mFlat), [])]), AssignmentExpression(=, [VariableReference(description.append("" fuzz, []), Expression("").append(range.mFuzz), [])]), AssignmentExpression(=, [VariableReference(description.append("" resolution, []), Expression("").append(range.mResolution), [])]), MethodCall(description.append(""\n""), [VariableReference(description, []), Expression(""\n"", [])]), Statement(}, []), MethodCall(return description.toString(), [VariableReference(return description, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(StringBuilder description, []), Expression(new StringBuilder(), [])])    VariableReference(StringBuilder description, [])    Expression(new StringBuilder(), [])  MethodCall(description.append(""Input Device "").append(mId).append("": "").append(mName).append(""\n""), [VariableReference(description, []), Expression(""Input Device "").append(mId).append("": "").append(mName).append(""\n"", [])])    VariableReference(description, [])    Expression(""Input Device "").append(mId).append("": "").append(mName).append(""\n"", [])  MethodCall(description.append(""  Descriptor: "").append(mDescriptor).append(""\n""), [VariableReference(description, []), Expression(""  Descriptor: "").append(mDescriptor).append(""\n"", [])])    VariableReference(description, [])    Expression(""  Descriptor: "").append(mDescriptor).append(""\n"", [])  MethodCall(description.append(""  Generation: "").append(mGeneration).append(""\n""), [VariableReference(description, []), Expression(""  Generation: "").append(mGeneration).append(""\n"", [])])    VariableReference(description, [])    Expression(""  Generation: "").append(mGeneration).append(""\n"", [])  MethodCall(description.append(""  Location: "").append(mIsExternal ? ""external"" : ""built-in"").append(""\n""), [VariableReference(description, []), Expression(""  Location: "").append(mIsExternal ? ""external"" : ""built-in"").append(""\n"", [])])    VariableReference(description, [])    Expression(""  Location: "").append(mIsExternal ? ""external"" : ""built-in"").append(""\n"", [])  MethodCall(description.append(""  Keyboard Type: ""), [VariableReference(description, []), Expression(""  Keyboard Type: "", [])])    VariableReference(description, [])    Expression(""  Keyboard Type: "", [])  Statement(switch(mKeyboardType) {, [])  Statement(case KEYBOARD_TYPE_NONE:, [])  MethodCall(description.append(""none""), [VariableReference(description, []), Expression(""none"", [])])    VariableReference(description, [])    Expression(""none"", [])  Statement(break, [])  Statement(case KEYBOARD_TYPE_NON_ALPHABETIC:, [])  MethodCall(description.append(""non-alphabetic""), [VariableReference(description, []), Expression(""non-alphabetic"", [])])    VariableReference(description, [])    Expression(""non-alphabetic"", [])  Statement(break, [])  Statement(case KEYBOARD_TYPE_ALPHABETIC:, [])  MethodCall(description.append(""alphabetic""), [VariableReference(description, []), Expression(""alphabetic"", [])])    VariableReference(description, [])    Expression(""alphabetic"", [])  Statement(break, [])  Statement(}, [])  MethodCall(description.append(""\n""), [VariableReference(description, []), Expression(""\n"", [])])    VariableReference(description, [])    Expression(""\n"", [])  MethodCall(description.append(""  Has Vibrator: "").append(mHasVibrator).append(""\n""), [VariableReference(description, []), Expression(""  Has Vibrator: "").append(mHasVibrator).append(""\n"", [])])    VariableReference(description, [])    Expression(""  Has Vibrator: "").append(mHasVibrator).append(""\n"", [])  MethodCall(description.append(""  Sources: 0x"").append(Integer.toHexString(mSources)).append("" (""), [VariableReference(description, []), Expression(""  Sources: 0x"").append(Integer.toHexString(mSources)).append("" ("", [])])    VariableReference(description, [])    Expression(""  Sources: 0x"").append(Integer.toHexString(mSources)).append("" ("", [])  Statement(appendSourceDescriptionIfApplicable(description, SOURCE_KEYBOARD, ""keyboard""), [])  Statement(appendSourceDescriptionIfApplicable(description, SOURCE_DPAD, ""dpad""), [])  Statement(appendSourceDescriptionIfApplicable(description, SOURCE_TOUCHSCREEN, ""touchscreen""), [])  Statement(appendSourceDescriptionIfApplicable(description, SOURCE_MOUSE, ""mouse""), [])  Statement(appendSourceDescriptionIfApplicable(description, SOURCE_STYLUS, ""stylus""), [])  Statement(appendSourceDescriptionIfApplicable(description, SOURCE_TRACKBALL, ""trackball""), [])  Statement(appendSourceDescriptionIfApplicable(description, SOURCE_TOUCHPAD, ""touchpad""), [])  Statement(appendSourceDescriptionIfApplicable(description, SOURCE_JOYSTICK, ""joystick""), [])  Statement(appendSourceDescriptionIfApplicable(description, SOURCE_GAMEPAD, ""gamepad""), [])  MethodCall(description.append("" )\n""), [VariableReference(description, []), Expression("" )\n"", [])])    VariableReference(description, [])    Expression("" )\n"", [])  AssignmentExpression(=, [VariableReference(final int numAxes, []), Expression(mMotionRanges.size(), [])])    VariableReference(final int numAxes, [])    Expression(mMotionRanges.size(), [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < numAxes, [])  Statement(i++) {, [])  AssignmentExpression(=, [VariableReference(MotionRange range, []), Expression(mMotionRanges.get(i), [])])    VariableReference(MotionRange range, [])    Expression(mMotionRanges.get(i), [])  MethodCall(description.append(""    "").append(MotionEvent.axisToString(range.mAxis)), [VariableReference(description, []), Expression(""    "").append(MotionEvent.axisToString(range.mAxis), [])])    VariableReference(description, [])    Expression(""    "").append(MotionEvent.axisToString(range.mAxis), [])  AssignmentExpression(=, [VariableReference(description.append("": source, []), Expression(0x"").append(Integer.toHexString(range.mSource)), [])])    VariableReference(description.append("": source, [])    Expression(0x"").append(Integer.toHexString(range.mSource)), [])  AssignmentExpression(=, [VariableReference(description.append("" min, []), Expression("").append(range.mMin), [])])    VariableReference(description.append("" min, [])    Expression("").append(range.mMin), [])  AssignmentExpression(=, [VariableReference(description.append("" max, []), Expression("").append(range.mMax), [])])    VariableReference(description.append("" max, [])    Expression("").append(range.mMax), [])  AssignmentExpression(=, [VariableReference(description.append("" flat, []), Expression("").append(range.mFlat), [])])    VariableReference(description.append("" flat, [])    Expression("").append(range.mFlat), [])  AssignmentExpression(=, [VariableReference(description.append("" fuzz, []), Expression("").append(range.mFuzz), [])])    VariableReference(description.append("" fuzz, [])    Expression("").append(range.mFuzz), [])  AssignmentExpression(=, [VariableReference(description.append("" resolution, []), Expression("").append(range.mResolution), [])])    VariableReference(description.append("" resolution, [])    Expression("").append(range.mResolution), [])  MethodCall(description.append(""\n""), [VariableReference(description, []), Expression(""\n"", [])])    VariableReference(description, [])    Expression(""\n"", [])  Statement(}, [])  MethodCall(return description.toString(), [VariableReference(return description, []), Expression(, [])])    VariableReference(return description, [])    Expression(, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(StringBuilder description, []), Expression(new StringBuilder(), [])]), MethodCall(description.append(""Input Device "").append(mId).append("": "").append(mName).append(""\n""), [VariableReference(description, []), Expression(""Input Device "").append(mId).append("": "").append(mName).append(""\n"", [])]), MethodCall(description.append(""  Descriptor: "").append(mDescriptor).append(""\n""), [VariableReference(description, []), Expression(""  Descriptor: "").append(mDescriptor).append(""\n"", [])]), MethodCall(description.append(""  Generation: "").append(mGeneration).append(""\n""), [VariableReference(description, []), Expression(""  Generation: "").append(mGeneration).append(""\n"", [])]), MethodCall(description.append(""  Location: "").append(mIsExternal ? ""external"" : ""built-in"").append(""\n""), [VariableReference(description, []), Expression(""  Location: "").append(mIsExternal ? ""external"" : ""built-in"").append(""\n"", [])]), MethodCall(description.append(""  Keyboard Type: ""), [VariableReference(description, []), Expression(""  Keyboard Type: "", [])]), Statement(switch(mKeyboardType) {, []), Statement(case KEYBOARD_TYPE_NONE:, []), MethodCall(description.append(""none""), [VariableReference(description, []), Expression(""none"", [])]), Statement(break, []), Statement(case KEYBOARD_TYPE_NON_ALPHABETIC:, []), MethodCall(description.append(""non-alphabetic""), [VariableReference(description, []), Expression(""non-alphabetic"", [])]), Statement(break, []), Statement(case KEYBOARD_TYPE_ALPHABETIC:, []), MethodCall(description.append(""alphabetic""), [VariableReference(description, []), Expression(""alphabetic"", [])]), Statement(break, []), Statement(}, []), MethodCall(description.append(""\n""), [VariableReference(description, []), Expression(""\n"", [])]), MethodCall(description.append(""  Has Vibrator: "").append(mHasVibrator).append(""\n""), [VariableReference(description, []), Expression(""  Has Vibrator: "").append(mHasVibrator).append(""\n"", [])]), MethodCall(description.append(""  Has mic: "").append(mHasMicrophone).append(""\n""), [VariableReference(description, []), Expression(""  Has mic: "").append(mHasMicrophone).append(""\n"", [])]), MethodCall(description.append(""  Sources: 0x"").append(Integer.toHexString(mSources)).append("" (""), [VariableReference(description, []), Expression(""  Sources: 0x"").append(Integer.toHexString(mSources)).append("" ("", [])]), Statement(appendSourceDescriptionIfApplicable(description, SOURCE_KEYBOARD, ""keyboard""), []), Statement(appendSourceDescriptionIfApplicable(description, SOURCE_DPAD, ""dpad""), []), Statement(appendSourceDescriptionIfApplicable(description, SOURCE_TOUCHSCREEN, ""touchscreen""), []), Statement(appendSourceDescriptionIfApplicable(description, SOURCE_MOUSE, ""mouse""), []), Statement(appendSourceDescriptionIfApplicable(description, SOURCE_STYLUS, ""stylus""), []), Statement(appendSourceDescriptionIfApplicable(description, SOURCE_TRACKBALL, ""trackball""), []), Statement(appendSourceDescriptionIfApplicable(description, SOURCE_TOUCHPAD, ""touchpad""), []), Statement(appendSourceDescriptionIfApplicable(description, SOURCE_JOYSTICK, ""joystick""), []), Statement(appendSourceDescriptionIfApplicable(description, SOURCE_GAMEPAD, ""gamepad""), []), MethodCall(description.append("" )\n""), [VariableReference(description, []), Expression("" )\n"", [])]), AssignmentExpression(=, [VariableReference(final int numAxes, []), Expression(mMotionRanges.size(), [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < numAxes, []), Statement(i++) {, []), AssignmentExpression(=, [VariableReference(MotionRange range, []), Expression(mMotionRanges.get(i), [])]), MethodCall(description.append(""    "").append(MotionEvent.axisToString(range.mAxis)), [VariableReference(description, []), Expression(""    "").append(MotionEvent.axisToString(range.mAxis), [])]), AssignmentExpression(=, [VariableReference(description.append("": source, []), Expression(0x"").append(Integer.toHexString(range.mSource)), [])]), AssignmentExpression(=, [VariableReference(description.append("" min, []), Expression("").append(range.mMin), [])]), AssignmentExpression(=, [VariableReference(description.append("" max, []), Expression("").append(range.mMax), [])]), AssignmentExpression(=, [VariableReference(description.append("" flat, []), Expression("").append(range.mFlat), [])]), AssignmentExpression(=, [VariableReference(description.append("" fuzz, []), Expression("").append(range.mFuzz), [])]), AssignmentExpression(=, [VariableReference(description.append("" resolution, []), Expression("").append(range.mResolution), [])]), MethodCall(description.append(""\n""), [VariableReference(description, []), Expression(""\n"", [])]), Statement(}, []), MethodCall(return description.toString(), [VariableReference(return description, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(StringBuilder description, []), Expression(new StringBuilder(), [])])    VariableReference(StringBuilder description, [])    Expression(new StringBuilder(), [])  MethodCall(description.append(""Input Device "").append(mId).append("": "").append(mName).append(""\n""), [VariableReference(description, []), Expression(""Input Device "").append(mId).append("": "").append(mName).append(""\n"", [])])    VariableReference(description, [])    Expression(""Input Device "").append(mId).append("": "").append(mName).append(""\n"", [])  MethodCall(description.append(""  Descriptor: "").append(mDescriptor).append(""\n""), [VariableReference(description, []), Expression(""  Descriptor: "").append(mDescriptor).append(""\n"", [])])    VariableReference(description, [])    Expression(""  Descriptor: "").append(mDescriptor).append(""\n"", [])  MethodCall(description.append(""  Generation: "").append(mGeneration).append(""\n""), [VariableReference(description, []), Expression(""  Generation: "").append(mGeneration).append(""\n"", [])])    VariableReference(description, [])    Expression(""  Generation: "").append(mGeneration).append(""\n"", [])  MethodCall(description.append(""  Location: "").append(mIsExternal ? ""external"" : ""built-in"").append(""\n""), [VariableReference(description, []), Expression(""  Location: "").append(mIsExternal ? ""external"" : ""built-in"").append(""\n"", [])])    VariableReference(description, [])    Expression(""  Location: "").append(mIsExternal ? ""external"" : ""built-in"").append(""\n"", [])  MethodCall(description.append(""  Keyboard Type: ""), [VariableReference(description, []), Expression(""  Keyboard Type: "", [])])    VariableReference(description, [])    Expression(""  Keyboard Type: "", [])  Statement(switch(mKeyboardType) {, [])  Statement(case KEYBOARD_TYPE_NONE:, [])  MethodCall(description.append(""none""), [VariableReference(description, []), Expression(""none"", [])])    VariableReference(description, [])    Expression(""none"", [])  Statement(break, [])  Statement(case KEYBOARD_TYPE_NON_ALPHABETIC:, [])  MethodCall(description.append(""non-alphabetic""), [VariableReference(description, []), Expression(""non-alphabetic"", [])])    VariableReference(description, [])    Expression(""non-alphabetic"", [])  Statement(break, [])  Statement(case KEYBOARD_TYPE_ALPHABETIC:, [])  MethodCall(description.append(""alphabetic""), [VariableReference(description, []), Expression(""alphabetic"", [])])    VariableReference(description, [])    Expression(""alphabetic"", [])  Statement(break, [])  Statement(}, [])  MethodCall(description.append(""\n""), [VariableReference(description, []), Expression(""\n"", [])])    VariableReference(description, [])    Expression(""\n"", [])  MethodCall(description.append(""  Has Vibrator: "").append(mHasVibrator).append(""\n""), [VariableReference(description, []), Expression(""  Has Vibrator: "").append(mHasVibrator).append(""\n"", [])])    VariableReference(description, [])    Expression(""  Has Vibrator: "").append(mHasVibrator).append(""\n"", [])  MethodCall(description.append(""  Has mic: "").append(mHasMicrophone).append(""\n""), [VariableReference(description, []), Expression(""  Has mic: "").append(mHasMicrophone).append(""\n"", [])])    VariableReference(description, [])    Expression(""  Has mic: "").append(mHasMicrophone).append(""\n"", [])  MethodCall(description.append(""  Sources: 0x"").append(Integer.toHexString(mSources)).append("" (""), [VariableReference(description, []), Expression(""  Sources: 0x"").append(Integer.toHexString(mSources)).append("" ("", [])])    VariableReference(description, [])    Expression(""  Sources: 0x"").append(Integer.toHexString(mSources)).append("" ("", [])  Statement(appendSourceDescriptionIfApplicable(description, SOURCE_KEYBOARD, ""keyboard""), [])  Statement(appendSourceDescriptionIfApplicable(description, SOURCE_DPAD, ""dpad""), [])  Statement(appendSourceDescriptionIfApplicable(description, SOURCE_TOUCHSCREEN, ""touchscreen""), [])  Statement(appendSourceDescriptionIfApplicable(description, SOURCE_MOUSE, ""mouse""), [])  Statement(appendSourceDescriptionIfApplicable(description, SOURCE_STYLUS, ""stylus""), [])  Statement(appendSourceDescriptionIfApplicable(description, SOURCE_TRACKBALL, ""trackball""), [])  Statement(appendSourceDescriptionIfApplicable(description, SOURCE_TOUCHPAD, ""touchpad""), [])  Statement(appendSourceDescriptionIfApplicable(description, SOURCE_JOYSTICK, ""joystick""), [])  Statement(appendSourceDescriptionIfApplicable(description, SOURCE_GAMEPAD, ""gamepad""), [])  MethodCall(description.append("" )\n""), [VariableReference(description, []), Expression("" )\n"", [])])    VariableReference(description, [])    Expression("" )\n"", [])  AssignmentExpression(=, [VariableReference(final int numAxes, []), Expression(mMotionRanges.size(), [])])    VariableReference(final int numAxes, [])    Expression(mMotionRanges.size(), [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < numAxes, [])  Statement(i++) {, [])  AssignmentExpression(=, [VariableReference(MotionRange range, []), Expression(mMotionRanges.get(i), [])])    VariableReference(MotionRange range, [])    Expression(mMotionRanges.get(i), [])  MethodCall(description.append(""    "").append(MotionEvent.axisToString(range.mAxis)), [VariableReference(description, []), Expression(""    "").append(MotionEvent.axisToString(range.mAxis), [])])    VariableReference(description, [])    Expression(""    "").append(MotionEvent.axisToString(range.mAxis), [])  AssignmentExpression(=, [VariableReference(description.append("": source, []), Expression(0x"").append(Integer.toHexString(range.mSource)), [])])    VariableReference(description.append("": source, [])    Expression(0x"").append(Integer.toHexString(range.mSource)), [])  AssignmentExpression(=, [VariableReference(description.append("" min, []), Expression("").append(range.mMin), [])])    VariableReference(description.append("" min, [])    Expression("").append(range.mMin), [])  AssignmentExpression(=, [VariableReference(description.append("" max, []), Expression("").append(range.mMax), [])])    VariableReference(description.append("" max, [])    Expression("").append(range.mMax), [])  AssignmentExpression(=, [VariableReference(description.append("" flat, []), Expression("").append(range.mFlat), [])])    VariableReference(description.append("" flat, [])    Expression("").append(range.mFlat), [])  AssignmentExpression(=, [VariableReference(description.append("" fuzz, []), Expression("").append(range.mFuzz), [])])    VariableReference(description.append("" fuzz, [])    Expression("").append(range.mFuzz), [])  AssignmentExpression(=, [VariableReference(description.append("" resolution, []), Expression("").append(range.mResolution), [])])    VariableReference(description.append("" resolution, [])    Expression("").append(range.mResolution), [])  MethodCall(description.append(""\n""), [VariableReference(description, []), Expression(""\n"", [])])    VariableReference(description, [])    Expression(""\n"", [])  Statement(}, [])  MethodCall(return description.toString(), [VariableReference(return description, []), Expression(, [])])    VariableReference(return description, [])    Expression(, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,,1,"1,4",1,4,1,"The late version implementation of the API includes a new method call to append a new line to the StringBuilder object, which is not present in the early version. This is a change in the ""other statement"" category.","The new method call in the late version can potentially lead to a different behavior, as it appends a new line to the StringBuilder object. This can cause the API to return a different value, which is a compatibility issue of type 1."
96,<android.view.ViewGroup: boolean isAnimationCacheEnabled()>,22,23,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(return (mGroupFlags & FLAG_ANIMATION_CACHE), []), Expression(, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(return (mGroupFlags & FLAG_ANIMATION_CACHE), []), Expression(, [])])    VariableReference(return (mGroupFlags & FLAG_ANIMATION_CACHE), [])    Expression(, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(return (mGroupFlags & FLAG_ANIMATION_CACHE), []), Expression(, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(return (mGroupFlags & FLAG_ANIMATION_CACHE), []), Expression(, [])])    VariableReference(return (mGroupFlags & FLAG_ANIMATION_CACHE), [])    Expression(, [])  Statement(}, [])",0,"/**
 * Indicates whether the children's drawing cache is used during a layout
 * animation. By default, the drawing cache is enabled but this will prevent
 * nested layout animations from working. To nest animations, you must disable
 * the cache.
 *
 * @return true if the animation cache is enabled, false otherwise
 *
 * @see #setAnimationCacheEnabled(boolean)
 * @see View#setDrawingCacheEnabled(boolean)
 */
","/**
 * Indicates whether the children's drawing cache is used during a layout
 * animation. By default, the drawing cache is enabled but this will prevent
 * nested layout animations from working. To nest animations, you must disable
 * the cache.
 *
 * @return true if the animation cache is enabled, false otherwise
 *
 * @see #setAnimationCacheEnabled(boolean)
 * @see View#setDrawingCacheEnabled(boolean)
 *
 * @deprecated As of {@link android.os.Build.VERSION_CODES#M}, this property is ignored.
 * Caching behavior of children may be controlled through {@link View#setLayerType(int, Paint)}.
 */
",1,[@ViewDebug.ExportedProperty],,1,,,,0,0,0,0,0,There is no change in the implementation of the method `isAnimationCacheEnabled()` between the early version (22) and the late version (23). The AST nodes for both versions are identical.,There is no compatibility issue (CI) in the method `isAnimationCacheEnabled()` between the early version (22) and the late version (23) as there is no change in the implementation. The method will behave the same way in both versions.
97,"<android.hardware.SystemSensorManager.TriggerEventQueue: void dispatchSensorEvent(int,float[],int,long)>",22,23,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final Sensor sensor, []), Expression(sHandleToSensor.get(handle), [])]), AssignmentExpression(=, [VariableReference(TriggerEvent t, []), Expression(null, [])]), Statement(synchronized (mTriggerEvents) {, []), AssignmentExpression(=, [VariableReference(t, []), Expression(mTriggerEvents.get(handle), [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (t, []), Expression(, [])]), MethodCall(Log.e(TAG, ""Error: Trigger Event is null for Sensor: "" + sensor), [VariableReference(Log, []), Expression(TAG, []), Expression(""Error: Trigger Event is null for Sensor: "" + sensor, [])]), Statement(return, []), Statement(}, []), Statement(// Copy from the values array., []), MethodCall(System.arraycopy(values, 0, t.values, 0, t.values.length), [VariableReference(System, []), Expression(values, []), Expression(0, []), Expression(t.values, []), Expression(0, []), Expression(t.values.length, [])]), AssignmentExpression(=, [VariableReference(t.timestamp, []), Expression(timestamp, [])]), AssignmentExpression(=, [VariableReference(t.sensor, []), Expression(sensor, [])]), Statement(// A trigger sensor is auto disabled. So just clean up and don't call native, []), Statement(// disable., []), MethodCall(mManager.cancelTriggerSensorImpl(mListener, sensor, false), [VariableReference(mManager, []), Expression(mListener, []), Expression(sensor, []), Expression(false, [])]), MethodCall(mListener.onTrigger(t), [VariableReference(mListener, []), Expression(t, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final Sensor sensor, []), Expression(sHandleToSensor.get(handle), [])])    VariableReference(final Sensor sensor, [])    Expression(sHandleToSensor.get(handle), [])  AssignmentExpression(=, [VariableReference(TriggerEvent t, []), Expression(null, [])])    VariableReference(TriggerEvent t, [])    Expression(null, [])  Statement(synchronized (mTriggerEvents) {, [])  AssignmentExpression(=, [VariableReference(t, []), Expression(mTriggerEvents.get(handle), [])])    VariableReference(t, [])    Expression(mTriggerEvents.get(handle), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (t, []), Expression(, [])])    VariableReference(if (t, [])    Expression(, [])  MethodCall(Log.e(TAG, ""Error: Trigger Event is null for Sensor: "" + sensor), [VariableReference(Log, []), Expression(TAG, []), Expression(""Error: Trigger Event is null for Sensor: "" + sensor, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Error: Trigger Event is null for Sensor: "" + sensor, [])  Statement(return, [])  Statement(}, [])  Statement(// Copy from the values array., [])  MethodCall(System.arraycopy(values, 0, t.values, 0, t.values.length), [VariableReference(System, []), Expression(values, []), Expression(0, []), Expression(t.values, []), Expression(0, []), Expression(t.values.length, [])])    VariableReference(System, [])    Expression(values, [])    Expression(0, [])    Expression(t.values, [])    Expression(0, [])    Expression(t.values.length, [])  AssignmentExpression(=, [VariableReference(t.timestamp, []), Expression(timestamp, [])])    VariableReference(t.timestamp, [])    Expression(timestamp, [])  AssignmentExpression(=, [VariableReference(t.sensor, []), Expression(sensor, [])])    VariableReference(t.sensor, [])    Expression(sensor, [])  Statement(// A trigger sensor is auto disabled. So just clean up and don't call native, [])  Statement(// disable., [])  MethodCall(mManager.cancelTriggerSensorImpl(mListener, sensor, false), [VariableReference(mManager, []), Expression(mListener, []), Expression(sensor, []), Expression(false, [])])    VariableReference(mManager, [])    Expression(mListener, [])    Expression(sensor, [])    Expression(false, [])  MethodCall(mListener.onTrigger(t), [VariableReference(mListener, []), Expression(t, [])])    VariableReference(mListener, [])    Expression(t, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final Sensor sensor, []), Expression(mManager.mHandleToSensor.get(handle), [])]), AssignmentExpression(=, [VariableReference(TriggerEvent t, []), Expression(null, [])]), Statement(synchronized (mTriggerEvents) {, []), AssignmentExpression(=, [VariableReference(t, []), Expression(mTriggerEvents.get(handle), [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (t, []), Expression(, [])]), MethodCall(Log.e(TAG, ""Error: Trigger Event is null for Sensor: "" + sensor), [VariableReference(Log, []), Expression(TAG, []), Expression(""Error: Trigger Event is null for Sensor: "" + sensor, [])]), Statement(return, []), Statement(}, []), Statement(// Copy from the values array., []), MethodCall(System.arraycopy(values, 0, t.values, 0, t.values.length), [VariableReference(System, []), Expression(values, []), Expression(0, []), Expression(t.values, []), Expression(0, []), Expression(t.values.length, [])]), AssignmentExpression(=, [VariableReference(t.timestamp, []), Expression(timestamp, [])]), AssignmentExpression(=, [VariableReference(t.sensor, []), Expression(sensor, [])]), Statement(// A trigger sensor is auto disabled. So just clean up and don't call native, []), Statement(// disable., []), MethodCall(mManager.cancelTriggerSensorImpl(mListener, sensor, false), [VariableReference(mManager, []), Expression(mListener, []), Expression(sensor, []), Expression(false, [])]), MethodCall(mListener.onTrigger(t), [VariableReference(mListener, []), Expression(t, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final Sensor sensor, []), Expression(mManager.mHandleToSensor.get(handle), [])])    VariableReference(final Sensor sensor, [])    Expression(mManager.mHandleToSensor.get(handle), [])  AssignmentExpression(=, [VariableReference(TriggerEvent t, []), Expression(null, [])])    VariableReference(TriggerEvent t, [])    Expression(null, [])  Statement(synchronized (mTriggerEvents) {, [])  AssignmentExpression(=, [VariableReference(t, []), Expression(mTriggerEvents.get(handle), [])])    VariableReference(t, [])    Expression(mTriggerEvents.get(handle), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (t, []), Expression(, [])])    VariableReference(if (t, [])    Expression(, [])  MethodCall(Log.e(TAG, ""Error: Trigger Event is null for Sensor: "" + sensor), [VariableReference(Log, []), Expression(TAG, []), Expression(""Error: Trigger Event is null for Sensor: "" + sensor, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Error: Trigger Event is null for Sensor: "" + sensor, [])  Statement(return, [])  Statement(}, [])  Statement(// Copy from the values array., [])  MethodCall(System.arraycopy(values, 0, t.values, 0, t.values.length), [VariableReference(System, []), Expression(values, []), Expression(0, []), Expression(t.values, []), Expression(0, []), Expression(t.values.length, [])])    VariableReference(System, [])    Expression(values, [])    Expression(0, [])    Expression(t.values, [])    Expression(0, [])    Expression(t.values.length, [])  AssignmentExpression(=, [VariableReference(t.timestamp, []), Expression(timestamp, [])])    VariableReference(t.timestamp, [])    Expression(timestamp, [])  AssignmentExpression(=, [VariableReference(t.sensor, []), Expression(sensor, [])])    VariableReference(t.sensor, [])    Expression(sensor, [])  Statement(// A trigger sensor is auto disabled. So just clean up and don't call native, [])  Statement(// disable., [])  MethodCall(mManager.cancelTriggerSensorImpl(mListener, sensor, false), [VariableReference(mManager, []), Expression(mListener, []), Expression(sensor, []), Expression(false, [])])    VariableReference(mManager, [])    Expression(mListener, [])    Expression(sensor, [])    Expression(false, [])  MethodCall(mListener.onTrigger(t), [VariableReference(mListener, []), Expression(t, [])])    VariableReference(mListener, [])    Expression(t, [])  Statement(}, [])",1,"// Called from native code.
","// Called from native code.
",0,"[@SuppressWarnings(""unused""), @Override]","[@SuppressWarnings(""unused""), @Override]",0,,,,2,"4,5",0,5,0,"The code change is a dependent API change (5), as the implementation of the `get` method used in the line `mManager.mHandleToSensor.get(handle)` has changed between the two versions. However, this change does not affect the behavior of the `dispatchSensorEvent` method, as it only retrieves a reference to a `Sensor` object and does not modify it or rely on its specific implementation.","There is no compatibility issue (0) caused by this change, as it does not affect the behavior of the `dispatchSensorEvent` method."
98,<android.os.Bundle: boolean hasFileDescriptors()>,22,23,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(if (!mFdsKnown) {, []), Statement(// keep going until we find one or run out of data, []), AssignmentExpression(=, [VariableReference(boolean fdFound, []), Expression(false, [])]), AssignmentExpression(=, [VariableReference(if (mParcelledData !, []), Expression(null) {, [])]), MethodCall(if (mParcelledData.hasFileDescriptors()), [VariableReference(if (mParcelledData, []), Expression(), [])]), AssignmentExpression(=, [VariableReference(fdFound, []), Expression(true, [])]), Statement(}, []), Statement(} else {, []), Statement(// It's been unparcelled, so we need to walk the map, []), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(mMap.size() - 1, [])]), AssignmentExpression(=, [VariableReference(i >, []), Expression(0, [])]), Statement(i--) {, []), AssignmentExpression(=, [VariableReference(Object obj, []), Expression(mMap.valueAt(i), [])]), Statement(if (obj instanceof Parcelable) {, []), AssignmentExpression(=, [VariableReference(if ((((Parcelable) obj).describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) !, []), Expression(0) {, [])]), AssignmentExpression(=, [VariableReference(fdFound, []), Expression(true, [])]), Statement(break, []), Statement(}, []), Statement(} else if (obj instanceof Parcelable[]) {, []), AssignmentExpression(=, [VariableReference(Parcelable[] array, []), Expression((Parcelable[]) obj, [])]), AssignmentExpression(=, [VariableReference(for (int n, []), Expression(array.length - 1, [])]), AssignmentExpression(=, [VariableReference(n >, []), Expression(0, [])]), Statement(n--) {, []), AssignmentExpression(=, [VariableReference(if ((array[n].describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) !, []), Expression(0) {, [])]), AssignmentExpression(=, [VariableReference(fdFound, []), Expression(true, [])]), Statement(break, []), Statement(}, []), Statement(}, []), Statement(} else if (obj instanceof SparseArray) {, []), AssignmentExpression(=, [VariableReference(SparseArray<? extends Parcelable> array, []), Expression((SparseArray<? extends Parcelable>) obj, [])]), AssignmentExpression(=, [VariableReference(for (int n, []), Expression(array.size() - 1, [])]), AssignmentExpression(=, [VariableReference(n >, []), Expression(0, [])]), Statement(n--) {, []), AssignmentExpression(=, [VariableReference(if ((array.valueAt(n).describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) !, []), Expression(0) {, [])]), AssignmentExpression(=, [VariableReference(fdFound, []), Expression(true, [])]), Statement(break, []), Statement(}, []), Statement(}, []), Statement(} else if (obj instanceof ArrayList) {, []), AssignmentExpression(=, [VariableReference(ArrayList array, []), Expression((ArrayList) obj, [])]), Statement(// Parcelables, []), Statement(only look inside for Parcelables, []), MethodCall(if (!array.isEmpty() && (array.get(0) instanceof Parcelable)), [VariableReference(if (!array, []), Expression() && (array.get(0) instanceof Parcelable), [])]), AssignmentExpression(=, [VariableReference(for (int n, []), Expression(array.size() - 1, [])]), AssignmentExpression(=, [VariableReference(n >, []), Expression(0, [])]), Statement(n--) {, []), AssignmentExpression(=, [VariableReference(Parcelable p, []), Expression((Parcelable) array.get(n), [])]), AssignmentExpression(=, [VariableReference(if (p !, []), Expression(null && ((p.describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) !, [])]), AssignmentExpression(=, [VariableReference(fdFound, []), Expression(true, [])]), Statement(break, []), Statement(}, []), Statement(}, []), Statement(}, []), Statement(}, []), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(mHasFds, []), Expression(fdFound, [])]), AssignmentExpression(=, [VariableReference(mFdsKnown, []), Expression(true, [])]), Statement(}, []), Statement(return mHasFds, []), Statement(}, [])])  Statement({, [])  Statement(if (!mFdsKnown) {, [])  Statement(// keep going until we find one or run out of data, [])  AssignmentExpression(=, [VariableReference(boolean fdFound, []), Expression(false, [])])    VariableReference(boolean fdFound, [])    Expression(false, [])  AssignmentExpression(=, [VariableReference(if (mParcelledData !, []), Expression(null) {, [])])    VariableReference(if (mParcelledData !, [])    Expression(null) {, [])  MethodCall(if (mParcelledData.hasFileDescriptors()), [VariableReference(if (mParcelledData, []), Expression(), [])])    VariableReference(if (mParcelledData, [])    Expression(), [])  AssignmentExpression(=, [VariableReference(fdFound, []), Expression(true, [])])    VariableReference(fdFound, [])    Expression(true, [])  Statement(}, [])  Statement(} else {, [])  Statement(// It's been unparcelled, so we need to walk the map, [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(mMap.size() - 1, [])])    VariableReference(for (int i, [])    Expression(mMap.size() - 1, [])  AssignmentExpression(=, [VariableReference(i >, []), Expression(0, [])])    VariableReference(i >, [])    Expression(0, [])  Statement(i--) {, [])  AssignmentExpression(=, [VariableReference(Object obj, []), Expression(mMap.valueAt(i), [])])    VariableReference(Object obj, [])    Expression(mMap.valueAt(i), [])  Statement(if (obj instanceof Parcelable) {, [])  AssignmentExpression(=, [VariableReference(if ((((Parcelable) obj).describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) !, []), Expression(0) {, [])])    VariableReference(if ((((Parcelable) obj).describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) !, [])    Expression(0) {, [])  AssignmentExpression(=, [VariableReference(fdFound, []), Expression(true, [])])    VariableReference(fdFound, [])    Expression(true, [])  Statement(break, [])  Statement(}, [])  Statement(} else if (obj instanceof Parcelable[]) {, [])  AssignmentExpression(=, [VariableReference(Parcelable[] array, []), Expression((Parcelable[]) obj, [])])    VariableReference(Parcelable[] array, [])    Expression((Parcelable[]) obj, [])  AssignmentExpression(=, [VariableReference(for (int n, []), Expression(array.length - 1, [])])    VariableReference(for (int n, [])    Expression(array.length - 1, [])  AssignmentExpression(=, [VariableReference(n >, []), Expression(0, [])])    VariableReference(n >, [])    Expression(0, [])  Statement(n--) {, [])  AssignmentExpression(=, [VariableReference(if ((array[n].describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) !, []), Expression(0) {, [])])    VariableReference(if ((array[n].describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) !, [])    Expression(0) {, [])  AssignmentExpression(=, [VariableReference(fdFound, []), Expression(true, [])])    VariableReference(fdFound, [])    Expression(true, [])  Statement(break, [])  Statement(}, [])  Statement(}, [])  Statement(} else if (obj instanceof SparseArray) {, [])  AssignmentExpression(=, [VariableReference(SparseArray<? extends Parcelable> array, []), Expression((SparseArray<? extends Parcelable>) obj, [])])    VariableReference(SparseArray<? extends Parcelable> array, [])    Expression((SparseArray<? extends Parcelable>) obj, [])  AssignmentExpression(=, [VariableReference(for (int n, []), Expression(array.size() - 1, [])])    VariableReference(for (int n, [])    Expression(array.size() - 1, [])  AssignmentExpression(=, [VariableReference(n >, []), Expression(0, [])])    VariableReference(n >, [])    Expression(0, [])  Statement(n--) {, [])  AssignmentExpression(=, [VariableReference(if ((array.valueAt(n).describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) !, []), Expression(0) {, [])])    VariableReference(if ((array.valueAt(n).describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) !, [])    Expression(0) {, [])  AssignmentExpression(=, [VariableReference(fdFound, []), Expression(true, [])])    VariableReference(fdFound, [])    Expression(true, [])  Statement(break, [])  Statement(}, [])  Statement(}, [])  Statement(} else if (obj instanceof ArrayList) {, [])  AssignmentExpression(=, [VariableReference(ArrayList array, []), Expression((ArrayList) obj, [])])    VariableReference(ArrayList array, [])    Expression((ArrayList) obj, [])  Statement(// Parcelables, [])  Statement(only look inside for Parcelables, [])  MethodCall(if (!array.isEmpty() && (array.get(0) instanceof Parcelable)), [VariableReference(if (!array, []), Expression() && (array.get(0) instanceof Parcelable), [])])    VariableReference(if (!array, [])    Expression() && (array.get(0) instanceof Parcelable), [])  AssignmentExpression(=, [VariableReference(for (int n, []), Expression(array.size() - 1, [])])    VariableReference(for (int n, [])    Expression(array.size() - 1, [])  AssignmentExpression(=, [VariableReference(n >, []), Expression(0, [])])    VariableReference(n >, [])    Expression(0, [])  Statement(n--) {, [])  AssignmentExpression(=, [VariableReference(Parcelable p, []), Expression((Parcelable) array.get(n), [])])    VariableReference(Parcelable p, [])    Expression((Parcelable) array.get(n), [])  AssignmentExpression(=, [VariableReference(if (p !, []), Expression(null && ((p.describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) !, [])])    VariableReference(if (p !, [])    Expression(null && ((p.describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) !, [])  AssignmentExpression(=, [VariableReference(fdFound, []), Expression(true, [])])    VariableReference(fdFound, [])    Expression(true, [])  Statement(break, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mHasFds, []), Expression(fdFound, [])])    VariableReference(mHasFds, [])    Expression(fdFound, [])  AssignmentExpression(=, [VariableReference(mFdsKnown, []), Expression(true, [])])    VariableReference(mFdsKnown, [])    Expression(true, [])  Statement(}, [])  Statement(return mHasFds, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (!mFdsKnown) {, []), Statement(// keep going until we find one or run out of data, []), AssignmentExpression(=, [VariableReference(boolean fdFound, []), Expression(false, [])]), AssignmentExpression(=, [VariableReference(if (mParcelledData !, []), Expression(null) {, [])]), MethodCall(if (mParcelledData.hasFileDescriptors()), [VariableReference(if (mParcelledData, []), Expression(), [])]), AssignmentExpression(=, [VariableReference(fdFound, []), Expression(true, [])]), Statement(}, []), Statement(} else {, []), Statement(// It's been unparcelled, so we need to walk the map, []), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(mMap.size() - 1, [])]), AssignmentExpression(=, [VariableReference(i >, []), Expression(0, [])]), Statement(i--) {, []), AssignmentExpression(=, [VariableReference(Object obj, []), Expression(mMap.valueAt(i), [])]), Statement(if (obj instanceof Parcelable) {, []), AssignmentExpression(=, [VariableReference(if ((((Parcelable) obj).describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) !, []), Expression(0) {, [])]), AssignmentExpression(=, [VariableReference(fdFound, []), Expression(true, [])]), Statement(break, []), Statement(}, []), Statement(} else if (obj instanceof Parcelable[]) {, []), AssignmentExpression(=, [VariableReference(Parcelable[] array, []), Expression((Parcelable[]) obj, [])]), AssignmentExpression(=, [VariableReference(for (int n, []), Expression(array.length - 1, [])]), AssignmentExpression(=, [VariableReference(n >, []), Expression(0, [])]), Statement(n--) {, []), AssignmentExpression(=, [VariableReference(Parcelable p, []), Expression(array[n], [])]), AssignmentExpression(=, [VariableReference(if (p !, []), Expression(null && ((p.describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) !, [])]), AssignmentExpression(=, [VariableReference(fdFound, []), Expression(true, [])]), Statement(break, []), Statement(}, []), Statement(}, []), Statement(} else if (obj instanceof SparseArray) {, []), AssignmentExpression(=, [VariableReference(SparseArray<? extends Parcelable> array, []), Expression((SparseArray<? extends Parcelable>) obj, [])]), AssignmentExpression(=, [VariableReference(for (int n, []), Expression(array.size() - 1, [])]), AssignmentExpression(=, [VariableReference(n >, []), Expression(0, [])]), Statement(n--) {, []), AssignmentExpression(=, [VariableReference(Parcelable p, []), Expression(array.valueAt(n), [])]), AssignmentExpression(=, [VariableReference(if (p !, []), Expression(null && (p.describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) !, [])]), AssignmentExpression(=, [VariableReference(fdFound, []), Expression(true, [])]), Statement(break, []), Statement(}, []), Statement(}, []), Statement(} else if (obj instanceof ArrayList) {, []), AssignmentExpression(=, [VariableReference(ArrayList array, []), Expression((ArrayList) obj, [])]), Statement(// Parcelables, []), Statement(only look inside for Parcelables, []), MethodCall(if (!array.isEmpty() && (array.get(0) instanceof Parcelable)), [VariableReference(if (!array, []), Expression() && (array.get(0) instanceof Parcelable), [])]), AssignmentExpression(=, [VariableReference(for (int n, []), Expression(array.size() - 1, [])]), AssignmentExpression(=, [VariableReference(n >, []), Expression(0, [])]), Statement(n--) {, []), AssignmentExpression(=, [VariableReference(Parcelable p, []), Expression((Parcelable) array.get(n), [])]), AssignmentExpression(=, [VariableReference(if (p !, []), Expression(null && ((p.describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) !, [])]), AssignmentExpression(=, [VariableReference(fdFound, []), Expression(true, [])]), Statement(break, []), Statement(}, []), Statement(}, []), Statement(}, []), Statement(}, []), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(mHasFds, []), Expression(fdFound, [])]), AssignmentExpression(=, [VariableReference(mFdsKnown, []), Expression(true, [])]), Statement(}, []), Statement(return mHasFds, []), Statement(}, [])])  Statement({, [])  Statement(if (!mFdsKnown) {, [])  Statement(// keep going until we find one or run out of data, [])  AssignmentExpression(=, [VariableReference(boolean fdFound, []), Expression(false, [])])    VariableReference(boolean fdFound, [])    Expression(false, [])  AssignmentExpression(=, [VariableReference(if (mParcelledData !, []), Expression(null) {, [])])    VariableReference(if (mParcelledData !, [])    Expression(null) {, [])  MethodCall(if (mParcelledData.hasFileDescriptors()), [VariableReference(if (mParcelledData, []), Expression(), [])])    VariableReference(if (mParcelledData, [])    Expression(), [])  AssignmentExpression(=, [VariableReference(fdFound, []), Expression(true, [])])    VariableReference(fdFound, [])    Expression(true, [])  Statement(}, [])  Statement(} else {, [])  Statement(// It's been unparcelled, so we need to walk the map, [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(mMap.size() - 1, [])])    VariableReference(for (int i, [])    Expression(mMap.size() - 1, [])  AssignmentExpression(=, [VariableReference(i >, []), Expression(0, [])])    VariableReference(i >, [])    Expression(0, [])  Statement(i--) {, [])  AssignmentExpression(=, [VariableReference(Object obj, []), Expression(mMap.valueAt(i), [])])    VariableReference(Object obj, [])    Expression(mMap.valueAt(i), [])  Statement(if (obj instanceof Parcelable) {, [])  AssignmentExpression(=, [VariableReference(if ((((Parcelable) obj).describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) !, []), Expression(0) {, [])])    VariableReference(if ((((Parcelable) obj).describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) !, [])    Expression(0) {, [])  AssignmentExpression(=, [VariableReference(fdFound, []), Expression(true, [])])    VariableReference(fdFound, [])    Expression(true, [])  Statement(break, [])  Statement(}, [])  Statement(} else if (obj instanceof Parcelable[]) {, [])  AssignmentExpression(=, [VariableReference(Parcelable[] array, []), Expression((Parcelable[]) obj, [])])    VariableReference(Parcelable[] array, [])    Expression((Parcelable[]) obj, [])  AssignmentExpression(=, [VariableReference(for (int n, []), Expression(array.length - 1, [])])    VariableReference(for (int n, [])    Expression(array.length - 1, [])  AssignmentExpression(=, [VariableReference(n >, []), Expression(0, [])])    VariableReference(n >, [])    Expression(0, [])  Statement(n--) {, [])  AssignmentExpression(=, [VariableReference(Parcelable p, []), Expression(array[n], [])])    VariableReference(Parcelable p, [])    Expression(array[n], [])  AssignmentExpression(=, [VariableReference(if (p !, []), Expression(null && ((p.describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) !, [])])    VariableReference(if (p !, [])    Expression(null && ((p.describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) !, [])  AssignmentExpression(=, [VariableReference(fdFound, []), Expression(true, [])])    VariableReference(fdFound, [])    Expression(true, [])  Statement(break, [])  Statement(}, [])  Statement(}, [])  Statement(} else if (obj instanceof SparseArray) {, [])  AssignmentExpression(=, [VariableReference(SparseArray<? extends Parcelable> array, []), Expression((SparseArray<? extends Parcelable>) obj, [])])    VariableReference(SparseArray<? extends Parcelable> array, [])    Expression((SparseArray<? extends Parcelable>) obj, [])  AssignmentExpression(=, [VariableReference(for (int n, []), Expression(array.size() - 1, [])])    VariableReference(for (int n, [])    Expression(array.size() - 1, [])  AssignmentExpression(=, [VariableReference(n >, []), Expression(0, [])])    VariableReference(n >, [])    Expression(0, [])  Statement(n--) {, [])  AssignmentExpression(=, [VariableReference(Parcelable p, []), Expression(array.valueAt(n), [])])    VariableReference(Parcelable p, [])    Expression(array.valueAt(n), [])  AssignmentExpression(=, [VariableReference(if (p !, []), Expression(null && (p.describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) !, [])])    VariableReference(if (p !, [])    Expression(null && (p.describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) !, [])  AssignmentExpression(=, [VariableReference(fdFound, []), Expression(true, [])])    VariableReference(fdFound, [])    Expression(true, [])  Statement(break, [])  Statement(}, [])  Statement(}, [])  Statement(} else if (obj instanceof ArrayList) {, [])  AssignmentExpression(=, [VariableReference(ArrayList array, []), Expression((ArrayList) obj, [])])    VariableReference(ArrayList array, [])    Expression((ArrayList) obj, [])  Statement(// Parcelables, [])  Statement(only look inside for Parcelables, [])  MethodCall(if (!array.isEmpty() && (array.get(0) instanceof Parcelable)), [VariableReference(if (!array, []), Expression() && (array.get(0) instanceof Parcelable), [])])    VariableReference(if (!array, [])    Expression() && (array.get(0) instanceof Parcelable), [])  AssignmentExpression(=, [VariableReference(for (int n, []), Expression(array.size() - 1, [])])    VariableReference(for (int n, [])    Expression(array.size() - 1, [])  AssignmentExpression(=, [VariableReference(n >, []), Expression(0, [])])    VariableReference(n >, [])    Expression(0, [])  Statement(n--) {, [])  AssignmentExpression(=, [VariableReference(Parcelable p, []), Expression((Parcelable) array.get(n), [])])    VariableReference(Parcelable p, [])    Expression((Parcelable) array.get(n), [])  AssignmentExpression(=, [VariableReference(if (p !, []), Expression(null && ((p.describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) !, [])])    VariableReference(if (p !, [])    Expression(null && ((p.describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) !, [])  AssignmentExpression(=, [VariableReference(fdFound, []), Expression(true, [])])    VariableReference(fdFound, [])    Expression(true, [])  Statement(break, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mHasFds, []), Expression(fdFound, [])])    VariableReference(mHasFds, [])    Expression(fdFound, [])  AssignmentExpression(=, [VariableReference(mFdsKnown, []), Expression(true, [])])    VariableReference(mFdsKnown, [])    Expression(true, [])  Statement(}, [])  Statement(return mHasFds, [])  Statement(}, [])",1,"/**
 * Reports whether the bundle contains any parcelled file descriptors.
 */
","/**
 * Reports whether the bundle contains any parcelled file descriptors.
 */
",0,,,0,,,,"1,2","3,4",1,0,0,"The AST nodes provided for the early and late versions of the API are identical. Therefore, there is no code change between the two versions.","As there is no code change between the two versions, there is no compatibility issue (CI) existent for the API."
99,"<android.content.IntentFilter: void writeToParcel(Parcel,int)>",22,23,,,,"MethodDeclaration(method_body, [Statement({, []), MethodCall(dest.writeStringList(mActions), [VariableReference(dest, []), Expression(mActions, [])]), AssignmentExpression(=, [VariableReference(if (mCategories !, []), Expression(null) {, [])]), MethodCall(dest.writeInt(1), [VariableReference(dest, []), Expression(1, [])]), MethodCall(dest.writeStringList(mCategories), [VariableReference(dest, []), Expression(mCategories, [])]), Statement(} else {, []), MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mDataSchemes !, []), Expression(null) {, [])]), MethodCall(dest.writeInt(1), [VariableReference(dest, []), Expression(1, [])]), MethodCall(dest.writeStringList(mDataSchemes), [VariableReference(dest, []), Expression(mDataSchemes, [])]), Statement(} else {, []), MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mDataTypes !, []), Expression(null) {, [])]), MethodCall(dest.writeInt(1), [VariableReference(dest, []), Expression(1, [])]), MethodCall(dest.writeStringList(mDataTypes), [VariableReference(dest, []), Expression(mDataTypes, [])]), Statement(} else {, []), MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mDataSchemeSpecificParts !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(final int N, []), Expression(mDataSchemeSpecificParts.size(), [])]), MethodCall(dest.writeInt(N), [VariableReference(dest, []), Expression(N, [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < N, []), Statement(i++) {, []), MethodCall(mDataSchemeSpecificParts.get(i).writeToParcel(dest, flags), [VariableReference(mDataSchemeSpecificParts, []), Expression(i).writeToParcel(dest, []), Expression(flags, [])]), Statement(}, []), Statement(} else {, []), MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mDataAuthorities !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(final int N, []), Expression(mDataAuthorities.size(), [])]), MethodCall(dest.writeInt(N), [VariableReference(dest, []), Expression(N, [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < N, []), Statement(i++) {, []), MethodCall(mDataAuthorities.get(i).writeToParcel(dest), [VariableReference(mDataAuthorities, []), Expression(i).writeToParcel(dest, [])]), Statement(}, []), Statement(} else {, []), MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mDataPaths !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(final int N, []), Expression(mDataPaths.size(), [])]), MethodCall(dest.writeInt(N), [VariableReference(dest, []), Expression(N, [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < N, []), Statement(i++) {, []), MethodCall(mDataPaths.get(i).writeToParcel(dest, flags), [VariableReference(mDataPaths, []), Expression(i).writeToParcel(dest, []), Expression(flags, [])]), Statement(}, []), Statement(} else {, []), MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])]), Statement(}, []), MethodCall(dest.writeInt(mPriority), [VariableReference(dest, []), Expression(mPriority, [])]), MethodCall(dest.writeInt(mHasPartialTypes ? 1 : 0), [VariableReference(dest, []), Expression(mHasPartialTypes ? 1 : 0, [])]), Statement(}, [])])  Statement({, [])  MethodCall(dest.writeStringList(mActions), [VariableReference(dest, []), Expression(mActions, [])])    VariableReference(dest, [])    Expression(mActions, [])  AssignmentExpression(=, [VariableReference(if (mCategories !, []), Expression(null) {, [])])    VariableReference(if (mCategories !, [])    Expression(null) {, [])  MethodCall(dest.writeInt(1), [VariableReference(dest, []), Expression(1, [])])    VariableReference(dest, [])    Expression(1, [])  MethodCall(dest.writeStringList(mCategories), [VariableReference(dest, []), Expression(mCategories, [])])    VariableReference(dest, [])    Expression(mCategories, [])  Statement(} else {, [])  MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])])    VariableReference(dest, [])    Expression(0, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mDataSchemes !, []), Expression(null) {, [])])    VariableReference(if (mDataSchemes !, [])    Expression(null) {, [])  MethodCall(dest.writeInt(1), [VariableReference(dest, []), Expression(1, [])])    VariableReference(dest, [])    Expression(1, [])  MethodCall(dest.writeStringList(mDataSchemes), [VariableReference(dest, []), Expression(mDataSchemes, [])])    VariableReference(dest, [])    Expression(mDataSchemes, [])  Statement(} else {, [])  MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])])    VariableReference(dest, [])    Expression(0, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mDataTypes !, []), Expression(null) {, [])])    VariableReference(if (mDataTypes !, [])    Expression(null) {, [])  MethodCall(dest.writeInt(1), [VariableReference(dest, []), Expression(1, [])])    VariableReference(dest, [])    Expression(1, [])  MethodCall(dest.writeStringList(mDataTypes), [VariableReference(dest, []), Expression(mDataTypes, [])])    VariableReference(dest, [])    Expression(mDataTypes, [])  Statement(} else {, [])  MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])])    VariableReference(dest, [])    Expression(0, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mDataSchemeSpecificParts !, []), Expression(null) {, [])])    VariableReference(if (mDataSchemeSpecificParts !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(final int N, []), Expression(mDataSchemeSpecificParts.size(), [])])    VariableReference(final int N, [])    Expression(mDataSchemeSpecificParts.size(), [])  MethodCall(dest.writeInt(N), [VariableReference(dest, []), Expression(N, [])])    VariableReference(dest, [])    Expression(N, [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < N, [])  Statement(i++) {, [])  MethodCall(mDataSchemeSpecificParts.get(i).writeToParcel(dest, flags), [VariableReference(mDataSchemeSpecificParts, []), Expression(i).writeToParcel(dest, []), Expression(flags, [])])    VariableReference(mDataSchemeSpecificParts, [])    Expression(i).writeToParcel(dest, [])    Expression(flags, [])  Statement(}, [])  Statement(} else {, [])  MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])])    VariableReference(dest, [])    Expression(0, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mDataAuthorities !, []), Expression(null) {, [])])    VariableReference(if (mDataAuthorities !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(final int N, []), Expression(mDataAuthorities.size(), [])])    VariableReference(final int N, [])    Expression(mDataAuthorities.size(), [])  MethodCall(dest.writeInt(N), [VariableReference(dest, []), Expression(N, [])])    VariableReference(dest, [])    Expression(N, [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < N, [])  Statement(i++) {, [])  MethodCall(mDataAuthorities.get(i).writeToParcel(dest), [VariableReference(mDataAuthorities, []), Expression(i).writeToParcel(dest, [])])    VariableReference(mDataAuthorities, [])    Expression(i).writeToParcel(dest, [])  Statement(}, [])  Statement(} else {, [])  MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])])    VariableReference(dest, [])    Expression(0, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mDataPaths !, []), Expression(null) {, [])])    VariableReference(if (mDataPaths !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(final int N, []), Expression(mDataPaths.size(), [])])    VariableReference(final int N, [])    Expression(mDataPaths.size(), [])  MethodCall(dest.writeInt(N), [VariableReference(dest, []), Expression(N, [])])    VariableReference(dest, [])    Expression(N, [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < N, [])  Statement(i++) {, [])  MethodCall(mDataPaths.get(i).writeToParcel(dest, flags), [VariableReference(mDataPaths, []), Expression(i).writeToParcel(dest, []), Expression(flags, [])])    VariableReference(mDataPaths, [])    Expression(i).writeToParcel(dest, [])    Expression(flags, [])  Statement(}, [])  Statement(} else {, [])  MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])])    VariableReference(dest, [])    Expression(0, [])  Statement(}, [])  MethodCall(dest.writeInt(mPriority), [VariableReference(dest, []), Expression(mPriority, [])])    VariableReference(dest, [])    Expression(mPriority, [])  MethodCall(dest.writeInt(mHasPartialTypes ? 1 : 0), [VariableReference(dest, []), Expression(mHasPartialTypes ? 1 : 0, [])])    VariableReference(dest, [])    Expression(mHasPartialTypes ? 1 : 0, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(dest.writeStringList(mActions), [VariableReference(dest, []), Expression(mActions, [])]), AssignmentExpression(=, [VariableReference(if (mCategories !, []), Expression(null) {, [])]), MethodCall(dest.writeInt(1), [VariableReference(dest, []), Expression(1, [])]), MethodCall(dest.writeStringList(mCategories), [VariableReference(dest, []), Expression(mCategories, [])]), Statement(} else {, []), MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mDataSchemes !, []), Expression(null) {, [])]), MethodCall(dest.writeInt(1), [VariableReference(dest, []), Expression(1, [])]), MethodCall(dest.writeStringList(mDataSchemes), [VariableReference(dest, []), Expression(mDataSchemes, [])]), Statement(} else {, []), MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mDataTypes !, []), Expression(null) {, [])]), MethodCall(dest.writeInt(1), [VariableReference(dest, []), Expression(1, [])]), MethodCall(dest.writeStringList(mDataTypes), [VariableReference(dest, []), Expression(mDataTypes, [])]), Statement(} else {, []), MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mDataSchemeSpecificParts !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(final int N, []), Expression(mDataSchemeSpecificParts.size(), [])]), MethodCall(dest.writeInt(N), [VariableReference(dest, []), Expression(N, [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < N, []), Statement(i++) {, []), MethodCall(mDataSchemeSpecificParts.get(i).writeToParcel(dest, flags), [VariableReference(mDataSchemeSpecificParts, []), Expression(i).writeToParcel(dest, []), Expression(flags, [])]), Statement(}, []), Statement(} else {, []), MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mDataAuthorities !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(final int N, []), Expression(mDataAuthorities.size(), [])]), MethodCall(dest.writeInt(N), [VariableReference(dest, []), Expression(N, [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < N, []), Statement(i++) {, []), MethodCall(mDataAuthorities.get(i).writeToParcel(dest), [VariableReference(mDataAuthorities, []), Expression(i).writeToParcel(dest, [])]), Statement(}, []), Statement(} else {, []), MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mDataPaths !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(final int N, []), Expression(mDataPaths.size(), [])]), MethodCall(dest.writeInt(N), [VariableReference(dest, []), Expression(N, [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < N, []), Statement(i++) {, []), MethodCall(mDataPaths.get(i).writeToParcel(dest, flags), [VariableReference(mDataPaths, []), Expression(i).writeToParcel(dest, []), Expression(flags, [])]), Statement(}, []), Statement(} else {, []), MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])]), Statement(}, []), MethodCall(dest.writeInt(mPriority), [VariableReference(dest, []), Expression(mPriority, [])]), MethodCall(dest.writeInt(mHasPartialTypes ? 1 : 0), [VariableReference(dest, []), Expression(mHasPartialTypes ? 1 : 0, [])]), MethodCall(dest.writeInt(getAutoVerify() ? 1 : 0), [VariableReference(dest, []), Expression(getAutoVerify() ? 1 : 0, [])]), Statement(}, [])])  Statement({, [])  MethodCall(dest.writeStringList(mActions), [VariableReference(dest, []), Expression(mActions, [])])    VariableReference(dest, [])    Expression(mActions, [])  AssignmentExpression(=, [VariableReference(if (mCategories !, []), Expression(null) {, [])])    VariableReference(if (mCategories !, [])    Expression(null) {, [])  MethodCall(dest.writeInt(1), [VariableReference(dest, []), Expression(1, [])])    VariableReference(dest, [])    Expression(1, [])  MethodCall(dest.writeStringList(mCategories), [VariableReference(dest, []), Expression(mCategories, [])])    VariableReference(dest, [])    Expression(mCategories, [])  Statement(} else {, [])  MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])])    VariableReference(dest, [])    Expression(0, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mDataSchemes !, []), Expression(null) {, [])])    VariableReference(if (mDataSchemes !, [])    Expression(null) {, [])  MethodCall(dest.writeInt(1), [VariableReference(dest, []), Expression(1, [])])    VariableReference(dest, [])    Expression(1, [])  MethodCall(dest.writeStringList(mDataSchemes), [VariableReference(dest, []), Expression(mDataSchemes, [])])    VariableReference(dest, [])    Expression(mDataSchemes, [])  Statement(} else {, [])  MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])])    VariableReference(dest, [])    Expression(0, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mDataTypes !, []), Expression(null) {, [])])    VariableReference(if (mDataTypes !, [])    Expression(null) {, [])  MethodCall(dest.writeInt(1), [VariableReference(dest, []), Expression(1, [])])    VariableReference(dest, [])    Expression(1, [])  MethodCall(dest.writeStringList(mDataTypes), [VariableReference(dest, []), Expression(mDataTypes, [])])    VariableReference(dest, [])    Expression(mDataTypes, [])  Statement(} else {, [])  MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])])    VariableReference(dest, [])    Expression(0, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mDataSchemeSpecificParts !, []), Expression(null) {, [])])    VariableReference(if (mDataSchemeSpecificParts !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(final int N, []), Expression(mDataSchemeSpecificParts.size(), [])])    VariableReference(final int N, [])    Expression(mDataSchemeSpecificParts.size(), [])  MethodCall(dest.writeInt(N), [VariableReference(dest, []), Expression(N, [])])    VariableReference(dest, [])    Expression(N, [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < N, [])  Statement(i++) {, [])  MethodCall(mDataSchemeSpecificParts.get(i).writeToParcel(dest, flags), [VariableReference(mDataSchemeSpecificParts, []), Expression(i).writeToParcel(dest, []), Expression(flags, [])])    VariableReference(mDataSchemeSpecificParts, [])    Expression(i).writeToParcel(dest, [])    Expression(flags, [])  Statement(}, [])  Statement(} else {, [])  MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])])    VariableReference(dest, [])    Expression(0, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mDataAuthorities !, []), Expression(null) {, [])])    VariableReference(if (mDataAuthorities !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(final int N, []), Expression(mDataAuthorities.size(), [])])    VariableReference(final int N, [])    Expression(mDataAuthorities.size(), [])  MethodCall(dest.writeInt(N), [VariableReference(dest, []), Expression(N, [])])    VariableReference(dest, [])    Expression(N, [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < N, [])  Statement(i++) {, [])  MethodCall(mDataAuthorities.get(i).writeToParcel(dest), [VariableReference(mDataAuthorities, []), Expression(i).writeToParcel(dest, [])])    VariableReference(mDataAuthorities, [])    Expression(i).writeToParcel(dest, [])  Statement(}, [])  Statement(} else {, [])  MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])])    VariableReference(dest, [])    Expression(0, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mDataPaths !, []), Expression(null) {, [])])    VariableReference(if (mDataPaths !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(final int N, []), Expression(mDataPaths.size(), [])])    VariableReference(final int N, [])    Expression(mDataPaths.size(), [])  MethodCall(dest.writeInt(N), [VariableReference(dest, []), Expression(N, [])])    VariableReference(dest, [])    Expression(N, [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < N, [])  Statement(i++) {, [])  MethodCall(mDataPaths.get(i).writeToParcel(dest, flags), [VariableReference(mDataPaths, []), Expression(i).writeToParcel(dest, []), Expression(flags, [])])    VariableReference(mDataPaths, [])    Expression(i).writeToParcel(dest, [])    Expression(flags, [])  Statement(}, [])  Statement(} else {, [])  MethodCall(dest.writeInt(0), [VariableReference(dest, []), Expression(0, [])])    VariableReference(dest, [])    Expression(0, [])  Statement(}, [])  MethodCall(dest.writeInt(mPriority), [VariableReference(dest, []), Expression(mPriority, [])])    VariableReference(dest, [])    Expression(mPriority, [])  MethodCall(dest.writeInt(mHasPartialTypes ? 1 : 0), [VariableReference(dest, []), Expression(mHasPartialTypes ? 1 : 0, [])])    VariableReference(dest, [])    Expression(mHasPartialTypes ? 1 : 0, [])  MethodCall(dest.writeInt(getAutoVerify() ? 1 : 0), [VariableReference(dest, []), Expression(getAutoVerify() ? 1 : 0, [])])    VariableReference(dest, [])    Expression(getAutoVerify() ? 1 : 0, [])  Statement(}, [])",1,,,0,,,0,,,,1,"1,4",1,"1,4",1,,A new method call has been added in the late version implementation: `dest.writeInt(getAutoVerify() ? 1 : 0)`. This method call writes the value of `getAutoVerify()` to the `Parcel` object `dest`.
100,<android.content.res.TypedArray: Resources getResources()>,22,23,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(if (mRecycled) {, []), Statement(throw new RuntimeException(""Cannot make calls to a recycled instance!""), []), Statement(}, []), Statement(return mResources, []), Statement(}, [])])  Statement({, [])  Statement(if (mRecycled) {, [])  Statement(throw new RuntimeException(""Cannot make calls to a recycled instance!""), [])  Statement(}, [])  Statement(return mResources, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (mRecycled) {, []), Statement(throw new RuntimeException(""Cannot make calls to a recycled instance!""), []), Statement(}, []), Statement(return mResources, []), Statement(}, [])])  Statement({, [])  Statement(if (mRecycled) {, [])  Statement(throw new RuntimeException(""Cannot make calls to a recycled instance!""), [])  Statement(}, [])  Statement(return mResources, [])  Statement(}, [])",0,"/**
 * Return the Resources object this array was loaded from.
 */
","/**
 * Returns the Resources object this array was loaded from.
 *
 * @throws RuntimeException if the TypedArray has already been recycled.
 */
",1,,,0,,,,0,0,0,0,0,There is no change in the implementation of the method `getResources()` between the early version (22) and the late version (23).,There is no compatibility issue between the early version and the late version of the method `getResources()` since there is no change in the implementation.
101,<android.widget.TimePicker: boolean is24HourView()>,22,23,,,,"MethodDeclaration(method_body, [Statement({, []), MethodCall(return mDelegate.is24HourView(), [VariableReference(return mDelegate, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return mDelegate.is24HourView(), [VariableReference(return mDelegate, []), Expression(, [])])    VariableReference(return mDelegate, [])    Expression(, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(return mDelegate.is24HourView(), [VariableReference(return mDelegate, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return mDelegate.is24HourView(), [VariableReference(return mDelegate, []), Expression(, [])])    VariableReference(return mDelegate, [])    Expression(, [])  Statement(}, [])",0,"/**
 * @return true if this is in 24 hour view else false.
 */
","/**
 * @return {@code true} if this widget displays time in 24-hour mode,
 * {@code false} otherwise}
 * @see #setIs24HourView(Boolean)
 */
",1,,,0,,,,0,0,0,0,0,There is no change in the implementation between the early version and late version. The AST nodes are the same for both versions.,There is no Compatibility Issue as there is no change in the implementation. The behavior of the API will be the same in both versions.
102,<android.net.DhcpStateMachine.StoppedState: boolean processMessage(Message)>,22,23,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(boolean retValue, []), Expression(HANDLED, [])]), Statement(if (DBG), []), MethodCall(Log.d(TAG, getName() + message.toString() + ""\n""), [VariableReference(Log, []), Expression(TAG, []), Expression(getName() + message.toString() + ""\n"", [])]), Statement(case CMD_START_DHCP:, []), Statement(if (mRegisteredForPreDhcpNotification) {, []), Statement(/* Notify controller before starting DHCP */, []), MethodCall(mController.sendMessage(CMD_PRE_DHCP_ACTION), [VariableReference(mController, []), Expression(CMD_PRE_DHCP_ACTION, [])]), Statement(transitionTo(mWaitBeforeStartState), []), Statement(} else {, []), Statement(transitionTo(mRunningState), []), Statement(}, []), Statement(}, []), Statement(break, []), Statement(case CMD_STOP_DHCP:, []), Statement(// ignore, []), Statement(break, []), Statement(default:, []), AssignmentExpression(=, [VariableReference(retValue, []), Expression(NOT_HANDLED, [])]), Statement(break, []), Statement(}, []), Statement(return retValue, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(boolean retValue, []), Expression(HANDLED, [])])    VariableReference(boolean retValue, [])    Expression(HANDLED, [])  Statement(if (DBG), [])  MethodCall(Log.d(TAG, getName() + message.toString() + ""\n""), [VariableReference(Log, []), Expression(TAG, []), Expression(getName() + message.toString() + ""\n"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(getName() + message.toString() + ""\n"", [])  Statement(case CMD_START_DHCP:, [])  Statement(if (mRegisteredForPreDhcpNotification) {, [])  Statement(/* Notify controller before starting DHCP */, [])  MethodCall(mController.sendMessage(CMD_PRE_DHCP_ACTION), [VariableReference(mController, []), Expression(CMD_PRE_DHCP_ACTION, [])])    VariableReference(mController, [])    Expression(CMD_PRE_DHCP_ACTION, [])  Statement(transitionTo(mWaitBeforeStartState), [])  Statement(} else {, [])  Statement(transitionTo(mRunningState), [])  Statement(}, [])  Statement(}, [])  Statement(break, [])  Statement(case CMD_STOP_DHCP:, [])  Statement(// ignore, [])  Statement(break, [])  Statement(default:, [])  AssignmentExpression(=, [VariableReference(retValue, []), Expression(NOT_HANDLED, [])])    VariableReference(retValue, [])    Expression(NOT_HANDLED, [])  Statement(break, [])  Statement(}, [])  Statement(return retValue, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(boolean retValue, []), Expression(HANDLED, [])]), Statement(if (DBG), []), MethodCall(Log.d(TAG, getName() + message.toString() + ""\n""), [VariableReference(Log, []), Expression(TAG, []), Expression(getName() + message.toString() + ""\n"", [])]), Statement(case CMD_START_DHCP:, []), Statement(if (mRegisteredForPreDhcpNotification) {, []), Statement(/* Notify controller before starting DHCP */, []), MethodCall(mController.sendMessage(CMD_PRE_DHCP_ACTION), [VariableReference(mController, []), Expression(CMD_PRE_DHCP_ACTION, [])]), Statement(transitionTo(mWaitBeforeStartState), []), Statement(} else {, []), Statement(if (runDhcpStart()) {, []), Statement(transitionTo(mRunningState), []), Statement(}, []), Statement(}, []), Statement(break, []), Statement(case CMD_STOP_DHCP:, []), Statement(// ignore, []), Statement(break, []), Statement(default:, []), AssignmentExpression(=, [VariableReference(retValue, []), Expression(NOT_HANDLED, [])]), Statement(break, []), Statement(}, []), Statement(return retValue, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(boolean retValue, []), Expression(HANDLED, [])])    VariableReference(boolean retValue, [])    Expression(HANDLED, [])  Statement(if (DBG), [])  MethodCall(Log.d(TAG, getName() + message.toString() + ""\n""), [VariableReference(Log, []), Expression(TAG, []), Expression(getName() + message.toString() + ""\n"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(getName() + message.toString() + ""\n"", [])  Statement(case CMD_START_DHCP:, [])  Statement(if (mRegisteredForPreDhcpNotification) {, [])  Statement(/* Notify controller before starting DHCP */, [])  MethodCall(mController.sendMessage(CMD_PRE_DHCP_ACTION), [VariableReference(mController, []), Expression(CMD_PRE_DHCP_ACTION, [])])    VariableReference(mController, [])    Expression(CMD_PRE_DHCP_ACTION, [])  Statement(transitionTo(mWaitBeforeStartState), [])  Statement(} else {, [])  Statement(if (runDhcpStart()) {, [])  Statement(transitionTo(mRunningState), [])  Statement(}, [])  Statement(}, [])  Statement(break, [])  Statement(case CMD_STOP_DHCP:, [])  Statement(// ignore, [])  Statement(break, [])  Statement(default:, [])  AssignmentExpression(=, [VariableReference(retValue, []), Expression(NOT_HANDLED, [])])    VariableReference(retValue, [])    Expression(NOT_HANDLED, [])  Statement(break, [])  Statement(}, [])  Statement(return retValue, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,,2,"3,5",1,3,1,"In the late version, an additional 'if' statement is introduced in the 'case CMD\_START\_DHCP:' block. The new 'if' statement checks the result of 'runDhcpStart()' before transitioning to 'mRunningState'.","The introduction of the new 'if' statement could potentially lead to a different behavior when 'CMD\_START\_DHCP' is processed. If 'runDhcpStart()' returns 'false' in the late version, the state machine will not transition to 'mRunningState', while in the early version, the state machine will always transition to 'mRunningState' when 'mRegisteredForPreDhcpNotification' is 'false'. This could cause a Compatibility Issue (CI) of type 1, as the API potentially returns different values."
103,<android.widget.ProgressBar: void setProgressDrawable(Drawable)>,23,24,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mProgressDrawable !, []), Expression(d) {, [])]), AssignmentExpression(=, [VariableReference(if (mProgressDrawable !, []), Expression(null) {, [])]), MethodCall(mProgressDrawable.setCallback(null), [VariableReference(mProgressDrawable, []), Expression(null, [])]), Statement(unscheduleDrawable(mProgressDrawable), []), Statement(}, []), AssignmentExpression(=, [VariableReference(mProgressDrawable, []), Expression(d, [])]), AssignmentExpression(=, [VariableReference(if (d !, []), Expression(null) {, [])]), MethodCall(d.setCallback(this), [VariableReference(d, []), Expression(this, [])]), MethodCall(d.setLayoutDirection(getLayoutDirection()), [VariableReference(d, []), Expression(getLayoutDirection(), [])]), MethodCall(if (d.isStateful()), [VariableReference(if (d, []), Expression(), [])]), MethodCall(d.setState(getDrawableState()), [VariableReference(d, []), Expression(getDrawableState(), [])]), Statement(}, []), Statement(// Make sure the ProgressBar is always tall enough, []), AssignmentExpression(=, [VariableReference(int drawableHeight, []), Expression(d.getMinimumHeight(), [])]), Statement(if (mMaxHeight < drawableHeight) {, []), AssignmentExpression(=, [VariableReference(mMaxHeight, []), Expression(drawableHeight, [])]), Statement(requestLayout(), []), Statement(}, []), Statement(applyProgressTints(), []), Statement(}, []), Statement(if (!mIndeterminate) {, []), AssignmentExpression(=, [VariableReference(mCurrentDrawable, []), Expression(d, [])]), Statement(postInvalidate(), []), Statement(}, []), Statement(updateDrawableBounds(getWidth(), getHeight()), []), Statement(updateDrawableState(), []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mProgressDrawable !, []), Expression(d) {, [])])    VariableReference(if (mProgressDrawable !, [])    Expression(d) {, [])  AssignmentExpression(=, [VariableReference(if (mProgressDrawable !, []), Expression(null) {, [])])    VariableReference(if (mProgressDrawable !, [])    Expression(null) {, [])  MethodCall(mProgressDrawable.setCallback(null), [VariableReference(mProgressDrawable, []), Expression(null, [])])    VariableReference(mProgressDrawable, [])    Expression(null, [])  Statement(unscheduleDrawable(mProgressDrawable), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mProgressDrawable, []), Expression(d, [])])    VariableReference(mProgressDrawable, [])    Expression(d, [])  AssignmentExpression(=, [VariableReference(if (d !, []), Expression(null) {, [])])    VariableReference(if (d !, [])    Expression(null) {, [])  MethodCall(d.setCallback(this), [VariableReference(d, []), Expression(this, [])])    VariableReference(d, [])    Expression(this, [])  MethodCall(d.setLayoutDirection(getLayoutDirection()), [VariableReference(d, []), Expression(getLayoutDirection(), [])])    VariableReference(d, [])    Expression(getLayoutDirection(), [])  MethodCall(if (d.isStateful()), [VariableReference(if (d, []), Expression(), [])])    VariableReference(if (d, [])    Expression(), [])  MethodCall(d.setState(getDrawableState()), [VariableReference(d, []), Expression(getDrawableState(), [])])    VariableReference(d, [])    Expression(getDrawableState(), [])  Statement(}, [])  Statement(// Make sure the ProgressBar is always tall enough, [])  AssignmentExpression(=, [VariableReference(int drawableHeight, []), Expression(d.getMinimumHeight(), [])])    VariableReference(int drawableHeight, [])    Expression(d.getMinimumHeight(), [])  Statement(if (mMaxHeight < drawableHeight) {, [])  AssignmentExpression(=, [VariableReference(mMaxHeight, []), Expression(drawableHeight, [])])    VariableReference(mMaxHeight, [])    Expression(drawableHeight, [])  Statement(requestLayout(), [])  Statement(}, [])  Statement(applyProgressTints(), [])  Statement(}, [])  Statement(if (!mIndeterminate) {, [])  AssignmentExpression(=, [VariableReference(mCurrentDrawable, []), Expression(d, [])])    VariableReference(mCurrentDrawable, [])    Expression(d, [])  Statement(postInvalidate(), [])  Statement(}, [])  Statement(updateDrawableBounds(getWidth(), getHeight()), [])  Statement(updateDrawableState(), [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mProgressDrawable !, []), Expression(d) {, [])]), AssignmentExpression(=, [VariableReference(if (mProgressDrawable !, []), Expression(null) {, [])]), MethodCall(mProgressDrawable.setCallback(null), [VariableReference(mProgressDrawable, []), Expression(null, [])]), Statement(unscheduleDrawable(mProgressDrawable), []), Statement(}, []), AssignmentExpression(=, [VariableReference(mProgressDrawable, []), Expression(d, [])]), AssignmentExpression(=, [VariableReference(if (d !, []), Expression(null) {, [])]), MethodCall(d.setCallback(this), [VariableReference(d, []), Expression(this, [])]), MethodCall(d.setLayoutDirection(getLayoutDirection()), [VariableReference(d, []), Expression(getLayoutDirection(), [])]), MethodCall(if (d.isStateful()), [VariableReference(if (d, []), Expression(), [])]), MethodCall(d.setState(getDrawableState()), [VariableReference(d, []), Expression(getDrawableState(), [])]), Statement(}, []), Statement(// Make sure the ProgressBar is always tall enough, []), AssignmentExpression(=, [VariableReference(int drawableHeight, []), Expression(d.getMinimumHeight(), [])]), Statement(if (mMaxHeight < drawableHeight) {, []), AssignmentExpression(=, [VariableReference(mMaxHeight, []), Expression(drawableHeight, [])]), Statement(requestLayout(), []), Statement(}, []), Statement(applyProgressTints(), []), Statement(}, []), Statement(if (!mIndeterminate) {, []), Statement(swapCurrentDrawable(d), []), Statement(postInvalidate(), []), Statement(}, []), Statement(updateDrawableBounds(getWidth(), getHeight()), []), Statement(updateDrawableState(), []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mProgressDrawable !, []), Expression(d) {, [])])    VariableReference(if (mProgressDrawable !, [])    Expression(d) {, [])  AssignmentExpression(=, [VariableReference(if (mProgressDrawable !, []), Expression(null) {, [])])    VariableReference(if (mProgressDrawable !, [])    Expression(null) {, [])  MethodCall(mProgressDrawable.setCallback(null), [VariableReference(mProgressDrawable, []), Expression(null, [])])    VariableReference(mProgressDrawable, [])    Expression(null, [])  Statement(unscheduleDrawable(mProgressDrawable), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mProgressDrawable, []), Expression(d, [])])    VariableReference(mProgressDrawable, [])    Expression(d, [])  AssignmentExpression(=, [VariableReference(if (d !, []), Expression(null) {, [])])    VariableReference(if (d !, [])    Expression(null) {, [])  MethodCall(d.setCallback(this), [VariableReference(d, []), Expression(this, [])])    VariableReference(d, [])    Expression(this, [])  MethodCall(d.setLayoutDirection(getLayoutDirection()), [VariableReference(d, []), Expression(getLayoutDirection(), [])])    VariableReference(d, [])    Expression(getLayoutDirection(), [])  MethodCall(if (d.isStateful()), [VariableReference(if (d, []), Expression(), [])])    VariableReference(if (d, [])    Expression(), [])  MethodCall(d.setState(getDrawableState()), [VariableReference(d, []), Expression(getDrawableState(), [])])    VariableReference(d, [])    Expression(getDrawableState(), [])  Statement(}, [])  Statement(// Make sure the ProgressBar is always tall enough, [])  AssignmentExpression(=, [VariableReference(int drawableHeight, []), Expression(d.getMinimumHeight(), [])])    VariableReference(int drawableHeight, [])    Expression(d.getMinimumHeight(), [])  Statement(if (mMaxHeight < drawableHeight) {, [])  AssignmentExpression(=, [VariableReference(mMaxHeight, []), Expression(drawableHeight, [])])    VariableReference(mMaxHeight, [])    Expression(drawableHeight, [])  Statement(requestLayout(), [])  Statement(}, [])  Statement(applyProgressTints(), [])  Statement(}, [])  Statement(if (!mIndeterminate) {, [])  Statement(swapCurrentDrawable(d), [])  Statement(postInvalidate(), [])  Statement(}, [])  Statement(updateDrawableBounds(getWidth(), getHeight()), [])  Statement(updateDrawableState(), [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Define the drawable used to draw the progress bar in progress mode.
 *
 * @param d the new drawable
 * @see #getProgressDrawable()
 * @see #setIndeterminate(boolean)
 */
","/**
 * Define the drawable used to draw the progress bar in progress mode.
 *
 * @param d the new drawable
 * @see #getProgressDrawable()
 * @see #setIndeterminate(boolean)
 */
",0,,,0,,,,"1,2","4,5",1,1,1,The only difference between two implementations is that `mCurrentDrawable = d;` in the early version is replaced by `swapCurrentDrawable(d);` in the late version.,"The change of `mCurrentDrawable = d;` to `swapCurrentDrawable(d);` may cause different behaviors in the API. In the early version, the `mCurrentDrawable` is directly assigned to the new drawable `d`, while in the late version, the `swapCurrentDrawable` method is called to update the drawable. Therefore, it's possible that the `swapCurrentDrawable` method in the late version may have additional logic or side-effects that can lead to compatibility issues."
104,"<android.view.inputmethod.InputConnectionWrapper: boolean setComposingText(CharSequence,int)>",23,24,,,,"MethodDeclaration(method_body, [Statement({, []), MethodCall(return mTarget.setComposingText(text, newCursorPosition), [VariableReference(return mTarget, []), Expression(text, []), Expression(newCursorPosition, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return mTarget.setComposingText(text, newCursorPosition), [VariableReference(return mTarget, []), Expression(text, []), Expression(newCursorPosition, [])])    VariableReference(return mTarget, [])    Expression(text, [])    Expression(newCursorPosition, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(return mTarget.setComposingText(text, newCursorPosition), [VariableReference(return mTarget, []), Expression(text, []), Expression(newCursorPosition, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return mTarget.setComposingText(text, newCursorPosition), [VariableReference(return mTarget, []), Expression(text, []), Expression(newCursorPosition, [])])    VariableReference(return mTarget, [])    Expression(text, [])    Expression(newCursorPosition, [])  Statement(}, [])",0,,"/**
 * {@inheritDoc}
 * @throws NullPointerException if the target is {@code null}.
 */
",1,,,0,,,,0,0,0,0,0,There is no difference between the Early_Implementation_AST_Node and Late_Implementation_AST_Node.,There is no compatibility issue as there is no change in the implementation.
105,<android.preference.PreferenceFragment: void onDestroyView()>,23,24,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(mList, []), Expression(null, [])]), MethodCall(mHandler.removeCallbacks(mRequestFocus), [VariableReference(mHandler, []), Expression(mRequestFocus, [])]), MethodCall(mHandler.removeMessages(MSG_BIND_PREFERENCES), [VariableReference(mHandler, []), Expression(MSG_BIND_PREFERENCES, [])]), MethodCall(super.onDestroyView(), [VariableReference(super, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(mList, []), Expression(null, [])])    VariableReference(mList, [])    Expression(null, [])  MethodCall(mHandler.removeCallbacks(mRequestFocus), [VariableReference(mHandler, []), Expression(mRequestFocus, [])])    VariableReference(mHandler, [])    Expression(mRequestFocus, [])  MethodCall(mHandler.removeMessages(MSG_BIND_PREFERENCES), [VariableReference(mHandler, []), Expression(MSG_BIND_PREFERENCES, [])])    VariableReference(mHandler, [])    Expression(MSG_BIND_PREFERENCES, [])  MethodCall(super.onDestroyView(), [VariableReference(super, []), Expression(, [])])    VariableReference(super, [])    Expression(, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mList !, []), Expression(null) {, [])]), MethodCall(mList.setOnKeyListener(null), [VariableReference(mList, []), Expression(null, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(mList, []), Expression(null, [])]), MethodCall(mHandler.removeCallbacks(mRequestFocus), [VariableReference(mHandler, []), Expression(mRequestFocus, [])]), MethodCall(mHandler.removeMessages(MSG_BIND_PREFERENCES), [VariableReference(mHandler, []), Expression(MSG_BIND_PREFERENCES, [])]), MethodCall(super.onDestroyView(), [VariableReference(super, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mList !, []), Expression(null) {, [])])    VariableReference(if (mList !, [])    Expression(null) {, [])  MethodCall(mList.setOnKeyListener(null), [VariableReference(mList, []), Expression(null, [])])    VariableReference(mList, [])    Expression(null, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mList, []), Expression(null, [])])    VariableReference(mList, [])    Expression(null, [])  MethodCall(mHandler.removeCallbacks(mRequestFocus), [VariableReference(mHandler, []), Expression(mRequestFocus, [])])    VariableReference(mHandler, [])    Expression(mRequestFocus, [])  MethodCall(mHandler.removeMessages(MSG_BIND_PREFERENCES), [VariableReference(mHandler, []), Expression(MSG_BIND_PREFERENCES, [])])    VariableReference(mHandler, [])    Expression(MSG_BIND_PREFERENCES, [])  MethodCall(super.onDestroyView(), [VariableReference(super, []), Expression(, [])])    VariableReference(super, [])    Expression(, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,,"1,2","3,4",0,"3,4",1,"The code in the early version only sets the mList to null and removes callbacks and messages from mHandler. The code in the late version, however, adds an if statement to check if mList is not null before setting it to null and removing its onKeyListener. The addition of this if statement and the removal of the onKeyListener are control dependency changes and other statement changes respectively.","The addition of the if statement before setting mList to null and removing its onKeyListener can potentially lead to different behaviors in the late version. If mList is null in the late version, the onKeyListener will not be removed, which can cause unexpected behavior if the onKeyListener is still active. Therefore, this is a compatibility issue caused by potential different return values or types (in this case, the state of the onKeyListener)."
106,"<android.app.admin.DevicePolicyManager: void setUserIcon(ComponentName,Bitmap)>",23,24,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(mService.setUserIcon(admin, icon), [VariableReference(mService, []), Expression(admin, []), Expression(icon, [])]), Statement(} catch (RemoteException re) {, []), MethodCall(Log.w(TAG, ""Could not set the user icon "", re), [VariableReference(Log, []), Expression(TAG, []), Expression(""Could not set the user icon "", []), Expression(re, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(mService.setUserIcon(admin, icon), [VariableReference(mService, []), Expression(admin, []), Expression(icon, [])])    VariableReference(mService, [])    Expression(admin, [])    Expression(icon, [])  Statement(} catch (RemoteException re) {, [])  MethodCall(Log.w(TAG, ""Could not set the user icon "", re), [VariableReference(Log, []), Expression(TAG, []), Expression(""Could not set the user icon "", []), Expression(re, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Could not set the user icon "", [])    Expression(re, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(throwIfParentInstance(""setUserIcon""), []), Statement(try {, []), MethodCall(mService.setUserIcon(admin, icon), [VariableReference(mService, []), Expression(admin, []), Expression(icon, [])]), Statement(} catch (RemoteException re) {, []), MethodCall(throw re.rethrowFromSystemServer(), [VariableReference(throw re, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(throwIfParentInstance(""setUserIcon""), [])  Statement(try {, [])  MethodCall(mService.setUserIcon(admin, icon), [VariableReference(mService, []), Expression(admin, []), Expression(icon, [])])    VariableReference(mService, [])    Expression(admin, [])    Expression(icon, [])  Statement(} catch (RemoteException re) {, [])  MethodCall(throw re.rethrowFromSystemServer(), [VariableReference(throw re, []), Expression(, [])])    VariableReference(throw re, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Called by profile or device owners to set the current user's photo.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param icon the bitmap to set as the photo.
 */
","/**
 * Called by profile or device owners to set the user's photo.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param icon the bitmap to set as the photo.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 */
",1,,,0,,,,"1,2","2,4",2,"2,5",2,"The code change between the two versions of the API `setUserIcon(ComponentName, Bitmap)` involves the addition of a new statement `throwIfParentInstance(""setUserIcon"")` and the change in the exception handling statement. In the early version, the exception `RemoteException` is caught and logged using the `Log.w` method. In the late version, the exception is caught and rethrown using the `rethrowFromSystemServer` method. Additionally, a new `SecurityException` is introduced in the late version.","The change in the exception handling statement can potentially lead to a compatibility issue. In the early version, the exception is caught and logged, and the method execution continues. In the late version, the exception is caught and rethrown, which can potentially cause the method to terminate abruptly and lead to unexpected behavior in the client code. Therefore, the compatibility issue type is 2. Additionally, the new `SecurityException` introduced in the late version can also lead to unexpected behavior in the client code if it is not handled properly."
107,<android.bluetooth.BluetoothGatt: boolean readCharacteristic(BluetoothGattCharacteristic)>,23,24,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if ((characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_READ), []), Expression(, [])]), Statement(return false, []), Statement(if (VDBG), []), MethodCall(Log.d(TAG, ""readCharacteristic() - uuid: "" + characteristic.getUuid()), [VariableReference(Log, []), Expression(TAG, []), Expression(""readCharacteristic() - uuid: "" + characteristic.getUuid(), [])]), AssignmentExpression(=, [VariableReference(if (mService, []), Expression(, [])]), Statement(return false, []), AssignmentExpression(=, [VariableReference(BluetoothGattService service, []), Expression(characteristic.getService(), [])]), AssignmentExpression(=, [VariableReference(if (service, []), Expression(, [])]), Statement(return false, []), AssignmentExpression(=, [VariableReference(BluetoothDevice device, []), Expression(service.getDevice(), [])]), AssignmentExpression(=, [VariableReference(if (device, []), Expression(, [])]), Statement(return false, []), Statement(synchronized (mDeviceBusy) {, []), Statement(if (mDeviceBusy), []), Statement(return false, []), AssignmentExpression(=, [VariableReference(mDeviceBusy, []), Expression(true, [])]), Statement(}, []), Statement(try {, []), MethodCall(mService.readCharacteristic(mClientIf, device.getAddress(), service.getType(), service.getInstanceId(), new ParcelUuid(service.getUuid()), characteristic.getInstanceId(), new ParcelUuid(characteristic.getUuid()), AUTHENTICATION_NONE), [VariableReference(mService, []), Expression(mClientIf, []), Expression(device.getAddress(), []), Expression(service.getType(), []), Expression(service.getInstanceId(), []), Expression(new ParcelUuid(service.getUuid()), []), Expression(characteristic.getInstanceId(), []), Expression(new ParcelUuid(characteristic.getUuid()), []), Expression(AUTHENTICATION_NONE, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(Log.e(TAG, """", e), [VariableReference(Log, []), Expression(TAG, []), Expression("""", []), Expression(e, [])]), AssignmentExpression(=, [VariableReference(mDeviceBusy, []), Expression(false, [])]), Statement(return false, []), Statement(}, []), Statement(return true, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if ((characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_READ), []), Expression(, [])])    VariableReference(if ((characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_READ), [])    Expression(, [])  Statement(return false, [])  Statement(if (VDBG), [])  MethodCall(Log.d(TAG, ""readCharacteristic() - uuid: "" + characteristic.getUuid()), [VariableReference(Log, []), Expression(TAG, []), Expression(""readCharacteristic() - uuid: "" + characteristic.getUuid(), [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""readCharacteristic() - uuid: "" + characteristic.getUuid(), [])  AssignmentExpression(=, [VariableReference(if (mService, []), Expression(, [])])    VariableReference(if (mService, [])    Expression(, [])  Statement(return false, [])  AssignmentExpression(=, [VariableReference(BluetoothGattService service, []), Expression(characteristic.getService(), [])])    VariableReference(BluetoothGattService service, [])    Expression(characteristic.getService(), [])  AssignmentExpression(=, [VariableReference(if (service, []), Expression(, [])])    VariableReference(if (service, [])    Expression(, [])  Statement(return false, [])  AssignmentExpression(=, [VariableReference(BluetoothDevice device, []), Expression(service.getDevice(), [])])    VariableReference(BluetoothDevice device, [])    Expression(service.getDevice(), [])  AssignmentExpression(=, [VariableReference(if (device, []), Expression(, [])])    VariableReference(if (device, [])    Expression(, [])  Statement(return false, [])  Statement(synchronized (mDeviceBusy) {, [])  Statement(if (mDeviceBusy), [])  Statement(return false, [])  AssignmentExpression(=, [VariableReference(mDeviceBusy, []), Expression(true, [])])    VariableReference(mDeviceBusy, [])    Expression(true, [])  Statement(}, [])  Statement(try {, [])  MethodCall(mService.readCharacteristic(mClientIf, device.getAddress(), service.getType(), service.getInstanceId(), new ParcelUuid(service.getUuid()), characteristic.getInstanceId(), new ParcelUuid(characteristic.getUuid()), AUTHENTICATION_NONE), [VariableReference(mService, []), Expression(mClientIf, []), Expression(device.getAddress(), []), Expression(service.getType(), []), Expression(service.getInstanceId(), []), Expression(new ParcelUuid(service.getUuid()), []), Expression(characteristic.getInstanceId(), []), Expression(new ParcelUuid(characteristic.getUuid()), []), Expression(AUTHENTICATION_NONE, [])])    VariableReference(mService, [])    Expression(mClientIf, [])    Expression(device.getAddress(), [])    Expression(service.getType(), [])    Expression(service.getInstanceId(), [])    Expression(new ParcelUuid(service.getUuid()), [])    Expression(characteristic.getInstanceId(), [])    Expression(new ParcelUuid(characteristic.getUuid()), [])    Expression(AUTHENTICATION_NONE, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(Log.e(TAG, """", e), [VariableReference(Log, []), Expression(TAG, []), Expression("""", []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression("""", [])    Expression(e, [])  AssignmentExpression(=, [VariableReference(mDeviceBusy, []), Expression(false, [])])    VariableReference(mDeviceBusy, [])    Expression(false, [])  Statement(return false, [])  Statement(}, [])  Statement(return true, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if ((characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_READ), []), Expression(, [])]), Statement(return false, []), Statement(if (VDBG), []), MethodCall(Log.d(TAG, ""readCharacteristic() - uuid: "" + characteristic.getUuid()), [VariableReference(Log, []), Expression(TAG, []), Expression(""readCharacteristic() - uuid: "" + characteristic.getUuid(), [])]), AssignmentExpression(=, [VariableReference(if (mService, []), Expression(, [])]), Statement(return false, []), AssignmentExpression(=, [VariableReference(BluetoothGattService service, []), Expression(characteristic.getService(), [])]), AssignmentExpression(=, [VariableReference(if (service, []), Expression(, [])]), Statement(return false, []), AssignmentExpression(=, [VariableReference(BluetoothDevice device, []), Expression(service.getDevice(), [])]), AssignmentExpression(=, [VariableReference(if (device, []), Expression(, [])]), Statement(return false, []), Statement(synchronized (mDeviceBusy) {, []), Statement(if (mDeviceBusy), []), Statement(return false, []), AssignmentExpression(=, [VariableReference(mDeviceBusy, []), Expression(true, [])]), Statement(}, []), Statement(try {, []), MethodCall(mService.readCharacteristic(mClientIf, device.getAddress(), characteristic.getInstanceId(), AUTHENTICATION_NONE), [VariableReference(mService, []), Expression(mClientIf, []), Expression(device.getAddress(), []), Expression(characteristic.getInstanceId(), []), Expression(AUTHENTICATION_NONE, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(Log.e(TAG, """", e), [VariableReference(Log, []), Expression(TAG, []), Expression("""", []), Expression(e, [])]), AssignmentExpression(=, [VariableReference(mDeviceBusy, []), Expression(false, [])]), Statement(return false, []), Statement(}, []), Statement(return true, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if ((characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_READ), []), Expression(, [])])    VariableReference(if ((characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_READ), [])    Expression(, [])  Statement(return false, [])  Statement(if (VDBG), [])  MethodCall(Log.d(TAG, ""readCharacteristic() - uuid: "" + characteristic.getUuid()), [VariableReference(Log, []), Expression(TAG, []), Expression(""readCharacteristic() - uuid: "" + characteristic.getUuid(), [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""readCharacteristic() - uuid: "" + characteristic.getUuid(), [])  AssignmentExpression(=, [VariableReference(if (mService, []), Expression(, [])])    VariableReference(if (mService, [])    Expression(, [])  Statement(return false, [])  AssignmentExpression(=, [VariableReference(BluetoothGattService service, []), Expression(characteristic.getService(), [])])    VariableReference(BluetoothGattService service, [])    Expression(characteristic.getService(), [])  AssignmentExpression(=, [VariableReference(if (service, []), Expression(, [])])    VariableReference(if (service, [])    Expression(, [])  Statement(return false, [])  AssignmentExpression(=, [VariableReference(BluetoothDevice device, []), Expression(service.getDevice(), [])])    VariableReference(BluetoothDevice device, [])    Expression(service.getDevice(), [])  AssignmentExpression(=, [VariableReference(if (device, []), Expression(, [])])    VariableReference(if (device, [])    Expression(, [])  Statement(return false, [])  Statement(synchronized (mDeviceBusy) {, [])  Statement(if (mDeviceBusy), [])  Statement(return false, [])  AssignmentExpression(=, [VariableReference(mDeviceBusy, []), Expression(true, [])])    VariableReference(mDeviceBusy, [])    Expression(true, [])  Statement(}, [])  Statement(try {, [])  MethodCall(mService.readCharacteristic(mClientIf, device.getAddress(), characteristic.getInstanceId(), AUTHENTICATION_NONE), [VariableReference(mService, []), Expression(mClientIf, []), Expression(device.getAddress(), []), Expression(characteristic.getInstanceId(), []), Expression(AUTHENTICATION_NONE, [])])    VariableReference(mService, [])    Expression(mClientIf, [])    Expression(device.getAddress(), [])    Expression(characteristic.getInstanceId(), [])    Expression(AUTHENTICATION_NONE, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(Log.e(TAG, """", e), [VariableReference(Log, []), Expression(TAG, []), Expression("""", []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression("""", [])    Expression(e, [])  AssignmentExpression(=, [VariableReference(mDeviceBusy, []), Expression(false, [])])    VariableReference(mDeviceBusy, [])    Expression(false, [])  Statement(return false, [])  Statement(}, [])  Statement(return true, [])  Statement(}, [])",1,"/**
 * Reads the requested characteristic from the associated remote device.
 *
 * <p>This is an asynchronous operation. The result of the read operation
 * is reported by the {@link BluetoothGattCallback#onCharacteristicRead}
 * callback.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param characteristic Characteristic to read from the remote device
 * @return true, if the read operation was initiated successfully
 */
","/**
 * Reads the requested characteristic from the associated remote device.
 *
 * <p>This is an asynchronous operation. The result of the read operation
 * is reported by the {@link BluetoothGattCallback#onCharacteristicRead}
 * callback.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param characteristic Characteristic to read from the remote device
 * @return true, if the read operation was initiated successfully
 */
",0,,,0,,,,2,5,1,5,"1,2",The method call in the try block has changed. The late version has fewer parameters than the early version. The change type is 5 (Dependent API changed).,"The change in the method call can potentially lead to different behaviors. If the late version API requires fewer parameters, it may not function as expected, leading to a Compatibility Issue. The CI type is 1 (Compatibility Issue caused by potential different return values or types) and 2 (Compatibility Issue caused by potential different exception handlings)."
108,<android.widget.TextView: void drawableStateChanged()>,23,24,,,,"MethodDeclaration(method_body, [Statement({, []), MethodCall(super.drawableStateChanged(), [VariableReference(super, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(if (mTextColor !, []), Expression(null && mTextColor.isStateful() || (mHintTextColor !, [])]), Statement(updateTextColors(), []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mDrawables !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(final int[] state, []), Expression(getDrawableState(), [])]), AssignmentExpression(=, [VariableReference(if (dr !, []), Expression(null && dr.isStateful()) {, [])]), MethodCall(dr.setState(state), [VariableReference(dr, []), Expression(state, [])]), Statement(}, []), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  MethodCall(super.drawableStateChanged(), [VariableReference(super, []), Expression(, [])])    VariableReference(super, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(if (mTextColor !, []), Expression(null && mTextColor.isStateful() || (mHintTextColor !, [])])    VariableReference(if (mTextColor !, [])    Expression(null && mTextColor.isStateful() || (mHintTextColor !, [])  Statement(updateTextColors(), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mDrawables !, []), Expression(null) {, [])])    VariableReference(if (mDrawables !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(final int[] state, []), Expression(getDrawableState(), [])])    VariableReference(final int[] state, [])    Expression(getDrawableState(), [])  AssignmentExpression(=, [VariableReference(if (dr !, []), Expression(null && dr.isStateful()) {, [])])    VariableReference(if (dr !, [])    Expression(null && dr.isStateful()) {, [])  MethodCall(dr.setState(state), [VariableReference(dr, []), Expression(state, [])])    VariableReference(dr, [])    Expression(state, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(super.drawableStateChanged(), [VariableReference(super, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(if (mTextColor !, []), Expression(null && mTextColor.isStateful() || (mHintTextColor !, [])]), Statement(updateTextColors(), []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mDrawables !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(final int[] state, []), Expression(getDrawableState(), [])]), AssignmentExpression(=, [VariableReference(if (dr !, []), Expression(null && dr.isStateful() && dr.setState(state)) {, [])]), Statement(invalidateDrawable(dr), []), Statement(}, []), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  MethodCall(super.drawableStateChanged(), [VariableReference(super, []), Expression(, [])])    VariableReference(super, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(if (mTextColor !, []), Expression(null && mTextColor.isStateful() || (mHintTextColor !, [])])    VariableReference(if (mTextColor !, [])    Expression(null && mTextColor.isStateful() || (mHintTextColor !, [])  Statement(updateTextColors(), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mDrawables !, []), Expression(null) {, [])])    VariableReference(if (mDrawables !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(final int[] state, []), Expression(getDrawableState(), [])])    VariableReference(final int[] state, [])    Expression(getDrawableState(), [])  AssignmentExpression(=, [VariableReference(if (dr !, []), Expression(null && dr.isStateful() && dr.setState(state)) {, [])])    VariableReference(if (dr !, [])    Expression(null && dr.isStateful() && dr.setState(state)) {, [])  Statement(invalidateDrawable(dr), [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,,"1,2","3,4,5",1,4,1,The code change between two versions is the addition of a new statement "dr.setState(state)" in the condition "null && dr.isStateful()" and the addition of a new statement "invalidateDrawable(dr)" after the condition. These changes have modified the control flow of the method.,"The compatibility issue arises due to the potential of the API to return different values in the two versions. The new statement ""dr.setState(state)"" can modify the state of the drawable ""dr"", which in turn can affect the value returned by the method. The new statement ""invalidateDrawable(dr)"" can also trigger a redraw of the view, which can affect the value returned by the method. Therefore, the compatibility issue type is 1."
109,<android.widget.AbsSeekBar: void jumpDrawablesToCurrentState()>,23,24,,,,"MethodDeclaration(method_body, [Statement({, []), MethodCall(super.jumpDrawablesToCurrentState(), [VariableReference(super, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(if (mThumb !, []), Expression(null) {, [])]), MethodCall(mThumb.jumpToCurrentState(), [VariableReference(mThumb, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  MethodCall(super.jumpDrawablesToCurrentState(), [VariableReference(super, []), Expression(, [])])    VariableReference(super, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(if (mThumb !, []), Expression(null) {, [])])    VariableReference(if (mThumb !, [])    Expression(null) {, [])  MethodCall(mThumb.jumpToCurrentState(), [VariableReference(mThumb, []), Expression(, [])])    VariableReference(mThumb, [])    Expression(, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(super.jumpDrawablesToCurrentState(), [VariableReference(super, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(if (mThumb !, []), Expression(null) {, [])]), MethodCall(mThumb.jumpToCurrentState(), [VariableReference(mThumb, []), Expression(, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mTickMark !, []), Expression(null) {, [])]), MethodCall(mTickMark.jumpToCurrentState(), [VariableReference(mTickMark, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  MethodCall(super.jumpDrawablesToCurrentState(), [VariableReference(super, []), Expression(, [])])    VariableReference(super, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(if (mThumb !, []), Expression(null) {, [])])    VariableReference(if (mThumb !, [])    Expression(null) {, [])  MethodCall(mThumb.jumpToCurrentState(), [VariableReference(mThumb, []), Expression(, [])])    VariableReference(mThumb, [])    Expression(, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mTickMark !, []), Expression(null) {, [])])    VariableReference(if (mTickMark !, [])    Expression(null) {, [])  MethodCall(mTickMark.jumpToCurrentState(), [VariableReference(mTickMark, []), Expression(, [])])    VariableReference(mTickMark, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,,"1,2","1,3,4",0,5,"1,2","The change is in the method implementation, specifically in the control dependencies. The late version has an additional conditional block for the 'mTickMark' variable, which was not present in the early version.","The additional conditional block in the late version for the 'mTickMark' variable may lead to a different behavior in the API. If 'mTickMark' is not null in the late version, the 'jumpToCurrentState()' method will be called on it, which was not the case in the early version. This may cause the API to return a different value or state, leading to a compatibility issue."
110,"<android.preference.SeekBarVolumizer.Receiver: void onReceive(Context,Intent)>",23,24,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final String action, []), Expression(intent.getAction(), [])]), AssignmentExpression(=, [VariableReference(int streamType, []), Expression(intent.getIntExtra(AudioManager.EXTRA_VOLUME_STREAM_TYPE, -1), [])]), AssignmentExpression(=, [VariableReference(int streamValue, []), Expression(intent.getIntExtra(AudioManager.EXTRA_VOLUME_STREAM_VALUE, -1), [])]), AssignmentExpression(=, [VariableReference(final boolean streamMatch, []), Expression(mNotificationOrRing ? isNotificationOrRing(streamType) : (streamType, [])]), AssignmentExpression(=, [VariableReference(if (mSeekBar !, []), Expression(null && streamMatch && streamValue !, [])]), AssignmentExpression(=, [VariableReference(final boolean muted, []), Expression(mAudioManager.isStreamMute(mStreamType) || streamValue, [])]), MethodCall(mUiHandler.postUpdateSlider(streamValue, mLastAudibleStreamVolume, muted), [VariableReference(mUiHandler, []), Expression(streamValue, []), Expression(mLastAudibleStreamVolume, []), Expression(muted, [])]), Statement(}, []), Statement(if (mNotificationOrRing) {, []), AssignmentExpression(=, [VariableReference(mRingerMode, []), Expression(mAudioManager.getRingerModeInternal(), [])]), Statement(}, []), Statement(if (mAffectedByRingerMode) {, []), Statement(updateSlider(), []), Statement(}, []), AssignmentExpression(=, [VariableReference(mZenMode, []), Expression(mNotificationManager.getZenMode(), [])]), Statement(updateSlider(), []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final String action, []), Expression(intent.getAction(), [])])    VariableReference(final String action, [])    Expression(intent.getAction(), [])  AssignmentExpression(=, [VariableReference(int streamType, []), Expression(intent.getIntExtra(AudioManager.EXTRA_VOLUME_STREAM_TYPE, -1), [])])    VariableReference(int streamType, [])    Expression(intent.getIntExtra(AudioManager.EXTRA_VOLUME_STREAM_TYPE, -1), [])  AssignmentExpression(=, [VariableReference(int streamValue, []), Expression(intent.getIntExtra(AudioManager.EXTRA_VOLUME_STREAM_VALUE, -1), [])])    VariableReference(int streamValue, [])    Expression(intent.getIntExtra(AudioManager.EXTRA_VOLUME_STREAM_VALUE, -1), [])  AssignmentExpression(=, [VariableReference(final boolean streamMatch, []), Expression(mNotificationOrRing ? isNotificationOrRing(streamType) : (streamType, [])])    VariableReference(final boolean streamMatch, [])    Expression(mNotificationOrRing ? isNotificationOrRing(streamType) : (streamType, [])  AssignmentExpression(=, [VariableReference(if (mSeekBar !, []), Expression(null && streamMatch && streamValue !, [])])    VariableReference(if (mSeekBar !, [])    Expression(null && streamMatch && streamValue !, [])  AssignmentExpression(=, [VariableReference(final boolean muted, []), Expression(mAudioManager.isStreamMute(mStreamType) || streamValue, [])])    VariableReference(final boolean muted, [])    Expression(mAudioManager.isStreamMute(mStreamType) || streamValue, [])  MethodCall(mUiHandler.postUpdateSlider(streamValue, mLastAudibleStreamVolume, muted), [VariableReference(mUiHandler, []), Expression(streamValue, []), Expression(mLastAudibleStreamVolume, []), Expression(muted, [])])    VariableReference(mUiHandler, [])    Expression(streamValue, [])    Expression(mLastAudibleStreamVolume, [])    Expression(muted, [])  Statement(}, [])  Statement(if (mNotificationOrRing) {, [])  AssignmentExpression(=, [VariableReference(mRingerMode, []), Expression(mAudioManager.getRingerModeInternal(), [])])    VariableReference(mRingerMode, [])    Expression(mAudioManager.getRingerModeInternal(), [])  Statement(}, [])  Statement(if (mAffectedByRingerMode) {, [])  Statement(updateSlider(), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mZenMode, []), Expression(mNotificationManager.getZenMode(), [])])    VariableReference(mZenMode, [])    Expression(mNotificationManager.getZenMode(), [])  Statement(updateSlider(), [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final String action, []), Expression(intent.getAction(), [])]), AssignmentExpression(=, [VariableReference(int streamType, []), Expression(intent.getIntExtra(AudioManager.EXTRA_VOLUME_STREAM_TYPE, -1), [])]), AssignmentExpression(=, [VariableReference(int streamValue, []), Expression(intent.getIntExtra(AudioManager.EXTRA_VOLUME_STREAM_VALUE, -1), [])]), Statement(updateVolumeSlider(streamType, streamValue), []), Statement(if (mNotificationOrRing) {, []), AssignmentExpression(=, [VariableReference(mRingerMode, []), Expression(mAudioManager.getRingerModeInternal(), [])]), Statement(}, []), Statement(if (mAffectedByRingerMode) {, []), Statement(updateSlider(), []), Statement(}, []), AssignmentExpression(=, [VariableReference(int streamType, []), Expression(intent.getIntExtra(AudioManager.EXTRA_VOLUME_STREAM_TYPE, -1), [])]), AssignmentExpression(=, [VariableReference(int streamVolume, []), Expression(mAudioManager.getStreamVolume(streamType), [])]), Statement(updateVolumeSlider(streamType, streamVolume), []), AssignmentExpression(=, [VariableReference(mZenMode, []), Expression(mNotificationManager.getZenMode(), [])]), Statement(updateSlider(), []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final String action, []), Expression(intent.getAction(), [])])    VariableReference(final String action, [])    Expression(intent.getAction(), [])  AssignmentExpression(=, [VariableReference(int streamType, []), Expression(intent.getIntExtra(AudioManager.EXTRA_VOLUME_STREAM_TYPE, -1), [])])    VariableReference(int streamType, [])    Expression(intent.getIntExtra(AudioManager.EXTRA_VOLUME_STREAM_TYPE, -1), [])  AssignmentExpression(=, [VariableReference(int streamValue, []), Expression(intent.getIntExtra(AudioManager.EXTRA_VOLUME_STREAM_VALUE, -1), [])])    VariableReference(int streamValue, [])    Expression(intent.getIntExtra(AudioManager.EXTRA_VOLUME_STREAM_VALUE, -1), [])  Statement(updateVolumeSlider(streamType, streamValue), [])  Statement(if (mNotificationOrRing) {, [])  AssignmentExpression(=, [VariableReference(mRingerMode, []), Expression(mAudioManager.getRingerModeInternal(), [])])    VariableReference(mRingerMode, [])    Expression(mAudioManager.getRingerModeInternal(), [])  Statement(}, [])  Statement(if (mAffectedByRingerMode) {, [])  Statement(updateSlider(), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(int streamType, []), Expression(intent.getIntExtra(AudioManager.EXTRA_VOLUME_STREAM_TYPE, -1), [])])    VariableReference(int streamType, [])    Expression(intent.getIntExtra(AudioManager.EXTRA_VOLUME_STREAM_TYPE, -1), [])  AssignmentExpression(=, [VariableReference(int streamVolume, []), Expression(mAudioManager.getStreamVolume(streamType), [])])    VariableReference(int streamVolume, [])    Expression(mAudioManager.getStreamVolume(streamType), [])  Statement(updateVolumeSlider(streamType, streamVolume), [])  AssignmentExpression(=, [VariableReference(mZenMode, []), Expression(mNotificationManager.getZenMode(), [])])    VariableReference(mZenMode, [])    Expression(mNotificationManager.getZenMode(), [])  Statement(updateSlider(), [])  Statement(}, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,,"1,2","3,4",0,"1,4,5","1,2",The code changes are as follows:,3. Dependent APIs have changed: "mAudioManager.getRingerModeInternal()" in the early version is replaced with "mAudioManager.getRingerMode()" in the late version.
111,<android.widget.Editor.PinnedPopupWindow: void hide()>,23,24,,,,"MethodDeclaration(method_body, [Statement({, []), MethodCall(mPopupWindow.dismiss(), [VariableReference(mPopupWindow, []), Expression(, [])]), MethodCall(getPositionListener().removeSubscriber(this), [VariableReference(getPositionListener(), []), Expression(this, [])]), Statement(}, [])])  Statement({, [])  MethodCall(mPopupWindow.dismiss(), [VariableReference(mPopupWindow, []), Expression(, [])])    VariableReference(mPopupWindow, [])    Expression(, [])  MethodCall(getPositionListener().removeSubscriber(this), [VariableReference(getPositionListener(), []), Expression(this, [])])    VariableReference(getPositionListener(), [])    Expression(this, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (!isShowing()) {, []), Statement(return, []), Statement(}, []), MethodCall(mPopupWindow.dismiss(), [VariableReference(mPopupWindow, []), Expression(, [])]), MethodCall(getPositionListener().removeSubscriber(this), [VariableReference(getPositionListener(), []), Expression(this, [])]), Statement(}, [])])  Statement({, [])  Statement(if (!isShowing()) {, [])  Statement(return, [])  Statement(}, [])  MethodCall(mPopupWindow.dismiss(), [VariableReference(mPopupWindow, []), Expression(, [])])    VariableReference(mPopupWindow, [])    Expression(, [])  MethodCall(getPositionListener().removeSubscriber(this), [VariableReference(getPositionListener(), []), Expression(this, [])])    VariableReference(getPositionListener(), [])    Expression(this, [])  Statement(}, [])",1,,,0,,,0,,,,"1,2","1,3,4",1,3,1,An if statement has been added to the method implementation. This statement checks whether the popup window is currently showing before dismissing it and removing the subscriber.,"The addition of the if statement could potentially lead to different behavior in the late version of the API. If the popup window is not currently showing, the method will immediately return and the subscriber will not be removed. In the early version, the subscriber would always be removed regardless of the state of the popup window. This could cause compatibility issues for applications that rely on the subscriber being removed when the hide() method is called."
112,<android.content.pm.PackageInstaller: List<SessionInfo> getAllSessions()>,23,24,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final ApplicationInfo info, []), Expression(mContext.getApplicationInfo(), [])]), AssignmentExpression(=, [VariableReference(if (""com.google.android.googlequicksearchbox"".equals(info.packageName) && info.versionCode <, []), Expression(300400110) {, [])]), MethodCall(Log.d(TAG, ""Ignoring callback request from old prebuilt""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Ignoring callback request from old prebuilt"", [])]), Statement(return Collections.EMPTY_LIST, []), Statement(}, []), Statement(try {, []), MethodCall(return mInstaller.getAllSessions(mUserId).getList(), [VariableReference(return mInstaller, []), Expression(mUserId).getList(, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowAsRuntimeException(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final ApplicationInfo info, []), Expression(mContext.getApplicationInfo(), [])])    VariableReference(final ApplicationInfo info, [])    Expression(mContext.getApplicationInfo(), [])  AssignmentExpression(=, [VariableReference(if (""com.google.android.googlequicksearchbox"".equals(info.packageName) && info.versionCode <, []), Expression(300400110) {, [])])    VariableReference(if (""com.google.android.googlequicksearchbox"".equals(info.packageName) && info.versionCode <, [])    Expression(300400110) {, [])  MethodCall(Log.d(TAG, ""Ignoring callback request from old prebuilt""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Ignoring callback request from old prebuilt"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Ignoring callback request from old prebuilt"", [])  Statement(return Collections.EMPTY_LIST, [])  Statement(}, [])  Statement(try {, [])  MethodCall(return mInstaller.getAllSessions(mUserId).getList(), [VariableReference(return mInstaller, []), Expression(mUserId).getList(, [])])    VariableReference(return mInstaller, [])    Expression(mUserId).getList(, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowAsRuntimeException(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(return mInstaller.getAllSessions(mUserId).getList(), [VariableReference(return mInstaller, []), Expression(mUserId).getList(, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(return mInstaller.getAllSessions(mUserId).getList(), [VariableReference(return mInstaller, []), Expression(mUserId).getList(, [])])    VariableReference(return mInstaller, [])    Expression(mUserId).getList(, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Return list of all known install sessions, regardless of the installer.
 */
","/**
 * Return list of all known install sessions, regardless of the installer.
 */
",0,[@NonNull],[@NonNull],0,,,,"1,2","1,2,3,4,5","1,2",2,2,"The implementation of the exception handling has been changed between the two versions. In the early version, the exception is rethrown as a RuntimeException using the `rethrowAsRuntimeException()` method. In the late version, the exception is rethrown as a SystemServerException using the `rethrowFromSystemServer()` method.","The change in the exception handling implementation can cause compatibility issues as the type of the exception being thrown has been changed. This can lead to different behavior in the calling code as it may not be prepared to handle the new type of exception. For example, if the calling code only catches RuntimeExceptions, it will not catch the SystemServerException being thrown in the late version, potentially leading to an unhandled exception and application crash."
113,<android.widget.ActionMenuPresenter.OpenOverflowRunnable: void run()>,23,24,,,,"MethodDeclaration(method_body, [Statement({, []), MethodCall(mMenu.changeMenuMode(), [VariableReference(mMenu, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(final View menuView, []), Expression((View) mMenuView, [])]), AssignmentExpression(=, [VariableReference(if (menuView !, []), Expression(null && menuView.getWindowToken() !, [])]), AssignmentExpression(=, [VariableReference(mOverflowPopup, []), Expression(mPopup, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(mPostedOpenRunnable, []), Expression(null, [])]), Statement(}, [])])  Statement({, [])  MethodCall(mMenu.changeMenuMode(), [VariableReference(mMenu, []), Expression(, [])])    VariableReference(mMenu, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(final View menuView, []), Expression((View) mMenuView, [])])    VariableReference(final View menuView, [])    Expression((View) mMenuView, [])  AssignmentExpression(=, [VariableReference(if (menuView !, []), Expression(null && menuView.getWindowToken() !, [])])    VariableReference(if (menuView !, [])    Expression(null && menuView.getWindowToken() !, [])  AssignmentExpression(=, [VariableReference(mOverflowPopup, []), Expression(mPopup, [])])    VariableReference(mOverflowPopup, [])    Expression(mPopup, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mPostedOpenRunnable, []), Expression(null, [])])    VariableReference(mPostedOpenRunnable, [])    Expression(null, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mMenu !, []), Expression(null) {, [])]), MethodCall(mMenu.changeMenuMode(), [VariableReference(mMenu, []), Expression(, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(final View menuView, []), Expression((View) mMenuView, [])]), AssignmentExpression(=, [VariableReference(if (menuView !, []), Expression(null && menuView.getWindowToken() !, [])]), AssignmentExpression(=, [VariableReference(mOverflowPopup, []), Expression(mPopup, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(mPostedOpenRunnable, []), Expression(null, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mMenu !, []), Expression(null) {, [])])    VariableReference(if (mMenu !, [])    Expression(null) {, [])  MethodCall(mMenu.changeMenuMode(), [VariableReference(mMenu, []), Expression(, [])])    VariableReference(mMenu, [])    Expression(, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(final View menuView, []), Expression((View) mMenuView, [])])    VariableReference(final View menuView, [])    Expression((View) mMenuView, [])  AssignmentExpression(=, [VariableReference(if (menuView !, []), Expression(null && menuView.getWindowToken() !, [])])    VariableReference(if (menuView !, [])    Expression(null && menuView.getWindowToken() !, [])  AssignmentExpression(=, [VariableReference(mOverflowPopup, []), Expression(mPopup, [])])    VariableReference(mOverflowPopup, [])    Expression(mPopup, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mPostedOpenRunnable, []), Expression(null, [])])    VariableReference(mPostedOpenRunnable, [])    Expression(null, [])  Statement(}, [])",1,,,0,,,0,,,,1,3,1,4,0,"A new assignment statement has been introduced to check if the `mMenu` object is not null before proceeding with the method call `mMenu.changeMenuMode()`. This is an example of ""Other statement changed"" as it does not involve changes to return statements, exception handling statements, or control dependency changes.","The introduced code change does not have an impact on the potential behaviors of the API. The new assignment statement is only checking if the `mMenu` object is not null, and it does not return a different value or throw a different exception. Therefore, there is no Compatibility Issue (CI) in this case."
114,"<android.accounts.AccountManager: AccountManagerFuture<Bundle> getAuthToken(Account,String,Bundle,boolean,AccountManagerCallback<Bundle>,Handler)>",23,24,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (account, []), Expression(, [])]), Statement(throw new IllegalArgumentException(""account is null""), []), AssignmentExpression(=, [VariableReference(if (authTokenType, []), Expression(, [])]), Statement(throw new IllegalArgumentException(""authTokenType is null""), []), AssignmentExpression(=, [VariableReference(final Bundle optionsIn, []), Expression(new Bundle(), [])]), AssignmentExpression(=, [VariableReference(if (options !, []), Expression(null) {, [])]), MethodCall(optionsIn.putAll(options), [VariableReference(optionsIn, []), Expression(options, [])]), Statement(}, []), MethodCall(optionsIn.putString(KEY_ANDROID_PACKAGE_NAME, mContext.getPackageName()), [VariableReference(optionsIn, []), Expression(KEY_ANDROID_PACKAGE_NAME, []), Expression(mContext.getPackageName(), [])]), Statement(return new AmsTask(null, handler, callback) {, []), Statement(public void doWork() throws RemoteException {, []), Statement(optionsIn), []), Statement(}, []), MethodCall(}.start(), [VariableReference(}, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (account, []), Expression(, [])])    VariableReference(if (account, [])    Expression(, [])  Statement(throw new IllegalArgumentException(""account is null""), [])  AssignmentExpression(=, [VariableReference(if (authTokenType, []), Expression(, [])])    VariableReference(if (authTokenType, [])    Expression(, [])  Statement(throw new IllegalArgumentException(""authTokenType is null""), [])  AssignmentExpression(=, [VariableReference(final Bundle optionsIn, []), Expression(new Bundle(), [])])    VariableReference(final Bundle optionsIn, [])    Expression(new Bundle(), [])  AssignmentExpression(=, [VariableReference(if (options !, []), Expression(null) {, [])])    VariableReference(if (options !, [])    Expression(null) {, [])  MethodCall(optionsIn.putAll(options), [VariableReference(optionsIn, []), Expression(options, [])])    VariableReference(optionsIn, [])    Expression(options, [])  Statement(}, [])  MethodCall(optionsIn.putString(KEY_ANDROID_PACKAGE_NAME, mContext.getPackageName()), [VariableReference(optionsIn, []), Expression(KEY_ANDROID_PACKAGE_NAME, []), Expression(mContext.getPackageName(), [])])    VariableReference(optionsIn, [])    Expression(KEY_ANDROID_PACKAGE_NAME, [])    Expression(mContext.getPackageName(), [])  Statement(return new AmsTask(null, handler, callback) {, [])  Statement(public void doWork() throws RemoteException {, [])  Statement(optionsIn), [])  Statement(}, [])  MethodCall(}.start(), [VariableReference(}, []), Expression(, [])])    VariableReference(}, [])    Expression(, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (account, []), Expression(, [])]), Statement(throw new IllegalArgumentException(""account is null""), []), AssignmentExpression(=, [VariableReference(if (authTokenType, []), Expression(, [])]), Statement(throw new IllegalArgumentException(""authTokenType is null""), []), AssignmentExpression(=, [VariableReference(final Bundle optionsIn, []), Expression(new Bundle(), [])]), AssignmentExpression(=, [VariableReference(if (options !, []), Expression(null) {, [])]), MethodCall(optionsIn.putAll(options), [VariableReference(optionsIn, []), Expression(options, [])]), Statement(}, []), MethodCall(optionsIn.putString(KEY_ANDROID_PACKAGE_NAME, mContext.getPackageName()), [VariableReference(optionsIn, []), Expression(KEY_ANDROID_PACKAGE_NAME, []), Expression(mContext.getPackageName(), [])]), Statement(return new AmsTask(null, handler, callback) {, []), Statement(@Override, []), Statement(public void doWork() throws RemoteException {, []), Statement(optionsIn), []), Statement(}, []), MethodCall(}.start(), [VariableReference(}, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (account, []), Expression(, [])])    VariableReference(if (account, [])    Expression(, [])  Statement(throw new IllegalArgumentException(""account is null""), [])  AssignmentExpression(=, [VariableReference(if (authTokenType, []), Expression(, [])])    VariableReference(if (authTokenType, [])    Expression(, [])  Statement(throw new IllegalArgumentException(""authTokenType is null""), [])  AssignmentExpression(=, [VariableReference(final Bundle optionsIn, []), Expression(new Bundle(), [])])    VariableReference(final Bundle optionsIn, [])    Expression(new Bundle(), [])  AssignmentExpression(=, [VariableReference(if (options !, []), Expression(null) {, [])])    VariableReference(if (options !, [])    Expression(null) {, [])  MethodCall(optionsIn.putAll(options), [VariableReference(optionsIn, []), Expression(options, [])])    VariableReference(optionsIn, [])    Expression(options, [])  Statement(}, [])  MethodCall(optionsIn.putString(KEY_ANDROID_PACKAGE_NAME, mContext.getPackageName()), [VariableReference(optionsIn, []), Expression(KEY_ANDROID_PACKAGE_NAME, []), Expression(mContext.getPackageName(), [])])    VariableReference(optionsIn, [])    Expression(KEY_ANDROID_PACKAGE_NAME, [])    Expression(mContext.getPackageName(), [])  Statement(return new AmsTask(null, handler, callback) {, [])  Statement(@Override, [])  Statement(public void doWork() throws RemoteException {, [])  Statement(optionsIn), [])  Statement(}, [])  MethodCall(}.start(), [VariableReference(}, []), Expression(, [])])    VariableReference(}, [])    Expression(, [])  Statement(}, [])",1,"/**
 * Gets an auth token of the specified type for a particular account,
 * optionally raising a notification if the user must enter credentials.
 * This method is intended for background tasks and services where the
 * user should not be immediately interrupted with a password prompt.
 *
 * <p>If a previously generated auth token is cached for this account and
 * type, then it is returned.  Otherwise, if a saved password is
 * available, it is sent to the server to generate a new auth token.
 * Otherwise, an {@link Intent} is returned which, when started, will
 * prompt the user for a password.  If the notifyAuthFailure parameter is
 * set, a status bar notification is also created with the same Intent,
 * alerting the user that they need to enter a password at some point.
 *
 * <p>In that case, you may need to wait until the user responds, which
 * could take hours or days or forever.  When the user does respond and
 * supply a new password, the account manager will broadcast the
 * {@link #LOGIN_ACCOUNTS_CHANGED_ACTION} Intent, which applications can
 * use to try again.
 *
 * <p>If notifyAuthFailure is not set, it is the application's
 * responsibility to launch the returned Intent at some point.
 * Either way, the result from this call will not wait for user action.
 *
 * <p>Some authenticators have auth token <em>types</em>, whose value
 * is authenticator-dependent.  Some services use different token types to
 * access different functionality -- for example, Google uses different auth
 * tokens to access Gmail and Google Calendar for the same account.
 *
 * <p>This method may be called from any thread, but the returned
 * {@link AccountManagerFuture} must not be used on the main thread.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * USE_CREDENTIALS permission is needed for those platforms. See docs for
 * this function in API level 22.
 *
 * @param account The account to fetch an auth token for
 * @param authTokenType The auth token type, an authenticator-dependent
 * string token, must not be null
 * @param options Authenticator-specific options for the request,
 * may be null or empty
 * @param notifyAuthFailure True to add a notification to prompt the
 * user for a password if necessary, false to leave that to the caller
 * @param callback Callback to invoke when the request completes,
 * null for no callback
 * @param handler {@link Handler} identifying the callback thread,
 * null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Bundle with
 * at least the following fields on success:
 * <ul>
 * <li> {@link #KEY_ACCOUNT_NAME} - the name of the account you supplied
 * <li> {@link #KEY_ACCOUNT_TYPE} - the type of the account
 * <li> {@link #KEY_AUTHTOKEN} - the auth token you wanted
 * </ul>
 *
 * (Other authenticator-specific values may be returned.)  If the user
 * must enter credentials, the returned Bundle contains only
 * {@link #KEY_INTENT} with the {@link Intent} needed to launch a prompt.
 *
 * If an error occurred, {@link AccountManagerFuture#getResult()} throws:
 * <ul>
 * <li> {@link AuthenticatorException} if the authenticator failed to respond
 * <li> {@link OperationCanceledException} if the operation is canceled for
 * any reason, incluidng the user canceling a credential request
 * <li> {@link IOException} if the authenticator experienced an I/O problem
 * creating a new auth token, usually because of network trouble
 * </ul>
 * If the account is no longer present on the device, the return value is
 * authenticator-dependent.  The caller should verify the validity of the
 * account before requesting an auth token.
 */
","/**
 * Gets an auth token of the specified type for a particular account,
 * optionally raising a notification if the user must enter credentials.
 * This method is intended for background tasks and services where the
 * user should not be immediately interrupted with a password prompt.
 *
 * <p>If a previously generated auth token is cached for this account and
 * type, then it is returned.  Otherwise, if a saved password is
 * available, it is sent to the server to generate a new auth token.
 * Otherwise, an {@link Intent} is returned which, when started, will
 * prompt the user for a password.  If the notifyAuthFailure parameter is
 * set, a status bar notification is also created with the same Intent,
 * alerting the user that they need to enter a password at some point.
 *
 * <p>In that case, you may need to wait until the user responds, which
 * could take hours or days or forever.  When the user does respond and
 * supply a new password, the account manager will broadcast the
 * {@link #LOGIN_ACCOUNTS_CHANGED_ACTION} Intent, which applications can
 * use to try again.
 *
 * <p>If notifyAuthFailure is not set, it is the application's
 * responsibility to launch the returned Intent at some point.
 * Either way, the result from this call will not wait for user action.
 *
 * <p>Some authenticators have auth token <em>types</em>, whose value
 * is authenticator-dependent.  Some services use different token types to
 * access different functionality -- for example, Google uses different auth
 * tokens to access Gmail and Google Calendar for the same account.
 *
 * <p>This method may be called from any thread, but the returned
 * {@link AccountManagerFuture} must not be used on the main thread.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * USE_CREDENTIALS permission is needed for those platforms. See docs for
 * this function in API level 22.
 *
 * @param account The account to fetch an auth token for
 * @param authTokenType The auth token type, an authenticator-dependent
 * string token, must not be null
 * @param options Authenticator-specific options for the request,
 * may be null or empty
 * @param notifyAuthFailure True to add a notification to prompt the
 * user for a password if necessary, false to leave that to the caller
 * @param callback Callback to invoke when the request completes,
 * null for no callback
 * @param handler {@link Handler} identifying the callback thread,
 * null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Bundle with
 * at least the following fields on success:
 * <ul>
 * <li> {@link #KEY_ACCOUNT_NAME} - the name of the account you supplied
 * <li> {@link #KEY_ACCOUNT_TYPE} - the type of the account
 * <li> {@link #KEY_AUTHTOKEN} - the auth token you wanted
 * </ul>
 *
 * (Other authenticator-specific values may be returned.)  If the user
 * must enter credentials, the returned Bundle contains only
 * {@link #KEY_INTENT} with the {@link Intent} needed to launch a prompt.
 *
 * If an error occurred, {@link AccountManagerFuture#getResult()} throws:
 * <ul>
 * <li> {@link AuthenticatorException} if the authenticator failed to respond
 * <li> {@link OperationCanceledException} if the operation is canceled for
 * any reason, incluidng the user canceling a credential request
 * <li> {@link IOException} if the authenticator experienced an I/O problem
 * creating a new auth token, usually because of network trouble
 * </ul>
 * If the account is no longer present on the device, the return value is
 * authenticator-dependent.  The caller should verify the validity of the
 * account before requesting an auth token.
 */
",0,,,0,,,,1,4,0,0,0,"There is no actual change between the two versions of the `getAuthToken` API. The AST nodes provided are just formatted differently, but the code logic and implementation remain the same.","Since there is no change in the API's implementation, there is no potential for compatibility issues to arise. The API will behave the same way in both the early and late versions."
115,<android.net.NetworkRequest: int hashCode()>,24,25,,,,"MethodDeclaration(method_body, [Statement({, []), MethodCall(return requestId + (legacyType * 1013) + (networkCapabilities.hashCode() * 1051), [VariableReference(return requestId + (legacyType * 1013) + (networkCapabilities, []), Expression() * 1051, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return requestId + (legacyType * 1013) + (networkCapabilities.hashCode() * 1051), [VariableReference(return requestId + (legacyType * 1013) + (networkCapabilities, []), Expression() * 1051, [])])    VariableReference(return requestId + (legacyType * 1013) + (networkCapabilities, [])    Expression() * 1051, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(return Objects.hash(requestId, legacyType, networkCapabilities, type), [VariableReference(return Objects, []), Expression(requestId, []), Expression(legacyType, []), Expression(networkCapabilities, []), Expression(type, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return Objects.hash(requestId, legacyType, networkCapabilities, type), [VariableReference(return Objects, []), Expression(requestId, []), Expression(legacyType, []), Expression(networkCapabilities, []), Expression(type, [])])    VariableReference(return Objects, [])    Expression(requestId, [])    Expression(legacyType, [])    Expression(networkCapabilities, [])    Expression(type, [])  Statement(}, [])",1,,,0,,,0,,,,"1,2","1,5",1,1,1,"The implementation of the hashCode() method has been changed from `return requestId + (legacyType * 1013) + (networkCapabilities.hashCode() * 1051)` to `return Objects.hash(requestId, legacyType, networkCapabilities, type)`. This is a return statement change as the method now returns a different value, calculated in a different way.","The change in the implementation of the hashCode() method can lead to compatibility issues as it now returns a different value, calculated in a different way. This can affect the behavior of the API in different ways, for example, if the API is used in a HashMap or a HashSet, the objects may not be retrieved or may not be stored correctly."
116,<android.view.TextureView: HardwareLayer getHardwareLayer()>,24,25,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mLayer, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(if (mAttachInfo, []), Expression(, [])]), Statement(return null, []), Statement(}, []), AssignmentExpression(=, [VariableReference(mLayer, []), Expression(mAttachInfo.mHardwareRenderer.createTextureLayer(), [])]), Statement(if (!mUpdateSurface) {, []), Statement(// Create a new SurfaceTexture for the layer., []), AssignmentExpression(=, [VariableReference(mSurface, []), Expression(new SurfaceTexture(false), [])]), MethodCall(mLayer.setSurfaceTexture(mSurface), [VariableReference(mLayer, []), Expression(mSurface, [])]), Statement(}, []), MethodCall(mSurface.setDefaultBufferSize(getWidth(), getHeight()), [VariableReference(mSurface, []), Expression(getWidth(), []), Expression(getHeight(), [])]), Statement(nCreateNativeWindow(mSurface), []), MethodCall(mSurface.setOnFrameAvailableListener(mUpdateListener, mAttachInfo.mHandler), [VariableReference(mSurface, []), Expression(mUpdateListener, []), Expression(mAttachInfo.mHandler, [])]), AssignmentExpression(=, [VariableReference(if (mListener !, []), Expression(null && !mUpdateSurface) {, [])]), MethodCall(mListener.onSurfaceTextureAvailable(mSurface, getWidth(), getHeight()), [VariableReference(mListener, []), Expression(mSurface, []), Expression(getWidth(), []), Expression(getHeight(), [])]), Statement(}, []), MethodCall(mLayer.setLayerPaint(mLayerPaint), [VariableReference(mLayer, []), Expression(mLayerPaint, [])]), Statement(}, []), Statement(if (mUpdateSurface) {, []), Statement(// Someone has requested that we use a specific SurfaceTexture, so, []), Statement(// tell mLayer about it and set the SurfaceTexture to use the, []), Statement(// current view size., []), AssignmentExpression(=, [VariableReference(mUpdateSurface, []), Expression(false, [])]), Statement(// Since we are updating the layer, force an update to ensure its, []), Statement(updateLayer(), []), AssignmentExpression(=, [VariableReference(mMatrixChanged, []), Expression(true, [])]), MethodCall(mLayer.setSurfaceTexture(mSurface), [VariableReference(mLayer, []), Expression(mSurface, [])]), MethodCall(mSurface.setDefaultBufferSize(getWidth(), getHeight()), [VariableReference(mSurface, []), Expression(getWidth(), []), Expression(getHeight(), [])]), Statement(}, []), Statement(return mLayer, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mLayer, []), Expression(, [])])    VariableReference(if (mLayer, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(if (mAttachInfo, []), Expression(, [])])    VariableReference(if (mAttachInfo, [])    Expression(, [])  Statement(return null, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mLayer, []), Expression(mAttachInfo.mHardwareRenderer.createTextureLayer(), [])])    VariableReference(mLayer, [])    Expression(mAttachInfo.mHardwareRenderer.createTextureLayer(), [])  Statement(if (!mUpdateSurface) {, [])  Statement(// Create a new SurfaceTexture for the layer., [])  AssignmentExpression(=, [VariableReference(mSurface, []), Expression(new SurfaceTexture(false), [])])    VariableReference(mSurface, [])    Expression(new SurfaceTexture(false), [])  MethodCall(mLayer.setSurfaceTexture(mSurface), [VariableReference(mLayer, []), Expression(mSurface, [])])    VariableReference(mLayer, [])    Expression(mSurface, [])  Statement(}, [])  MethodCall(mSurface.setDefaultBufferSize(getWidth(), getHeight()), [VariableReference(mSurface, []), Expression(getWidth(), []), Expression(getHeight(), [])])    VariableReference(mSurface, [])    Expression(getWidth(), [])    Expression(getHeight(), [])  Statement(nCreateNativeWindow(mSurface), [])  MethodCall(mSurface.setOnFrameAvailableListener(mUpdateListener, mAttachInfo.mHandler), [VariableReference(mSurface, []), Expression(mUpdateListener, []), Expression(mAttachInfo.mHandler, [])])    VariableReference(mSurface, [])    Expression(mUpdateListener, [])    Expression(mAttachInfo.mHandler, [])  AssignmentExpression(=, [VariableReference(if (mListener !, []), Expression(null && !mUpdateSurface) {, [])])    VariableReference(if (mListener !, [])    Expression(null && !mUpdateSurface) {, [])  MethodCall(mListener.onSurfaceTextureAvailable(mSurface, getWidth(), getHeight()), [VariableReference(mListener, []), Expression(mSurface, []), Expression(getWidth(), []), Expression(getHeight(), [])])    VariableReference(mListener, [])    Expression(mSurface, [])    Expression(getWidth(), [])    Expression(getHeight(), [])  Statement(}, [])  MethodCall(mLayer.setLayerPaint(mLayerPaint), [VariableReference(mLayer, []), Expression(mLayerPaint, [])])    VariableReference(mLayer, [])    Expression(mLayerPaint, [])  Statement(}, [])  Statement(if (mUpdateSurface) {, [])  Statement(// Someone has requested that we use a specific SurfaceTexture, so, [])  Statement(// tell mLayer about it and set the SurfaceTexture to use the, [])  Statement(// current view size., [])  AssignmentExpression(=, [VariableReference(mUpdateSurface, []), Expression(false, [])])    VariableReference(mUpdateSurface, [])    Expression(false, [])  Statement(// Since we are updating the layer, force an update to ensure its, [])  Statement(updateLayer(), [])  AssignmentExpression(=, [VariableReference(mMatrixChanged, []), Expression(true, [])])    VariableReference(mMatrixChanged, [])    Expression(true, [])  MethodCall(mLayer.setSurfaceTexture(mSurface), [VariableReference(mLayer, []), Expression(mSurface, [])])    VariableReference(mLayer, [])    Expression(mSurface, [])  MethodCall(mSurface.setDefaultBufferSize(getWidth(), getHeight()), [VariableReference(mSurface, []), Expression(getWidth(), []), Expression(getHeight(), [])])    VariableReference(mSurface, [])    Expression(getWidth(), [])    Expression(getHeight(), [])  Statement(}, [])  Statement(return mLayer, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mLayer, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(if (mAttachInfo, []), Expression(, [])]), Statement(return null, []), Statement(}, []), AssignmentExpression(=, [VariableReference(mLayer, []), Expression(mAttachInfo.mHardwareRenderer.createTextureLayer(), [])]), AssignmentExpression(=, [VariableReference(boolean createNewSurface, []), Expression((mSurface, [])]), Statement(if (createNewSurface) {, []), Statement(// Create a new SurfaceTexture for the layer., []), AssignmentExpression(=, [VariableReference(mSurface, []), Expression(new SurfaceTexture(false), [])]), Statement(nCreateNativeWindow(mSurface), []), Statement(}, []), MethodCall(mLayer.setSurfaceTexture(mSurface), [VariableReference(mLayer, []), Expression(mSurface, [])]), MethodCall(mSurface.setDefaultBufferSize(getWidth(), getHeight()), [VariableReference(mSurface, []), Expression(getWidth(), []), Expression(getHeight(), [])]), MethodCall(mSurface.setOnFrameAvailableListener(mUpdateListener, mAttachInfo.mHandler), [VariableReference(mSurface, []), Expression(mUpdateListener, []), Expression(mAttachInfo.mHandler, [])]), AssignmentExpression(=, [VariableReference(if (mListener !, []), Expression(null && createNewSurface) {, [])]), MethodCall(mListener.onSurfaceTextureAvailable(mSurface, getWidth(), getHeight()), [VariableReference(mListener, []), Expression(mSurface, []), Expression(getWidth(), []), Expression(getHeight(), [])]), Statement(}, []), MethodCall(mLayer.setLayerPaint(mLayerPaint), [VariableReference(mLayer, []), Expression(mLayerPaint, [])]), Statement(}, []), Statement(if (mUpdateSurface) {, []), Statement(// Someone has requested that we use a specific SurfaceTexture, so, []), Statement(// tell mLayer about it and set the SurfaceTexture to use the, []), Statement(// current view size., []), AssignmentExpression(=, [VariableReference(mUpdateSurface, []), Expression(false, [])]), Statement(// Since we are updating the layer, force an update to ensure its, []), Statement(updateLayer(), []), AssignmentExpression(=, [VariableReference(mMatrixChanged, []), Expression(true, [])]), MethodCall(mLayer.setSurfaceTexture(mSurface), [VariableReference(mLayer, []), Expression(mSurface, [])]), MethodCall(mSurface.setDefaultBufferSize(getWidth(), getHeight()), [VariableReference(mSurface, []), Expression(getWidth(), []), Expression(getHeight(), [])]), Statement(}, []), Statement(return mLayer, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mLayer, []), Expression(, [])])    VariableReference(if (mLayer, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(if (mAttachInfo, []), Expression(, [])])    VariableReference(if (mAttachInfo, [])    Expression(, [])  Statement(return null, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mLayer, []), Expression(mAttachInfo.mHardwareRenderer.createTextureLayer(), [])])    VariableReference(mLayer, [])    Expression(mAttachInfo.mHardwareRenderer.createTextureLayer(), [])  AssignmentExpression(=, [VariableReference(boolean createNewSurface, []), Expression((mSurface, [])])    VariableReference(boolean createNewSurface, [])    Expression((mSurface, [])  Statement(if (createNewSurface) {, [])  Statement(// Create a new SurfaceTexture for the layer., [])  AssignmentExpression(=, [VariableReference(mSurface, []), Expression(new SurfaceTexture(false), [])])    VariableReference(mSurface, [])    Expression(new SurfaceTexture(false), [])  Statement(nCreateNativeWindow(mSurface), [])  Statement(}, [])  MethodCall(mLayer.setSurfaceTexture(mSurface), [VariableReference(mLayer, []), Expression(mSurface, [])])    VariableReference(mLayer, [])    Expression(mSurface, [])  MethodCall(mSurface.setDefaultBufferSize(getWidth(), getHeight()), [VariableReference(mSurface, []), Expression(getWidth(), []), Expression(getHeight(), [])])    VariableReference(mSurface, [])    Expression(getWidth(), [])    Expression(getHeight(), [])  MethodCall(mSurface.setOnFrameAvailableListener(mUpdateListener, mAttachInfo.mHandler), [VariableReference(mSurface, []), Expression(mUpdateListener, []), Expression(mAttachInfo.mHandler, [])])    VariableReference(mSurface, [])    Expression(mUpdateListener, [])    Expression(mAttachInfo.mHandler, [])  AssignmentExpression(=, [VariableReference(if (mListener !, []), Expression(null && createNewSurface) {, [])])    VariableReference(if (mListener !, [])    Expression(null && createNewSurface) {, [])  MethodCall(mListener.onSurfaceTextureAvailable(mSurface, getWidth(), getHeight()), [VariableReference(mListener, []), Expression(mSurface, []), Expression(getWidth(), []), Expression(getHeight(), [])])    VariableReference(mListener, [])    Expression(mSurface, [])    Expression(getWidth(), [])    Expression(getHeight(), [])  Statement(}, [])  MethodCall(mLayer.setLayerPaint(mLayerPaint), [VariableReference(mLayer, []), Expression(mLayerPaint, [])])    VariableReference(mLayer, [])    Expression(mLayerPaint, [])  Statement(}, [])  Statement(if (mUpdateSurface) {, [])  Statement(// Someone has requested that we use a specific SurfaceTexture, so, [])  Statement(// tell mLayer about it and set the SurfaceTexture to use the, [])  Statement(// current view size., [])  AssignmentExpression(=, [VariableReference(mUpdateSurface, []), Expression(false, [])])    VariableReference(mUpdateSurface, [])    Expression(false, [])  Statement(// Since we are updating the layer, force an update to ensure its, [])  Statement(updateLayer(), [])  AssignmentExpression(=, [VariableReference(mMatrixChanged, []), Expression(true, [])])    VariableReference(mMatrixChanged, [])    Expression(true, [])  MethodCall(mLayer.setSurfaceTexture(mSurface), [VariableReference(mLayer, []), Expression(mSurface, [])])    VariableReference(mLayer, [])    Expression(mSurface, [])  MethodCall(mSurface.setDefaultBufferSize(getWidth(), getHeight()), [VariableReference(mSurface, []), Expression(getWidth(), []), Expression(getHeight(), [])])    VariableReference(mSurface, [])    Expression(getWidth(), [])    Expression(getHeight(), [])  Statement(}, [])  Statement(return mLayer, [])  Statement(}, [])",1,,,0,,,0,,,,"1,2","3,4,5",1,4,1,"The code change is in the variable ""createNewSurface"" which is assigned a value based on the condition ""mSurface == null"". In the early version, the condition is not present, and the variable is not assigned a value. In the late version, the condition is added, and the variable is assigned a value based on the condition. This is a control dependency change (change type 4) as it changes the behavior of the code based on the condition.","The compatibility issue is caused by the potential different return values or types (CI type 1). In the early version, if ""mSurface"" is null, a new ""SurfaceTexture"" is created and assigned to ""mSurface"". In the late version, if ""mSurface"" is null, the variable ""createNewSurface"" is assigned the value true, and a new ""SurfaceTexture"" is created and assigned to ""mSurface"" only if the condition ""createNewSurface"" is true. This means that in the late version, if ""mSurface"" is null and the condition ""createNewSurface"" is false, a new ""SurfaceTexture"" will not be created, and the method will return null. This is a compatibility issue as it changes the behavior of the method and can potentially cause crashes or unexpected behavior in apps that rely on the method to return a non-null value."
117,<android.nfc.NfcAdapter: void disableReaderMode(Activity)>,24,25,,,,"MethodDeclaration(method_body, [Statement({, []), MethodCall(mNfcActivityManager.disableReaderMode(activity), [VariableReference(mNfcActivityManager, []), Expression(activity, [])]), Statement(}, [])])  Statement({, [])  MethodCall(mNfcActivityManager.disableReaderMode(activity), [VariableReference(mNfcActivityManager, []), Expression(activity, [])])    VariableReference(mNfcActivityManager, [])    Expression(activity, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (!sHasNfcFeature) {, []), Statement(throw new UnsupportedOperationException(), []), Statement(}, []), Statement(}, []), MethodCall(mNfcActivityManager.disableReaderMode(activity), [VariableReference(mNfcActivityManager, []), Expression(activity, [])]), Statement(}, [])])  Statement({, [])  Statement(if (!sHasNfcFeature) {, [])  Statement(throw new UnsupportedOperationException(), [])  Statement(}, [])  Statement(}, [])  MethodCall(mNfcActivityManager.disableReaderMode(activity), [VariableReference(mNfcActivityManager, []), Expression(activity, [])])    VariableReference(mNfcActivityManager, [])    Expression(activity, [])  Statement(}, [])",1,"/**
 * Restore the NFC adapter to normal mode of operation: supporting
 * peer-to-peer (Android Beam), card emulation, and polling for
 * all supported tag technologies.
 *
 * @param activity the Activity that currently has reader mode enabled
 */
","/**
 * Restore the NFC adapter to normal mode of operation: supporting
 * peer-to-peer (Android Beam), card emulation, and polling for
 * all supported tag technologies.
 *
 * @param activity the Activity that currently has reader mode enabled
 * @throws UnsupportedOperationException if FEATURE_NFC is unavailable.
 */
",1,,,0,,,,"1,2","2,3,4","1,2","2,5",2,"The method has been changed by adding an 'if' statement and a 'throw' statement. The control dependency has changed and a new exception handling statement has been introduced, so the code change type is 2,5.","The added 'if' statement and 'throw' statement could lead to different behaviour when the late version API is invoked. Specifically, the API will throw an 'UnsupportedOperationException' if the FEATURE_NFC is unavailable, while in the early version, there is no such exception throwing. Therefore, the CI type is 2."
119,"<android.provider.DocumentsProvider: String copyDocument(String,String)>",25,26,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(throw new UnsupportedOperationException(""Copy not supported""), []), Statement(}, [])])  Statement({, [])  Statement(throw new UnsupportedOperationException(""Copy not supported""), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(throw new UnsupportedOperationException(""Copy not supported""), []), Statement(}, [])])  Statement({, [])  Statement(throw new UnsupportedOperationException(""Copy not supported""), [])  Statement(}, [])",0,"/**
 * Copy the requested document or a document tree.
 * <p>
 * Copies a document including all child documents to another location within
 * the same document provider. Upon completion returns the document id of
 * the copied document at the target destination. {@code null} must never
 * be returned.
 *
 * @param sourceDocumentId the document to copy.
 * @param targetParentDocumentId the target document to be copied into as a child.
 */
","/**
 * Copy the requested document or a document tree.
 * <p>
 * Copies a document including all child documents to another location within
 * the same document provider. Upon completion returns the document id of
 * the copied document at the target destination. {@code null} must never
 * be returned.
 *
 * @param sourceDocumentId the document to copy.
 * @param targetParentDocumentId the target document to be copied into as a child.
 * @throws AuthenticationRequiredException If authentication is required from
 * the user (such as login credentials), but it is not guaranteed
 * that the client will handle this properly.
 */
",1,[@SuppressWarnings("unused")],[@SuppressWarnings("unused")],0,,,,0,0,0,2,2,"The implementation of the method ""copyDocument"" has not changed between the two versions. However, in the late version, a new exception ""AuthenticationRequiredException"" has been added to the method's Javadoc comment.","The addition of the ""AuthenticationRequiredException"" in the late version's Javadoc comment indicates that this exception may be thrown by the method in certain circumstances. If the client code calling this method is not updated to handle this new exception, it may result in unhandled exception errors or unexpected behavior, which is a compatibility issue."
120,<android.widget.TextView: void onCommitCorrection(CorrectionInfo)>,25,26,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mEditor !, []), Expression(null), [])]), MethodCall(mEditor.onCommitCorrection(info), [VariableReference(mEditor, []), Expression(info, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mEditor !, []), Expression(null), [])])    VariableReference(if (mEditor !, [])    Expression(null), [])  MethodCall(mEditor.onCommitCorrection(info), [VariableReference(mEditor, []), Expression(info, [])])    VariableReference(mEditor, [])    Expression(info, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mEditor !, []), Expression(null), [])]), MethodCall(mEditor.onCommitCorrection(info), [VariableReference(mEditor, []), Expression(info, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mEditor !, []), Expression(null), [])])    VariableReference(if (mEditor !, [])    Expression(null), [])  MethodCall(mEditor.onCommitCorrection(info), [VariableReference(mEditor, []), Expression(info, [])])    VariableReference(mEditor, [])    Expression(info, [])  Statement(}, [])",0,"/**
 * Called by the framework in response to a text auto-correction (such as fixing a typo using a
 * a dictionnary) from the current input method, provided by it calling
 * {@link InputConnection#commitCorrection} InputConnection.commitCorrection()}. The default
 * implementation flashes the background of the corrected word to provide feedback to the user.
 *
 * @param info The auto correct info about the text that was corrected.
 */
","/**
 * Called by the framework in response to a text auto-correction (such as fixing a typo using a
 * dictionary) from the current input method, provided by it calling
 * {@link InputConnection#commitCorrection(CorrectionInfo) InputConnection.commitCorrection()}.
 * The default implementation flashes the background of the corrected word to provide
 * feedback to the user.
 *
 * @param info The auto correct info about the text that was corrected.
 */
",1,,,0,,,,0,0,0,0,0,No changes have been made to the implementation of the API in the given AST Nodes.,"No Compatibility Issue exists, as the implementation of the API remains the same in both versions."
121,<android.appwidget.AppWidgetManager: List<AppWidgetProviderInfo> getInstalledProvidersForProfile(UserHandle)>,25,26,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mService, []), Expression(, [])]), MethodCall(return Collections.emptyList(), [VariableReference(return Collections, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mService, []), Expression(, [])])    VariableReference(if (mService, [])    Expression(, [])  MethodCall(return Collections.emptyList(), [VariableReference(return Collections, []), Expression(, [])])    VariableReference(return Collections, [])    Expression(, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mService, []), Expression(, [])]), MethodCall(return Collections.emptyList(), [VariableReference(return Collections, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mService, []), Expression(, [])])    VariableReference(if (mService, [])    Expression(, [])  MethodCall(return Collections.emptyList(), [VariableReference(return Collections, []), Expression(, [])])    VariableReference(return Collections, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Gets the AppWidget providers for the given user profile. User profile can only
 * be the current user or a profile of the current user. For example, the current
 * user may have a corporate profile. In this case the parent user profile has a
 * child profile, the corporate one.
 *
 * @param profile The profile for which to get providers. Passing null is equivaled
 * to passing only the current user handle.
 * @return The intalled providers.
 *
 * @see android.os.Process#myUserHandle()
 * @see android.os.UserManager#getUserProfiles()
 */
","/**
 * Gets the AppWidget providers for the given user profile. User profile can only
 * be the current user or a profile of the current user. For example, the current
 * user may have a corporate profile. In this case the parent user profile has a
 * child profile, the corporate one.
 *
 * @param profile The profile for which to get providers. Passing null is equivalent
 * to querying for only the calling user.
 * @return The installed providers, or an empty list if none are found for the given user.
 *
 * @see android.os.Process#myUserHandle()
 * @see android.os.UserManager#getUserProfiles()
 */
",1,,[@NonNull],1,,,,2,"1,5",1,"1,5","1,2","The method's return type has been annotated with @NonNull in the Late_Version, whereas in the Early_Version, there is no such annotation. Also, the method comment has been updated in the Late_Version, but it does not have any impact on the method's behavior.","The code change can potentially cause a Compatibility Issue (CI) as the method's return type has been annotated with @NonNull in the Late_Version. This means that the method is expected to never return null in the Late_Version. However, in the Early_Version, there is no such expectation. Therefore, if the method ever returns null in the Early_Version, it can lead to unexpected behavior in the Late_Version, such as a NullPointerException. Additionally, the Compatibility Issue can also be caused by a different exception handling, as the Late_Version might throw a NullPointerException, while the Early_Version does not."
122,"<android.view.View: boolean onKeyDown(int,KeyEvent)>",25,26,,,,"MethodDeclaration(method_body, [Statement({, []), MethodCall(if (KeyEvent.isConfirmKey(keyCode)), [VariableReference(if (KeyEvent, []), Expression(keyCode), [])]), AssignmentExpression(=, [VariableReference(if ((mViewFlags & ENABLED_MASK), []), Expression(, [])]), Statement(return true, []), Statement(}, []), Statement(// Long clickable items don't necessarily have to be clickable., []), AssignmentExpression(=, [VariableReference(if (((mViewFlags & CLICKABLE), []), Expression(, [])]), Statement(// For the purposes of menu anchoring and drawable hotspots,, []), Statement(// key events are considered to be at the center of the view., []), AssignmentExpression(=, [VariableReference(final float x, []), Expression(getWidth() / 2f, [])]), AssignmentExpression(=, [VariableReference(final float y, []), Expression(getHeight() / 2f, [])]), Statement(setPressed(true, x, y), []), Statement(checkForLongClick(0, x, y), []), Statement(return true, []), Statement(}, []), Statement(}, []), Statement(return false, []), Statement(}, [])])  Statement({, [])  MethodCall(if (KeyEvent.isConfirmKey(keyCode)), [VariableReference(if (KeyEvent, []), Expression(keyCode), [])])    VariableReference(if (KeyEvent, [])    Expression(keyCode), [])  AssignmentExpression(=, [VariableReference(if ((mViewFlags & ENABLED_MASK), []), Expression(, [])])    VariableReference(if ((mViewFlags & ENABLED_MASK), [])    Expression(, [])  Statement(return true, [])  Statement(}, [])  Statement(// Long clickable items don't necessarily have to be clickable., [])  AssignmentExpression(=, [VariableReference(if (((mViewFlags & CLICKABLE), []), Expression(, [])])    VariableReference(if (((mViewFlags & CLICKABLE), [])    Expression(, [])  Statement(// For the purposes of menu anchoring and drawable hotspots,, [])  Statement(// key events are considered to be at the center of the view., [])  AssignmentExpression(=, [VariableReference(final float x, []), Expression(getWidth() / 2f, [])])    VariableReference(final float x, [])    Expression(getWidth() / 2f, [])  AssignmentExpression(=, [VariableReference(final float y, []), Expression(getHeight() / 2f, [])])    VariableReference(final float y, [])    Expression(getHeight() / 2f, [])  Statement(setPressed(true, x, y), [])  Statement(checkForLongClick(0, x, y), [])  Statement(return true, [])  Statement(}, [])  Statement(}, [])  Statement(return false, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(if (KeyEvent.isConfirmKey(keyCode)), [VariableReference(if (KeyEvent, []), Expression(keyCode), [])]), AssignmentExpression(=, [VariableReference(if ((mViewFlags & ENABLED_MASK), []), Expression(, [])]), Statement(return true, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (event.getRepeatCount(), []), Expression(, [])]), Statement(// Long clickable items don't necessarily have to be clickable., []), AssignmentExpression(=, [VariableReference(final boolean clickable, []), Expression((mViewFlags & CLICKABLE), [])]), AssignmentExpression(=, [VariableReference(if (clickable || (mViewFlags & TOOLTIP), []), Expression(, [])]), Statement(// For the purposes of menu anchoring and drawable hotspots,, []), Statement(// key events are considered to be at the center of the view., []), AssignmentExpression(=, [VariableReference(final float x, []), Expression(getWidth() / 2f, [])]), AssignmentExpression(=, [VariableReference(final float y, []), Expression(getHeight() / 2f, [])]), Statement(if (clickable) {, []), Statement(setPressed(true, x, y), []), Statement(}, []), Statement(checkForLongClick(0, x, y), []), Statement(return true, []), Statement(}, []), Statement(}, []), Statement(}, []), Statement(return false, []), Statement(}, [])])  Statement({, [])  MethodCall(if (KeyEvent.isConfirmKey(keyCode)), [VariableReference(if (KeyEvent, []), Expression(keyCode), [])])    VariableReference(if (KeyEvent, [])    Expression(keyCode), [])  AssignmentExpression(=, [VariableReference(if ((mViewFlags & ENABLED_MASK), []), Expression(, [])])    VariableReference(if ((mViewFlags & ENABLED_MASK), [])    Expression(, [])  Statement(return true, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (event.getRepeatCount(), []), Expression(, [])])    VariableReference(if (event.getRepeatCount(), [])    Expression(, [])  Statement(// Long clickable items don't necessarily have to be clickable., [])  AssignmentExpression(=, [VariableReference(final boolean clickable, []), Expression((mViewFlags & CLICKABLE), [])])    VariableReference(final boolean clickable, [])    Expression((mViewFlags & CLICKABLE), [])  AssignmentExpression(=, [VariableReference(if (clickable || (mViewFlags & TOOLTIP), []), Expression(, [])])    VariableReference(if (clickable || (mViewFlags & TOOLTIP), [])    Expression(, [])  Statement(// For the purposes of menu anchoring and drawable hotspots,, [])  Statement(// key events are considered to be at the center of the view., [])  AssignmentExpression(=, [VariableReference(final float x, []), Expression(getWidth() / 2f, [])])    VariableReference(final float x, [])    Expression(getWidth() / 2f, [])  AssignmentExpression(=, [VariableReference(final float y, []), Expression(getHeight() / 2f, [])])    VariableReference(final float y, [])    Expression(getHeight() / 2f, [])  Statement(if (clickable) {, [])  Statement(setPressed(true, x, y), [])  Statement(}, [])  Statement(checkForLongClick(0, x, y), [])  Statement(return true, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(return false, [])  Statement(}, [])",1,"/**
 * Default implementation of {@link KeyEvent.Callback#onKeyDown(int, KeyEvent)
 * KeyEvent.Callback.onKeyDown()}: perform press of the view
 * when {@link KeyEvent#KEYCODE_DPAD_CENTER} or {@link KeyEvent#KEYCODE_ENTER}
 * is released, if the view is enabled and clickable.
 * <p>
 * Key presses in software keyboards will generally NOT trigger this
 * listener, although some may elect to do so in some situations. Do not
 * rely on this to catch software key presses.
 *
 * @param keyCode a key code that represents the button pressed, from
 * {@link android.view.KeyEvent}
 * @param event the KeyEvent object that defines the button action
 */
","/**
 * Default implementation of {@link KeyEvent.Callback#onKeyDown(int, KeyEvent)
 * KeyEvent.Callback.onKeyDown()}: perform press of the view
 * when {@link KeyEvent#KEYCODE_DPAD_CENTER} or {@link KeyEvent#KEYCODE_ENTER}
 * is released, if the view is enabled and clickable.
 * <p>
 * Key presses in software keyboards will generally NOT trigger this
 * listener, although some may elect to do so in some situations. Do not
 * rely on this to catch software key presses.
 *
 * @param keyCode a key code that represents the button pressed, from
 * {@link android.view.KeyEvent}
 * @param event the KeyEvent object that defines the button action
 */
",0,,,0,,,,"1,2","3,4",1,"3,4","1,2","The change from Early_Version to Late_Version in the implementation of the method onKeyDown(int, KeyEvent) is as follows:","2. In the Early_Version, the code checks if the view is long clickable by using the expression (mViewFlags & CLICKABLE). In the Late_Version, the code first assigns the result of this expression to a boolean variable clickable, and then checks if the view is long clickable by using the expression (clickable || (mViewFlags & TOOLTIP)). This change will not lead to different behaviors, since the two expressions are logically equivalent."
123,<android.text.method.TimeKeyListener: TimeKeyListener getInstance()>,25,26,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (sInstance !, []), Expression(null), [])]), Statement(return sInstance, []), AssignmentExpression(=, [VariableReference(sInstance, []), Expression(new TimeKeyListener(), [])]), Statement(return sInstance, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (sInstance !, []), Expression(null), [])])    VariableReference(if (sInstance !, [])    Expression(null), [])  Statement(return sInstance, [])  AssignmentExpression(=, [VariableReference(sInstance, []), Expression(new TimeKeyListener(), [])])    VariableReference(sInstance, [])    Expression(new TimeKeyListener(), [])  Statement(return sInstance, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return getInstance(null), []), Statement(}, [])])  Statement({, [])  Statement(return getInstance(null), [])  Statement(}, [])",1,,"/**
 * @deprecated Use {@link #getInstance(Locale)} instead.
 */
",1,,"[@Deprecated, @NonNull]",1,,,,"1,2","1,3,5",1,"1,5",1,"The implementation of the `getInstance()` method has been changed. In the early version, it first checks if the `sInstance` variable is not null, and if so, it returns `sInstance`. If `sInstance` is null, it creates a new `TimeKeyListener` instance and assigns it to `sInstance`, then returns `sInstance`. In the late version, it directly calls `getInstance(null)` to get the instance. Additionally, the late version has a `@Deprecated` annotation and the comment indicates that `getInstance(Locale)` should be used instead.","The change in the implementation of the `getInstance()` method could potentially lead to Compatibility Issue (CI) as it might return a different instance in the late version. In the early version, the `sInstance` variable is used to cache the instance and only creates a new one if necessary. However, in the late version, it's not clear how the `getInstance(null)` method is implemented and if it also caches the instance. If it doesn't, it might create a new instance every time, which could cause unexpected behaviors or performance issues in the app using the API."
124,"<android.app.assist.AssistStructure.ParcelTransferWriter: void writeView(ViewNode,Parcel,PooledStringWriter,int)>",25,26,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(if (DEBUG_PARCEL), []), AssignmentExpression(=, [VariableReference(Log.d(TAG, ""write view: at "" + out.dataPosition() + "", windows, []), Expression("" + mNumWrittenWindows + "", views, [])]), MethodCall(out.writeInt(VALIDATE_VIEW_TOKEN), [VariableReference(out, []), Expression(VALIDATE_VIEW_TOKEN, [])]), AssignmentExpression(=, [VariableReference(int flags, []), Expression(child.writeSelfToParcel(out, pwriter, mTmpMatrix), [])]), Statement(mNumWrittenViews++, []), Statement(// If the child has children, push it on the stack to write them next., []), AssignmentExpression(=, [VariableReference(if ((flags & ViewNode.FLAGS_HAS_CHILDREN) !, []), Expression(0) {, [])]), Statement(if (DEBUG_PARCEL_TREE || DEBUG_PARCEL_CHILDREN), []), MethodCall(Log.d(TAG, ""Preparing to write "" + child.mChildren.length + "" children: @ #"" + mNumWrittenViews + "", level "" + (mCurViewStackPos + levelAdj)), [VariableReference(Log, []), Expression(TAG, []), Expression(""Preparing to write "" + child.mChildren.length + "" children: @ #"" + mNumWrittenViews + "", []), Expression(level "" + (mCurViewStackPos + levelAdj), [])]), MethodCall(out.writeInt(child.mChildren.length), [VariableReference(out, []), Expression(child.mChildren.length, [])]), AssignmentExpression(=, [VariableReference(int pos, []), Expression(++mCurViewStackPos, [])]), Statement(pushViewStackEntry(child, pos), []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(if (DEBUG_PARCEL), [])  AssignmentExpression(=, [VariableReference(Log.d(TAG, ""write view: at "" + out.dataPosition() + "", windows, []), Expression("" + mNumWrittenWindows + "", views, [])])    VariableReference(Log.d(TAG, ""write view: at "" + out.dataPosition() + "", windows, [])    Expression("" + mNumWrittenWindows + "", views, [])  MethodCall(out.writeInt(VALIDATE_VIEW_TOKEN), [VariableReference(out, []), Expression(VALIDATE_VIEW_TOKEN, [])])    VariableReference(out, [])    Expression(VALIDATE_VIEW_TOKEN, [])  AssignmentExpression(=, [VariableReference(int flags, []), Expression(child.writeSelfToParcel(out, pwriter, mTmpMatrix), [])])    VariableReference(int flags, [])    Expression(child.writeSelfToParcel(out, pwriter, mTmpMatrix), [])  Statement(mNumWrittenViews++, [])  Statement(// If the child has children, push it on the stack to write them next., [])  AssignmentExpression(=, [VariableReference(if ((flags & ViewNode.FLAGS_HAS_CHILDREN) !, []), Expression(0) {, [])])    VariableReference(if ((flags & ViewNode.FLAGS_HAS_CHILDREN) !, [])    Expression(0) {, [])  Statement(if (DEBUG_PARCEL_TREE || DEBUG_PARCEL_CHILDREN), [])  MethodCall(Log.d(TAG, ""Preparing to write "" + child.mChildren.length + "" children: @ #"" + mNumWrittenViews + "", level "" + (mCurViewStackPos + levelAdj)), [VariableReference(Log, []), Expression(TAG, []), Expression(""Preparing to write "" + child.mChildren.length + "" children: @ #"" + mNumWrittenViews + "", []), Expression(level "" + (mCurViewStackPos + levelAdj), [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Preparing to write "" + child.mChildren.length + "" children: @ #"" + mNumWrittenViews + "", [])    Expression(level "" + (mCurViewStackPos + levelAdj), [])  MethodCall(out.writeInt(child.mChildren.length), [VariableReference(out, []), Expression(child.mChildren.length, [])])    VariableReference(out, [])    Expression(child.mChildren.length, [])  AssignmentExpression(=, [VariableReference(int pos, []), Expression(++mCurViewStackPos, [])])    VariableReference(int pos, [])    Expression(++mCurViewStackPos, [])  Statement(pushViewStackEntry(child, pos), [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (DEBUG_PARCEL), []), AssignmentExpression(=, [VariableReference(Log.d(TAG, ""write view: at "" + out.dataPosition() + "", windows, []), Expression("" + mNumWrittenWindows + "", views, [])]), MethodCall(out.writeInt(VALIDATE_VIEW_TOKEN), [VariableReference(out, []), Expression(VALIDATE_VIEW_TOKEN, [])]), AssignmentExpression(=, [VariableReference(int flags, []), Expression(child.writeSelfToParcel(out, pwriter, mSanitizeOnWrite, mTmpMatrix), [])]), Statement(mNumWrittenViews++, []), Statement(// If the child has children, push it on the stack to write them next., []), AssignmentExpression(=, [VariableReference(if ((flags & ViewNode.FLAGS_HAS_CHILDREN) !, []), Expression(0) {, [])]), Statement(if (DEBUG_PARCEL_TREE || DEBUG_PARCEL_CHILDREN), []), MethodCall(Log.d(TAG, ""Preparing to write "" + child.mChildren.length + "" children: @ #"" + mNumWrittenViews + "", level "" + (mCurViewStackPos + levelAdj)), [VariableReference(Log, []), Expression(TAG, []), Expression(""Preparing to write "" + child.mChildren.length + "" children: @ #"" + mNumWrittenViews + "", []), Expression(level "" + (mCurViewStackPos + levelAdj), [])]), MethodCall(out.writeInt(child.mChildren.length), [VariableReference(out, []), Expression(child.mChildren.length, [])]), AssignmentExpression(=, [VariableReference(int pos, []), Expression(++mCurViewStackPos, [])]), Statement(pushViewStackEntry(child, pos), []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(if (DEBUG_PARCEL), [])  AssignmentExpression(=, [VariableReference(Log.d(TAG, ""write view: at "" + out.dataPosition() + "", windows, []), Expression("" + mNumWrittenWindows + "", views, [])])    VariableReference(Log.d(TAG, ""write view: at "" + out.dataPosition() + "", windows, [])    Expression("" + mNumWrittenWindows + "", views, [])  MethodCall(out.writeInt(VALIDATE_VIEW_TOKEN), [VariableReference(out, []), Expression(VALIDATE_VIEW_TOKEN, [])])    VariableReference(out, [])    Expression(VALIDATE_VIEW_TOKEN, [])  AssignmentExpression(=, [VariableReference(int flags, []), Expression(child.writeSelfToParcel(out, pwriter, mSanitizeOnWrite, mTmpMatrix), [])])    VariableReference(int flags, [])    Expression(child.writeSelfToParcel(out, pwriter, mSanitizeOnWrite, mTmpMatrix), [])  Statement(mNumWrittenViews++, [])  Statement(// If the child has children, push it on the stack to write them next., [])  AssignmentExpression(=, [VariableReference(if ((flags & ViewNode.FLAGS_HAS_CHILDREN) !, []), Expression(0) {, [])])    VariableReference(if ((flags & ViewNode.FLAGS_HAS_CHILDREN) !, [])    Expression(0) {, [])  Statement(if (DEBUG_PARCEL_TREE || DEBUG_PARCEL_CHILDREN), [])  MethodCall(Log.d(TAG, ""Preparing to write "" + child.mChildren.length + "" children: @ #"" + mNumWrittenViews + "", level "" + (mCurViewStackPos + levelAdj)), [VariableReference(Log, []), Expression(TAG, []), Expression(""Preparing to write "" + child.mChildren.length + "" children: @ #"" + mNumWrittenViews + "", []), Expression(level "" + (mCurViewStackPos + levelAdj), [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Preparing to write "" + child.mChildren.length + "" children: @ #"" + mNumWrittenViews + "", [])    Expression(level "" + (mCurViewStackPos + levelAdj), [])  MethodCall(out.writeInt(child.mChildren.length), [VariableReference(out, []), Expression(child.mChildren.length, [])])    VariableReference(out, [])    Expression(child.mChildren.length, [])  AssignmentExpression(=, [VariableReference(int pos, []), Expression(++mCurViewStackPos, [])])    VariableReference(int pos, [])    Expression(++mCurViewStackPos, [])  Statement(pushViewStackEntry(child, pos), [])  Statement(}, [])  Statement(}, [])",1,,,0,,,0,,,,2,5,1,5,1,"In the late version of the implementation, an additional parameter `mSanitizeOnWrite` is added to the method call `child.writeSelfToParcel(out, pwriter, mSanitizeOnWrite, mTmpMatrix)`. This new parameter potentially changes the behavior of the method call and thus affects the value of the variable `flags`.","The value of the variable `flags` potentially changes due to the new parameter added in the method call. If the value of `flags` changes, the control flow of the method may change and lead to different return values or types. Therefore, the compatibility issue type is 1."
125,<android.text.TextUtils: boolean isEmpty(CharSequence)>,25,26,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (str, []), Expression(, [])]), Statement(return true, []), Statement(else, []), Statement(return false, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (str, []), Expression(, [])])    VariableReference(if (str, [])    Expression(, [])  Statement(return true, [])  Statement(else, [])  Statement(return false, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(return str, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(return str, []), Expression(, [])])    VariableReference(return str, [])    Expression(, [])  Statement(}, [])",1,"/**
 * Returns true if the string is null or 0-length.
 * @param str the string to be examined
 * @return true if str is null or zero length
 */
","/**
 * Returns true if the string is null or 0-length.
 * @param str the string to be examined
 * @return true if str is null or zero length
 */
",0,,,0,,,,1,"1,3",1,1,1,The return statement has been changed from "if (str == null || str.length() == 0) { return true; } else { return false; }" to "return str == null || str.length() == 0;".,"The change in the return statement can potentially lead to different behavior in the API. In the early version, if the input str is null or has a length of 0, the API will return true. Otherwise, it will return false. In the late version, the API will always return a boolean value, which is the result of the comparison ""str == null || str.length() == 0"". If the input str is not null and has a length greater than 0, the API will still return false. However, if the input str is null or has a length of 0, the API will now return the result of the comparison directly, which is still true. Therefore, the compatibility issue is caused by the potential different return values or types."
126,<android.widget.TextView: void setMinWidth(int)>,25,26,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(mMinWidth, []), Expression(minpixels, [])]), AssignmentExpression(=, [VariableReference(mMinWidthMode, []), Expression(PIXELS, [])]), Statement(requestLayout(), []), Statement(invalidate(), []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(mMinWidth, []), Expression(minpixels, [])])    VariableReference(mMinWidth, [])    Expression(minpixels, [])  AssignmentExpression(=, [VariableReference(mMinWidthMode, []), Expression(PIXELS, [])])    VariableReference(mMinWidthMode, [])    Expression(PIXELS, [])  Statement(requestLayout(), [])  Statement(invalidate(), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(mMinWidth, []), Expression(minPixels, [])]), AssignmentExpression(=, [VariableReference(mMinWidthMode, []), Expression(PIXELS, [])]), Statement(requestLayout(), []), Statement(invalidate(), []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(mMinWidth, []), Expression(minPixels, [])])    VariableReference(mMinWidth, [])    Expression(minPixels, [])  AssignmentExpression(=, [VariableReference(mMinWidthMode, []), Expression(PIXELS, [])])    VariableReference(mMinWidthMode, [])    Expression(PIXELS, [])  Statement(requestLayout(), [])  Statement(invalidate(), [])  Statement(}, [])",1,"/**
 * Makes the TextView at least this many pixels wide
 *
 * @attr ref android.R.styleable#TextView_minWidth
 */
","/**
 * Sets the width of the TextView to be at least {@code minPixels} wide.
 * <p>
 * This value is used for width calculation if LayoutParams does not force TextView to have an
 * exact width. Setting this value overrides previous minimum width configurations such as
 * {@link #setMinEms(int)} or {@link #setEms(int)}.
 * <p>
 * The value given here is different than {@link #setMinimumWidth(int)}. Between
 * {@code minWidth} and the value set in {@link #setMinimumWidth(int)}, the greater one is used
 * to decide the final width.
 *
 * @param minPixels the minimum width of TextView in terms of pixels
 *
 * @see #getMinWidth()
 * @see #setWidth(int)
 *
 * @attr ref android.R.styleable#TextView_minWidth
 */
",1,[@android.view.RemotableViewMethod],[@android.view.RemotableViewMethod],0,,,,1,4,0,4,0,The name of the parameter in the method has been changed from "minpixels" to "minPixels" in the late version. This is an example of "Other statement changed" as per the given definitions and instructions.,"The Compatibility Issue (CI) does not exist in the given method between the two continuous versions. The change in the name of the parameter does not affect the behavior of the method, as it is only a cosmetic change and does not alter the functionality or the returned value of the method. Therefore, the CI type is 0."
127,<android.service.notification.NotificationListenerService.MyHandler: void handleMessage(Message)>,25,26,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(if (!isConnected) {, []), Statement(return, []), Statement(}, []), Statement(case MSG_ON_NOTIFICATION_POSTED:, []), Statement({, []), AssignmentExpression(=, [VariableReference(SomeArgs args, []), Expression((SomeArgs) msg.obj, [])]), AssignmentExpression(=, [VariableReference(StatusBarNotification sbn, []), Expression((StatusBarNotification) args.arg1, [])]), AssignmentExpression(=, [VariableReference(RankingMap rankingMap, []), Expression((RankingMap) args.arg2, [])]), MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])]), Statement(onNotificationPosted(sbn, rankingMap), []), Statement(}, []), Statement(break, []), Statement(case MSG_ON_NOTIFICATION_REMOVED:, []), Statement({, []), AssignmentExpression(=, [VariableReference(SomeArgs args, []), Expression((SomeArgs) msg.obj, [])]), AssignmentExpression(=, [VariableReference(StatusBarNotification sbn, []), Expression((StatusBarNotification) args.arg1, [])]), AssignmentExpression(=, [VariableReference(RankingMap rankingMap, []), Expression((RankingMap) args.arg2, [])]), MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])]), Statement(onNotificationRemoved(sbn, rankingMap), []), Statement(}, []), Statement(break, []), Statement(case MSG_ON_LISTENER_CONNECTED:, []), Statement({, []), Statement(onListenerConnected(), []), Statement(}, []), Statement(break, []), Statement(case MSG_ON_NOTIFICATION_RANKING_UPDATE:, []), Statement({, []), AssignmentExpression(=, [VariableReference(RankingMap rankingMap, []), Expression((RankingMap) msg.obj, [])]), Statement(onNotificationRankingUpdate(rankingMap), []), Statement(}, []), Statement(break, []), Statement(case MSG_ON_LISTENER_HINTS_CHANGED:, []), Statement({, []), AssignmentExpression(=, [VariableReference(final int hints, []), Expression(msg.arg1, [])]), Statement(onListenerHintsChanged(hints), []), Statement(}, []), Statement(break, []), Statement(case MSG_ON_INTERRUPTION_FILTER_CHANGED:, []), Statement({, []), AssignmentExpression(=, [VariableReference(final int interruptionFilter, []), Expression(msg.arg1, [])]), Statement(onInterruptionFilterChanged(interruptionFilter), []), Statement(}, []), Statement(break, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(if (!isConnected) {, [])  Statement(return, [])  Statement(}, [])  Statement(case MSG_ON_NOTIFICATION_POSTED:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(SomeArgs args, []), Expression((SomeArgs) msg.obj, [])])    VariableReference(SomeArgs args, [])    Expression((SomeArgs) msg.obj, [])  AssignmentExpression(=, [VariableReference(StatusBarNotification sbn, []), Expression((StatusBarNotification) args.arg1, [])])    VariableReference(StatusBarNotification sbn, [])    Expression((StatusBarNotification) args.arg1, [])  AssignmentExpression(=, [VariableReference(RankingMap rankingMap, []), Expression((RankingMap) args.arg2, [])])    VariableReference(RankingMap rankingMap, [])    Expression((RankingMap) args.arg2, [])  MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])])    VariableReference(args, [])    Expression(, [])  Statement(onNotificationPosted(sbn, rankingMap), [])  Statement(}, [])  Statement(break, [])  Statement(case MSG_ON_NOTIFICATION_REMOVED:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(SomeArgs args, []), Expression((SomeArgs) msg.obj, [])])    VariableReference(SomeArgs args, [])    Expression((SomeArgs) msg.obj, [])  AssignmentExpression(=, [VariableReference(StatusBarNotification sbn, []), Expression((StatusBarNotification) args.arg1, [])])    VariableReference(StatusBarNotification sbn, [])    Expression((StatusBarNotification) args.arg1, [])  AssignmentExpression(=, [VariableReference(RankingMap rankingMap, []), Expression((RankingMap) args.arg2, [])])    VariableReference(RankingMap rankingMap, [])    Expression((RankingMap) args.arg2, [])  MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])])    VariableReference(args, [])    Expression(, [])  Statement(onNotificationRemoved(sbn, rankingMap), [])  Statement(}, [])  Statement(break, [])  Statement(case MSG_ON_LISTENER_CONNECTED:, [])  Statement({, [])  Statement(onListenerConnected(), [])  Statement(}, [])  Statement(break, [])  Statement(case MSG_ON_NOTIFICATION_RANKING_UPDATE:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(RankingMap rankingMap, []), Expression((RankingMap) msg.obj, [])])    VariableReference(RankingMap rankingMap, [])    Expression((RankingMap) msg.obj, [])  Statement(onNotificationRankingUpdate(rankingMap), [])  Statement(}, [])  Statement(break, [])  Statement(case MSG_ON_LISTENER_HINTS_CHANGED:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(final int hints, []), Expression(msg.arg1, [])])    VariableReference(final int hints, [])    Expression(msg.arg1, [])  Statement(onListenerHintsChanged(hints), [])  Statement(}, [])  Statement(break, [])  Statement(case MSG_ON_INTERRUPTION_FILTER_CHANGED:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(final int interruptionFilter, []), Expression(msg.arg1, [])])    VariableReference(final int interruptionFilter, [])    Expression(msg.arg1, [])  Statement(onInterruptionFilterChanged(interruptionFilter), [])  Statement(}, [])  Statement(break, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (!isConnected) {, []), Statement(return, []), Statement(}, []), Statement(case MSG_ON_NOTIFICATION_POSTED:, []), Statement({, []), AssignmentExpression(=, [VariableReference(SomeArgs args, []), Expression((SomeArgs) msg.obj, [])]), AssignmentExpression(=, [VariableReference(StatusBarNotification sbn, []), Expression((StatusBarNotification) args.arg1, [])]), AssignmentExpression(=, [VariableReference(RankingMap rankingMap, []), Expression((RankingMap) args.arg2, [])]), MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])]), Statement(onNotificationPosted(sbn, rankingMap), []), Statement(}, []), Statement(break, []), Statement(case MSG_ON_NOTIFICATION_REMOVED:, []), Statement({, []), AssignmentExpression(=, [VariableReference(SomeArgs args, []), Expression((SomeArgs) msg.obj, [])]), AssignmentExpression(=, [VariableReference(StatusBarNotification sbn, []), Expression((StatusBarNotification) args.arg1, [])]), AssignmentExpression(=, [VariableReference(RankingMap rankingMap, []), Expression((RankingMap) args.arg2, [])]), AssignmentExpression(=, [VariableReference(int reason, []), Expression((int) args.arg3, [])]), MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])]), Statement(onNotificationRemoved(sbn, rankingMap, reason), []), Statement(}, []), Statement(break, []), Statement(case MSG_ON_LISTENER_CONNECTED:, []), Statement({, []), Statement(onListenerConnected(), []), Statement(}, []), Statement(break, []), Statement(case MSG_ON_NOTIFICATION_RANKING_UPDATE:, []), Statement({, []), AssignmentExpression(=, [VariableReference(RankingMap rankingMap, []), Expression((RankingMap) msg.obj, [])]), Statement(onNotificationRankingUpdate(rankingMap), []), Statement(}, []), Statement(break, []), Statement(case MSG_ON_LISTENER_HINTS_CHANGED:, []), Statement({, []), AssignmentExpression(=, [VariableReference(final int hints, []), Expression(msg.arg1, [])]), Statement(onListenerHintsChanged(hints), []), Statement(}, []), Statement(break, []), Statement(case MSG_ON_INTERRUPTION_FILTER_CHANGED:, []), Statement({, []), AssignmentExpression(=, [VariableReference(final int interruptionFilter, []), Expression(msg.arg1, [])]), Statement(onInterruptionFilterChanged(interruptionFilter), []), Statement(}, []), Statement(break, []), Statement(case MSG_ON_NOTIFICATION_CHANNEL_MODIFIED:, []), Statement({, []), AssignmentExpression(=, [VariableReference(SomeArgs args, []), Expression((SomeArgs) msg.obj, [])]), AssignmentExpression(=, [VariableReference(String pkgName, []), Expression((String) args.arg1, [])]), AssignmentExpression(=, [VariableReference(UserHandle user, []), Expression((UserHandle) args.arg2, [])]), AssignmentExpression(=, [VariableReference(NotificationChannel channel, []), Expression((NotificationChannel) args.arg3, [])]), AssignmentExpression(=, [VariableReference(int modificationType, []), Expression((int) args.arg4, [])]), Statement(onNotificationChannelModified(pkgName, user, channel, modificationType), []), Statement(}, []), Statement(break, []), Statement(case MSG_ON_NOTIFICATION_CHANNEL_GROUP_MODIFIED:, []), Statement({, []), AssignmentExpression(=, [VariableReference(SomeArgs args, []), Expression((SomeArgs) msg.obj, [])]), AssignmentExpression(=, [VariableReference(String pkgName, []), Expression((String) args.arg1, [])]), AssignmentExpression(=, [VariableReference(UserHandle user, []), Expression((UserHandle) args.arg2, [])]), AssignmentExpression(=, [VariableReference(NotificationChannelGroup group, []), Expression((NotificationChannelGroup) args.arg3, [])]), AssignmentExpression(=, [VariableReference(int modificationType, []), Expression((int) args.arg4, [])]), Statement(onNotificationChannelGroupModified(pkgName, user, group, modificationType), []), Statement(}, []), Statement(break, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(if (!isConnected) {, [])  Statement(return, [])  Statement(}, [])  Statement(case MSG_ON_NOTIFICATION_POSTED:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(SomeArgs args, []), Expression((SomeArgs) msg.obj, [])])    VariableReference(SomeArgs args, [])    Expression((SomeArgs) msg.obj, [])  AssignmentExpression(=, [VariableReference(StatusBarNotification sbn, []), Expression((StatusBarNotification) args.arg1, [])])    VariableReference(StatusBarNotification sbn, [])    Expression((StatusBarNotification) args.arg1, [])  AssignmentExpression(=, [VariableReference(RankingMap rankingMap, []), Expression((RankingMap) args.arg2, [])])    VariableReference(RankingMap rankingMap, [])    Expression((RankingMap) args.arg2, [])  MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])])    VariableReference(args, [])    Expression(, [])  Statement(onNotificationPosted(sbn, rankingMap), [])  Statement(}, [])  Statement(break, [])  Statement(case MSG_ON_NOTIFICATION_REMOVED:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(SomeArgs args, []), Expression((SomeArgs) msg.obj, [])])    VariableReference(SomeArgs args, [])    Expression((SomeArgs) msg.obj, [])  AssignmentExpression(=, [VariableReference(StatusBarNotification sbn, []), Expression((StatusBarNotification) args.arg1, [])])    VariableReference(StatusBarNotification sbn, [])    Expression((StatusBarNotification) args.arg1, [])  AssignmentExpression(=, [VariableReference(RankingMap rankingMap, []), Expression((RankingMap) args.arg2, [])])    VariableReference(RankingMap rankingMap, [])    Expression((RankingMap) args.arg2, [])  AssignmentExpression(=, [VariableReference(int reason, []), Expression((int) args.arg3, [])])    VariableReference(int reason, [])    Expression((int) args.arg3, [])  MethodCall(args.recycle(), [VariableReference(args, []), Expression(, [])])    VariableReference(args, [])    Expression(, [])  Statement(onNotificationRemoved(sbn, rankingMap, reason), [])  Statement(}, [])  Statement(break, [])  Statement(case MSG_ON_LISTENER_CONNECTED:, [])  Statement({, [])  Statement(onListenerConnected(), [])  Statement(}, [])  Statement(break, [])  Statement(case MSG_ON_NOTIFICATION_RANKING_UPDATE:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(RankingMap rankingMap, []), Expression((RankingMap) msg.obj, [])])    VariableReference(RankingMap rankingMap, [])    Expression((RankingMap) msg.obj, [])  Statement(onNotificationRankingUpdate(rankingMap), [])  Statement(}, [])  Statement(break, [])  Statement(case MSG_ON_LISTENER_HINTS_CHANGED:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(final int hints, []), Expression(msg.arg1, [])])    VariableReference(final int hints, [])    Expression(msg.arg1, [])  Statement(onListenerHintsChanged(hints), [])  Statement(}, [])  Statement(break, [])  Statement(case MSG_ON_INTERRUPTION_FILTER_CHANGED:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(final int interruptionFilter, []), Expression(msg.arg1, [])])    VariableReference(final int interruptionFilter, [])    Expression(msg.arg1, [])  Statement(onInterruptionFilterChanged(interruptionFilter), [])  Statement(}, [])  Statement(break, [])  Statement(case MSG_ON_NOTIFICATION_CHANNEL_MODIFIED:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(SomeArgs args, []), Expression((SomeArgs) msg.obj, [])])    VariableReference(SomeArgs args, [])    Expression((SomeArgs) msg.obj, [])  AssignmentExpression(=, [VariableReference(String pkgName, []), Expression((String) args.arg1, [])])    VariableReference(String pkgName, [])    Expression((String) args.arg1, [])  AssignmentExpression(=, [VariableReference(UserHandle user, []), Expression((UserHandle) args.arg2, [])])    VariableReference(UserHandle user, [])    Expression((UserHandle) args.arg2, [])  AssignmentExpression(=, [VariableReference(NotificationChannel channel, []), Expression((NotificationChannel) args.arg3, [])])    VariableReference(NotificationChannel channel, [])    Expression((NotificationChannel) args.arg3, [])  AssignmentExpression(=, [VariableReference(int modificationType, []), Expression((int) args.arg4, [])])    VariableReference(int modificationType, [])    Expression((int) args.arg4, [])  Statement(onNotificationChannelModified(pkgName, user, channel, modificationType), [])  Statement(}, [])  Statement(break, [])  Statement(case MSG_ON_NOTIFICATION_CHANNEL_GROUP_MODIFIED:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(SomeArgs args, []), Expression((SomeArgs) msg.obj, [])])    VariableReference(SomeArgs args, [])    Expression((SomeArgs) msg.obj, [])  AssignmentExpression(=, [VariableReference(String pkgName, []), Expression((String) args.arg1, [])])    VariableReference(String pkgName, [])    Expression((String) args.arg1, [])  AssignmentExpression(=, [VariableReference(UserHandle user, []), Expression((UserHandle) args.arg2, [])])    VariableReference(UserHandle user, [])    Expression((UserHandle) args.arg2, [])  AssignmentExpression(=, [VariableReference(NotificationChannelGroup group, []), Expression((NotificationChannelGroup) args.arg3, [])])    VariableReference(NotificationChannelGroup group, [])    Expression((NotificationChannelGroup) args.arg3, [])  AssignmentExpression(=, [VariableReference(int modificationType, []), Expression((int) args.arg4, [])])    VariableReference(int modificationType, [])    Expression((int) args.arg4, [])  Statement(onNotificationChannelGroupModified(pkgName, user, group, modificationType), [])  Statement(}, [])  Statement(break, [])  Statement(}, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,,"1,2","3,4,5",1,"4,5","1,2","The code change between the two versions is a combination of control dependency change (4) and dependent API change (5). In the late version, two new cases ""MSG\_ON\_NOTIFICATION\_CHANNEL\_MODIFIED"" and ""MSG\_ON\_NOTIFICATION\_CHANNEL\_GROUP\_MODIFIED"" have been added, which leads to the control flow change. Moreover, the method ""onNotificationRemoved"" in the dependent API has been changed to ""onNotificationRemoved(sbn, rankingMap, reason)"".","The code change between the two versions could lead to compatibility issues (CI) of both type 1 and type 2. The newly added cases in the late version could result in different behaviors when the same message is handled in the two versions. Additionally, the change of the method ""onNotificationRemoved"" in the dependent API could also lead to different behaviors or even crashes if the app is not adapted to the new version."
128,<android.app.EnterTransitionCoordinator: void onTransitionsComplete()>,25,26,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(moveSharedElementsFromOverlay(), []), AssignmentExpression(=, [VariableReference(final ViewGroup decorView, []), Expression(getDecor(), [])]), AssignmentExpression(=, [VariableReference(if (decorView !, []), Expression(null) {, [])]), MethodCall(decorView.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED), [VariableReference(decorView, []), Expression(AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(moveSharedElementsFromOverlay(), [])  AssignmentExpression(=, [VariableReference(final ViewGroup decorView, []), Expression(getDecor(), [])])    VariableReference(final ViewGroup decorView, [])    Expression(getDecor(), [])  AssignmentExpression(=, [VariableReference(if (decorView !, []), Expression(null) {, [])])    VariableReference(if (decorView !, [])    Expression(null) {, [])  MethodCall(decorView.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED), [VariableReference(decorView, []), Expression(AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED, [])])    VariableReference(decorView, [])    Expression(AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(moveSharedElementsFromOverlay(), []), AssignmentExpression(=, [VariableReference(final ViewGroup decorView, []), Expression(getDecor(), [])]), AssignmentExpression(=, [VariableReference(if (decorView !, []), Expression(null) {, [])]), MethodCall(decorView.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED), [VariableReference(decorView, []), Expression(AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED, [])]), AssignmentExpression(=, [VariableReference(Window window, []), Expression(getWindow(), [])]), AssignmentExpression(=, [VariableReference(if (window !, []), Expression(null && mReplacedBackground, [])]), MethodCall(window.setBackgroundDrawable(null), [VariableReference(window, []), Expression(null, [])]), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(moveSharedElementsFromOverlay(), [])  AssignmentExpression(=, [VariableReference(final ViewGroup decorView, []), Expression(getDecor(), [])])    VariableReference(final ViewGroup decorView, [])    Expression(getDecor(), [])  AssignmentExpression(=, [VariableReference(if (decorView !, []), Expression(null) {, [])])    VariableReference(if (decorView !, [])    Expression(null) {, [])  MethodCall(decorView.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED), [VariableReference(decorView, []), Expression(AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED, [])])    VariableReference(decorView, [])    Expression(AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED, [])  AssignmentExpression(=, [VariableReference(Window window, []), Expression(getWindow(), [])])    VariableReference(Window window, [])    Expression(getWindow(), [])  AssignmentExpression(=, [VariableReference(if (window !, []), Expression(null && mReplacedBackground, [])])    VariableReference(if (window !, [])    Expression(null && mReplacedBackground, [])  MethodCall(window.setBackgroundDrawable(null), [VariableReference(window, []), Expression(null, [])])    VariableReference(window, [])    Expression(null, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,,"1,2","3,4",1,4,0,The code in the late version has added three statements after the `decorView.sendAccessibilityEvent` method call. These statements are not related to the method's return value or exception handling. They are assigning values to variables and calling a method on an object.,"The added statements in the late version do not affect the method's return value or exception handling. Therefore, there is no compatibility issue in this case."
129,<android.widget.VideoView: void stopPlayback()>,25,26,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mMediaPlayer !, []), Expression(null) {, [])]), MethodCall(mMediaPlayer.stop(), [VariableReference(mMediaPlayer, []), Expression(, [])]), MethodCall(mMediaPlayer.release(), [VariableReference(mMediaPlayer, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(mMediaPlayer, []), Expression(null, [])]), AssignmentExpression(=, [VariableReference(mCurrentState, []), Expression(STATE_IDLE, [])]), AssignmentExpression(=, [VariableReference(mTargetState, []), Expression(STATE_IDLE, [])]), AssignmentExpression(=, [VariableReference(AudioManager am, []), Expression((AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE), [])]), MethodCall(am.abandonAudioFocus(null), [VariableReference(am, []), Expression(null, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mMediaPlayer !, []), Expression(null) {, [])])    VariableReference(if (mMediaPlayer !, [])    Expression(null) {, [])  MethodCall(mMediaPlayer.stop(), [VariableReference(mMediaPlayer, []), Expression(, [])])    VariableReference(mMediaPlayer, [])    Expression(, [])  MethodCall(mMediaPlayer.release(), [VariableReference(mMediaPlayer, []), Expression(, [])])    VariableReference(mMediaPlayer, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(mMediaPlayer, []), Expression(null, [])])    VariableReference(mMediaPlayer, [])    Expression(null, [])  AssignmentExpression(=, [VariableReference(mCurrentState, []), Expression(STATE_IDLE, [])])    VariableReference(mCurrentState, [])    Expression(STATE_IDLE, [])  AssignmentExpression(=, [VariableReference(mTargetState, []), Expression(STATE_IDLE, [])])    VariableReference(mTargetState, [])    Expression(STATE_IDLE, [])  AssignmentExpression(=, [VariableReference(AudioManager am, []), Expression((AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE), [])])    VariableReference(AudioManager am, [])    Expression((AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE), [])  MethodCall(am.abandonAudioFocus(null), [VariableReference(am, []), Expression(null, [])])    VariableReference(am, [])    Expression(null, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mMediaPlayer !, []), Expression(null) {, [])]), MethodCall(mMediaPlayer.stop(), [VariableReference(mMediaPlayer, []), Expression(, [])]), MethodCall(mMediaPlayer.release(), [VariableReference(mMediaPlayer, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(mMediaPlayer, []), Expression(null, [])]), AssignmentExpression(=, [VariableReference(mCurrentState, []), Expression(STATE_IDLE, [])]), AssignmentExpression(=, [VariableReference(mTargetState, []), Expression(STATE_IDLE, [])]), MethodCall(mAudioManager.abandonAudioFocus(null), [VariableReference(mAudioManager, []), Expression(null, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mMediaPlayer !, []), Expression(null) {, [])])    VariableReference(if (mMediaPlayer !, [])    Expression(null) {, [])  MethodCall(mMediaPlayer.stop(), [VariableReference(mMediaPlayer, []), Expression(, [])])    VariableReference(mMediaPlayer, [])    Expression(, [])  MethodCall(mMediaPlayer.release(), [VariableReference(mMediaPlayer, []), Expression(, [])])    VariableReference(mMediaPlayer, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(mMediaPlayer, []), Expression(null, [])])    VariableReference(mMediaPlayer, [])    Expression(null, [])  AssignmentExpression(=, [VariableReference(mCurrentState, []), Expression(STATE_IDLE, [])])    VariableReference(mCurrentState, [])    Expression(STATE_IDLE, [])  AssignmentExpression(=, [VariableReference(mTargetState, []), Expression(STATE_IDLE, [])])    VariableReference(mTargetState, [])    Expression(STATE_IDLE, [])  MethodCall(mAudioManager.abandonAudioFocus(null), [VariableReference(mAudioManager, []), Expression(null, [])])    VariableReference(mAudioManager, [])    Expression(null, [])  Statement(}, [])  Statement(}, [])",1,,,0,,,0,,,,"1,2",4,0,5,0,"The method call to abandon audio focus in the early version is `am.abandonAudioFocus(null)`, where `am` is a local variable defined as `AudioManager am = (AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE)`. In the late version, this method call has been changed to `mAudioManager.abandonAudioFocus(null)`, where `mAudioManager` is likely a class-level variable that has been introduced in the late version. This is a dependent API change (type 5) as the change involves the method name and the object on which the method is called.","The Compatibility Issue (CI) type is 0, which means that no compatibility issue exists. This is because the change in the method call to abandon audio focus does not affect the return type or value of the `stopPlayback()` method, nor does it introduce any new exception handling. Therefore, this change is unlikely to cause any compatibility issues in applications that use the `VideoView` class."
130,<android.app.Notification.Action.Builder: Action build()>,25,26,,,,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(RemoteInput[] remoteInputs, []), Expression(mRemoteInputs !, [])]), Statement(return new Action(mIcon, mTitle, mIntent, mExtras, remoteInputs, mAllowGeneratedReplies), []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(RemoteInput[] remoteInputs, []), Expression(mRemoteInputs !, [])])    VariableReference(RemoteInput[] remoteInputs, [])    Expression(mRemoteInputs !, [])  Statement(return new Action(mIcon, mTitle, mIntent, mExtras, remoteInputs, mAllowGeneratedReplies), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(ArrayList<RemoteInput> dataOnlyInputs, []), Expression(new ArrayList<>(), [])]), AssignmentExpression(=, [VariableReference(RemoteInput[] previousDataInputs, []), Expression((RemoteInput[]) mExtras.getParcelableArray(EXTRA_DATA_ONLY_INPUTS), [])]), AssignmentExpression(=, [VariableReference(if (previousDataInputs !, []), Expression(null) {, [])]), Statement(for (RemoteInput input : previousDataInputs) {, []), MethodCall(dataOnlyInputs.add(input), [VariableReference(dataOnlyInputs, []), Expression(input, [])]), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(List<RemoteInput> textInputs, []), Expression(new ArrayList<>(), [])]), AssignmentExpression(=, [VariableReference(if (mRemoteInputs !, []), Expression(null) {, [])]), Statement(for (RemoteInput input : mRemoteInputs) {, []), MethodCall(if (input.isDataOnly()), [VariableReference(if (input, []), Expression(), [])]), MethodCall(dataOnlyInputs.add(input), [VariableReference(dataOnlyInputs, []), Expression(input, [])]), Statement(} else {, []), MethodCall(textInputs.add(input), [VariableReference(textInputs, []), Expression(input, [])]), Statement(}, []), Statement(}, []), Statement(}, []), MethodCall(if (!dataOnlyInputs.isEmpty()), [VariableReference(if (!dataOnlyInputs, []), Expression(), [])]), AssignmentExpression(=, [VariableReference(RemoteInput[] dataInputsArr, []), Expression(dataOnlyInputs.toArray(new RemoteInput[dataOnlyInputs.size()]), [])]), MethodCall(mExtras.putParcelableArray(EXTRA_DATA_ONLY_INPUTS, dataInputsArr), [VariableReference(mExtras, []), Expression(EXTRA_DATA_ONLY_INPUTS, []), Expression(dataInputsArr, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(RemoteInput[] textInputsArr, []), Expression(textInputs.isEmpty() ? null : textInputs.toArray(new RemoteInput[textInputs.size()]), [])]), Statement(return new Action(mIcon, mTitle, mIntent, mExtras, textInputsArr, mAllowGeneratedReplies), []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(ArrayList<RemoteInput> dataOnlyInputs, []), Expression(new ArrayList<>(), [])])    VariableReference(ArrayList<RemoteInput> dataOnlyInputs, [])    Expression(new ArrayList<>(), [])  AssignmentExpression(=, [VariableReference(RemoteInput[] previousDataInputs, []), Expression((RemoteInput[]) mExtras.getParcelableArray(EXTRA_DATA_ONLY_INPUTS), [])])    VariableReference(RemoteInput[] previousDataInputs, [])    Expression((RemoteInput[]) mExtras.getParcelableArray(EXTRA_DATA_ONLY_INPUTS), [])  AssignmentExpression(=, [VariableReference(if (previousDataInputs !, []), Expression(null) {, [])])    VariableReference(if (previousDataInputs !, [])    Expression(null) {, [])  Statement(for (RemoteInput input : previousDataInputs) {, [])  MethodCall(dataOnlyInputs.add(input), [VariableReference(dataOnlyInputs, []), Expression(input, [])])    VariableReference(dataOnlyInputs, [])    Expression(input, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(List<RemoteInput> textInputs, []), Expression(new ArrayList<>(), [])])    VariableReference(List<RemoteInput> textInputs, [])    Expression(new ArrayList<>(), [])  AssignmentExpression(=, [VariableReference(if (mRemoteInputs !, []), Expression(null) {, [])])    VariableReference(if (mRemoteInputs !, [])    Expression(null) {, [])  Statement(for (RemoteInput input : mRemoteInputs) {, [])  MethodCall(if (input.isDataOnly()), [VariableReference(if (input, []), Expression(), [])])    VariableReference(if (input, [])    Expression(), [])  MethodCall(dataOnlyInputs.add(input), [VariableReference(dataOnlyInputs, []), Expression(input, [])])    VariableReference(dataOnlyInputs, [])    Expression(input, [])  Statement(} else {, [])  MethodCall(textInputs.add(input), [VariableReference(textInputs, []), Expression(input, [])])    VariableReference(textInputs, [])    Expression(input, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  MethodCall(if (!dataOnlyInputs.isEmpty()), [VariableReference(if (!dataOnlyInputs, []), Expression(), [])])    VariableReference(if (!dataOnlyInputs, [])    Expression(), [])  AssignmentExpression(=, [VariableReference(RemoteInput[] dataInputsArr, []), Expression(dataOnlyInputs.toArray(new RemoteInput[dataOnlyInputs.size()]), [])])    VariableReference(RemoteInput[] dataInputsArr, [])    Expression(dataOnlyInputs.toArray(new RemoteInput[dataOnlyInputs.size()]), [])  MethodCall(mExtras.putParcelableArray(EXTRA_DATA_ONLY_INPUTS, dataInputsArr), [VariableReference(mExtras, []), Expression(EXTRA_DATA_ONLY_INPUTS, []), Expression(dataInputsArr, [])])    VariableReference(mExtras, [])    Expression(EXTRA_DATA_ONLY_INPUTS, [])    Expression(dataInputsArr, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(RemoteInput[] textInputsArr, []), Expression(textInputs.isEmpty() ? null : textInputs.toArray(new RemoteInput[textInputs.size()]), [])])    VariableReference(RemoteInput[] textInputsArr, [])    Expression(textInputs.isEmpty() ? null : textInputs.toArray(new RemoteInput[textInputs.size()]), [])  Statement(return new Action(mIcon, mTitle, mIntent, mExtras, textInputsArr, mAllowGeneratedReplies), [])  Statement(}, [])",1,"/**
 * Combine all of the options that have been set and return a new {@link Action}
 * object.
 * @return the built action
 */
","/**
 * Combine all of the options that have been set and return a new {@link Action}
 * object.
 * @return the built action
 */
",0,,,0,,,,"1,2","1,3,4,5",1,"3,5",1,"The implementation of the `build()` method has undergone significant changes in its control dependency and introduced new statements to handle the `RemoteInput` objects differently. In the early version, it simply assigned the `mRemoteInputs` to a local variable `remoteInputs` and passed it to the `Action` constructor. In the late version, it first checks if there are any data-only `RemoteInput` objects and adds them to a separate list `dataOnlyInputs`. It then adds the remaining text-based `RemoteInput` objects to a separate list `textInputs`. These two lists are then converted to arrays and passed to the `Action` constructor, along with an additional extras key `EXTRA_DATA_ONLY_INPUTS` to denote the data-only inputs.","The changes in the control dependency and the introduction of new statements to handle the `RemoteInput` objects differently can lead to compatibility issues. The behavior of the `build()` method has changed in the way it processes the `RemoteInput` objects, which can potentially result in a different `Action` object being returned. This is because the late version separates the data-only and text-based inputs and passes them as separate arrays, whereas the early version simply passes all the inputs in a single array. This can affect the functionality of the notification action, especially if the app is designed to handle data-only and text-based inputs differently."
131,"<android.app.SharedPreferencesImpl.EditorImpl: Editor putInt(String,int)>",25,26,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(synchronized (this) {, []), MethodCall(mModified.put(key, value), [VariableReference(mModified, []), Expression(key, []), Expression(value, [])]), Statement(return this, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(synchronized (this) {, [])  MethodCall(mModified.put(key, value), [VariableReference(mModified, []), Expression(key, []), Expression(value, [])])    VariableReference(mModified, [])    Expression(key, [])    Expression(value, [])  Statement(return this, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(synchronized (mLock) {, []), MethodCall(mModified.put(key, value), [VariableReference(mModified, []), Expression(key, []), Expression(value, [])]), Statement(return this, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(synchronized (mLock) {, [])  MethodCall(mModified.put(key, value), [VariableReference(mModified, []), Expression(key, []), Expression(value, [])])    VariableReference(mModified, [])    Expression(key, [])    Expression(value, [])  Statement(return this, [])  Statement(}, [])  Statement(}, [])",1,,,0,,,0,,,,1,4,0,3,0,"In the Late\_Version, the synchronized block has been changed from `synchronized (this)` to `synchronized (mLock)`. This affects the control dependency of the code, as the lock used for synchronization has been changed.","No Compatibility Issue exist. The change of lock object in synchronized block will not cause different return values or types, or throw a different exception, because the behavior of the code inside the synchronized block is still the same."
132,<android.appwidget.AppWidgetHost: int allocateAppWidgetId()>,26,27,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(return sService.allocateAppWidgetId(mContextOpPackageName, mHostId), [VariableReference(return sService, []), Expression(mContextOpPackageName, []), Expression(mHostId, [])]), Statement(} catch (RemoteException e) {, []), Statement(throw new RuntimeException(""system server dead?"", e), []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(return sService.allocateAppWidgetId(mContextOpPackageName, mHostId), [VariableReference(return sService, []), Expression(mContextOpPackageName, []), Expression(mHostId, [])])    VariableReference(return sService, [])    Expression(mContextOpPackageName, [])    Expression(mHostId, [])  Statement(} catch (RemoteException e) {, [])  Statement(throw new RuntimeException(""system server dead?"", e), [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (sService, []), Expression(, [])]), Statement(return -1, []), Statement(}, []), Statement(try {, []), MethodCall(return sService.allocateAppWidgetId(mContextOpPackageName, mHostId), [VariableReference(return sService, []), Expression(mContextOpPackageName, []), Expression(mHostId, [])]), Statement(} catch (RemoteException e) {, []), Statement(throw new RuntimeException(""system server dead?"", e), []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (sService, []), Expression(, [])])    VariableReference(if (sService, [])    Expression(, [])  Statement(return -1, [])  Statement(}, [])  Statement(try {, [])  MethodCall(return sService.allocateAppWidgetId(mContextOpPackageName, mHostId), [VariableReference(return sService, []), Expression(mContextOpPackageName, []), Expression(mHostId, [])])    VariableReference(return sService, [])    Expression(mContextOpPackageName, [])    Expression(mHostId, [])  Statement(} catch (RemoteException e) {, [])  Statement(throw new RuntimeException(""system server dead?"", e), [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Get a appWidgetId for a host in the calling process.
 *
 * @return a appWidgetId
 */
","/**
 * Get a appWidgetId for a host in the calling process.
 *
 * @return a appWidgetId
 */
",0,,,0,,,,1,"1,3",1,"1,3",1,"The return statement has been changed to a control dependency statement. In the early version, the method returns the result of `sService.allocateAppWidgetId(mContextOpPackageName, mHostId)` directly. In the late version, the method first checks whether `sService` is null. If it is null, the method returns -1. Otherwise, the method returns the result of `sService.allocateAppWidgetId(mContextOpPackageName, mHostId)`. This change can potentially lead to different return values.","In the late version, the method returns -1 when `sService` is null. However, in the early version, the method will throw a NullPointerException when `sService` is null. This change can potentially cause compatibility issues for the calling code that does not expect the method to return -1 or does not handle the NullPointerException."
133,<android.webkit.WebView: void shortPressOnTextField()>,4,5,<android.webkit.WebView: void shortPressOnTextField()>,<android.webkit.WebView: void shortPressOnTextField()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(if (inEditingMode()) {, []), AssignmentExpression(=, [VariableReference(View v, []), Expression(mTextEntry, [])]), AssignmentExpression(=, [VariableReference(int x, []), Expression(viewToContent((v.getLeft() + v.getRight()) >> 1), [])]), AssignmentExpression(=, [VariableReference(int y, []), Expression(viewToContent((v.getTop() + v.getBottom()) >> 1), [])]), Statement(nativeMotionUp(x, y, mNavSlop, true), []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(if (inEditingMode()) {, [])  AssignmentExpression(=, [VariableReference(View v, []), Expression(mTextEntry, [])])    VariableReference(View v, [])    Expression(mTextEntry, [])  AssignmentExpression(=, [VariableReference(int x, []), Expression(viewToContent((v.getLeft() + v.getRight()) >> 1), [])])    VariableReference(int x, [])    Expression(viewToContent((v.getLeft() + v.getRight()) >> 1), [])  AssignmentExpression(=, [VariableReference(int y, []), Expression(viewToContent((v.getTop() + v.getBottom()) >> 1), [])])    VariableReference(int y, [])    Expression(viewToContent((v.getTop() + v.getBottom()) >> 1), [])  Statement(nativeMotionUp(x, y, mNavSlop, true), [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (inEditingMode()) {, []), AssignmentExpression(=, [VariableReference(View v, []), Expression(mWebTextView, [])]), AssignmentExpression(=, [VariableReference(int x, []), Expression(viewToContentX((v.getLeft() + v.getRight()) >> 1), [])]), AssignmentExpression(=, [VariableReference(int y, []), Expression(viewToContentY((v.getTop() + v.getBottom()) >> 1), [])]), Statement(nativeTextInputMotionUp(x, y), []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(if (inEditingMode()) {, [])  AssignmentExpression(=, [VariableReference(View v, []), Expression(mWebTextView, [])])    VariableReference(View v, [])    Expression(mWebTextView, [])  AssignmentExpression(=, [VariableReference(int x, []), Expression(viewToContentX((v.getLeft() + v.getRight()) >> 1), [])])    VariableReference(int x, [])    Expression(viewToContentX((v.getLeft() + v.getRight()) >> 1), [])  AssignmentExpression(=, [VariableReference(int y, []), Expression(viewToContentY((v.getTop() + v.getBottom()) >> 1), [])])    VariableReference(int y, [])    Expression(viewToContentY((v.getTop() + v.getBottom()) >> 1), [])  Statement(nativeTextInputMotionUp(x, y), [])  Statement(}, [])  Statement(}, [])",1,"/*package*/
","/*package*/
",0,,,0,,,0,"1,2","4,5",0,0,0,"2. Exception handling statement changed: No, there is no exception handling statement in the given code.","	* Variable `mTextEntry` has been changed to `mWebTextView`."
134,<android.webkit.MimeTypeMap: String getFileExtensionFromUrl(String)>,4,5,<android.webkit.MimeTypeMap: String getFileExtensionFromUrl(String)>,<android.webkit.MimeTypeMap: String getFileExtensionFromUrl(String)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (url !, []), Expression(null && url.length() > 0) {, [])]), AssignmentExpression(=, [VariableReference(int query, []), Expression(url.lastIndexOf('?'), [])]), Statement(if (query > 0) {, []), AssignmentExpression(=, [VariableReference(url, []), Expression(url.substring(0, query), [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(int filenamePos, []), Expression(url.lastIndexOf('/'), [])]), AssignmentExpression(=, [VariableReference(String filename, []), Expression(0 <, [])]), Statement(// consider it valid for our matching purposes:, []), MethodCall(if (filename.length() > 0 && Pattern.matches(""[a-zA-Z_0-9\\.\\-\\(\\)]+"", filename)), [VariableReference(if (filename, []), Expression() > 0 && Pattern.matches(""[a-zA-Z_0-9\\.\\-\\(\\)]+"", []), Expression(filename), [])]), AssignmentExpression(=, [VariableReference(int dotPos, []), Expression(filename.lastIndexOf('.'), [])]), AssignmentExpression(=, [VariableReference(if (0 <, []), Expression(dotPos) {, [])]), MethodCall(return filename.substring(dotPos + 1), [VariableReference(return filename, []), Expression(dotPos + 1, [])]), Statement(}, []), Statement(}, []), Statement(}, []), Statement(return """", []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (url !, []), Expression(null && url.length() > 0) {, [])])    VariableReference(if (url !, [])    Expression(null && url.length() > 0) {, [])  AssignmentExpression(=, [VariableReference(int query, []), Expression(url.lastIndexOf('?'), [])])    VariableReference(int query, [])    Expression(url.lastIndexOf('?'), [])  Statement(if (query > 0) {, [])  AssignmentExpression(=, [VariableReference(url, []), Expression(url.substring(0, query), [])])    VariableReference(url, [])    Expression(url.substring(0, query), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(int filenamePos, []), Expression(url.lastIndexOf('/'), [])])    VariableReference(int filenamePos, [])    Expression(url.lastIndexOf('/'), [])  AssignmentExpression(=, [VariableReference(String filename, []), Expression(0 <, [])])    VariableReference(String filename, [])    Expression(0 <, [])  Statement(// consider it valid for our matching purposes:, [])  MethodCall(if (filename.length() > 0 && Pattern.matches(""[a-zA-Z_0-9\\.\\-\\(\\)]+"", filename)), [VariableReference(if (filename, []), Expression() > 0 && Pattern.matches(""[a-zA-Z_0-9\\.\\-\\(\\)]+"", []), Expression(filename), [])])    VariableReference(if (filename, [])    Expression() > 0 && Pattern.matches(""[a-zA-Z_0-9\\.\\-\\(\\)]+"", [])    Expression(filename), [])  AssignmentExpression(=, [VariableReference(int dotPos, []), Expression(filename.lastIndexOf('.'), [])])    VariableReference(int dotPos, [])    Expression(filename.lastIndexOf('.'), [])  AssignmentExpression(=, [VariableReference(if (0 <, []), Expression(dotPos) {, [])])    VariableReference(if (0 <, [])    Expression(dotPos) {, [])  MethodCall(return filename.substring(dotPos + 1), [VariableReference(return filename, []), Expression(dotPos + 1, [])])    VariableReference(return filename, [])    Expression(dotPos + 1, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(return """", [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (url !, []), Expression(null && url.length() > 0) {, [])]), AssignmentExpression(=, [VariableReference(int query, []), Expression(url.lastIndexOf('?'), [])]), Statement(if (query > 0) {, []), AssignmentExpression(=, [VariableReference(url, []), Expression(url.substring(0, query), [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(int filenamePos, []), Expression(url.lastIndexOf('/'), [])]), AssignmentExpression(=, [VariableReference(String filename, []), Expression(0 <, [])]), Statement(// consider it valid for our matching purposes:, []), MethodCall(if (filename.length() > 0 && Pattern.matches(""[a-zA-Z_0-9\\.\\-\\(\\)]+"", filename)), [VariableReference(if (filename, []), Expression() > 0 && Pattern.matches(""[a-zA-Z_0-9\\.\\-\\(\\)]+"", []), Expression(filename), [])]), AssignmentExpression(=, [VariableReference(int dotPos, []), Expression(filename.lastIndexOf('.'), [])]), AssignmentExpression(=, [VariableReference(if (0 <, []), Expression(dotPos) {, [])]), MethodCall(return filename.substring(dotPos + 1), [VariableReference(return filename, []), Expression(dotPos + 1, [])]), Statement(}, []), Statement(}, []), Statement(}, []), Statement(return """", []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (url !, []), Expression(null && url.length() > 0) {, [])])    VariableReference(if (url !, [])    Expression(null && url.length() > 0) {, [])  AssignmentExpression(=, [VariableReference(int query, []), Expression(url.lastIndexOf('?'), [])])    VariableReference(int query, [])    Expression(url.lastIndexOf('?'), [])  Statement(if (query > 0) {, [])  AssignmentExpression(=, [VariableReference(url, []), Expression(url.substring(0, query), [])])    VariableReference(url, [])    Expression(url.substring(0, query), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(int filenamePos, []), Expression(url.lastIndexOf('/'), [])])    VariableReference(int filenamePos, [])    Expression(url.lastIndexOf('/'), [])  AssignmentExpression(=, [VariableReference(String filename, []), Expression(0 <, [])])    VariableReference(String filename, [])    Expression(0 <, [])  Statement(// consider it valid for our matching purposes:, [])  MethodCall(if (filename.length() > 0 && Pattern.matches(""[a-zA-Z_0-9\\.\\-\\(\\)]+"", filename)), [VariableReference(if (filename, []), Expression() > 0 && Pattern.matches(""[a-zA-Z_0-9\\.\\-\\(\\)]+"", []), Expression(filename), [])])    VariableReference(if (filename, [])    Expression() > 0 && Pattern.matches(""[a-zA-Z_0-9\\.\\-\\(\\)]+"", [])    Expression(filename), [])  AssignmentExpression(=, [VariableReference(int dotPos, []), Expression(filename.lastIndexOf('.'), [])])    VariableReference(int dotPos, [])    Expression(filename.lastIndexOf('.'), [])  AssignmentExpression(=, [VariableReference(if (0 <, []), Expression(dotPos) {, [])])    VariableReference(if (0 <, [])    Expression(dotPos) {, [])  MethodCall(return filename.substring(dotPos + 1), [VariableReference(return filename, []), Expression(dotPos + 1, [])])    VariableReference(return filename, [])    Expression(dotPos + 1, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(return """", [])  Statement(}, [])",0,"/**
 * Returns the file extension or an empty string iff there is no
 * extension.
 */
","/**
 * Returns the file extension or an empty string iff there is no
 * extension. This method is a convenience method for obtaining the
 * extension of a url and has undefined results for other Strings.
 * @param url
 * @return The file extension of the given url.
 */
",1,,,0,,,0,0,0,0,0,0,"There is no change in the implementation, comment, or annotation between the two versions of the API.","There is no Compatibility Issue (CI) exist for the API, as there are no changes that could lead to different behaviors."
136,"<android.provider.ContactsContract.QuickContact: void showQuickContact(Context,View,Uri,int,String[])>",5,6,"<android.provider.ContactsContract.QuickContact: void showQuickContact(Context,View,Uri,int,String[])>","<android.provider.ContactsContract.QuickContact: void showQuickContact(Context,View,Uri,int,String[])>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(// Find location and bounds of target view, []), AssignmentExpression(=, [VariableReference(final int[] location, []), Expression(new int[2], [])]), MethodCall(target.getLocationOnScreen(location), [VariableReference(target, []), Expression(location, [])]), AssignmentExpression(=, [VariableReference(final Rect rect, []), Expression(new Rect(), [])]), AssignmentExpression(=, [VariableReference(rect.left, []), Expression(location[0], [])]), AssignmentExpression(=, [VariableReference(rect.top, []), Expression(location[1], [])]), AssignmentExpression(=, [VariableReference(rect.right, []), Expression(rect.left + target.getWidth(), [])]), AssignmentExpression(=, [VariableReference(rect.bottom, []), Expression(rect.top + target.getHeight(), [])]), Statement(// Trigger with obtained rectangle, []), Statement(showQuickContact(context, rect, lookupUri, mode, excludeMimes), []), Statement(}, [])])  Statement({, [])  Statement(// Find location and bounds of target view, [])  AssignmentExpression(=, [VariableReference(final int[] location, []), Expression(new int[2], [])])    VariableReference(final int[] location, [])    Expression(new int[2], [])  MethodCall(target.getLocationOnScreen(location), [VariableReference(target, []), Expression(location, [])])    VariableReference(target, [])    Expression(location, [])  AssignmentExpression(=, [VariableReference(final Rect rect, []), Expression(new Rect(), [])])    VariableReference(final Rect rect, [])    Expression(new Rect(), [])  AssignmentExpression(=, [VariableReference(rect.left, []), Expression(location[0], [])])    VariableReference(rect.left, [])    Expression(location[0], [])  AssignmentExpression(=, [VariableReference(rect.top, []), Expression(location[1], [])])    VariableReference(rect.top, [])    Expression(location[1], [])  AssignmentExpression(=, [VariableReference(rect.right, []), Expression(rect.left + target.getWidth(), [])])    VariableReference(rect.right, [])    Expression(rect.left + target.getWidth(), [])  AssignmentExpression(=, [VariableReference(rect.bottom, []), Expression(rect.top + target.getHeight(), [])])    VariableReference(rect.bottom, [])    Expression(rect.top + target.getHeight(), [])  Statement(// Trigger with obtained rectangle, [])  Statement(showQuickContact(context, rect, lookupUri, mode, excludeMimes), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(// Find location and bounds of target view, []), AssignmentExpression(=, [VariableReference(final int[] location, []), Expression(new int[2], [])]), MethodCall(target.getLocationOnScreen(location), [VariableReference(target, []), Expression(location, [])]), AssignmentExpression(=, [VariableReference(final Rect rect, []), Expression(new Rect(), [])]), AssignmentExpression(=, [VariableReference(rect.left, []), Expression(location[0], [])]), AssignmentExpression(=, [VariableReference(rect.top, []), Expression(location[1], [])]), AssignmentExpression(=, [VariableReference(rect.right, []), Expression(rect.left + target.getWidth(), [])]), AssignmentExpression(=, [VariableReference(rect.bottom, []), Expression(rect.top + target.getHeight(), [])]), Statement(// Trigger with obtained rectangle, []), Statement(showQuickContact(context, rect, lookupUri, mode, excludeMimes), []), Statement(}, [])])  Statement({, [])  Statement(// Find location and bounds of target view, [])  AssignmentExpression(=, [VariableReference(final int[] location, []), Expression(new int[2], [])])    VariableReference(final int[] location, [])    Expression(new int[2], [])  MethodCall(target.getLocationOnScreen(location), [VariableReference(target, []), Expression(location, [])])    VariableReference(target, [])    Expression(location, [])  AssignmentExpression(=, [VariableReference(final Rect rect, []), Expression(new Rect(), [])])    VariableReference(final Rect rect, [])    Expression(new Rect(), [])  AssignmentExpression(=, [VariableReference(rect.left, []), Expression(location[0], [])])    VariableReference(rect.left, [])    Expression(location[0], [])  AssignmentExpression(=, [VariableReference(rect.top, []), Expression(location[1], [])])    VariableReference(rect.top, [])    Expression(location[1], [])  AssignmentExpression(=, [VariableReference(rect.right, []), Expression(rect.left + target.getWidth(), [])])    VariableReference(rect.right, [])    Expression(rect.left + target.getWidth(), [])  AssignmentExpression(=, [VariableReference(rect.bottom, []), Expression(rect.top + target.getHeight(), [])])    VariableReference(rect.bottom, [])    Expression(rect.top + target.getHeight(), [])  Statement(// Trigger with obtained rectangle, [])  Statement(showQuickContact(context, rect, lookupUri, mode, excludeMimes), [])  Statement(}, [])",0,"/**
 * Trigger a dialog that lists the various methods of interacting with
 * the requested {@link Contacts} entry. This may be based on available
 * {@link Data} rows under that contact, and may also include social
 * status and presence details.
 *
 * @param context The parent {@link Context} that may be used as the
 * parent for this dialog.
 * @param target Specific {@link View} from your layout that this dialog
 * should be centered around. In particular, if the dialog
 * has a ""callout"" arrow, it will be pointed and centered
 * around this {@link View}.
 * @param lookupUri A {@link ContactsContract.Contacts#CONTENT_LOOKUP_URI} style
 * {@link Uri} that describes a specific contact to feature
 * in this dialog.
 * @param mode Any of {@link #MODE_SMALL}, {@link #MODE_MEDIUM}, or
 * {@link #MODE_LARGE}, indicating the desired dialog size,
 * when supported.
 * @param excludeMimes Optional list of {@link Data#MIMETYPE} MIME-types
 * to exclude when showing this dialog. For example, when
 * already viewing the contact details card, this can be used
 * to omit the details entry from the dialog.
 */
","/**
 * Trigger a dialog that lists the various methods of interacting with
 * the requested {@link Contacts} entry. This may be based on available
 * {@link ContactsContract.Data} rows under that contact, and may also
 * include social status and presence details.
 *
 * @param context The parent {@link Context} that may be used as the
 * parent for this dialog.
 * @param target Specific {@link View} from your layout that this dialog
 * should be centered around. In particular, if the dialog
 * has a ""callout"" arrow, it will be pointed and centered
 * around this {@link View}.
 * @param lookupUri A {@link ContactsContract.Contacts#CONTENT_LOOKUP_URI} style
 * {@link Uri} that describes a specific contact to feature
 * in this dialog.
 * @param mode Any of {@link #MODE_SMALL}, {@link #MODE_MEDIUM}, or
 * {@link #MODE_LARGE}, indicating the desired dialog size,
 * when supported.
 * @param excludeMimes Optional list of {@link Data#MIMETYPE} MIME-types
 * to exclude when showing this dialog. For example, when
 * already viewing the contact details card, this can be used
 * to omit the details entry from the dialog.
 */
",1,,,0,,,0,0,0,0,0,0,There is no change in the implementation code of the `showQuickContact` method between the early and late versions.,"The method's behavior remains the same between the two versions, and there is no compatibility issue."
137,<android.webkit.WebView: void shortPressOnTextField()>,6,7,<android.webkit.WebView: void shortPressOnTextField()>,<android.webkit.WebView: void shortPressOnTextField()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(if (inEditingMode()) {, []), AssignmentExpression(=, [VariableReference(View v, []), Expression(mWebTextView, [])]), AssignmentExpression(=, [VariableReference(int x, []), Expression(viewToContentX((v.getLeft() + v.getRight()) >> 1), [])]), AssignmentExpression(=, [VariableReference(int y, []), Expression(viewToContentY((v.getTop() + v.getBottom()) >> 1), [])]), Statement(nativeTextInputMotionUp(x, y), []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(if (inEditingMode()) {, [])  AssignmentExpression(=, [VariableReference(View v, []), Expression(mWebTextView, [])])    VariableReference(View v, [])    Expression(mWebTextView, [])  AssignmentExpression(=, [VariableReference(int x, []), Expression(viewToContentX((v.getLeft() + v.getRight()) >> 1), [])])    VariableReference(int x, [])    Expression(viewToContentX((v.getLeft() + v.getRight()) >> 1), [])  AssignmentExpression(=, [VariableReference(int y, []), Expression(viewToContentY((v.getTop() + v.getBottom()) >> 1), [])])    VariableReference(int y, [])    Expression(viewToContentY((v.getTop() + v.getBottom()) >> 1), [])  Statement(nativeTextInputMotionUp(x, y), [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (inEditingMode()) {, []), AssignmentExpression(=, [VariableReference(View v, []), Expression(mWebTextView, [])]), AssignmentExpression(=, [VariableReference(int x, []), Expression(viewToContentX((v.getLeft() + v.getRight()) >> 1), [])]), AssignmentExpression(=, [VariableReference(int y, []), Expression(viewToContentY((v.getTop() + v.getBottom()) >> 1), [])]), Statement(displaySoftKeyboard(true), []), Statement(nativeTextInputMotionUp(x, y), []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(if (inEditingMode()) {, [])  AssignmentExpression(=, [VariableReference(View v, []), Expression(mWebTextView, [])])    VariableReference(View v, [])    Expression(mWebTextView, [])  AssignmentExpression(=, [VariableReference(int x, []), Expression(viewToContentX((v.getLeft() + v.getRight()) >> 1), [])])    VariableReference(int x, [])    Expression(viewToContentX((v.getLeft() + v.getRight()) >> 1), [])  AssignmentExpression(=, [VariableReference(int y, []), Expression(viewToContentY((v.getTop() + v.getBottom()) >> 1), [])])    VariableReference(int y, [])    Expression(viewToContentY((v.getTop() + v.getBottom()) >> 1), [])  Statement(displaySoftKeyboard(true), [])  Statement(nativeTextInputMotionUp(x, y), [])  Statement(}, [])  Statement(}, [])",1,"/*package*/
","/*package*/
",0,,,0,,,0,2,4,0,4,1,"A new statement ""displaySoftKeyboard(true)"" has been added to the method body of the late version implementation, which is not present in the early version. This statement is not related to return statements, exception handling statements, or control dependency statements. Therefore, the code change type is 4 (Other statement changed).","The newly added statement ""displaySoftKeyboard(true)"" in the late version implementation may cause a different behavior in the application compared to the early version. Specifically, this statement will display the soft keyboard on the screen when the method ""shortPressOnTextField()"" is called. If the application is designed in such a way that it should not display the soft keyboard in response to a short press on a text field, this may lead to a compatibility issue. Therefore, the compatibility issue type is 1 (Compatibility Issue caused by potential different return values or types)."
138,<android.hardware.Camera.Parameters: List<Integer> getSupportedPictureFormats()>,6,7,<android.hardware.Camera.Parameters: List<Integer> getSupportedPictureFormats()>,<android.hardware.Camera.Parameters: List<Integer> getSupportedPictureFormats()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(String str, []), Expression(get(KEY_PICTURE_SIZE + SUPPORTED_VALUES_SUFFIX), [])]), Statement(return splitInt(str), []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(String str, []), Expression(get(KEY_PICTURE_SIZE + SUPPORTED_VALUES_SUFFIX), [])])    VariableReference(String str, [])    Expression(get(KEY_PICTURE_SIZE + SUPPORTED_VALUES_SUFFIX), [])  Statement(return splitInt(str), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(String str, []), Expression(get(KEY_PICTURE_FORMAT + SUPPORTED_VALUES_SUFFIX), [])]), AssignmentExpression(=, [VariableReference(ArrayList<Integer> formats, []), Expression(new ArrayList<Integer>(), [])]), Statement(for (String s : split(str)) {, []), AssignmentExpression(=, [VariableReference(int f, []), Expression(pixelFormatForCameraFormat(s), [])]), AssignmentExpression(=, [VariableReference(if (f, []), Expression(, [])]), Statement(continue, []), MethodCall(formats.add(f), [VariableReference(formats, []), Expression(f, [])]), Statement(}, []), Statement(return formats, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(String str, []), Expression(get(KEY_PICTURE_FORMAT + SUPPORTED_VALUES_SUFFIX), [])])    VariableReference(String str, [])    Expression(get(KEY_PICTURE_FORMAT + SUPPORTED_VALUES_SUFFIX), [])  AssignmentExpression(=, [VariableReference(ArrayList<Integer> formats, []), Expression(new ArrayList<Integer>(), [])])    VariableReference(ArrayList<Integer> formats, [])    Expression(new ArrayList<Integer>(), [])  Statement(for (String s : split(str)) {, [])  AssignmentExpression(=, [VariableReference(int f, []), Expression(pixelFormatForCameraFormat(s), [])])    VariableReference(int f, [])    Expression(pixelFormatForCameraFormat(s), [])  AssignmentExpression(=, [VariableReference(if (f, []), Expression(, [])])    VariableReference(if (f, [])    Expression(, [])  Statement(continue, [])  MethodCall(formats.add(f), [VariableReference(formats, []), Expression(f, [])])    VariableReference(formats, [])    Expression(f, [])  Statement(}, [])  Statement(return formats, [])  Statement(}, [])",1,"/**
 * Gets the supported picture formats.
 *
 * @return a List of Integer objects (values are PixelFormat.XXX). null
 * if picture setting is not supported.
 */
","/**
 * Gets the supported picture formats.
 *
 * @return a List of Integer objects (values are PixelFormat.XXX). This
 * method will always return a list with at least one element.
 */
",1,,,0,,,0,"1,2","1,3,4",1,"1,5","1,2","The return statement has changed from `return splitInt(str);` to `return formats;`. Also, several new statements have been added to process the `str` and populate the `formats` list, including an assignment statement, a for-each loop, an if-statement, and a method call to `formats.add(f);`. These changes are not only related to the return statement but also the control flow and the logic to handle the data, so the code change type is 1,5.","The change in the return statement can cause the API to return a different type of object (from an array of integers to a list of integers), which can lead to compatibility issues in the client code that uses this API. Additionally, the newly added logic to process the `str` and populate the `formats` list can also lead to different behavior in the API. For example, the client code may receive a list with a different order of elements or a different number of elements (e.g., when the `if (f < 0)` condition is met). Therefore, the compatibility issue type is 1,2."
139,<android.webkit.HTML5VideoViewProxy: void handleMessage(Message)>,7,8,<android.webkit.HTML5VideoViewProxy: void handleMessage(Message)>,<android.webkit.HTML5VideoViewProxy: void handleMessage(Message)>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(// This executes on the UI thread., []), Statement(case PLAY:, []), Statement({, []), AssignmentExpression(=, [VariableReference(String url, []), Expression((String) msg.obj, [])]), AssignmentExpression(=, [VariableReference(WebChromeClient client, []), Expression(mWebView.getWebChromeClient(), [])]), AssignmentExpression(=, [VariableReference(if (client !, []), Expression(null) {, [])]), MethodCall(VideoPlayer.play(url, mSeekPosition, this, client), [VariableReference(VideoPlayer, []), Expression(url, []), Expression(mSeekPosition, []), Expression(this, []), Expression(client, [])]), Statement(}, []), Statement(break, []), Statement(}, []), Statement(case SEEK:, []), Statement({, []), AssignmentExpression(=, [VariableReference(Integer time, []), Expression((Integer) msg.obj, [])]), AssignmentExpression(=, [VariableReference(mSeekPosition, []), Expression(time, [])]), MethodCall(VideoPlayer.seek(mSeekPosition, this), [VariableReference(VideoPlayer, []), Expression(mSeekPosition, []), Expression(this, [])]), Statement(break, []), Statement(}, []), Statement(case PAUSE:, []), Statement({, []), MethodCall(VideoPlayer.pause(this), [VariableReference(VideoPlayer, []), Expression(this, [])]), Statement(break, []), Statement(}, []), Statement(case ERROR:, []), Statement({, []), AssignmentExpression(=, [VariableReference(WebChromeClient client, []), Expression(mWebView.getWebChromeClient(), [])]), AssignmentExpression(=, [VariableReference(if (client !, []), Expression(null) {, [])]), MethodCall(client.onHideCustomView(), [VariableReference(client, []), Expression(, [])]), Statement(}, []), Statement(break, []), Statement(}, []), Statement(case LOAD_DEFAULT_POSTER:, []), Statement({, []), AssignmentExpression(=, [VariableReference(WebChromeClient client, []), Expression(mWebView.getWebChromeClient(), [])]), AssignmentExpression(=, [VariableReference(if (client !, []), Expression(null) {, [])]), MethodCall(doSetPoster(client.getDefaultVideoPoster()), [VariableReference(doSetPoster(client, []), Expression(), [])]), Statement(}, []), Statement(break, []), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(// This executes on the UI thread., [])  Statement(case PLAY:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(String url, []), Expression((String) msg.obj, [])])    VariableReference(String url, [])    Expression((String) msg.obj, [])  AssignmentExpression(=, [VariableReference(WebChromeClient client, []), Expression(mWebView.getWebChromeClient(), [])])    VariableReference(WebChromeClient client, [])    Expression(mWebView.getWebChromeClient(), [])  AssignmentExpression(=, [VariableReference(if (client !, []), Expression(null) {, [])])    VariableReference(if (client !, [])    Expression(null) {, [])  MethodCall(VideoPlayer.play(url, mSeekPosition, this, client), [VariableReference(VideoPlayer, []), Expression(url, []), Expression(mSeekPosition, []), Expression(this, []), Expression(client, [])])    VariableReference(VideoPlayer, [])    Expression(url, [])    Expression(mSeekPosition, [])    Expression(this, [])    Expression(client, [])  Statement(}, [])  Statement(break, [])  Statement(}, [])  Statement(case SEEK:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(Integer time, []), Expression((Integer) msg.obj, [])])    VariableReference(Integer time, [])    Expression((Integer) msg.obj, [])  AssignmentExpression(=, [VariableReference(mSeekPosition, []), Expression(time, [])])    VariableReference(mSeekPosition, [])    Expression(time, [])  MethodCall(VideoPlayer.seek(mSeekPosition, this), [VariableReference(VideoPlayer, []), Expression(mSeekPosition, []), Expression(this, [])])    VariableReference(VideoPlayer, [])    Expression(mSeekPosition, [])    Expression(this, [])  Statement(break, [])  Statement(}, [])  Statement(case PAUSE:, [])  Statement({, [])  MethodCall(VideoPlayer.pause(this), [VariableReference(VideoPlayer, []), Expression(this, [])])    VariableReference(VideoPlayer, [])    Expression(this, [])  Statement(break, [])  Statement(}, [])  Statement(case ERROR:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(WebChromeClient client, []), Expression(mWebView.getWebChromeClient(), [])])    VariableReference(WebChromeClient client, [])    Expression(mWebView.getWebChromeClient(), [])  AssignmentExpression(=, [VariableReference(if (client !, []), Expression(null) {, [])])    VariableReference(if (client !, [])    Expression(null) {, [])  MethodCall(client.onHideCustomView(), [VariableReference(client, []), Expression(, [])])    VariableReference(client, [])    Expression(, [])  Statement(}, [])  Statement(break, [])  Statement(}, [])  Statement(case LOAD_DEFAULT_POSTER:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(WebChromeClient client, []), Expression(mWebView.getWebChromeClient(), [])])    VariableReference(WebChromeClient client, [])    Expression(mWebView.getWebChromeClient(), [])  AssignmentExpression(=, [VariableReference(if (client !, []), Expression(null) {, [])])    VariableReference(if (client !, [])    Expression(null) {, [])  MethodCall(doSetPoster(client.getDefaultVideoPoster()), [VariableReference(doSetPoster(client, []), Expression(), [])])    VariableReference(doSetPoster(client, [])    Expression(), [])  Statement(}, [])  Statement(break, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(// This executes on the UI thread., []), Statement(case PLAY:, []), Statement({, []), AssignmentExpression(=, [VariableReference(String url, []), Expression((String) msg.obj, [])]), AssignmentExpression(=, [VariableReference(WebChromeClient client, []), Expression(mWebView.getWebChromeClient(), [])]), AssignmentExpression(=, [VariableReference(if (client !, []), Expression(null) {, [])]), MethodCall(VideoPlayer.play(url, mSeekPosition, this, client), [VariableReference(VideoPlayer, []), Expression(url, []), Expression(mSeekPosition, []), Expression(this, []), Expression(client, [])]), Statement(}, []), Statement(break, []), Statement(}, []), Statement(case SEEK:, []), Statement({, []), AssignmentExpression(=, [VariableReference(Integer time, []), Expression((Integer) msg.obj, [])]), AssignmentExpression(=, [VariableReference(mSeekPosition, []), Expression(time, [])]), MethodCall(VideoPlayer.seek(mSeekPosition, this), [VariableReference(VideoPlayer, []), Expression(mSeekPosition, []), Expression(this, [])]), Statement(break, []), Statement(}, []), Statement(case PAUSE:, []), Statement({, []), MethodCall(VideoPlayer.pause(this), [VariableReference(VideoPlayer, []), Expression(this, [])]), Statement(break, []), Statement(}, []), Statement(case ENDED:, []), Statement(case ERROR:, []), Statement({, []), AssignmentExpression(=, [VariableReference(WebChromeClient client, []), Expression(mWebView.getWebChromeClient(), [])]), AssignmentExpression(=, [VariableReference(if (client !, []), Expression(null) {, [])]), MethodCall(client.onHideCustomView(), [VariableReference(client, []), Expression(, [])]), Statement(}, []), Statement(break, []), Statement(}, []), Statement(case LOAD_DEFAULT_POSTER:, []), Statement({, []), AssignmentExpression(=, [VariableReference(WebChromeClient client, []), Expression(mWebView.getWebChromeClient(), [])]), AssignmentExpression(=, [VariableReference(if (client !, []), Expression(null) {, [])]), MethodCall(doSetPoster(client.getDefaultVideoPoster()), [VariableReference(doSetPoster(client, []), Expression(), [])]), Statement(}, []), Statement(break, []), Statement(}, []), Statement(case TIMEUPDATE:, []), Statement({, []), MethodCall(if (VideoPlayer.isPlaying(this)), [VariableReference(if (VideoPlayer, []), Expression(this), [])]), Statement(sendTimeupdate(), []), Statement(}, []), Statement(break, []), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(// This executes on the UI thread., [])  Statement(case PLAY:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(String url, []), Expression((String) msg.obj, [])])    VariableReference(String url, [])    Expression((String) msg.obj, [])  AssignmentExpression(=, [VariableReference(WebChromeClient client, []), Expression(mWebView.getWebChromeClient(), [])])    VariableReference(WebChromeClient client, [])    Expression(mWebView.getWebChromeClient(), [])  AssignmentExpression(=, [VariableReference(if (client !, []), Expression(null) {, [])])    VariableReference(if (client !, [])    Expression(null) {, [])  MethodCall(VideoPlayer.play(url, mSeekPosition, this, client), [VariableReference(VideoPlayer, []), Expression(url, []), Expression(mSeekPosition, []), Expression(this, []), Expression(client, [])])    VariableReference(VideoPlayer, [])    Expression(url, [])    Expression(mSeekPosition, [])    Expression(this, [])    Expression(client, [])  Statement(}, [])  Statement(break, [])  Statement(}, [])  Statement(case SEEK:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(Integer time, []), Expression((Integer) msg.obj, [])])    VariableReference(Integer time, [])    Expression((Integer) msg.obj, [])  AssignmentExpression(=, [VariableReference(mSeekPosition, []), Expression(time, [])])    VariableReference(mSeekPosition, [])    Expression(time, [])  MethodCall(VideoPlayer.seek(mSeekPosition, this), [VariableReference(VideoPlayer, []), Expression(mSeekPosition, []), Expression(this, [])])    VariableReference(VideoPlayer, [])    Expression(mSeekPosition, [])    Expression(this, [])  Statement(break, [])  Statement(}, [])  Statement(case PAUSE:, [])  Statement({, [])  MethodCall(VideoPlayer.pause(this), [VariableReference(VideoPlayer, []), Expression(this, [])])    VariableReference(VideoPlayer, [])    Expression(this, [])  Statement(break, [])  Statement(}, [])  Statement(case ENDED:, [])  Statement(case ERROR:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(WebChromeClient client, []), Expression(mWebView.getWebChromeClient(), [])])    VariableReference(WebChromeClient client, [])    Expression(mWebView.getWebChromeClient(), [])  AssignmentExpression(=, [VariableReference(if (client !, []), Expression(null) {, [])])    VariableReference(if (client !, [])    Expression(null) {, [])  MethodCall(client.onHideCustomView(), [VariableReference(client, []), Expression(, [])])    VariableReference(client, [])    Expression(, [])  Statement(}, [])  Statement(break, [])  Statement(}, [])  Statement(case LOAD_DEFAULT_POSTER:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(WebChromeClient client, []), Expression(mWebView.getWebChromeClient(), [])])    VariableReference(WebChromeClient client, [])    Expression(mWebView.getWebChromeClient(), [])  AssignmentExpression(=, [VariableReference(if (client !, []), Expression(null) {, [])])    VariableReference(if (client !, [])    Expression(null) {, [])  MethodCall(doSetPoster(client.getDefaultVideoPoster()), [VariableReference(doSetPoster(client, []), Expression(), [])])    VariableReference(doSetPoster(client, [])    Expression(), [])  Statement(}, [])  Statement(break, [])  Statement(}, [])  Statement(case TIMEUPDATE:, [])  Statement({, [])  MethodCall(if (VideoPlayer.isPlaying(this)), [VariableReference(if (VideoPlayer, []), Expression(this), [])])    VariableReference(if (VideoPlayer, [])    Expression(this), [])  Statement(sendTimeupdate(), [])  Statement(}, [])  Statement(break, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])",1,"// Handler for the messages from WebCore thread to the UI thread.
","// Handler for the messages from WebCore or Timer thread to the UI thread.
",1,[@Override],[@Override],0,,,0,"1,2",3,0,"3,5","1,2",The code change between the two versions is a combination of 3) Control dependency changed and 5) Dependent API changed.,
140,<android.webkit.HTML5VideoViewProxy: void handleMessage(Message)>,8,9,<android.webkit.HTML5VideoViewProxy: void handleMessage(Message)>,<android.webkit.HTML5VideoViewProxy: void handleMessage(Message)>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(// This executes on the UI thread., []), Statement(case PLAY:, []), Statement({, []), AssignmentExpression(=, [VariableReference(String url, []), Expression((String) msg.obj, [])]), AssignmentExpression(=, [VariableReference(WebChromeClient client, []), Expression(mWebView.getWebChromeClient(), [])]), AssignmentExpression(=, [VariableReference(if (client !, []), Expression(null) {, [])]), MethodCall(VideoPlayer.play(url, mSeekPosition, this, client), [VariableReference(VideoPlayer, []), Expression(url, []), Expression(mSeekPosition, []), Expression(this, []), Expression(client, [])]), Statement(}, []), Statement(break, []), Statement(}, []), Statement(case SEEK:, []), Statement({, []), AssignmentExpression(=, [VariableReference(Integer time, []), Expression((Integer) msg.obj, [])]), AssignmentExpression(=, [VariableReference(mSeekPosition, []), Expression(time, [])]), MethodCall(VideoPlayer.seek(mSeekPosition, this), [VariableReference(VideoPlayer, []), Expression(mSeekPosition, []), Expression(this, [])]), Statement(break, []), Statement(}, []), Statement(case PAUSE:, []), Statement({, []), MethodCall(VideoPlayer.pause(this), [VariableReference(VideoPlayer, []), Expression(this, [])]), Statement(break, []), Statement(}, []), Statement(case ENDED:, []), Statement(case ERROR:, []), Statement({, []), AssignmentExpression(=, [VariableReference(WebChromeClient client, []), Expression(mWebView.getWebChromeClient(), [])]), AssignmentExpression(=, [VariableReference(if (client !, []), Expression(null) {, [])]), MethodCall(client.onHideCustomView(), [VariableReference(client, []), Expression(, [])]), Statement(}, []), Statement(break, []), Statement(}, []), Statement(case LOAD_DEFAULT_POSTER:, []), Statement({, []), AssignmentExpression(=, [VariableReference(WebChromeClient client, []), Expression(mWebView.getWebChromeClient(), [])]), AssignmentExpression(=, [VariableReference(if (client !, []), Expression(null) {, [])]), MethodCall(doSetPoster(client.getDefaultVideoPoster()), [VariableReference(doSetPoster(client, []), Expression(), [])]), Statement(}, []), Statement(break, []), Statement(}, []), Statement(case TIMEUPDATE:, []), Statement({, []), MethodCall(if (VideoPlayer.isPlaying(this)), [VariableReference(if (VideoPlayer, []), Expression(this), [])]), Statement(sendTimeupdate(), []), Statement(}, []), Statement(break, []), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(// This executes on the UI thread., [])  Statement(case PLAY:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(String url, []), Expression((String) msg.obj, [])])    VariableReference(String url, [])    Expression((String) msg.obj, [])  AssignmentExpression(=, [VariableReference(WebChromeClient client, []), Expression(mWebView.getWebChromeClient(), [])])    VariableReference(WebChromeClient client, [])    Expression(mWebView.getWebChromeClient(), [])  AssignmentExpression(=, [VariableReference(if (client !, []), Expression(null) {, [])])    VariableReference(if (client !, [])    Expression(null) {, [])  MethodCall(VideoPlayer.play(url, mSeekPosition, this, client), [VariableReference(VideoPlayer, []), Expression(url, []), Expression(mSeekPosition, []), Expression(this, []), Expression(client, [])])    VariableReference(VideoPlayer, [])    Expression(url, [])    Expression(mSeekPosition, [])    Expression(this, [])    Expression(client, [])  Statement(}, [])  Statement(break, [])  Statement(}, [])  Statement(case SEEK:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(Integer time, []), Expression((Integer) msg.obj, [])])    VariableReference(Integer time, [])    Expression((Integer) msg.obj, [])  AssignmentExpression(=, [VariableReference(mSeekPosition, []), Expression(time, [])])    VariableReference(mSeekPosition, [])    Expression(time, [])  MethodCall(VideoPlayer.seek(mSeekPosition, this), [VariableReference(VideoPlayer, []), Expression(mSeekPosition, []), Expression(this, [])])    VariableReference(VideoPlayer, [])    Expression(mSeekPosition, [])    Expression(this, [])  Statement(break, [])  Statement(}, [])  Statement(case PAUSE:, [])  Statement({, [])  MethodCall(VideoPlayer.pause(this), [VariableReference(VideoPlayer, []), Expression(this, [])])    VariableReference(VideoPlayer, [])    Expression(this, [])  Statement(break, [])  Statement(}, [])  Statement(case ENDED:, [])  Statement(case ERROR:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(WebChromeClient client, []), Expression(mWebView.getWebChromeClient(), [])])    VariableReference(WebChromeClient client, [])    Expression(mWebView.getWebChromeClient(), [])  AssignmentExpression(=, [VariableReference(if (client !, []), Expression(null) {, [])])    VariableReference(if (client !, [])    Expression(null) {, [])  MethodCall(client.onHideCustomView(), [VariableReference(client, []), Expression(, [])])    VariableReference(client, [])    Expression(, [])  Statement(}, [])  Statement(break, [])  Statement(}, [])  Statement(case LOAD_DEFAULT_POSTER:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(WebChromeClient client, []), Expression(mWebView.getWebChromeClient(), [])])    VariableReference(WebChromeClient client, [])    Expression(mWebView.getWebChromeClient(), [])  AssignmentExpression(=, [VariableReference(if (client !, []), Expression(null) {, [])])    VariableReference(if (client !, [])    Expression(null) {, [])  MethodCall(doSetPoster(client.getDefaultVideoPoster()), [VariableReference(doSetPoster(client, []), Expression(), [])])    VariableReference(doSetPoster(client, [])    Expression(), [])  Statement(}, [])  Statement(break, [])  Statement(}, [])  Statement(case TIMEUPDATE:, [])  Statement({, [])  MethodCall(if (VideoPlayer.isPlaying(this)), [VariableReference(if (VideoPlayer, []), Expression(this), [])])    VariableReference(if (VideoPlayer, [])    Expression(this), [])  Statement(sendTimeupdate(), [])  Statement(}, [])  Statement(break, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(// This executes on the UI thread., []), Statement(case PLAY:, []), Statement({, []), AssignmentExpression(=, [VariableReference(String url, []), Expression((String) msg.obj, [])]), AssignmentExpression(=, [VariableReference(WebChromeClient client, []), Expression(mWebView.getWebChromeClient(), [])]), AssignmentExpression(=, [VariableReference(if (client !, []), Expression(null) {, [])]), MethodCall(VideoPlayer.play(url, mSeekPosition, this, client), [VariableReference(VideoPlayer, []), Expression(url, []), Expression(mSeekPosition, []), Expression(this, []), Expression(client, [])]), Statement(}, []), Statement(break, []), Statement(}, []), Statement(case SEEK:, []), Statement({, []), AssignmentExpression(=, [VariableReference(Integer time, []), Expression((Integer) msg.obj, [])]), AssignmentExpression(=, [VariableReference(mSeekPosition, []), Expression(time, [])]), MethodCall(VideoPlayer.seek(mSeekPosition, this), [VariableReference(VideoPlayer, []), Expression(mSeekPosition, []), Expression(this, [])]), Statement(break, []), Statement(}, []), Statement(case PAUSE:, []), Statement({, []), MethodCall(VideoPlayer.pause(this), [VariableReference(VideoPlayer, []), Expression(this, [])]), Statement(break, []), Statement(}, []), Statement(case ENDED:, []), AssignmentExpression(=, [VariableReference(if (msg.arg1, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(VideoPlayer.isVideoSelfEnded, []), Expression(true, [])]), Statement(case ERROR:, []), Statement({, []), AssignmentExpression(=, [VariableReference(WebChromeClient client, []), Expression(mWebView.getWebChromeClient(), [])]), AssignmentExpression(=, [VariableReference(if (client !, []), Expression(null) {, [])]), MethodCall(client.onHideCustomView(), [VariableReference(client, []), Expression(, [])]), Statement(}, []), Statement(break, []), Statement(}, []), Statement(case LOAD_DEFAULT_POSTER:, []), Statement({, []), AssignmentExpression(=, [VariableReference(WebChromeClient client, []), Expression(mWebView.getWebChromeClient(), [])]), AssignmentExpression(=, [VariableReference(if (client !, []), Expression(null) {, [])]), MethodCall(doSetPoster(client.getDefaultVideoPoster()), [VariableReference(doSetPoster(client, []), Expression(), [])]), Statement(}, []), Statement(break, []), Statement(}, []), Statement(case TIMEUPDATE:, []), Statement({, []), MethodCall(if (VideoPlayer.isPlaying(this)), [VariableReference(if (VideoPlayer, []), Expression(this), [])]), Statement(sendTimeupdate(), []), Statement(}, []), Statement(break, []), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(// This executes on the UI thread., [])  Statement(case PLAY:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(String url, []), Expression((String) msg.obj, [])])    VariableReference(String url, [])    Expression((String) msg.obj, [])  AssignmentExpression(=, [VariableReference(WebChromeClient client, []), Expression(mWebView.getWebChromeClient(), [])])    VariableReference(WebChromeClient client, [])    Expression(mWebView.getWebChromeClient(), [])  AssignmentExpression(=, [VariableReference(if (client !, []), Expression(null) {, [])])    VariableReference(if (client !, [])    Expression(null) {, [])  MethodCall(VideoPlayer.play(url, mSeekPosition, this, client), [VariableReference(VideoPlayer, []), Expression(url, []), Expression(mSeekPosition, []), Expression(this, []), Expression(client, [])])    VariableReference(VideoPlayer, [])    Expression(url, [])    Expression(mSeekPosition, [])    Expression(this, [])    Expression(client, [])  Statement(}, [])  Statement(break, [])  Statement(}, [])  Statement(case SEEK:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(Integer time, []), Expression((Integer) msg.obj, [])])    VariableReference(Integer time, [])    Expression((Integer) msg.obj, [])  AssignmentExpression(=, [VariableReference(mSeekPosition, []), Expression(time, [])])    VariableReference(mSeekPosition, [])    Expression(time, [])  MethodCall(VideoPlayer.seek(mSeekPosition, this), [VariableReference(VideoPlayer, []), Expression(mSeekPosition, []), Expression(this, [])])    VariableReference(VideoPlayer, [])    Expression(mSeekPosition, [])    Expression(this, [])  Statement(break, [])  Statement(}, [])  Statement(case PAUSE:, [])  Statement({, [])  MethodCall(VideoPlayer.pause(this), [VariableReference(VideoPlayer, []), Expression(this, [])])    VariableReference(VideoPlayer, [])    Expression(this, [])  Statement(break, [])  Statement(}, [])  Statement(case ENDED:, [])  AssignmentExpression(=, [VariableReference(if (msg.arg1, []), Expression(, [])])    VariableReference(if (msg.arg1, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(VideoPlayer.isVideoSelfEnded, []), Expression(true, [])])    VariableReference(VideoPlayer.isVideoSelfEnded, [])    Expression(true, [])  Statement(case ERROR:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(WebChromeClient client, []), Expression(mWebView.getWebChromeClient(), [])])    VariableReference(WebChromeClient client, [])    Expression(mWebView.getWebChromeClient(), [])  AssignmentExpression(=, [VariableReference(if (client !, []), Expression(null) {, [])])    VariableReference(if (client !, [])    Expression(null) {, [])  MethodCall(client.onHideCustomView(), [VariableReference(client, []), Expression(, [])])    VariableReference(client, [])    Expression(, [])  Statement(}, [])  Statement(break, [])  Statement(}, [])  Statement(case LOAD_DEFAULT_POSTER:, [])  Statement({, [])  AssignmentExpression(=, [VariableReference(WebChromeClient client, []), Expression(mWebView.getWebChromeClient(), [])])    VariableReference(WebChromeClient client, [])    Expression(mWebView.getWebChromeClient(), [])  AssignmentExpression(=, [VariableReference(if (client !, []), Expression(null) {, [])])    VariableReference(if (client !, [])    Expression(null) {, [])  MethodCall(doSetPoster(client.getDefaultVideoPoster()), [VariableReference(doSetPoster(client, []), Expression(), [])])    VariableReference(doSetPoster(client, [])    Expression(), [])  Statement(}, [])  Statement(break, [])  Statement(}, [])  Statement(case TIMEUPDATE:, [])  Statement({, [])  MethodCall(if (VideoPlayer.isPlaying(this)), [VariableReference(if (VideoPlayer, []), Expression(this), [])])    VariableReference(if (VideoPlayer, [])    Expression(this), [])  Statement(sendTimeupdate(), [])  Statement(}, [])  Statement(break, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])",1,"// Handler for the messages from WebCore or Timer thread to the UI thread.
","// Handler for the messages from WebCore or Timer thread to the UI thread.
",0,[@Override],[@Override],0,,,0,1,"3,4",0,"1,2",1,"In the late version, the ""ENDED"" case in the switch statement has been modified. The new code assigns a value to ""if (msg.arg1)"" and sets ""VideoPlayer.isVideoSelfEnded"" to true. These changes were not present in the early version.","The Compatibility Issue arises due to the modification of the ""ENDED"" case in the late version. The new code assigns a value to ""if (msg.arg1)"" and sets ""VideoPlayer.isVideoSelfEnded"" to true. These changes can potentially lead to different behavior in the application, as the value of ""if (msg.arg1)"" and ""VideoPlayer.isVideoSelfEnded"" can affect the logic of the program."
141,"<android.content.ContentProvider: int bulkInsert(Uri,ContentValues[])>",8,9,"<android.content.ContentProvider: int bulkInsert(Uri,ContentValues[])>","<android.content.ContentProvider: int bulkInsert(Uri,ContentValues[])>",0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(int numValues, []), Expression(values.length, [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < numValues, []), Statement(i++) {, []), Statement(insert(uri, values[i]), []), Statement(}, []), Statement(return numValues, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(int numValues, []), Expression(values.length, [])])    VariableReference(int numValues, [])    Expression(values.length, [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < numValues, [])  Statement(i++) {, [])  Statement(insert(uri, values[i]), [])  Statement(}, [])  Statement(return numValues, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(int numValues, []), Expression(values.length, [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < numValues, []), Statement(i++) {, []), Statement(insert(uri, values[i]), []), Statement(}, []), Statement(return numValues, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(int numValues, []), Expression(values.length, [])])    VariableReference(int numValues, [])    Expression(values.length, [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < numValues, [])  Statement(i++) {, [])  Statement(insert(uri, values[i]), [])  Statement(}, [])  Statement(return numValues, [])  Statement(}, [])",0,"/**
 * Implement this to insert a set of new rows, or the default implementation will
 * iterate over the values and call {@link #insert} on each of them.
 * As a courtesy, call {@link ContentResolver#notifyChange(android.net.Uri ,android.database.ContentObserver) notifyChange()}
 * after inserting.
 * This method can be called from multiple
 * threads, as described in
 * <a href=""{@docRoot}guide/topics/fundamentals.html#procthread"">Application Fundamentals:
 * Processes and Threads</a>.
 *
 * @param uri The content:// URI of the insertion request.
 * @param values An array of sets of column_name/value pairs to add to the database.
 * @return The number of values that were inserted.
 */
","/**
 * Override this to handle requests to insert a set of new rows, or the
 * default implementation will iterate over the values and call
 * {@link #insert} on each of them.
 * As a courtesy, call {@link ContentResolver#notifyChange(android.net.Uri ,android.database.ContentObserver) notifyChange()}
 * after inserting.
 * This method can be called from multiple threads, as described in
 * <a href=""{@docRoot}guide/topics/fundamentals.html#procthread"">Application Fundamentals:
 * Processes and Threads</a>.
 *
 * @param uri The content:// URI of the insertion request.
 * @param values An array of sets of column_name/value pairs to add to the database.
 * @return The number of values that were inserted.
 */
",1,,,0,,,0,0,0,0,0,0,The given implementation AST nodes and comments for the API in the early and late versions are the same. There is no code change between the two versions.,"As there is no code change between the two versions, no Compatibility Issue exists for the API."
142,<android.widget.ProgressBar: boolean isIndeterminate()>,8,9,<android.widget.ProgressBar: boolean isIndeterminate()>,<android.widget.ProgressBar: boolean isIndeterminate()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(return mIndeterminate, []), Statement(}, [])])  Statement({, [])  Statement(return mIndeterminate, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return mIndeterminate, []), Statement(}, [])])  Statement({, [])  Statement(return mIndeterminate, [])  Statement(}, [])",0,"/**
 * <p>Indicate whether this progress bar is in indeterminate mode.</p>
 *
 * @return true if the progress bar is in indeterminate mode
 */
","/**
 * <p>Indicate whether this progress bar is in indeterminate mode.</p>
 *
 * @return true if the progress bar is in indeterminate mode
 */
",0,[@ViewDebug.ExportedProperty],[@ViewDebug.ExportedProperty(category = "progress")],1,,,0,0,0,0,5,0,The annotation of the method `isIndeterminate()` has been changed from `@ViewDebug.ExportedProperty` to `@ViewDebug.ExportedProperty(category = "progress")`.,"The change in the annotation doesn't affect the behavior of the method, hence there is no compatibility issue."
143,<android.app.Activity: void performStop()>,9,10,<android.app.Activity: void performStop()>,<android.app.Activity: void performStop()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(if (!mStopped) {, []), AssignmentExpression(=, [VariableReference(if (mWindow !, []), Expression(null) {, [])]), MethodCall(mWindow.closeAllPanels(), [VariableReference(mWindow, []), Expression(, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(mCalled, []), Expression(false, [])]), MethodCall(mInstrumentation.callActivityOnStop(this), [VariableReference(mInstrumentation, []), Expression(this, [])]), Statement(if (!mCalled) {, []), MethodCall(throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onStop()""), [VariableReference(throw new SuperNotCalledException(""Activity "" + mComponent, []), Expression() + "" did not call through to super.onStop()"", [])]), Statement(}, []), Statement(synchronized (mManagedCursors) {, []), AssignmentExpression(=, [VariableReference(final int N, []), Expression(mManagedCursors.size(), [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < N, []), Statement(i++) {, []), AssignmentExpression(=, [VariableReference(ManagedCursor mc, []), Expression(mManagedCursors.get(i), [])]), AssignmentExpression(=, [VariableReference(mc.mReleased, []), Expression(true, [])]), Statement(}, []), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(mStopped, []), Expression(true, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(mResumed, []), Expression(false, [])]), Statement(}, [])])  Statement({, [])  Statement(if (!mStopped) {, [])  AssignmentExpression(=, [VariableReference(if (mWindow !, []), Expression(null) {, [])])    VariableReference(if (mWindow !, [])    Expression(null) {, [])  MethodCall(mWindow.closeAllPanels(), [VariableReference(mWindow, []), Expression(, [])])    VariableReference(mWindow, [])    Expression(, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mCalled, []), Expression(false, [])])    VariableReference(mCalled, [])    Expression(false, [])  MethodCall(mInstrumentation.callActivityOnStop(this), [VariableReference(mInstrumentation, []), Expression(this, [])])    VariableReference(mInstrumentation, [])    Expression(this, [])  Statement(if (!mCalled) {, [])  MethodCall(throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onStop()""), [VariableReference(throw new SuperNotCalledException(""Activity "" + mComponent, []), Expression() + "" did not call through to super.onStop()"", [])])    VariableReference(throw new SuperNotCalledException(""Activity "" + mComponent, [])    Expression() + "" did not call through to super.onStop()"", [])  Statement(}, [])  Statement(synchronized (mManagedCursors) {, [])  AssignmentExpression(=, [VariableReference(final int N, []), Expression(mManagedCursors.size(), [])])    VariableReference(final int N, [])    Expression(mManagedCursors.size(), [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < N, [])  Statement(i++) {, [])  AssignmentExpression(=, [VariableReference(ManagedCursor mc, []), Expression(mManagedCursors.get(i), [])])    VariableReference(ManagedCursor mc, [])    Expression(mManagedCursors.get(i), [])  AssignmentExpression(=, [VariableReference(mc.mReleased, []), Expression(true, [])])    VariableReference(mc.mReleased, [])    Expression(true, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mStopped, []), Expression(true, [])])    VariableReference(mStopped, [])    Expression(true, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mResumed, []), Expression(false, [])])    VariableReference(mResumed, [])    Expression(false, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (!mStopped) {, []), AssignmentExpression(=, [VariableReference(if (mWindow !, []), Expression(null) {, [])]), MethodCall(mWindow.closeAllPanels(), [VariableReference(mWindow, []), Expression(, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(mCalled, []), Expression(false, [])]), MethodCall(mInstrumentation.callActivityOnStop(this), [VariableReference(mInstrumentation, []), Expression(this, [])]), Statement(if (!mCalled) {, []), MethodCall(throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onStop()""), [VariableReference(throw new SuperNotCalledException(""Activity "" + mComponent, []), Expression() + "" did not call through to super.onStop()"", [])]), Statement(}, []), Statement(synchronized (mManagedCursors) {, []), AssignmentExpression(=, [VariableReference(final int N, []), Expression(mManagedCursors.size(), [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < N, []), Statement(i++) {, []), AssignmentExpression(=, [VariableReference(ManagedCursor mc, []), Expression(mManagedCursors.get(i), [])]), AssignmentExpression(=, [VariableReference(mc.mReleased, []), Expression(true, [])]), Statement(}, []), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(mStopped, []), Expression(true, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(if (!mStopped) {, [])  AssignmentExpression(=, [VariableReference(if (mWindow !, []), Expression(null) {, [])])    VariableReference(if (mWindow !, [])    Expression(null) {, [])  MethodCall(mWindow.closeAllPanels(), [VariableReference(mWindow, []), Expression(, [])])    VariableReference(mWindow, [])    Expression(, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mCalled, []), Expression(false, [])])    VariableReference(mCalled, [])    Expression(false, [])  MethodCall(mInstrumentation.callActivityOnStop(this), [VariableReference(mInstrumentation, []), Expression(this, [])])    VariableReference(mInstrumentation, [])    Expression(this, [])  Statement(if (!mCalled) {, [])  MethodCall(throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onStop()""), [VariableReference(throw new SuperNotCalledException(""Activity "" + mComponent, []), Expression() + "" did not call through to super.onStop()"", [])])    VariableReference(throw new SuperNotCalledException(""Activity "" + mComponent, [])    Expression() + "" did not call through to super.onStop()"", [])  Statement(}, [])  Statement(synchronized (mManagedCursors) {, [])  AssignmentExpression(=, [VariableReference(final int N, []), Expression(mManagedCursors.size(), [])])    VariableReference(final int N, [])    Expression(mManagedCursors.size(), [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < N, [])  Statement(i++) {, [])  AssignmentExpression(=, [VariableReference(ManagedCursor mc, []), Expression(mManagedCursors.get(i), [])])    VariableReference(ManagedCursor mc, [])    Expression(mManagedCursors.get(i), [])  AssignmentExpression(=, [VariableReference(mc.mReleased, []), Expression(true, [])])    VariableReference(mc.mReleased, [])    Expression(true, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mStopped, []), Expression(true, [])])    VariableReference(mStopped, [])    Expression(true, [])  Statement(}, [])  Statement(}, [])",1,,,0,,,0,,,0,1,4,0,0,0,"The ASTs of the two versions of the method performStop() in the class android.app.Activity are identical, so there is no code change.","Since there is no code change, there is no Compatibility Issue (CI) exist."
144,"<android.database.sqlite.SQLiteDatabase: long replaceOrThrow(String,String,ContentValues)>",9,10,"<android.database.sqlite.SQLiteDatabase: long replaceOrThrow(String,String,ContentValues)>","<android.database.sqlite.SQLiteDatabase: long replaceOrThrow(String,String,ContentValues)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(return insertWithOnConflict(table, nullColumnHack, initialValues, CONFLICT_REPLACE), []), Statement(}, [])])  Statement({, [])  Statement(return insertWithOnConflict(table, nullColumnHack, initialValues, CONFLICT_REPLACE), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return insertWithOnConflict(table, nullColumnHack, initialValues, CONFLICT_REPLACE), []), Statement(}, [])])  Statement({, [])  Statement(return insertWithOnConflict(table, nullColumnHack, initialValues, CONFLICT_REPLACE), [])  Statement(}, [])",0,"/**
 * Convenience method for replacing a row in the database.
 *
 * @param table the table in which to replace the row
 * @param nullColumnHack SQL doesn't allow inserting a completely empty row,
 * so if initialValues is empty this row will explicitly be
 * assigned a NULL value
 * @param initialValues this map contains the initial column values for
 * the row. The key
 * @throws SQLException
 * @return the row ID of the newly inserted row, or -1 if an error occurred
 */
","/**
 * Convenience method for replacing a row in the database.
 *
 * @param table the table in which to replace the row
 * @param nullColumnHack optional; may be <code>null</code>.
 * SQL doesn't allow inserting a completely empty row without
 * naming at least one column name.  If your provided <code>initialValues</code> is
 * empty, no column names are known and an empty row can't be inserted.
 * If not set to null, the <code>nullColumnHack</code> parameter
 * provides the name of nullable column name to explicitly insert a NULL into
 * in the case where your <code>initialValues</code> is empty.
 * @param initialValues this map contains the initial column values for
 * the row. The key
 * @throws SQLException
 * @return the row ID of the newly inserted row, or -1 if an error occurred
 */
",1,,,0,,,0,0,0,0,1,1,"The implementation of the method `replaceOrThrow` has not changed between the two versions. However, there is a change in the comment for the `nullColumnHack` parameter. In the early version, it is mentioned that if `initialValues` is empty, this row will explicitly be assigned a NULL value. In the late version, it is mentioned that if `initialValues` is empty, no column names are known and an empty row can't be inserted. If not set to null, the `nullColumnHack` parameter provides the name of nullable column name to explicitly insert a NULL into in the case where `initialValues` is empty. This change in the comment may suggest a change in the behavior of the method, but it is not reflected in the implementation. Therefore, the code change type is 1 (Return statement changed).","The change in the comment for the `nullColumnHack` parameter may suggest a change in the behavior of the method `replaceOrThrow`. In the early version, it is mentioned that if `initialValues` is empty, this row will explicitly be assigned a NULL value. In the late version, it is mentioned that if `initialValues` is empty, no column names are known and an empty row can't be inserted. If not set to null, the `nullColumnHack` parameter provides the name of nullable column name to explicitly insert a NULL into in the case where `initialValues` is empty. This change in the comment may lead to developers using the method differently, expecting a different behavior, and therefore may cause a Compatibility Issue (CI). The CI type is 1 (Compatibility Issue caused by potential different return values or types)."
145,<android.widget.AbsListView: void hideSelector()>,13,14,<android.widget.AbsListView: void hideSelector()>,<android.widget.AbsListView: void hideSelector()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mSelectedPosition !, []), Expression(INVALID_POSITION) {, [])]), AssignmentExpression(=, [VariableReference(if (mLayoutMode !, []), Expression(LAYOUT_SPECIFIC) {, [])]), AssignmentExpression(=, [VariableReference(mResurrectToPosition, []), Expression(mSelectedPosition, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mNextSelectedPosition >, []), Expression(0 && mNextSelectedPosition !, [])]), AssignmentExpression(=, [VariableReference(mResurrectToPosition, []), Expression(mNextSelectedPosition, [])]), Statement(}, []), Statement(setSelectedPositionInt(INVALID_POSITION), []), Statement(setNextSelectedPositionInt(INVALID_POSITION), []), AssignmentExpression(=, [VariableReference(mSelectedTop, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(mSelectorShowing, []), Expression(false, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mSelectedPosition !, []), Expression(INVALID_POSITION) {, [])])    VariableReference(if (mSelectedPosition !, [])    Expression(INVALID_POSITION) {, [])  AssignmentExpression(=, [VariableReference(if (mLayoutMode !, []), Expression(LAYOUT_SPECIFIC) {, [])])    VariableReference(if (mLayoutMode !, [])    Expression(LAYOUT_SPECIFIC) {, [])  AssignmentExpression(=, [VariableReference(mResurrectToPosition, []), Expression(mSelectedPosition, [])])    VariableReference(mResurrectToPosition, [])    Expression(mSelectedPosition, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mNextSelectedPosition >, []), Expression(0 && mNextSelectedPosition !, [])])    VariableReference(if (mNextSelectedPosition >, [])    Expression(0 && mNextSelectedPosition !, [])  AssignmentExpression(=, [VariableReference(mResurrectToPosition, []), Expression(mNextSelectedPosition, [])])    VariableReference(mResurrectToPosition, [])    Expression(mNextSelectedPosition, [])  Statement(}, [])  Statement(setSelectedPositionInt(INVALID_POSITION), [])  Statement(setNextSelectedPositionInt(INVALID_POSITION), [])  AssignmentExpression(=, [VariableReference(mSelectedTop, []), Expression(0, [])])    VariableReference(mSelectedTop, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(mSelectorShowing, []), Expression(false, [])])    VariableReference(mSelectorShowing, [])    Expression(false, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mSelectedPosition !, []), Expression(INVALID_POSITION) {, [])]), AssignmentExpression(=, [VariableReference(if (mLayoutMode !, []), Expression(LAYOUT_SPECIFIC) {, [])]), AssignmentExpression(=, [VariableReference(mResurrectToPosition, []), Expression(mSelectedPosition, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mNextSelectedPosition >, []), Expression(0 && mNextSelectedPosition !, [])]), AssignmentExpression(=, [VariableReference(mResurrectToPosition, []), Expression(mNextSelectedPosition, [])]), Statement(}, []), Statement(setSelectedPositionInt(INVALID_POSITION), []), Statement(setNextSelectedPositionInt(INVALID_POSITION), []), AssignmentExpression(=, [VariableReference(mSelectedTop, []), Expression(0, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mSelectedPosition !, []), Expression(INVALID_POSITION) {, [])])    VariableReference(if (mSelectedPosition !, [])    Expression(INVALID_POSITION) {, [])  AssignmentExpression(=, [VariableReference(if (mLayoutMode !, []), Expression(LAYOUT_SPECIFIC) {, [])])    VariableReference(if (mLayoutMode !, [])    Expression(LAYOUT_SPECIFIC) {, [])  AssignmentExpression(=, [VariableReference(mResurrectToPosition, []), Expression(mSelectedPosition, [])])    VariableReference(mResurrectToPosition, [])    Expression(mSelectedPosition, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mNextSelectedPosition >, []), Expression(0 && mNextSelectedPosition !, [])])    VariableReference(if (mNextSelectedPosition >, [])    Expression(0 && mNextSelectedPosition !, [])  AssignmentExpression(=, [VariableReference(mResurrectToPosition, []), Expression(mNextSelectedPosition, [])])    VariableReference(mResurrectToPosition, [])    Expression(mNextSelectedPosition, [])  Statement(}, [])  Statement(setSelectedPositionInt(INVALID_POSITION), [])  Statement(setNextSelectedPositionInt(INVALID_POSITION), [])  AssignmentExpression(=, [VariableReference(mSelectedTop, []), Expression(0, [])])    VariableReference(mSelectedTop, [])    Expression(0, [])  Statement(}, [])  Statement(}, [])",1,,,0,,,0,,,0,1,4,0,0,0,The given AST nodes for the early and late versions of the method `hideSelector()` in the class `AbsListView` are identical. No changes have been made between the two versions.,"Since no changes have been made between the two versions, there are no compatibility issues that could arise from using this method in either version."
146,"<android.database.CursorWindow: String getString(int,int)>",13,14,"<android.database.CursorWindow: String getString(int,int)>","<android.database.CursorWindow: String getString(int,int)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(acquireReference(), []), Statement(try {, []), Statement(return getString_native(row - mStartPos, col), []), Statement(} finally {, []), Statement(releaseReference(), []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(acquireReference(), [])  Statement(try {, [])  Statement(return getString_native(row - mStartPos, col), [])  Statement(} finally {, [])  Statement(releaseReference(), [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(acquireReference(), []), Statement(try {, []), Statement(return nativeGetString(mWindowPtr, row - mStartPos, column), []), Statement(} finally {, []), Statement(releaseReference(), []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(acquireReference(), [])  Statement(try {, [])  Statement(return nativeGetString(mWindowPtr, row - mStartPos, column), [])  Statement(} finally {, [])  Statement(releaseReference(), [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Returns a String for the given field.
 *
 * @param row the row to read from, row - getStartPosition() being the actual row in the window
 * @param col the column to read from
 * @return a String value for the given field
 */
","/**
 * Gets the value of the field at the specified row and column index as a string.
 * <p>
 * The result is determined as follows:
 * <ul>
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_NULL}, then the result
 * is <code>null</code>.</li>
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_STRING}, then the result
 * is the string value.</li>
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_INTEGER}, then the result
 * is a string representation of the integer in decimal, obtained by formatting the
 * value with the <code>printf</code> family of functions using
 * format specifier <code>%lld</code>.</li>
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_FLOAT}, then the result
 * is a string representation of the floating-point value in decimal, obtained by
 * formatting the value with the <code>printf</code> family of functions using
 * format specifier <code>%g</code>.</li>
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_BLOB}, then a
 * {@link SQLiteException} is thrown.</li>
 * </ul>
 * </p>
 *
 * @param row The zero-based row index, relative to the cursor window's
 * start position ({@link #getStartPosition()}).
 * @param column The zero-based column index.
 * @return The value of the field as a string.
 */
",1,,,0,,,0,"1,2","1,5",1,1,1,"The return statement in the method has changed from `return getString_native(row - mStartPos, col)` to `return nativeGetString(mWindowPtr, row - mStartPos, column)`. This means that the method is now using a different native method to retrieve the string value.","The change in the native method used to retrieve the string value could potentially lead to different behavior in the method. For example, the new native method might handle null or missing values differently, or it might return the string in a different format. This could cause compatibility issues if the method is being used in a way that assumes the old behavior."
147,<android.view.View: boolean dispatchHoverEvent(MotionEvent)>,14,15,<android.view.View: boolean dispatchHoverEvent(MotionEvent)>,<android.view.View: boolean dispatchHoverEvent(MotionEvent)>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(// noinspection SimplifiableIfStatement, []), AssignmentExpression(=, [VariableReference(if (mOnHoverListener !, []), Expression(null && (mViewFlags & ENABLED_MASK), [])]), Statement(return true, []), Statement(}, []), Statement(return onHoverEvent(event), []), Statement(}, [])])  Statement({, [])  Statement(// noinspection SimplifiableIfStatement, [])  AssignmentExpression(=, [VariableReference(if (mOnHoverListener !, []), Expression(null && (mViewFlags & ENABLED_MASK), [])])    VariableReference(if (mOnHoverListener !, [])    Expression(null && (mViewFlags & ENABLED_MASK), [])  Statement(return true, [])  Statement(}, [])  Statement(return onHoverEvent(event), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(// noinspection SimplifiableIfStatement, []), AssignmentExpression(=, [VariableReference(ListenerInfo li, []), Expression(mListenerInfo, [])]), AssignmentExpression(=, [VariableReference(if (li !, []), Expression(null && li.mOnHoverListener !, [])]), Statement(return true, []), Statement(}, []), Statement(return onHoverEvent(event), []), Statement(}, [])])  Statement({, [])  Statement(// noinspection SimplifiableIfStatement, [])  AssignmentExpression(=, [VariableReference(ListenerInfo li, []), Expression(mListenerInfo, [])])    VariableReference(ListenerInfo li, [])    Expression(mListenerInfo, [])  AssignmentExpression(=, [VariableReference(if (li !, []), Expression(null && li.mOnHoverListener !, [])])    VariableReference(if (li !, [])    Expression(null && li.mOnHoverListener !, [])  Statement(return true, [])  Statement(}, [])  Statement(return onHoverEvent(event), [])  Statement(}, [])",1,"/**
 * Dispatch a hover event.
 * <p>
 * Do not call this method directly.
 * Call {@link #dispatchGenericMotionEvent(MotionEvent)} instead.
 * </p>
 *
 * @param event The motion event to be dispatched.
 * @return True if the event was handled by the view, false otherwise.
 */
","/**
 * Dispatch a hover event.
 * <p>
 * Do not call this method directly.
 * Call {@link #dispatchGenericMotionEvent(MotionEvent)} instead.
 * </p>
 *
 * @param event The motion event to be dispatched.
 * @return True if the event was handled by the view, false otherwise.
 */
",0,,,0,,,0,1,4,1,5,1,The implementation of the method has changed from using the `mOnHoverListener` field directly to using the `mListenerInfo` field to get the `mOnHoverListener` field. This is a dependent API change as the `mListenerInfo` field is used to get the `mOnHoverListener` field.,"The change in the implementation of the method can potentially lead to compatibility issues as the behavior of the method can be different if the `mListenerInfo` field is not properly initialized or if it contains stale data. This can result in the method returning a different value (true or false) than expected, which can cause issues in the calling code. Therefore, the CI type is 1."
148,"<android.database.CursorWindow: String getString(int,int)>",14,15,"<android.database.CursorWindow: String getString(int,int)>","<android.database.CursorWindow: String getString(int,int)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(acquireReference(), []), Statement(try {, []), Statement(return nativeGetString(mWindowPtr, row - mStartPos, column), []), Statement(} finally {, []), Statement(releaseReference(), []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(acquireReference(), [])  Statement(try {, [])  Statement(return nativeGetString(mWindowPtr, row - mStartPos, column), [])  Statement(} finally {, [])  Statement(releaseReference(), [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(acquireReference(), []), Statement(try {, []), Statement(return nativeGetString(mWindowPtr, row - mStartPos, column), []), Statement(} finally {, []), Statement(releaseReference(), []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(acquireReference(), [])  Statement(try {, [])  Statement(return nativeGetString(mWindowPtr, row - mStartPos, column), [])  Statement(} finally {, [])  Statement(releaseReference(), [])  Statement(}, [])  Statement(}, [])",0,"/**
 * Gets the value of the field at the specified row and column index as a string.
 * <p>
 * The result is determined as follows:
 * <ul>
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_NULL}, then the result
 * is <code>null</code>.</li>
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_STRING}, then the result
 * is the string value.</li>
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_INTEGER}, then the result
 * is a string representation of the integer in decimal, obtained by formatting the
 * value with the <code>printf</code> family of functions using
 * format specifier <code>%lld</code>.</li>
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_FLOAT}, then the result
 * is a string representation of the floating-point value in decimal, obtained by
 * formatting the value with the <code>printf</code> family of functions using
 * format specifier <code>%g</code>.</li>
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_BLOB}, then a
 * {@link SQLiteException} is thrown.</li>
 * </ul>
 * </p>
 *
 * @param row The zero-based row index, relative to the cursor window's
 * start position ({@link #getStartPosition()}).
 * @param column The zero-based column index.
 * @return The value of the field as a string.
 */
","/**
 * Gets the value of the field at the specified row and column index as a string.
 * <p>
 * The result is determined as follows:
 * <ul>
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_NULL}, then the result
 * is <code>null</code>.</li>
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_STRING}, then the result
 * is the string value.</li>
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_INTEGER}, then the result
 * is a string representation of the integer in decimal, obtained by formatting the
 * value with the <code>printf</code> family of functions using
 * format specifier <code>%lld</code>.</li>
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_FLOAT}, then the result
 * is a string representation of the floating-point value in decimal, obtained by
 * formatting the value with the <code>printf</code> family of functions using
 * format specifier <code>%g</code>.</li>
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_BLOB}, then a
 * {@link SQLiteException} is thrown.</li>
 * </ul>
 * </p>
 *
 * @param row The zero-based row index.
 * @param column The zero-based column index.
 * @return The value of the field as a string.
 */
",1,,,0,,,0,0,0,0,0,0,"There is no change in the provided implementation code, comment, and annotations for the `getString` method of `android.database.CursorWindow` between versions 14 and 15.","As there are no changes in the code, comments, or annotations, there is no Compatibility Issue (CI) that has been introduced between versions 14 and 15 for the `getString` method of `android.database.CursorWindow`."
149,<android.content.AsyncTaskLoader.LoadTask: void onPostExecute(D)>,15,16,<android.content.AsyncTaskLoader.LoadTask: void onPostExecute(D)>,<android.content.AsyncTaskLoader.LoadTask: void onPostExecute(D)>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(if (DEBUG), []), MethodCall(Slog.v(TAG, this + "" onPostExecute""), [VariableReference(Slog, []), Expression(TAG, []), Expression(this + "" onPostExecute"", [])]), Statement(try {, []), Statement(} finally {, []), MethodCall(done.countDown(), [VariableReference(done, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(if (DEBUG), [])  MethodCall(Slog.v(TAG, this + "" onPostExecute""), [VariableReference(Slog, []), Expression(TAG, []), Expression(this + "" onPostExecute"", [])])    VariableReference(Slog, [])    Expression(TAG, [])    Expression(this + "" onPostExecute"", [])  Statement(try {, [])  Statement(} finally {, [])  MethodCall(done.countDown(), [VariableReference(done, []), Expression(, [])])    VariableReference(done, [])    Expression(, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (DEBUG), []), MethodCall(Slog.v(TAG, this + "" onPostExecute""), [VariableReference(Slog, []), Expression(TAG, []), Expression(this + "" onPostExecute"", [])]), Statement(try {, []), Statement(} finally {, []), MethodCall(mDone.countDown(), [VariableReference(mDone, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(if (DEBUG), [])  MethodCall(Slog.v(TAG, this + "" onPostExecute""), [VariableReference(Slog, []), Expression(TAG, []), Expression(this + "" onPostExecute"", [])])    VariableReference(Slog, [])    Expression(TAG, [])    Expression(this + "" onPostExecute"", [])  Statement(try {, [])  Statement(} finally {, [])  MethodCall(mDone.countDown(), [VariableReference(mDone, []), Expression(, [])])    VariableReference(mDone, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",1,"/* Runs on the UI thread */
","/* Runs on the UI thread */
",0,[@Override],[@Override],0,,,0,"1,2",5,0,4,0,The variable reference "done" in the method call "done.countDown()" in the finally block of the early version implementation has been changed to "mDone" in the late version implementation. This is a change in the Other statement category.,"The Compatibility Issue does not exist in this case. The change in variable reference from ""done"" to ""mDone"" does not affect the behavior of the API. The purpose of the variable is to count down the number of tasks that are running, and as long as the variable is correctly initialized and used, the behavior of the API will remain the same."
151,<android.webkit.WebView: boolean shouldDelayChildPressedState()>,15,16,<android.webkit.WebView: boolean shouldDelayChildPressedState()>,<android.webkit.WebView: boolean shouldDelayChildPressedState()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(return true, []), Statement(}, [])])  Statement({, [])  Statement(return true, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(return mProvider.getViewDelegate().shouldDelayChildPressedState(), [VariableReference(return mProvider, []), Expression().shouldDelayChildPressedState(, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return mProvider.getViewDelegate().shouldDelayChildPressedState(), [VariableReference(return mProvider, []), Expression().shouldDelayChildPressedState(, [])])    VariableReference(return mProvider, [])    Expression().shouldDelayChildPressedState(, [])  Statement(}, [])",1,,,0,[@Override],"[@Deprecated, @Override]",1,,,0,"1,2","1,5",1,5,1,The implementation of the `shouldDelayChildPressedState()` method has been changed from directly returning `true` to delegating the call to `mProvider.getViewDelegate().shouldDelayChildPressedState()`. This is a Dependent API changed (class 5) as the method now relies on the behavior of the `shouldDelayChildPressedState()` method of the view delegate.,"The change in the implementation of the `shouldDelayChildPressedState()` method can lead to a Compatibility Issue (class 1) as the method now relies on the behavior of the `shouldDelayChildPressedState()` method of the view delegate. If the view delegate's implementation of the method returns a value different from `true`, it will affect the behavior of the `shouldDelayChildPressedState()` method, potentially causing it to return a different value compared to the earlier version."
152,<android.server.search.SearchManagerService: ComponentName getWebSearchActivity()>,16,17,<android.server.search.SearchManagerService: ComponentName getWebSearchActivity()>,<android.server.search.SearchManagerService: ComponentName getWebSearchActivity()>,0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(return getSearchables().getWebSearchActivity(), [VariableReference(return getSearchables(), []), Expression(, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return getSearchables().getWebSearchActivity(), [VariableReference(return getSearchables(), []), Expression(, [])])    VariableReference(return getSearchables(), [])    Expression(, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(return getSearchables(UserHandle.getCallingUserId()).getWebSearchActivity(), [VariableReference(return getSearchables(UserHandle, []), Expression()).getWebSearchActivity(, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return getSearchables(UserHandle.getCallingUserId()).getWebSearchActivity(), [VariableReference(return getSearchables(UserHandle, []), Expression()).getWebSearchActivity(, [])])    VariableReference(return getSearchables(UserHandle, [])    Expression()).getWebSearchActivity(, [])  Statement(}, [])",1,"/**
 * Gets the name of the web search activity.
 */
","/**
 * Gets the name of the web search activity.
 */
",0,,,0,,,0,"1,2","1,5",1,5,1,"The parameter of the method 'getSearchables' has changed between the two versions. In the early version, the method is called without any parameter, while in the late version, the method is called with a parameter 'UserHandle.getCallingUserId()'.","The change in the parameter of the method 'getSearchables' can potentially lead to a different value being returned by the method. This, in turn, can cause the method 'getWebSearchActivity' to return a different value, resulting in a Compatibility Issue of type 1."
153,<android.webkit.AccessibilityInjector: void addAccessibilityApisIfNecessary()>,16,17,<android.webkit.AccessibilityInjector: void addAccessibilityApisIfNecessary()>,<android.webkit.AccessibilityInjector: void addAccessibilityApisIfNecessary()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(if (!isAccessibilityEnabled() || !isJavaScriptEnabled()) {, []), Statement(return, []), Statement(}, []), Statement(addTtsApis(), []), Statement(addCallbackApis(), []), Statement(}, [])])  Statement({, [])  Statement(if (!isAccessibilityEnabled() || !isJavaScriptEnabled()) {, [])  Statement(return, [])  Statement(}, [])  Statement(addTtsApis(), [])  Statement(addCallbackApis(), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (!isAccessibilityEnabled() || !isJavaScriptEnabled()) {, []), Statement(return, []), Statement(}, []), Statement(addTtsApis(), []), Statement(addCallbackApis(), []), Statement(}, [])])  Statement({, [])  Statement(if (!isAccessibilityEnabled() || !isJavaScriptEnabled()) {, [])  Statement(return, [])  Statement(}, [])  Statement(addTtsApis(), [])  Statement(addCallbackApis(), [])  Statement(}, [])",0,"/**
 * Attempts to load scripting interfaces for accessibility.
 * <p>
 * This should be called when the window is attached.
 * </p>
 */
","/**
 * Attempts to load scripting interfaces for accessibility.
 * <p>
 * This should only be called before a page loads.
 */
",1,,,0,,,0,0,0,0,4,0,"The comment for the method has changed, specifically the line ""This should be called when the window is attached."" was replaced with ""This should only be called before a page loads.""","The change in the method comment does not affect the behavior of the method, it only provides guidance on when to call the method. Therefore, there is no compatibility issue."
154,"<android.webkit.AccessibilityInjector.CallbackHandler: void onResult(String,String)>",16,17,"<android.webkit.AccessibilityInjector.CallbackHandler: void onResult(String,String)>","<android.webkit.AccessibilityInjector.CallbackHandler: void onResult(String,String)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(final long resultId, []), Statement(try {, []), AssignmentExpression(=, [VariableReference(resultId, []), Expression(Long.parseLong(id), [])]), Statement(} catch (NumberFormatException e) {, []), Statement(return, []), Statement(}, []), Statement(synchronized (mResultLock) {, []), Statement(if (resultId > mResultId) {, []), AssignmentExpression(=, [VariableReference(mResult, []), Expression(Boolean.parseBoolean(result), [])]), AssignmentExpression(=, [VariableReference(mResultId, []), Expression(resultId, [])]), Statement(}, []), MethodCall(mResultLock.notifyAll(), [VariableReference(mResultLock, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(final long resultId, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(resultId, []), Expression(Long.parseLong(id), [])])    VariableReference(resultId, [])    Expression(Long.parseLong(id), [])  Statement(} catch (NumberFormatException e) {, [])  Statement(return, [])  Statement(}, [])  Statement(synchronized (mResultLock) {, [])  Statement(if (resultId > mResultId) {, [])  AssignmentExpression(=, [VariableReference(mResult, []), Expression(Boolean.parseBoolean(result), [])])    VariableReference(mResult, [])    Expression(Boolean.parseBoolean(result), [])  AssignmentExpression(=, [VariableReference(mResultId, []), Expression(resultId, [])])    VariableReference(mResultId, [])    Expression(resultId, [])  Statement(}, [])  MethodCall(mResultLock.notifyAll(), [VariableReference(mResultLock, []), Expression(, [])])    VariableReference(mResultLock, [])    Expression(, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (DEBUG) {, []), MethodCall(Log.w(TAG, ""Saw CVOX result of '"" + result + ""' for ID "" + id), [VariableReference(Log, []), Expression(TAG, []), Expression(""Saw CVOX result of '"" + result + ""' for ID "" + id, [])]), Statement(}, []), Statement(final int resultId, []), Statement(try {, []), AssignmentExpression(=, [VariableReference(resultId, []), Expression(Integer.parseInt(id), [])]), Statement(} catch (NumberFormatException e) {, []), Statement(return, []), Statement(}, []), Statement(synchronized (mResultLock) {, []), Statement(if (resultId > mResultId) {, []), AssignmentExpression(=, [VariableReference(mResult, []), Expression(Boolean.parseBoolean(result), [])]), AssignmentExpression(=, [VariableReference(mResultId, []), Expression(resultId, [])]), Statement(} else {, []), Statement(if (DEBUG) {, []), MethodCall(Log.w(TAG, ""Result with ID "" + resultId + "" was stale vesus "" + mResultId), [VariableReference(Log, []), Expression(TAG, []), Expression(""Result with ID "" + resultId + "" was stale vesus "" + mResultId, [])]), Statement(}, []), Statement(}, []), MethodCall(mResultLock.notifyAll(), [VariableReference(mResultLock, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(if (DEBUG) {, [])  MethodCall(Log.w(TAG, ""Saw CVOX result of '"" + result + ""' for ID "" + id), [VariableReference(Log, []), Expression(TAG, []), Expression(""Saw CVOX result of '"" + result + ""' for ID "" + id, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Saw CVOX result of '"" + result + ""' for ID "" + id, [])  Statement(}, [])  Statement(final int resultId, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(resultId, []), Expression(Integer.parseInt(id), [])])    VariableReference(resultId, [])    Expression(Integer.parseInt(id), [])  Statement(} catch (NumberFormatException e) {, [])  Statement(return, [])  Statement(}, [])  Statement(synchronized (mResultLock) {, [])  Statement(if (resultId > mResultId) {, [])  AssignmentExpression(=, [VariableReference(mResult, []), Expression(Boolean.parseBoolean(result), [])])    VariableReference(mResult, [])    Expression(Boolean.parseBoolean(result), [])  AssignmentExpression(=, [VariableReference(mResultId, []), Expression(resultId, [])])    VariableReference(mResultId, [])    Expression(resultId, [])  Statement(} else {, [])  Statement(if (DEBUG) {, [])  MethodCall(Log.w(TAG, ""Result with ID "" + resultId + "" was stale vesus "" + mResultId), [VariableReference(Log, []), Expression(TAG, []), Expression(""Result with ID "" + resultId + "" was stale vesus "" + mResultId, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Result with ID "" + resultId + "" was stale vesus "" + mResultId, [])  Statement(}, [])  Statement(}, [])  MethodCall(mResultLock.notifyAll(), [VariableReference(mResultLock, []), Expression(, [])])    VariableReference(mResultLock, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Callback exposed to JavaScript. Handles returning the result of a
 * request to a waiting (or potentially timed out) thread.
 *
 * @param id The result id of the request as a {@link String}.
 * @param result The result of the request as a {@link String}.
 */
","/**
 * Callback exposed to JavaScript. Handles returning the result of a
 * request to a waiting (or potentially timed out) thread.
 *
 * @param id The result id of the request as a {@link String}.
 * @param result The result of the request as a {@link String}.
 */
",0,[@SuppressWarnings("unused")],"[@JavascriptInterface, @SuppressWarnings(""unused"")]",1,,,0,"1,2","3,4,5",1,"1,5","1,2",The code changes between the two versions are:,3. The method used to parse the `id` string has changed from `Long.parseLong(id)` to `Integer.parseInt(id)`.
155,"<android.app.Activity: boolean startNextMatchingActivity(Intent,Bundle)>",17,18,"<android.app.Activity: boolean startNextMatchingActivity(Intent,Bundle)>","<android.app.Activity: boolean startNextMatchingActivity(Intent,Bundle)>",0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mParent, []), Expression(, [])]), Statement(try {, []), MethodCall(intent.setAllowFds(false), [VariableReference(intent, []), Expression(false, [])]), MethodCall(return ActivityManagerNative.getDefault().startNextMatchingActivity(mToken, intent, options), [VariableReference(return ActivityManagerNative, []), Expression().startNextMatchingActivity(mToken, []), Expression(intent, []), Expression(options, [])]), Statement(} catch (RemoteException e) {, []), Statement(// Empty, []), Statement(}, []), Statement(return false, []), Statement(}, []), Statement(throw new UnsupportedOperationException(""startNextMatchingActivity can only be called from a top-level activity""), []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mParent, []), Expression(, [])])    VariableReference(if (mParent, [])    Expression(, [])  Statement(try {, [])  MethodCall(intent.setAllowFds(false), [VariableReference(intent, []), Expression(false, [])])    VariableReference(intent, [])    Expression(false, [])  MethodCall(return ActivityManagerNative.getDefault().startNextMatchingActivity(mToken, intent, options), [VariableReference(return ActivityManagerNative, []), Expression().startNextMatchingActivity(mToken, []), Expression(intent, []), Expression(options, [])])    VariableReference(return ActivityManagerNative, [])    Expression().startNextMatchingActivity(mToken, [])    Expression(intent, [])    Expression(options, [])  Statement(} catch (RemoteException e) {, [])  Statement(// Empty, [])  Statement(}, [])  Statement(return false, [])  Statement(}, [])  Statement(throw new UnsupportedOperationException(""startNextMatchingActivity can only be called from a top-level activity""), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mParent, []), Expression(, [])]), Statement(try {, []), MethodCall(intent.migrateExtraStreamToClipData(), [VariableReference(intent, []), Expression(, [])]), MethodCall(intent.prepareToLeaveProcess(), [VariableReference(intent, []), Expression(, [])]), MethodCall(return ActivityManagerNative.getDefault().startNextMatchingActivity(mToken, intent, options), [VariableReference(return ActivityManagerNative, []), Expression().startNextMatchingActivity(mToken, []), Expression(intent, []), Expression(options, [])]), Statement(} catch (RemoteException e) {, []), Statement(// Empty, []), Statement(}, []), Statement(return false, []), Statement(}, []), Statement(throw new UnsupportedOperationException(""startNextMatchingActivity can only be called from a top-level activity""), []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mParent, []), Expression(, [])])    VariableReference(if (mParent, [])    Expression(, [])  Statement(try {, [])  MethodCall(intent.migrateExtraStreamToClipData(), [VariableReference(intent, []), Expression(, [])])    VariableReference(intent, [])    Expression(, [])  MethodCall(intent.prepareToLeaveProcess(), [VariableReference(intent, []), Expression(, [])])    VariableReference(intent, [])    Expression(, [])  MethodCall(return ActivityManagerNative.getDefault().startNextMatchingActivity(mToken, intent, options), [VariableReference(return ActivityManagerNative, []), Expression().startNextMatchingActivity(mToken, []), Expression(intent, []), Expression(options, [])])    VariableReference(return ActivityManagerNative, [])    Expression().startNextMatchingActivity(mToken, [])    Expression(intent, [])    Expression(options, [])  Statement(} catch (RemoteException e) {, [])  Statement(// Empty, [])  Statement(}, [])  Statement(return false, [])  Statement(}, [])  Statement(throw new UnsupportedOperationException(""startNextMatchingActivity can only be called from a top-level activity""), [])  Statement(}, [])",1,"/**
 * Special version of starting an activity, for use when you are replacing
 * other activity components.  You can use this to hand the Intent off
 * to the next Activity that can handle it.  You typically call this in
 * {@link #onCreate} with the Intent returned by {@link #getIntent}.
 *
 * @param intent The intent to dispatch to the next activity.  For
 * correct behavior, this must be the same as the Intent that started
 * your own activity; the only changes you can make are to the extras
 * inside of it.
 * @param options Additional options for how the Activity should be started.
 * See {@link android.content.Context#startActivity(Intent, Bundle)
 * Context.startActivity(Intent, Bundle)} for more details.
 *
 * @return Returns a boolean indicating whether there was another Activity
 * to start: true if there was a next activity to start, false if there
 * wasn't.  In general, if true is returned you will then want to call
 * finish() on yourself.
 */
","/**
 * Special version of starting an activity, for use when you are replacing
 * other activity components.  You can use this to hand the Intent off
 * to the next Activity that can handle it.  You typically call this in
 * {@link #onCreate} with the Intent returned by {@link #getIntent}.
 *
 * @param intent The intent to dispatch to the next activity.  For
 * correct behavior, this must be the same as the Intent that started
 * your own activity; the only changes you can make are to the extras
 * inside of it.
 * @param options Additional options for how the Activity should be started.
 * See {@link android.content.Context#startActivity(Intent, Bundle)
 * Context.startActivity(Intent, Bundle)} for more details.
 *
 * @return Returns a boolean indicating whether there was another Activity
 * to start: true if there was a next activity to start, false if there
 * wasn't.  In general, if true is returned you will then want to call
 * finish() on yourself.
 */
",0,,,0,,,0,"1,2",5,0,4,1,"In the late version, two new method calls (intent.migrateExtraStreamToClipData() and intent.prepareToLeaveProcess()) are added before the return statement.","The newly added method calls in the late version may modify the 'intent' object, which could potentially lead to different behavior in the API. Therefore, this is a Compatibility Issue caused by potential different return values or types."
156,"<android.content.ContentProvider: int bulkInsert(Uri,ContentValues[])>",17,18,"<android.content.ContentProvider: int bulkInsert(Uri,ContentValues[])>","<android.content.ContentProvider: int bulkInsert(Uri,ContentValues[])>",0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(int numValues, []), Expression(values.length, [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < numValues, []), Statement(i++) {, []), Statement(insert(uri, values[i]), []), Statement(}, []), Statement(return numValues, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(int numValues, []), Expression(values.length, [])])    VariableReference(int numValues, [])    Expression(values.length, [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < numValues, [])  Statement(i++) {, [])  Statement(insert(uri, values[i]), [])  Statement(}, [])  Statement(return numValues, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(int numValues, []), Expression(values.length, [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < numValues, []), Statement(i++) {, []), Statement(insert(uri, values[i]), []), Statement(}, []), Statement(return numValues, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(int numValues, []), Expression(values.length, [])])    VariableReference(int numValues, [])    Expression(values.length, [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < numValues, [])  Statement(i++) {, [])  Statement(insert(uri, values[i]), [])  Statement(}, [])  Statement(return numValues, [])  Statement(}, [])",0,"/**
 * Override this to handle requests to insert a set of new rows, or the
 * default implementation will iterate over the values and call
 * {@link #insert} on each of them.
 * As a courtesy, call {@link ContentResolver#notifyChange(android.net.Uri ,android.database.ContentObserver) notifyChange()}
 * after inserting.
 * This method can be called from multiple threads, as described in
 * <a href=""{@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads"">Processes
 * and Threads</a>.
 *
 * @param uri The content:// URI of the insertion request.
 * @param values An array of sets of column_name/value pairs to add to the database.
 * @return The number of values that were inserted.
 */
","/**
 * Override this to handle requests to insert a set of new rows, or the
 * default implementation will iterate over the values and call
 * {@link #insert} on each of them.
 * As a courtesy, call {@link ContentResolver#notifyChange(android.net.Uri ,android.database.ContentObserver) notifyChange()}
 * after inserting.
 * This method can be called from multiple threads, as described in
 * <a href=""{@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads"">Processes
 * and Threads</a>.
 *
 * @param uri The content:// URI of the insertion request.
 * @param values An array of sets of column_name/value pairs to add to the database.
 * This must not be {@code null}.
 * @return The number of values that were inserted.
 */
",1,,,0,,,0,0,0,0,0,0,The code in the implementation of the API has not been changed between the two versions.,"The code in the implementation of the API has not been changed, so there is no compatibility issue between the two versions."
157,<android.view.Surface.CompatibleCanvas: void getMatrix(Matrix)>,17,18,<android.view.Surface.CompatibleCanvas: void getMatrix(Matrix)>,<android.view.Surface.CompatibleCanvas: void getMatrix(Matrix)>,0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(super.getMatrix(m), [VariableReference(super, []), Expression(m, [])]), AssignmentExpression(=, [VariableReference(if (mOrigMatrix, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(mOrigMatrix, []), Expression(new Matrix(), [])]), Statement(}, []), MethodCall(mOrigMatrix.set(m), [VariableReference(mOrigMatrix, []), Expression(m, [])]), Statement(}, [])])  Statement({, [])  MethodCall(super.getMatrix(m), [VariableReference(super, []), Expression(m, [])])    VariableReference(super, [])    Expression(m, [])  AssignmentExpression(=, [VariableReference(if (mOrigMatrix, []), Expression(, [])])    VariableReference(if (mOrigMatrix, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(mOrigMatrix, []), Expression(new Matrix(), [])])    VariableReference(mOrigMatrix, [])    Expression(new Matrix(), [])  Statement(}, [])  MethodCall(mOrigMatrix.set(m), [VariableReference(mOrigMatrix, []), Expression(m, [])])    VariableReference(mOrigMatrix, [])    Expression(m, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(super.getMatrix(m), [VariableReference(super, []), Expression(m, [])]), AssignmentExpression(=, [VariableReference(if (mOrigMatrix, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(mOrigMatrix, []), Expression(new Matrix(), [])]), Statement(}, []), MethodCall(mOrigMatrix.set(m), [VariableReference(mOrigMatrix, []), Expression(m, [])]), Statement(}, [])])  Statement({, [])  MethodCall(super.getMatrix(m), [VariableReference(super, []), Expression(m, [])])    VariableReference(super, [])    Expression(m, [])  AssignmentExpression(=, [VariableReference(if (mOrigMatrix, []), Expression(, [])])    VariableReference(if (mOrigMatrix, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(mOrigMatrix, []), Expression(new Matrix(), [])])    VariableReference(mOrigMatrix, [])    Expression(new Matrix(), [])  Statement(}, [])  MethodCall(mOrigMatrix.set(m), [VariableReference(mOrigMatrix, []), Expression(m, [])])    VariableReference(mOrigMatrix, [])    Expression(m, [])  Statement(}, [])",0,,,0,[@Override],"[@SuppressWarnings(""deprecation""), @Override]",1,,,0,0,0,0,5,1,"A new `@SuppressWarnings(""deprecation"")` annotation has been added to the method declaration, which indicates that the method is using a deprecated API and the compiler should not generate a warning for it. Additionally, the implementation of the method has not changed, so the code change type is 5 (Dependent API changed).","The addition of the `@SuppressWarnings(""deprecated"")` annotation does not affect the runtime behavior of the method, so there is no compatibility issue caused by this change. However, if the deprecated API used by the method is removed or its behavior is changed in a future version, it could potentially lead to a compatibility issue. Therefore, the CI type is 1 (Compatibility Issue caused by potential different return values or types)."
159,<android.view.View: void setSystemUiVisibility(int)>,18,19,<android.view.View: void setSystemUiVisibility(int)>,<android.view.View: void setSystemUiVisibility(int)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (visibility !, []), Expression(mSystemUiVisibility) {, [])]), AssignmentExpression(=, [VariableReference(mSystemUiVisibility, []), Expression(visibility, [])]), AssignmentExpression(=, [VariableReference(if (mParent !, []), Expression(null && mAttachInfo !, [])]), MethodCall(mParent.recomputeViewAttributes(this), [VariableReference(mParent, []), Expression(this, [])]), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (visibility !, []), Expression(mSystemUiVisibility) {, [])])    VariableReference(if (visibility !, [])    Expression(mSystemUiVisibility) {, [])  AssignmentExpression(=, [VariableReference(mSystemUiVisibility, []), Expression(visibility, [])])    VariableReference(mSystemUiVisibility, [])    Expression(visibility, [])  AssignmentExpression(=, [VariableReference(if (mParent !, []), Expression(null && mAttachInfo !, [])])    VariableReference(if (mParent !, [])    Expression(null && mAttachInfo !, [])  MethodCall(mParent.recomputeViewAttributes(this), [VariableReference(mParent, []), Expression(this, [])])    VariableReference(mParent, [])    Expression(this, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (visibility !, []), Expression(mSystemUiVisibility) {, [])]), AssignmentExpression(=, [VariableReference(mSystemUiVisibility, []), Expression(visibility, [])]), AssignmentExpression(=, [VariableReference(if (mParent !, []), Expression(null && mAttachInfo !, [])]), MethodCall(mParent.recomputeViewAttributes(this), [VariableReference(mParent, []), Expression(this, [])]), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (visibility !, []), Expression(mSystemUiVisibility) {, [])])    VariableReference(if (visibility !, [])    Expression(mSystemUiVisibility) {, [])  AssignmentExpression(=, [VariableReference(mSystemUiVisibility, []), Expression(visibility, [])])    VariableReference(mSystemUiVisibility, [])    Expression(visibility, [])  AssignmentExpression(=, [VariableReference(if (mParent !, []), Expression(null && mAttachInfo !, [])])    VariableReference(if (mParent !, [])    Expression(null && mAttachInfo !, [])  MethodCall(mParent.recomputeViewAttributes(this), [VariableReference(mParent, []), Expression(this, [])])    VariableReference(mParent, [])    Expression(this, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])",0,"/**
 * Request that the visibility of the status bar or other screen/window
 * decorations be changed.
 *
 * <p>This method is used to put the over device UI into temporary modes
 * where the user's attention is focused more on the application content,
 * by dimming or hiding surrounding system affordances.  This is typically
 * used in conjunction with {@link Window#FEATURE_ACTION_BAR_OVERLAY
 * Window.FEATURE_ACTION_BAR_OVERLAY}, allowing the applications content
 * to be placed behind the action bar (and with these flags other system
 * affordances) so that smooth transitions between hiding and showing them
 * can be done.
 *
 * <p>Two representative examples of the use of system UI visibility is
 * implementing a content browsing application (like a magazine reader)
 * and a video playing application.
 *
 * <p>The first code shows a typical implementation of a View in a content
 * browsing application.  In this implementation, the application goes
 * into a content-oriented mode by hiding the status bar and action bar,
 * and putting the navigation elements into lights out mode.  The user can
 * then interact with content while in this mode.  Such an application should
 * provide an easy way for the user to toggle out of the mode (such as to
 * check information in the status bar or access notifications).  In the
 * implementation here, this is done simply by tapping on the content.
 *
 * {@sample development/samples/ApiDemos/src/com/example/android/apis/view/ContentBrowserActivity.java
 * content}
 *
 * <p>This second code sample shows a typical implementation of a View
 * in a video playing application.  In this situation, while the video is
 * playing the application would like to go into a complete full-screen mode,
 * to use as much of the display as possible for the video.  When in this state
 * the user can not interact with the application; the system intercepts
 * touching on the screen to pop the UI out of full screen mode.  See
 * {@link #fitSystemWindows(Rect)} for a sample layout that goes with this code.
 *
 * {@sample development/samples/ApiDemos/src/com/example/android/apis/view/VideoPlayerActivity.java
 * content}
 *
 * @param visibility  Bitwise-or of flags {@link #SYSTEM_UI_FLAG_LOW_PROFILE},
 * {@link #SYSTEM_UI_FLAG_HIDE_NAVIGATION}, {@link #SYSTEM_UI_FLAG_FULLSCREEN},
 * {@link #SYSTEM_UI_FLAG_LAYOUT_STABLE}, {@link #SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION},
 * and {@link #SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN}.
 */
","/**
 * Request that the visibility of the status bar or other screen/window
 * decorations be changed.
 *
 * <p>This method is used to put the over device UI into temporary modes
 * where the user's attention is focused more on the application content,
 * by dimming or hiding surrounding system affordances.  This is typically
 * used in conjunction with {@link Window#FEATURE_ACTION_BAR_OVERLAY
 * Window.FEATURE_ACTION_BAR_OVERLAY}, allowing the applications content
 * to be placed behind the action bar (and with these flags other system
 * affordances) so that smooth transitions between hiding and showing them
 * can be done.
 *
 * <p>Two representative examples of the use of system UI visibility is
 * implementing a content browsing application (like a magazine reader)
 * and a video playing application.
 *
 * <p>The first code shows a typical implementation of a View in a content
 * browsing application.  In this implementation, the application goes
 * into a content-oriented mode by hiding the status bar and action bar,
 * and putting the navigation elements into lights out mode.  The user can
 * then interact with content while in this mode.  Such an application should
 * provide an easy way for the user to toggle out of the mode (such as to
 * check information in the status bar or access notifications).  In the
 * implementation here, this is done simply by tapping on the content.
 *
 * {@sample development/samples/ApiDemos/src/com/example/android/apis/view/ContentBrowserActivity.java
 * content}
 *
 * <p>This second code sample shows a typical implementation of a View
 * in a video playing application.  In this situation, while the video is
 * playing the application would like to go into a complete full-screen mode,
 * to use as much of the display as possible for the video.  When in this state
 * the user can not interact with the application; the system intercepts
 * touching on the screen to pop the UI out of full screen mode.  See
 * {@link #fitSystemWindows(Rect)} for a sample layout that goes with this code.
 *
 * {@sample development/samples/ApiDemos/src/com/example/android/apis/view/VideoPlayerActivity.java
 * content}
 *
 * @param visibility  Bitwise-or of flags {@link #SYSTEM_UI_FLAG_LOW_PROFILE},
 * {@link #SYSTEM_UI_FLAG_HIDE_NAVIGATION}, {@link #SYSTEM_UI_FLAG_FULLSCREEN},
 * {@link #SYSTEM_UI_FLAG_LAYOUT_STABLE}, {@link #SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION},
 * {@link #SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN}, {@link #SYSTEM_UI_FLAG_IMMERSIVE},
 * and {@link #SYSTEM_UI_FLAG_IMMERSIVE_STICKY}.
 */
",1,,,0,,,0,0,0,0,0,0,There are no changes in the implementation of the API between the two versions.,"As there are no changes in the implementation of the API, there is no potential for different behaviors, return values, or exceptions to be thrown."
160,"<android.webkit.WebView: void onMeasure(int,int)>",18,19,"<android.webkit.WebView: void onMeasure(int,int)>","<android.webkit.WebView: void onMeasure(int,int)>",0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(super.onMeasure(widthMeasureSpec, heightMeasureSpec), [VariableReference(super, []), Expression(widthMeasureSpec, []), Expression(heightMeasureSpec, [])]), MethodCall(mProvider.getViewDelegate().onMeasure(widthMeasureSpec, heightMeasureSpec), [VariableReference(mProvider, []), Expression().onMeasure(widthMeasureSpec, []), Expression(heightMeasureSpec, [])]), Statement(}, [])])  Statement({, [])  MethodCall(super.onMeasure(widthMeasureSpec, heightMeasureSpec), [VariableReference(super, []), Expression(widthMeasureSpec, []), Expression(heightMeasureSpec, [])])    VariableReference(super, [])    Expression(widthMeasureSpec, [])    Expression(heightMeasureSpec, [])  MethodCall(mProvider.getViewDelegate().onMeasure(widthMeasureSpec, heightMeasureSpec), [VariableReference(mProvider, []), Expression().onMeasure(widthMeasureSpec, []), Expression(heightMeasureSpec, [])])    VariableReference(mProvider, [])    Expression().onMeasure(widthMeasureSpec, [])    Expression(heightMeasureSpec, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(super.onMeasure(widthMeasureSpec, heightMeasureSpec), [VariableReference(super, []), Expression(widthMeasureSpec, []), Expression(heightMeasureSpec, [])]), MethodCall(mProvider.getViewDelegate().onMeasure(widthMeasureSpec, heightMeasureSpec), [VariableReference(mProvider, []), Expression().onMeasure(widthMeasureSpec, []), Expression(heightMeasureSpec, [])]), Statement(}, [])])  Statement({, [])  MethodCall(super.onMeasure(widthMeasureSpec, heightMeasureSpec), [VariableReference(super, []), Expression(widthMeasureSpec, []), Expression(heightMeasureSpec, [])])    VariableReference(super, [])    Expression(widthMeasureSpec, [])    Expression(heightMeasureSpec, [])  MethodCall(mProvider.getViewDelegate().onMeasure(widthMeasureSpec, heightMeasureSpec), [VariableReference(mProvider, []), Expression().onMeasure(widthMeasureSpec, []), Expression(heightMeasureSpec, [])])    VariableReference(mProvider, [])    Expression().onMeasure(widthMeasureSpec, [])    Expression(heightMeasureSpec, [])  Statement(}, [])",0,,,0,"[@Deprecated, @Override]",[@Override],1,,,0,0,0,0,5,0,"The @Deprecated annotation has been removed from the late version of the API. This change does not affect the behavior of the API, but it indicates that the API is no longer deprecated and can be used in the future.","There is no compatibility issue caused by this change, as it does not affect the behavior of the API. The removal of the @Deprecated annotation only changes the way developers perceive and use the API."
161,<android.print.PrintAttributes.MediaSize: MediaSize asPortrait()>,19,20,<android.print.PrintAttributes.MediaSize: MediaSize asPortrait()>,<android.print.PrintAttributes.MediaSize: MediaSize asPortrait()>,0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(return new MediaSize(mId, mLabel, mPackageName, Math.min(mWidthMils, mHeightMils), Math.max(mWidthMils, mHeightMils), mLabelResId), [VariableReference(return new MediaSize(mId, mLabel, mPackageName, Math, []), Expression(mWidthMils, []), Expression(mHeightMils), []), Expression(Math.max(mWidthMils, []), Expression(mHeightMils), []), Expression(mLabelResId, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return new MediaSize(mId, mLabel, mPackageName, Math.min(mWidthMils, mHeightMils), Math.max(mWidthMils, mHeightMils), mLabelResId), [VariableReference(return new MediaSize(mId, mLabel, mPackageName, Math, []), Expression(mWidthMils, []), Expression(mHeightMils), []), Expression(Math.max(mWidthMils, []), Expression(mHeightMils), []), Expression(mLabelResId, [])])    VariableReference(return new MediaSize(mId, mLabel, mPackageName, Math, [])    Expression(mWidthMils, [])    Expression(mHeightMils), [])    Expression(Math.max(mWidthMils, [])    Expression(mHeightMils), [])    Expression(mLabelResId, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (isPortrait()) {, []), Statement(return this, []), Statement(}, []), MethodCall(return new MediaSize(mId, mLabel, mPackageName, Math.min(mWidthMils, mHeightMils), Math.max(mWidthMils, mHeightMils), mLabelResId), [VariableReference(return new MediaSize(mId, mLabel, mPackageName, Math, []), Expression(mWidthMils, []), Expression(mHeightMils), []), Expression(Math.max(mWidthMils, []), Expression(mHeightMils), []), Expression(mLabelResId, [])]), Statement(}, [])])  Statement({, [])  Statement(if (isPortrait()) {, [])  Statement(return this, [])  Statement(}, [])  MethodCall(return new MediaSize(mId, mLabel, mPackageName, Math.min(mWidthMils, mHeightMils), Math.max(mWidthMils, mHeightMils), mLabelResId), [VariableReference(return new MediaSize(mId, mLabel, mPackageName, Math, []), Expression(mWidthMils, []), Expression(mHeightMils), []), Expression(Math.max(mWidthMils, []), Expression(mHeightMils), []), Expression(mLabelResId, [])])    VariableReference(return new MediaSize(mId, mLabel, mPackageName, Math, [])    Expression(mWidthMils, [])    Expression(mHeightMils), [])    Expression(Math.max(mWidthMils, [])    Expression(mHeightMils), [])    Expression(mLabelResId, [])  Statement(}, [])",1,"/**
 * Returns a new media size in a portrait orientation
 * which is the height is the greater dimension.
 *
 * @return New instance in landscape orientation.
 */
","/**
 * Returns a new media size instance in a portrait orientation,
 * which is the height is the greater dimension.
 *
 * @return New instance in landscape orientation if this one
 * is in landscape, otherwise this instance.
 */
",1,,,0,,,0,"1,2","1,3",1,"1,3",1,"A new if statement has been added in the late version implementation. The new if statement checks whether the current instance is in portrait mode or not. If it is, the method returns the current instance instead of creating a new one. This is a control dependency change as it affects the flow of the program and whether or not a new instance is created. Additionally, the return statement has been changed to accommodate the new if statement.","The compatibility issue arises because the behavior of the method has changed between the two versions. In the early version, the method always returns a new instance in portrait orientation. However, in the late version, the method may return the current instance if it is already in portrait orientation. This can lead to unexpected behavior in programs that rely on the method to always return a new instance."
162,"<android.provider.DocumentsProvider: Cursor queryRecentDocuments(String,String[])>",19,20,"<android.provider.DocumentsProvider: Cursor queryRecentDocuments(String,String[])>","<android.provider.DocumentsProvider: Cursor queryRecentDocuments(String,String[])>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(throw new UnsupportedOperationException(""Recent not supported""), []), Statement(}, [])])  Statement({, [])  Statement(throw new UnsupportedOperationException(""Recent not supported""), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(throw new UnsupportedOperationException(""Recent not supported""), []), Statement(}, [])])  Statement({, [])  Statement(throw new UnsupportedOperationException(""Recent not supported""), [])  Statement(}, [])",0,"/**
 * Return recently modified documents under the requested root. This will
 * only be called for roots that advertise
 * {@link Root#FLAG_SUPPORTS_RECENTS}. The returned documents should be
 * sorted by {@link Document#COLUMN_LAST_MODIFIED} in descending order, and
 * limited to only return the 64 most recently modified documents.
 *
 * @param projection list of {@link Document} columns to put into the
 * cursor. If {@code null} all supported columns should be
 * included.
 * @see DocumentsContract#EXTRA_LOADING
 */
","/**
 * Return recently modified documents under the requested root. This will
 * only be called for roots that advertise
 * {@link Root#FLAG_SUPPORTS_RECENTS}. The returned documents should be
 * sorted by {@link Document#COLUMN_LAST_MODIFIED} in descending order, and
 * limited to only return the 64 most recently modified documents.
 * <p>
 * Recent documents do not support change notifications.
 *
 * @param projection list of {@link Document} columns to put into the
 * cursor. If {@code null} all supported columns should be
 * included.
 * @see DocumentsContract#EXTRA_LOADING
 */
",1,[@SuppressWarnings("unused")],[@SuppressWarnings("unused")],0,,,0,0,0,0,0,0,"The AST node for the implementation as well as the signature, comment, and annotation for the given API have not changed between the two versions.","As there are no changes in the code and implementation, there is no potential for compatibility issues to arise."
163,<android.app.MediaRouteActionProvider: View onCreateActionView()>,19,20,<android.app.MediaRouteActionProvider: View onCreateActionView()>,<android.app.MediaRouteActionProvider: View onCreateActionView()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(}, [])])  Statement({, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(}, [])])  Statement({, [])  Statement(}, [])",0,,,0,[@Override],"[@Override, @SuppressWarnings(""deprecation"")]",1,,,0,0,0,0,4,0,"An annotation (@SuppressWarnings(""deprecation"")) has been added to the method declaration, which is not related to the return statement, exception handling statement, and control dependency. So the code change type is 4 (Other statement changed).","The added annotation does not have any effect on the behavior of the API, so there is no Compatibility Issue (CI type is 0)."
164,<android.os.CountDownTimer: CountDownTimer start()>,20,21,<android.os.CountDownTimer: CountDownTimer start()>,<android.os.CountDownTimer: CountDownTimer start()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mMillisInFuture <, []), Expression(0) {, [])]), Statement(onFinish(), []), Statement(return this, []), Statement(}, []), AssignmentExpression(=, [VariableReference(mStopTimeInFuture, []), Expression(SystemClock.elapsedRealtime() + mMillisInFuture, [])]), MethodCall(mHandler.sendMessage(mHandler.obtainMessage(MSG)), [VariableReference(mHandler, []), Expression(mHandler.obtainMessage(MSG), [])]), Statement(return this, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mMillisInFuture <, []), Expression(0) {, [])])    VariableReference(if (mMillisInFuture <, [])    Expression(0) {, [])  Statement(onFinish(), [])  Statement(return this, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mStopTimeInFuture, []), Expression(SystemClock.elapsedRealtime() + mMillisInFuture, [])])    VariableReference(mStopTimeInFuture, [])    Expression(SystemClock.elapsedRealtime() + mMillisInFuture, [])  MethodCall(mHandler.sendMessage(mHandler.obtainMessage(MSG)), [VariableReference(mHandler, []), Expression(mHandler.obtainMessage(MSG), [])])    VariableReference(mHandler, [])    Expression(mHandler.obtainMessage(MSG), [])  Statement(return this, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(mCancelled, []), Expression(false, [])]), AssignmentExpression(=, [VariableReference(if (mMillisInFuture <, []), Expression(0) {, [])]), Statement(onFinish(), []), Statement(return this, []), Statement(}, []), AssignmentExpression(=, [VariableReference(mStopTimeInFuture, []), Expression(SystemClock.elapsedRealtime() + mMillisInFuture, [])]), MethodCall(mHandler.sendMessage(mHandler.obtainMessage(MSG)), [VariableReference(mHandler, []), Expression(mHandler.obtainMessage(MSG), [])]), Statement(return this, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(mCancelled, []), Expression(false, [])])    VariableReference(mCancelled, [])    Expression(false, [])  AssignmentExpression(=, [VariableReference(if (mMillisInFuture <, []), Expression(0) {, [])])    VariableReference(if (mMillisInFuture <, [])    Expression(0) {, [])  Statement(onFinish(), [])  Statement(return this, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mStopTimeInFuture, []), Expression(SystemClock.elapsedRealtime() + mMillisInFuture, [])])    VariableReference(mStopTimeInFuture, [])    Expression(SystemClock.elapsedRealtime() + mMillisInFuture, [])  MethodCall(mHandler.sendMessage(mHandler.obtainMessage(MSG)), [VariableReference(mHandler, []), Expression(mHandler.obtainMessage(MSG), [])])    VariableReference(mHandler, [])    Expression(mHandler.obtainMessage(MSG), [])  Statement(return this, [])  Statement(}, [])",1,"/**
 * Start the countdown.
 */
","/**
 * Start the countdown.
 */
",0,,,0,,,0,1,4,0,4,0,"The implementation of the method start() in CountDownTimer has changed in version 21. Specifically, a new assignment statement has been added at the beginning of the method, which assigns the value of mCancelled to false. However, this change does not affect the return value or the exception handling of the method.","The code change of adding an assignment statement to set the value of mCancelled to false does not introduce any compatibility issues, as it does not affect the return value or the exception handling of the method. Therefore, the CI type is 0, indicating that no compatibility issues exist."
165,<android.service.dreams.DreamService: boolean isScreenBright()>,20,21,<android.service.dreams.DreamService: boolean isScreenBright()>,<android.service.dreams.DreamService: boolean isScreenBright()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(}, [])])  Statement({, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(}, [])])  Statement({, [])  Statement(}, [])",0,"/**
 * Returns whether or not this dream keeps the screen bright while dreaming. Defaults to false,
 * allowing the screen to dim if necessary.
 *
 * @see #setScreenBright(boolean)
 */
","/**
 * Returns whether or not this dream keeps the screen bright while dreaming.
 * Defaults to false, allowing the screen to dim if necessary.
 *
 * @see #setScreenBright(boolean)
 */
",1,,,0,,,0,0,0,0,0,0,There is no difference found between the AST implementation nodes of the two versions.,"No Compatibility Issue exists, as there is no difference between the two versions."
166,"<android.app.Activity: Dialog onCreateDialog(int,Bundle)>",20,21,"<android.app.Activity: Dialog onCreateDialog(int,Bundle)>","<android.app.Activity: Dialog onCreateDialog(int,Bundle)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(return onCreateDialog(id), []), Statement(}, [])])  Statement({, [])  Statement(return onCreateDialog(id), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return onCreateDialog(id), []), Statement(}, [])])  Statement({, [])  Statement(return onCreateDialog(id), [])  Statement(}, [])",0,"/**
 * Callback for creating dialogs that are managed (saved and restored) for you
 * by the activity.  The default implementation calls through to
 * {@link #onCreateDialog(int)} for compatibility.
 *
 * <em>If you are targeting {@link android.os.Build.VERSION_CODES#HONEYCOMB}
 * or later, consider instead using a {@link DialogFragment} instead.</em>
 *
 * <p>If you use {@link #showDialog(int)}, the activity will call through to
 * this method the first time, and hang onto it thereafter.  Any dialog
 * that is created by this method will automatically be saved and restored
 * for you, including whether it is showing.
 *
 * <p>If you would like the activity to manage saving and restoring dialogs
 * for you, you should override this method and handle any ids that are
 * passed to {@link #showDialog}.
 *
 * <p>If you would like an opportunity to prepare your dialog before it is shown,
 * override {@link #onPrepareDialog(int, Dialog, Bundle)}.
 *
 * @param id The id of the dialog.
 * @param args The dialog arguments provided to {@link #showDialog(int, Bundle)}.
 * @return The dialog.  If you return null, the dialog will not be created.
 *
 * @see #onPrepareDialog(int, Dialog, Bundle)
 * @see #showDialog(int, Bundle)
 * @see #dismissDialog(int)
 * @see #removeDialog(int)
 *
 * @deprecated Use the new {@link DialogFragment} class with
 * {@link FragmentManager} instead; this is also
 * available on older platforms through the Android compatibility package.
 */
","/**
 * Callback for creating dialogs that are managed (saved and restored) for you
 * by the activity.  The default implementation calls through to
 * {@link #onCreateDialog(int)} for compatibility.
 *
 * <em>If you are targeting {@link android.os.Build.VERSION_CODES#HONEYCOMB}
 * or later, consider instead using a {@link DialogFragment} instead.</em>
 *
 * <p>If you use {@link #showDialog(int)}, the activity will call through to
 * this method the first time, and hang onto it thereafter.  Any dialog
 * that is created by this method will automatically be saved and restored
 * for you, including whether it is showing.
 *
 * <p>If you would like the activity to manage saving and restoring dialogs
 * for you, you should override this method and handle any ids that are
 * passed to {@link #showDialog}.
 *
 * <p>If you would like an opportunity to prepare your dialog before it is shown,
 * override {@link #onPrepareDialog(int, Dialog, Bundle)}.
 *
 * @param id The id of the dialog.
 * @param args The dialog arguments provided to {@link #showDialog(int, Bundle)}.
 * @return The dialog.  If you return null, the dialog will not be created.
 *
 * @see #onPrepareDialog(int, Dialog, Bundle)
 * @see #showDialog(int, Bundle)
 * @see #dismissDialog(int)
 * @see #removeDialog(int)
 *
 * @deprecated Use the new {@link DialogFragment} class with
 * {@link FragmentManager} instead; this is also
 * available on older platforms through the Android compatibility package.
 */
",0,[@Deprecated],"[@Nullable, @Deprecated]",1,,,0,0,0,0,4,0,"The annotation has been changed from `@Deprecated` to `@Nullable` and `@Deprecated`. The `@Nullable` annotation indicates that the method may return null, which was not explicitly stated before. However, the method implementation and behavior have not changed.","The compatibility issue does not exist since the method implementation and behavior have not changed. The added `@Nullable` annotation only provides more information to the API users, but does not affect the API's compatibility."
167,<android.hardware.camera2.legacy.SurfaceTextureRenderer: void drawIntoSurfaces(CaptureCollector)>,21,22,<android.hardware.camera2.legacy.SurfaceTextureRenderer: void drawIntoSurfaces(CaptureCollector)>,<android.hardware.camera2.legacy.SurfaceTextureRenderer: void drawIntoSurfaces(CaptureCollector)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if ((mSurfaces, []), Expression(, [])]), Statement(return, []), Statement(}, []), AssignmentExpression(=, [VariableReference(boolean doTiming, []), Expression(targetCollector.hasPendingPreviewCaptures(), [])]), Statement(checkGlError(""before updateTexImage""), []), Statement(if (doTiming) {, []), Statement(beginGlTiming(), []), Statement(}, []), MethodCall(mSurfaceTexture.updateTexImage(), [VariableReference(mSurfaceTexture, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(long timestamp, []), Expression(mSurfaceTexture.getTimestamp(), [])]), AssignmentExpression(=, [VariableReference(Pair<RequestHolder, Long> captureHolder, []), Expression(targetCollector.previewCaptured(timestamp), [])]), Statement(// No preview request queued, drop frame., []), AssignmentExpression(=, [VariableReference(if (captureHolder, []), Expression(, [])]), Statement(if (DEBUG) {, []), MethodCall(Log.d(TAG, ""Dropping preview frame.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Dropping preview frame."", [])]), Statement(}, []), Statement(if (doTiming) {, []), Statement(endGlTiming(), []), Statement(}, []), Statement(return, []), Statement(}, []), AssignmentExpression(=, [VariableReference(RequestHolder request, []), Expression(captureHolder.first, [])]), AssignmentExpression(=, [VariableReference(Collection<Surface> targetSurfaces, []), Expression(request.getHolderTargets(), [])]), Statement(if (doTiming) {, []), Statement(addGlTimestamp(timestamp), []), Statement(}, []), AssignmentExpression(=, [VariableReference(List<Long> targetSurfaceIds, []), Expression(LegacyCameraDevice.getSurfaceIds(targetSurfaces), [])]), Statement(for (EGLSurfaceHolder holder : mSurfaces) {, []), MethodCall(if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)), [VariableReference(if (LegacyCameraDevice, []), Expression(holder.surface, []), Expression(targetSurfaceIds), [])]), Statement(try {, []), MethodCall(LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(holder.width, []), Expression(holder.height, [])]), MethodCall(LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(captureHolder.second, [])]), MethodCall(Log.w(TAG, ""Surface abandoned, dropping frame. "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Surface abandoned, []), Expression(dropping frame. "", []), Expression(e, [])]), Statement(}, []), Statement(}, []), Statement(}, []), Statement(for (EGLSurfaceHolder holder : mConversionSurfaces) {, []), MethodCall(if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)), [VariableReference(if (LegacyCameraDevice, []), Expression(holder.surface, []), Expression(targetSurfaceIds), [])]), MethodCall(mPBufferPixels.clear(), [VariableReference(mPBufferPixels, []), Expression(, [])]), Statement(0, /*y*/, []), Statement(0, holder.width, holder.height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, mPBufferPixels), []), Statement(checkGlError(""glReadPixels""), []), Statement(try {, []), AssignmentExpression(=, [VariableReference(int format, []), Expression(LegacyCameraDevice.detectSurfaceType(holder.surface), [])]), MethodCall(LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(captureHolder.second, [])]), MethodCall(LegacyCameraDevice.produceFrame(holder.surface, mPBufferPixels.array(), holder.width, holder.height, format), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(mPBufferPixels.array(), []), Expression(holder.width, []), Expression(holder.height, []), Expression(format, [])]), MethodCall(Log.w(TAG, ""Surface abandoned, dropping frame. "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Surface abandoned, []), Expression(dropping frame. "", []), Expression(e, [])]), Statement(}, []), Statement(}, []), Statement(}, []), MethodCall(targetCollector.previewProduced(), [VariableReference(targetCollector, []), Expression(, [])]), Statement(if (doTiming) {, []), Statement(endGlTiming(), []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if ((mSurfaces, []), Expression(, [])])    VariableReference(if ((mSurfaces, [])    Expression(, [])  Statement(return, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(boolean doTiming, []), Expression(targetCollector.hasPendingPreviewCaptures(), [])])    VariableReference(boolean doTiming, [])    Expression(targetCollector.hasPendingPreviewCaptures(), [])  Statement(checkGlError(""before updateTexImage""), [])  Statement(if (doTiming) {, [])  Statement(beginGlTiming(), [])  Statement(}, [])  MethodCall(mSurfaceTexture.updateTexImage(), [VariableReference(mSurfaceTexture, []), Expression(, [])])    VariableReference(mSurfaceTexture, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(long timestamp, []), Expression(mSurfaceTexture.getTimestamp(), [])])    VariableReference(long timestamp, [])    Expression(mSurfaceTexture.getTimestamp(), [])  AssignmentExpression(=, [VariableReference(Pair<RequestHolder, Long> captureHolder, []), Expression(targetCollector.previewCaptured(timestamp), [])])    VariableReference(Pair<RequestHolder, Long> captureHolder, [])    Expression(targetCollector.previewCaptured(timestamp), [])  Statement(// No preview request queued, drop frame., [])  AssignmentExpression(=, [VariableReference(if (captureHolder, []), Expression(, [])])    VariableReference(if (captureHolder, [])    Expression(, [])  Statement(if (DEBUG) {, [])  MethodCall(Log.d(TAG, ""Dropping preview frame.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Dropping preview frame."", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Dropping preview frame."", [])  Statement(}, [])  Statement(if (doTiming) {, [])  Statement(endGlTiming(), [])  Statement(}, [])  Statement(return, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(RequestHolder request, []), Expression(captureHolder.first, [])])    VariableReference(RequestHolder request, [])    Expression(captureHolder.first, [])  AssignmentExpression(=, [VariableReference(Collection<Surface> targetSurfaces, []), Expression(request.getHolderTargets(), [])])    VariableReference(Collection<Surface> targetSurfaces, [])    Expression(request.getHolderTargets(), [])  Statement(if (doTiming) {, [])  Statement(addGlTimestamp(timestamp), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(List<Long> targetSurfaceIds, []), Expression(LegacyCameraDevice.getSurfaceIds(targetSurfaces), [])])    VariableReference(List<Long> targetSurfaceIds, [])    Expression(LegacyCameraDevice.getSurfaceIds(targetSurfaces), [])  Statement(for (EGLSurfaceHolder holder : mSurfaces) {, [])  MethodCall(if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)), [VariableReference(if (LegacyCameraDevice, []), Expression(holder.surface, []), Expression(targetSurfaceIds), [])])    VariableReference(if (LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(targetSurfaceIds), [])  Statement(try {, [])  MethodCall(LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(holder.width, []), Expression(holder.height, [])])    VariableReference(LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(holder.width, [])    Expression(holder.height, [])  MethodCall(LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(captureHolder.second, [])])    VariableReference(LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(captureHolder.second, [])  MethodCall(Log.w(TAG, ""Surface abandoned, dropping frame. "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Surface abandoned, []), Expression(dropping frame. "", []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Surface abandoned, [])    Expression(dropping frame. "", [])    Expression(e, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(for (EGLSurfaceHolder holder : mConversionSurfaces) {, [])  MethodCall(if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)), [VariableReference(if (LegacyCameraDevice, []), Expression(holder.surface, []), Expression(targetSurfaceIds), [])])    VariableReference(if (LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(targetSurfaceIds), [])  MethodCall(mPBufferPixels.clear(), [VariableReference(mPBufferPixels, []), Expression(, [])])    VariableReference(mPBufferPixels, [])    Expression(, [])  Statement(0, /*y*/, [])  Statement(0, holder.width, holder.height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, mPBufferPixels), [])  Statement(checkGlError(""glReadPixels""), [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(int format, []), Expression(LegacyCameraDevice.detectSurfaceType(holder.surface), [])])    VariableReference(int format, [])    Expression(LegacyCameraDevice.detectSurfaceType(holder.surface), [])  MethodCall(LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(captureHolder.second, [])])    VariableReference(LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(captureHolder.second, [])  MethodCall(LegacyCameraDevice.produceFrame(holder.surface, mPBufferPixels.array(), holder.width, holder.height, format), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(mPBufferPixels.array(), []), Expression(holder.width, []), Expression(holder.height, []), Expression(format, [])])    VariableReference(LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(mPBufferPixels.array(), [])    Expression(holder.width, [])    Expression(holder.height, [])    Expression(format, [])  MethodCall(Log.w(TAG, ""Surface abandoned, dropping frame. "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Surface abandoned, []), Expression(dropping frame. "", []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Surface abandoned, [])    Expression(dropping frame. "", [])    Expression(e, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  MethodCall(targetCollector.previewProduced(), [VariableReference(targetCollector, []), Expression(, [])])    VariableReference(targetCollector, [])    Expression(, [])  Statement(if (doTiming) {, [])  Statement(endGlTiming(), [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if ((mSurfaces, []), Expression(, [])]), Statement(return, []), Statement(}, []), AssignmentExpression(=, [VariableReference(boolean doTiming, []), Expression(targetCollector.hasPendingPreviewCaptures(), [])]), Statement(checkGlError(""before updateTexImage""), []), Statement(if (doTiming) {, []), Statement(beginGlTiming(), []), Statement(}, []), MethodCall(mSurfaceTexture.updateTexImage(), [VariableReference(mSurfaceTexture, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(long timestamp, []), Expression(mSurfaceTexture.getTimestamp(), [])]), AssignmentExpression(=, [VariableReference(Pair<RequestHolder, Long> captureHolder, []), Expression(targetCollector.previewCaptured(timestamp), [])]), Statement(// No preview request queued, drop frame., []), AssignmentExpression(=, [VariableReference(if (captureHolder, []), Expression(, [])]), Statement(if (DEBUG) {, []), MethodCall(Log.d(TAG, ""Dropping preview frame.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Dropping preview frame."", [])]), Statement(}, []), Statement(if (doTiming) {, []), Statement(endGlTiming(), []), Statement(}, []), Statement(return, []), Statement(}, []), AssignmentExpression(=, [VariableReference(RequestHolder request, []), Expression(captureHolder.first, [])]), AssignmentExpression(=, [VariableReference(Collection<Surface> targetSurfaces, []), Expression(request.getHolderTargets(), [])]), Statement(if (doTiming) {, []), Statement(addGlTimestamp(timestamp), []), Statement(}, []), AssignmentExpression(=, [VariableReference(List<Long> targetSurfaceIds, []), Expression(LegacyCameraDevice.getSurfaceIds(targetSurfaces), [])]), Statement(for (EGLSurfaceHolder holder : mSurfaces) {, []), MethodCall(if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)), [VariableReference(if (LegacyCameraDevice, []), Expression(holder.surface, []), Expression(targetSurfaceIds), [])]), Statement(try {, []), MethodCall(LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(holder.width, []), Expression(holder.height, [])]), MethodCall(LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(captureHolder.second, [])]), AssignmentExpression(=, [VariableReference(drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing, []), Expression(, [])]), MethodCall(Log.w(TAG, ""Surface abandoned, dropping frame. "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Surface abandoned, []), Expression(dropping frame. "", []), Expression(e, [])]), Statement(}, []), Statement(}, []), Statement(}, []), Statement(for (EGLSurfaceHolder holder : mConversionSurfaces) {, []), MethodCall(if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)), [VariableReference(if (LegacyCameraDevice, []), Expression(holder.surface, []), Expression(targetSurfaceIds), [])]), Statement(// glReadPixels reads from the bottom of the buffer, so add an extra vertical flip, []), AssignmentExpression(=, [VariableReference(drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing, []), Expression(, [])]), MethodCall(mPBufferPixels.clear(), [VariableReference(mPBufferPixels, []), Expression(, [])]), Statement(0, /*y*/, []), Statement(0, holder.width, holder.height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, mPBufferPixels), []), Statement(checkGlError(""glReadPixels""), []), Statement(try {, []), AssignmentExpression(=, [VariableReference(int format, []), Expression(LegacyCameraDevice.detectSurfaceType(holder.surface), [])]), MethodCall(LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(holder.width, []), Expression(holder.height, [])]), MethodCall(LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(captureHolder.second, [])]), MethodCall(LegacyCameraDevice.produceFrame(holder.surface, mPBufferPixels.array(), holder.width, holder.height, format), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(mPBufferPixels.array(), []), Expression(holder.width, []), Expression(holder.height, []), Expression(format, [])]), MethodCall(Log.w(TAG, ""Surface abandoned, dropping frame. "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Surface abandoned, []), Expression(dropping frame. "", []), Expression(e, [])]), Statement(}, []), Statement(}, []), Statement(}, []), MethodCall(targetCollector.previewProduced(), [VariableReference(targetCollector, []), Expression(, [])]), Statement(if (doTiming) {, []), Statement(endGlTiming(), []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if ((mSurfaces, []), Expression(, [])])    VariableReference(if ((mSurfaces, [])    Expression(, [])  Statement(return, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(boolean doTiming, []), Expression(targetCollector.hasPendingPreviewCaptures(), [])])    VariableReference(boolean doTiming, [])    Expression(targetCollector.hasPendingPreviewCaptures(), [])  Statement(checkGlError(""before updateTexImage""), [])  Statement(if (doTiming) {, [])  Statement(beginGlTiming(), [])  Statement(}, [])  MethodCall(mSurfaceTexture.updateTexImage(), [VariableReference(mSurfaceTexture, []), Expression(, [])])    VariableReference(mSurfaceTexture, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(long timestamp, []), Expression(mSurfaceTexture.getTimestamp(), [])])    VariableReference(long timestamp, [])    Expression(mSurfaceTexture.getTimestamp(), [])  AssignmentExpression(=, [VariableReference(Pair<RequestHolder, Long> captureHolder, []), Expression(targetCollector.previewCaptured(timestamp), [])])    VariableReference(Pair<RequestHolder, Long> captureHolder, [])    Expression(targetCollector.previewCaptured(timestamp), [])  Statement(// No preview request queued, drop frame., [])  AssignmentExpression(=, [VariableReference(if (captureHolder, []), Expression(, [])])    VariableReference(if (captureHolder, [])    Expression(, [])  Statement(if (DEBUG) {, [])  MethodCall(Log.d(TAG, ""Dropping preview frame.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Dropping preview frame."", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Dropping preview frame."", [])  Statement(}, [])  Statement(if (doTiming) {, [])  Statement(endGlTiming(), [])  Statement(}, [])  Statement(return, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(RequestHolder request, []), Expression(captureHolder.first, [])])    VariableReference(RequestHolder request, [])    Expression(captureHolder.first, [])  AssignmentExpression(=, [VariableReference(Collection<Surface> targetSurfaces, []), Expression(request.getHolderTargets(), [])])    VariableReference(Collection<Surface> targetSurfaces, [])    Expression(request.getHolderTargets(), [])  Statement(if (doTiming) {, [])  Statement(addGlTimestamp(timestamp), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(List<Long> targetSurfaceIds, []), Expression(LegacyCameraDevice.getSurfaceIds(targetSurfaces), [])])    VariableReference(List<Long> targetSurfaceIds, [])    Expression(LegacyCameraDevice.getSurfaceIds(targetSurfaces), [])  Statement(for (EGLSurfaceHolder holder : mSurfaces) {, [])  MethodCall(if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)), [VariableReference(if (LegacyCameraDevice, []), Expression(holder.surface, []), Expression(targetSurfaceIds), [])])    VariableReference(if (LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(targetSurfaceIds), [])  Statement(try {, [])  MethodCall(LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(holder.width, []), Expression(holder.height, [])])    VariableReference(LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(holder.width, [])    Expression(holder.height, [])  MethodCall(LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(captureHolder.second, [])])    VariableReference(LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(captureHolder.second, [])  AssignmentExpression(=, [VariableReference(drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing, []), Expression(, [])])    VariableReference(drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing, [])    Expression(, [])  MethodCall(Log.w(TAG, ""Surface abandoned, dropping frame. "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Surface abandoned, []), Expression(dropping frame. "", []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Surface abandoned, [])    Expression(dropping frame. "", [])    Expression(e, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(for (EGLSurfaceHolder holder : mConversionSurfaces) {, [])  MethodCall(if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)), [VariableReference(if (LegacyCameraDevice, []), Expression(holder.surface, []), Expression(targetSurfaceIds), [])])    VariableReference(if (LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(targetSurfaceIds), [])  Statement(// glReadPixels reads from the bottom of the buffer, so add an extra vertical flip, [])  AssignmentExpression(=, [VariableReference(drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing, []), Expression(, [])])    VariableReference(drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing, [])    Expression(, [])  MethodCall(mPBufferPixels.clear(), [VariableReference(mPBufferPixels, []), Expression(, [])])    VariableReference(mPBufferPixels, [])    Expression(, [])  Statement(0, /*y*/, [])  Statement(0, holder.width, holder.height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, mPBufferPixels), [])  Statement(checkGlError(""glReadPixels""), [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(int format, []), Expression(LegacyCameraDevice.detectSurfaceType(holder.surface), [])])    VariableReference(int format, [])    Expression(LegacyCameraDevice.detectSurfaceType(holder.surface), [])  MethodCall(LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(holder.width, []), Expression(holder.height, [])])    VariableReference(LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(holder.width, [])    Expression(holder.height, [])  MethodCall(LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(captureHolder.second, [])])    VariableReference(LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(captureHolder.second, [])  MethodCall(LegacyCameraDevice.produceFrame(holder.surface, mPBufferPixels.array(), holder.width, holder.height, format), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(mPBufferPixels.array(), []), Expression(holder.width, []), Expression(holder.height, []), Expression(format, [])])    VariableReference(LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(mPBufferPixels.array(), [])    Expression(holder.width, [])    Expression(holder.height, [])    Expression(format, [])  MethodCall(Log.w(TAG, ""Surface abandoned, dropping frame. "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Surface abandoned, []), Expression(dropping frame. "", []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Surface abandoned, [])    Expression(dropping frame. "", [])    Expression(e, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  MethodCall(targetCollector.previewProduced(), [VariableReference(targetCollector, []), Expression(, [])])    VariableReference(targetCollector, [])    Expression(, [])  Statement(if (doTiming) {, [])  Statement(endGlTiming(), [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Draw the current buffer in the {@link SurfaceTexture} returned from
 * {@link #getSurfaceTexture()} into the set of target {@link Surface}s
 * in the next request from the given {@link CaptureCollector}, or drop
 * the frame if none is available.
 *
 * <p>
 * Any {@link Surface}s targeted must be a subset of the {@link Surface}s
 * set in the last {@link #configureSurfaces(java.util.Collection)} call.
 * </p>
 *
 * @param targetCollector the surfaces to draw to.
 */
","/**
 * Draw the current buffer in the {@link SurfaceTexture} returned from
 * {@link #getSurfaceTexture()} into the set of target {@link Surface}s
 * in the next request from the given {@link CaptureCollector}, or drop
 * the frame if none is available.
 *
 * <p>
 * Any {@link Surface}s targeted must be a subset of the {@link Surface}s
 * set in the last {@link #configureSurfaces(java.util.Collection)} call.
 * </p>
 *
 * @param targetCollector the surfaces to draw to.
 */
",0,,,0,,,0,"1,2","4,5",0,"3,5","1,2","The code change includes the control flow change and the introduction of a new method call. In the late version, a new 'drawFrame' method call is added in the 'try' block of the two 'for' loops, which potentially changes the behavior of the method. Additionally, the control flow has been changed in the late version, where an 'if' statement is added to check the 'captureHolder' variable before the 'for' loops, which also potentially changes the behavior of the method.","The Compatibility Issue (CI) arises from the code change that could lead to different behaviors. The new 'drawFrame' method call in the late version could potentially throw a new exception or return a different value, which leads to CI type 1 and 2. The change in the control flow in the late version, where an 'if' statement is added before the 'for' loops, could potentially cause the method to skip the loops and return a different value, which leads to CI type 1."
168,"<android.accounts.AccountManager: AccountManagerFuture<Boolean> removeAccount(Account,AccountManagerCallback<Boolean>,Handler)>",21,22,"<android.accounts.AccountManager: AccountManagerFuture<Boolean> removeAccount(Account,AccountManagerCallback<Boolean>,Handler)>","<android.accounts.AccountManager: AccountManagerFuture<Boolean> removeAccount(Account,AccountManagerCallback<Boolean>,Handler)>",0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (account, []), Expression(, [])]), Statement(throw new IllegalArgumentException(""account is null""), []), Statement(return new Future2Task<Boolean>(handler, callback) {, []), Statement(public void doWork() throws RemoteException {, []), MethodCall(mService.removeAccount(mResponse, account), [VariableReference(mService, []), Expression(mResponse, []), Expression(account, [])]), Statement(}, []), Statement(public Boolean bundleToResult(Bundle bundle) throws AuthenticatorException {, []), MethodCall(if (!bundle.containsKey(KEY_BOOLEAN_RESULT)), [VariableReference(if (!bundle, []), Expression(KEY_BOOLEAN_RESULT), [])]), Statement(throw new AuthenticatorException(""no result in response""), []), Statement(}, []), MethodCall(return bundle.getBoolean(KEY_BOOLEAN_RESULT), [VariableReference(return bundle, []), Expression(KEY_BOOLEAN_RESULT, [])]), Statement(}, []), MethodCall(}.start(), [VariableReference(}, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (account, []), Expression(, [])])    VariableReference(if (account, [])    Expression(, [])  Statement(throw new IllegalArgumentException(""account is null""), [])  Statement(return new Future2Task<Boolean>(handler, callback) {, [])  Statement(public void doWork() throws RemoteException {, [])  MethodCall(mService.removeAccount(mResponse, account), [VariableReference(mService, []), Expression(mResponse, []), Expression(account, [])])    VariableReference(mService, [])    Expression(mResponse, [])    Expression(account, [])  Statement(}, [])  Statement(public Boolean bundleToResult(Bundle bundle) throws AuthenticatorException {, [])  MethodCall(if (!bundle.containsKey(KEY_BOOLEAN_RESULT)), [VariableReference(if (!bundle, []), Expression(KEY_BOOLEAN_RESULT), [])])    VariableReference(if (!bundle, [])    Expression(KEY_BOOLEAN_RESULT), [])  Statement(throw new AuthenticatorException(""no result in response""), [])  Statement(}, [])  MethodCall(return bundle.getBoolean(KEY_BOOLEAN_RESULT), [VariableReference(return bundle, []), Expression(KEY_BOOLEAN_RESULT, [])])    VariableReference(return bundle, [])    Expression(KEY_BOOLEAN_RESULT, [])  Statement(}, [])  MethodCall(}.start(), [VariableReference(}, []), Expression(, [])])    VariableReference(}, [])    Expression(, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (account, []), Expression(, [])]), Statement(throw new IllegalArgumentException(""account is null""), []), Statement(return new Future2Task<Boolean>(handler, callback) {, []), Statement(public void doWork() throws RemoteException {, []), MethodCall(mService.removeAccount(mResponse, account, false), [VariableReference(mService, []), Expression(mResponse, []), Expression(account, []), Expression(false, [])]), Statement(}, []), Statement(public Boolean bundleToResult(Bundle bundle) throws AuthenticatorException {, []), MethodCall(if (!bundle.containsKey(KEY_BOOLEAN_RESULT)), [VariableReference(if (!bundle, []), Expression(KEY_BOOLEAN_RESULT), [])]), Statement(throw new AuthenticatorException(""no result in response""), []), Statement(}, []), MethodCall(return bundle.getBoolean(KEY_BOOLEAN_RESULT), [VariableReference(return bundle, []), Expression(KEY_BOOLEAN_RESULT, [])]), Statement(}, []), MethodCall(}.start(), [VariableReference(}, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (account, []), Expression(, [])])    VariableReference(if (account, [])    Expression(, [])  Statement(throw new IllegalArgumentException(""account is null""), [])  Statement(return new Future2Task<Boolean>(handler, callback) {, [])  Statement(public void doWork() throws RemoteException {, [])  MethodCall(mService.removeAccount(mResponse, account, false), [VariableReference(mService, []), Expression(mResponse, []), Expression(account, []), Expression(false, [])])    VariableReference(mService, [])    Expression(mResponse, [])    Expression(account, [])    Expression(false, [])  Statement(}, [])  Statement(public Boolean bundleToResult(Bundle bundle) throws AuthenticatorException {, [])  MethodCall(if (!bundle.containsKey(KEY_BOOLEAN_RESULT)), [VariableReference(if (!bundle, []), Expression(KEY_BOOLEAN_RESULT), [])])    VariableReference(if (!bundle, [])    Expression(KEY_BOOLEAN_RESULT), [])  Statement(throw new AuthenticatorException(""no result in response""), [])  Statement(}, [])  MethodCall(return bundle.getBoolean(KEY_BOOLEAN_RESULT), [VariableReference(return bundle, []), Expression(KEY_BOOLEAN_RESULT, [])])    VariableReference(return bundle, [])    Expression(KEY_BOOLEAN_RESULT, [])  Statement(}, [])  MethodCall(}.start(), [VariableReference(}, []), Expression(, [])])    VariableReference(}, [])    Expression(, [])  Statement(}, [])",1,"/**
 * Removes an account from the AccountManager.  Does nothing if the account
 * does not exist.  Does not delete the account from the server.
 * The authenticator may have its own policies preventing account
 * deletion, in which case the account will not be deleted.
 *
 * <p>This method may be called from any thread, but the returned
 * {@link AccountManagerFuture} must not be used on the main thread.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#MANAGE_ACCOUNTS}.
 *
 * @param account The {@link Account} to remove
 * @param callback Callback to invoke when the request completes,
 * null for no callback
 * @param handler {@link Handler} identifying the callback thread,
 * null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Boolean,
 * true if the account has been successfully removed
 */
","/**
 * Removes an account from the AccountManager.  Does nothing if the account
 * does not exist.  Does not delete the account from the server.
 * The authenticator may have its own policies preventing account
 * deletion, in which case the account will not be deleted.
 *
 * <p>This method may be called from any thread, but the returned
 * {@link AccountManagerFuture} must not be used on the main thread.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#MANAGE_ACCOUNTS}.
 *
 * @param account The {@link Account} to remove
 * @param callback Callback to invoke when the request completes,
 * null for no callback
 * @param handler {@link Handler} identifying the callback thread,
 * null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Boolean,
 * true if the account has been successfully removed
 * @deprecated use
 * {@link #removeAccount(Account, Activity, AccountManagerCallback, Handler)}
 * instead
 */
",1,,[@Deprecated],1,,,0,"1,2",5,0,"3,5",1,"In the late version of the removeAccount method, there is an additional boolean parameter with a value of false in the mService.removeAccount method call. This additional parameter is not present in the early version of the method. Additionally, the late version of the method is annotated with @Deprecated, indicating that it is no longer the recommended way to remove an account and that it may be removed in a future version of the software. The control flow of the method remains the same, with an initial check for a null account parameter, followed by the creation of a Future2Task object that is started asynchronously.","The additional boolean parameter in the late version of the removeAccount method may cause the method to behave differently than the early version, as it could potentially affect the logic of the mService.removeAccount method. This could lead to compatibility issues if the method is called in the same way in both versions of the software but produces different results. The @Deprecated annotation also indicates that the method may be removed in the future, which could cause compatibility issues if the method is still being used in older versions of the software."
169,<android.widget.TextView: void setExtractedText(ExtractedText)>,22,23,<android.widget.TextView: void setExtractedText(ExtractedText)>,<android.widget.TextView: void setExtractedText(ExtractedText)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(Editable content, []), Expression(getEditableText(), [])]), AssignmentExpression(=, [VariableReference(if (text.text !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(if (content, []), Expression(, [])]), MethodCall(removeParcelableSpans(content, 0, content.length()), [VariableReference(removeParcelableSpans(content, 0, content, []), Expression(), [])]), MethodCall(content.replace(0, content.length(), text.text), [VariableReference(content, []), Expression(0, []), Expression(content.length(), []), Expression(text.text, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(final int N, []), Expression(content.length(), [])]), AssignmentExpression(=, [VariableReference(int start, []), Expression(text.partialStartOffset, [])]), Statement(if (start > N), []), AssignmentExpression(=, [VariableReference(start, []), Expression(N, [])]), AssignmentExpression(=, [VariableReference(int end, []), Expression(text.partialEndOffset, [])]), Statement(if (end > N), []), AssignmentExpression(=, [VariableReference(end, []), Expression(N, [])]), Statement(removeParcelableSpans(content, start, end), []), MethodCall(content.replace(start, end, text.text), [VariableReference(content, []), Expression(start, []), Expression(end, []), Expression(text.text, [])]), Statement(}, []), Statement(}, []), Statement(// Now set the selection position...  make sure it is in range, to, []), Statement(// avoid crashes.  If this is a partial update, it is possible that, []), Statement(// the underlying text may have changed, causing us problems here., []), Statement(// Also we just don't want to trust clients to do the right thing., []), AssignmentExpression(=, [VariableReference(Spannable sp, []), Expression((Spannable) getText(), [])]), AssignmentExpression(=, [VariableReference(final int N, []), Expression(sp.length(), [])]), AssignmentExpression(=, [VariableReference(int start, []), Expression(text.selectionStart, [])]), Statement(if (start < 0), []), AssignmentExpression(=, [VariableReference(start, []), Expression(0, [])]), Statement(else if (start > N), []), AssignmentExpression(=, [VariableReference(start, []), Expression(N, [])]), AssignmentExpression(=, [VariableReference(int end, []), Expression(text.selectionEnd, [])]), Statement(if (end < 0), []), AssignmentExpression(=, [VariableReference(end, []), Expression(0, [])]), Statement(else if (end > N), []), AssignmentExpression(=, [VariableReference(end, []), Expression(N, [])]), MethodCall(Selection.setSelection(sp, start, end), [VariableReference(Selection, []), Expression(sp, []), Expression(start, []), Expression(end, [])]), Statement(// Finally, update the selection mode., []), AssignmentExpression(=, [VariableReference(if ((text.flags & ExtractedText.FLAG_SELECTING) !, []), Expression(0) {, [])]), MethodCall(MetaKeyKeyListener.startSelecting(this, sp), [VariableReference(MetaKeyKeyListener, []), Expression(this, []), Expression(sp, [])]), Statement(} else {, []), MethodCall(MetaKeyKeyListener.stopSelecting(this, sp), [VariableReference(MetaKeyKeyListener, []), Expression(this, []), Expression(sp, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(Editable content, []), Expression(getEditableText(), [])])    VariableReference(Editable content, [])    Expression(getEditableText(), [])  AssignmentExpression(=, [VariableReference(if (text.text !, []), Expression(null) {, [])])    VariableReference(if (text.text !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(if (content, []), Expression(, [])])    VariableReference(if (content, [])    Expression(, [])  MethodCall(removeParcelableSpans(content, 0, content.length()), [VariableReference(removeParcelableSpans(content, 0, content, []), Expression(), [])])    VariableReference(removeParcelableSpans(content, 0, content, [])    Expression(), [])  MethodCall(content.replace(0, content.length(), text.text), [VariableReference(content, []), Expression(0, []), Expression(content.length(), []), Expression(text.text, [])])    VariableReference(content, [])    Expression(0, [])    Expression(content.length(), [])    Expression(text.text, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(final int N, []), Expression(content.length(), [])])    VariableReference(final int N, [])    Expression(content.length(), [])  AssignmentExpression(=, [VariableReference(int start, []), Expression(text.partialStartOffset, [])])    VariableReference(int start, [])    Expression(text.partialStartOffset, [])  Statement(if (start > N), [])  AssignmentExpression(=, [VariableReference(start, []), Expression(N, [])])    VariableReference(start, [])    Expression(N, [])  AssignmentExpression(=, [VariableReference(int end, []), Expression(text.partialEndOffset, [])])    VariableReference(int end, [])    Expression(text.partialEndOffset, [])  Statement(if (end > N), [])  AssignmentExpression(=, [VariableReference(end, []), Expression(N, [])])    VariableReference(end, [])    Expression(N, [])  Statement(removeParcelableSpans(content, start, end), [])  MethodCall(content.replace(start, end, text.text), [VariableReference(content, []), Expression(start, []), Expression(end, []), Expression(text.text, [])])    VariableReference(content, [])    Expression(start, [])    Expression(end, [])    Expression(text.text, [])  Statement(}, [])  Statement(}, [])  Statement(// Now set the selection position...  make sure it is in range, to, [])  Statement(// avoid crashes.  If this is a partial update, it is possible that, [])  Statement(// the underlying text may have changed, causing us problems here., [])  Statement(// Also we just don't want to trust clients to do the right thing., [])  AssignmentExpression(=, [VariableReference(Spannable sp, []), Expression((Spannable) getText(), [])])    VariableReference(Spannable sp, [])    Expression((Spannable) getText(), [])  AssignmentExpression(=, [VariableReference(final int N, []), Expression(sp.length(), [])])    VariableReference(final int N, [])    Expression(sp.length(), [])  AssignmentExpression(=, [VariableReference(int start, []), Expression(text.selectionStart, [])])    VariableReference(int start, [])    Expression(text.selectionStart, [])  Statement(if (start < 0), [])  AssignmentExpression(=, [VariableReference(start, []), Expression(0, [])])    VariableReference(start, [])    Expression(0, [])  Statement(else if (start > N), [])  AssignmentExpression(=, [VariableReference(start, []), Expression(N, [])])    VariableReference(start, [])    Expression(N, [])  AssignmentExpression(=, [VariableReference(int end, []), Expression(text.selectionEnd, [])])    VariableReference(int end, [])    Expression(text.selectionEnd, [])  Statement(if (end < 0), [])  AssignmentExpression(=, [VariableReference(end, []), Expression(0, [])])    VariableReference(end, [])    Expression(0, [])  Statement(else if (end > N), [])  AssignmentExpression(=, [VariableReference(end, []), Expression(N, [])])    VariableReference(end, [])    Expression(N, [])  MethodCall(Selection.setSelection(sp, start, end), [VariableReference(Selection, []), Expression(sp, []), Expression(start, []), Expression(end, [])])    VariableReference(Selection, [])    Expression(sp, [])    Expression(start, [])    Expression(end, [])  Statement(// Finally, update the selection mode., [])  AssignmentExpression(=, [VariableReference(if ((text.flags & ExtractedText.FLAG_SELECTING) !, []), Expression(0) {, [])])    VariableReference(if ((text.flags & ExtractedText.FLAG_SELECTING) !, [])    Expression(0) {, [])  MethodCall(MetaKeyKeyListener.startSelecting(this, sp), [VariableReference(MetaKeyKeyListener, []), Expression(this, []), Expression(sp, [])])    VariableReference(MetaKeyKeyListener, [])    Expression(this, [])    Expression(sp, [])  Statement(} else {, [])  MethodCall(MetaKeyKeyListener.stopSelecting(this, sp), [VariableReference(MetaKeyKeyListener, []), Expression(this, []), Expression(sp, [])])    VariableReference(MetaKeyKeyListener, [])    Expression(this, [])    Expression(sp, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(Editable content, []), Expression(getEditableText(), [])]), AssignmentExpression(=, [VariableReference(if (text.text !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(if (content, []), Expression(, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(int start, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(int end, []), Expression(content.length(), [])]), AssignmentExpression(=, [VariableReference(if (text.partialStartOffset >, []), Expression(0) {, [])]), AssignmentExpression(=, [VariableReference(final int N, []), Expression(content.length(), [])]), AssignmentExpression(=, [VariableReference(start, []), Expression(text.partialStartOffset, [])]), Statement(if (start > N), []), AssignmentExpression(=, [VariableReference(start, []), Expression(N, [])]), AssignmentExpression(=, [VariableReference(end, []), Expression(text.partialEndOffset, [])]), Statement(if (end > N), []), AssignmentExpression(=, [VariableReference(end, []), Expression(N, [])]), Statement(}, []), Statement(removeParcelableSpans(content, start, end), []), MethodCall(if (TextUtils.equals(content.subSequence(start, end), text.text)), [VariableReference(if (TextUtils, []), Expression(content.subSequence(start, []), Expression(end), []), Expression(text.text), [])]), Statement(// OK to copy spans only., []), MethodCall(TextUtils.copySpansFrom((Spanned) text.text, start, end, Object.class, content, start), [VariableReference(TextUtils, []), Expression((Spanned) text.text, []), Expression(start, []), Expression(end, []), Expression(Object.class, []), Expression(content, []), Expression(start, [])]), Statement(}, []), Statement(} else {, []), MethodCall(content.replace(start, end, text.text), [VariableReference(content, []), Expression(start, []), Expression(end, []), Expression(text.text, [])]), Statement(}, []), Statement(}, []), Statement(}, []), Statement(// Now set the selection position...  make sure it is in range, to, []), Statement(// avoid crashes.  If this is a partial update, it is possible that, []), Statement(// the underlying text may have changed, causing us problems here., []), Statement(// Also we just don't want to trust clients to do the right thing., []), AssignmentExpression(=, [VariableReference(Spannable sp, []), Expression((Spannable) getText(), [])]), AssignmentExpression(=, [VariableReference(final int N, []), Expression(sp.length(), [])]), AssignmentExpression(=, [VariableReference(int start, []), Expression(text.selectionStart, [])]), Statement(if (start < 0), []), AssignmentExpression(=, [VariableReference(start, []), Expression(0, [])]), Statement(else if (start > N), []), AssignmentExpression(=, [VariableReference(start, []), Expression(N, [])]), AssignmentExpression(=, [VariableReference(int end, []), Expression(text.selectionEnd, [])]), Statement(if (end < 0), []), AssignmentExpression(=, [VariableReference(end, []), Expression(0, [])]), Statement(else if (end > N), []), AssignmentExpression(=, [VariableReference(end, []), Expression(N, [])]), MethodCall(Selection.setSelection(sp, start, end), [VariableReference(Selection, []), Expression(sp, []), Expression(start, []), Expression(end, [])]), Statement(// Finally, update the selection mode., []), AssignmentExpression(=, [VariableReference(if ((text.flags & ExtractedText.FLAG_SELECTING) !, []), Expression(0) {, [])]), MethodCall(MetaKeyKeyListener.startSelecting(this, sp), [VariableReference(MetaKeyKeyListener, []), Expression(this, []), Expression(sp, [])]), Statement(} else {, []), MethodCall(MetaKeyKeyListener.stopSelecting(this, sp), [VariableReference(MetaKeyKeyListener, []), Expression(this, []), Expression(sp, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(Editable content, []), Expression(getEditableText(), [])])    VariableReference(Editable content, [])    Expression(getEditableText(), [])  AssignmentExpression(=, [VariableReference(if (text.text !, []), Expression(null) {, [])])    VariableReference(if (text.text !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(if (content, []), Expression(, [])])    VariableReference(if (content, [])    Expression(, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(int start, []), Expression(0, [])])    VariableReference(int start, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(int end, []), Expression(content.length(), [])])    VariableReference(int end, [])    Expression(content.length(), [])  AssignmentExpression(=, [VariableReference(if (text.partialStartOffset >, []), Expression(0) {, [])])    VariableReference(if (text.partialStartOffset >, [])    Expression(0) {, [])  AssignmentExpression(=, [VariableReference(final int N, []), Expression(content.length(), [])])    VariableReference(final int N, [])    Expression(content.length(), [])  AssignmentExpression(=, [VariableReference(start, []), Expression(text.partialStartOffset, [])])    VariableReference(start, [])    Expression(text.partialStartOffset, [])  Statement(if (start > N), [])  AssignmentExpression(=, [VariableReference(start, []), Expression(N, [])])    VariableReference(start, [])    Expression(N, [])  AssignmentExpression(=, [VariableReference(end, []), Expression(text.partialEndOffset, [])])    VariableReference(end, [])    Expression(text.partialEndOffset, [])  Statement(if (end > N), [])  AssignmentExpression(=, [VariableReference(end, []), Expression(N, [])])    VariableReference(end, [])    Expression(N, [])  Statement(}, [])  Statement(removeParcelableSpans(content, start, end), [])  MethodCall(if (TextUtils.equals(content.subSequence(start, end), text.text)), [VariableReference(if (TextUtils, []), Expression(content.subSequence(start, []), Expression(end), []), Expression(text.text), [])])    VariableReference(if (TextUtils, [])    Expression(content.subSequence(start, [])    Expression(end), [])    Expression(text.text), [])  Statement(// OK to copy spans only., [])  MethodCall(TextUtils.copySpansFrom((Spanned) text.text, start, end, Object.class, content, start), [VariableReference(TextUtils, []), Expression((Spanned) text.text, []), Expression(start, []), Expression(end, []), Expression(Object.class, []), Expression(content, []), Expression(start, [])])    VariableReference(TextUtils, [])    Expression((Spanned) text.text, [])    Expression(start, [])    Expression(end, [])    Expression(Object.class, [])    Expression(content, [])    Expression(start, [])  Statement(}, [])  Statement(} else {, [])  MethodCall(content.replace(start, end, text.text), [VariableReference(content, []), Expression(start, []), Expression(end, []), Expression(text.text, [])])    VariableReference(content, [])    Expression(start, [])    Expression(end, [])    Expression(text.text, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(// Now set the selection position...  make sure it is in range, to, [])  Statement(// avoid crashes.  If this is a partial update, it is possible that, [])  Statement(// the underlying text may have changed, causing us problems here., [])  Statement(// Also we just don't want to trust clients to do the right thing., [])  AssignmentExpression(=, [VariableReference(Spannable sp, []), Expression((Spannable) getText(), [])])    VariableReference(Spannable sp, [])    Expression((Spannable) getText(), [])  AssignmentExpression(=, [VariableReference(final int N, []), Expression(sp.length(), [])])    VariableReference(final int N, [])    Expression(sp.length(), [])  AssignmentExpression(=, [VariableReference(int start, []), Expression(text.selectionStart, [])])    VariableReference(int start, [])    Expression(text.selectionStart, [])  Statement(if (start < 0), [])  AssignmentExpression(=, [VariableReference(start, []), Expression(0, [])])    VariableReference(start, [])    Expression(0, [])  Statement(else if (start > N), [])  AssignmentExpression(=, [VariableReference(start, []), Expression(N, [])])    VariableReference(start, [])    Expression(N, [])  AssignmentExpression(=, [VariableReference(int end, []), Expression(text.selectionEnd, [])])    VariableReference(int end, [])    Expression(text.selectionEnd, [])  Statement(if (end < 0), [])  AssignmentExpression(=, [VariableReference(end, []), Expression(0, [])])    VariableReference(end, [])    Expression(0, [])  Statement(else if (end > N), [])  AssignmentExpression(=, [VariableReference(end, []), Expression(N, [])])    VariableReference(end, [])    Expression(N, [])  MethodCall(Selection.setSelection(sp, start, end), [VariableReference(Selection, []), Expression(sp, []), Expression(start, []), Expression(end, [])])    VariableReference(Selection, [])    Expression(sp, [])    Expression(start, [])    Expression(end, [])  Statement(// Finally, update the selection mode., [])  AssignmentExpression(=, [VariableReference(if ((text.flags & ExtractedText.FLAG_SELECTING) !, []), Expression(0) {, [])])    VariableReference(if ((text.flags & ExtractedText.FLAG_SELECTING) !, [])    Expression(0) {, [])  MethodCall(MetaKeyKeyListener.startSelecting(this, sp), [VariableReference(MetaKeyKeyListener, []), Expression(this, []), Expression(sp, [])])    VariableReference(MetaKeyKeyListener, [])    Expression(this, [])    Expression(sp, [])  Statement(} else {, [])  MethodCall(MetaKeyKeyListener.stopSelecting(this, sp), [VariableReference(MetaKeyKeyListener, []), Expression(this, []), Expression(sp, [])])    VariableReference(MetaKeyKeyListener, [])    Expression(this, [])    Expression(sp, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Apply to this text view the given extracted text, as previously
 * returned by {@link #extractText(ExtractedTextRequest, ExtractedText)}.
 */
","/**
 * Apply to this text view the given extracted text, as previously
 * returned by {@link #extractText(ExtractedTextRequest, ExtractedText)}.
 */
",0,,,0,,,0,"1,2","3,4,5",0,"3,4",1,"The implementation of the setExtractedText method has been modified in the late version. Firstly, there is a change in control dependency as the condition for the if-else statement has been changed from checking ""if (content)"" to ""} else {"". Secondly, there is a change in other statements as the way the start and end variables are assigned and the way the text content is replaced has been modified.","The Compatibility Issue arises due to the potential for the setExtractedText method to return a different value in the late version. The changes in control dependency and other statements could result in the text content being replaced differently, which would lead to a different value being returned."
170,<android.net.Uri: Uri normalizeScheme()>,22,23,<android.net.Uri: Uri normalizeScheme()>,<android.net.Uri: Uri normalizeScheme()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(String scheme, []), Expression(getScheme(), [])]), Statement(// give up, []), AssignmentExpression(=, [VariableReference(if (scheme, []), Expression(, [])]), Statement(return this, []), AssignmentExpression(=, [VariableReference(String lowerScheme, []), Expression(scheme.toLowerCase(Locale.ROOT), [])]), Statement(// no change, []), MethodCall(if (scheme.equals(lowerScheme)), [VariableReference(if (scheme, []), Expression(lowerScheme), [])]), Statement(return this, []), MethodCall(return buildUpon().scheme(lowerScheme).build(), [VariableReference(return buildUpon(), []), Expression(lowerScheme).build(, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(String scheme, []), Expression(getScheme(), [])])    VariableReference(String scheme, [])    Expression(getScheme(), [])  Statement(// give up, [])  AssignmentExpression(=, [VariableReference(if (scheme, []), Expression(, [])])    VariableReference(if (scheme, [])    Expression(, [])  Statement(return this, [])  AssignmentExpression(=, [VariableReference(String lowerScheme, []), Expression(scheme.toLowerCase(Locale.ROOT), [])])    VariableReference(String lowerScheme, [])    Expression(scheme.toLowerCase(Locale.ROOT), [])  Statement(// no change, [])  MethodCall(if (scheme.equals(lowerScheme)), [VariableReference(if (scheme, []), Expression(lowerScheme), [])])    VariableReference(if (scheme, [])    Expression(lowerScheme), [])  Statement(return this, [])  MethodCall(return buildUpon().scheme(lowerScheme).build(), [VariableReference(return buildUpon(), []), Expression(lowerScheme).build(, [])])    VariableReference(return buildUpon(), [])    Expression(lowerScheme).build(, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(String scheme, []), Expression(getScheme(), [])]), Statement(// give up, []), AssignmentExpression(=, [VariableReference(if (scheme, []), Expression(, [])]), Statement(return this, []), AssignmentExpression(=, [VariableReference(String lowerScheme, []), Expression(scheme.toLowerCase(Locale.ROOT), [])]), Statement(// no change, []), MethodCall(if (scheme.equals(lowerScheme)), [VariableReference(if (scheme, []), Expression(lowerScheme), [])]), Statement(return this, []), MethodCall(return buildUpon().scheme(lowerScheme).build(), [VariableReference(return buildUpon(), []), Expression(lowerScheme).build(, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(String scheme, []), Expression(getScheme(), [])])    VariableReference(String scheme, [])    Expression(getScheme(), [])  Statement(// give up, [])  AssignmentExpression(=, [VariableReference(if (scheme, []), Expression(, [])])    VariableReference(if (scheme, [])    Expression(, [])  Statement(return this, [])  AssignmentExpression(=, [VariableReference(String lowerScheme, []), Expression(scheme.toLowerCase(Locale.ROOT), [])])    VariableReference(String lowerScheme, [])    Expression(scheme.toLowerCase(Locale.ROOT), [])  Statement(// no change, [])  MethodCall(if (scheme.equals(lowerScheme)), [VariableReference(if (scheme, []), Expression(lowerScheme), [])])    VariableReference(if (scheme, [])    Expression(lowerScheme), [])  Statement(return this, [])  MethodCall(return buildUpon().scheme(lowerScheme).build(), [VariableReference(return buildUpon(), []), Expression(lowerScheme).build(, [])])    VariableReference(return buildUpon(), [])    Expression(lowerScheme).build(, [])  Statement(}, [])",0,"/**
 * Return an equivalent URI with a lowercase scheme component.
 * This aligns the Uri with Android best practices for
 * intent filtering.
 *
 * <p>For example, ""HTTP://www.android.com"" becomes
 * ""http://www.android.com""
 *
 * <p>All URIs received from outside Android (such as user input,
 * or external sources like Bluetooth, NFC, or the Internet) should
 * be normalized before they are used to create an Intent.
 *
 * <p class=""note"">This method does <em>not</em> validate bad URI's,
 * or 'fix' poorly formatted URI's - so do not use it for input validation.
 * A Uri will always be returned, even if the Uri is badly formatted to
 * begin with and a scheme component cannot be found.
 *
 * @return normalized Uri (never null)
 * @see {@link android.content.Intent#setData}
 * @see {@link #setNormalizedData}
 */
","/**
 * Return an equivalent URI with a lowercase scheme component.
 * This aligns the Uri with Android best practices for
 * intent filtering.
 *
 * <p>For example, ""HTTP://www.android.com"" becomes
 * ""http://www.android.com""
 *
 * <p>All URIs received from outside Android (such as user input,
 * or external sources like Bluetooth, NFC, or the Internet) should
 * be normalized before they are used to create an Intent.
 *
 * <p class=""note"">This method does <em>not</em> validate bad URI's,
 * or 'fix' poorly formatted URI's - so do not use it for input validation.
 * A Uri will always be returned, even if the Uri is badly formatted to
 * begin with and a scheme component cannot be found.
 *
 * @return normalized Uri (never null)
 * @see {@link android.content.Intent#setData}
 * @see {@link android.content.Intent#setDataAndNormalize}
 */
",1,,,0,,,0,0,0,0,5,0,The change between the two versions is that the method `setDataAndNormalize` is referred in the late version's comment but not in the early version. This is considered as a "Dependent API changed" type.,"The change in the comment does not affect the behavior of the `normalizeScheme` method, so there is no Compatibility Issue."
171,"<android.content.ContextWrapper: void sendStickyOrderedBroadcastAsUser(Intent,UserHandle,BroadcastReceiver,Handler,int,String,Bundle)>",22,23,"<android.content.ContextWrapper: void sendStickyOrderedBroadcastAsUser(Intent,UserHandle,BroadcastReceiver,Handler,int,String,Bundle)>","<android.content.ContextWrapper: void sendStickyOrderedBroadcastAsUser(Intent,UserHandle,BroadcastReceiver,Handler,int,String,Bundle)>",0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(mBase.sendStickyOrderedBroadcastAsUser(intent, user, resultReceiver, scheduler, initialCode, initialData, initialExtras), [VariableReference(mBase, []), Expression(intent, []), Expression(user, []), Expression(resultReceiver, []), Expression(scheduler, []), Expression(initialCode, []), Expression(initialData, []), Expression(initialExtras, [])]), Statement(}, [])])  Statement({, [])  MethodCall(mBase.sendStickyOrderedBroadcastAsUser(intent, user, resultReceiver, scheduler, initialCode, initialData, initialExtras), [VariableReference(mBase, []), Expression(intent, []), Expression(user, []), Expression(resultReceiver, []), Expression(scheduler, []), Expression(initialCode, []), Expression(initialData, []), Expression(initialExtras, [])])    VariableReference(mBase, [])    Expression(intent, [])    Expression(user, [])    Expression(resultReceiver, [])    Expression(scheduler, [])    Expression(initialCode, [])    Expression(initialData, [])    Expression(initialExtras, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(mBase.sendStickyOrderedBroadcastAsUser(intent, user, resultReceiver, scheduler, initialCode, initialData, initialExtras), [VariableReference(mBase, []), Expression(intent, []), Expression(user, []), Expression(resultReceiver, []), Expression(scheduler, []), Expression(initialCode, []), Expression(initialData, []), Expression(initialExtras, [])]), Statement(}, [])])  Statement({, [])  MethodCall(mBase.sendStickyOrderedBroadcastAsUser(intent, user, resultReceiver, scheduler, initialCode, initialData, initialExtras), [VariableReference(mBase, []), Expression(intent, []), Expression(user, []), Expression(resultReceiver, []), Expression(scheduler, []), Expression(initialCode, []), Expression(initialData, []), Expression(initialExtras, [])])    VariableReference(mBase, [])    Expression(intent, [])    Expression(user, [])    Expression(resultReceiver, [])    Expression(scheduler, [])    Expression(initialCode, [])    Expression(initialData, [])    Expression(initialExtras, [])  Statement(}, [])",0,,,0,[@Override],"[@Override, @Deprecated]",1,,,0,0,0,0,5,0,"The method has been annotated with `@Deprecated` in the late version, indicating that it is no longer recommended for use.","No compatibility issues exist as the code implementation has not changed and the method still behaves the same way. The `@Deprecated` annotation only suggests that a different method should be used instead, but it does not affect the functionality of the current method."
172,<android.hardware.camera2.legacy.SurfaceTextureRenderer: void drawIntoSurfaces(CaptureCollector)>,23,24,<android.hardware.camera2.legacy.SurfaceTextureRenderer: void drawIntoSurfaces(CaptureCollector)>,<android.hardware.camera2.legacy.SurfaceTextureRenderer: void drawIntoSurfaces(CaptureCollector)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if ((mSurfaces, []), Expression(, [])]), Statement(return, []), Statement(}, []), AssignmentExpression(=, [VariableReference(boolean doTiming, []), Expression(targetCollector.hasPendingPreviewCaptures(), [])]), Statement(checkGlError(""before updateTexImage""), []), Statement(if (doTiming) {, []), Statement(beginGlTiming(), []), Statement(}, []), MethodCall(mSurfaceTexture.updateTexImage(), [VariableReference(mSurfaceTexture, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(long timestamp, []), Expression(mSurfaceTexture.getTimestamp(), [])]), AssignmentExpression(=, [VariableReference(Pair<RequestHolder, Long> captureHolder, []), Expression(targetCollector.previewCaptured(timestamp), [])]), Statement(// No preview request queued, drop frame., []), AssignmentExpression(=, [VariableReference(if (captureHolder, []), Expression(, [])]), Statement(if (DEBUG) {, []), MethodCall(Log.d(TAG, ""Dropping preview frame.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Dropping preview frame."", [])]), Statement(}, []), Statement(if (doTiming) {, []), Statement(endGlTiming(), []), Statement(}, []), Statement(return, []), Statement(}, []), AssignmentExpression(=, [VariableReference(RequestHolder request, []), Expression(captureHolder.first, [])]), AssignmentExpression(=, [VariableReference(Collection<Surface> targetSurfaces, []), Expression(request.getHolderTargets(), [])]), Statement(if (doTiming) {, []), Statement(addGlTimestamp(timestamp), []), Statement(}, []), AssignmentExpression(=, [VariableReference(List<Long> targetSurfaceIds, []), Expression(LegacyCameraDevice.getSurfaceIds(targetSurfaces), [])]), Statement(for (EGLSurfaceHolder holder : mSurfaces) {, []), MethodCall(if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)), [VariableReference(if (LegacyCameraDevice, []), Expression(holder.surface, []), Expression(targetSurfaceIds), [])]), Statement(try {, []), MethodCall(LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(holder.width, []), Expression(holder.height, [])]), MethodCall(LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(captureHolder.second, [])]), AssignmentExpression(=, [VariableReference(drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing, []), Expression(, [])]), MethodCall(Log.w(TAG, ""Surface abandoned, dropping frame. "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Surface abandoned, []), Expression(dropping frame. "", []), Expression(e, [])]), Statement(}, []), Statement(}, []), Statement(}, []), Statement(for (EGLSurfaceHolder holder : mConversionSurfaces) {, []), MethodCall(if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)), [VariableReference(if (LegacyCameraDevice, []), Expression(holder.surface, []), Expression(targetSurfaceIds), [])]), Statement(// glReadPixels reads from the bottom of the buffer, so add an extra vertical flip, []), AssignmentExpression(=, [VariableReference(drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing, []), Expression(, [])]), MethodCall(mPBufferPixels.clear(), [VariableReference(mPBufferPixels, []), Expression(, [])]), Statement(0, /*y*/, []), Statement(0, holder.width, holder.height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, mPBufferPixels), []), Statement(checkGlError(""glReadPixels""), []), Statement(try {, []), AssignmentExpression(=, [VariableReference(int format, []), Expression(LegacyCameraDevice.detectSurfaceType(holder.surface), [])]), MethodCall(LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(holder.width, []), Expression(holder.height, [])]), MethodCall(LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(captureHolder.second, [])]), MethodCall(LegacyCameraDevice.produceFrame(holder.surface, mPBufferPixels.array(), holder.width, holder.height, format), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(mPBufferPixels.array(), []), Expression(holder.width, []), Expression(holder.height, []), Expression(format, [])]), MethodCall(Log.w(TAG, ""Surface abandoned, dropping frame. "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Surface abandoned, []), Expression(dropping frame. "", []), Expression(e, [])]), Statement(}, []), Statement(}, []), Statement(}, []), MethodCall(targetCollector.previewProduced(), [VariableReference(targetCollector, []), Expression(, [])]), Statement(if (doTiming) {, []), Statement(endGlTiming(), []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if ((mSurfaces, []), Expression(, [])])    VariableReference(if ((mSurfaces, [])    Expression(, [])  Statement(return, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(boolean doTiming, []), Expression(targetCollector.hasPendingPreviewCaptures(), [])])    VariableReference(boolean doTiming, [])    Expression(targetCollector.hasPendingPreviewCaptures(), [])  Statement(checkGlError(""before updateTexImage""), [])  Statement(if (doTiming) {, [])  Statement(beginGlTiming(), [])  Statement(}, [])  MethodCall(mSurfaceTexture.updateTexImage(), [VariableReference(mSurfaceTexture, []), Expression(, [])])    VariableReference(mSurfaceTexture, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(long timestamp, []), Expression(mSurfaceTexture.getTimestamp(), [])])    VariableReference(long timestamp, [])    Expression(mSurfaceTexture.getTimestamp(), [])  AssignmentExpression(=, [VariableReference(Pair<RequestHolder, Long> captureHolder, []), Expression(targetCollector.previewCaptured(timestamp), [])])    VariableReference(Pair<RequestHolder, Long> captureHolder, [])    Expression(targetCollector.previewCaptured(timestamp), [])  Statement(// No preview request queued, drop frame., [])  AssignmentExpression(=, [VariableReference(if (captureHolder, []), Expression(, [])])    VariableReference(if (captureHolder, [])    Expression(, [])  Statement(if (DEBUG) {, [])  MethodCall(Log.d(TAG, ""Dropping preview frame.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Dropping preview frame."", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Dropping preview frame."", [])  Statement(}, [])  Statement(if (doTiming) {, [])  Statement(endGlTiming(), [])  Statement(}, [])  Statement(return, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(RequestHolder request, []), Expression(captureHolder.first, [])])    VariableReference(RequestHolder request, [])    Expression(captureHolder.first, [])  AssignmentExpression(=, [VariableReference(Collection<Surface> targetSurfaces, []), Expression(request.getHolderTargets(), [])])    VariableReference(Collection<Surface> targetSurfaces, [])    Expression(request.getHolderTargets(), [])  Statement(if (doTiming) {, [])  Statement(addGlTimestamp(timestamp), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(List<Long> targetSurfaceIds, []), Expression(LegacyCameraDevice.getSurfaceIds(targetSurfaces), [])])    VariableReference(List<Long> targetSurfaceIds, [])    Expression(LegacyCameraDevice.getSurfaceIds(targetSurfaces), [])  Statement(for (EGLSurfaceHolder holder : mSurfaces) {, [])  MethodCall(if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)), [VariableReference(if (LegacyCameraDevice, []), Expression(holder.surface, []), Expression(targetSurfaceIds), [])])    VariableReference(if (LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(targetSurfaceIds), [])  Statement(try {, [])  MethodCall(LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(holder.width, []), Expression(holder.height, [])])    VariableReference(LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(holder.width, [])    Expression(holder.height, [])  MethodCall(LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(captureHolder.second, [])])    VariableReference(LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(captureHolder.second, [])  AssignmentExpression(=, [VariableReference(drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing, []), Expression(, [])])    VariableReference(drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing, [])    Expression(, [])  MethodCall(Log.w(TAG, ""Surface abandoned, dropping frame. "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Surface abandoned, []), Expression(dropping frame. "", []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Surface abandoned, [])    Expression(dropping frame. "", [])    Expression(e, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(for (EGLSurfaceHolder holder : mConversionSurfaces) {, [])  MethodCall(if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)), [VariableReference(if (LegacyCameraDevice, []), Expression(holder.surface, []), Expression(targetSurfaceIds), [])])    VariableReference(if (LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(targetSurfaceIds), [])  Statement(// glReadPixels reads from the bottom of the buffer, so add an extra vertical flip, [])  AssignmentExpression(=, [VariableReference(drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing, []), Expression(, [])])    VariableReference(drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing, [])    Expression(, [])  MethodCall(mPBufferPixels.clear(), [VariableReference(mPBufferPixels, []), Expression(, [])])    VariableReference(mPBufferPixels, [])    Expression(, [])  Statement(0, /*y*/, [])  Statement(0, holder.width, holder.height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, mPBufferPixels), [])  Statement(checkGlError(""glReadPixels""), [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(int format, []), Expression(LegacyCameraDevice.detectSurfaceType(holder.surface), [])])    VariableReference(int format, [])    Expression(LegacyCameraDevice.detectSurfaceType(holder.surface), [])  MethodCall(LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(holder.width, []), Expression(holder.height, [])])    VariableReference(LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(holder.width, [])    Expression(holder.height, [])  MethodCall(LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(captureHolder.second, [])])    VariableReference(LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(captureHolder.second, [])  MethodCall(LegacyCameraDevice.produceFrame(holder.surface, mPBufferPixels.array(), holder.width, holder.height, format), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(mPBufferPixels.array(), []), Expression(holder.width, []), Expression(holder.height, []), Expression(format, [])])    VariableReference(LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(mPBufferPixels.array(), [])    Expression(holder.width, [])    Expression(holder.height, [])    Expression(format, [])  MethodCall(Log.w(TAG, ""Surface abandoned, dropping frame. "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Surface abandoned, []), Expression(dropping frame. "", []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Surface abandoned, [])    Expression(dropping frame. "", [])    Expression(e, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  MethodCall(targetCollector.previewProduced(), [VariableReference(targetCollector, []), Expression(, [])])    VariableReference(targetCollector, [])    Expression(, [])  Statement(if (doTiming) {, [])  Statement(endGlTiming(), [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if ((mSurfaces, []), Expression(, [])]), Statement(return, []), Statement(}, []), AssignmentExpression(=, [VariableReference(boolean doTiming, []), Expression(targetCollector.hasPendingPreviewCaptures(), [])]), Statement(checkGlError(""before updateTexImage""), []), Statement(if (doTiming) {, []), Statement(beginGlTiming(), []), Statement(}, []), MethodCall(mSurfaceTexture.updateTexImage(), [VariableReference(mSurfaceTexture, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(long timestamp, []), Expression(mSurfaceTexture.getTimestamp(), [])]), AssignmentExpression(=, [VariableReference(Pair<RequestHolder, Long> captureHolder, []), Expression(targetCollector.previewCaptured(timestamp), [])]), Statement(// No preview request queued, drop frame., []), AssignmentExpression(=, [VariableReference(if (captureHolder, []), Expression(, [])]), Statement(if (DEBUG) {, []), MethodCall(Log.d(TAG, ""Dropping preview frame.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Dropping preview frame."", [])]), Statement(}, []), Statement(if (doTiming) {, []), Statement(endGlTiming(), []), Statement(}, []), Statement(return, []), Statement(}, []), AssignmentExpression(=, [VariableReference(RequestHolder request, []), Expression(captureHolder.first, [])]), AssignmentExpression(=, [VariableReference(Collection<Surface> targetSurfaces, []), Expression(request.getHolderTargets(), [])]), Statement(if (doTiming) {, []), Statement(addGlTimestamp(timestamp), []), Statement(}, []), AssignmentExpression(=, [VariableReference(List<Long> targetSurfaceIds, []), Expression(new ArrayList(), [])]), Statement(try {, []), AssignmentExpression(=, [VariableReference(targetSurfaceIds, []), Expression(LegacyCameraDevice.getSurfaceIds(targetSurfaces), [])]), MethodCall(Log.w(TAG, ""Surface abandoned, dropping frame. "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Surface abandoned, []), Expression(dropping frame. "", []), Expression(e, [])]), MethodCall(request.setOutputAbandoned(), [VariableReference(request, []), Expression(, [])]), Statement(}, []), Statement(for (EGLSurfaceHolder holder : mSurfaces) {, []), MethodCall(if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)), [VariableReference(if (LegacyCameraDevice, []), Expression(holder.surface, []), Expression(targetSurfaceIds), [])]), Statement(try {, []), MethodCall(LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(holder.width, []), Expression(holder.height, [])]), MethodCall(LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(captureHolder.second, [])]), AssignmentExpression(=, [VariableReference(drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing, []), Expression(, [])]), MethodCall(Log.w(TAG, ""Surface abandoned, dropping frame. "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Surface abandoned, []), Expression(dropping frame. "", []), Expression(e, [])]), MethodCall(request.setOutputAbandoned(), [VariableReference(request, []), Expression(, [])]), Statement(}, []), Statement(}, []), Statement(}, []), Statement(for (EGLSurfaceHolder holder : mConversionSurfaces) {, []), MethodCall(if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)), [VariableReference(if (LegacyCameraDevice, []), Expression(holder.surface, []), Expression(targetSurfaceIds), [])]), Statement(// glReadPixels reads from the bottom of the buffer, so add an extra vertical flip, []), AssignmentExpression(=, [VariableReference(drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing, []), Expression(, [])]), MethodCall(mPBufferPixels.clear(), [VariableReference(mPBufferPixels, []), Expression(, [])]), Statement(0, /*y*/, []), Statement(0, holder.width, holder.height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, mPBufferPixels), []), Statement(checkGlError(""glReadPixels""), []), Statement(try {, []), AssignmentExpression(=, [VariableReference(int format, []), Expression(LegacyCameraDevice.detectSurfaceType(holder.surface), [])]), MethodCall(LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(holder.width, []), Expression(holder.height, [])]), MethodCall(LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(captureHolder.second, [])]), MethodCall(LegacyCameraDevice.produceFrame(holder.surface, mPBufferPixels.array(), holder.width, holder.height, format), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(mPBufferPixels.array(), []), Expression(holder.width, []), Expression(holder.height, []), Expression(format, [])]), MethodCall(Log.w(TAG, ""Surface abandoned, dropping frame. "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Surface abandoned, []), Expression(dropping frame. "", []), Expression(e, [])]), MethodCall(request.setOutputAbandoned(), [VariableReference(request, []), Expression(, [])]), Statement(}, []), Statement(}, []), Statement(}, []), MethodCall(targetCollector.previewProduced(), [VariableReference(targetCollector, []), Expression(, [])]), Statement(if (doTiming) {, []), Statement(endGlTiming(), []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if ((mSurfaces, []), Expression(, [])])    VariableReference(if ((mSurfaces, [])    Expression(, [])  Statement(return, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(boolean doTiming, []), Expression(targetCollector.hasPendingPreviewCaptures(), [])])    VariableReference(boolean doTiming, [])    Expression(targetCollector.hasPendingPreviewCaptures(), [])  Statement(checkGlError(""before updateTexImage""), [])  Statement(if (doTiming) {, [])  Statement(beginGlTiming(), [])  Statement(}, [])  MethodCall(mSurfaceTexture.updateTexImage(), [VariableReference(mSurfaceTexture, []), Expression(, [])])    VariableReference(mSurfaceTexture, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(long timestamp, []), Expression(mSurfaceTexture.getTimestamp(), [])])    VariableReference(long timestamp, [])    Expression(mSurfaceTexture.getTimestamp(), [])  AssignmentExpression(=, [VariableReference(Pair<RequestHolder, Long> captureHolder, []), Expression(targetCollector.previewCaptured(timestamp), [])])    VariableReference(Pair<RequestHolder, Long> captureHolder, [])    Expression(targetCollector.previewCaptured(timestamp), [])  Statement(// No preview request queued, drop frame., [])  AssignmentExpression(=, [VariableReference(if (captureHolder, []), Expression(, [])])    VariableReference(if (captureHolder, [])    Expression(, [])  Statement(if (DEBUG) {, [])  MethodCall(Log.d(TAG, ""Dropping preview frame.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Dropping preview frame."", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Dropping preview frame."", [])  Statement(}, [])  Statement(if (doTiming) {, [])  Statement(endGlTiming(), [])  Statement(}, [])  Statement(return, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(RequestHolder request, []), Expression(captureHolder.first, [])])    VariableReference(RequestHolder request, [])    Expression(captureHolder.first, [])  AssignmentExpression(=, [VariableReference(Collection<Surface> targetSurfaces, []), Expression(request.getHolderTargets(), [])])    VariableReference(Collection<Surface> targetSurfaces, [])    Expression(request.getHolderTargets(), [])  Statement(if (doTiming) {, [])  Statement(addGlTimestamp(timestamp), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(List<Long> targetSurfaceIds, []), Expression(new ArrayList(), [])])    VariableReference(List<Long> targetSurfaceIds, [])    Expression(new ArrayList(), [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(targetSurfaceIds, []), Expression(LegacyCameraDevice.getSurfaceIds(targetSurfaces), [])])    VariableReference(targetSurfaceIds, [])    Expression(LegacyCameraDevice.getSurfaceIds(targetSurfaces), [])  MethodCall(Log.w(TAG, ""Surface abandoned, dropping frame. "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Surface abandoned, []), Expression(dropping frame. "", []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Surface abandoned, [])    Expression(dropping frame. "", [])    Expression(e, [])  MethodCall(request.setOutputAbandoned(), [VariableReference(request, []), Expression(, [])])    VariableReference(request, [])    Expression(, [])  Statement(}, [])  Statement(for (EGLSurfaceHolder holder : mSurfaces) {, [])  MethodCall(if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)), [VariableReference(if (LegacyCameraDevice, []), Expression(holder.surface, []), Expression(targetSurfaceIds), [])])    VariableReference(if (LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(targetSurfaceIds), [])  Statement(try {, [])  MethodCall(LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(holder.width, []), Expression(holder.height, [])])    VariableReference(LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(holder.width, [])    Expression(holder.height, [])  MethodCall(LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(captureHolder.second, [])])    VariableReference(LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(captureHolder.second, [])  AssignmentExpression(=, [VariableReference(drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing, []), Expression(, [])])    VariableReference(drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing, [])    Expression(, [])  MethodCall(Log.w(TAG, ""Surface abandoned, dropping frame. "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Surface abandoned, []), Expression(dropping frame. "", []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Surface abandoned, [])    Expression(dropping frame. "", [])    Expression(e, [])  MethodCall(request.setOutputAbandoned(), [VariableReference(request, []), Expression(, [])])    VariableReference(request, [])    Expression(, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(for (EGLSurfaceHolder holder : mConversionSurfaces) {, [])  MethodCall(if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)), [VariableReference(if (LegacyCameraDevice, []), Expression(holder.surface, []), Expression(targetSurfaceIds), [])])    VariableReference(if (LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(targetSurfaceIds), [])  Statement(// glReadPixels reads from the bottom of the buffer, so add an extra vertical flip, [])  AssignmentExpression(=, [VariableReference(drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing, []), Expression(, [])])    VariableReference(drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing, [])    Expression(, [])  MethodCall(mPBufferPixels.clear(), [VariableReference(mPBufferPixels, []), Expression(, [])])    VariableReference(mPBufferPixels, [])    Expression(, [])  Statement(0, /*y*/, [])  Statement(0, holder.width, holder.height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, mPBufferPixels), [])  Statement(checkGlError(""glReadPixels""), [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(int format, []), Expression(LegacyCameraDevice.detectSurfaceType(holder.surface), [])])    VariableReference(int format, [])    Expression(LegacyCameraDevice.detectSurfaceType(holder.surface), [])  MethodCall(LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(holder.width, []), Expression(holder.height, [])])    VariableReference(LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(holder.width, [])    Expression(holder.height, [])  MethodCall(LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(captureHolder.second, [])])    VariableReference(LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(captureHolder.second, [])  MethodCall(LegacyCameraDevice.produceFrame(holder.surface, mPBufferPixels.array(), holder.width, holder.height, format), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(mPBufferPixels.array(), []), Expression(holder.width, []), Expression(holder.height, []), Expression(format, [])])    VariableReference(LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(mPBufferPixels.array(), [])    Expression(holder.width, [])    Expression(holder.height, [])    Expression(format, [])  MethodCall(Log.w(TAG, ""Surface abandoned, dropping frame. "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Surface abandoned, []), Expression(dropping frame. "", []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Surface abandoned, [])    Expression(dropping frame. "", [])    Expression(e, [])  MethodCall(request.setOutputAbandoned(), [VariableReference(request, []), Expression(, [])])    VariableReference(request, [])    Expression(, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  MethodCall(targetCollector.previewProduced(), [VariableReference(targetCollector, []), Expression(, [])])    VariableReference(targetCollector, [])    Expression(, [])  Statement(if (doTiming) {, [])  Statement(endGlTiming(), [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Draw the current buffer in the {@link SurfaceTexture} returned from
 * {@link #getSurfaceTexture()} into the set of target {@link Surface}s
 * in the next request from the given {@link CaptureCollector}, or drop
 * the frame if none is available.
 *
 * <p>
 * Any {@link Surface}s targeted must be a subset of the {@link Surface}s
 * set in the last {@link #configureSurfaces(java.util.Collection)} call.
 * </p>
 *
 * @param targetCollector the surfaces to draw to.
 */
","/**
 * Draw the current buffer in the {@link SurfaceTexture} returned from
 * {@link #getSurfaceTexture()} into the set of target {@link Surface}s
 * in the next request from the given {@link CaptureCollector}, or drop
 * the frame if none is available.
 *
 * <p>
 * Any {@link Surface}s targeted must be a subset of the {@link Surface}s
 * set in the last {@link #configureSurfaces(java.util.Collection)} call.
 * </p>
 *
 * @param targetCollector the surfaces to draw to.
 */
",0,,,0,,,0,"1,2","2,4,5",2,"3,4","1,2",The implementation of the method has been modified in several ways:,3. The `Log.w` statement inside the `for` loop has been moved to the `catch` block of the new `try-catch` block.
173,<android.widget.TabWidget: void setRightStripDrawable(Drawable)>,23,24,<android.widget.TabWidget: void setRightStripDrawable(Drawable)>,<android.widget.TabWidget: void setRightStripDrawable(Drawable)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(mRightStrip, []), Expression(drawable, [])]), Statement(requestLayout(), []), Statement(invalidate(), []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(mRightStrip, []), Expression(drawable, [])])    VariableReference(mRightStrip, [])    Expression(drawable, [])  Statement(requestLayout(), [])  Statement(invalidate(), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(mRightStrip, []), Expression(drawable, [])]), Statement(requestLayout(), []), Statement(invalidate(), []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(mRightStrip, []), Expression(drawable, [])])    VariableReference(mRightStrip, [])    Expression(drawable, [])  Statement(requestLayout(), [])  Statement(invalidate(), [])  Statement(}, [])",0,"/**
 * Sets the drawable to use as the right part of the strip below the
 * tab indicators.
 * @param drawable the right strip drawable
 */
","/**
 * Sets the drawable to use as the right part of the strip below the tab
 * indicators.
 *
 * @param drawable the right strip drawable
 * @see #getRightStripDrawable()
 * @attr ref android.R.styleable#TabWidget_tabStripRight
 */
",1,,,0,,,0,0,0,0,0,0,No change in the implementation code between the two versions. Only a comment has been added in the late version.,No Compatibility Issue exists as there are no changes in the implementation code between the two versions.
174,<android.app.Dialog: void onActionModeStarted(ActionMode)>,23,24,<android.app.Dialog: void onActionModeStarted(ActionMode)>,<android.app.Dialog: void onActionModeStarted(ActionMode)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(mActionMode, []), Expression(mode, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(mActionMode, []), Expression(mode, [])])    VariableReference(mActionMode, [])    Expression(mode, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(mActionMode, []), Expression(mode, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(mActionMode, []), Expression(mode, [])])    VariableReference(mActionMode, [])    Expression(mode, [])  Statement(}, [])",0,"/**
 * {@inheritDoc}
 *
 * Note that if you override this method you should always call through
 * to the superclass implementation by calling super.onActionModeStarted(mode).
 */
","/**
 * {@inheritDoc}
 *
 * Note that if you override this method you should always call through
 * to the superclass implementation by calling super.onActionModeStarted(mode).
 */
",0,[@CallSuper],"[@Override, @CallSuper]",1,,,0,0,0,0,5,0,The annotation of the method has changed from @CallSuper in the early version to @Override and @CallSuper in the late version. The change of annotation is classified as 5) Dependent API changed.,"There is no Compatibility Issue caused by the change of the method annotation. The @Override annotation is used to indicate that a method is intended to override a method in a superclass, while the @CallSuper annotation is used to indicate that a method should always call through to the superclass implementation. The addition of the @Override annotation does not change the behavior of the method, so it does not lead to Compatibility Issue."
175,<android.service.notification.ZenModeConfig.ZenRule: int hashCode()>,24,25,<android.service.notification.ZenModeConfig.ZenRule: int hashCode()>,<android.service.notification.ZenModeConfig.ZenRule: int hashCode()>,0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(return Objects.hash(enabled, snoozing, name, zenMode, conditionId, condition, component, id, creationTime), [VariableReference(return Objects, []), Expression(enabled, []), Expression(snoozing, []), Expression(name, []), Expression(zenMode, []), Expression(conditionId, []), Expression(condition, []), Expression(component, []), Expression(id, []), Expression(creationTime, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return Objects.hash(enabled, snoozing, name, zenMode, conditionId, condition, component, id, creationTime), [VariableReference(return Objects, []), Expression(enabled, []), Expression(snoozing, []), Expression(name, []), Expression(zenMode, []), Expression(conditionId, []), Expression(condition, []), Expression(component, []), Expression(id, []), Expression(creationTime, [])])    VariableReference(return Objects, [])    Expression(enabled, [])    Expression(snoozing, [])    Expression(name, [])    Expression(zenMode, [])    Expression(conditionId, [])    Expression(condition, [])    Expression(component, [])    Expression(id, [])    Expression(creationTime, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(return Objects.hash(enabled, snoozing, name, zenMode, conditionId, condition, component, id, creationTime, enabler), [VariableReference(return Objects, []), Expression(enabled, []), Expression(snoozing, []), Expression(name, []), Expression(zenMode, []), Expression(conditionId, []), Expression(condition, []), Expression(component, []), Expression(id, []), Expression(creationTime, []), Expression(enabler, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return Objects.hash(enabled, snoozing, name, zenMode, conditionId, condition, component, id, creationTime, enabler), [VariableReference(return Objects, []), Expression(enabled, []), Expression(snoozing, []), Expression(name, []), Expression(zenMode, []), Expression(conditionId, []), Expression(condition, []), Expression(component, []), Expression(id, []), Expression(creationTime, []), Expression(enabler, [])])    VariableReference(return Objects, [])    Expression(enabled, [])    Expression(snoozing, [])    Expression(name, [])    Expression(zenMode, [])    Expression(conditionId, [])    Expression(condition, [])    Expression(component, [])    Expression(id, [])    Expression(creationTime, [])    Expression(enabler, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,0,"1,2","1,5",1,1,1,The code change between the two versions is that an additional parameter 'enabler' has been added to the 'Objects.hash()' method call in the return statement.,"This code change could lead to a Compatibility Issue as the API potentially returns a different hash code value in the two versions. The addition of the 'enabler' parameter to the 'Objects.hash()' method call in the return statement affects the calculation of the hash code value, which could result in different values being returned by the API in the two versions."
176,<android.view.DragEvent: ClipDescription getClipDescription()>,24,25,<android.view.DragEvent: ClipDescription getClipDescription()>,<android.view.DragEvent: ClipDescription getClipDescription()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(return mClipDescription, []), Statement(}, [])])  Statement({, [])  Statement(return mClipDescription, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return mClipDescription, []), Statement(}, [])])  Statement({, [])  Statement(return mClipDescription, [])  Statement(}, [])",0,"/**
 * Returns the {@link android.content.ClipDescription} object contained in the
 * {@link android.content.ClipData} object sent to the system as part of the call to
 * {@link android.view.View#startDrag(ClipData,View.DragShadowBuilder,Object,int) startDrag()}.
 * The drag handler or listener for a View can use the metadata in this object to decide if the
 * View can accept the dragged View object's data.
 * <p>
 * This method returns valid data for all event actions.
 * @return The ClipDescription that was part of the ClipData sent to the system by startDrag().
 */
","/**
 * Returns the {@link android.content.ClipDescription} object contained in the
 * {@link android.content.ClipData} object sent to the system as part of the call to
 * {@link android.view.View#startDrag(ClipData,View.DragShadowBuilder,Object,int) startDrag()}.
 * The drag handler or listener for a View can use the metadata in this object to decide if the
 * View can accept the dragged View object's data.
 * <p>
 * This method returns valid data for all event actions except for {@link #ACTION_DRAG_ENDED}.
 * @return The ClipDescription that was part of the ClipData sent to the system by startDrag().
 */
",1,,,0,,,0,0,0,0,0,0,"The AST nodes for the Early and Late implementations are identical, indicating that there are no code changes between the two versions. However, the comment in the Late version has been updated to specify that the method does not return valid data for the ACTION\_DRAG\_ENDED event action.","Since there are no code changes, there is no Compatibility Issue (CI) between the two versions. The updated comment in the Late version provides additional information about the method's behavior but does not introduce any breaking changes."
177,<android.hardware.camera2.legacy.SurfaceTextureRenderer: void drawIntoSurfaces(CaptureCollector)>,25,26,<android.hardware.camera2.legacy.SurfaceTextureRenderer: void drawIntoSurfaces(CaptureCollector)>,<android.hardware.camera2.legacy.SurfaceTextureRenderer: void drawIntoSurfaces(CaptureCollector)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if ((mSurfaces, []), Expression(, [])]), Statement(return, []), Statement(}, []), AssignmentExpression(=, [VariableReference(boolean doTiming, []), Expression(targetCollector.hasPendingPreviewCaptures(), [])]), Statement(checkGlError(""before updateTexImage""), []), Statement(if (doTiming) {, []), Statement(beginGlTiming(), []), Statement(}, []), MethodCall(mSurfaceTexture.updateTexImage(), [VariableReference(mSurfaceTexture, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(long timestamp, []), Expression(mSurfaceTexture.getTimestamp(), [])]), AssignmentExpression(=, [VariableReference(Pair<RequestHolder, Long> captureHolder, []), Expression(targetCollector.previewCaptured(timestamp), [])]), Statement(// No preview request queued, drop frame., []), AssignmentExpression(=, [VariableReference(if (captureHolder, []), Expression(, [])]), Statement(if (DEBUG) {, []), MethodCall(Log.d(TAG, ""Dropping preview frame.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Dropping preview frame."", [])]), Statement(}, []), Statement(if (doTiming) {, []), Statement(endGlTiming(), []), Statement(}, []), Statement(return, []), Statement(}, []), AssignmentExpression(=, [VariableReference(RequestHolder request, []), Expression(captureHolder.first, [])]), AssignmentExpression(=, [VariableReference(Collection<Surface> targetSurfaces, []), Expression(request.getHolderTargets(), [])]), Statement(if (doTiming) {, []), Statement(addGlTimestamp(timestamp), []), Statement(}, []), AssignmentExpression(=, [VariableReference(List<Long> targetSurfaceIds, []), Expression(new ArrayList(), [])]), Statement(try {, []), AssignmentExpression(=, [VariableReference(targetSurfaceIds, []), Expression(LegacyCameraDevice.getSurfaceIds(targetSurfaces), [])]), MethodCall(Log.w(TAG, ""Surface abandoned, dropping frame. "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Surface abandoned, []), Expression(dropping frame. "", []), Expression(e, [])]), MethodCall(request.setOutputAbandoned(), [VariableReference(request, []), Expression(, [])]), Statement(}, []), Statement(for (EGLSurfaceHolder holder : mSurfaces) {, []), MethodCall(if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)), [VariableReference(if (LegacyCameraDevice, []), Expression(holder.surface, []), Expression(targetSurfaceIds), [])]), Statement(try {, []), MethodCall(LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(holder.width, []), Expression(holder.height, [])]), MethodCall(LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(captureHolder.second, [])]), AssignmentExpression(=, [VariableReference(drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing, []), Expression(, [])]), MethodCall(Log.w(TAG, ""Surface abandoned, dropping frame. "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Surface abandoned, []), Expression(dropping frame. "", []), Expression(e, [])]), MethodCall(request.setOutputAbandoned(), [VariableReference(request, []), Expression(, [])]), Statement(}, []), Statement(}, []), Statement(}, []), Statement(for (EGLSurfaceHolder holder : mConversionSurfaces) {, []), MethodCall(if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)), [VariableReference(if (LegacyCameraDevice, []), Expression(holder.surface, []), Expression(targetSurfaceIds), [])]), Statement(// glReadPixels reads from the bottom of the buffer, so add an extra vertical flip, []), AssignmentExpression(=, [VariableReference(drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing, []), Expression(, [])]), MethodCall(mPBufferPixels.clear(), [VariableReference(mPBufferPixels, []), Expression(, [])]), Statement(0, /*y*/, []), Statement(0, holder.width, holder.height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, mPBufferPixels), []), Statement(checkGlError(""glReadPixels""), []), Statement(try {, []), AssignmentExpression(=, [VariableReference(int format, []), Expression(LegacyCameraDevice.detectSurfaceType(holder.surface), [])]), MethodCall(LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(holder.width, []), Expression(holder.height, [])]), MethodCall(LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(captureHolder.second, [])]), MethodCall(LegacyCameraDevice.produceFrame(holder.surface, mPBufferPixels.array(), holder.width, holder.height, format), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(mPBufferPixels.array(), []), Expression(holder.width, []), Expression(holder.height, []), Expression(format, [])]), MethodCall(Log.w(TAG, ""Surface abandoned, dropping frame. "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Surface abandoned, []), Expression(dropping frame. "", []), Expression(e, [])]), MethodCall(request.setOutputAbandoned(), [VariableReference(request, []), Expression(, [])]), Statement(}, []), Statement(}, []), Statement(}, []), MethodCall(targetCollector.previewProduced(), [VariableReference(targetCollector, []), Expression(, [])]), Statement(if (doTiming) {, []), Statement(endGlTiming(), []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if ((mSurfaces, []), Expression(, [])])    VariableReference(if ((mSurfaces, [])    Expression(, [])  Statement(return, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(boolean doTiming, []), Expression(targetCollector.hasPendingPreviewCaptures(), [])])    VariableReference(boolean doTiming, [])    Expression(targetCollector.hasPendingPreviewCaptures(), [])  Statement(checkGlError(""before updateTexImage""), [])  Statement(if (doTiming) {, [])  Statement(beginGlTiming(), [])  Statement(}, [])  MethodCall(mSurfaceTexture.updateTexImage(), [VariableReference(mSurfaceTexture, []), Expression(, [])])    VariableReference(mSurfaceTexture, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(long timestamp, []), Expression(mSurfaceTexture.getTimestamp(), [])])    VariableReference(long timestamp, [])    Expression(mSurfaceTexture.getTimestamp(), [])  AssignmentExpression(=, [VariableReference(Pair<RequestHolder, Long> captureHolder, []), Expression(targetCollector.previewCaptured(timestamp), [])])    VariableReference(Pair<RequestHolder, Long> captureHolder, [])    Expression(targetCollector.previewCaptured(timestamp), [])  Statement(// No preview request queued, drop frame., [])  AssignmentExpression(=, [VariableReference(if (captureHolder, []), Expression(, [])])    VariableReference(if (captureHolder, [])    Expression(, [])  Statement(if (DEBUG) {, [])  MethodCall(Log.d(TAG, ""Dropping preview frame.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Dropping preview frame."", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Dropping preview frame."", [])  Statement(}, [])  Statement(if (doTiming) {, [])  Statement(endGlTiming(), [])  Statement(}, [])  Statement(return, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(RequestHolder request, []), Expression(captureHolder.first, [])])    VariableReference(RequestHolder request, [])    Expression(captureHolder.first, [])  AssignmentExpression(=, [VariableReference(Collection<Surface> targetSurfaces, []), Expression(request.getHolderTargets(), [])])    VariableReference(Collection<Surface> targetSurfaces, [])    Expression(request.getHolderTargets(), [])  Statement(if (doTiming) {, [])  Statement(addGlTimestamp(timestamp), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(List<Long> targetSurfaceIds, []), Expression(new ArrayList(), [])])    VariableReference(List<Long> targetSurfaceIds, [])    Expression(new ArrayList(), [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(targetSurfaceIds, []), Expression(LegacyCameraDevice.getSurfaceIds(targetSurfaces), [])])    VariableReference(targetSurfaceIds, [])    Expression(LegacyCameraDevice.getSurfaceIds(targetSurfaces), [])  MethodCall(Log.w(TAG, ""Surface abandoned, dropping frame. "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Surface abandoned, []), Expression(dropping frame. "", []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Surface abandoned, [])    Expression(dropping frame. "", [])    Expression(e, [])  MethodCall(request.setOutputAbandoned(), [VariableReference(request, []), Expression(, [])])    VariableReference(request, [])    Expression(, [])  Statement(}, [])  Statement(for (EGLSurfaceHolder holder : mSurfaces) {, [])  MethodCall(if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)), [VariableReference(if (LegacyCameraDevice, []), Expression(holder.surface, []), Expression(targetSurfaceIds), [])])    VariableReference(if (LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(targetSurfaceIds), [])  Statement(try {, [])  MethodCall(LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(holder.width, []), Expression(holder.height, [])])    VariableReference(LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(holder.width, [])    Expression(holder.height, [])  MethodCall(LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(captureHolder.second, [])])    VariableReference(LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(captureHolder.second, [])  AssignmentExpression(=, [VariableReference(drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing, []), Expression(, [])])    VariableReference(drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing, [])    Expression(, [])  MethodCall(Log.w(TAG, ""Surface abandoned, dropping frame. "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Surface abandoned, []), Expression(dropping frame. "", []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Surface abandoned, [])    Expression(dropping frame. "", [])    Expression(e, [])  MethodCall(request.setOutputAbandoned(), [VariableReference(request, []), Expression(, [])])    VariableReference(request, [])    Expression(, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(for (EGLSurfaceHolder holder : mConversionSurfaces) {, [])  MethodCall(if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)), [VariableReference(if (LegacyCameraDevice, []), Expression(holder.surface, []), Expression(targetSurfaceIds), [])])    VariableReference(if (LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(targetSurfaceIds), [])  Statement(// glReadPixels reads from the bottom of the buffer, so add an extra vertical flip, [])  AssignmentExpression(=, [VariableReference(drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing, []), Expression(, [])])    VariableReference(drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing, [])    Expression(, [])  MethodCall(mPBufferPixels.clear(), [VariableReference(mPBufferPixels, []), Expression(, [])])    VariableReference(mPBufferPixels, [])    Expression(, [])  Statement(0, /*y*/, [])  Statement(0, holder.width, holder.height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, mPBufferPixels), [])  Statement(checkGlError(""glReadPixels""), [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(int format, []), Expression(LegacyCameraDevice.detectSurfaceType(holder.surface), [])])    VariableReference(int format, [])    Expression(LegacyCameraDevice.detectSurfaceType(holder.surface), [])  MethodCall(LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(holder.width, []), Expression(holder.height, [])])    VariableReference(LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(holder.width, [])    Expression(holder.height, [])  MethodCall(LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(captureHolder.second, [])])    VariableReference(LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(captureHolder.second, [])  MethodCall(LegacyCameraDevice.produceFrame(holder.surface, mPBufferPixels.array(), holder.width, holder.height, format), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(mPBufferPixels.array(), []), Expression(holder.width, []), Expression(holder.height, []), Expression(format, [])])    VariableReference(LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(mPBufferPixels.array(), [])    Expression(holder.width, [])    Expression(holder.height, [])    Expression(format, [])  MethodCall(Log.w(TAG, ""Surface abandoned, dropping frame. "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Surface abandoned, []), Expression(dropping frame. "", []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Surface abandoned, [])    Expression(dropping frame. "", [])    Expression(e, [])  MethodCall(request.setOutputAbandoned(), [VariableReference(request, []), Expression(, [])])    VariableReference(request, [])    Expression(, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  MethodCall(targetCollector.previewProduced(), [VariableReference(targetCollector, []), Expression(, [])])    VariableReference(targetCollector, [])    Expression(, [])  Statement(if (doTiming) {, [])  Statement(endGlTiming(), [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if ((mSurfaces, []), Expression(, [])]), Statement(return, []), Statement(}, []), AssignmentExpression(=, [VariableReference(boolean doTiming, []), Expression(targetCollector.hasPendingPreviewCaptures(), [])]), Statement(checkGlError(""before updateTexImage""), []), Statement(if (doTiming) {, []), Statement(beginGlTiming(), []), Statement(}, []), MethodCall(mSurfaceTexture.updateTexImage(), [VariableReference(mSurfaceTexture, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(long timestamp, []), Expression(mSurfaceTexture.getTimestamp(), [])]), AssignmentExpression(=, [VariableReference(Pair<RequestHolder, Long> captureHolder, []), Expression(targetCollector.previewCaptured(timestamp), [])]), Statement(// No preview request queued, drop frame., []), AssignmentExpression(=, [VariableReference(if (captureHolder, []), Expression(, [])]), Statement(if (DEBUG) {, []), MethodCall(Log.d(TAG, ""Dropping preview frame.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Dropping preview frame."", [])]), Statement(}, []), Statement(if (doTiming) {, []), Statement(endGlTiming(), []), Statement(}, []), Statement(return, []), Statement(}, []), AssignmentExpression(=, [VariableReference(RequestHolder request, []), Expression(captureHolder.first, [])]), AssignmentExpression(=, [VariableReference(Collection<Surface> targetSurfaces, []), Expression(request.getHolderTargets(), [])]), Statement(if (doTiming) {, []), Statement(addGlTimestamp(timestamp), []), Statement(}, []), AssignmentExpression(=, [VariableReference(List<Long> targetSurfaceIds, []), Expression(new ArrayList(), [])]), Statement(try {, []), AssignmentExpression(=, [VariableReference(targetSurfaceIds, []), Expression(LegacyCameraDevice.getSurfaceIds(targetSurfaces), [])]), MethodCall(Log.w(TAG, ""Surface abandoned, dropping frame. "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Surface abandoned, []), Expression(dropping frame. "", []), Expression(e, [])]), MethodCall(request.setOutputAbandoned(), [VariableReference(request, []), Expression(, [])]), Statement(}, []), Statement(for (EGLSurfaceHolder holder : mSurfaces) {, []), MethodCall(if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)), [VariableReference(if (LegacyCameraDevice, []), Expression(holder.surface, []), Expression(targetSurfaceIds), [])]), Statement(try {, []), MethodCall(LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(holder.width, []), Expression(holder.height, [])]), MethodCall(LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(captureHolder.second, [])]), AssignmentExpression(=, [VariableReference(drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing, []), Expression(, [])]), MethodCall(Log.w(TAG, ""Surface abandoned, dropping frame. "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Surface abandoned, []), Expression(dropping frame. "", []), Expression(e, [])]), MethodCall(request.setOutputAbandoned(), [VariableReference(request, []), Expression(, [])]), Statement(}, []), Statement(}, []), Statement(}, []), Statement(for (EGLSurfaceHolder holder : mConversionSurfaces) {, []), MethodCall(if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)), [VariableReference(if (LegacyCameraDevice, []), Expression(holder.surface, []), Expression(targetSurfaceIds), [])]), Statement(// glReadPixels reads from the bottom of the buffer, so add an extra vertical flip, []), Statement(try {, []), AssignmentExpression(=, [VariableReference(drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing, []), Expression(, [])]), Statement(// Should never hit this., []), Statement(}, []), MethodCall(mPBufferPixels.clear(), [VariableReference(mPBufferPixels, []), Expression(, [])]), Statement(0, /*y*/, []), Statement(0, holder.width, holder.height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, mPBufferPixels), []), Statement(checkGlError(""glReadPixels""), []), Statement(try {, []), AssignmentExpression(=, [VariableReference(int format, []), Expression(LegacyCameraDevice.detectSurfaceType(holder.surface), [])]), MethodCall(LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(holder.width, []), Expression(holder.height, [])]), MethodCall(LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(captureHolder.second, [])]), MethodCall(LegacyCameraDevice.produceFrame(holder.surface, mPBufferPixels.array(), holder.width, holder.height, format), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(mPBufferPixels.array(), []), Expression(holder.width, []), Expression(holder.height, []), Expression(format, [])]), MethodCall(Log.w(TAG, ""Surface abandoned, dropping frame. "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Surface abandoned, []), Expression(dropping frame. "", []), Expression(e, [])]), MethodCall(request.setOutputAbandoned(), [VariableReference(request, []), Expression(, [])]), Statement(}, []), Statement(}, []), Statement(}, []), MethodCall(targetCollector.previewProduced(), [VariableReference(targetCollector, []), Expression(, [])]), Statement(if (doTiming) {, []), Statement(endGlTiming(), []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if ((mSurfaces, []), Expression(, [])])    VariableReference(if ((mSurfaces, [])    Expression(, [])  Statement(return, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(boolean doTiming, []), Expression(targetCollector.hasPendingPreviewCaptures(), [])])    VariableReference(boolean doTiming, [])    Expression(targetCollector.hasPendingPreviewCaptures(), [])  Statement(checkGlError(""before updateTexImage""), [])  Statement(if (doTiming) {, [])  Statement(beginGlTiming(), [])  Statement(}, [])  MethodCall(mSurfaceTexture.updateTexImage(), [VariableReference(mSurfaceTexture, []), Expression(, [])])    VariableReference(mSurfaceTexture, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(long timestamp, []), Expression(mSurfaceTexture.getTimestamp(), [])])    VariableReference(long timestamp, [])    Expression(mSurfaceTexture.getTimestamp(), [])  AssignmentExpression(=, [VariableReference(Pair<RequestHolder, Long> captureHolder, []), Expression(targetCollector.previewCaptured(timestamp), [])])    VariableReference(Pair<RequestHolder, Long> captureHolder, [])    Expression(targetCollector.previewCaptured(timestamp), [])  Statement(// No preview request queued, drop frame., [])  AssignmentExpression(=, [VariableReference(if (captureHolder, []), Expression(, [])])    VariableReference(if (captureHolder, [])    Expression(, [])  Statement(if (DEBUG) {, [])  MethodCall(Log.d(TAG, ""Dropping preview frame.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Dropping preview frame."", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Dropping preview frame."", [])  Statement(}, [])  Statement(if (doTiming) {, [])  Statement(endGlTiming(), [])  Statement(}, [])  Statement(return, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(RequestHolder request, []), Expression(captureHolder.first, [])])    VariableReference(RequestHolder request, [])    Expression(captureHolder.first, [])  AssignmentExpression(=, [VariableReference(Collection<Surface> targetSurfaces, []), Expression(request.getHolderTargets(), [])])    VariableReference(Collection<Surface> targetSurfaces, [])    Expression(request.getHolderTargets(), [])  Statement(if (doTiming) {, [])  Statement(addGlTimestamp(timestamp), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(List<Long> targetSurfaceIds, []), Expression(new ArrayList(), [])])    VariableReference(List<Long> targetSurfaceIds, [])    Expression(new ArrayList(), [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(targetSurfaceIds, []), Expression(LegacyCameraDevice.getSurfaceIds(targetSurfaces), [])])    VariableReference(targetSurfaceIds, [])    Expression(LegacyCameraDevice.getSurfaceIds(targetSurfaces), [])  MethodCall(Log.w(TAG, ""Surface abandoned, dropping frame. "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Surface abandoned, []), Expression(dropping frame. "", []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Surface abandoned, [])    Expression(dropping frame. "", [])    Expression(e, [])  MethodCall(request.setOutputAbandoned(), [VariableReference(request, []), Expression(, [])])    VariableReference(request, [])    Expression(, [])  Statement(}, [])  Statement(for (EGLSurfaceHolder holder : mSurfaces) {, [])  MethodCall(if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)), [VariableReference(if (LegacyCameraDevice, []), Expression(holder.surface, []), Expression(targetSurfaceIds), [])])    VariableReference(if (LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(targetSurfaceIds), [])  Statement(try {, [])  MethodCall(LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(holder.width, []), Expression(holder.height, [])])    VariableReference(LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(holder.width, [])    Expression(holder.height, [])  MethodCall(LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(captureHolder.second, [])])    VariableReference(LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(captureHolder.second, [])  AssignmentExpression(=, [VariableReference(drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing, []), Expression(, [])])    VariableReference(drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing, [])    Expression(, [])  MethodCall(Log.w(TAG, ""Surface abandoned, dropping frame. "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Surface abandoned, []), Expression(dropping frame. "", []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Surface abandoned, [])    Expression(dropping frame. "", [])    Expression(e, [])  MethodCall(request.setOutputAbandoned(), [VariableReference(request, []), Expression(, [])])    VariableReference(request, [])    Expression(, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(for (EGLSurfaceHolder holder : mConversionSurfaces) {, [])  MethodCall(if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)), [VariableReference(if (LegacyCameraDevice, []), Expression(holder.surface, []), Expression(targetSurfaceIds), [])])    VariableReference(if (LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(targetSurfaceIds), [])  Statement(// glReadPixels reads from the bottom of the buffer, so add an extra vertical flip, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing, []), Expression(, [])])    VariableReference(drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing, [])    Expression(, [])  Statement(// Should never hit this., [])  Statement(}, [])  MethodCall(mPBufferPixels.clear(), [VariableReference(mPBufferPixels, []), Expression(, [])])    VariableReference(mPBufferPixels, [])    Expression(, [])  Statement(0, /*y*/, [])  Statement(0, holder.width, holder.height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, mPBufferPixels), [])  Statement(checkGlError(""glReadPixels""), [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(int format, []), Expression(LegacyCameraDevice.detectSurfaceType(holder.surface), [])])    VariableReference(int format, [])    Expression(LegacyCameraDevice.detectSurfaceType(holder.surface), [])  MethodCall(LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(holder.width, []), Expression(holder.height, [])])    VariableReference(LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(holder.width, [])    Expression(holder.height, [])  MethodCall(LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(captureHolder.second, [])])    VariableReference(LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(captureHolder.second, [])  MethodCall(LegacyCameraDevice.produceFrame(holder.surface, mPBufferPixels.array(), holder.width, holder.height, format), [VariableReference(LegacyCameraDevice, []), Expression(holder.surface, []), Expression(mPBufferPixels.array(), []), Expression(holder.width, []), Expression(holder.height, []), Expression(format, [])])    VariableReference(LegacyCameraDevice, [])    Expression(holder.surface, [])    Expression(mPBufferPixels.array(), [])    Expression(holder.width, [])    Expression(holder.height, [])    Expression(format, [])  MethodCall(Log.w(TAG, ""Surface abandoned, dropping frame. "", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Surface abandoned, []), Expression(dropping frame. "", []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Surface abandoned, [])    Expression(dropping frame. "", [])    Expression(e, [])  MethodCall(request.setOutputAbandoned(), [VariableReference(request, []), Expression(, [])])    VariableReference(request, [])    Expression(, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  MethodCall(targetCollector.previewProduced(), [VariableReference(targetCollector, []), Expression(, [])])    VariableReference(targetCollector, [])    Expression(, [])  Statement(if (doTiming) {, [])  Statement(endGlTiming(), [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Draw the current buffer in the {@link SurfaceTexture} returned from
 * {@link #getSurfaceTexture()} into the set of target {@link Surface}s
 * in the next request from the given {@link CaptureCollector}, or drop
 * the frame if none is available.
 *
 * <p>
 * Any {@link Surface}s targeted must be a subset of the {@link Surface}s
 * set in the last {@link #configureSurfaces(java.util.Collection)} call.
 * </p>
 *
 * @param targetCollector the surfaces to draw to.
 */
","/**
 * Draw the current buffer in the {@link SurfaceTexture} returned from
 * {@link #getSurfaceTexture()} into the set of target {@link Surface}s
 * in the next request from the given {@link CaptureCollector}, or drop
 * the frame if none is available.
 *
 * <p>
 * Any {@link Surface}s targeted must be a subset of the {@link Surface}s
 * set in the last {@link #configureSurfaces(java.util.Collection)} call.
 * </p>
 *
 * @param targetCollector the surfaces to draw to.
 */
",0,,,0,,,0,"1,2",2,2,4,1,"In the late implementation, a new statement `Statement(// Should never hit this., [])` is introduced in the try block of the for loop for `mConversionSurfaces`.","The new statement `Statement(// Should never hit this., [])` in the try block of the for loop for `mConversionSurfaces` could potentially cause the API to return a different value, as it may affect the behavior of the code in the try block. Therefore, it should be regarded as a Compatibility Issue caused by potential different return values or types (CI type 1)."
178,<android.net.Uri: Uri normalizeScheme()>,25,26,<android.net.Uri: Uri normalizeScheme()>,<android.net.Uri: Uri normalizeScheme()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(String scheme, []), Expression(getScheme(), [])]), Statement(// give up, []), AssignmentExpression(=, [VariableReference(if (scheme, []), Expression(, [])]), Statement(return this, []), AssignmentExpression(=, [VariableReference(String lowerScheme, []), Expression(scheme.toLowerCase(Locale.ROOT), [])]), Statement(// no change, []), MethodCall(if (scheme.equals(lowerScheme)), [VariableReference(if (scheme, []), Expression(lowerScheme), [])]), Statement(return this, []), MethodCall(return buildUpon().scheme(lowerScheme).build(), [VariableReference(return buildUpon(), []), Expression(lowerScheme).build(, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(String scheme, []), Expression(getScheme(), [])])    VariableReference(String scheme, [])    Expression(getScheme(), [])  Statement(// give up, [])  AssignmentExpression(=, [VariableReference(if (scheme, []), Expression(, [])])    VariableReference(if (scheme, [])    Expression(, [])  Statement(return this, [])  AssignmentExpression(=, [VariableReference(String lowerScheme, []), Expression(scheme.toLowerCase(Locale.ROOT), [])])    VariableReference(String lowerScheme, [])    Expression(scheme.toLowerCase(Locale.ROOT), [])  Statement(// no change, [])  MethodCall(if (scheme.equals(lowerScheme)), [VariableReference(if (scheme, []), Expression(lowerScheme), [])])    VariableReference(if (scheme, [])    Expression(lowerScheme), [])  Statement(return this, [])  MethodCall(return buildUpon().scheme(lowerScheme).build(), [VariableReference(return buildUpon(), []), Expression(lowerScheme).build(, [])])    VariableReference(return buildUpon(), [])    Expression(lowerScheme).build(, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(String scheme, []), Expression(getScheme(), [])]), Statement(// give up, []), AssignmentExpression(=, [VariableReference(if (scheme, []), Expression(, [])]), Statement(return this, []), AssignmentExpression(=, [VariableReference(String lowerScheme, []), Expression(scheme.toLowerCase(Locale.ROOT), [])]), Statement(// no change, []), MethodCall(if (scheme.equals(lowerScheme)), [VariableReference(if (scheme, []), Expression(lowerScheme), [])]), Statement(return this, []), MethodCall(return buildUpon().scheme(lowerScheme).build(), [VariableReference(return buildUpon(), []), Expression(lowerScheme).build(, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(String scheme, []), Expression(getScheme(), [])])    VariableReference(String scheme, [])    Expression(getScheme(), [])  Statement(// give up, [])  AssignmentExpression(=, [VariableReference(if (scheme, []), Expression(, [])])    VariableReference(if (scheme, [])    Expression(, [])  Statement(return this, [])  AssignmentExpression(=, [VariableReference(String lowerScheme, []), Expression(scheme.toLowerCase(Locale.ROOT), [])])    VariableReference(String lowerScheme, [])    Expression(scheme.toLowerCase(Locale.ROOT), [])  Statement(// no change, [])  MethodCall(if (scheme.equals(lowerScheme)), [VariableReference(if (scheme, []), Expression(lowerScheme), [])])    VariableReference(if (scheme, [])    Expression(lowerScheme), [])  Statement(return this, [])  MethodCall(return buildUpon().scheme(lowerScheme).build(), [VariableReference(return buildUpon(), []), Expression(lowerScheme).build(, [])])    VariableReference(return buildUpon(), [])    Expression(lowerScheme).build(, [])  Statement(}, [])",0,"/**
 * Return an equivalent URI with a lowercase scheme component.
 * This aligns the Uri with Android best practices for
 * intent filtering.
 *
 * <p>For example, ""HTTP://www.android.com"" becomes
 * ""http://www.android.com""
 *
 * <p>All URIs received from outside Android (such as user input,
 * or external sources like Bluetooth, NFC, or the Internet) should
 * be normalized before they are used to create an Intent.
 *
 * <p class=""note"">This method does <em>not</em> validate bad URI's,
 * or 'fix' poorly formatted URI's - so do not use it for input validation.
 * A Uri will always be returned, even if the Uri is badly formatted to
 * begin with and a scheme component cannot be found.
 *
 * @return normalized Uri (never null)
 * @see {@link android.content.Intent#setData}
 * @see {@link android.content.Intent#setDataAndNormalize}
 */
","/**
 * Return an equivalent URI with a lowercase scheme component.
 * This aligns the Uri with Android best practices for
 * intent filtering.
 *
 * <p>For example, ""HTTP://www.android.com"" becomes
 * ""http://www.android.com""
 *
 * <p>All URIs received from outside Android (such as user input,
 * or external sources like Bluetooth, NFC, or the Internet) should
 * be normalized before they are used to create an Intent.
 *
 * <p class=""note"">This method does <em>not</em> validate bad URI's,
 * or 'fix' poorly formatted URI's - so do not use it for input validation.
 * A Uri will always be returned, even if the Uri is badly formatted to
 * begin with and a scheme component cannot be found.
 *
 * @return normalized Uri (never null)
 * @see android.content.Intent#setData
 * @see android.content.Intent#setDataAndNormalize
 */
",1,,,0,,,0,0,0,0,0,0,There is no code change between the two versions of the API.,There is no compatibility issue for the API as there is no code change.
179,<android.widget.GridView: void setRemoteViewsAdapter(Intent)>,25,26,<android.widget.GridView: void setRemoteViewsAdapter(Intent)>,<android.widget.GridView: void setRemoteViewsAdapter(Intent)>,0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(super.setRemoteViewsAdapter(intent), [VariableReference(super, []), Expression(intent, [])]), Statement(}, [])])  Statement({, [])  MethodCall(super.setRemoteViewsAdapter(intent), [VariableReference(super, []), Expression(intent, [])])    VariableReference(super, [])    Expression(intent, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(super.setRemoteViewsAdapter(intent), [VariableReference(super, []), Expression(intent, [])]), Statement(}, [])])  Statement({, [])  MethodCall(super.setRemoteViewsAdapter(intent), [VariableReference(super, []), Expression(intent, [])])    VariableReference(super, [])    Expression(intent, [])  Statement(}, [])",0,"/**
 * Sets up this AbsListView to use a remote views adapter which connects to a RemoteViewsService
 * through the specified intent.
 * @param intent the intent used to identify the RemoteViewsService for the adapter to connect to.
 */
","/**
 * Sets up this AbsListView to use a remote views adapter which connects to a RemoteViewsService
 * through the specified intent.
 * @param intent the intent used to identify the RemoteViewsService for the adapter to connect to.
 */
",0,[@android.view.RemotableViewMethod],[@android.view.RemotableViewMethod(asyncImpl = "setRemoteViewsAdapterAsync")],1,,,0,0,0,0,5,0,"The only change is in the Late_Annotation, where the asyncImpl attribute has been added to the @android.view.RemotableViewMethod annotation.","Since the code implementation and the method behavior remain the same between the two versions, there are no compatibility issues. The added asyncImpl attribute in the Late_Annotation only specifies an asynchronous implementation for the method, but it does not affect the method's behavior or any dependencies."
180,<android.os.MemoryFile.MemoryInputStream: int available()>,26,27,<android.os.MemoryFile.MemoryInputStream: int available()>,<android.os.MemoryFile.MemoryInputStream: int available()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mOffset >, []), Expression(mLength) {, [])]), Statement(return 0, []), Statement(}, []), Statement(return mLength - mOffset, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mOffset >, []), Expression(mLength) {, [])])    VariableReference(if (mOffset >, [])    Expression(mLength) {, [])  Statement(return 0, [])  Statement(}, [])  Statement(return mLength - mOffset, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mOffset >, []), Expression(mSharedMemory.getSize()) {, [])]), Statement(return 0, []), Statement(}, []), MethodCall(return mSharedMemory.getSize(), [VariableReference(return mSharedMemory, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mOffset >, []), Expression(mSharedMemory.getSize()) {, [])])    VariableReference(if (mOffset >, [])    Expression(mSharedMemory.getSize()) {, [])  Statement(return 0, [])  Statement(}, [])  MethodCall(return mSharedMemory.getSize(), [VariableReference(return mSharedMemory, []), Expression(, [])])    VariableReference(return mSharedMemory, [])    Expression(, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,0,"1,2","1,3,4",1,5,1,"The expression in the if statement has been changed from ""mLength"" to ""mSharedMemory.getSize()"", and the statement in the if block has been changed from ""mLength - mOffset"" to a method call ""mSharedMemory.getSize()"". These changes indicate that the method now uses the size of the shared memory instead of the length of the file to calculate the available bytes, and the method call in the if block is used to get the size of the shared memory.","The change in the expression used to calculate the available bytes could potentially lead to a compatibility issue, as the new method uses the size of the shared memory instead of the length of the file. This means that the available bytes returned by the method could be different in the new version, which could affect the behavior of the application using the method. Therefore, it is classified as Compatibility Issue caused by potential different return values or types."
182,<android.view.textclassifier.TextClassification: String getText()>,26,27,<android.view.textclassifier.TextClassification: String getText()>,<android.view.textclassifier.TextClassification: String getText()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(return mText, []), Statement(}, [])])  Statement({, [])  Statement(return mText, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return mText, []), Statement(}, [])])  Statement({, [])  Statement(return mText, [])  Statement(}, [])",0,"/**
 * Gets the classified text.
 */
","/**
 * Gets the classified text.
 */
",0,[@NonNull],[@Nullable],1,,,0,0,0,0,5,1,"The annotation of the method has changed from @NonNull to @Nullable, which means that the method might return a null value in the late version.",The change of annotation potentially leads to different behaviors when the API is invoked. The code that calls this API might not handle the null value properly and cause a NullPointerException in the late version.
183,<android.os.MemoryFile.MemoryInputStream: int available()>,26,27,<android.os.MemoryFile.MemoryInputStream: int available()>,<android.os.MemoryFile.MemoryInputStream: int available()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mOffset >, []), Expression(mLength) {, [])]), Statement(return 0, []), Statement(}, []), Statement(return mLength - mOffset, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mOffset >, []), Expression(mLength) {, [])])    VariableReference(if (mOffset >, [])    Expression(mLength) {, [])  Statement(return 0, [])  Statement(}, [])  Statement(return mLength - mOffset, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mOffset >, []), Expression(mSharedMemory.getSize()) {, [])]), Statement(return 0, []), Statement(}, []), MethodCall(return mSharedMemory.getSize(), [VariableReference(return mSharedMemory, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mOffset >, []), Expression(mSharedMemory.getSize()) {, [])])    VariableReference(if (mOffset >, [])    Expression(mSharedMemory.getSize()) {, [])  Statement(return 0, [])  Statement(}, [])  MethodCall(return mSharedMemory.getSize(), [VariableReference(return mSharedMemory, []), Expression(, [])])    VariableReference(return mSharedMemory, [])    Expression(, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,0,"1,2","1,3,4",1,"1,5","1,2","The code change between the early version and the late version is in the implementation of the `available()` method of the `MemoryFile.MemoryInputStream` class. In the early version, the method returns the difference between `mLength` and `mOffset` if `mOffset` is less than or equal to `mLength`, and 0 otherwise. In the late version, the method returns the size of the shared memory if `mOffset` is less than or equal to the size of the shared memory, and 0 otherwise. The change in the implementation potentially leads to different return values, and the method now relies on a new dependent API, `getSize()` of the `SharedMemory` class.","The Compatibility Issue arises because the change in the implementation of the `available()` method potentially leads to different return values. In the early version, the method returns the difference between `mLength` and `mOffset`, while in the late version, the method returns the size of the shared memory. This can cause issues in the client code that relies on the specific behavior of the `available()` method. Additionally, the method now relies on a new dependent API, `getSize()` of the `SharedMemory` class. If the implementation of the `SharedMemory` class changes in a way that affects the behavior of the `getSize()` method, it can also lead to Compatibility Issues in the `available()` method."
185,<android.view.textclassifier.TextClassification: String getText()>,27,28,<android.view.textclassifier.TextClassification: String getText()>,<android.view.textclassifier.TextClassification: String getText()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(return mText, []), Statement(}, [])])  Statement({, [])  Statement(return mText, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return mText, []), Statement(}, [])])  Statement({, [])  Statement(return mText, [])  Statement(}, [])",0,"/**
 * Gets the classified text.
 */
","/**
 * Gets the classified text.
 */
",0,[@NonNull],[@Nullable],1,,,0,0,0,0,5,1,"The annotation of the method has changed from NonNull to Nullable, which means the returned value can be null in the late version.","As the returned value can be null in the late version, it may cause compatibility issue if the client code is not handling the null value properly."
186,"<android.view.textclassifier.TextSelection.Builder: Builder setEntityType(String,float)>",27,28,"<android.view.textclassifier.TextSelection.Builder: Builder setEntityType(String,float)>","<android.view.textclassifier.TextSelection.Builder: Builder setEntityType(String,float)>",0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(mEntityConfidence.setEntityType(type, confidenceScore), [VariableReference(mEntityConfidence, []), Expression(type, []), Expression(confidenceScore, [])]), Statement(return this, []), Statement(}, [])])  Statement({, [])  MethodCall(mEntityConfidence.setEntityType(type, confidenceScore), [VariableReference(mEntityConfidence, []), Expression(type, []), Expression(confidenceScore, [])])    VariableReference(mEntityConfidence, [])    Expression(type, [])    Expression(confidenceScore, [])  Statement(return this, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(Preconditions.checkNotNull(type), [VariableReference(Preconditions, []), Expression(type, [])]), MethodCall(mEntityConfidence.put(type, confidenceScore), [VariableReference(mEntityConfidence, []), Expression(type, []), Expression(confidenceScore, [])]), Statement(return this, []), Statement(}, [])])  Statement({, [])  MethodCall(Preconditions.checkNotNull(type), [VariableReference(Preconditions, []), Expression(type, [])])    VariableReference(Preconditions, [])    Expression(type, [])  MethodCall(mEntityConfidence.put(type, confidenceScore), [VariableReference(mEntityConfidence, []), Expression(type, []), Expression(confidenceScore, [])])    VariableReference(mEntityConfidence, [])    Expression(type, [])    Expression(confidenceScore, [])  Statement(return this, [])  Statement(}, [])",1,"/**
 * Sets an entity type for the classified text and assigns a confidence score.
 *
 * @param confidenceScore a value from 0 (low confidence) to 1 (high confidence).
 * 0 implies the entity does not exist for the classified text.
 * Values greater than 1 are clamped to 1.
 */
","/**
 * Sets an entity type for the classified text and assigns a confidence score.
 *
 * @param confidenceScore a value from 0 (low confidence) to 1 (high confidence).
 * 0 implies the entity does not exist for the classified text.
 * Values greater than 1 are clamped to 1.
 */
",0,,[@NonNull],1,,,0,"1,2","1,4,5",1,"2,5","1,2","The method call `mEntityConfidence.setEntityType(type, confidenceScore)` in the early implementation has been replaced with `Preconditions.checkNotNull(type)` and `mEntityConfidence.put(type, confidenceScore)` in the late implementation. This change potentially affects the behavior of the API by throwing a different exception (NullPointerException) and returning a different value (the entity type may not be set if the type parameter is null). Additionally, the method signature has been annotated with `@NonNull` in the late version, indicating that the type parameter should not be null.","The compatibility issue arises due to the potential for different exception handling and return values in the late version of the API. If the type parameter is null in the early version, the API will not throw an exception and the entity type will not be set. However, in the late version, a NullPointerException will be thrown and the entity type will not be set. This can cause compatibility issues for applications that rely on the behavior of the API in the early version and do not handle NullPointerExceptions or expect a different return value."
187,"<android.bluetooth.BluetoothDevice: BluetoothGatt connectGatt(Context,boolean,BluetoothGattCallback)>",27,28,"<android.bluetooth.BluetoothDevice: BluetoothGatt connectGatt(Context,boolean,BluetoothGattCallback)>","<android.bluetooth.BluetoothDevice: BluetoothGatt connectGatt(Context,boolean,BluetoothGattCallback)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(return (connectGatt(context, autoConnect, callback, TRANSPORT_AUTO)), []), Statement(}, [])])  Statement({, [])  Statement(return (connectGatt(context, autoConnect, callback, TRANSPORT_AUTO)), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return (connectGatt(context, autoConnect, callback, TRANSPORT_AUTO)), []), Statement(}, [])])  Statement({, [])  Statement(return (connectGatt(context, autoConnect, callback, TRANSPORT_AUTO)), [])  Statement(}, [])",0,"/**
 * Connect to GATT Server hosted by this device. Caller acts as GATT client.
 * The callback is used to deliver results to Caller, such as connection status as well
 * as any further GATT client operations.
 * The method returns a BluetoothGatt instance. You can use BluetoothGatt to conduct
 * GATT client operations.
 * @param callback GATT callback handler that will receive asynchronous callbacks.
 * @param autoConnect Whether to directly connect to the remote device (false)
 * or to automatically connect as soon as the remote
 * device becomes available (true).
 * @throws IllegalArgumentException if callback is null
 */
","/**
 * Connect to GATT Server hosted by this device. Caller acts as GATT client.
 * The callback is used to deliver results to Caller, such as connection status as well
 * as any further GATT client operations.
 * The method returns a BluetoothGatt instance. You can use BluetoothGatt to conduct
 * GATT client operations.
 *
 * @param callback GATT callback handler that will receive asynchronous callbacks.
 * @param autoConnect Whether to directly connect to the remote device (false) or to
 * automatically connect as soon as the remote device becomes available (true).
 * @throws IllegalArgumentException if callback is null
 */
",1,,,0,,,0,0,0,0,5,0,"The implementation of the method `connectGatt` is different in the two versions. The early version has an extra curly brace `{}`, which makes the AST node of the method body different. This change is categorized as ""Dependent API changed"" (code change type 5) because it is caused by the change of the AST node structure. However, this change does not affect the behavior of the method, so there is no compatibility issue.","This change does not affect the behavior of the method, so there is no compatibility issue."
188,<android.inputmethodservice.IInputMethodWrapper: void bindInput(InputBinding)>,27,28,<android.inputmethodservice.IInputMethodWrapper: void bindInput(InputBinding)>,<android.inputmethodservice.IInputMethodWrapper: void bindInput(InputBinding)>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(// This IInputContext is guaranteed to implement all the methods., []), AssignmentExpression(=, [VariableReference(final int missingMethodFlags, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(InputConnection ic, []), Expression(new InputConnectionWrapper(mTarget, IInputContext.Stub.asInterface(binding.getConnectionToken()), missingMethodFlags), [])]), AssignmentExpression(=, [VariableReference(InputBinding nu, []), Expression(new InputBinding(ic, binding), [])]), MethodCall(mCaller.executeOrSendMessage(mCaller.obtainMessageO(DO_SET_INPUT_CONTEXT, nu)), [VariableReference(mCaller, []), Expression(mCaller.obtainMessageO(DO_SET_INPUT_CONTEXT, []), Expression(nu), [])]), Statement(}, [])])  Statement({, [])  Statement(// This IInputContext is guaranteed to implement all the methods., [])  AssignmentExpression(=, [VariableReference(final int missingMethodFlags, []), Expression(0, [])])    VariableReference(final int missingMethodFlags, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(InputConnection ic, []), Expression(new InputConnectionWrapper(mTarget, IInputContext.Stub.asInterface(binding.getConnectionToken()), missingMethodFlags), [])])    VariableReference(InputConnection ic, [])    Expression(new InputConnectionWrapper(mTarget, IInputContext.Stub.asInterface(binding.getConnectionToken()), missingMethodFlags), [])  AssignmentExpression(=, [VariableReference(InputBinding nu, []), Expression(new InputBinding(ic, binding), [])])    VariableReference(InputBinding nu, [])    Expression(new InputBinding(ic, binding), [])  MethodCall(mCaller.executeOrSendMessage(mCaller.obtainMessageO(DO_SET_INPUT_CONTEXT, nu)), [VariableReference(mCaller, []), Expression(mCaller.obtainMessageO(DO_SET_INPUT_CONTEXT, []), Expression(nu), [])])    VariableReference(mCaller, [])    Expression(mCaller.obtainMessageO(DO_SET_INPUT_CONTEXT, [])    Expression(nu), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mIsUnbindIssued !, []), Expression(null) {, [])]), MethodCall(Log.e(TAG, ""bindInput must be paired with unbindInput.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""bindInput must be paired with unbindInput."", [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(mIsUnbindIssued, []), Expression(new AtomicBoolean(), [])]), Statement(// This IInputContext is guaranteed to implement all the methods., []), AssignmentExpression(=, [VariableReference(final int missingMethodFlags, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(InputConnection ic, []), Expression(new InputConnectionWrapper(mTarget, IInputContext.Stub.asInterface(binding.getConnectionToken()), missingMethodFlags, mIsUnbindIssued), [])]), AssignmentExpression(=, [VariableReference(InputBinding nu, []), Expression(new InputBinding(ic, binding), [])]), MethodCall(mCaller.executeOrSendMessage(mCaller.obtainMessageO(DO_SET_INPUT_CONTEXT, nu)), [VariableReference(mCaller, []), Expression(mCaller.obtainMessageO(DO_SET_INPUT_CONTEXT, []), Expression(nu), [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mIsUnbindIssued !, []), Expression(null) {, [])])    VariableReference(if (mIsUnbindIssued !, [])    Expression(null) {, [])  MethodCall(Log.e(TAG, ""bindInput must be paired with unbindInput.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""bindInput must be paired with unbindInput."", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""bindInput must be paired with unbindInput."", [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mIsUnbindIssued, []), Expression(new AtomicBoolean(), [])])    VariableReference(mIsUnbindIssued, [])    Expression(new AtomicBoolean(), [])  Statement(// This IInputContext is guaranteed to implement all the methods., [])  AssignmentExpression(=, [VariableReference(final int missingMethodFlags, []), Expression(0, [])])    VariableReference(final int missingMethodFlags, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(InputConnection ic, []), Expression(new InputConnectionWrapper(mTarget, IInputContext.Stub.asInterface(binding.getConnectionToken()), missingMethodFlags, mIsUnbindIssued), [])])    VariableReference(InputConnection ic, [])    Expression(new InputConnectionWrapper(mTarget, IInputContext.Stub.asInterface(binding.getConnectionToken()), missingMethodFlags, mIsUnbindIssued), [])  AssignmentExpression(=, [VariableReference(InputBinding nu, []), Expression(new InputBinding(ic, binding), [])])    VariableReference(InputBinding nu, [])    Expression(new InputBinding(ic, binding), [])  MethodCall(mCaller.executeOrSendMessage(mCaller.obtainMessageO(DO_SET_INPUT_CONTEXT, nu)), [VariableReference(mCaller, []), Expression(mCaller.obtainMessageO(DO_SET_INPUT_CONTEXT, []), Expression(nu), [])])    VariableReference(mCaller, [])    Expression(mCaller.obtainMessageO(DO_SET_INPUT_CONTEXT, [])    Expression(nu), [])  Statement(}, [])",1,,,0,[@Override],"[@BinderThread, @Override]",1,,,0,"1,2","3,4,5",0,"2,5","1,2",The following changes have been made between the early and late versions of the API:,"* A new log statement `Log.e(TAG, ""bindInput must be paired with unbindInput."")` has been added after the above condition statement. This is an other statement change (type 4)."
189,<android.os.MemoryFile.MemoryInputStream: int available()>,28,29,<android.os.MemoryFile.MemoryInputStream: int available()>,<android.os.MemoryFile.MemoryInputStream: int available()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mOffset >, []), Expression(mLength) {, [])]), Statement(return 0, []), Statement(}, []), Statement(return mLength - mOffset, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mOffset >, []), Expression(mLength) {, [])])    VariableReference(if (mOffset >, [])    Expression(mLength) {, [])  Statement(return 0, [])  Statement(}, [])  Statement(return mLength - mOffset, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mOffset >, []), Expression(mSharedMemory.getSize()) {, [])]), Statement(return 0, []), Statement(}, []), MethodCall(return mSharedMemory.getSize(), [VariableReference(return mSharedMemory, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mOffset >, []), Expression(mSharedMemory.getSize()) {, [])])    VariableReference(if (mOffset >, [])    Expression(mSharedMemory.getSize()) {, [])  Statement(return 0, [])  Statement(}, [])  MethodCall(return mSharedMemory.getSize(), [VariableReference(return mSharedMemory, []), Expression(, [])])    VariableReference(return mSharedMemory, [])    Expression(, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,0,"1,2","1,3",1,"1,5",1,"The return statement has changed, as well as the variable used in the condition statement and the return value. In the early version, the condition is ""mOffset > mLength"" and the return value is ""mLength - mOffset"". In the late version, the condition is ""mOffset > mSharedMemory.getSize()"" and the return value is ""mSharedMemory.getSize()"".","The change in the condition statement and the return value could lead to different behavior. For example, if the value of ""mLength"" and ""mSharedMemory.getSize()"" are different, the return value would be different in the two versions. Thus, the compatibility issue type is 1."
191,<android.view.textclassifier.TextClassification: String getText()>,28,29,<android.view.textclassifier.TextClassification: String getText()>,<android.view.textclassifier.TextClassification: String getText()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(return mText, []), Statement(}, [])])  Statement({, [])  Statement(return mText, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return mText, []), Statement(}, [])])  Statement({, [])  Statement(return mText, [])  Statement(}, [])",0,"/**
 * Gets the classified text.
 */
","/**
 * Gets the classified text.
 */
",0,[@NonNull],[@Nullable],1,,,0,0,0,0,5,1,"The annotation of the method has changed from @NonNull to @Nullable, indicating that the method may now return a null value.",The change in annotation may lead to compatibility issues for code that relies on the method always returning a non-null value. Such code may now throw a NullPointerException when the method returns null.
192,"<android.view.textclassifier.TextSelection.Builder: Builder setEntityType(String,float)>",28,29,"<android.view.textclassifier.TextSelection.Builder: Builder setEntityType(String,float)>","<android.view.textclassifier.TextSelection.Builder: Builder setEntityType(String,float)>",0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(mEntityConfidence.setEntityType(type, confidenceScore), [VariableReference(mEntityConfidence, []), Expression(type, []), Expression(confidenceScore, [])]), Statement(return this, []), Statement(}, [])])  Statement({, [])  MethodCall(mEntityConfidence.setEntityType(type, confidenceScore), [VariableReference(mEntityConfidence, []), Expression(type, []), Expression(confidenceScore, [])])    VariableReference(mEntityConfidence, [])    Expression(type, [])    Expression(confidenceScore, [])  Statement(return this, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(Preconditions.checkNotNull(type), [VariableReference(Preconditions, []), Expression(type, [])]), MethodCall(mEntityConfidence.put(type, confidenceScore), [VariableReference(mEntityConfidence, []), Expression(type, []), Expression(confidenceScore, [])]), Statement(return this, []), Statement(}, [])])  Statement({, [])  MethodCall(Preconditions.checkNotNull(type), [VariableReference(Preconditions, []), Expression(type, [])])    VariableReference(Preconditions, [])    Expression(type, [])  MethodCall(mEntityConfidence.put(type, confidenceScore), [VariableReference(mEntityConfidence, []), Expression(type, []), Expression(confidenceScore, [])])    VariableReference(mEntityConfidence, [])    Expression(type, [])    Expression(confidenceScore, [])  Statement(return this, [])  Statement(}, [])",1,"/**
 * Sets an entity type for the classified text and assigns a confidence score.
 *
 * @param confidenceScore a value from 0 (low confidence) to 1 (high confidence).
 * 0 implies the entity does not exist for the classified text.
 * Values greater than 1 are clamped to 1.
 */
","/**
 * Sets an entity type for the classified text and assigns a confidence score.
 *
 * @param confidenceScore a value from 0 (low confidence) to 1 (high confidence).
 * 0 implies the entity does not exist for the classified text.
 * Values greater than 1 are clamped to 1.
 */
",0,,[@NonNull],1,,,0,"1,2","1,4,5",1,"2,5",2,"The original MethodCall ""mEntityConfidence.setEntityType(type, confidenceScore)"" is replaced by MethodCall ""Preconditions.checkNotNull(type)"" and ""mEntityConfidence.put(type, confidenceScore)"". Meanwhile, a ""@NonNull"" annotation is added in the late implementation, which is not in the early one.","The second change type (Exception handling statement changed) is detected due to the newly added MethodCall ""Preconditions.checkNotNull(type)"". If the ""type"" argument is null, an exception will be thrown in the late version, while in the early version, the method will still execute ""mEntityConfidence.setEntityType(type, confidenceScore)"" and not throw any exception. Therefore, this change could lead to different behaviors."
193,"<android.bluetooth.BluetoothDevice: BluetoothGatt connectGatt(Context,boolean,BluetoothGattCallback)>",28,29,"<android.bluetooth.BluetoothDevice: BluetoothGatt connectGatt(Context,boolean,BluetoothGattCallback)>","<android.bluetooth.BluetoothDevice: BluetoothGatt connectGatt(Context,boolean,BluetoothGattCallback)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(return (connectGatt(context, autoConnect, callback, TRANSPORT_AUTO)), []), Statement(}, [])])  Statement({, [])  Statement(return (connectGatt(context, autoConnect, callback, TRANSPORT_AUTO)), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return (connectGatt(context, autoConnect, callback, TRANSPORT_AUTO)), []), Statement(}, [])])  Statement({, [])  Statement(return (connectGatt(context, autoConnect, callback, TRANSPORT_AUTO)), [])  Statement(}, [])",0,"/**
 * Connect to GATT Server hosted by this device. Caller acts as GATT client.
 * The callback is used to deliver results to Caller, such as connection status as well
 * as any further GATT client operations.
 * The method returns a BluetoothGatt instance. You can use BluetoothGatt to conduct
 * GATT client operations.
 * @param callback GATT callback handler that will receive asynchronous callbacks.
 * @param autoConnect Whether to directly connect to the remote device (false)
 * or to automatically connect as soon as the remote
 * device becomes available (true).
 * @throws IllegalArgumentException if callback is null
 */
","/**
 * Connect to GATT Server hosted by this device. Caller acts as GATT client.
 * The callback is used to deliver results to Caller, such as connection status as well
 * as any further GATT client operations.
 * The method returns a BluetoothGatt instance. You can use BluetoothGatt to conduct
 * GATT client operations.
 *
 * @param callback GATT callback handler that will receive asynchronous callbacks.
 * @param autoConnect Whether to directly connect to the remote device (false) or to
 * automatically connect as soon as the remote device becomes available (true).
 * @throws IllegalArgumentException if callback is null
 */
",1,,,0,,,0,0,0,0,0,0,"There is no code change between the two versions, only the comments have been slightly modified.",There is no compatibility issue between the two versions since there is no code change.
194,<android.inputmethodservice.IInputMethodWrapper: void bindInput(InputBinding)>,28,29,<android.inputmethodservice.IInputMethodWrapper: void bindInput(InputBinding)>,<android.inputmethodservice.IInputMethodWrapper: void bindInput(InputBinding)>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(// This IInputContext is guaranteed to implement all the methods., []), AssignmentExpression(=, [VariableReference(final int missingMethodFlags, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(InputConnection ic, []), Expression(new InputConnectionWrapper(mTarget, IInputContext.Stub.asInterface(binding.getConnectionToken()), missingMethodFlags), [])]), AssignmentExpression(=, [VariableReference(InputBinding nu, []), Expression(new InputBinding(ic, binding), [])]), MethodCall(mCaller.executeOrSendMessage(mCaller.obtainMessageO(DO_SET_INPUT_CONTEXT, nu)), [VariableReference(mCaller, []), Expression(mCaller.obtainMessageO(DO_SET_INPUT_CONTEXT, []), Expression(nu), [])]), Statement(}, [])])  Statement({, [])  Statement(// This IInputContext is guaranteed to implement all the methods., [])  AssignmentExpression(=, [VariableReference(final int missingMethodFlags, []), Expression(0, [])])    VariableReference(final int missingMethodFlags, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(InputConnection ic, []), Expression(new InputConnectionWrapper(mTarget, IInputContext.Stub.asInterface(binding.getConnectionToken()), missingMethodFlags), [])])    VariableReference(InputConnection ic, [])    Expression(new InputConnectionWrapper(mTarget, IInputContext.Stub.asInterface(binding.getConnectionToken()), missingMethodFlags), [])  AssignmentExpression(=, [VariableReference(InputBinding nu, []), Expression(new InputBinding(ic, binding), [])])    VariableReference(InputBinding nu, [])    Expression(new InputBinding(ic, binding), [])  MethodCall(mCaller.executeOrSendMessage(mCaller.obtainMessageO(DO_SET_INPUT_CONTEXT, nu)), [VariableReference(mCaller, []), Expression(mCaller.obtainMessageO(DO_SET_INPUT_CONTEXT, []), Expression(nu), [])])    VariableReference(mCaller, [])    Expression(mCaller.obtainMessageO(DO_SET_INPUT_CONTEXT, [])    Expression(nu), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mIsUnbindIssued !, []), Expression(null) {, [])]), MethodCall(Log.e(TAG, ""bindInput must be paired with unbindInput.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""bindInput must be paired with unbindInput."", [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(mIsUnbindIssued, []), Expression(new AtomicBoolean(), [])]), Statement(// This IInputContext is guaranteed to implement all the methods., []), AssignmentExpression(=, [VariableReference(final int missingMethodFlags, []), Expression(0, [])]), AssignmentExpression(=, [VariableReference(InputConnection ic, []), Expression(new InputConnectionWrapper(mTarget, IInputContext.Stub.asInterface(binding.getConnectionToken()), missingMethodFlags, mIsUnbindIssued), [])]), AssignmentExpression(=, [VariableReference(InputBinding nu, []), Expression(new InputBinding(ic, binding), [])]), MethodCall(mCaller.executeOrSendMessage(mCaller.obtainMessageO(DO_SET_INPUT_CONTEXT, nu)), [VariableReference(mCaller, []), Expression(mCaller.obtainMessageO(DO_SET_INPUT_CONTEXT, []), Expression(nu), [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mIsUnbindIssued !, []), Expression(null) {, [])])    VariableReference(if (mIsUnbindIssued !, [])    Expression(null) {, [])  MethodCall(Log.e(TAG, ""bindInput must be paired with unbindInput.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""bindInput must be paired with unbindInput."", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""bindInput must be paired with unbindInput."", [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mIsUnbindIssued, []), Expression(new AtomicBoolean(), [])])    VariableReference(mIsUnbindIssued, [])    Expression(new AtomicBoolean(), [])  Statement(// This IInputContext is guaranteed to implement all the methods., [])  AssignmentExpression(=, [VariableReference(final int missingMethodFlags, []), Expression(0, [])])    VariableReference(final int missingMethodFlags, [])    Expression(0, [])  AssignmentExpression(=, [VariableReference(InputConnection ic, []), Expression(new InputConnectionWrapper(mTarget, IInputContext.Stub.asInterface(binding.getConnectionToken()), missingMethodFlags, mIsUnbindIssued), [])])    VariableReference(InputConnection ic, [])    Expression(new InputConnectionWrapper(mTarget, IInputContext.Stub.asInterface(binding.getConnectionToken()), missingMethodFlags, mIsUnbindIssued), [])  AssignmentExpression(=, [VariableReference(InputBinding nu, []), Expression(new InputBinding(ic, binding), [])])    VariableReference(InputBinding nu, [])    Expression(new InputBinding(ic, binding), [])  MethodCall(mCaller.executeOrSendMessage(mCaller.obtainMessageO(DO_SET_INPUT_CONTEXT, nu)), [VariableReference(mCaller, []), Expression(mCaller.obtainMessageO(DO_SET_INPUT_CONTEXT, []), Expression(nu), [])])    VariableReference(mCaller, [])    Expression(mCaller.obtainMessageO(DO_SET_INPUT_CONTEXT, [])    Expression(nu), [])  Statement(}, [])",1,,,0,[@Override],"[@BinderThread, @Override]",1,,,0,"1,2","3,4,5",0,"2,5",2,The Late implementation adds an `if` statement to check the value of `mIsUnbindIssued` and a `Log.e()` statement to log an error message if the value is `false`. It also adds a new parameter `mIsUnbindIssued` to the constructor of `InputConnectionWrapper` class. The annotation of the method has also changed.,The addition of the `if` statement and the `Log.e()` statement may change the behavior of the method in case `mIsUnbindIssued` is `false`. The addition of the new parameter to the constructor of `InputConnectionWrapper` class may cause compatibility issues if the class is used in other parts of the code that have not been updated to include the new parameter. The change of annotation may also cause compatibility issues.
195,<android.widget.CheckedTextView: Mode getCheckMarkTintMode()>,28,29,<android.widget.CheckedTextView: Mode getCheckMarkTintMode()>,<android.widget.CheckedTextView: Mode getCheckMarkTintMode()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(return mCheckMarkTintMode, []), Statement(}, [])])  Statement({, [])  Statement(return mCheckMarkTintMode, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(return mCheckMarkBlendMode !, []), Expression(null ? BlendMode.blendModeToPorterDuffMode(mCheckMarkBlendMode) : null, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(return mCheckMarkBlendMode !, []), Expression(null ? BlendMode.blendModeToPorterDuffMode(mCheckMarkBlendMode) : null, [])])    VariableReference(return mCheckMarkBlendMode !, [])    Expression(null ? BlendMode.blendModeToPorterDuffMode(mCheckMarkBlendMode) : null, [])  Statement(}, [])",1,"/**
 * Returns the blending mode used to apply the tint to the check mark
 * drawable, if specified.
 *
 * @return the blending mode used to apply the tint to the check mark
 * drawable
 * @attr ref android.R.styleable#CheckedTextView_checkMarkTintMode
 * @see #setCheckMarkTintMode(PorterDuff.Mode)
 */
","/**
 * Returns the blending mode used to apply the tint to the check mark
 * drawable, if specified.
 *
 * @return the blending mode used to apply the tint to the check mark
 * drawable
 * @attr ref android.R.styleable#CheckedTextView_checkMarkTintMode
 * @see #setCheckMarkTintMode(PorterDuff.Mode)
 */
",0,[@Nullable],"[@InspectableProperty, @Nullable]",1,,,0,"1,2","1,4",1,"1,5",1,The API implementation has been changed from returning the value of `mCheckMarkTintMode` to returning the value of `mCheckMarkBlendMode` after converting it to a `PorterDuff.Mode` using `BlendMode.blendModeToPorterDuffMode()`. This is a Return statement changed (1) as well as a Dependent API changed (5) since the new implementation uses a different field and a new method to calculate the return value.,"The change in the API implementation can lead to a Compatibility Issue (CI) as the new implementation may return a different value than the previous one. This is because the new implementation uses a different field (`mCheckMarkBlendMode` instead of `mCheckMarkTintMode`) and a new method (`BlendMode.blendModeToPorterDuffMode()`) to calculate the return value. This means that any code that relies on the previous behavior of the API may not work as expected with the new implementation, leading to potential bugs and issues."
196,<android.accessibilityservice.AccessibilityService.SoftKeyboardController: boolean setShowMode(int)>,28,29,<android.accessibilityservice.AccessibilityService.SoftKeyboardController: boolean setShowMode(int)>,<android.accessibilityservice.AccessibilityService.SoftKeyboardController: boolean setShowMode(int)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final IAccessibilityServiceConnection connection, []), Expression(AccessibilityInteractionClient.getInstance().getConnection(mService.mConnectionId), [])]), AssignmentExpression(=, [VariableReference(if (connection !, []), Expression(null) {, [])]), Statement(try {, []), MethodCall(return connection.setSoftKeyboardShowMode(showMode), [VariableReference(return connection, []), Expression(showMode, [])]), Statement(} catch (RemoteException re) {, []), MethodCall(Log.w(LOG_TAG, ""Failed to set soft keyboard behavior"", re), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""Failed to set soft keyboard behavior"", []), Expression(re, [])]), MethodCall(re.rethrowFromSystemServer(), [VariableReference(re, []), Expression(, [])]), Statement(}, []), Statement(}, []), Statement(return false, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final IAccessibilityServiceConnection connection, []), Expression(AccessibilityInteractionClient.getInstance().getConnection(mService.mConnectionId), [])])    VariableReference(final IAccessibilityServiceConnection connection, [])    Expression(AccessibilityInteractionClient.getInstance().getConnection(mService.mConnectionId), [])  AssignmentExpression(=, [VariableReference(if (connection !, []), Expression(null) {, [])])    VariableReference(if (connection !, [])    Expression(null) {, [])  Statement(try {, [])  MethodCall(return connection.setSoftKeyboardShowMode(showMode), [VariableReference(return connection, []), Expression(showMode, [])])    VariableReference(return connection, [])    Expression(showMode, [])  Statement(} catch (RemoteException re) {, [])  MethodCall(Log.w(LOG_TAG, ""Failed to set soft keyboard behavior"", re), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""Failed to set soft keyboard behavior"", []), Expression(re, [])])    VariableReference(Log, [])    Expression(LOG_TAG, [])    Expression(""Failed to set soft keyboard behavior"", [])    Expression(re, [])  MethodCall(re.rethrowFromSystemServer(), [VariableReference(re, []), Expression(, [])])    VariableReference(re, [])    Expression(, [])  Statement(}, [])  Statement(}, [])  Statement(return false, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final IAccessibilityServiceConnection connection, []), Expression(AccessibilityInteractionClient.getInstance().getConnection(mService.mConnectionId), [])]), AssignmentExpression(=, [VariableReference(if (connection !, []), Expression(null) {, [])]), Statement(try {, []), MethodCall(return connection.setSoftKeyboardShowMode(showMode), [VariableReference(return connection, []), Expression(showMode, [])]), Statement(} catch (RemoteException re) {, []), MethodCall(Log.w(LOG_TAG, ""Failed to set soft keyboard behavior"", re), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""Failed to set soft keyboard behavior"", []), Expression(re, [])]), MethodCall(re.rethrowFromSystemServer(), [VariableReference(re, []), Expression(, [])]), Statement(}, []), Statement(}, []), Statement(return false, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final IAccessibilityServiceConnection connection, []), Expression(AccessibilityInteractionClient.getInstance().getConnection(mService.mConnectionId), [])])    VariableReference(final IAccessibilityServiceConnection connection, [])    Expression(AccessibilityInteractionClient.getInstance().getConnection(mService.mConnectionId), [])  AssignmentExpression(=, [VariableReference(if (connection !, []), Expression(null) {, [])])    VariableReference(if (connection !, [])    Expression(null) {, [])  Statement(try {, [])  MethodCall(return connection.setSoftKeyboardShowMode(showMode), [VariableReference(return connection, []), Expression(showMode, [])])    VariableReference(return connection, [])    Expression(showMode, [])  Statement(} catch (RemoteException re) {, [])  MethodCall(Log.w(LOG_TAG, ""Failed to set soft keyboard behavior"", re), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""Failed to set soft keyboard behavior"", []), Expression(re, [])])    VariableReference(Log, [])    Expression(LOG_TAG, [])    Expression(""Failed to set soft keyboard behavior"", [])    Expression(re, [])  MethodCall(re.rethrowFromSystemServer(), [VariableReference(re, []), Expression(, [])])    VariableReference(re, [])    Expression(, [])  Statement(}, [])  Statement(}, [])  Statement(return false, [])  Statement(}, [])",0,"/**
 * Sets the soft keyboard show mode. The default show mode is
 * {@code SHOW_MODE_AUTO}, where the soft keyboard is shown when a text input field is
 * focused. An AccessibilityService can also request the show mode
 * {@code SHOW_MODE_HIDDEN}, where the soft keyboard is never shown. The
 * The lastto this method will be honored, regardless of any previous calls (including those
 * made by other AccessibilityServices).
 * <p>
 * <strong>Note:</strong> If the service is not yet connected (e.g.
 * {@link AccessibilityService#onServiceConnected()} has not yet been called) or the
 * service has been disconnected, this method will have no effect and return {@code false}.
 *
 * @param showMode the new show mode for the soft keyboard
 * @return {@code true} on success
 */
","/**
 * Sets the soft keyboard show mode.
 * <p>
 * <strong>Note:</strong> If the service is not yet connected (e.g.
 * {@link AccessibilityService#onServiceConnected()} has not yet been called) or the
 * service has been disconnected, this method will have no effect and return {@code false}.
 *
 * @param showMode the new show mode for the soft keyboard
 * @return {@code true} on success
 *
 * @see AccessibilityService#SHOW_MODE_AUTO
 * @see AccessibilityService#SHOW_MODE_HIDDEN
 * @see AccessibilityService#SHOW_MODE_IGNORE_HARD_KEYBOARD
 */
",1,,,0,,,0,0,0,0,2,2,"The implementation of the method ""setShowMode"" has changed in the way that it handles the exception ""RemoteException"". In the early version, the method logs the exception using ""Log.w"" and then rethrows it using ""rethrowFromSystemServer"". In the late version, the method only logs the exception and does not rethrow it.","The change in the exception handling of the method ""setShowMode"" can lead to a compatibility issue of type 2. In the early version, if a ""RemoteException"" occurs, it is logged and then rethrown, which means that the caller of the method needs to handle this exception. In the late version, the exception is only logged and not rethrown, which means that the caller of the method does not need to handle this exception. This can lead to different behaviors in the calling code between the two versions."
197,"<android.view.textclassifier.TextSelection.Builder: Builder setEntityType(String,float)>",29,30,"<android.view.textclassifier.TextSelection.Builder: Builder setEntityType(String,float)>","<android.view.textclassifier.TextSelection.Builder: Builder setEntityType(String,float)>",0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(Preconditions.checkNotNull(type), [VariableReference(Preconditions, []), Expression(type, [])]), MethodCall(mEntityConfidence.put(type, confidenceScore), [VariableReference(mEntityConfidence, []), Expression(type, []), Expression(confidenceScore, [])]), Statement(return this, []), Statement(}, [])])  Statement({, [])  MethodCall(Preconditions.checkNotNull(type), [VariableReference(Preconditions, []), Expression(type, [])])    VariableReference(Preconditions, [])    Expression(type, [])  MethodCall(mEntityConfidence.put(type, confidenceScore), [VariableReference(mEntityConfidence, []), Expression(type, []), Expression(confidenceScore, [])])    VariableReference(mEntityConfidence, [])    Expression(type, [])    Expression(confidenceScore, [])  Statement(return this, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(Objects.requireNonNull(type), [VariableReference(Objects, []), Expression(type, [])]), MethodCall(mEntityConfidence.put(type, confidenceScore), [VariableReference(mEntityConfidence, []), Expression(type, []), Expression(confidenceScore, [])]), Statement(return this, []), Statement(}, [])])  Statement({, [])  MethodCall(Objects.requireNonNull(type), [VariableReference(Objects, []), Expression(type, [])])    VariableReference(Objects, [])    Expression(type, [])  MethodCall(mEntityConfidence.put(type, confidenceScore), [VariableReference(mEntityConfidence, []), Expression(type, []), Expression(confidenceScore, [])])    VariableReference(mEntityConfidence, [])    Expression(type, [])    Expression(confidenceScore, [])  Statement(return this, [])  Statement(}, [])",1,"/**
 * Sets an entity type for the classified text and assigns a confidence score.
 *
 * @param confidenceScore a value from 0 (low confidence) to 1 (high confidence).
 * 0 implies the entity does not exist for the classified text.
 * Values greater than 1 are clamped to 1.
 */
","/**
 * Sets an entity type for the classified text and assigns a confidence score.
 *
 * @param confidenceScore a value from 0 (low confidence) to 1 (high confidence).
 * 0 implies the entity does not exist for the classified text.
 * Values greater than 1 are clamped to 1.
 */
",0,[@NonNull],[@NonNull],0,,,0,"1,2",5,0,5,0,The method used for input validation has been changed from `Preconditions.checkNotNull(type)` to `Objects.requireNonNull(type)`. This is a dependent API change since it involves modifications to the method name and the class it belongs to.,"The change in the input validation method does not affect the behavior of the `setEntityType` method. Both `Preconditions.checkNotNull` and `Objects.requireNonNull` throw a `NullPointerException` if the input is null. Therefore, there are no compatibility issues introduced by this change."
198,"<android.net.ConnectivityManager.NetworkCallback: void onLinkPropertiesChanged(Network,LinkProperties)>",29,30,"<android.net.ConnectivityManager.NetworkCallback: void onLinkPropertiesChanged(Network,LinkProperties)>","<android.net.ConnectivityManager.NetworkCallback: void onLinkPropertiesChanged(Network,LinkProperties)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(}, [])])  Statement({, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(}, [])])  Statement({, [])  Statement(}, [])",0,"/**
 * Called when the network the framework connected to for this request
 * changes {@link LinkProperties}.
 *
 * @param network The {@link Network} whose link properties have changed.
 * @param linkProperties The new {@link LinkProperties} for this network.
 */
","/**
 * Called when the network corresponding to this request changes {@link LinkProperties}.
 *
 * <p>Starting with {@link android.os.Build.VERSION_CODES#O} this method is guaranteed
 * to be called immediately after {@link #onAvailable}.
 *
 * <p>Do NOT call {@link #getNetworkCapabilities(Network)} or other synchronous
 * ConnectivityManager methods in this callback as this is prone to race conditions :
 * calling these methods while in a callback may return an outdated or even a null object.
 *
 * @param network The {@link Network} whose link properties have changed.
 * @param linkProperties The new {@link LinkProperties} for this network.
 */
",1,,,0,,,0,0,0,0,0,0,The AST nodes of the method implementation in both versions are the same. The only difference is in the method comment where some additional information has been added in the late version.,There is no compatibility issue as the method implementation has not changed and the additional information in the method comment does not affect the behavior of the API.
199,<android.hardware.radio.RadioManager.ModuleProperties: String toString()>,29,30,<android.hardware.radio.RadioManager.ModuleProperties: String toString()>,<android.hardware.radio.RadioManager.ModuleProperties: String toString()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(return ""ModuleProperties [mId, []), Expression("" + mId + "", mServiceName, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(return ""ModuleProperties [mId, []), Expression("" + mId + "", mServiceName, [])])    VariableReference(return ""ModuleProperties [mId, [])    Expression("" + mId + "", mServiceName, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(return ""ModuleProperties [mId, []), Expression("" + mId + "", mServiceName, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(return ""ModuleProperties [mId, []), Expression("" + mId + "", mServiceName, [])])    VariableReference(return ""ModuleProperties [mId, [])    Expression("" + mId + "", mServiceName, [])  Statement(}, [])",0,,,0,[@Override],"[@NonNull, @Override]",1,,,0,0,0,0,4,0,A new annotation `@NonNull` has been added to the method in the late version. This change does not affect the method's behavior or its return value.,"No Compatibility Issue exists in this case. The added annotation `@NonNull` only indicates that the method will not return a null value, but it does not change the method's behavior or its return value."
200,"<android.app.admin.DeviceAdminReceiver: void onUserSwitched(Context,Intent,UserHandle)>",30,31,"<android.app.admin.DeviceAdminReceiver: void onUserSwitched(Context,Intent,UserHandle)>","<android.app.admin.DeviceAdminReceiver: void onUserSwitched(Context,Intent,UserHandle)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(}, [])])  Statement({, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (LOCAL_LOGV) {, []), MethodCall(Log.v(TAG, getClass().getName() + "".onUserSwitched() on user "" + context.getUserId()), [VariableReference(Log, []), Expression(TAG, []), Expression(getClass().getName() + "".onUserSwitched() on user "" + context.getUserId(), [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(if (LOCAL_LOGV) {, [])  MethodCall(Log.v(TAG, getClass().getName() + "".onUserSwitched() on user "" + context.getUserId()), [VariableReference(Log, []), Expression(TAG, []), Expression(getClass().getName() + "".onUserSwitched() on user "" + context.getUserId(), [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(getClass().getName() + "".onUserSwitched() on user "" + context.getUserId(), [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Called when a user or profile is switched to.
 *
 * <p>This callback is only applicable to device owners.
 *
 * @param context The running context as per {@link #onReceive}.
 * @param intent The received intent as per {@link #onReceive}.
 * @param switchedUser The {@link UserHandle} of the user that has just been switched to.
 */
","/**
 * Called when a user or profile is switched to.
 *
 * <p>This callback is only applicable to device owners.
 *
 * @param context The running context as per {@link #onReceive}.
 * @param intent The received intent as per {@link #onReceive}.
 * @param switchedUser The {@link UserHandle} of the user that has just been switched to.
 */
",0,,,0,,,0,"1,2","3,4",0,4,0,"The code change is that two log statements are added in the late version. These statements are not related to return statements, exception handling statements, and control dependency, so the change type is 4 (other statement changed).","The added log statements do not affect the behavior of the API, so there is no compatibility issue in this case."
201,<android.bluetooth.BluetoothGattServer: List<BluetoothGattService> getServices()>,30,31,<android.bluetooth.BluetoothGattServer: List<BluetoothGattService> getServices()>,<android.bluetooth.BluetoothGattServer: List<BluetoothGattService> getServices()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(return mServices, []), Statement(}, [])])  Statement({, [])  Statement(return mServices, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return mServices, []), Statement(}, [])])  Statement({, [])  Statement(return mServices, [])  Statement(}, [])",0,"/**
 * Returns a list of GATT services offered by this device.
 *
 * <p>An application must call {@link #addService} to add a serice to the
 * list of services offered by this device.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @return List of services. Returns an empty list if no services have been added yet.
 */
","/**
 * Returns a list of GATT services offered by this device.
 *
 * <p>An application must call {@link #addService} to add a serice to the
 * list of services offered by this device.
 *
 * @return List of services. Returns an empty list if no services have been added yet.
 */
",1,,"[@RequiresLegacyBluetoothPermission, @RequiresNoPermission]",1,,,0,0,0,0,0,0,N/A,N/A
202,<android.app.Application: void dispatchActivityPostStarted(Activity)>,30,31,<android.app.Application: void dispatchActivityPostStarted(Activity)>,<android.app.Application: void dispatchActivityPostStarted(Activity)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(Object[] callbacks, []), Expression(collectActivityLifecycleCallbacks(), [])]), AssignmentExpression(=, [VariableReference(if (callbacks !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < callbacks.length, []), Statement(i++) {, []), MethodCall(((ActivityLifecycleCallbacks) callbacks[i]).onActivityPostStarted(activity), [VariableReference(((ActivityLifecycleCallbacks) callbacks[i]), []), Expression(activity, [])]), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(Object[] callbacks, []), Expression(collectActivityLifecycleCallbacks(), [])])    VariableReference(Object[] callbacks, [])    Expression(collectActivityLifecycleCallbacks(), [])  AssignmentExpression(=, [VariableReference(if (callbacks !, []), Expression(null) {, [])])    VariableReference(if (callbacks !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < callbacks.length, [])  Statement(i++) {, [])  MethodCall(((ActivityLifecycleCallbacks) callbacks[i]).onActivityPostStarted(activity), [VariableReference(((ActivityLifecycleCallbacks) callbacks[i]), []), Expression(activity, [])])    VariableReference(((ActivityLifecycleCallbacks) callbacks[i]), [])    Expression(activity, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(Object[] callbacks, []), Expression(collectActivityLifecycleCallbacks(), [])]), AssignmentExpression(=, [VariableReference(if (callbacks !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < callbacks.length, []), Statement(i++) {, []), MethodCall(((ActivityLifecycleCallbacks) callbacks[i]).onActivityPostStarted(activity), [VariableReference(((ActivityLifecycleCallbacks) callbacks[i]), []), Expression(activity, [])]), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(Object[] callbacks, []), Expression(collectActivityLifecycleCallbacks(), [])])    VariableReference(Object[] callbacks, [])    Expression(collectActivityLifecycleCallbacks(), [])  AssignmentExpression(=, [VariableReference(if (callbacks !, []), Expression(null) {, [])])    VariableReference(if (callbacks !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < callbacks.length, [])  Statement(i++) {, [])  MethodCall(((ActivityLifecycleCallbacks) callbacks[i]).onActivityPostStarted(activity), [VariableReference(((ActivityLifecycleCallbacks) callbacks[i]), []), Expression(activity, [])])    VariableReference(((ActivityLifecycleCallbacks) callbacks[i]), [])    Expression(activity, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])",0,,,0,[@UnsupportedAppUsage],"[@UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553)]",1,,,0,0,0,0,5,0,"The annotation of the method has been changed from `@UnsupportedAppUsage` to `@UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553)`. This change only affects the meta-data of the method and does not modify the implementation of the method.","The annotation change does not affect the behavior of the method, so there is no compatibility issue."
203,"<android.hardware.camera2.impl.CameraMetadataNative: void set(Key<T>,T)>",31,32,"<android.hardware.camera2.impl.CameraMetadataNative: void set(Key<T>,T)>","<android.hardware.camera2.impl.CameraMetadataNative: void set(Key<T>,T)>",0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(set(key.getNativeKey(), value), [VariableReference(set(key, []), Expression(), []), Expression(value, [])]), Statement(}, [])])  Statement({, [])  MethodCall(set(key.getNativeKey(), value), [VariableReference(set(key, []), Expression(), []), Expression(value, [])])    VariableReference(set(key, [])    Expression(), [])    Expression(value, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(SetCommand s, []), Expression(sSetCommandMap.get(key), [])]), AssignmentExpression(=, [VariableReference(if (s !, []), Expression(null) {, [])]), MethodCall(s.setValue(this, value), [VariableReference(s, []), Expression(this, []), Expression(value, [])]), Statement(return, []), Statement(}, []), Statement(setBase(key, value), []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(SetCommand s, []), Expression(sSetCommandMap.get(key), [])])    VariableReference(SetCommand s, [])    Expression(sSetCommandMap.get(key), [])  AssignmentExpression(=, [VariableReference(if (s !, []), Expression(null) {, [])])    VariableReference(if (s !, [])    Expression(null) {, [])  MethodCall(s.setValue(this, value), [VariableReference(s, []), Expression(this, []), Expression(value, [])])    VariableReference(s, [])    Expression(this, [])    Expression(value, [])  Statement(return, [])  Statement(}, [])  Statement(setBase(key, value), [])  Statement(}, [])",1,,"/**
 * Set a camera metadata field to a value. The field definitions can be
 * found in {@link CameraCharacteristics}, {@link CaptureResult}, and
 * {@link CaptureRequest}.
 *
 * @param key The metadata field to write.
 * @param value The value to set the field to, which must be of a matching
 * type to the key.
 */
",1,,,0,,,0,"1,2","1,3,4,5",1,"1,3,4",1,"There are code changes between the early and late versions of the API. Specifically, in the late version implementation, there are new assignment expressions, a new if statement, and a new method call (s.setValue(this, value)). These changes are classified as 1 (Return statement changed), 3 (Control dependency changed), and 4 (Other statement changed).","The code changes in the late version may potentially lead to different behaviors compared to the early version. Specifically, the new method call (s.setValue(this, value)) may cause the API to return a different value, which is classified as Compatibility Issue caused by potential different return values or types (1)."
204,<android.view.accessibility.AccessibilityEvent: void setEventType(int)>,31,32,<android.view.accessibility.AccessibilityEvent: void setEventType(int)>,<android.view.accessibility.AccessibilityEvent: void setEventType(int)>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(enforceNotSealed(), []), AssignmentExpression(=, [VariableReference(mEventType, []), Expression(eventType, [])]), Statement(}, [])])  Statement({, [])  Statement(enforceNotSealed(), [])  AssignmentExpression(=, [VariableReference(mEventType, []), Expression(eventType, [])])    VariableReference(mEventType, [])    Expression(eventType, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(enforceNotSealed(), []), AssignmentExpression(=, [VariableReference(mEventType, []), Expression(eventType, [])]), Statement(}, [])])  Statement({, [])  Statement(enforceNotSealed(), [])  AssignmentExpression(=, [VariableReference(mEventType, []), Expression(eventType, [])])    VariableReference(mEventType, [])    Expression(eventType, [])  Statement(}, [])",0,"/**
 * Sets the event type.
 *
 * @param eventType The event type.
 *
 * @throws IllegalStateException If called from an AccessibilityService.
 */
","/**
 * Sets the event type.
 *
 * <b>Note: An event must represent a single event type.</b>
 * @param eventType The event type.
 *
 * @throws IllegalStateException If called from an AccessibilityService.
 */
",1,,,0,,,0,0,0,0,0,0,There is no difference between the early implementation AST node and the late implementation AST node. The comments have been updated to provide more clarity.,There is no compatibility issue as the API behavior remains the same. The update in the comment is not a code change and does not affect the API behavior.
205,<android.accessibilityservice.AccessibilityService: Context createDisplayContext(Display)>,31,32,<android.accessibilityservice.AccessibilityService: Context createDisplayContext(Display)>,<android.accessibilityservice.AccessibilityService: Context createDisplayContext(Display)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final Context context, []), Expression(super.createDisplayContext(display), [])]), AssignmentExpression(=, [VariableReference(final int displayId, []), Expression(display.getDisplayId(), [])]), Statement(setDefaultTokenInternal(context, displayId), []), Statement(return context, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final Context context, []), Expression(super.createDisplayContext(display), [])])    VariableReference(final Context context, [])    Expression(super.createDisplayContext(display), [])  AssignmentExpression(=, [VariableReference(final int displayId, []), Expression(display.getDisplayId(), [])])    VariableReference(final int displayId, [])    Expression(display.getDisplayId(), [])  Statement(setDefaultTokenInternal(context, displayId), [])  Statement(return context, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(return new AccessibilityContext(super.createDisplayContext(display), mConnectionId), [VariableReference(return new AccessibilityContext(super, []), Expression(display), []), Expression(mConnectionId, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return new AccessibilityContext(super.createDisplayContext(display), mConnectionId), [VariableReference(return new AccessibilityContext(super, []), Expression(display), []), Expression(mConnectionId, [])])    VariableReference(return new AccessibilityContext(super, [])    Expression(display), [])    Expression(mConnectionId, [])  Statement(}, [])",1,,,0,[@Override],"[@NonNull, @Override]",1,,,0,"1,2","1,4",1,"1,5","1,2","The implementation of the method has been completely changed. In the early version, it first calls the superclass's `createDisplayContext` method and assigns the result to a local variable `context`. Then it gets the display id and assigns it to `displayId`. After that, it calls `setDefaultTokenInternal` method with `context` and `displayId` as parameters. Finally, it returns `context`. In the late version, it directly creates a new `AccessibilityContext` object with the result of the superclass's `createDisplayContext` method and a new field `mConnectionId` as parameters, and returns it. Also, the late version has an additional `@NonNull` annotation.","The change of implementation can lead to compatibility issues. In the early version, the method returns the context created by the superclass, while in the late version, it returns a new `AccessibilityContext` object. This means that the returned object's type and value are different, which can cause potential compatibility issues. For example, if the client code only expects the context created by the superclass, it may not work properly with the new `AccessibilityContext` object. Also, the new `@NonNull` annotation means that the method will never return null, which can also cause potential compatibility issues if the client code relies on the possibility of a null return."
206,<android.os.UserManager: Bundle getUserRestrictions()>,32,33,<android.os.UserManager: Bundle getUserRestrictions()>,<android.os.UserManager: Bundle getUserRestrictions()>,0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(return getUserRestrictions(Process.myUserHandle()), [VariableReference(return getUserRestrictions(Process, []), Expression(), [])]), Statement(}, [])])  Statement({, [])  MethodCall(return getUserRestrictions(Process.myUserHandle()), [VariableReference(return getUserRestrictions(Process, []), Expression(), [])])    VariableReference(return getUserRestrictions(Process, [])    Expression(), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(return mService.getUserRestrictions(getContextUserIfAppropriate()), [VariableReference(return mService, []), Expression(getContextUserIfAppropriate(), [])]), Statement(} catch (RemoteException re) {, []), MethodCall(throw re.rethrowFromSystemServer(), [VariableReference(throw re, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(return mService.getUserRestrictions(getContextUserIfAppropriate()), [VariableReference(return mService, []), Expression(getContextUserIfAppropriate(), [])])    VariableReference(return mService, [])    Expression(getContextUserIfAppropriate(), [])  Statement(} catch (RemoteException re) {, [])  MethodCall(throw re.rethrowFromSystemServer(), [VariableReference(throw re, []), Expression(, [])])    VariableReference(throw re, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Returns the user-wide restrictions imposed on this user.
 * @return a Bundle containing all the restrictions.
 */
","/**
 * Returns the user-wide restrictions imposed on the context user.
 * @return a Bundle containing all the restrictions.
 */
",1,,"[@UserHandleAware(enabledSinceTargetSdkVersion = Build.VERSION_CODES.TIRAMISU, requiresAnyOfPermissionsIfNotCallerProfileGroup = { android.Manifest.permission.MANAGE_USERS, android.Manifest.permission.INTERACT_ACROSS_USERS })]",1,,,0,"1,2","1,2,5","1,2","1,2,5","1,2","The early implementation of the API returns the user restrictions by directly calling the `getUserRestrictions(Process.myUserHandle())` method. In the late version, the API first calls the `getContextUserIfAppropriate()` method to get the appropriate user handle and then calls the `mService.getUserRestrictions(getContextUserIfAppropriate())` method to get the user restrictions. A new try-catch block is also added in the late version, which throws a `RemoteException` if it occurs. Moreover, a new annotation `@UserHandleAware` is added in the late version, indicating that the API is user handle aware.","The change in the implementation of the API, from directly calling the `getUserRestrictions(Process.myUserHandle())` method to first calling the `getContextUserIfAppropriate()` method to get the appropriate user handle, could potentially lead to different user restrictions being returned. Therefore, it is classified as a Compatibility Issue caused by potential different return values or types (1)."
207,<android.service.dreams.DreamService: boolean isScreenBright()>,32,33,<android.service.dreams.DreamService: boolean isScreenBright()>,<android.service.dreams.DreamService: boolean isScreenBright()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(}, [])])  Statement({, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(}, [])])  Statement({, [])  Statement(}, [])",0,"/**
 * Returns whether or not this dream keeps the screen bright while dreaming.
 * Defaults to false, allowing the screen to dim if necessary.
 *
 * @see #setScreenBright(boolean)
 */
","/**
 * Returns whether this dream keeps the screen bright while dreaming.
 * Defaults to false, allowing the screen to dim if necessary.
 *
 * @see #setScreenBright(boolean)
 */
",1,,,0,,,0,0,0,0,0,0,"The implementation AST node, the comment and annotation of the API `isScreenBright()` in early version (32) and late version (33) are the same. So there is no code change.","As the code implementation, comment and annotation are the same between the two versions, there is no potential compatibility issue that can arise from this API."
208,<android.os.Parcel: Parcelable[] readParcelableArray(ClassLoader)>,32,33,<android.os.Parcel: Parcelable[] readParcelableArray(ClassLoader)>,<android.os.Parcel: Parcelable[] readParcelableArray(ClassLoader)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(int N, []), Expression(readInt(), [])]), Statement(if (N < 0) {, []), Statement(return null, []), Statement(}, []), AssignmentExpression(=, [VariableReference(Parcelable[] p, []), Expression(new Parcelable[N], [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < N, []), Statement(i++) {, []), AssignmentExpression(=, [VariableReference(p[i], []), Expression(readParcelable(loader), [])]), Statement(}, []), Statement(return p, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(int N, []), Expression(readInt(), [])])    VariableReference(int N, [])    Expression(readInt(), [])  Statement(if (N < 0) {, [])  Statement(return null, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(Parcelable[] p, []), Expression(new Parcelable[N], [])])    VariableReference(Parcelable[] p, [])    Expression(new Parcelable[N], [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < N, [])  Statement(i++) {, [])  AssignmentExpression(=, [VariableReference(p[i], []), Expression(readParcelable(loader), [])])    VariableReference(p[i], [])    Expression(readParcelable(loader), [])  Statement(}, [])  Statement(return p, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return readParcelableArrayInternal(loader, /* clazz */, []), Statement(null), []), Statement(}, [])])  Statement({, [])  Statement(return readParcelableArrayInternal(loader, /* clazz */, [])  Statement(null), [])  Statement(}, [])",1,"/**
 * Read and return a new Parcelable array from the parcel.
 * The given class loader will be used to load any enclosed
 * Parcelables.
 * @return the Parcelable array, or null if the array is null
 */
","/**
 * Read and return a new Parcelable array from the parcel.
 * The given class loader will be used to load any enclosed
 * Parcelables.
 * @return the Parcelable array, or null if the array is null
 *
 * @deprecated Use the type-safer version {@link #readParcelableArray(ClassLoader, Class)}
 * starting from Android {@link Build.VERSION_CODES#TIRAMISU}. Also consider changing the
 * format to use {@link #createTypedArray(Parcelable.Creator)} if possible (eg. if the
 * items' class is final) since this is also more performant. Note that changing to the
 * latter also requires changing the writes.
 */
",1,[@Nullable],"[@Deprecated, @Nullable]",1,,,0,"1,2","1,2,5","1,2",5,1,"The implementation of the method has been completely changed, from manually reading the length and elements of the array to using an internal method `readParcelableArrayInternal()`. This is a code change of type 5, which is a dependent API change.","The new implementation may lead to compatibility issues, as the behavior of the internal method `readParcelableArrayInternal()` may be different from the previous manual implementation. This is a CI of type 1, which is caused by potential different return values or types."
502,"<android.os.image.DynamicSystemClient.DynSystemServiceConnection: void onServiceConnected(ComponentName,IBinder)>",30,31,"<android.os.image.DynamicSystemClient.DynSystemServiceConnection: void onServiceConnected(ComponentName,IBinder)>","<android.os.image.DynamicSystemClient.DynSystemServiceConnection: void onServiceConnected(ComponentName,IBinder)>",0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(Slog.v(TAG, ""DynSystemService connected""), [VariableReference(Slog, []), Expression(TAG, []), Expression(""DynSystemService connected"", [])]), AssignmentExpression(=, [VariableReference(mService, []), Expression(new Messenger(service), [])]), Statement(try {, []), AssignmentExpression(=, [VariableReference(Message msg, []), Expression(Message.obtain(null, MSG_REGISTER_LISTENER), [])]), AssignmentExpression(=, [VariableReference(msg.replyTo, []), Expression(mMessenger, [])]), MethodCall(mService.send(msg), [VariableReference(mService, []), Expression(msg, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(Slog.e(TAG, ""Unable to get status from installation service""), [VariableReference(Slog, []), Expression(TAG, []), Expression(""Unable to get status from installation service"", [])]), AssignmentExpression(=, [VariableReference(if (mExecutor !, []), Expression(null) {, [])]), MethodCall(mExecutor.execute((), [VariableReference(mExecutor, []), Expression((, [])]), MethodCall(mListener.onStatusChanged(STATUS_UNKNOWN, CAUSE_ERROR_IPC, 0, e), [VariableReference(mListener, []), Expression(STATUS_UNKNOWN, []), Expression(CAUSE_ERROR_IPC, []), Expression(0, []), Expression(e, [])]), Statement(}), []), Statement(} else {, []), MethodCall(mListener.onStatusChanged(STATUS_UNKNOWN, CAUSE_ERROR_IPC, 0, e), [VariableReference(mListener, []), Expression(STATUS_UNKNOWN, []), Expression(CAUSE_ERROR_IPC, []), Expression(0, []), Expression(e, [])]), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  MethodCall(Slog.v(TAG, ""DynSystemService connected""), [VariableReference(Slog, []), Expression(TAG, []), Expression(""DynSystemService connected"", [])])    VariableReference(Slog, [])    Expression(TAG, [])    Expression(""DynSystemService connected"", [])  AssignmentExpression(=, [VariableReference(mService, []), Expression(new Messenger(service), [])])    VariableReference(mService, [])    Expression(new Messenger(service), [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(Message msg, []), Expression(Message.obtain(null, MSG_REGISTER_LISTENER), [])])    VariableReference(Message msg, [])    Expression(Message.obtain(null, MSG_REGISTER_LISTENER), [])  AssignmentExpression(=, [VariableReference(msg.replyTo, []), Expression(mMessenger, [])])    VariableReference(msg.replyTo, [])    Expression(mMessenger, [])  MethodCall(mService.send(msg), [VariableReference(mService, []), Expression(msg, [])])    VariableReference(mService, [])    Expression(msg, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(Slog.e(TAG, ""Unable to get status from installation service""), [VariableReference(Slog, []), Expression(TAG, []), Expression(""Unable to get status from installation service"", [])])    VariableReference(Slog, [])    Expression(TAG, [])    Expression(""Unable to get status from installation service"", [])  AssignmentExpression(=, [VariableReference(if (mExecutor !, []), Expression(null) {, [])])    VariableReference(if (mExecutor !, [])    Expression(null) {, [])  MethodCall(mExecutor.execute((), [VariableReference(mExecutor, []), Expression((, [])])    VariableReference(mExecutor, [])    Expression((, [])  MethodCall(mListener.onStatusChanged(STATUS_UNKNOWN, CAUSE_ERROR_IPC, 0, e), [VariableReference(mListener, []), Expression(STATUS_UNKNOWN, []), Expression(CAUSE_ERROR_IPC, []), Expression(0, []), Expression(e, [])])    VariableReference(mListener, [])    Expression(STATUS_UNKNOWN, [])    Expression(CAUSE_ERROR_IPC, [])    Expression(0, [])    Expression(e, [])  Statement(}), [])  Statement(} else {, [])  MethodCall(mListener.onStatusChanged(STATUS_UNKNOWN, CAUSE_ERROR_IPC, 0, e), [VariableReference(mListener, []), Expression(STATUS_UNKNOWN, []), Expression(CAUSE_ERROR_IPC, []), Expression(0, []), Expression(e, [])])    VariableReference(mListener, [])    Expression(STATUS_UNKNOWN, [])    Expression(CAUSE_ERROR_IPC, [])    Expression(0, [])    Expression(e, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(Slog.v(TAG, ""onServiceConnected: "" + className), [VariableReference(Slog, []), Expression(TAG, []), Expression(""onServiceConnected: "" + className, [])]), AssignmentExpression(=, [VariableReference(mService, []), Expression(new Messenger(service), [])]), Statement(try {, []), AssignmentExpression(=, [VariableReference(Message msg, []), Expression(Message.obtain(null, MSG_REGISTER_LISTENER), [])]), AssignmentExpression(=, [VariableReference(msg.replyTo, []), Expression(mMessenger, [])]), MethodCall(mService.send(msg), [VariableReference(mService, []), Expression(msg, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(Slog.e(TAG, ""Unable to get status from installation service""), [VariableReference(Slog, []), Expression(TAG, []), Expression(""Unable to get status from installation service"", [])]), Statement(notifyOnStatusChangedListener(STATUS_UNKNOWN, CAUSE_ERROR_IPC, 0, e), []), Statement(}, []), Statement(}, [])])  Statement({, [])  MethodCall(Slog.v(TAG, ""onServiceConnected: "" + className), [VariableReference(Slog, []), Expression(TAG, []), Expression(""onServiceConnected: "" + className, [])])    VariableReference(Slog, [])    Expression(TAG, [])    Expression(""onServiceConnected: "" + className, [])  AssignmentExpression(=, [VariableReference(mService, []), Expression(new Messenger(service), [])])    VariableReference(mService, [])    Expression(new Messenger(service), [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(Message msg, []), Expression(Message.obtain(null, MSG_REGISTER_LISTENER), [])])    VariableReference(Message msg, [])    Expression(Message.obtain(null, MSG_REGISTER_LISTENER), [])  AssignmentExpression(=, [VariableReference(msg.replyTo, []), Expression(mMessenger, [])])    VariableReference(msg.replyTo, [])    Expression(mMessenger, [])  MethodCall(mService.send(msg), [VariableReference(mService, []), Expression(msg, [])])    VariableReference(mService, [])    Expression(msg, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(Slog.e(TAG, ""Unable to get status from installation service""), [VariableReference(Slog, []), Expression(TAG, []), Expression(""Unable to get status from installation service"", [])])    VariableReference(Slog, [])    Expression(TAG, [])    Expression(""Unable to get status from installation service"", [])  Statement(notifyOnStatusChangedListener(STATUS_UNKNOWN, CAUSE_ERROR_IPC, 0, e), [])  Statement(}, [])  Statement(}, [])",1,,,-1,,,-1,-1,-1,-1,-1,"2,3,4",0,"1,2","1,2","The code change between the two versions is in the method body. In the early version, when a `RemoteException` is caught, the method `mListener.onStatusChanged()` is called twice - once in the `if` statement and once in the `else` statement. In the late version, the `if-else` statement has been removed, and the method `mListener.onStatusChanged()` is called only once in the `catch` block. Additionally, the log message in the `catch` block has been changed.","The Compatibility Issue (CI) arises from the code change in the method body. In the early version, the method `mListener.onStatusChanged()` is called twice when a `RemoteException` is caught, which may not be the intended behavior. In the late version, the method is called only once, which is more likely to be correct. This change in the method's behavior can lead to different results or exceptions in the calling code, depending on how it is designed to handle the `RemoteException`. Therefore, the CI type is 1, 2."
168,<android.hardware.display.DisplayManagerInternal.DisplayPowerRequest: boolean equals(DisplayPowerRequest)>,29,30,<android.hardware.display.DisplayManagerInternal.DisplayPowerRequest: boolean equals(DisplayPowerRequest)>,<android.hardware.display.DisplayManagerInternal.DisplayPowerRequest: boolean equals(DisplayPowerRequest)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(return other !, []), Expression(null && policy, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(return other !, []), Expression(null && policy, [])])    VariableReference(return other !, [])    Expression(null && policy, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(return other !, []), Expression(null && policy, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(return other !, []), Expression(null && policy, [])])    VariableReference(return other !, [])    Expression(null && policy, [])  Statement(}, [])",1,,,-1,,,-1,-1,-1,-1,-1,"1,4",0,0,0,,* There are no Compatibility Issues since there are no changes in the implementation.
223,<android.text.TextUtils: int getLayoutDirectionFromLocale(Locale)>,18,19,<android.text.TextUtils: int getLayoutDirectionFromLocale(Locale)>,<android.text.TextUtils: int getLayoutDirectionFromLocale(Locale)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (locale !, []), Expression(null && !locale.equals(Locale.ROOT)) {, [])]), AssignmentExpression(=, [VariableReference(final String scriptSubtag, []), Expression(ICU.getScript(ICU.addLikelySubtags(locale.toString())), [])]), AssignmentExpression(=, [VariableReference(if (scriptSubtag, []), Expression(, [])]), Statement(return getLayoutDirectionFromFirstChar(locale), []), MethodCall(if (scriptSubtag.equalsIgnoreCase(ARAB_SCRIPT_SUBTAG) || scriptSubtag.equalsIgnoreCase(HEBR_SCRIPT_SUBTAG)), [VariableReference(if (scriptSubtag, []), Expression(ARAB_SCRIPT_SUBTAG) || scriptSubtag.equalsIgnoreCase(HEBR_SCRIPT_SUBTAG), [])]), Statement(return View.LAYOUT_DIRECTION_RTL, []), Statement(}, []), Statement(}, []), Statement(return View.LAYOUT_DIRECTION_LTR, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (locale !, []), Expression(null && !locale.equals(Locale.ROOT)) {, [])])    VariableReference(if (locale !, [])    Expression(null && !locale.equals(Locale.ROOT)) {, [])  AssignmentExpression(=, [VariableReference(final String scriptSubtag, []), Expression(ICU.getScript(ICU.addLikelySubtags(locale.toString())), [])])    VariableReference(final String scriptSubtag, [])    Expression(ICU.getScript(ICU.addLikelySubtags(locale.toString())), [])  AssignmentExpression(=, [VariableReference(if (scriptSubtag, []), Expression(, [])])    VariableReference(if (scriptSubtag, [])    Expression(, [])  Statement(return getLayoutDirectionFromFirstChar(locale), [])  MethodCall(if (scriptSubtag.equalsIgnoreCase(ARAB_SCRIPT_SUBTAG) || scriptSubtag.equalsIgnoreCase(HEBR_SCRIPT_SUBTAG)), [VariableReference(if (scriptSubtag, []), Expression(ARAB_SCRIPT_SUBTAG) || scriptSubtag.equalsIgnoreCase(HEBR_SCRIPT_SUBTAG), [])])    VariableReference(if (scriptSubtag, [])    Expression(ARAB_SCRIPT_SUBTAG) || scriptSubtag.equalsIgnoreCase(HEBR_SCRIPT_SUBTAG), [])  Statement(return View.LAYOUT_DIRECTION_RTL, [])  Statement(}, [])  Statement(}, [])  Statement(return View.LAYOUT_DIRECTION_LTR, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (locale !, []), Expression(null && !locale.equals(Locale.ROOT)) {, [])]), AssignmentExpression(=, [VariableReference(final String scriptSubtag, []), Expression(ICU.getScript(ICU.addLikelySubtags(locale.toString())), [])]), AssignmentExpression(=, [VariableReference(if (scriptSubtag, []), Expression(, [])]), Statement(return getLayoutDirectionFromFirstChar(locale), []), MethodCall(if (scriptSubtag.equalsIgnoreCase(ARAB_SCRIPT_SUBTAG) || scriptSubtag.equalsIgnoreCase(HEBR_SCRIPT_SUBTAG)), [VariableReference(if (scriptSubtag, []), Expression(ARAB_SCRIPT_SUBTAG) || scriptSubtag.equalsIgnoreCase(HEBR_SCRIPT_SUBTAG), [])]), Statement(return View.LAYOUT_DIRECTION_RTL, []), Statement(}, []), Statement(}, []), Statement(// If forcing into RTL layout mode, return RTL as default, else LTR, []), MethodCall(return SystemProperties.getBoolean(Settings.Global.DEVELOPMENT_FORCE_RTL, false), [VariableReference(return SystemProperties, []), Expression(Settings.Global.DEVELOPMENT_FORCE_RTL, []), Expression(false, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (locale !, []), Expression(null && !locale.equals(Locale.ROOT)) {, [])])    VariableReference(if (locale !, [])    Expression(null && !locale.equals(Locale.ROOT)) {, [])  AssignmentExpression(=, [VariableReference(final String scriptSubtag, []), Expression(ICU.getScript(ICU.addLikelySubtags(locale.toString())), [])])    VariableReference(final String scriptSubtag, [])    Expression(ICU.getScript(ICU.addLikelySubtags(locale.toString())), [])  AssignmentExpression(=, [VariableReference(if (scriptSubtag, []), Expression(, [])])    VariableReference(if (scriptSubtag, [])    Expression(, [])  Statement(return getLayoutDirectionFromFirstChar(locale), [])  MethodCall(if (scriptSubtag.equalsIgnoreCase(ARAB_SCRIPT_SUBTAG) || scriptSubtag.equalsIgnoreCase(HEBR_SCRIPT_SUBTAG)), [VariableReference(if (scriptSubtag, []), Expression(ARAB_SCRIPT_SUBTAG) || scriptSubtag.equalsIgnoreCase(HEBR_SCRIPT_SUBTAG), [])])    VariableReference(if (scriptSubtag, [])    Expression(ARAB_SCRIPT_SUBTAG) || scriptSubtag.equalsIgnoreCase(HEBR_SCRIPT_SUBTAG), [])  Statement(return View.LAYOUT_DIRECTION_RTL, [])  Statement(}, [])  Statement(}, [])  Statement(// If forcing into RTL layout mode, return RTL as default, else LTR, [])  MethodCall(return SystemProperties.getBoolean(Settings.Global.DEVELOPMENT_FORCE_RTL, false), [VariableReference(return SystemProperties, []), Expression(Settings.Global.DEVELOPMENT_FORCE_RTL, []), Expression(false, [])])    VariableReference(return SystemProperties, [])    Expression(Settings.Global.DEVELOPMENT_FORCE_RTL, [])    Expression(false, [])  Statement(}, [])",1,"/**
 * Return the layout direction for a given Locale
 *
 * @param locale the Locale for which we want the layout direction. Can be null.
 * @return the layout direction. This may be one of:
 * {@link android.view.View#LAYOUT_DIRECTION_LTR} or
 * {@link android.view.View#LAYOUT_DIRECTION_RTL}.
 *
 * Be careful: this code will need to be updated when vertical scripts will be supported
 */
","/**
 * Return the layout direction for a given Locale
 *
 * @param locale the Locale for which we want the layout direction. Can be null.
 * @return the layout direction. This may be one of:
 * {@link android.view.View#LAYOUT_DIRECTION_LTR} or
 * {@link android.view.View#LAYOUT_DIRECTION_RTL}.
 *
 * Be careful: this code will need to be updated when vertical scripts will be supported
 */
",-1,,,-1,-1,-1,-1,-1,"1,3,4",1,"1,5","1,2","A new condition statement and a return statement have been added to the implementation. The new condition statement checks whether the system property ""DEVELOPMENT\_FORCE\_RTL"" is set to true or not. If it is set to true, then the implementation returns View.LAYOUT\_DIRECTION\_RTL, otherwise, it returns View.LAYOUT\_DIRECTION\_LTR. This change has potentially impacted the return value of the API.","The new condition statement and the return statement added to the implementation can cause a Compatibility Issue (CI). If the system property ""DEVELOPMENT\_FORCE\_RTL"" is set to true, then the implementation will return View.LAYOUT\_DIRECTION\_RTL, even if the input locale is not an RTL (Right-to-Left) language. This behavior is different from the early version of the API, where the return value was determined based on the input locale only. This difference can cause unexpected behavior in the applications that rely on the API's return value to set the layout direction. Therefore, the CI type is 1,2."
234,"<android.hardware.camera2.impl.CameraDeviceImpl: void createConstrainedHighSpeedCaptureSession(List<Surface>,StateCallback,Handler)>",25,26,"<android.hardware.camera2.impl.CameraDeviceImpl: void createConstrainedHighSpeedCaptureSession(List<Surface>,StateCallback,Handler)>","<android.hardware.camera2.impl.CameraDeviceImpl: void createConstrainedHighSpeedCaptureSession(List<Surface>,StateCallback,Handler)>",0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (outputs, []), Expression(, [])]), Statement(throw new IllegalArgumentException(""Output surface list must not be null and the size must be no more than 2""), []), Statement(}, []), AssignmentExpression(=, [VariableReference(StreamConfigurationMap config, []), Expression(getCharacteristics().get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP), [])]), Statement(null, config), []), AssignmentExpression(=, [VariableReference(List<OutputConfiguration> outConfigurations, []), Expression(new ArrayList<>(outputs.size()), [])]), Statement(for (Surface surface : outputs) {, []), MethodCall(outConfigurations.add(new OutputConfiguration(surface)), [VariableReference(outConfigurations, []), Expression(new OutputConfiguration(surface), [])]), Statement(}, []), Statement(createCaptureSessionInternal(null, outConfigurations, callback, handler, /*isConstrainedHighSpeed*/, []), Statement(true), []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (outputs, []), Expression(, [])])    VariableReference(if (outputs, [])    Expression(, [])  Statement(throw new IllegalArgumentException(""Output surface list must not be null and the size must be no more than 2""), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(StreamConfigurationMap config, []), Expression(getCharacteristics().get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP), [])])    VariableReference(StreamConfigurationMap config, [])    Expression(getCharacteristics().get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP), [])  Statement(null, config), [])  AssignmentExpression(=, [VariableReference(List<OutputConfiguration> outConfigurations, []), Expression(new ArrayList<>(outputs.size()), [])])    VariableReference(List<OutputConfiguration> outConfigurations, [])    Expression(new ArrayList<>(outputs.size()), [])  Statement(for (Surface surface : outputs) {, [])  MethodCall(outConfigurations.add(new OutputConfiguration(surface)), [VariableReference(outConfigurations, []), Expression(new OutputConfiguration(surface), [])])    VariableReference(outConfigurations, [])    Expression(new OutputConfiguration(surface), [])  Statement(}, [])  Statement(createCaptureSessionInternal(null, outConfigurations, callback, handler, /*isConstrainedHighSpeed*/, [])  Statement(true), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (outputs, []), Expression(, [])]), Statement(throw new IllegalArgumentException(""Output surface list must not be null and the size must be no more than 2""), []), Statement(}, []), AssignmentExpression(=, [VariableReference(StreamConfigurationMap config, []), Expression(getCharacteristics().get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP), [])]), Statement(null, config), []), AssignmentExpression(=, [VariableReference(List<OutputConfiguration> outConfigurations, []), Expression(new ArrayList<>(outputs.size()), [])]), Statement(for (Surface surface : outputs) {, []), MethodCall(outConfigurations.add(new OutputConfiguration(surface)), [VariableReference(outConfigurations, []), Expression(new OutputConfiguration(surface), [])]), Statement(}, []), Statement(createCaptureSessionInternal(null, outConfigurations, callback, handler, /*operatingMode*/, []), Statement(ICameraDeviceUser.CONSTRAINED_HIGH_SPEED_MODE), []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (outputs, []), Expression(, [])])    VariableReference(if (outputs, [])    Expression(, [])  Statement(throw new IllegalArgumentException(""Output surface list must not be null and the size must be no more than 2""), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(StreamConfigurationMap config, []), Expression(getCharacteristics().get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP), [])])    VariableReference(StreamConfigurationMap config, [])    Expression(getCharacteristics().get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP), [])  Statement(null, config), [])  AssignmentExpression(=, [VariableReference(List<OutputConfiguration> outConfigurations, []), Expression(new ArrayList<>(outputs.size()), [])])    VariableReference(List<OutputConfiguration> outConfigurations, [])    Expression(new ArrayList<>(outputs.size()), [])  Statement(for (Surface surface : outputs) {, [])  MethodCall(outConfigurations.add(new OutputConfiguration(surface)), [VariableReference(outConfigurations, []), Expression(new OutputConfiguration(surface), [])])    VariableReference(outConfigurations, [])    Expression(new OutputConfiguration(surface), [])  Statement(}, [])  Statement(createCaptureSessionInternal(null, outConfigurations, callback, handler, /*operatingMode*/, [])  Statement(ICameraDeviceUser.CONSTRAINED_HIGH_SPEED_MODE), [])  Statement(}, [])",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,4,1,5,1,"The API implementation relies on another API `createCaptureSessionInternal`, and the method call to this dependent API has changed. Specifically, the last argument to `createCaptureSessionInternal` has changed from `/*isConstrainedHighSpeed*/` to `/*operatingMode*/`, and a new argument `ICameraDeviceUser.CONSTRAINED_HIGH_SPEED_MODE` has been added.","The change in the dependent API's method call could potentially cause the API to return a different value, leading to a Compatibility Issue. Specifically, the new argument `ICameraDeviceUser.CONSTRAINED_HIGH_SPEED_MODE` could affect the behavior of `createCaptureSessionInternal` and result in a different capture session being created. This, in turn, could lead to differences in the behavior of the `createConstrainedHighSpeedCaptureSession` API."
695,<android.content.ContentValues: Long getAsLong(String)>,28,29,<android.content.ContentValues: Long getAsLong(String)>,<android.content.ContentValues: Long getAsLong(String)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(Object value, []), Expression(mValues.get(key), [])]), Statement(try {, []), AssignmentExpression(=, [VariableReference(return value !, []), Expression(null ? ((Number) value).longValue() : null, [])]), Statement(} catch (ClassCastException e) {, []), Statement(if (value instanceof CharSequence) {, []), Statement(try {, []), MethodCall(return Long.valueOf(value.toString()), [VariableReference(return Long, []), Expression(value.toString(), [])]), Statement(} catch (NumberFormatException e2) {, []), MethodCall(Log.e(TAG, ""Cannot parse Long value for "" + value + "" at key "" + key), [VariableReference(Log, []), Expression(TAG, []), Expression(""Cannot parse Long value for "" + value + "" at key "" + key, [])]), Statement(return null, []), Statement(}, []), Statement(} else {, []), MethodCall(Log.e(TAG, ""Cannot cast value for "" + key + "" to a Long: "" + value, e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Cannot cast value for "" + key + "" to a Long: "" + value, []), Expression(e, [])]), Statement(return null, []), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(Object value, []), Expression(mValues.get(key), [])])    VariableReference(Object value, [])    Expression(mValues.get(key), [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(return value !, []), Expression(null ? ((Number) value).longValue() : null, [])])    VariableReference(return value !, [])    Expression(null ? ((Number) value).longValue() : null, [])  Statement(} catch (ClassCastException e) {, [])  Statement(if (value instanceof CharSequence) {, [])  Statement(try {, [])  MethodCall(return Long.valueOf(value.toString()), [VariableReference(return Long, []), Expression(value.toString(), [])])    VariableReference(return Long, [])    Expression(value.toString(), [])  Statement(} catch (NumberFormatException e2) {, [])  MethodCall(Log.e(TAG, ""Cannot parse Long value for "" + value + "" at key "" + key), [VariableReference(Log, []), Expression(TAG, []), Expression(""Cannot parse Long value for "" + value + "" at key "" + key, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Cannot parse Long value for "" + value + "" at key "" + key, [])  Statement(return null, [])  Statement(}, [])  Statement(} else {, [])  MethodCall(Log.e(TAG, ""Cannot cast value for "" + key + "" to a Long: "" + value, e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Cannot cast value for "" + key + "" to a Long: "" + value, []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Cannot cast value for "" + key + "" to a Long: "" + value, [])    Expression(e, [])  Statement(return null, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(Object value, []), Expression(mMap.get(key), [])]), Statement(try {, []), AssignmentExpression(=, [VariableReference(return value !, []), Expression(null ? ((Number) value).longValue() : null, [])]), Statement(} catch (ClassCastException e) {, []), Statement(if (value instanceof CharSequence) {, []), Statement(try {, []), MethodCall(return Long.valueOf(value.toString()), [VariableReference(return Long, []), Expression(value.toString(), [])]), Statement(} catch (NumberFormatException e2) {, []), MethodCall(Log.e(TAG, ""Cannot parse Long value for "" + value + "" at key "" + key), [VariableReference(Log, []), Expression(TAG, []), Expression(""Cannot parse Long value for "" + value + "" at key "" + key, [])]), Statement(return null, []), Statement(}, []), Statement(} else {, []), MethodCall(Log.e(TAG, ""Cannot cast value for "" + key + "" to a Long: "" + value, e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Cannot cast value for "" + key + "" to a Long: "" + value, []), Expression(e, [])]), Statement(return null, []), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(Object value, []), Expression(mMap.get(key), [])])    VariableReference(Object value, [])    Expression(mMap.get(key), [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(return value !, []), Expression(null ? ((Number) value).longValue() : null, [])])    VariableReference(return value !, [])    Expression(null ? ((Number) value).longValue() : null, [])  Statement(} catch (ClassCastException e) {, [])  Statement(if (value instanceof CharSequence) {, [])  Statement(try {, [])  MethodCall(return Long.valueOf(value.toString()), [VariableReference(return Long, []), Expression(value.toString(), [])])    VariableReference(return Long, [])    Expression(value.toString(), [])  Statement(} catch (NumberFormatException e2) {, [])  MethodCall(Log.e(TAG, ""Cannot parse Long value for "" + value + "" at key "" + key), [VariableReference(Log, []), Expression(TAG, []), Expression(""Cannot parse Long value for "" + value + "" at key "" + key, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Cannot parse Long value for "" + value + "" at key "" + key, [])  Statement(return null, [])  Statement(}, [])  Statement(} else {, [])  MethodCall(Log.e(TAG, ""Cannot cast value for "" + key + "" to a Long: "" + value, e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Cannot cast value for "" + key + "" to a Long: "" + value, []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Cannot cast value for "" + key + "" to a Long: "" + value, [])    Expression(e, [])  Statement(return null, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Gets a value and converts it to a Long.
 *
 * @param key the value to get
 * @return the Long value, or {@code null} if the value is missing or cannot be converted
 */
","/**
 * Gets a value and converts it to a Long.
 *
 * @param key the value to get
 * @return the Long value, or {@code null} if the value is missing or cannot be converted
 */
",-1,,,-1,-1,-1,-1,-1,4,0,5,1,"The only change between the two versions is that the variable `mValues` has been replaced with `mMap`. This is an example of a dependent API change, as the `get` method is being called on a different object.","The Compatibility Issue arises because the `get` method may return different results depending on the implementation of `mValues` and `mMap`. If the two objects have different keys or values, then the `getAsLong` method may return different results in the two versions. This is an example of a Compatibility Issue caused by potential different return values or types."
863,<android.widget.RemoteViews.AsyncApplyTask: ViewTree doInBackground(Void)>,30,31,<android.widget.RemoteViews.AsyncApplyTask: ViewTree doInBackground(Void)>,<android.widget.RemoteViews.AsyncApplyTask: ViewTree doInBackground(Void)>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), AssignmentExpression(=, [VariableReference(if (mResult, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(mResult, []), Expression(inflateView(mContext, mRV, mParent), [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(mTree, []), Expression(new ViewTree(mResult), [])]), AssignmentExpression(=, [VariableReference(if (mRV.mActions !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(int count, []), Expression(mRV.mActions.size(), [])]), AssignmentExpression(=, [VariableReference(mActions, []), Expression(new Action[count], [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < count && !isCancelled(), []), Statement(i++) {, []), Statement(// TODO: check if isCancelled in nested views., []), AssignmentExpression(=, [VariableReference(mActions[i], []), Expression(mRV.mActions.get(i).initActionAsync(mTree, mParent, mHandler), [])]), Statement(}, []), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mActions, []), Expression(null, [])]), Statement(}, []), Statement(return mTree, []), Statement(} catch (Exception e) {, []), AssignmentExpression(=, [VariableReference(mError, []), Expression(e, [])]), Statement(return null, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(if (mResult, []), Expression(, [])])    VariableReference(if (mResult, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(mResult, []), Expression(inflateView(mContext, mRV, mParent), [])])    VariableReference(mResult, [])    Expression(inflateView(mContext, mRV, mParent), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mTree, []), Expression(new ViewTree(mResult), [])])    VariableReference(mTree, [])    Expression(new ViewTree(mResult), [])  AssignmentExpression(=, [VariableReference(if (mRV.mActions !, []), Expression(null) {, [])])    VariableReference(if (mRV.mActions !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(int count, []), Expression(mRV.mActions.size(), [])])    VariableReference(int count, [])    Expression(mRV.mActions.size(), [])  AssignmentExpression(=, [VariableReference(mActions, []), Expression(new Action[count], [])])    VariableReference(mActions, [])    Expression(new Action[count], [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < count && !isCancelled(), [])  Statement(i++) {, [])  Statement(// TODO: check if isCancelled in nested views., [])  AssignmentExpression(=, [VariableReference(mActions[i], []), Expression(mRV.mActions.get(i).initActionAsync(mTree, mParent, mHandler), [])])    VariableReference(mActions[i], [])    Expression(mRV.mActions.get(i).initActionAsync(mTree, mParent, mHandler), [])  Statement(}, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mActions, []), Expression(null, [])])    VariableReference(mActions, [])    Expression(null, [])  Statement(}, [])  Statement(return mTree, [])  Statement(} catch (Exception e) {, [])  AssignmentExpression(=, [VariableReference(mError, []), Expression(e, [])])    VariableReference(mError, [])    Expression(e, [])  Statement(return null, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), AssignmentExpression(=, [VariableReference(if (mResult, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(mResult, []), Expression(inflateView(mContext, mRV, mParent, 0, mColorResources), [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(mTree, []), Expression(new ViewTree(mResult), [])]), AssignmentExpression(=, [VariableReference(if (mRV.mActions !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(int count, []), Expression(mRV.mActions.size(), [])]), AssignmentExpression(=, [VariableReference(mActions, []), Expression(new Action[count], [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < count && !isCancelled(), []), Statement(i++) {, []), Statement(// TODO: check if isCancelled in nested views., []), AssignmentExpression(=, [VariableReference(mActions[i], []), Expression(mRV.mActions.get(i).initActionAsync(mTree, mParent, mHandler, mColorResources), [])]), Statement(}, []), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mActions, []), Expression(null, [])]), Statement(}, []), Statement(return mTree, []), Statement(} catch (Exception e) {, []), AssignmentExpression(=, [VariableReference(mError, []), Expression(e, [])]), Statement(return null, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(if (mResult, []), Expression(, [])])    VariableReference(if (mResult, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(mResult, []), Expression(inflateView(mContext, mRV, mParent, 0, mColorResources), [])])    VariableReference(mResult, [])    Expression(inflateView(mContext, mRV, mParent, 0, mColorResources), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mTree, []), Expression(new ViewTree(mResult), [])])    VariableReference(mTree, [])    Expression(new ViewTree(mResult), [])  AssignmentExpression(=, [VariableReference(if (mRV.mActions !, []), Expression(null) {, [])])    VariableReference(if (mRV.mActions !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(int count, []), Expression(mRV.mActions.size(), [])])    VariableReference(int count, [])    Expression(mRV.mActions.size(), [])  AssignmentExpression(=, [VariableReference(mActions, []), Expression(new Action[count], [])])    VariableReference(mActions, [])    Expression(new Action[count], [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < count && !isCancelled(), [])  Statement(i++) {, [])  Statement(// TODO: check if isCancelled in nested views., [])  AssignmentExpression(=, [VariableReference(mActions[i], []), Expression(mRV.mActions.get(i).initActionAsync(mTree, mParent, mHandler, mColorResources), [])])    VariableReference(mActions[i], [])    Expression(mRV.mActions.get(i).initActionAsync(mTree, mParent, mHandler, mColorResources), [])  Statement(}, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mActions, []), Expression(null, [])])    VariableReference(mActions, [])    Expression(null, [])  Statement(}, [])  Statement(return mTree, [])  Statement(} catch (Exception e) {, [])  AssignmentExpression(=, [VariableReference(mError, []), Expression(e, [])])    VariableReference(mError, [])    Expression(e, [])  Statement(return null, [])  Statement(}, [])  Statement(}, [])",1,,,-1,[@Override],"[@Nullable, @Override]",-1,-1,-1,-1,-1,5,0,"1,5","1,2","The implementation of the method has been changed in two ways. Firstly, the method `inflateView` called in the assignment expression of `mResult` has an additional parameter `mColorResources` in the late version. This indicates that the method `inflateView` has undergone changes, which is classified as change type 5. Secondly, the method `initActionAsync` called in the assignment expression of `mActions[i]` also has an additional parameter `mColorResources` in the late version. This means that the behavior of the method `initActionAsync` may be different in the late version, which may lead to different values of `mActions[i]` and thus the returned `mTree`. This is classified as change type 1. Moreover, the additional parameter `mColorResources` may also cause the method `initActionAsync` to throw exceptions differently, which is classified as change type 2.","The Compatibility Issues (CI) exist in this case. The additional parameter `mColorResources` in the methods `inflateView` and `initActionAsync` may lead to different behaviors of these methods, which may further lead to different values of `mResult`, `mActions[i]` and thus the returned `mTree`. This is classified as CI type 1. Moreover, the additional parameter `mColorResources` may also cause the method `initActionAsync` to throw exceptions differently, which may cause the method `doInBackground` to return `null` in the late version but not in the early version. This is classified as CI type 2."
117,<android.hardware.camera2.impl.CameraDeviceImpl: void createExtensionSession(ExtensionSessionConfiguration)>,32,33,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(if (CameraExtensionCharacteristics.areAdvancedExtensionsSupported()), [VariableReference(if (CameraExtensionCharacteristics, []), Expression(), [])]), AssignmentExpression(=, [VariableReference(mCurrentAdvancedExtensionSession, []), Expression(CameraAdvancedExtensionSessionImpl.createCameraAdvancedExtensionSession(this, mContext, extensionConfiguration), [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mCurrentExtensionSession, []), Expression(CameraExtensionSessionImpl.createCameraExtensionSession(this, mContext, extensionConfiguration), [])]), Statement(}, []), Statement(} catch (RemoteException e) {, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(if (CameraExtensionCharacteristics.areAdvancedExtensionsSupported()), [VariableReference(if (CameraExtensionCharacteristics, []), Expression(), [])])    VariableReference(if (CameraExtensionCharacteristics, [])    Expression(), [])  AssignmentExpression(=, [VariableReference(mCurrentAdvancedExtensionSession, []), Expression(CameraAdvancedExtensionSessionImpl.createCameraAdvancedExtensionSession(this, mContext, extensionConfiguration), [])])    VariableReference(mCurrentAdvancedExtensionSession, [])    Expression(CameraAdvancedExtensionSessionImpl.createCameraAdvancedExtensionSession(this, mContext, extensionConfiguration), [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mCurrentExtensionSession, []), Expression(CameraExtensionSessionImpl.createCameraExtensionSession(this, mContext, extensionConfiguration), [])])    VariableReference(mCurrentExtensionSession, [])    Expression(CameraExtensionSessionImpl.createCameraExtensionSession(this, mContext, extensionConfiguration), [])  Statement(}, [])  Statement(} catch (RemoteException e) {, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(if (CameraExtensionCharacteristics.areAdvancedExtensionsSupported()), [VariableReference(if (CameraExtensionCharacteristics, []), Expression(), [])]), AssignmentExpression(=, [VariableReference(mCurrentAdvancedExtensionSession, []), Expression(CameraAdvancedExtensionSessionImpl.createCameraAdvancedExtensionSession(this, mContext, extensionConfiguration, mNextSessionId++), [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mCurrentExtensionSession, []), Expression(CameraExtensionSessionImpl.createCameraExtensionSession(this, mContext, extensionConfiguration, mNextSessionId++), [])]), Statement(}, []), Statement(} catch (RemoteException e) {, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(if (CameraExtensionCharacteristics.areAdvancedExtensionsSupported()), [VariableReference(if (CameraExtensionCharacteristics, []), Expression(), [])])    VariableReference(if (CameraExtensionCharacteristics, [])    Expression(), [])  AssignmentExpression(=, [VariableReference(mCurrentAdvancedExtensionSession, []), Expression(CameraAdvancedExtensionSessionImpl.createCameraAdvancedExtensionSession(this, mContext, extensionConfiguration, mNextSessionId++), [])])    VariableReference(mCurrentAdvancedExtensionSession, [])    Expression(CameraAdvancedExtensionSessionImpl.createCameraAdvancedExtensionSession(this, mContext, extensionConfiguration, mNextSessionId++), [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mCurrentExtensionSession, []), Expression(CameraExtensionSessionImpl.createCameraExtensionSession(this, mContext, extensionConfiguration, mNextSessionId++), [])])    VariableReference(mCurrentExtensionSession, [])    Expression(CameraExtensionSessionImpl.createCameraExtensionSession(this, mContext, extensionConfiguration, mNextSessionId++), [])  Statement(}, [])  Statement(} catch (RemoteException e) {, [])  Statement(}, [])  Statement(}, [])",1,,,0,[@Override],[@Override],0,,,,,5,0,5,1,"The late implementation has added an additional argument `mNextSessionId++` to the method calls `CameraAdvancedExtensionSessionImpl.createCameraAdvancedExtensionSession()` and `CameraExtensionSessionImpl.createCameraExtensionSession()`. This means that the behavior of these methods may have changed, and the new argument may affect the values that are returned.","The Compatibility Issue (CI) in this case is that the added argument `mNextSessionId++` may cause the methods `CameraAdvancedExtensionSessionImpl.createCameraAdvancedExtensionSession()` and `CameraExtensionSessionImpl.createCameraExtensionSession()` to return different values in the late version compared to the early version. This could potentially break any code that relies on the specific values that these methods return. Therefore, the CI type is 1 - Compatibility Issue caused by potential different return values or types."
9,<android.webkit.WebView: void onDraw(Canvas)>,6,7,<android.webkit.WebView: void onDraw(Canvas)>,<android.webkit.WebView: void onDraw(Canvas)>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(// if mNativeClass is 0, the WebView has been destroyed. Do nothing., []), AssignmentExpression(=, [VariableReference(if (mNativeClass, []), Expression(, [])]), Statement(return, []), Statement(}, []), AssignmentExpression(=, [VariableReference(int saveCount, []), Expression(canvas.save(), [])]), AssignmentExpression(=, [VariableReference(if (mTitleBar !, []), Expression(null) {, [])]), MethodCall(canvas.translate(0, (int) mTitleBar.getHeight()), [VariableReference(canvas, []), Expression(0, []), Expression((int) mTitleBar.getHeight(), [])]), Statement(}, []), Statement(// Update the buttons in the picture, so when we draw the picture, []), Statement(// to the screen, they are in the correct state., []), Statement(// Tell the native side if user is a) touching the screen,, []), Statement(// b) pressing the trackball down, or c) pressing the enter key, []), Statement(// If the cursor is on a button, we need to draw it in the pressed, []), Statement(// state., []), Statement(// If mNativeClass is 0, we should not reach here, so we do not, []), Statement(// need to check it again., []), AssignmentExpression(=, [VariableReference(nativeRecordButtons(hasFocus() && hasWindowFocus(), mTouchMode, []), Expression(, [])]), Statement(drawCoreAndCursorRing(canvas, mBackgroundColor, mDrawCursorRing), []), MethodCall(canvas.restoreToCount(saveCount), [VariableReference(canvas, []), Expression(saveCount, [])]), Statement(// Now draw the shadow., []), AssignmentExpression(=, [VariableReference(if (mTitleBar !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(int y, []), Expression(mScrollY + getVisibleTitleHeight(), [])]), AssignmentExpression(=, [VariableReference(int height, []), Expression((int) (5f * getContext().getResources().getDisplayMetrics().density), [])]), MethodCall(mTitleShadow.setBounds(mScrollX, y, mScrollX + getWidth(), y + height), [VariableReference(mTitleShadow, []), Expression(mScrollX, []), Expression(y, []), Expression(mScrollX + getWidth(), []), Expression(y + height, [])]), MethodCall(mTitleShadow.draw(canvas), [VariableReference(mTitleShadow, []), Expression(canvas, [])]), Statement(}, []), Statement(if (AUTO_REDRAW_HACK && mAutoRedraw) {, []), Statement(invalidate(), []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(// if mNativeClass is 0, the WebView has been destroyed. Do nothing., [])  AssignmentExpression(=, [VariableReference(if (mNativeClass, []), Expression(, [])])    VariableReference(if (mNativeClass, [])    Expression(, [])  Statement(return, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(int saveCount, []), Expression(canvas.save(), [])])    VariableReference(int saveCount, [])    Expression(canvas.save(), [])  AssignmentExpression(=, [VariableReference(if (mTitleBar !, []), Expression(null) {, [])])    VariableReference(if (mTitleBar !, [])    Expression(null) {, [])  MethodCall(canvas.translate(0, (int) mTitleBar.getHeight()), [VariableReference(canvas, []), Expression(0, []), Expression((int) mTitleBar.getHeight(), [])])    VariableReference(canvas, [])    Expression(0, [])    Expression((int) mTitleBar.getHeight(), [])  Statement(}, [])  Statement(// Update the buttons in the picture, so when we draw the picture, [])  Statement(// to the screen, they are in the correct state., [])  Statement(// Tell the native side if user is a) touching the screen,, [])  Statement(// b) pressing the trackball down, or c) pressing the enter key, [])  Statement(// If the cursor is on a button, we need to draw it in the pressed, [])  Statement(// state., [])  Statement(// If mNativeClass is 0, we should not reach here, so we do not, [])  Statement(// need to check it again., [])  AssignmentExpression(=, [VariableReference(nativeRecordButtons(hasFocus() && hasWindowFocus(), mTouchMode, []), Expression(, [])])    VariableReference(nativeRecordButtons(hasFocus() && hasWindowFocus(), mTouchMode, [])    Expression(, [])  Statement(drawCoreAndCursorRing(canvas, mBackgroundColor, mDrawCursorRing), [])  MethodCall(canvas.restoreToCount(saveCount), [VariableReference(canvas, []), Expression(saveCount, [])])    VariableReference(canvas, [])    Expression(saveCount, [])  Statement(// Now draw the shadow., [])  AssignmentExpression(=, [VariableReference(if (mTitleBar !, []), Expression(null) {, [])])    VariableReference(if (mTitleBar !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(int y, []), Expression(mScrollY + getVisibleTitleHeight(), [])])    VariableReference(int y, [])    Expression(mScrollY + getVisibleTitleHeight(), [])  AssignmentExpression(=, [VariableReference(int height, []), Expression((int) (5f * getContext().getResources().getDisplayMetrics().density), [])])    VariableReference(int height, [])    Expression((int) (5f * getContext().getResources().getDisplayMetrics().density), [])  MethodCall(mTitleShadow.setBounds(mScrollX, y, mScrollX + getWidth(), y + height), [VariableReference(mTitleShadow, []), Expression(mScrollX, []), Expression(y, []), Expression(mScrollX + getWidth(), []), Expression(y + height, [])])    VariableReference(mTitleShadow, [])    Expression(mScrollX, [])    Expression(y, [])    Expression(mScrollX + getWidth(), [])    Expression(y + height, [])  MethodCall(mTitleShadow.draw(canvas), [VariableReference(mTitleShadow, []), Expression(canvas, [])])    VariableReference(mTitleShadow, [])    Expression(canvas, [])  Statement(}, [])  Statement(if (AUTO_REDRAW_HACK && mAutoRedraw) {, [])  Statement(invalidate(), [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(// if mNativeClass is 0, the WebView has been destroyed. Do nothing., []), AssignmentExpression(=, [VariableReference(if (mNativeClass, []), Expression(, [])]), Statement(return, []), Statement(}, []), AssignmentExpression(=, [VariableReference(int saveCount, []), Expression(canvas.save(), [])]), AssignmentExpression(=, [VariableReference(if (mTitleBar !, []), Expression(null) {, [])]), MethodCall(canvas.translate(0, (int) mTitleBar.getHeight()), [VariableReference(canvas, []), Expression(0, []), Expression((int) mTitleBar.getHeight(), [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mDragTrackerHandler, []), Expression(, [])]), Statement(drawContent(canvas), []), Statement(}, []), MethodCall(canvas.restoreToCount(saveCount), [VariableReference(canvas, []), Expression(saveCount, [])]), Statement(// Now draw the shadow., []), AssignmentExpression(=, [VariableReference(if (mTitleBar !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(int y, []), Expression(mScrollY + getVisibleTitleHeight(), [])]), AssignmentExpression(=, [VariableReference(int height, []), Expression((int) (5f * getContext().getResources().getDisplayMetrics().density), [])]), MethodCall(mTitleShadow.setBounds(mScrollX, y, mScrollX + getWidth(), y + height), [VariableReference(mTitleShadow, []), Expression(mScrollX, []), Expression(y, []), Expression(mScrollX + getWidth(), []), Expression(y + height, [])]), MethodCall(mTitleShadow.draw(canvas), [VariableReference(mTitleShadow, []), Expression(canvas, [])]), Statement(}, []), Statement(if (AUTO_REDRAW_HACK && mAutoRedraw) {, []), Statement(invalidate(), []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(// if mNativeClass is 0, the WebView has been destroyed. Do nothing., [])  AssignmentExpression(=, [VariableReference(if (mNativeClass, []), Expression(, [])])    VariableReference(if (mNativeClass, [])    Expression(, [])  Statement(return, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(int saveCount, []), Expression(canvas.save(), [])])    VariableReference(int saveCount, [])    Expression(canvas.save(), [])  AssignmentExpression(=, [VariableReference(if (mTitleBar !, []), Expression(null) {, [])])    VariableReference(if (mTitleBar !, [])    Expression(null) {, [])  MethodCall(canvas.translate(0, (int) mTitleBar.getHeight()), [VariableReference(canvas, []), Expression(0, []), Expression((int) mTitleBar.getHeight(), [])])    VariableReference(canvas, [])    Expression(0, [])    Expression((int) mTitleBar.getHeight(), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mDragTrackerHandler, []), Expression(, [])])    VariableReference(if (mDragTrackerHandler, [])    Expression(, [])  Statement(drawContent(canvas), [])  Statement(}, [])  MethodCall(canvas.restoreToCount(saveCount), [VariableReference(canvas, []), Expression(saveCount, [])])    VariableReference(canvas, [])    Expression(saveCount, [])  Statement(// Now draw the shadow., [])  AssignmentExpression(=, [VariableReference(if (mTitleBar !, []), Expression(null) {, [])])    VariableReference(if (mTitleBar !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(int y, []), Expression(mScrollY + getVisibleTitleHeight(), [])])    VariableReference(int y, [])    Expression(mScrollY + getVisibleTitleHeight(), [])  AssignmentExpression(=, [VariableReference(int height, []), Expression((int) (5f * getContext().getResources().getDisplayMetrics().density), [])])    VariableReference(int height, [])    Expression((int) (5f * getContext().getResources().getDisplayMetrics().density), [])  MethodCall(mTitleShadow.setBounds(mScrollX, y, mScrollX + getWidth(), y + height), [VariableReference(mTitleShadow, []), Expression(mScrollX, []), Expression(y, []), Expression(mScrollX + getWidth(), []), Expression(y + height, [])])    VariableReference(mTitleShadow, [])    Expression(mScrollX, [])    Expression(y, [])    Expression(mScrollX + getWidth(), [])    Expression(y + height, [])  MethodCall(mTitleShadow.draw(canvas), [VariableReference(mTitleShadow, []), Expression(canvas, [])])    VariableReference(mTitleShadow, [])    Expression(canvas, [])  Statement(}, [])  Statement(if (AUTO_REDRAW_HACK && mAutoRedraw) {, [])  Statement(invalidate(), [])  Statement(}, [])  Statement(}, [])",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,"3,4",0,3,1,"The method body has been changed. Specifically, the statements ""drawCoreAndCursorRing(canvas, mBackgroundColor, mDrawCursorRing)"" and the following comment ""// Now draw the shadow."" have been replaced with a new statement ""drawContent(canvas)"".","The change in the method body could potentially lead to different behavior in the late version. Specifically, the new statement ""drawContent(canvas)"" might not draw the shadow as it was done in the early version. This could lead to a compatibility issue if the application relies on the shadow being drawn."
583,<android.app.ActivityThread.PackageInfo: ClassLoader getClassLoader()>,7,8,<android.app.ActivityThread.PackageInfo: ClassLoader getClassLoader()>,<android.app.ActivityThread.PackageInfo: ClassLoader getClassLoader()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(synchronized (this) {, []), AssignmentExpression(=, [VariableReference(if (mClassLoader !, []), Expression(null) {, [])]), Statement(return mClassLoader, []), Statement(}, []), MethodCall(if (mIncludeCode && !mPackageName.equals(""android"")), [VariableReference(if (mIncludeCode && !mPackageName, []), Expression(""android""), [])]), AssignmentExpression(=, [VariableReference(String zip, []), Expression(mAppDir, [])]), Statement(/*, []), Statement(* The following is a bit of a hack to inject, []), Statement(* instrumentation into the system: If the app, []), Statement(* being started matches one of the instrumentation names,, []), Statement(* then we combine both the ""instrumentation"" and, []), Statement(* ""instrumented"" app into the path, along with the, []), Statement(* concatenation of both apps' shared library lists., []), Statement(*/, []), AssignmentExpression(=, [VariableReference(String instrumentationAppDir, []), Expression(mActivityThread.mInstrumentationAppDir, [])]), AssignmentExpression(=, [VariableReference(String instrumentationAppPackage, []), Expression(mActivityThread.mInstrumentationAppPackage, [])]), AssignmentExpression(=, [VariableReference(String instrumentedAppDir, []), Expression(mActivityThread.mInstrumentedAppDir, [])]), AssignmentExpression(=, [VariableReference(String[] instrumentationLibs, []), Expression(null, [])]), MethodCall(if (mAppDir.equals(instrumentationAppDir) || mAppDir.equals(instrumentedAppDir)), [VariableReference(if (mAppDir, []), Expression(instrumentationAppDir) || mAppDir.equals(instrumentedAppDir), [])]), AssignmentExpression(=, [VariableReference(zip, []), Expression(instrumentationAppDir + "":"" + instrumentedAppDir, [])]), MethodCall(if (!instrumentedAppDir.equals(instrumentationAppDir)), [VariableReference(if (!instrumentedAppDir, []), Expression(instrumentationAppDir), [])]), AssignmentExpression(=, [VariableReference(instrumentationLibs, []), Expression(getLibrariesFor(instrumentationAppPackage), [])]), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if ((mSharedLibraries !, []), Expression(null) || (instrumentationLibs !, [])]), AssignmentExpression(=, [VariableReference(zip, []), Expression(combineLibs(mSharedLibraries, instrumentationLibs) + ':' + zip, [])]), Statement(}, []), Statement(if (localLOGV), []), MethodCall(Log.v(TAG, ""Class path: "" + zip), [VariableReference(Log, []), Expression(TAG, []), Expression(""Class path: "" + zip, [])]), AssignmentExpression(=, [VariableReference(mClassLoader, []), Expression(ApplicationLoaders.getDefault().getClassLoader(zip, mDataDir, mBaseClassLoader), [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(if (mBaseClassLoader, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(mClassLoader, []), Expression(ClassLoader.getSystemClassLoader(), [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mClassLoader, []), Expression(mBaseClassLoader, [])]), Statement(}, []), Statement(}, []), Statement(return mClassLoader, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(synchronized (this) {, [])  AssignmentExpression(=, [VariableReference(if (mClassLoader !, []), Expression(null) {, [])])    VariableReference(if (mClassLoader !, [])    Expression(null) {, [])  Statement(return mClassLoader, [])  Statement(}, [])  MethodCall(if (mIncludeCode && !mPackageName.equals(""android"")), [VariableReference(if (mIncludeCode && !mPackageName, []), Expression(""android""), [])])    VariableReference(if (mIncludeCode && !mPackageName, [])    Expression(""android""), [])  AssignmentExpression(=, [VariableReference(String zip, []), Expression(mAppDir, [])])    VariableReference(String zip, [])    Expression(mAppDir, [])  Statement(/*, [])  Statement(* The following is a bit of a hack to inject, [])  Statement(* instrumentation into the system: If the app, [])  Statement(* being started matches one of the instrumentation names,, [])  Statement(* then we combine both the ""instrumentation"" and, [])  Statement(* ""instrumented"" app into the path, along with the, [])  Statement(* concatenation of both apps' shared library lists., [])  Statement(*/, [])  AssignmentExpression(=, [VariableReference(String instrumentationAppDir, []), Expression(mActivityThread.mInstrumentationAppDir, [])])    VariableReference(String instrumentationAppDir, [])    Expression(mActivityThread.mInstrumentationAppDir, [])  AssignmentExpression(=, [VariableReference(String instrumentationAppPackage, []), Expression(mActivityThread.mInstrumentationAppPackage, [])])    VariableReference(String instrumentationAppPackage, [])    Expression(mActivityThread.mInstrumentationAppPackage, [])  AssignmentExpression(=, [VariableReference(String instrumentedAppDir, []), Expression(mActivityThread.mInstrumentedAppDir, [])])    VariableReference(String instrumentedAppDir, [])    Expression(mActivityThread.mInstrumentedAppDir, [])  AssignmentExpression(=, [VariableReference(String[] instrumentationLibs, []), Expression(null, [])])    VariableReference(String[] instrumentationLibs, [])    Expression(null, [])  MethodCall(if (mAppDir.equals(instrumentationAppDir) || mAppDir.equals(instrumentedAppDir)), [VariableReference(if (mAppDir, []), Expression(instrumentationAppDir) || mAppDir.equals(instrumentedAppDir), [])])    VariableReference(if (mAppDir, [])    Expression(instrumentationAppDir) || mAppDir.equals(instrumentedAppDir), [])  AssignmentExpression(=, [VariableReference(zip, []), Expression(instrumentationAppDir + "":"" + instrumentedAppDir, [])])    VariableReference(zip, [])    Expression(instrumentationAppDir + "":"" + instrumentedAppDir, [])  MethodCall(if (!instrumentedAppDir.equals(instrumentationAppDir)), [VariableReference(if (!instrumentedAppDir, []), Expression(instrumentationAppDir), [])])    VariableReference(if (!instrumentedAppDir, [])    Expression(instrumentationAppDir), [])  AssignmentExpression(=, [VariableReference(instrumentationLibs, []), Expression(getLibrariesFor(instrumentationAppPackage), [])])    VariableReference(instrumentationLibs, [])    Expression(getLibrariesFor(instrumentationAppPackage), [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if ((mSharedLibraries !, []), Expression(null) || (instrumentationLibs !, [])])    VariableReference(if ((mSharedLibraries !, [])    Expression(null) || (instrumentationLibs !, [])  AssignmentExpression(=, [VariableReference(zip, []), Expression(combineLibs(mSharedLibraries, instrumentationLibs) + ':' + zip, [])])    VariableReference(zip, [])    Expression(combineLibs(mSharedLibraries, instrumentationLibs) + ':' + zip, [])  Statement(}, [])  Statement(if (localLOGV), [])  MethodCall(Log.v(TAG, ""Class path: "" + zip), [VariableReference(Log, []), Expression(TAG, []), Expression(""Class path: "" + zip, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Class path: "" + zip, [])  AssignmentExpression(=, [VariableReference(mClassLoader, []), Expression(ApplicationLoaders.getDefault().getClassLoader(zip, mDataDir, mBaseClassLoader), [])])    VariableReference(mClassLoader, [])    Expression(ApplicationLoaders.getDefault().getClassLoader(zip, mDataDir, mBaseClassLoader), [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(if (mBaseClassLoader, []), Expression(, [])])    VariableReference(if (mBaseClassLoader, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(mClassLoader, []), Expression(ClassLoader.getSystemClassLoader(), [])])    VariableReference(mClassLoader, [])    Expression(ClassLoader.getSystemClassLoader(), [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mClassLoader, []), Expression(mBaseClassLoader, [])])    VariableReference(mClassLoader, [])    Expression(mBaseClassLoader, [])  Statement(}, [])  Statement(}, [])  Statement(return mClassLoader, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(synchronized (this) {, []), AssignmentExpression(=, [VariableReference(if (mClassLoader !, []), Expression(null) {, [])]), Statement(return mClassLoader, []), Statement(}, []), MethodCall(if (mIncludeCode && !mPackageName.equals(""android"")), [VariableReference(if (mIncludeCode && !mPackageName, []), Expression(""android""), [])]), AssignmentExpression(=, [VariableReference(String zip, []), Expression(mAppDir, [])]), Statement(/*, []), Statement(* The following is a bit of a hack to inject, []), Statement(* instrumentation into the system: If the app, []), Statement(* being started matches one of the instrumentation names,, []), Statement(* then we combine both the ""instrumentation"" and, []), Statement(* ""instrumented"" app into the path, along with the, []), Statement(* concatenation of both apps' shared library lists., []), Statement(*/, []), AssignmentExpression(=, [VariableReference(String instrumentationAppDir, []), Expression(mActivityThread.mInstrumentationAppDir, [])]), AssignmentExpression(=, [VariableReference(String instrumentationAppPackage, []), Expression(mActivityThread.mInstrumentationAppPackage, [])]), AssignmentExpression(=, [VariableReference(String instrumentedAppDir, []), Expression(mActivityThread.mInstrumentedAppDir, [])]), AssignmentExpression(=, [VariableReference(String[] instrumentationLibs, []), Expression(null, [])]), MethodCall(if (mAppDir.equals(instrumentationAppDir) || mAppDir.equals(instrumentedAppDir)), [VariableReference(if (mAppDir, []), Expression(instrumentationAppDir) || mAppDir.equals(instrumentedAppDir), [])]), AssignmentExpression(=, [VariableReference(zip, []), Expression(instrumentationAppDir + "":"" + instrumentedAppDir, [])]), MethodCall(if (!instrumentedAppDir.equals(instrumentationAppDir)), [VariableReference(if (!instrumentedAppDir, []), Expression(instrumentationAppDir), [])]), AssignmentExpression(=, [VariableReference(instrumentationLibs, []), Expression(getLibrariesFor(instrumentationAppPackage), [])]), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if ((mSharedLibraries !, []), Expression(null) || (instrumentationLibs !, [])]), AssignmentExpression(=, [VariableReference(zip, []), Expression(combineLibs(mSharedLibraries, instrumentationLibs) + ':' + zip, [])]), Statement(}, []), Statement(if (localLOGV), []), MethodCall(Slog.v(TAG, ""Class path: "" + zip), [VariableReference(Slog, []), Expression(TAG, []), Expression(""Class path: "" + zip, [])]), AssignmentExpression(=, [VariableReference(mClassLoader, []), Expression(ApplicationLoaders.getDefault().getClassLoader(zip, mDataDir, mBaseClassLoader), [])]), Statement(initializeJavaContextClassLoader(), []), Statement(} else {, []), AssignmentExpression(=, [VariableReference(if (mBaseClassLoader, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(mClassLoader, []), Expression(ClassLoader.getSystemClassLoader(), [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mClassLoader, []), Expression(mBaseClassLoader, [])]), Statement(}, []), Statement(}, []), Statement(return mClassLoader, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(synchronized (this) {, [])  AssignmentExpression(=, [VariableReference(if (mClassLoader !, []), Expression(null) {, [])])    VariableReference(if (mClassLoader !, [])    Expression(null) {, [])  Statement(return mClassLoader, [])  Statement(}, [])  MethodCall(if (mIncludeCode && !mPackageName.equals(""android"")), [VariableReference(if (mIncludeCode && !mPackageName, []), Expression(""android""), [])])    VariableReference(if (mIncludeCode && !mPackageName, [])    Expression(""android""), [])  AssignmentExpression(=, [VariableReference(String zip, []), Expression(mAppDir, [])])    VariableReference(String zip, [])    Expression(mAppDir, [])  Statement(/*, [])  Statement(* The following is a bit of a hack to inject, [])  Statement(* instrumentation into the system: If the app, [])  Statement(* being started matches one of the instrumentation names,, [])  Statement(* then we combine both the ""instrumentation"" and, [])  Statement(* ""instrumented"" app into the path, along with the, [])  Statement(* concatenation of both apps' shared library lists., [])  Statement(*/, [])  AssignmentExpression(=, [VariableReference(String instrumentationAppDir, []), Expression(mActivityThread.mInstrumentationAppDir, [])])    VariableReference(String instrumentationAppDir, [])    Expression(mActivityThread.mInstrumentationAppDir, [])  AssignmentExpression(=, [VariableReference(String instrumentationAppPackage, []), Expression(mActivityThread.mInstrumentationAppPackage, [])])    VariableReference(String instrumentationAppPackage, [])    Expression(mActivityThread.mInstrumentationAppPackage, [])  AssignmentExpression(=, [VariableReference(String instrumentedAppDir, []), Expression(mActivityThread.mInstrumentedAppDir, [])])    VariableReference(String instrumentedAppDir, [])    Expression(mActivityThread.mInstrumentedAppDir, [])  AssignmentExpression(=, [VariableReference(String[] instrumentationLibs, []), Expression(null, [])])    VariableReference(String[] instrumentationLibs, [])    Expression(null, [])  MethodCall(if (mAppDir.equals(instrumentationAppDir) || mAppDir.equals(instrumentedAppDir)), [VariableReference(if (mAppDir, []), Expression(instrumentationAppDir) || mAppDir.equals(instrumentedAppDir), [])])    VariableReference(if (mAppDir, [])    Expression(instrumentationAppDir) || mAppDir.equals(instrumentedAppDir), [])  AssignmentExpression(=, [VariableReference(zip, []), Expression(instrumentationAppDir + "":"" + instrumentedAppDir, [])])    VariableReference(zip, [])    Expression(instrumentationAppDir + "":"" + instrumentedAppDir, [])  MethodCall(if (!instrumentedAppDir.equals(instrumentationAppDir)), [VariableReference(if (!instrumentedAppDir, []), Expression(instrumentationAppDir), [])])    VariableReference(if (!instrumentedAppDir, [])    Expression(instrumentationAppDir), [])  AssignmentExpression(=, [VariableReference(instrumentationLibs, []), Expression(getLibrariesFor(instrumentationAppPackage), [])])    VariableReference(instrumentationLibs, [])    Expression(getLibrariesFor(instrumentationAppPackage), [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if ((mSharedLibraries !, []), Expression(null) || (instrumentationLibs !, [])])    VariableReference(if ((mSharedLibraries !, [])    Expression(null) || (instrumentationLibs !, [])  AssignmentExpression(=, [VariableReference(zip, []), Expression(combineLibs(mSharedLibraries, instrumentationLibs) + ':' + zip, [])])    VariableReference(zip, [])    Expression(combineLibs(mSharedLibraries, instrumentationLibs) + ':' + zip, [])  Statement(}, [])  Statement(if (localLOGV), [])  MethodCall(Slog.v(TAG, ""Class path: "" + zip), [VariableReference(Slog, []), Expression(TAG, []), Expression(""Class path: "" + zip, [])])    VariableReference(Slog, [])    Expression(TAG, [])    Expression(""Class path: "" + zip, [])  AssignmentExpression(=, [VariableReference(mClassLoader, []), Expression(ApplicationLoaders.getDefault().getClassLoader(zip, mDataDir, mBaseClassLoader), [])])    VariableReference(mClassLoader, [])    Expression(ApplicationLoaders.getDefault().getClassLoader(zip, mDataDir, mBaseClassLoader), [])  Statement(initializeJavaContextClassLoader(), [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(if (mBaseClassLoader, []), Expression(, [])])    VariableReference(if (mBaseClassLoader, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(mClassLoader, []), Expression(ClassLoader.getSystemClassLoader(), [])])    VariableReference(mClassLoader, [])    Expression(ClassLoader.getSystemClassLoader(), [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mClassLoader, []), Expression(mBaseClassLoader, [])])    VariableReference(mClassLoader, [])    Expression(mBaseClassLoader, [])  Statement(}, [])  Statement(}, [])  Statement(return mClassLoader, [])  Statement(}, [])  Statement(}, [])",1,,,-1,,,-1,-1,-1,-1,-1,4,1,"4,5","1,2",The code change between the two versions involves a change in the control dependency and the addition of a new statement. The control dependency change is in the 'if-else' statement where the condition for the 'if' statement has been modified. The new statement that has been added is 'initializeJavaContextClassLoader()'.,"The modification of the 'if' statement's condition could lead to different execution paths between the two versions, causing potential differences in the returned value or thrown exception. The addition of the 'initializeJavaContextClassLoader()' statement could also introduce new exceptions or affect the returned value if it has side-effects on the 'mClassLoader' variable. Therefore, the Compatibility Issue types are 1 and 2."
1032,<android.animation.AnimatorSet: void setStartDelay(long)>,25,26,<android.animation.AnimatorSet: void setStartDelay(long)>,<android.animation.AnimatorSet: void setStartDelay(long)>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(// Clamp start delay to non-negative range., []), Statement(if (startDelay < 0) {, []), MethodCall(Log.w(TAG, ""Start delay should always be non-negative""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Start delay should always be non-negative"", [])]), AssignmentExpression(=, [VariableReference(startDelay, []), Expression(0, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(long delta, []), Expression(startDelay - mStartDelay, [])]), AssignmentExpression(=, [VariableReference(if (delta, []), Expression(, [])]), Statement(return, []), Statement(}, []), AssignmentExpression(=, [VariableReference(mStartDelay, []), Expression(startDelay, [])]), Statement(if (mStartDelay > 0) {, []), AssignmentExpression(=, [VariableReference(mReversible, []), Expression(false, [])]), Statement(}, []), Statement(if (!mDependencyDirty) {, []), Statement(// Dependency graph already constructed, update all the nodes' start/end time, []), AssignmentExpression(=, [VariableReference(int size, []), Expression(mNodes.size(), [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < size, []), Statement(i++) {, []), AssignmentExpression(=, [VariableReference(Node node, []), Expression(mNodes.get(i), [])]), AssignmentExpression(=, [VariableReference(if (node, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(node.mEndTime, []), Expression(mStartDelay, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(node.mStartTime, []), Expression(node.mStartTime, [])]), AssignmentExpression(=, [VariableReference(node.mEndTime, []), Expression(node.mEndTime, [])]), Statement(}, []), Statement(}, []), Statement(// Update total duration, if necessary., []), AssignmentExpression(=, [VariableReference(if (mTotalDuration !, []), Expression(DURATION_INFINITE) {, [])]), AssignmentExpression(=, [VariableReference(mTotalDuration +, []), Expression(delta, [])]), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(// Clamp start delay to non-negative range., [])  Statement(if (startDelay < 0) {, [])  MethodCall(Log.w(TAG, ""Start delay should always be non-negative""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Start delay should always be non-negative"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Start delay should always be non-negative"", [])  AssignmentExpression(=, [VariableReference(startDelay, []), Expression(0, [])])    VariableReference(startDelay, [])    Expression(0, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(long delta, []), Expression(startDelay - mStartDelay, [])])    VariableReference(long delta, [])    Expression(startDelay - mStartDelay, [])  AssignmentExpression(=, [VariableReference(if (delta, []), Expression(, [])])    VariableReference(if (delta, [])    Expression(, [])  Statement(return, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mStartDelay, []), Expression(startDelay, [])])    VariableReference(mStartDelay, [])    Expression(startDelay, [])  Statement(if (mStartDelay > 0) {, [])  AssignmentExpression(=, [VariableReference(mReversible, []), Expression(false, [])])    VariableReference(mReversible, [])    Expression(false, [])  Statement(}, [])  Statement(if (!mDependencyDirty) {, [])  Statement(// Dependency graph already constructed, update all the nodes' start/end time, [])  AssignmentExpression(=, [VariableReference(int size, []), Expression(mNodes.size(), [])])    VariableReference(int size, [])    Expression(mNodes.size(), [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < size, [])  Statement(i++) {, [])  AssignmentExpression(=, [VariableReference(Node node, []), Expression(mNodes.get(i), [])])    VariableReference(Node node, [])    Expression(mNodes.get(i), [])  AssignmentExpression(=, [VariableReference(if (node, []), Expression(, [])])    VariableReference(if (node, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(node.mEndTime, []), Expression(mStartDelay, [])])    VariableReference(node.mEndTime, [])    Expression(mStartDelay, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(node.mStartTime, []), Expression(node.mStartTime, [])])    VariableReference(node.mStartTime, [])    Expression(node.mStartTime, [])  AssignmentExpression(=, [VariableReference(node.mEndTime, []), Expression(node.mEndTime, [])])    VariableReference(node.mEndTime, [])    Expression(node.mEndTime, [])  Statement(}, [])  Statement(}, [])  Statement(// Update total duration, if necessary., [])  AssignmentExpression(=, [VariableReference(if (mTotalDuration !, []), Expression(DURATION_INFINITE) {, [])])    VariableReference(if (mTotalDuration !, [])    Expression(DURATION_INFINITE) {, [])  AssignmentExpression(=, [VariableReference(mTotalDuration +, []), Expression(delta, [])])    VariableReference(mTotalDuration +, [])    Expression(delta, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(// Clamp start delay to non-negative range., []), Statement(if (startDelay < 0) {, []), MethodCall(Log.w(TAG, ""Start delay should always be non-negative""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Start delay should always be non-negative"", [])]), AssignmentExpression(=, [VariableReference(startDelay, []), Expression(0, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(long delta, []), Expression(startDelay - mStartDelay, [])]), AssignmentExpression(=, [VariableReference(if (delta, []), Expression(, [])]), Statement(return, []), Statement(}, []), AssignmentExpression(=, [VariableReference(mStartDelay, []), Expression(startDelay, [])]), Statement(if (!mDependencyDirty) {, []), Statement(// Dependency graph already constructed, update all the nodes' start/end time, []), AssignmentExpression(=, [VariableReference(int size, []), Expression(mNodes.size(), [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < size, []), Statement(i++) {, []), AssignmentExpression(=, [VariableReference(Node node, []), Expression(mNodes.get(i), [])]), AssignmentExpression(=, [VariableReference(if (node, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(node.mEndTime, []), Expression(mStartDelay, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(node.mStartTime, []), Expression(node.mStartTime, [])]), AssignmentExpression(=, [VariableReference(node.mEndTime, []), Expression(node.mEndTime, [])]), Statement(}, []), Statement(}, []), Statement(// Update total duration, if necessary., []), AssignmentExpression(=, [VariableReference(if (mTotalDuration !, []), Expression(DURATION_INFINITE) {, [])]), AssignmentExpression(=, [VariableReference(mTotalDuration +, []), Expression(delta, [])]), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(// Clamp start delay to non-negative range., [])  Statement(if (startDelay < 0) {, [])  MethodCall(Log.w(TAG, ""Start delay should always be non-negative""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Start delay should always be non-negative"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Start delay should always be non-negative"", [])  AssignmentExpression(=, [VariableReference(startDelay, []), Expression(0, [])])    VariableReference(startDelay, [])    Expression(0, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(long delta, []), Expression(startDelay - mStartDelay, [])])    VariableReference(long delta, [])    Expression(startDelay - mStartDelay, [])  AssignmentExpression(=, [VariableReference(if (delta, []), Expression(, [])])    VariableReference(if (delta, [])    Expression(, [])  Statement(return, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mStartDelay, []), Expression(startDelay, [])])    VariableReference(mStartDelay, [])    Expression(startDelay, [])  Statement(if (!mDependencyDirty) {, [])  Statement(// Dependency graph already constructed, update all the nodes' start/end time, [])  AssignmentExpression(=, [VariableReference(int size, []), Expression(mNodes.size(), [])])    VariableReference(int size, [])    Expression(mNodes.size(), [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < size, [])  Statement(i++) {, [])  AssignmentExpression(=, [VariableReference(Node node, []), Expression(mNodes.get(i), [])])    VariableReference(Node node, [])    Expression(mNodes.get(i), [])  AssignmentExpression(=, [VariableReference(if (node, []), Expression(, [])])    VariableReference(if (node, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(node.mEndTime, []), Expression(mStartDelay, [])])    VariableReference(node.mEndTime, [])    Expression(mStartDelay, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(node.mStartTime, []), Expression(node.mStartTime, [])])    VariableReference(node.mStartTime, [])    Expression(node.mStartTime, [])  AssignmentExpression(=, [VariableReference(node.mEndTime, []), Expression(node.mEndTime, [])])    VariableReference(node.mEndTime, [])    Expression(node.mEndTime, [])  Statement(}, [])  Statement(}, [])  Statement(// Update total duration, if necessary., [])  AssignmentExpression(=, [VariableReference(if (mTotalDuration !, []), Expression(DURATION_INFINITE) {, [])])    VariableReference(if (mTotalDuration !, [])    Expression(DURATION_INFINITE) {, [])  AssignmentExpression(=, [VariableReference(mTotalDuration +, []), Expression(delta, [])])    VariableReference(mTotalDuration +, [])    Expression(delta, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * The amount of time, in milliseconds, to delay starting the animation after
 * {@link #start()} is called. Note that the start delay should always be non-negative. Any
 * negative start delay will be clamped to 0 on N and above.
 *
 * @param startDelay The amount of the delay, in milliseconds
 */
","/**
 * The amount of time, in milliseconds, to delay starting the animation after
 * {@link #start()} is called. Note that the start delay should always be non-negative. Any
 * negative start delay will be clamped to 0 on N and above.
 *
 * @param startDelay The amount of the delay, in milliseconds
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,3,0,0,0,"There are no changes in the given implementation, comment, and annotation of the API between the two continuous versions.","As there are no changes, there are no compatibility issues that could arise."
193,<android.pim.vcard.VCardComposer.HandlerForOutputStream: boolean onInit(Context)>,8,9,<android.pim.vcard.VCardComposer.HandlerForOutputStream: boolean onInit(Context)>,<android.pim.vcard.VCardComposer.HandlerForOutputStream: boolean onInit(Context)>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), AssignmentExpression(=, [VariableReference(mWriter, []), Expression(new BufferedWriter(new OutputStreamWriter(mOutputStream, mCharsetString)), [])]), Statement(} catch (UnsupportedEncodingException e1) {, []), MethodCall(Log.e(LOG_TAG, ""Unsupported charset: "" + mCharsetString), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""Unsupported charset: "" + mCharsetString, [])]), AssignmentExpression(=, [VariableReference(mErrorReason, []), Expression(""Encoding is not supported (usually this does not happen!): "" + mCharsetString, [])]), Statement(return false, []), Statement(}, []), Statement(if (mIsDoCoMo) {, []), Statement(try {, []), Statement(// Create one empty entry., []), MethodCall(mWriter.write(createOneEntryInternal(""-1"", null)), [VariableReference(mWriter, []), Expression(createOneEntryInternal(""-1"", []), Expression(null), [])]), Statement(} catch (VCardException e) {, []), MethodCall(Log.e(LOG_TAG, ""VCardException has been thrown during on Init(): "" + e.getMessage()), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""VCardException has been thrown during on Init(): "" + e.getMessage(), [])]), Statement(return false, []), Statement(} catch (IOException e) {, []), MethodCall(Log.e(LOG_TAG, ""IOException occurred during exportOneContactData: "" + e.getMessage()), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""IOException occurred during exportOneContactData: "" + e.getMessage(), [])]), AssignmentExpression(=, [VariableReference(mErrorReason, []), Expression(""IOException occurred: "" + e.getMessage(), [])]), Statement(return false, []), Statement(}, []), Statement(}, []), Statement(return true, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(mWriter, []), Expression(new BufferedWriter(new OutputStreamWriter(mOutputStream, mCharsetString)), [])])    VariableReference(mWriter, [])    Expression(new BufferedWriter(new OutputStreamWriter(mOutputStream, mCharsetString)), [])  Statement(} catch (UnsupportedEncodingException e1) {, [])  MethodCall(Log.e(LOG_TAG, ""Unsupported charset: "" + mCharsetString), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""Unsupported charset: "" + mCharsetString, [])])    VariableReference(Log, [])    Expression(LOG_TAG, [])    Expression(""Unsupported charset: "" + mCharsetString, [])  AssignmentExpression(=, [VariableReference(mErrorReason, []), Expression(""Encoding is not supported (usually this does not happen!): "" + mCharsetString, [])])    VariableReference(mErrorReason, [])    Expression(""Encoding is not supported (usually this does not happen!): "" + mCharsetString, [])  Statement(return false, [])  Statement(}, [])  Statement(if (mIsDoCoMo) {, [])  Statement(try {, [])  Statement(// Create one empty entry., [])  MethodCall(mWriter.write(createOneEntryInternal(""-1"", null)), [VariableReference(mWriter, []), Expression(createOneEntryInternal(""-1"", []), Expression(null), [])])    VariableReference(mWriter, [])    Expression(createOneEntryInternal(""-1"", [])    Expression(null), [])  Statement(} catch (VCardException e) {, [])  MethodCall(Log.e(LOG_TAG, ""VCardException has been thrown during on Init(): "" + e.getMessage()), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""VCardException has been thrown during on Init(): "" + e.getMessage(), [])])    VariableReference(Log, [])    Expression(LOG_TAG, [])    Expression(""VCardException has been thrown during on Init(): "" + e.getMessage(), [])  Statement(return false, [])  Statement(} catch (IOException e) {, [])  MethodCall(Log.e(LOG_TAG, ""IOException occurred during exportOneContactData: "" + e.getMessage()), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""IOException occurred during exportOneContactData: "" + e.getMessage(), [])])    VariableReference(Log, [])    Expression(LOG_TAG, [])    Expression(""IOException occurred during exportOneContactData: "" + e.getMessage(), [])  AssignmentExpression(=, [VariableReference(mErrorReason, []), Expression(""IOException occurred: "" + e.getMessage(), [])])    VariableReference(mErrorReason, [])    Expression(""IOException occurred: "" + e.getMessage(), [])  Statement(return false, [])  Statement(}, [])  Statement(}, [])  Statement(return true, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), AssignmentExpression(=, [VariableReference(mWriter, []), Expression(new BufferedWriter(new OutputStreamWriter(mOutputStream, mCharset)), [])]), Statement(} catch (UnsupportedEncodingException e1) {, []), MethodCall(Log.e(LOG_TAG, ""Unsupported charset: "" + mCharset), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""Unsupported charset: "" + mCharset, [])]), AssignmentExpression(=, [VariableReference(mErrorReason, []), Expression(""Encoding is not supported (usually this does not happen!): "" + mCharset, [])]), Statement(return false, []), Statement(}, []), Statement(if (mIsDoCoMo) {, []), Statement(try {, []), Statement(// Create one empty entry., []), MethodCall(mWriter.write(createOneEntryInternal(""-1"", null)), [VariableReference(mWriter, []), Expression(createOneEntryInternal(""-1"", []), Expression(null), [])]), Statement(} catch (VCardException e) {, []), MethodCall(Log.e(LOG_TAG, ""VCardException has been thrown during on Init(): "" + e.getMessage()), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""VCardException has been thrown during on Init(): "" + e.getMessage(), [])]), Statement(return false, []), Statement(} catch (IOException e) {, []), MethodCall(Log.e(LOG_TAG, ""IOException occurred during exportOneContactData: "" + e.getMessage()), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""IOException occurred during exportOneContactData: "" + e.getMessage(), [])]), AssignmentExpression(=, [VariableReference(mErrorReason, []), Expression(""IOException occurred: "" + e.getMessage(), [])]), Statement(return false, []), Statement(}, []), Statement(}, []), Statement(return true, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(mWriter, []), Expression(new BufferedWriter(new OutputStreamWriter(mOutputStream, mCharset)), [])])    VariableReference(mWriter, [])    Expression(new BufferedWriter(new OutputStreamWriter(mOutputStream, mCharset)), [])  Statement(} catch (UnsupportedEncodingException e1) {, [])  MethodCall(Log.e(LOG_TAG, ""Unsupported charset: "" + mCharset), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""Unsupported charset: "" + mCharset, [])])    VariableReference(Log, [])    Expression(LOG_TAG, [])    Expression(""Unsupported charset: "" + mCharset, [])  AssignmentExpression(=, [VariableReference(mErrorReason, []), Expression(""Encoding is not supported (usually this does not happen!): "" + mCharset, [])])    VariableReference(mErrorReason, [])    Expression(""Encoding is not supported (usually this does not happen!): "" + mCharset, [])  Statement(return false, [])  Statement(}, [])  Statement(if (mIsDoCoMo) {, [])  Statement(try {, [])  Statement(// Create one empty entry., [])  MethodCall(mWriter.write(createOneEntryInternal(""-1"", null)), [VariableReference(mWriter, []), Expression(createOneEntryInternal(""-1"", []), Expression(null), [])])    VariableReference(mWriter, [])    Expression(createOneEntryInternal(""-1"", [])    Expression(null), [])  Statement(} catch (VCardException e) {, [])  MethodCall(Log.e(LOG_TAG, ""VCardException has been thrown during on Init(): "" + e.getMessage()), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""VCardException has been thrown during on Init(): "" + e.getMessage(), [])])    VariableReference(Log, [])    Expression(LOG_TAG, [])    Expression(""VCardException has been thrown during on Init(): "" + e.getMessage(), [])  Statement(return false, [])  Statement(} catch (IOException e) {, [])  MethodCall(Log.e(LOG_TAG, ""IOException occurred during exportOneContactData: "" + e.getMessage()), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""IOException occurred during exportOneContactData: "" + e.getMessage(), [])])    VariableReference(Log, [])    Expression(LOG_TAG, [])    Expression(""IOException occurred during exportOneContactData: "" + e.getMessage(), [])  AssignmentExpression(=, [VariableReference(mErrorReason, []), Expression(""IOException occurred: "" + e.getMessage(), [])])    VariableReference(mErrorReason, [])    Expression(""IOException occurred: "" + e.getMessage(), [])  Statement(return false, [])  Statement(}, [])  Statement(}, [])  Statement(return true, [])  Statement(}, [])",1,,,-1,,,-1,-1,-1,-1,-1,4,0,1,1,"The code change between the two versions is in the variable used for the character encoding in the `OutputStreamWriter` constructor. In the early version, the variable `mCharsetString` is used, while in the late version, the variable `mCharset` is used. This change can potentially lead to different behaviors if the values of `mCharsetString` and `mCharset` are different.","If the values of `mCharsetString` and `mCharset` are different, the `OutputStreamWriter` will use different character encodings in the early and late versions. This can potentially lead to different output in the written file, which can be considered as a compatibility issue. For example, if `mCharsetString` is ""UTF-8"" and `mCharset` is ""ISO-8859-1"", the output file in the early version will be encoded in UTF-8, while the output file in the late version will be encoded in ISO-8859-1."
888,"<android.inputmethodservice.InputMethodService: void doStartInput(InputConnection,EditorInfo,boolean)>",29,30,"<android.inputmethodservice.InputMethodService: void doStartInput(InputConnection,EditorInfo,boolean)>","<android.inputmethodservice.InputMethodService: void doStartInput(InputConnection,EditorInfo,boolean)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(if (!restarting) {, []), Statement(doFinishInput(), []), Statement(}, []), AssignmentExpression(=, [VariableReference(mInputStarted, []), Expression(true, [])]), AssignmentExpression(=, [VariableReference(mStartedInputConnection, []), Expression(ic, [])]), AssignmentExpression(=, [VariableReference(mInputEditorInfo, []), Expression(attribute, [])]), Statement(initialize(), []), Statement(if (DEBUG), []), MethodCall(Log.v(TAG, ""CALL: onStartInput""), [VariableReference(Log, []), Expression(TAG, []), Expression(""CALL: onStartInput"", [])]), Statement(onStartInput(attribute, restarting), []), Statement(if (mDecorViewVisible) {, []), Statement(if (mShowInputRequested) {, []), Statement(if (DEBUG), []), MethodCall(Log.v(TAG, ""CALL: onStartInputView""), [VariableReference(Log, []), Expression(TAG, []), Expression(""CALL: onStartInputView"", [])]), AssignmentExpression(=, [VariableReference(mInputViewStarted, []), Expression(true, [])]), Statement(onStartInputView(mInputEditorInfo, restarting), []), Statement(startExtractingText(true), []), AssignmentExpression(=, [VariableReference(} else if (mCandidatesVisibility, []), Expression(, [])]), Statement(if (DEBUG), []), MethodCall(Log.v(TAG, ""CALL: onStartCandidatesView""), [VariableReference(Log, []), Expression(TAG, []), Expression(""CALL: onStartCandidatesView"", [])]), AssignmentExpression(=, [VariableReference(mCandidatesViewStarted, []), Expression(true, [])]), Statement(onStartCandidatesView(mInputEditorInfo, restarting), []), Statement(}, []), AssignmentExpression(=, [VariableReference(} else if (mCanPreRender && mInputEditorInfo !, []), Expression(null && mStartedInputConnection !, [])]), Statement(// pre-render IME window and keep it invisible., []), Statement(if (DEBUG), []), MethodCall(Log.v(TAG, ""Pre-Render IME for "" + mInputEditorInfo.fieldName), [VariableReference(Log, []), Expression(TAG, []), Expression(""Pre-Render IME for "" + mInputEditorInfo.fieldName, [])]), Statement(if (mInShowWindow) {, []), MethodCall(Log.w(TAG, ""Re-entrance in to showWindow""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Re-entrance in to showWindow"", [])]), Statement(return, []), Statement(}, []), AssignmentExpression(=, [VariableReference(mDecorViewWasVisible, []), Expression(mDecorViewVisible, [])]), AssignmentExpression(=, [VariableReference(mInShowWindow, []), Expression(true, [])]), Statement(startViews(prepareWindow(true)), []), Statement(// compute visibility, []), AssignmentExpression(=, [VariableReference(mIsPreRendered, []), Expression(true, [])]), Statement(onPreRenderedWindowVisibilityChanged(false), []), Statement(// When IME is not pre-rendered, this will actually show the IME., []), Statement(if (DEBUG), []), MethodCall(Log.v(TAG, ""showWindow: draw decorView!""), [VariableReference(Log, []), Expression(TAG, []), Expression(""showWindow: draw decorView!"", [])]), MethodCall(mWindow.show(), [VariableReference(mWindow, []), Expression(, [])]), Statement(maybeNotifyPreRendered(), []), AssignmentExpression(=, [VariableReference(mDecorViewWasVisible, []), Expression(true, [])]), AssignmentExpression(=, [VariableReference(mInShowWindow, []), Expression(false, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mIsPreRendered, []), Expression(false, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(if (!restarting) {, [])  Statement(doFinishInput(), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mInputStarted, []), Expression(true, [])])    VariableReference(mInputStarted, [])    Expression(true, [])  AssignmentExpression(=, [VariableReference(mStartedInputConnection, []), Expression(ic, [])])    VariableReference(mStartedInputConnection, [])    Expression(ic, [])  AssignmentExpression(=, [VariableReference(mInputEditorInfo, []), Expression(attribute, [])])    VariableReference(mInputEditorInfo, [])    Expression(attribute, [])  Statement(initialize(), [])  Statement(if (DEBUG), [])  MethodCall(Log.v(TAG, ""CALL: onStartInput""), [VariableReference(Log, []), Expression(TAG, []), Expression(""CALL: onStartInput"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""CALL: onStartInput"", [])  Statement(onStartInput(attribute, restarting), [])  Statement(if (mDecorViewVisible) {, [])  Statement(if (mShowInputRequested) {, [])  Statement(if (DEBUG), [])  MethodCall(Log.v(TAG, ""CALL: onStartInputView""), [VariableReference(Log, []), Expression(TAG, []), Expression(""CALL: onStartInputView"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""CALL: onStartInputView"", [])  AssignmentExpression(=, [VariableReference(mInputViewStarted, []), Expression(true, [])])    VariableReference(mInputViewStarted, [])    Expression(true, [])  Statement(onStartInputView(mInputEditorInfo, restarting), [])  Statement(startExtractingText(true), [])  AssignmentExpression(=, [VariableReference(} else if (mCandidatesVisibility, []), Expression(, [])])    VariableReference(} else if (mCandidatesVisibility, [])    Expression(, [])  Statement(if (DEBUG), [])  MethodCall(Log.v(TAG, ""CALL: onStartCandidatesView""), [VariableReference(Log, []), Expression(TAG, []), Expression(""CALL: onStartCandidatesView"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""CALL: onStartCandidatesView"", [])  AssignmentExpression(=, [VariableReference(mCandidatesViewStarted, []), Expression(true, [])])    VariableReference(mCandidatesViewStarted, [])    Expression(true, [])  Statement(onStartCandidatesView(mInputEditorInfo, restarting), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(} else if (mCanPreRender && mInputEditorInfo !, []), Expression(null && mStartedInputConnection !, [])])    VariableReference(} else if (mCanPreRender && mInputEditorInfo !, [])    Expression(null && mStartedInputConnection !, [])  Statement(// pre-render IME window and keep it invisible., [])  Statement(if (DEBUG), [])  MethodCall(Log.v(TAG, ""Pre-Render IME for "" + mInputEditorInfo.fieldName), [VariableReference(Log, []), Expression(TAG, []), Expression(""Pre-Render IME for "" + mInputEditorInfo.fieldName, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Pre-Render IME for "" + mInputEditorInfo.fieldName, [])  Statement(if (mInShowWindow) {, [])  MethodCall(Log.w(TAG, ""Re-entrance in to showWindow""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Re-entrance in to showWindow"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Re-entrance in to showWindow"", [])  Statement(return, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mDecorViewWasVisible, []), Expression(mDecorViewVisible, [])])    VariableReference(mDecorViewWasVisible, [])    Expression(mDecorViewVisible, [])  AssignmentExpression(=, [VariableReference(mInShowWindow, []), Expression(true, [])])    VariableReference(mInShowWindow, [])    Expression(true, [])  Statement(startViews(prepareWindow(true)), [])  Statement(// compute visibility, [])  AssignmentExpression(=, [VariableReference(mIsPreRendered, []), Expression(true, [])])    VariableReference(mIsPreRendered, [])    Expression(true, [])  Statement(onPreRenderedWindowVisibilityChanged(false), [])  Statement(// When IME is not pre-rendered, this will actually show the IME., [])  Statement(if (DEBUG), [])  MethodCall(Log.v(TAG, ""showWindow: draw decorView!""), [VariableReference(Log, []), Expression(TAG, []), Expression(""showWindow: draw decorView!"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""showWindow: draw decorView!"", [])  MethodCall(mWindow.show(), [VariableReference(mWindow, []), Expression(, [])])    VariableReference(mWindow, [])    Expression(, [])  Statement(maybeNotifyPreRendered(), [])  AssignmentExpression(=, [VariableReference(mDecorViewWasVisible, []), Expression(true, [])])    VariableReference(mDecorViewWasVisible, [])    Expression(true, [])  AssignmentExpression(=, [VariableReference(mInShowWindow, []), Expression(false, [])])    VariableReference(mInShowWindow, [])    Expression(false, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mIsPreRendered, []), Expression(false, [])])    VariableReference(mIsPreRendered, [])    Expression(false, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (!restarting) {, []), Statement(doFinishInput(), []), Statement(}, []), AssignmentExpression(=, [VariableReference(mInputStarted, []), Expression(true, [])]), AssignmentExpression(=, [VariableReference(mStartedInputConnection, []), Expression(ic, [])]), AssignmentExpression(=, [VariableReference(mInputEditorInfo, []), Expression(attribute, [])]), Statement(initialize(), []), AssignmentExpression(=, [VariableReference(mInlineSuggestionSessionController.notifyOnStartInput(attribute, []), Expression(, [])]), Statement(if (DEBUG), []), MethodCall(Log.v(TAG, ""CALL: onStartInput""), [VariableReference(Log, []), Expression(TAG, []), Expression(""CALL: onStartInput"", [])]), Statement(onStartInput(attribute, restarting), []), Statement(if (mDecorViewVisible) {, []), Statement(if (mShowInputRequested) {, []), Statement(if (DEBUG), []), MethodCall(Log.v(TAG, ""CALL: onStartInputView""), [VariableReference(Log, []), Expression(TAG, []), Expression(""CALL: onStartInputView"", [])]), AssignmentExpression(=, [VariableReference(mInputViewStarted, []), Expression(true, [])]), MethodCall(mInlineSuggestionSessionController.notifyOnStartInputView(), [VariableReference(mInlineSuggestionSessionController, []), Expression(, [])]), Statement(onStartInputView(mInputEditorInfo, restarting), []), Statement(startExtractingText(true), []), AssignmentExpression(=, [VariableReference(} else if (mCandidatesVisibility, []), Expression(, [])]), Statement(if (DEBUG), []), MethodCall(Log.v(TAG, ""CALL: onStartCandidatesView""), [VariableReference(Log, []), Expression(TAG, []), Expression(""CALL: onStartCandidatesView"", [])]), AssignmentExpression(=, [VariableReference(mCandidatesViewStarted, []), Expression(true, [])]), Statement(onStartCandidatesView(mInputEditorInfo, restarting), []), Statement(}, []), AssignmentExpression(=, [VariableReference(} else if (mCanPreRender && mInputEditorInfo !, []), Expression(null && mStartedInputConnection !, [])]), Statement(// pre-render IME window and keep it invisible., []), Statement(if (DEBUG), []), MethodCall(Log.v(TAG, ""Pre-Render IME for "" + mInputEditorInfo.fieldName), [VariableReference(Log, []), Expression(TAG, []), Expression(""Pre-Render IME for "" + mInputEditorInfo.fieldName, [])]), Statement(if (mInShowWindow) {, []), MethodCall(Log.w(TAG, ""Re-entrance in to showWindow""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Re-entrance in to showWindow"", [])]), Statement(return, []), Statement(}, []), AssignmentExpression(=, [VariableReference(mDecorViewWasVisible, []), Expression(mDecorViewVisible, [])]), AssignmentExpression(=, [VariableReference(mInShowWindow, []), Expression(true, [])]), Statement(startViews(prepareWindow(true)), []), Statement(// compute visibility, []), AssignmentExpression(=, [VariableReference(mIsPreRendered, []), Expression(true, [])]), Statement(onPreRenderedWindowVisibilityChanged(false), []), Statement(// When IME is not pre-rendered, this will actually show the IME., []), Statement(if (DEBUG), []), MethodCall(Log.v(TAG, ""showWindow: draw decorView!""), [VariableReference(Log, []), Expression(TAG, []), Expression(""showWindow: draw decorView!"", [])]), MethodCall(mWindow.show(), [VariableReference(mWindow, []), Expression(, [])]), Statement(maybeNotifyPreRendered(), []), AssignmentExpression(=, [VariableReference(mDecorViewWasVisible, []), Expression(true, [])]), AssignmentExpression(=, [VariableReference(mInShowWindow, []), Expression(false, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mIsPreRendered, []), Expression(false, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(if (!restarting) {, [])  Statement(doFinishInput(), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mInputStarted, []), Expression(true, [])])    VariableReference(mInputStarted, [])    Expression(true, [])  AssignmentExpression(=, [VariableReference(mStartedInputConnection, []), Expression(ic, [])])    VariableReference(mStartedInputConnection, [])    Expression(ic, [])  AssignmentExpression(=, [VariableReference(mInputEditorInfo, []), Expression(attribute, [])])    VariableReference(mInputEditorInfo, [])    Expression(attribute, [])  Statement(initialize(), [])  AssignmentExpression(=, [VariableReference(mInlineSuggestionSessionController.notifyOnStartInput(attribute, []), Expression(, [])])    VariableReference(mInlineSuggestionSessionController.notifyOnStartInput(attribute, [])    Expression(, [])  Statement(if (DEBUG), [])  MethodCall(Log.v(TAG, ""CALL: onStartInput""), [VariableReference(Log, []), Expression(TAG, []), Expression(""CALL: onStartInput"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""CALL: onStartInput"", [])  Statement(onStartInput(attribute, restarting), [])  Statement(if (mDecorViewVisible) {, [])  Statement(if (mShowInputRequested) {, [])  Statement(if (DEBUG), [])  MethodCall(Log.v(TAG, ""CALL: onStartInputView""), [VariableReference(Log, []), Expression(TAG, []), Expression(""CALL: onStartInputView"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""CALL: onStartInputView"", [])  AssignmentExpression(=, [VariableReference(mInputViewStarted, []), Expression(true, [])])    VariableReference(mInputViewStarted, [])    Expression(true, [])  MethodCall(mInlineSuggestionSessionController.notifyOnStartInputView(), [VariableReference(mInlineSuggestionSessionController, []), Expression(, [])])    VariableReference(mInlineSuggestionSessionController, [])    Expression(, [])  Statement(onStartInputView(mInputEditorInfo, restarting), [])  Statement(startExtractingText(true), [])  AssignmentExpression(=, [VariableReference(} else if (mCandidatesVisibility, []), Expression(, [])])    VariableReference(} else if (mCandidatesVisibility, [])    Expression(, [])  Statement(if (DEBUG), [])  MethodCall(Log.v(TAG, ""CALL: onStartCandidatesView""), [VariableReference(Log, []), Expression(TAG, []), Expression(""CALL: onStartCandidatesView"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""CALL: onStartCandidatesView"", [])  AssignmentExpression(=, [VariableReference(mCandidatesViewStarted, []), Expression(true, [])])    VariableReference(mCandidatesViewStarted, [])    Expression(true, [])  Statement(onStartCandidatesView(mInputEditorInfo, restarting), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(} else if (mCanPreRender && mInputEditorInfo !, []), Expression(null && mStartedInputConnection !, [])])    VariableReference(} else if (mCanPreRender && mInputEditorInfo !, [])    Expression(null && mStartedInputConnection !, [])  Statement(// pre-render IME window and keep it invisible., [])  Statement(if (DEBUG), [])  MethodCall(Log.v(TAG, ""Pre-Render IME for "" + mInputEditorInfo.fieldName), [VariableReference(Log, []), Expression(TAG, []), Expression(""Pre-Render IME for "" + mInputEditorInfo.fieldName, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Pre-Render IME for "" + mInputEditorInfo.fieldName, [])  Statement(if (mInShowWindow) {, [])  MethodCall(Log.w(TAG, ""Re-entrance in to showWindow""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Re-entrance in to showWindow"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Re-entrance in to showWindow"", [])  Statement(return, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mDecorViewWasVisible, []), Expression(mDecorViewVisible, [])])    VariableReference(mDecorViewWasVisible, [])    Expression(mDecorViewVisible, [])  AssignmentExpression(=, [VariableReference(mInShowWindow, []), Expression(true, [])])    VariableReference(mInShowWindow, [])    Expression(true, [])  Statement(startViews(prepareWindow(true)), [])  Statement(// compute visibility, [])  AssignmentExpression(=, [VariableReference(mIsPreRendered, []), Expression(true, [])])    VariableReference(mIsPreRendered, [])    Expression(true, [])  Statement(onPreRenderedWindowVisibilityChanged(false), [])  Statement(// When IME is not pre-rendered, this will actually show the IME., [])  Statement(if (DEBUG), [])  MethodCall(Log.v(TAG, ""showWindow: draw decorView!""), [VariableReference(Log, []), Expression(TAG, []), Expression(""showWindow: draw decorView!"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""showWindow: draw decorView!"", [])  MethodCall(mWindow.show(), [VariableReference(mWindow, []), Expression(, [])])    VariableReference(mWindow, [])    Expression(, [])  Statement(maybeNotifyPreRendered(), [])  AssignmentExpression(=, [VariableReference(mDecorViewWasVisible, []), Expression(true, [])])    VariableReference(mDecorViewWasVisible, [])    Expression(true, [])  AssignmentExpression(=, [VariableReference(mInShowWindow, []), Expression(false, [])])    VariableReference(mInShowWindow, [])    Expression(false, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mIsPreRendered, []), Expression(false, [])])    VariableReference(mIsPreRendered, [])    Expression(false, [])  Statement(}, [])  Statement(}, [])",1,,,-1,,,-1,-1,-1,-1,-1,4,0,"4,5","1,2","There are two new method calls in the late version implementation: `mInlineSuggestionSessionController.notifyOnStartInput(attribute, [])` and `mInlineSuggestionSessionController.notifyOnStartInputView()`. These new method calls could potentially lead to different behaviors of the API. Additionally, the control dependency has changed as the new method calls are placed inside the existing control flow.","The new method calls `mInlineSuggestionSessionController.notifyOnStartInput(attribute, [])` and `mInlineSuggestionSessionController.notifyOnStartInputView()` could potentially cause the API to return different values or throw different exceptions. For example, if the `mInlineSuggestionSessionController` object is not properly initialized or if it throws an exception during the execution of the new method calls, this could lead to a compatibility issue. Moreover, the changed control dependency could also lead to different execution paths and hence different behaviors of the API."
48,<android.animation.Keyframe.FloatKeyframe: FloatKeyframe clone()>,20,21,<android.animation.Keyframe.FloatKeyframe: FloatKeyframe clone()>,<android.animation.Keyframe.FloatKeyframe: FloatKeyframe clone()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(FloatKeyframe kfClone, []), Expression(mHasValue ? new FloatKeyframe(getFraction(), mValue) : new FloatKeyframe(getFraction()), [])]), MethodCall(kfClone.setInterpolator(getInterpolator()), [VariableReference(kfClone, []), Expression(getInterpolator(), [])]), Statement(return kfClone, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(FloatKeyframe kfClone, []), Expression(mHasValue ? new FloatKeyframe(getFraction(), mValue) : new FloatKeyframe(getFraction()), [])])    VariableReference(FloatKeyframe kfClone, [])    Expression(mHasValue ? new FloatKeyframe(getFraction(), mValue) : new FloatKeyframe(getFraction()), [])  MethodCall(kfClone.setInterpolator(getInterpolator()), [VariableReference(kfClone, []), Expression(getInterpolator(), [])])    VariableReference(kfClone, [])    Expression(getInterpolator(), [])  Statement(return kfClone, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(FloatKeyframe kfClone, []), Expression(mHasValue ? new FloatKeyframe(getFraction(), mValue) : new FloatKeyframe(getFraction()), [])]), MethodCall(kfClone.setInterpolator(getInterpolator()), [VariableReference(kfClone, []), Expression(getInterpolator(), [])]), AssignmentExpression(=, [VariableReference(kfClone.mValueWasSetOnStart, []), Expression(mValueWasSetOnStart, [])]), Statement(return kfClone, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(FloatKeyframe kfClone, []), Expression(mHasValue ? new FloatKeyframe(getFraction(), mValue) : new FloatKeyframe(getFraction()), [])])    VariableReference(FloatKeyframe kfClone, [])    Expression(mHasValue ? new FloatKeyframe(getFraction(), mValue) : new FloatKeyframe(getFraction()), [])  MethodCall(kfClone.setInterpolator(getInterpolator()), [VariableReference(kfClone, []), Expression(getInterpolator(), [])])    VariableReference(kfClone, [])    Expression(getInterpolator(), [])  AssignmentExpression(=, [VariableReference(kfClone.mValueWasSetOnStart, []), Expression(mValueWasSetOnStart, [])])    VariableReference(kfClone.mValueWasSetOnStart, [])    Expression(mValueWasSetOnStart, [])  Statement(return kfClone, [])  Statement(}, [])",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,4,0,4,1,"In the late version, a new assignment expression has been added: `kfClone.mValueWasSetOnStart = mValueWasSetOnStart;`. This statement sets the value of the `mValueWasSetOnStart` field in the cloned `FloatKeyframe` object to the value of the same field in the original object. This change does not affect the control flow or the exception handling of the method.","The new assignment expression in the late version can potentially cause a compatibility issue if the application code relies on the `mValueWasSetOnStart` field of a cloned `FloatKeyframe` object to have a different value than the original object. This is because the late version of the method sets the value of this field in the cloned object to be the same as the original object, while the early version does not. However, this field is not part of the public API of the `FloatKeyframe` class, and is marked as `@hide` in the Android framework source code. Therefore, it is unlikely that application code would directly access or rely on the value of this field."
212,<android.webkit.WebView: void requestImageRef(Message)>,15,16,<android.webkit.WebView: void requestImageRef(Message)>,<android.webkit.WebView: void requestImageRef(Message)>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(checkThread(), []), Statement(// client isn't initialized, []), AssignmentExpression(=, [VariableReference(if (0, []), Expression(, [])]), Statement(return, []), AssignmentExpression(=, [VariableReference(int contentX, []), Expression(viewToContentX(mLastTouchX + mScrollX), [])]), AssignmentExpression(=, [VariableReference(int contentY, []), Expression(viewToContentY(mLastTouchY + mScrollY), [])]), AssignmentExpression(=, [VariableReference(String ref, []), Expression(nativeImageURI(contentX, contentY), [])]), AssignmentExpression(=, [VariableReference(Bundle data, []), Expression(msg.getData(), [])]), MethodCall(data.putString(""url"", ref), [VariableReference(data, []), Expression(""url"", []), Expression(ref, [])]), MethodCall(msg.setData(data), [VariableReference(msg, []), Expression(data, [])]), MethodCall(msg.sendToTarget(), [VariableReference(msg, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  Statement(checkThread(), [])  Statement(// client isn't initialized, [])  AssignmentExpression(=, [VariableReference(if (0, []), Expression(, [])])    VariableReference(if (0, [])    Expression(, [])  Statement(return, [])  AssignmentExpression(=, [VariableReference(int contentX, []), Expression(viewToContentX(mLastTouchX + mScrollX), [])])    VariableReference(int contentX, [])    Expression(viewToContentX(mLastTouchX + mScrollX), [])  AssignmentExpression(=, [VariableReference(int contentY, []), Expression(viewToContentY(mLastTouchY + mScrollY), [])])    VariableReference(int contentY, [])    Expression(viewToContentY(mLastTouchY + mScrollY), [])  AssignmentExpression(=, [VariableReference(String ref, []), Expression(nativeImageURI(contentX, contentY), [])])    VariableReference(String ref, [])    Expression(nativeImageURI(contentX, contentY), [])  AssignmentExpression(=, [VariableReference(Bundle data, []), Expression(msg.getData(), [])])    VariableReference(Bundle data, [])    Expression(msg.getData(), [])  MethodCall(data.putString(""url"", ref), [VariableReference(data, []), Expression(""url"", []), Expression(ref, [])])    VariableReference(data, [])    Expression(""url"", [])    Expression(ref, [])  MethodCall(msg.setData(data), [VariableReference(msg, []), Expression(data, [])])    VariableReference(msg, [])    Expression(data, [])  MethodCall(msg.sendToTarget(), [VariableReference(msg, []), Expression(, [])])    VariableReference(msg, [])    Expression(, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(checkThread(), []), MethodCall(mProvider.requestImageRef(msg), [VariableReference(mProvider, []), Expression(msg, [])]), Statement(}, [])])  Statement({, [])  Statement(checkThread(), [])  MethodCall(mProvider.requestImageRef(msg), [VariableReference(mProvider, []), Expression(msg, [])])    VariableReference(mProvider, [])    Expression(msg, [])  Statement(}, [])",1,"/**
 * Request the url of the image last touched by the user. msg will be sent
 * to its target with a String representing the url as its object.
 *
 * @param msg This message will be dispatched with the result of the request
 * as the data member with ""url"" as key. The result can be null.
 */
","/**
 * Requests the URL of the image last touched by the user. msg will be sent
 * to its target with a String representing the URL as its object.
 *
 * @param msg the message to be dispatched with the result of the request
 * as the data member with ""url"" as key. The result can be null.
 */
",-1,,,-1,-1,-1,-1,-1,"1,3,4",1,5,1,"The implementation of the method ""requestImageRef"" has been changed from a series of statements including variable assignments, method calls, and a conditional statement, to a single method call ""mProvider.requestImageRef(msg)"". This is a Dependent API change as the method now relies on the ""mProvider"" object's implementation of ""requestImageRef"".","The Compatibility Issue arises as the change in the Dependent API can potentially lead to a different behavior in the method ""requestImageRef"". The previous implementation had a conditional statement that would return early if a certain condition was met, and also had specific logic for calculating the x and y coordinates of the image. The new implementation, however, relies entirely on the ""mProvider"" object's implementation, which may not include the same logic, leading to a different returned value."
171,<android.app.ActivityManager: int getLockTaskModeState()>,23,24,<android.app.ActivityManager: int getLockTaskModeState()>,<android.app.ActivityManager: int getLockTaskModeState()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(return ActivityManagerNative.getDefault().getLockTaskModeState(), [VariableReference(return ActivityManagerNative, []), Expression().getLockTaskModeState(, [])]), Statement(} catch (RemoteException e) {, []), Statement(return ActivityManager.LOCK_TASK_MODE_NONE, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(return ActivityManagerNative.getDefault().getLockTaskModeState(), [VariableReference(return ActivityManagerNative, []), Expression().getLockTaskModeState(, [])])    VariableReference(return ActivityManagerNative, [])    Expression().getLockTaskModeState(, [])  Statement(} catch (RemoteException e) {, [])  Statement(return ActivityManager.LOCK_TASK_MODE_NONE, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(return ActivityManagerNative.getDefault().getLockTaskModeState(), [VariableReference(return ActivityManagerNative, []), Expression().getLockTaskModeState(, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(return ActivityManagerNative.getDefault().getLockTaskModeState(), [VariableReference(return ActivityManagerNative, []), Expression().getLockTaskModeState(, [])])    VariableReference(return ActivityManagerNative, [])    Expression().getLockTaskModeState(, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Return the current state of task locking. The three possible outcomes
 * are {@link #LOCK_TASK_MODE_NONE}, {@link #LOCK_TASK_MODE_LOCKED}
 * and {@link #LOCK_TASK_MODE_PINNED}.
 *
 * @see Activity#startLockTask()
 */
","/**
 * Return the current state of task locking. The three possible outcomes
 * are {@link #LOCK_TASK_MODE_NONE}, {@link #LOCK_TASK_MODE_LOCKED}
 * and {@link #LOCK_TASK_MODE_PINNED}.
 *
 * @see Activity#startLockTask()
 */
",-1,,,-1,-1,-1,-1,-1,"1,2",2,2,2,"The reason for the Compatibility Issue (CI) classification is that the change in the exception handling statement could lead to different behavior in the calling code. Specifically, if the calling code is not prepared to handle the runtime exception that is thrown by the late version of the method `getLockTaskModeState()`, it could crash or behave incorrectly.",
785,"<android.app.admin.DevicePolicyManager: void setCameraDisabled(ComponentName,boolean)>",23,24,"<android.app.admin.DevicePolicyManager: void setCameraDisabled(ComponentName,boolean)>","<android.app.admin.DevicePolicyManager: void setCameraDisabled(ComponentName,boolean)>",0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mService !, []), Expression(null) {, [])]), Statement(try {, []), MethodCall(mService.setCameraDisabled(admin, disabled), [VariableReference(mService, []), Expression(admin, []), Expression(disabled, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(Log.w(TAG, ""Failed talking with device policy service"", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Failed talking with device policy service"", []), Expression(e, [])]), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mService !, []), Expression(null) {, [])])    VariableReference(if (mService !, [])    Expression(null) {, [])  Statement(try {, [])  MethodCall(mService.setCameraDisabled(admin, disabled), [VariableReference(mService, []), Expression(admin, []), Expression(disabled, [])])    VariableReference(mService, [])    Expression(admin, [])    Expression(disabled, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(Log.w(TAG, ""Failed talking with device policy service"", e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Failed talking with device policy service"", []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Failed talking with device policy service"", [])    Expression(e, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(throwIfParentInstance(""setCameraDisabled""), []), AssignmentExpression(=, [VariableReference(if (mService !, []), Expression(null) {, [])]), Statement(try {, []), MethodCall(mService.setCameraDisabled(admin, disabled), [VariableReference(mService, []), Expression(admin, []), Expression(disabled, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(throwIfParentInstance(""setCameraDisabled""), [])  AssignmentExpression(=, [VariableReference(if (mService !, []), Expression(null) {, [])])    VariableReference(if (mService !, [])    Expression(null) {, [])  Statement(try {, [])  MethodCall(mService.setCameraDisabled(admin, disabled), [VariableReference(mService, []), Expression(admin, []), Expression(disabled, [])])    VariableReference(mService, [])    Expression(admin, [])    Expression(disabled, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Called by an application that is administering the device to disable all cameras
 * on the device, for this user. After setting this, no applications running as this user
 * will be able to access any cameras on the device.
 *
 * <p>The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_DISABLE_CAMERA} to be able to call
 * this method; if it has not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param disabled Whether or not the camera should be disabled.
 */
","/**
 * Called by an application that is administering the device to disable all cameras on the
 * device, for this user. After setting this, no applications running as this user will be able
 * to access any cameras on the device.
 * <p>
 * If the caller is device owner, then the restriction will be applied to all users.
 * <p>
 * The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_DISABLE_CAMERA} to be able to call this method; if it has
 * not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param disabled Whether or not the camera should be disabled.
 * @throws SecurityException if {@code admin} is not an active administrator or does not use
 * {@link DeviceAdminInfo#USES_POLICY_DISABLE_CAMERA}.
 */
",-1,,,-1,-1,-1,-1,-1,"2,4",2,"1,2","1,2","The implementation of the `setCameraDisabled` method has been modified between the early version (23) and the late version (24). In the early version, the method catches a `RemoteException` and logs a warning message if the communication with the device policy service fails. In the late version, the method first calls a `throwIfParentInstance` method, and then catches the `RemoteException` and rethrows it as a runtime exception using the `rethrowFromSystemServer` method.","The change in the exception handling mechanism between the early and late versions of the `setCameraDisabled` method can potentially lead to compatibility issues. In the early version, if the communication with the device policy service fails, the method only logs a warning message and does not throw an exception. However, in the late version, the method rethrows the `RemoteException` as a runtime exception, which can potentially propagate to the calling code and cause unexpected behavior. This is a type 1 compatibility issue, as the method can potentially return a different value (i.e., throw an exception) in the late version. Additionally, the change in the exception handling mechanism can also lead to a type 2 compatibility issue, as the method can potentially throw a different exception in the late version."
202,"<android.content.ContentResolver: void requestSync(Account,String,Bundle)>",18,19,"<android.content.ContentResolver: void requestSync(Account,String,Bundle)>","<android.content.ContentResolver: void requestSync(Account,String,Bundle)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(validateSyncExtrasBundle(extras), []), Statement(try {, []), MethodCall(getContentService().requestSync(account, authority, extras), [VariableReference(getContentService(), []), Expression(account, []), Expression(authority, []), Expression(extras, [])]), Statement(} catch (RemoteException e) {, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(validateSyncExtrasBundle(extras), [])  Statement(try {, [])  MethodCall(getContentService().requestSync(account, authority, extras), [VariableReference(getContentService(), []), Expression(account, []), Expression(authority, []), Expression(extras, [])])    VariableReference(getContentService(), [])    Expression(account, [])    Expression(authority, [])    Expression(extras, [])  Statement(} catch (RemoteException e) {, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (extras, []), Expression(, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(SyncRequest request, []), Expression(new SyncRequest.Builder().setSyncAdapter(account, authority).setExtras(extras).syncOnce().build(), [])]), Statement(requestSync(request), []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (extras, []), Expression(, [])])    VariableReference(if (extras, [])    Expression(, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(SyncRequest request, []), Expression(new SyncRequest.Builder().setSyncAdapter(account, authority).setExtras(extras).syncOnce().build(), [])])    VariableReference(SyncRequest request, [])    Expression(new SyncRequest.Builder().setSyncAdapter(account, authority).setExtras(extras).syncOnce().build(), [])  Statement(requestSync(request), [])  Statement(}, [])",1,"/**
 * Start an asynchronous sync operation. If you want to monitor the progress
 * of the sync you may register a SyncObserver. Only values of the following
 * types may be used in the extras bundle:
 * <ul>
 * <li>Integer</li>
 * <li>Long</li>
 * <li>Boolean</li>
 * <li>Float</li>
 * <li>Double</li>
 * <li>String</li>
 * </ul>
 *
 * @param account which account should be synced
 * @param authority which authority should be synced
 * @param extras any extras to pass to the SyncAdapter.
 */
","/**
 * Start an asynchronous sync operation. If you want to monitor the progress
 * of the sync you may register a SyncObserver. Only values of the following
 * types may be used in the extras bundle:
 * <ul>
 * <li>Integer</li>
 * <li>Long</li>
 * <li>Boolean</li>
 * <li>Float</li>
 * <li>Double</li>
 * <li>String</li>
 * <li>Account</li>
 * <li>null</li>
 * </ul>
 *
 * @param account which account should be synced
 * @param authority which authority should be synced
 * @param extras any extras to pass to the SyncAdapter.
 */
",-1,,,-1,-1,-1,-1,-1,"2,3,4",2,5,1,The API implementation has changed from using ContentResolver's requestSync method to using SyncRequest.Builder to create a SyncRequest and then calling requestSync method with the created SyncRequest object. This is a dependent API change (type 5) because the API relies on a different method to achieve the same functionality.,"This change could potentially cause a compatibility issue (type 1) because the new implementation using SyncRequest.Builder may not handle the extras Bundle in the same way as the old implementation using ContentResolver's requestSync method. The documentation for the API mentions that only certain types of values may be used in the extras Bundle, and it's possible that the new implementation is more or less strict in enforcing this, which could lead to different behavior for apps that use this API."
498,"<android.view.Choreographer.FrameDisplayEventReceiver: void onVsync(long,int,int)>",20,21,"<android.view.Choreographer.FrameDisplayEventReceiver: void onVsync(long,int,int)>","<android.view.Choreographer.FrameDisplayEventReceiver: void onVsync(long,int,int)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(// that we need to fix this., []), AssignmentExpression(=, [VariableReference(if (builtInDisplayId !, []), Expression(SurfaceControl.BUILT_IN_DISPLAY_ID_MAIN) {, [])]), MethodCall(Log.d(TAG, ""Received vsync from secondary display, but we don't support "" + ""this case yet.  Choreographer needs a way to explicitly request "" + ""vsync for a specific display to ensure it doesn't lose track "" + ""of its scheduled vsync.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Received vsync from secondary display, []), Expression(but we don't support "" + ""this case yet.  Choreographer needs a way to explicitly request "" + ""vsync for a specific display to ensure it doesn't lose track "" + ""of its scheduled vsync."", [])]), Statement(scheduleVsync(), []), Statement(return, []), Statement(}, []), Statement(// Post the vsync event to the Handler., []), Statement(// The idea is to prevent incoming vsync events from completely starving, []), Statement(// the message queue.  If there are no messages in the queue with timestamps, []), Statement(// earlier than the frame time, then the vsync event will be processed immediately., []), Statement(// Otherwise, messages that predate the vsync event will be handled first., []), AssignmentExpression(=, [VariableReference(long now, []), Expression(System.nanoTime(), [])]), Statement(if (timestampNanos > now) {, []), MethodCall(Log.w(TAG, ""Frame time is "" + ((timestampNanos - now) * 0.000001f) + "" ms in the future!  Check that graphics HAL is generating vsync "" + ""timestamps using the correct timebase.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Frame time is "" + ((timestampNanos - now) * 0.000001f) + "" ms in the future!  Check that graphics HAL is generating vsync "" + ""timestamps using the correct timebase."", [])]), AssignmentExpression(=, [VariableReference(timestampNanos, []), Expression(now, [])]), Statement(}, []), Statement(if (mHavePendingVsync) {, []), MethodCall(Log.w(TAG, ""Already have a pending vsync event.  There should only be "" + ""one at a time.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Already have a pending vsync event.  There should only be "" + ""one at a time."", [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mHavePendingVsync, []), Expression(true, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(mTimestampNanos, []), Expression(timestampNanos, [])]), AssignmentExpression(=, [VariableReference(mFrame, []), Expression(frame, [])]), AssignmentExpression(=, [VariableReference(Message msg, []), Expression(Message.obtain(mHandler, this), [])]), MethodCall(msg.setAsynchronous(true), [VariableReference(msg, []), Expression(true, [])]), MethodCall(mHandler.sendMessageAtTime(msg, timestampNanos / NANOS_PER_MS), [VariableReference(mHandler, []), Expression(msg, []), Expression(timestampNanos / NANOS_PER_MS, [])]), Statement(}, [])])  Statement({, [])  Statement(// that we need to fix this., [])  AssignmentExpression(=, [VariableReference(if (builtInDisplayId !, []), Expression(SurfaceControl.BUILT_IN_DISPLAY_ID_MAIN) {, [])])    VariableReference(if (builtInDisplayId !, [])    Expression(SurfaceControl.BUILT_IN_DISPLAY_ID_MAIN) {, [])  MethodCall(Log.d(TAG, ""Received vsync from secondary display, but we don't support "" + ""this case yet.  Choreographer needs a way to explicitly request "" + ""vsync for a specific display to ensure it doesn't lose track "" + ""of its scheduled vsync.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Received vsync from secondary display, []), Expression(but we don't support "" + ""this case yet.  Choreographer needs a way to explicitly request "" + ""vsync for a specific display to ensure it doesn't lose track "" + ""of its scheduled vsync."", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Received vsync from secondary display, [])    Expression(but we don't support "" + ""this case yet.  Choreographer needs a way to explicitly request "" + ""vsync for a specific display to ensure it doesn't lose track "" + ""of its scheduled vsync."", [])  Statement(scheduleVsync(), [])  Statement(return, [])  Statement(}, [])  Statement(// Post the vsync event to the Handler., [])  Statement(// The idea is to prevent incoming vsync events from completely starving, [])  Statement(// the message queue.  If there are no messages in the queue with timestamps, [])  Statement(// earlier than the frame time, then the vsync event will be processed immediately., [])  Statement(// Otherwise, messages that predate the vsync event will be handled first., [])  AssignmentExpression(=, [VariableReference(long now, []), Expression(System.nanoTime(), [])])    VariableReference(long now, [])    Expression(System.nanoTime(), [])  Statement(if (timestampNanos > now) {, [])  MethodCall(Log.w(TAG, ""Frame time is "" + ((timestampNanos - now) * 0.000001f) + "" ms in the future!  Check that graphics HAL is generating vsync "" + ""timestamps using the correct timebase.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Frame time is "" + ((timestampNanos - now) * 0.000001f) + "" ms in the future!  Check that graphics HAL is generating vsync "" + ""timestamps using the correct timebase."", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Frame time is "" + ((timestampNanos - now) * 0.000001f) + "" ms in the future!  Check that graphics HAL is generating vsync "" + ""timestamps using the correct timebase."", [])  AssignmentExpression(=, [VariableReference(timestampNanos, []), Expression(now, [])])    VariableReference(timestampNanos, [])    Expression(now, [])  Statement(}, [])  Statement(if (mHavePendingVsync) {, [])  MethodCall(Log.w(TAG, ""Already have a pending vsync event.  There should only be "" + ""one at a time.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Already have a pending vsync event.  There should only be "" + ""one at a time."", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Already have a pending vsync event.  There should only be "" + ""one at a time."", [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mHavePendingVsync, []), Expression(true, [])])    VariableReference(mHavePendingVsync, [])    Expression(true, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mTimestampNanos, []), Expression(timestampNanos, [])])    VariableReference(mTimestampNanos, [])    Expression(timestampNanos, [])  AssignmentExpression(=, [VariableReference(mFrame, []), Expression(frame, [])])    VariableReference(mFrame, [])    Expression(frame, [])  AssignmentExpression(=, [VariableReference(Message msg, []), Expression(Message.obtain(mHandler, this), [])])    VariableReference(Message msg, [])    Expression(Message.obtain(mHandler, this), [])  MethodCall(msg.setAsynchronous(true), [VariableReference(msg, []), Expression(true, [])])    VariableReference(msg, [])    Expression(true, [])  MethodCall(mHandler.sendMessageAtTime(msg, timestampNanos / NANOS_PER_MS), [VariableReference(mHandler, []), Expression(msg, []), Expression(timestampNanos / NANOS_PER_MS, [])])    VariableReference(mHandler, [])    Expression(msg, [])    Expression(timestampNanos / NANOS_PER_MS, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(// that we need to fix this., []), AssignmentExpression(=, [VariableReference(if (builtInDisplayId !, []), Expression(SurfaceControl.BUILT_IN_DISPLAY_ID_MAIN) {, [])]), MethodCall(Log.d(TAG, ""Received vsync from secondary display, but we don't support "" + ""this case yet.  Choreographer needs a way to explicitly request "" + ""vsync for a specific display to ensure it doesn't lose track "" + ""of its scheduled vsync.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Received vsync from secondary display, []), Expression(but we don't support "" + ""this case yet.  Choreographer needs a way to explicitly request "" + ""vsync for a specific display to ensure it doesn't lose track "" + ""of its scheduled vsync."", [])]), Statement(scheduleVsync(), []), Statement(return, []), Statement(}, []), Statement(// Post the vsync event to the Handler., []), Statement(// The idea is to prevent incoming vsync events from completely starving, []), Statement(// the message queue.  If there are no messages in the queue with timestamps, []), Statement(// earlier than the frame time, then the vsync event will be processed immediately., []), Statement(// Otherwise, messages that predate the vsync event will be handled first., []), AssignmentExpression(=, [VariableReference(long now, []), Expression(System.nanoTime(), [])]), Statement(if (timestampNanos > now) {, []), MethodCall(Log.w(TAG, ""Frame time is "" + ((timestampNanos - now) * 0.000001f) + "" ms in the future!  Check that graphics HAL is generating vsync "" + ""timestamps using the correct timebase.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Frame time is "" + ((timestampNanos - now) * 0.000001f) + "" ms in the future!  Check that graphics HAL is generating vsync "" + ""timestamps using the correct timebase."", [])]), AssignmentExpression(=, [VariableReference(timestampNanos, []), Expression(now, [])]), Statement(}, []), Statement(if (mHavePendingVsync) {, []), MethodCall(Log.w(TAG, ""Already have a pending vsync event.  There should only be "" + ""one at a time.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Already have a pending vsync event.  There should only be "" + ""one at a time."", [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mHavePendingVsync, []), Expression(true, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(mTimestampNanos, []), Expression(timestampNanos, [])]), AssignmentExpression(=, [VariableReference(mFrame, []), Expression(frame, [])]), AssignmentExpression(=, [VariableReference(Message msg, []), Expression(Message.obtain(mHandler, this), [])]), MethodCall(msg.setAsynchronous(true), [VariableReference(msg, []), Expression(true, [])]), MethodCall(mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS), [VariableReference(mHandler, []), Expression(msg, []), Expression(timestampNanos / TimeUtils.NANOS_PER_MS, [])]), Statement(}, [])])  Statement({, [])  Statement(// that we need to fix this., [])  AssignmentExpression(=, [VariableReference(if (builtInDisplayId !, []), Expression(SurfaceControl.BUILT_IN_DISPLAY_ID_MAIN) {, [])])    VariableReference(if (builtInDisplayId !, [])    Expression(SurfaceControl.BUILT_IN_DISPLAY_ID_MAIN) {, [])  MethodCall(Log.d(TAG, ""Received vsync from secondary display, but we don't support "" + ""this case yet.  Choreographer needs a way to explicitly request "" + ""vsync for a specific display to ensure it doesn't lose track "" + ""of its scheduled vsync.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Received vsync from secondary display, []), Expression(but we don't support "" + ""this case yet.  Choreographer needs a way to explicitly request "" + ""vsync for a specific display to ensure it doesn't lose track "" + ""of its scheduled vsync."", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Received vsync from secondary display, [])    Expression(but we don't support "" + ""this case yet.  Choreographer needs a way to explicitly request "" + ""vsync for a specific display to ensure it doesn't lose track "" + ""of its scheduled vsync."", [])  Statement(scheduleVsync(), [])  Statement(return, [])  Statement(}, [])  Statement(// Post the vsync event to the Handler., [])  Statement(// The idea is to prevent incoming vsync events from completely starving, [])  Statement(// the message queue.  If there are no messages in the queue with timestamps, [])  Statement(// earlier than the frame time, then the vsync event will be processed immediately., [])  Statement(// Otherwise, messages that predate the vsync event will be handled first., [])  AssignmentExpression(=, [VariableReference(long now, []), Expression(System.nanoTime(), [])])    VariableReference(long now, [])    Expression(System.nanoTime(), [])  Statement(if (timestampNanos > now) {, [])  MethodCall(Log.w(TAG, ""Frame time is "" + ((timestampNanos - now) * 0.000001f) + "" ms in the future!  Check that graphics HAL is generating vsync "" + ""timestamps using the correct timebase.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Frame time is "" + ((timestampNanos - now) * 0.000001f) + "" ms in the future!  Check that graphics HAL is generating vsync "" + ""timestamps using the correct timebase."", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Frame time is "" + ((timestampNanos - now) * 0.000001f) + "" ms in the future!  Check that graphics HAL is generating vsync "" + ""timestamps using the correct timebase."", [])  AssignmentExpression(=, [VariableReference(timestampNanos, []), Expression(now, [])])    VariableReference(timestampNanos, [])    Expression(now, [])  Statement(}, [])  Statement(if (mHavePendingVsync) {, [])  MethodCall(Log.w(TAG, ""Already have a pending vsync event.  There should only be "" + ""one at a time.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Already have a pending vsync event.  There should only be "" + ""one at a time."", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Already have a pending vsync event.  There should only be "" + ""one at a time."", [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mHavePendingVsync, []), Expression(true, [])])    VariableReference(mHavePendingVsync, [])    Expression(true, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mTimestampNanos, []), Expression(timestampNanos, [])])    VariableReference(mTimestampNanos, [])    Expression(timestampNanos, [])  AssignmentExpression(=, [VariableReference(mFrame, []), Expression(frame, [])])    VariableReference(mFrame, [])    Expression(frame, [])  AssignmentExpression(=, [VariableReference(Message msg, []), Expression(Message.obtain(mHandler, this), [])])    VariableReference(Message msg, [])    Expression(Message.obtain(mHandler, this), [])  MethodCall(msg.setAsynchronous(true), [VariableReference(msg, []), Expression(true, [])])    VariableReference(msg, [])    Expression(true, [])  MethodCall(mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS), [VariableReference(mHandler, []), Expression(msg, []), Expression(timestampNanos / TimeUtils.NANOS_PER_MS, [])])    VariableReference(mHandler, [])    Expression(msg, [])    Expression(timestampNanos / TimeUtils.NANOS_PER_MS, [])  Statement(}, [])",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,5,0,5,0,"The only difference between the two versions is the use of `NANOS_PER_MS` constant. In early version, it is directly used as `NANOS_PER_MS` while in late version, it is accessed through `TimeUtils` class as `TimeUtils.NANOS_PER_MS`. However, this change does not affect the behavior of the API as `NANOS_PER_MS` is a constant and its value remains the same.","There is no Compatibility Issue (CI) exist for the API. The change in the use of `NANOS_PER_MS` constant does not affect the behavior of the API as its value remains the same. Therefore, the API will not return a different variable or throw an exception differently in the late version."
530,<android.view.View: AccessibilityNodeInfo createAccessibilityNodeInfo()>,17,18,<android.view.View: AccessibilityNodeInfo createAccessibilityNodeInfo()>,<android.view.View: AccessibilityNodeInfo createAccessibilityNodeInfo()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(AccessibilityNodeProvider provider, []), Expression(getAccessibilityNodeProvider(), [])]), AssignmentExpression(=, [VariableReference(if (provider !, []), Expression(null) {, [])]), MethodCall(return provider.createAccessibilityNodeInfo(View.NO_ID), [VariableReference(return provider, []), Expression(View.NO_ID, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(AccessibilityNodeInfo info, []), Expression(AccessibilityNodeInfo.obtain(this), [])]), Statement(onInitializeAccessibilityNodeInfo(info), []), Statement(return info, []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(AccessibilityNodeProvider provider, []), Expression(getAccessibilityNodeProvider(), [])])    VariableReference(AccessibilityNodeProvider provider, [])    Expression(getAccessibilityNodeProvider(), [])  AssignmentExpression(=, [VariableReference(if (provider !, []), Expression(null) {, [])])    VariableReference(if (provider !, [])    Expression(null) {, [])  MethodCall(return provider.createAccessibilityNodeInfo(View.NO_ID), [VariableReference(return provider, []), Expression(View.NO_ID, [])])    VariableReference(return provider, [])    Expression(View.NO_ID, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(AccessibilityNodeInfo info, []), Expression(AccessibilityNodeInfo.obtain(this), [])])    VariableReference(AccessibilityNodeInfo info, [])    Expression(AccessibilityNodeInfo.obtain(this), [])  Statement(onInitializeAccessibilityNodeInfo(info), [])  Statement(return info, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mAccessibilityDelegate !, []), Expression(null) {, [])]), MethodCall(return mAccessibilityDelegate.createAccessibilityNodeInfo(this), [VariableReference(return mAccessibilityDelegate, []), Expression(this, [])]), Statement(} else {, []), Statement(return createAccessibilityNodeInfoInternal(), []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mAccessibilityDelegate !, []), Expression(null) {, [])])    VariableReference(if (mAccessibilityDelegate !, [])    Expression(null) {, [])  MethodCall(return mAccessibilityDelegate.createAccessibilityNodeInfo(this), [VariableReference(return mAccessibilityDelegate, []), Expression(this, [])])    VariableReference(return mAccessibilityDelegate, [])    Expression(this, [])  Statement(} else {, [])  Statement(return createAccessibilityNodeInfoInternal(), [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Returns an {@link AccessibilityNodeInfo} representing this view from the
 * point of view of an {@link android.accessibilityservice.AccessibilityService}.
 * This method is responsible for obtaining an accessibility node info from a
 * pool of reusable instances and calling
 * {@link #onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo)} on this view to
 * initialize the former.
 * <p>
 * Note: The client is responsible for recycling the obtained instance by calling
 * {@link AccessibilityNodeInfo#recycle()} to minimize object creation.
 * </p>
 *
 * @return A populated {@link AccessibilityNodeInfo}.
 *
 * @see AccessibilityNodeInfo
 */
","/**
 * Returns an {@link AccessibilityNodeInfo} representing this view from the
 * point of view of an {@link android.accessibilityservice.AccessibilityService}.
 * This method is responsible for obtaining an accessibility node info from a
 * pool of reusable instances and calling
 * {@link #onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo)} on this view to
 * initialize the former.
 * <p>
 * Note: The client is responsible for recycling the obtained instance by calling
 * {@link AccessibilityNodeInfo#recycle()} to minimize object creation.
 * </p>
 *
 * @return A populated {@link AccessibilityNodeInfo}.
 *
 * @see AccessibilityNodeInfo
 */
",-1,,,-1,-1,-1,-1,-1,"1,3,4,5",1,"1,5",1,The variable 'provider' has been replaced by 'mAccessibilityDelegate'. The method 'createAccessibilityNodeInfo(View.NO_ID)' has been replaced by 'createAccessibilityNodeInfo(this)'. The method 'AccessibilityNodeInfo.obtain(this)' is replaced by 'createAccessibilityNodeInfoInternal()'. These changes cause the method to potentially return different values.,"The changes in the method parameters and method calls can potentially cause the method to return different values, which can lead to compatibility issues in the application."
1403,<android.app.WallpaperManager: Drawable peekDrawable()>,23,24,<android.app.WallpaperManager: Drawable peekDrawable()>,<android.app.WallpaperManager: Drawable peekDrawable()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(Bitmap bm, []), Expression(sGlobals.peekWallpaperBitmap(mContext, false), [])]), AssignmentExpression(=, [VariableReference(if (bm !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(Drawable dr, []), Expression(new BitmapDrawable(mContext.getResources(), bm), [])]), MethodCall(dr.setDither(false), [VariableReference(dr, []), Expression(false, [])]), Statement(return dr, []), Statement(}, []), Statement(return null, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(Bitmap bm, []), Expression(sGlobals.peekWallpaperBitmap(mContext, false), [])])    VariableReference(Bitmap bm, [])    Expression(sGlobals.peekWallpaperBitmap(mContext, false), [])  AssignmentExpression(=, [VariableReference(if (bm !, []), Expression(null) {, [])])    VariableReference(if (bm !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(Drawable dr, []), Expression(new BitmapDrawable(mContext.getResources(), bm), [])])    VariableReference(Drawable dr, [])    Expression(new BitmapDrawable(mContext.getResources(), bm), [])  MethodCall(dr.setDither(false), [VariableReference(dr, []), Expression(false, [])])    VariableReference(dr, [])    Expression(false, [])  Statement(return dr, [])  Statement(}, [])  Statement(return null, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(Bitmap bm, []), Expression(sGlobals.peekWallpaperBitmap(mContext, false, FLAG_SYSTEM), [])]), AssignmentExpression(=, [VariableReference(if (bm !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(Drawable dr, []), Expression(new BitmapDrawable(mContext.getResources(), bm), [])]), MethodCall(dr.setDither(false), [VariableReference(dr, []), Expression(false, [])]), Statement(return dr, []), Statement(}, []), Statement(return null, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(Bitmap bm, []), Expression(sGlobals.peekWallpaperBitmap(mContext, false, FLAG_SYSTEM), [])])    VariableReference(Bitmap bm, [])    Expression(sGlobals.peekWallpaperBitmap(mContext, false, FLAG_SYSTEM), [])  AssignmentExpression(=, [VariableReference(if (bm !, []), Expression(null) {, [])])    VariableReference(if (bm !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(Drawable dr, []), Expression(new BitmapDrawable(mContext.getResources(), bm), [])])    VariableReference(Drawable dr, [])    Expression(new BitmapDrawable(mContext.getResources(), bm), [])  MethodCall(dr.setDither(false), [VariableReference(dr, []), Expression(false, [])])    VariableReference(dr, [])    Expression(false, [])  Statement(return dr, [])  Statement(}, [])  Statement(return null, [])  Statement(}, [])",1,"/**
 * Retrieve the current system wallpaper; if there is no wallpaper set,
 * a null pointer is returned. This is returned as an
 * abstract Drawable that you can install in a View to display whatever
 * wallpaper the user has currently set.
 *
 * @return Returns a Drawable object that will draw the wallpaper or a
 * null pointer if these is none.
 */
","/**
 * Retrieve the current system wallpaper; if there is no wallpaper set,
 * a null pointer is returned. This is returned as an
 * abstract Drawable that you can install in a View to display whatever
 * wallpaper the user has currently set.
 *
 * @return Returns a Drawable object that will draw the wallpaper or a
 * null pointer if these is none.
 */
",-1,,,-1,-1,-1,-1,-1,5,0,5,1,"The code change is in the parameter of the method `sGlobals.peekWallpaperBitmap()`, from `false` to `false, FLAG_SYSTEM`. This is a Dependent API change.","The change of the parameter in the method `sGlobals.peekWallpaperBitmap()` may affect the value of `Bitmap bm`, which will further affect the value of `Drawable dr` and the return value of the method `peekDrawable()`. Therefore, it may cause a Compatibility Issue of potential different return values or types."
65,<android.app.VoiceInteractor: boolean unregisterOnDestroyedCallback(Runnable)>,29,30,<android.app.VoiceInteractor: boolean unregisterOnDestroyedCallback(Runnable)>,<android.app.VoiceInteractor: boolean unregisterOnDestroyedCallback(Runnable)>,0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(Preconditions.checkNotNull(callback), [VariableReference(Preconditions, []), Expression(callback, [])]), Statement(if (isDestroyed()) {, []), MethodCall(Log.w(TAG, ""Cannot interact with a destroyed voice interactor""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Cannot interact with a destroyed voice interactor"", [])]), Statement(return false, []), Statement(}, []), AssignmentExpression(=, [VariableReference(return mOnDestroyCallbacks.remove(callback) !, []), Expression(null, [])]), Statement(}, [])])  Statement({, [])  MethodCall(Preconditions.checkNotNull(callback), [VariableReference(Preconditions, []), Expression(callback, [])])    VariableReference(Preconditions, [])    Expression(callback, [])  Statement(if (isDestroyed()) {, [])  MethodCall(Log.w(TAG, ""Cannot interact with a destroyed voice interactor""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Cannot interact with a destroyed voice interactor"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Cannot interact with a destroyed voice interactor"", [])  Statement(return false, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(return mOnDestroyCallbacks.remove(callback) !, []), Expression(null, [])])    VariableReference(return mOnDestroyCallbacks.remove(callback) !, [])    Expression(null, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(Objects.requireNonNull(callback), [VariableReference(Objects, []), Expression(callback, [])]), Statement(if (isDestroyed()) {, []), MethodCall(Log.w(TAG, ""Cannot interact with a destroyed voice interactor""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Cannot interact with a destroyed voice interactor"", [])]), Statement(return false, []), Statement(}, []), AssignmentExpression(=, [VariableReference(return mOnDestroyCallbacks.remove(callback) !, []), Expression(null, [])]), Statement(}, [])])  Statement({, [])  MethodCall(Objects.requireNonNull(callback), [VariableReference(Objects, []), Expression(callback, [])])    VariableReference(Objects, [])    Expression(callback, [])  Statement(if (isDestroyed()) {, [])  MethodCall(Log.w(TAG, ""Cannot interact with a destroyed voice interactor""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Cannot interact with a destroyed voice interactor"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Cannot interact with a destroyed voice interactor"", [])  Statement(return false, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(return mOnDestroyCallbacks.remove(callback) !, []), Expression(null, [])])    VariableReference(return mOnDestroyCallbacks.remove(callback) !, [])    Expression(null, [])  Statement(}, [])",1,"/**
 * Unregisters a previously registered onDestroy callback
 *
 * @param callback The callback to remove.
 * @return whether the callback was unregistered.
 */
","/**
 * Unregisters a previously registered onDestroy callback
 *
 * @param callback The callback to remove.
 * @return whether the callback was unregistered.
 */
",-1,,,-1,-1,-1,-1,-1,4,0,2,2,"The API has changed from using `Preconditions.checkNotNull(callback)` to `Objects.requireNonNull(callback)` to check if the input `callback` is null. This change can potentially lead to different exception handling behaviors as `Preconditions.checkNotNull(callback)` throws a `NullPointerException` with a custom error message, while `Objects.requireNonNull(callback)` throws a `NullPointerException` with a default error message.","The change in exception handling behavior can cause compatibility issues as the custom error message provided by `Preconditions.checkNotNull(callback)` may be used by the client code for error handling or logging, and the change to a default error message may break this functionality."
736,"<android.hardware.display.DisplayManager: VirtualDisplay createVirtualDisplay(String,int,int,int,Surface,int)>",20,21,"<android.hardware.display.DisplayManager: VirtualDisplay createVirtualDisplay(String,int,int,int,Surface,int)>","<android.hardware.display.DisplayManager: VirtualDisplay createVirtualDisplay(String,int,int,int,Surface,int)>",0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(return mGlobal.createVirtualDisplay(mContext, name, width, height, densityDpi, surface, flags), [VariableReference(return mGlobal, []), Expression(mContext, []), Expression(name, []), Expression(width, []), Expression(height, []), Expression(densityDpi, []), Expression(surface, []), Expression(flags, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return mGlobal.createVirtualDisplay(mContext, name, width, height, densityDpi, surface, flags), [VariableReference(return mGlobal, []), Expression(mContext, []), Expression(name, []), Expression(width, []), Expression(height, []), Expression(densityDpi, []), Expression(surface, []), Expression(flags, [])])    VariableReference(return mGlobal, [])    Expression(mContext, [])    Expression(name, [])    Expression(width, [])    Expression(height, [])    Expression(densityDpi, [])    Expression(surface, [])    Expression(flags, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return createVirtualDisplay(name, width, height, densityDpi, surface, flags, null, null), []), Statement(}, [])])  Statement({, [])  Statement(return createVirtualDisplay(name, width, height, densityDpi, surface, flags, null, null), [])  Statement(}, [])",1,"/**
 * Creates a virtual display.
 * <p>
 * The content of a virtual display is rendered to a {@link Surface} provided
 * by the application.
 * </p><p>
 * The virtual display should be {@link VirtualDisplay#release released}
 * when no longer needed.  Because a virtual display renders to a surface
 * provided by the application, it will be released automatically when the
 * process terminates and all remaining windows on it will be forcibly removed.
 * </p><p>
 * The behavior of the virtual display depends on the flags that are provided
 * to this method.  By default, virtual displays are created to be private,
 * non-presentation and unsecure.  Permissions may be required to use certain flags.
 * </p>
 *
 * @param name The name of the virtual display, must be non-empty.
 * @param width The width of the virtual display in pixels, must be greater than 0.
 * @param height The height of the virtual display in pixels, must be greater than 0.
 * @param densityDpi The density of the virtual display in dpi, must be greater than 0.
 * @param surface The surface to which the content of the virtual display should
 * be rendered, must be non-null.
 * @param flags A combination of virtual display flags:
 * {@link #VIRTUAL_DISPLAY_FLAG_PUBLIC}, {@link #VIRTUAL_DISPLAY_FLAG_PRESENTATION}
 * or {@link #VIRTUAL_DISPLAY_FLAG_SECURE}.
 * @return The newly created virtual display, or null if the application could
 * not create the virtual display.
 *
 * @throws SecurityException if the caller does not have permission to create
 * a virtual display with the specified flags.
 */
","/**
 * Creates a virtual display.
 *
 * @see #createVirtualDisplay(String, int, int, int, Surface, int, VirtualDisplay.Callback)
 */
",-1,,,-1,-1,-1,-1,-1,"1,4",1,5,1,"The implementation of the method has been changed from calling `mGlobal.createVirtualDisplay(mContext, name, width, height, densityDpi, surface, flags)` to `createVirtualDisplay(name, width, height, densityDpi, surface, flags, null, null)`. This indicates that the method used to create the virtual display has been modified, and is now a dependent API change.","This Compatibility Issue arises due to the potential of the method to return a different value in the late version. The change in the implementation of the method used to create the virtual display could lead to differences in the behavior of the method, and hence the returned virtual display object could also be different. This would impact the applications that rely on the specific behavior of the method in the early version."
138,<android.view.View: boolean hasFocusable()>,20,21,<android.view.View: boolean hasFocusable()>,<android.view.View: boolean hasFocusable()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(return (mViewFlags & VISIBILITY_MASK), []), Expression(, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(return (mViewFlags & VISIBILITY_MASK), []), Expression(, [])])    VariableReference(return (mViewFlags & VISIBILITY_MASK), [])    Expression(, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (!isFocusableInTouchMode()) {, []), AssignmentExpression(=, [VariableReference(for (ViewParent p, []), Expression(mParent, [])]), Statement(p instanceof ViewGroup, []), AssignmentExpression(=, [VariableReference(p, []), Expression(p.getParent()) {, [])]), AssignmentExpression(=, [VariableReference(final ViewGroup g, []), Expression((ViewGroup) p, [])]), MethodCall(if (g.shouldBlockFocusForTouchscreen()), [VariableReference(if (g, []), Expression(), [])]), Statement(return false, []), Statement(}, []), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(return (mViewFlags & VISIBILITY_MASK), []), Expression(, [])]), Statement(}, [])])  Statement({, [])  Statement(if (!isFocusableInTouchMode()) {, [])  AssignmentExpression(=, [VariableReference(for (ViewParent p, []), Expression(mParent, [])])    VariableReference(for (ViewParent p, [])    Expression(mParent, [])  Statement(p instanceof ViewGroup, [])  AssignmentExpression(=, [VariableReference(p, []), Expression(p.getParent()) {, [])])    VariableReference(p, [])    Expression(p.getParent()) {, [])  AssignmentExpression(=, [VariableReference(final ViewGroup g, []), Expression((ViewGroup) p, [])])    VariableReference(final ViewGroup g, [])    Expression((ViewGroup) p, [])  MethodCall(if (g.shouldBlockFocusForTouchscreen()), [VariableReference(if (g, []), Expression(), [])])    VariableReference(if (g, [])    Expression(), [])  Statement(return false, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(return (mViewFlags & VISIBILITY_MASK), []), Expression(, [])])    VariableReference(return (mViewFlags & VISIBILITY_MASK), [])    Expression(, [])  Statement(}, [])",1,"/**
 * Returns true if this view is focusable or if it contains a reachable View
 * for which {@link #hasFocusable()} returns true. A ""reachable hasFocusable()""
 * is a View whose parents do not block descendants focus.
 *
 * Only {@link #VISIBLE} views are considered focusable.
 *
 * @return True if the view is focusable or if the view contains a focusable
 * View, false otherwise.
 *
 * @see ViewGroup#FOCUS_BLOCK_DESCENDANTS
 */
","/**
 * Returns true if this view is focusable or if it contains a reachable View
 * for which {@link #hasFocusable()} returns true. A ""reachable hasFocusable()""
 * is a View whose parents do not block descendants focus.
 *
 * Only {@link #VISIBLE} views are considered focusable.
 *
 * @return True if the view is focusable or if the view contains a focusable
 * View, false otherwise.
 *
 * @see ViewGroup#FOCUS_BLOCK_DESCENDANTS
 * @see ViewGroup#getTouchscreenBlocksFocus()
 */
",-1,,,-1,-1,-1,-1,-1,"1,3",1,"1,3","1,2","The implementation of hasFocusable() method has been changed. In the early version, it only checks the visibility of the view. In the late version, it first checks if the view is focusable in touch mode, if not, it will return false. Then it checks the parents of the view, if any parent blocks the focus for touchscreen, it will also return false. Finally, it checks the visibility of the view.","The change in the implementation of hasFocusable() method may cause compatibility issues. In the early version, the method only considers the visibility of the view, so it may return true for a view that is not focusable in touch mode or whose parent blocks the focus for touchscreen. In the late version, the method considers these factors and may return false for such views. This may cause the behavior of the app to change unexpectedly when it is running on a device with a later version of the Android OS. The app may not be able to properly handle the focus of views, which may lead to a poor user experience."
352,<android.preference.PreferenceActivity: void switchToHeader(Header)>,20,21,<android.preference.PreferenceActivity: void switchToHeader(Header)>,<android.preference.PreferenceActivity: void switchToHeader(Header)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mCurHeader, []), Expression(, [])]), Statement(// This is the header we are currently displaying.  Just make sure, []), Statement(// to pop the stack up to its root state., []), MethodCall(getFragmentManager().popBackStack(BACK_STACK_PREFS, FragmentManager.POP_BACK_STACK_INCLUSIVE), [VariableReference(getFragmentManager(), []), Expression(BACK_STACK_PREFS, []), Expression(FragmentManager.POP_BACK_STACK_INCLUSIVE, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(if (header.fragment, []), Expression(, [])]), Statement(throw new IllegalStateException(""can't switch to header that has no fragment""), []), Statement(}, []), AssignmentExpression(=, [VariableReference(int direction, []), Expression(mHeaders.indexOf(header) - mHeaders.indexOf(mCurHeader), [])]), Statement(setSelectedHeader(header), []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mCurHeader, []), Expression(, [])])    VariableReference(if (mCurHeader, [])    Expression(, [])  Statement(// This is the header we are currently displaying.  Just make sure, [])  Statement(// to pop the stack up to its root state., [])  MethodCall(getFragmentManager().popBackStack(BACK_STACK_PREFS, FragmentManager.POP_BACK_STACK_INCLUSIVE), [VariableReference(getFragmentManager(), []), Expression(BACK_STACK_PREFS, []), Expression(FragmentManager.POP_BACK_STACK_INCLUSIVE, [])])    VariableReference(getFragmentManager(), [])    Expression(BACK_STACK_PREFS, [])    Expression(FragmentManager.POP_BACK_STACK_INCLUSIVE, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(if (header.fragment, []), Expression(, [])])    VariableReference(if (header.fragment, [])    Expression(, [])  Statement(throw new IllegalStateException(""can't switch to header that has no fragment""), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(int direction, []), Expression(mHeaders.indexOf(header) - mHeaders.indexOf(mCurHeader), [])])    VariableReference(int direction, [])    Expression(mHeaders.indexOf(header) - mHeaders.indexOf(mCurHeader), [])  Statement(setSelectedHeader(header), [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mCurHeader, []), Expression(, [])]), Statement(// This is the header we are currently displaying.  Just make sure, []), Statement(// to pop the stack up to its root state., []), MethodCall(getFragmentManager().popBackStack(BACK_STACK_PREFS, FragmentManager.POP_BACK_STACK_INCLUSIVE), [VariableReference(getFragmentManager(), []), Expression(BACK_STACK_PREFS, []), Expression(FragmentManager.POP_BACK_STACK_INCLUSIVE, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(if (header.fragment, []), Expression(, [])]), Statement(throw new IllegalStateException(""can't switch to header that has no fragment""), []), Statement(}, []), Statement(setSelectedHeader(header), []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mCurHeader, []), Expression(, [])])    VariableReference(if (mCurHeader, [])    Expression(, [])  Statement(// This is the header we are currently displaying.  Just make sure, [])  Statement(// to pop the stack up to its root state., [])  MethodCall(getFragmentManager().popBackStack(BACK_STACK_PREFS, FragmentManager.POP_BACK_STACK_INCLUSIVE), [VariableReference(getFragmentManager(), []), Expression(BACK_STACK_PREFS, []), Expression(FragmentManager.POP_BACK_STACK_INCLUSIVE, [])])    VariableReference(getFragmentManager(), [])    Expression(BACK_STACK_PREFS, [])    Expression(FragmentManager.POP_BACK_STACK_INCLUSIVE, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(if (header.fragment, []), Expression(, [])])    VariableReference(if (header.fragment, [])    Expression(, [])  Statement(throw new IllegalStateException(""can't switch to header that has no fragment""), [])  Statement(}, [])  Statement(setSelectedHeader(header), [])  Statement(}, [])  Statement(}, [])",1,"/**
 * When in two-pane mode, switch to the fragment pane to show the given
 * preference fragment.
 *
 * @param header The new header to display.
 */
","/**
 * When in two-pane mode, switch to the fragment pane to show the given
 * preference fragment.
 *
 * @param header The new header to display.
 */
",-1,,,-1,-1,-1,-1,-1,4,0,0,0,"There is no change between the two versions of the API. The AST nodes provided are identical, and there are no modifications to the method name, parameter types or number, or any other aspect of the API.","There is no compatibility issue between the two versions of the API. The API behaves exactly the same way in both versions, and there is no potential for different return values or types, or different exception handlings."
551,<android.view.View: void setAutofillId(AutofillId)>,28,29,<android.view.View: void setAutofillId(AutofillId)>,<android.view.View: void setAutofillId(AutofillId)>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(// TODO(b/37566627): add unit / CTS test for all possible combinations below, []), MethodCall(Log.v(VIEW_LOG_TAG, ""setAutofill(): from "" + mAutofillId + "" to "" + id), [VariableReference(Log, []), Expression(VIEW_LOG_TAG, []), Expression(""setAutofill(): from "" + mAutofillId + "" to "" + id, [])]), Statement(}, []), Statement(if (isAttachedToWindow()) {, []), Statement(throw new IllegalStateException(""Cannot set autofill id when view is attached""), []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (id !, []), Expression(null && id.isVirtual()) {, [])]), Statement(throw new IllegalStateException(""Cannot set autofill id assigned to virtual views""), []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (id, []), Expression(, [])]), Statement(// Ignore reset because it was never explicitly set before., []), Statement(return, []), Statement(}, []), AssignmentExpression(=, [VariableReference(mAutofillId, []), Expression(id, [])]), AssignmentExpression(=, [VariableReference(if (id !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(mAutofillViewId, []), Expression(id.getViewId(), [])]), AssignmentExpression(=, [VariableReference(mPrivateFlags3 |, []), Expression(PFLAG3_AUTOFILLID_EXPLICITLY_SET, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mAutofillViewId, []), Expression(NO_ID, [])]), AssignmentExpression(=, [VariableReference(mPrivateFlags3 &, []), Expression(~PFLAG3_AUTOFILLID_EXPLICITLY_SET, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(// TODO(b/37566627): add unit / CTS test for all possible combinations below, [])  MethodCall(Log.v(VIEW_LOG_TAG, ""setAutofill(): from "" + mAutofillId + "" to "" + id), [VariableReference(Log, []), Expression(VIEW_LOG_TAG, []), Expression(""setAutofill(): from "" + mAutofillId + "" to "" + id, [])])    VariableReference(Log, [])    Expression(VIEW_LOG_TAG, [])    Expression(""setAutofill(): from "" + mAutofillId + "" to "" + id, [])  Statement(}, [])  Statement(if (isAttachedToWindow()) {, [])  Statement(throw new IllegalStateException(""Cannot set autofill id when view is attached""), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (id !, []), Expression(null && id.isVirtual()) {, [])])    VariableReference(if (id !, [])    Expression(null && id.isVirtual()) {, [])  Statement(throw new IllegalStateException(""Cannot set autofill id assigned to virtual views""), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (id, []), Expression(, [])])    VariableReference(if (id, [])    Expression(, [])  Statement(// Ignore reset because it was never explicitly set before., [])  Statement(return, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mAutofillId, []), Expression(id, [])])    VariableReference(mAutofillId, [])    Expression(id, [])  AssignmentExpression(=, [VariableReference(if (id !, []), Expression(null) {, [])])    VariableReference(if (id !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(mAutofillViewId, []), Expression(id.getViewId(), [])])    VariableReference(mAutofillViewId, [])    Expression(id.getViewId(), [])  AssignmentExpression(=, [VariableReference(mPrivateFlags3 |, []), Expression(PFLAG3_AUTOFILLID_EXPLICITLY_SET, [])])    VariableReference(mPrivateFlags3 |, [])    Expression(PFLAG3_AUTOFILLID_EXPLICITLY_SET, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mAutofillViewId, []), Expression(NO_ID, [])])    VariableReference(mAutofillViewId, [])    Expression(NO_ID, [])  AssignmentExpression(=, [VariableReference(mPrivateFlags3 &, []), Expression(~PFLAG3_AUTOFILLID_EXPLICITLY_SET, [])])    VariableReference(mPrivateFlags3 &, [])    Expression(~PFLAG3_AUTOFILLID_EXPLICITLY_SET, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(// TODO(b/37566627): add unit / CTS test for all possible combinations below, []), MethodCall(if (Log.isLoggable(AUTOFILL_LOG_TAG, Log.VERBOSE)), [VariableReference(if (Log, []), Expression(AUTOFILL_LOG_TAG, []), Expression(Log.VERBOSE), [])]), MethodCall(Log.v(AUTOFILL_LOG_TAG, ""setAutofill(): from "" + mAutofillId + "" to "" + id), [VariableReference(Log, []), Expression(AUTOFILL_LOG_TAG, []), Expression(""setAutofill(): from "" + mAutofillId + "" to "" + id, [])]), Statement(}, []), Statement(if (isAttachedToWindow()) {, []), Statement(throw new IllegalStateException(""Cannot set autofill id when view is attached""), []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (id !, []), Expression(null && !id.isNonVirtual()) {, [])]), Statement(throw new IllegalStateException(""Cannot set autofill id assigned to virtual views""), []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (id, []), Expression(, [])]), Statement(// Ignore reset because it was never explicitly set before., []), Statement(return, []), Statement(}, []), AssignmentExpression(=, [VariableReference(mAutofillId, []), Expression(id, [])]), AssignmentExpression(=, [VariableReference(if (id !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(mAutofillViewId, []), Expression(id.getViewId(), [])]), AssignmentExpression(=, [VariableReference(mPrivateFlags3 |, []), Expression(PFLAG3_AUTOFILLID_EXPLICITLY_SET, [])]), Statement(} else {, []), AssignmentExpression(=, [VariableReference(mAutofillViewId, []), Expression(NO_ID, [])]), AssignmentExpression(=, [VariableReference(mPrivateFlags3 &, []), Expression(~PFLAG3_AUTOFILLID_EXPLICITLY_SET, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(// TODO(b/37566627): add unit / CTS test for all possible combinations below, [])  MethodCall(if (Log.isLoggable(AUTOFILL_LOG_TAG, Log.VERBOSE)), [VariableReference(if (Log, []), Expression(AUTOFILL_LOG_TAG, []), Expression(Log.VERBOSE), [])])    VariableReference(if (Log, [])    Expression(AUTOFILL_LOG_TAG, [])    Expression(Log.VERBOSE), [])  MethodCall(Log.v(AUTOFILL_LOG_TAG, ""setAutofill(): from "" + mAutofillId + "" to "" + id), [VariableReference(Log, []), Expression(AUTOFILL_LOG_TAG, []), Expression(""setAutofill(): from "" + mAutofillId + "" to "" + id, [])])    VariableReference(Log, [])    Expression(AUTOFILL_LOG_TAG, [])    Expression(""setAutofill(): from "" + mAutofillId + "" to "" + id, [])  Statement(}, [])  Statement(if (isAttachedToWindow()) {, [])  Statement(throw new IllegalStateException(""Cannot set autofill id when view is attached""), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (id !, []), Expression(null && !id.isNonVirtual()) {, [])])    VariableReference(if (id !, [])    Expression(null && !id.isNonVirtual()) {, [])  Statement(throw new IllegalStateException(""Cannot set autofill id assigned to virtual views""), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (id, []), Expression(, [])])    VariableReference(if (id, [])    Expression(, [])  Statement(// Ignore reset because it was never explicitly set before., [])  Statement(return, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mAutofillId, []), Expression(id, [])])    VariableReference(mAutofillId, [])    Expression(id, [])  AssignmentExpression(=, [VariableReference(if (id !, []), Expression(null) {, [])])    VariableReference(if (id !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(mAutofillViewId, []), Expression(id.getViewId(), [])])    VariableReference(mAutofillViewId, [])    Expression(id.getViewId(), [])  AssignmentExpression(=, [VariableReference(mPrivateFlags3 |, []), Expression(PFLAG3_AUTOFILLID_EXPLICITLY_SET, [])])    VariableReference(mPrivateFlags3 |, [])    Expression(PFLAG3_AUTOFILLID_EXPLICITLY_SET, [])  Statement(} else {, [])  AssignmentExpression(=, [VariableReference(mAutofillViewId, []), Expression(NO_ID, [])])    VariableReference(mAutofillViewId, [])    Expression(NO_ID, [])  AssignmentExpression(=, [VariableReference(mPrivateFlags3 &, []), Expression(~PFLAG3_AUTOFILLID_EXPLICITLY_SET, [])])    VariableReference(mPrivateFlags3 &, [])    Expression(~PFLAG3_AUTOFILLID_EXPLICITLY_SET, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Sets the unique, logical identifier of this view in the activity, for autofill purposes.
 *
 * <p>The autofill id is created on demand, and this method should only be called when a view is
 * reused after {@link #dispatchProvideAutofillStructure(ViewStructure, int)} is called, as
 * that method creates a snapshot of the view that is passed along to the autofill service.
 *
 * <p>This method is typically used when view subtrees are recycled to represent different
 * content* &mdash;in this case, the autofill id can be saved before the view content is swapped
 * out, and restored later when it's swapped back in. For example:
 *
 * <pre>
 * EditText reusableView = ...;
 * ViewGroup parentView = ...;
 * AutofillManager afm = ...;
 *
 * // Swap out the view and change its contents
 * AutofillId oldId = reusableView.getAutofillId();
 * CharSequence oldText = reusableView.getText();
 * parentView.removeView(reusableView);
 * AutofillId newId = afm.getNextAutofillId();
 * reusableView.setText(""New I am"");
 * reusableView.setAutofillId(newId);
 * parentView.addView(reusableView);
 *
 * // Later, swap the old content back in
 * parentView.removeView(reusableView);
 * reusableView.setAutofillId(oldId);
 * reusableView.setText(oldText);
 * parentView.addView(reusableView);
 * </pre>
 *
 * @param id an autofill ID that is unique in the {@link android.app.Activity} hosting the view,
 * or {@code null} to reset it. Usually it's an id previously allocated to another view (and
 * obtained through {@link #getAutofillId()}), or a new value obtained through
 * {@link AutofillManager#getNextAutofillId()}.
 *
 * @throws IllegalStateException if the view is already {@link #isAttachedToWindow() attached to
 * a window}.
 *
 * @throws IllegalArgumentException if the id is an autofill id associated with a virtual view.
 */
","/**
 * Sets the unique, logical identifier of this view in the activity, for autofill purposes.
 *
 * <p>The autofill id is created on demand, and this method should only be called when a view is
 * reused after {@link #dispatchProvideAutofillStructure(ViewStructure, int)} is called, as
 * that method creates a snapshot of the view that is passed along to the autofill service.
 *
 * <p>This method is typically used when view subtrees are recycled to represent different
 * content* &mdash;in this case, the autofill id can be saved before the view content is swapped
 * out, and restored later when it's swapped back in. For example:
 *
 * <pre>
 * EditText reusableView = ...;
 * ViewGroup parentView = ...;
 * AutofillManager afm = ...;
 *
 * // Swap out the view and change its contents
 * AutofillId oldId = reusableView.getAutofillId();
 * CharSequence oldText = reusableView.getText();
 * parentView.removeView(reusableView);
 * AutofillId newId = afm.getNextAutofillId();
 * reusableView.setText(""New I am"");
 * reusableView.setAutofillId(newId);
 * parentView.addView(reusableView);
 *
 * // Later, swap the old content back in
 * parentView.removeView(reusableView);
 * reusableView.setAutofillId(oldId);
 * reusableView.setText(oldText);
 * parentView.addView(reusableView);
 * </pre>
 *
 * @param id an autofill ID that is unique in the {@link android.app.Activity} hosting the view,
 * or {@code null} to reset it. Usually it's an id previously allocated to another view (and
 * obtained through {@link #getAutofillId()}), or a new value obtained through
 * {@link AutofillManager#getNextAutofillId()}.
 *
 * @throws IllegalStateException if the view is already {@link #isAttachedToWindow() attached to
 * a window}.
 *
 * @throws IllegalArgumentException if the id is an autofill id associated with a virtual view.
 */
",-1,,,-1,-1,-1,-1,-1,"2,3,4",2,"3,4",1,The implementation of the API has been changed in the following ways:,3) A new 'if' statement has been added to check whether the Log is enabled for the AUTOFILL_LOG_TAG at the VERBOSE level.
363,"<android.app.ContextImpl: void sendOrderedBroadcast(Intent,String)>",16,17,"<android.app.ContextImpl: void sendOrderedBroadcast(Intent,String)>","<android.app.ContextImpl: void sendOrderedBroadcast(Intent,String)>",0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(String resolvedType, []), Expression(intent.resolveTypeIfNeeded(getContentResolver()), [])]), Statement(try {, []), MethodCall(intent.setAllowFds(false), [VariableReference(intent, []), Expression(false, [])]), MethodCall(ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermission, true, false, Binder.getOrigCallingUser()), [VariableReference(ActivityManagerNative, []), Expression().broadcastIntent(mMainThread.getApplicationThread(), []), Expression(intent, []), Expression(resolvedType, []), Expression(null, []), Expression(Activity.RESULT_OK, []), Expression(null, []), Expression(null, []), Expression(receiverPermission, []), Expression(true, []), Expression(false, []), Expression(Binder.getOrigCallingUser(), [])]), Statement(} catch (RemoteException e) {, []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(String resolvedType, []), Expression(intent.resolveTypeIfNeeded(getContentResolver()), [])])    VariableReference(String resolvedType, [])    Expression(intent.resolveTypeIfNeeded(getContentResolver()), [])  Statement(try {, [])  MethodCall(intent.setAllowFds(false), [VariableReference(intent, []), Expression(false, [])])    VariableReference(intent, [])    Expression(false, [])  MethodCall(ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermission, true, false, Binder.getOrigCallingUser()), [VariableReference(ActivityManagerNative, []), Expression().broadcastIntent(mMainThread.getApplicationThread(), []), Expression(intent, []), Expression(resolvedType, []), Expression(null, []), Expression(Activity.RESULT_OK, []), Expression(null, []), Expression(null, []), Expression(receiverPermission, []), Expression(true, []), Expression(false, []), Expression(Binder.getOrigCallingUser(), [])])    VariableReference(ActivityManagerNative, [])    Expression().broadcastIntent(mMainThread.getApplicationThread(), [])    Expression(intent, [])    Expression(resolvedType, [])    Expression(null, [])    Expression(Activity.RESULT_OK, [])    Expression(null, [])    Expression(null, [])    Expression(receiverPermission, [])    Expression(true, [])    Expression(false, [])    Expression(Binder.getOrigCallingUser(), [])  Statement(} catch (RemoteException e) {, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(warnIfCallingFromSystemProcess(), []), AssignmentExpression(=, [VariableReference(String resolvedType, []), Expression(intent.resolveTypeIfNeeded(getContentResolver()), [])]), Statement(try {, []), MethodCall(intent.setAllowFds(false), [VariableReference(intent, []), Expression(false, [])]), MethodCall(ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermission, true, false, getUserId()), [VariableReference(ActivityManagerNative, []), Expression().broadcastIntent(mMainThread.getApplicationThread(), []), Expression(intent, []), Expression(resolvedType, []), Expression(null, []), Expression(Activity.RESULT_OK, []), Expression(null, []), Expression(null, []), Expression(receiverPermission, []), Expression(true, []), Expression(false, []), Expression(getUserId(), [])]), Statement(} catch (RemoteException e) {, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(warnIfCallingFromSystemProcess(), [])  AssignmentExpression(=, [VariableReference(String resolvedType, []), Expression(intent.resolveTypeIfNeeded(getContentResolver()), [])])    VariableReference(String resolvedType, [])    Expression(intent.resolveTypeIfNeeded(getContentResolver()), [])  Statement(try {, [])  MethodCall(intent.setAllowFds(false), [VariableReference(intent, []), Expression(false, [])])    VariableReference(intent, [])    Expression(false, [])  MethodCall(ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermission, true, false, getUserId()), [VariableReference(ActivityManagerNative, []), Expression().broadcastIntent(mMainThread.getApplicationThread(), []), Expression(intent, []), Expression(resolvedType, []), Expression(null, []), Expression(Activity.RESULT_OK, []), Expression(null, []), Expression(null, []), Expression(receiverPermission, []), Expression(true, []), Expression(false, []), Expression(getUserId(), [])])    VariableReference(ActivityManagerNative, [])    Expression().broadcastIntent(mMainThread.getApplicationThread(), [])    Expression(intent, [])    Expression(resolvedType, [])    Expression(null, [])    Expression(Activity.RESULT_OK, [])    Expression(null, [])    Expression(null, [])    Expression(receiverPermission, [])    Expression(true, [])    Expression(false, [])    Expression(getUserId(), [])  Statement(} catch (RemoteException e) {, [])  Statement(}, [])  Statement(}, [])",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,"4,5",1,5,"1,2",The following changes have been made between the two versions:,"3. The `broadcastIntent` method now has 11 parameters, while in the earlier version it had only 10."
729,<android.widget.AdapterView: int getPositionForView(View)>,22,23,<android.widget.AdapterView: int getPositionForView(View)>,<android.widget.AdapterView: int getPositionForView(View)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(View listItem, []), Expression(view, [])]), Statement(try {, []), Statement(View v, []), AssignmentExpression(=, [VariableReference(while (!(v, []), Expression((View) listItem.getParent()).equals(this)) {, [])]), AssignmentExpression(=, [VariableReference(listItem, []), Expression(v, [])]), Statement(}, []), Statement(} catch (ClassCastException e) {, []), Statement(// We made it up to the window without find this list view, []), Statement(return INVALID_POSITION, []), Statement(}, []), Statement(// Search the children for the list item, []), AssignmentExpression(=, [VariableReference(final int childCount, []), Expression(getChildCount(), [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < childCount, []), Statement(i++) {, []), MethodCall(if (getChildAt(i).equals(listItem)), [VariableReference(if (getChildAt(i), []), Expression(listItem), [])]), Statement(return mFirstPosition + i, []), Statement(}, []), Statement(}, []), Statement(// Child not found!, []), Statement(return INVALID_POSITION, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(View listItem, []), Expression(view, [])])    VariableReference(View listItem, [])    Expression(view, [])  Statement(try {, [])  Statement(View v, [])  AssignmentExpression(=, [VariableReference(while (!(v, []), Expression((View) listItem.getParent()).equals(this)) {, [])])    VariableReference(while (!(v, [])    Expression((View) listItem.getParent()).equals(this)) {, [])  AssignmentExpression(=, [VariableReference(listItem, []), Expression(v, [])])    VariableReference(listItem, [])    Expression(v, [])  Statement(}, [])  Statement(} catch (ClassCastException e) {, [])  Statement(// We made it up to the window without find this list view, [])  Statement(return INVALID_POSITION, [])  Statement(}, [])  Statement(// Search the children for the list item, [])  AssignmentExpression(=, [VariableReference(final int childCount, []), Expression(getChildCount(), [])])    VariableReference(final int childCount, [])    Expression(getChildCount(), [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < childCount, [])  Statement(i++) {, [])  MethodCall(if (getChildAt(i).equals(listItem)), [VariableReference(if (getChildAt(i), []), Expression(listItem), [])])    VariableReference(if (getChildAt(i), [])    Expression(listItem), [])  Statement(return mFirstPosition + i, [])  Statement(}, [])  Statement(}, [])  Statement(// Child not found!, [])  Statement(return INVALID_POSITION, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(View listItem, []), Expression(view, [])]), Statement(try {, []), Statement(View v, []), AssignmentExpression(=, [VariableReference(while ((v, []), Expression((View) listItem.getParent()) !, [])]), AssignmentExpression(=, [VariableReference(listItem, []), Expression(v, [])]), Statement(}, []), Statement(} catch (ClassCastException e) {, []), Statement(// We made it up to the window without find this list view, []), Statement(return INVALID_POSITION, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (listItem !, []), Expression(null) {, [])]), Statement(// Search the children for the list item, []), AssignmentExpression(=, [VariableReference(final int childCount, []), Expression(getChildCount(), [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < childCount, []), Statement(i++) {, []), MethodCall(if (getChildAt(i).equals(listItem)), [VariableReference(if (getChildAt(i), []), Expression(listItem), [])]), Statement(return mFirstPosition + i, []), Statement(}, []), Statement(}, []), Statement(}, []), Statement(// Child not found!, []), Statement(return INVALID_POSITION, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(View listItem, []), Expression(view, [])])    VariableReference(View listItem, [])    Expression(view, [])  Statement(try {, [])  Statement(View v, [])  AssignmentExpression(=, [VariableReference(while ((v, []), Expression((View) listItem.getParent()) !, [])])    VariableReference(while ((v, [])    Expression((View) listItem.getParent()) !, [])  AssignmentExpression(=, [VariableReference(listItem, []), Expression(v, [])])    VariableReference(listItem, [])    Expression(v, [])  Statement(}, [])  Statement(} catch (ClassCastException e) {, [])  Statement(// We made it up to the window without find this list view, [])  Statement(return INVALID_POSITION, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (listItem !, []), Expression(null) {, [])])    VariableReference(if (listItem !, [])    Expression(null) {, [])  Statement(// Search the children for the list item, [])  AssignmentExpression(=, [VariableReference(final int childCount, []), Expression(getChildCount(), [])])    VariableReference(final int childCount, [])    Expression(getChildCount(), [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < childCount, [])  Statement(i++) {, [])  MethodCall(if (getChildAt(i).equals(listItem)), [VariableReference(if (getChildAt(i), []), Expression(listItem), [])])    VariableReference(if (getChildAt(i), [])    Expression(listItem), [])  Statement(return mFirstPosition + i, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(// Child not found!, [])  Statement(return INVALID_POSITION, [])  Statement(}, [])",1,"/**
 * Get the position within the adapter's data set for the view, where view is a an adapter item
 * or a descendant of an adapter item.
 *
 * @param view an adapter item, or a descendant of an adapter item. This must be visible in this
 * AdapterView at the time of the call.
 * @return the position within the adapter's data set of the view, or {@link #INVALID_POSITION}
 * if the view does not correspond to a list item (or it is not currently visible).
 */
","/**
 * Get the position within the adapter's data set for the view, where view is a an adapter item
 * or a descendant of an adapter item.
 *
 * @param view an adapter item, or a descendant of an adapter item. This must be visible in this
 * AdapterView at the time of the call.
 * @return the position within the adapter's data set of the view, or {@link #INVALID_POSITION}
 * if the view does not correspond to a list item (or it is not currently visible).
 */
",-1,,,-1,-1,-1,-1,-1,3,1,3,1,The condition in the while loop has been changed from "!(v" to "((v". This may lead to different behaviors when the method is invoked.,"The Compatibility Issue arises due to the potential for the API to return different values. The change in the while loop condition may cause the method to iterate through the views differently, leading to a different position being returned for a given view."
768,<android.hardware.radio.RadioManager.ProgramInfo: boolean equals(Object)>,27,28,<android.hardware.radio.RadioManager.ProgramInfo: boolean equals(Object)>,<android.hardware.radio.RadioManager.ProgramInfo: boolean equals(Object)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (this, []), Expression(, [])]), Statement(return true, []), Statement(if (!(obj instanceof ProgramInfo)), []), Statement(return false, []), AssignmentExpression(=, [VariableReference(ProgramInfo other, []), Expression((ProgramInfo) obj, [])]), MethodCall(if (!mSelector.equals(other.getSelector())), [VariableReference(if (!mSelector, []), Expression(other.getSelector()), [])]), Statement(return false, []), AssignmentExpression(=, [VariableReference(if (mTuned !, []), Expression(other.isTuned()), [])]), Statement(return false, []), AssignmentExpression(=, [VariableReference(if (mStereo !, []), Expression(other.isStereo()), [])]), Statement(return false, []), AssignmentExpression(=, [VariableReference(if (mDigital !, []), Expression(other.isDigital()), [])]), Statement(return false, []), AssignmentExpression(=, [VariableReference(if (mFlags !, []), Expression(other.mFlags), [])]), Statement(return false, []), AssignmentExpression(=, [VariableReference(if (mSignalStrength !, []), Expression(other.getSignalStrength()), [])]), Statement(return false, []), AssignmentExpression(=, [VariableReference(if (mMetadata, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(if (other.getMetadata() !, []), Expression(null), [])]), Statement(return false, []), MethodCall(} else if (!mMetadata.equals(other.getMetadata())), [VariableReference(} else if (!mMetadata, []), Expression(other.getMetadata()), [])]), Statement(return false, []), MethodCall(if (!mVendorInfo.equals(other.mVendorInfo)), [VariableReference(if (!mVendorInfo, []), Expression(other.mVendorInfo), [])]), Statement(return false, []), Statement(return true, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (this, []), Expression(, [])])    VariableReference(if (this, [])    Expression(, [])  Statement(return true, [])  Statement(if (!(obj instanceof ProgramInfo)), [])  Statement(return false, [])  AssignmentExpression(=, [VariableReference(ProgramInfo other, []), Expression((ProgramInfo) obj, [])])    VariableReference(ProgramInfo other, [])    Expression((ProgramInfo) obj, [])  MethodCall(if (!mSelector.equals(other.getSelector())), [VariableReference(if (!mSelector, []), Expression(other.getSelector()), [])])    VariableReference(if (!mSelector, [])    Expression(other.getSelector()), [])  Statement(return false, [])  AssignmentExpression(=, [VariableReference(if (mTuned !, []), Expression(other.isTuned()), [])])    VariableReference(if (mTuned !, [])    Expression(other.isTuned()), [])  Statement(return false, [])  AssignmentExpression(=, [VariableReference(if (mStereo !, []), Expression(other.isStereo()), [])])    VariableReference(if (mStereo !, [])    Expression(other.isStereo()), [])  Statement(return false, [])  AssignmentExpression(=, [VariableReference(if (mDigital !, []), Expression(other.isDigital()), [])])    VariableReference(if (mDigital !, [])    Expression(other.isDigital()), [])  Statement(return false, [])  AssignmentExpression(=, [VariableReference(if (mFlags !, []), Expression(other.mFlags), [])])    VariableReference(if (mFlags !, [])    Expression(other.mFlags), [])  Statement(return false, [])  AssignmentExpression(=, [VariableReference(if (mSignalStrength !, []), Expression(other.getSignalStrength()), [])])    VariableReference(if (mSignalStrength !, [])    Expression(other.getSignalStrength()), [])  Statement(return false, [])  AssignmentExpression(=, [VariableReference(if (mMetadata, []), Expression(, [])])    VariableReference(if (mMetadata, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(if (other.getMetadata() !, []), Expression(null), [])])    VariableReference(if (other.getMetadata() !, [])    Expression(null), [])  Statement(return false, [])  MethodCall(} else if (!mMetadata.equals(other.getMetadata())), [VariableReference(} else if (!mMetadata, []), Expression(other.getMetadata()), [])])    VariableReference(} else if (!mMetadata, [])    Expression(other.getMetadata()), [])  Statement(return false, [])  MethodCall(if (!mVendorInfo.equals(other.mVendorInfo)), [VariableReference(if (!mVendorInfo, []), Expression(other.mVendorInfo), [])])    VariableReference(if (!mVendorInfo, [])    Expression(other.mVendorInfo), [])  Statement(return false, [])  Statement(return true, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (this, []), Expression(, [])]), Statement(return true, []), Statement(if (!(obj instanceof ProgramInfo)), []), Statement(return false, []), AssignmentExpression(=, [VariableReference(ProgramInfo other, []), Expression((ProgramInfo) obj, [])]), MethodCall(if (!Objects.equals(mSelector, other.mSelector)), [VariableReference(if (!Objects, []), Expression(mSelector, []), Expression(other.mSelector), [])]), Statement(return false, []), MethodCall(if (!Objects.equals(mLogicallyTunedTo, other.mLogicallyTunedTo)), [VariableReference(if (!Objects, []), Expression(mLogicallyTunedTo, []), Expression(other.mLogicallyTunedTo), [])]), Statement(return false, []), MethodCall(if (!Objects.equals(mPhysicallyTunedTo, other.mPhysicallyTunedTo)), [VariableReference(if (!Objects, []), Expression(mPhysicallyTunedTo, []), Expression(other.mPhysicallyTunedTo), [])]), Statement(return false, []), MethodCall(if (!Objects.equals(mRelatedContent, other.mRelatedContent)), [VariableReference(if (!Objects, []), Expression(mRelatedContent, []), Expression(other.mRelatedContent), [])]), Statement(return false, []), AssignmentExpression(=, [VariableReference(if (mInfoFlags !, []), Expression(other.mInfoFlags), [])]), Statement(return false, []), AssignmentExpression(=, [VariableReference(if (mSignalQuality !, []), Expression(other.mSignalQuality), [])]), Statement(return false, []), MethodCall(if (!Objects.equals(mMetadata, other.mMetadata)), [VariableReference(if (!Objects, []), Expression(mMetadata, []), Expression(other.mMetadata), [])]), Statement(return false, []), MethodCall(if (!Objects.equals(mVendorInfo, other.mVendorInfo)), [VariableReference(if (!Objects, []), Expression(mVendorInfo, []), Expression(other.mVendorInfo), [])]), Statement(return false, []), Statement(return true, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (this, []), Expression(, [])])    VariableReference(if (this, [])    Expression(, [])  Statement(return true, [])  Statement(if (!(obj instanceof ProgramInfo)), [])  Statement(return false, [])  AssignmentExpression(=, [VariableReference(ProgramInfo other, []), Expression((ProgramInfo) obj, [])])    VariableReference(ProgramInfo other, [])    Expression((ProgramInfo) obj, [])  MethodCall(if (!Objects.equals(mSelector, other.mSelector)), [VariableReference(if (!Objects, []), Expression(mSelector, []), Expression(other.mSelector), [])])    VariableReference(if (!Objects, [])    Expression(mSelector, [])    Expression(other.mSelector), [])  Statement(return false, [])  MethodCall(if (!Objects.equals(mLogicallyTunedTo, other.mLogicallyTunedTo)), [VariableReference(if (!Objects, []), Expression(mLogicallyTunedTo, []), Expression(other.mLogicallyTunedTo), [])])    VariableReference(if (!Objects, [])    Expression(mLogicallyTunedTo, [])    Expression(other.mLogicallyTunedTo), [])  Statement(return false, [])  MethodCall(if (!Objects.equals(mPhysicallyTunedTo, other.mPhysicallyTunedTo)), [VariableReference(if (!Objects, []), Expression(mPhysicallyTunedTo, []), Expression(other.mPhysicallyTunedTo), [])])    VariableReference(if (!Objects, [])    Expression(mPhysicallyTunedTo, [])    Expression(other.mPhysicallyTunedTo), [])  Statement(return false, [])  MethodCall(if (!Objects.equals(mRelatedContent, other.mRelatedContent)), [VariableReference(if (!Objects, []), Expression(mRelatedContent, []), Expression(other.mRelatedContent), [])])    VariableReference(if (!Objects, [])    Expression(mRelatedContent, [])    Expression(other.mRelatedContent), [])  Statement(return false, [])  AssignmentExpression(=, [VariableReference(if (mInfoFlags !, []), Expression(other.mInfoFlags), [])])    VariableReference(if (mInfoFlags !, [])    Expression(other.mInfoFlags), [])  Statement(return false, [])  AssignmentExpression(=, [VariableReference(if (mSignalQuality !, []), Expression(other.mSignalQuality), [])])    VariableReference(if (mSignalQuality !, [])    Expression(other.mSignalQuality), [])  Statement(return false, [])  MethodCall(if (!Objects.equals(mMetadata, other.mMetadata)), [VariableReference(if (!Objects, []), Expression(mMetadata, []), Expression(other.mMetadata), [])])    VariableReference(if (!Objects, [])    Expression(mMetadata, [])    Expression(other.mMetadata), [])  Statement(return false, [])  MethodCall(if (!Objects.equals(mVendorInfo, other.mVendorInfo)), [VariableReference(if (!Objects, []), Expression(mVendorInfo, []), Expression(other.mVendorInfo), [])])    VariableReference(if (!Objects, [])    Expression(mVendorInfo, [])    Expression(other.mVendorInfo), [])  Statement(return false, [])  Statement(return true, [])  Statement(}, [])",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,"1,3,4",1,"1,5",1,"The implementation of the equals method in the ProgramInfo class has been changed between version 27 and 28. The early implementation uses the '==' operator to compare the selector, tuned, stereo, digital, flags, and signal strength fields of the ProgramInfo object with the corresponding fields of the other object. The late implementation, on the other hand, uses the Objects.equals method to compare the selector, logicallyTunedTo, physicallyTunedTo, relatedContent, and vendorInfo fields, and uses the '==' operator to compare the infoFlags and signalQuality fields. This is a combination of code changes, including return statement changed (1), and dependent API changed (5).","The change in the implementation of the equals method can lead to compatibility issues. In particular, the use of the Objects.equals method in the late implementation to compare the selector, logicallyTunedTo, physicallyTunedTo, relatedContent, and vendorInfo fields can result in different behavior compared to the use of the '==' operator in the early implementation. This is because the Objects.equals method can handle null values and can also be overridden in subclasses to provide custom comparison logic, whereas the '==' operator simply checks if the two objects have the same memory address. Therefore, if a codebase that uses the early version of the ProgramInfo class is upgraded to the late version, the behavior of the equals method may change in unexpected ways, potentially leading to bugs or other issues."
264,<android.app.ContextImpl: int checkSelfPermission(String)>,30,31,<android.app.ContextImpl: int checkSelfPermission(String)>,<android.app.ContextImpl: int checkSelfPermission(String)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (permission, []), Expression(, [])]), Statement(throw new IllegalArgumentException(""permission is null""), []), Statement(}, []), MethodCall(return checkPermission(permission, Process.myPid(), Process.myUid()), [VariableReference(return checkPermission(permission, Process, []), Expression(), []), Expression(Process.myUid(), [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (permission, []), Expression(, [])])    VariableReference(if (permission, [])    Expression(, [])  Statement(throw new IllegalArgumentException(""permission is null""), [])  Statement(}, [])  MethodCall(return checkPermission(permission, Process.myPid(), Process.myUid()), [VariableReference(return checkPermission(permission, Process, []), Expression(), []), Expression(Process.myUid(), [])])    VariableReference(return checkPermission(permission, Process, [])    Expression(), [])    Expression(Process.myUid(), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (permission, []), Expression(, [])]), Statement(throw new IllegalArgumentException(""permission is null""), []), Statement(}, []), MethodCall(if (mParams.isRenouncedPermission(permission)), [VariableReference(if (mParams, []), Expression(permission), [])]), MethodCall(Log.v(TAG, ""Treating renounced permission "" + permission + "" as denied""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Treating renounced permission "" + permission + "" as denied"", [])]), Statement(return PERMISSION_DENIED, []), Statement(}, []), MethodCall(return checkPermission(permission, Process.myPid(), Process.myUid()), [VariableReference(return checkPermission(permission, Process, []), Expression(), []), Expression(Process.myUid(), [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (permission, []), Expression(, [])])    VariableReference(if (permission, [])    Expression(, [])  Statement(throw new IllegalArgumentException(""permission is null""), [])  Statement(}, [])  MethodCall(if (mParams.isRenouncedPermission(permission)), [VariableReference(if (mParams, []), Expression(permission), [])])    VariableReference(if (mParams, [])    Expression(permission), [])  MethodCall(Log.v(TAG, ""Treating renounced permission "" + permission + "" as denied""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Treating renounced permission "" + permission + "" as denied"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Treating renounced permission "" + permission + "" as denied"", [])  Statement(return PERMISSION_DENIED, [])  Statement(}, [])  MethodCall(return checkPermission(permission, Process.myPid(), Process.myUid()), [VariableReference(return checkPermission(permission, Process, []), Expression(), []), Expression(Process.myUid(), [])])    VariableReference(return checkPermission(permission, Process, [])    Expression(), [])    Expression(Process.myUid(), [])  Statement(}, [])",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,"1,3,4",1,"1,2,3",1,The code change between the two versions is as follows:,2. Exception handling statement changed: There is no change in exception handling statements.
1068,"<android.os.Vibrator: void vibrate(long[],int,AudioAttributes)>",25,26,"<android.os.Vibrator: void vibrate(long[],int,AudioAttributes)>","<android.os.Vibrator: void vibrate(long[],int,AudioAttributes)>",0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(vibrate(Process.myUid(), mPackageName, pattern, repeat, attributes), [VariableReference(vibrate(Process, []), Expression(), []), Expression(mPackageName, []), Expression(pattern, []), Expression(repeat, []), Expression(attributes, [])]), Statement(}, [])])  Statement({, [])  MethodCall(vibrate(Process.myUid(), mPackageName, pattern, repeat, attributes), [VariableReference(vibrate(Process, []), Expression(), []), Expression(mPackageName, []), Expression(pattern, []), Expression(repeat, []), Expression(attributes, [])])    VariableReference(vibrate(Process, [])    Expression(), [])    Expression(mPackageName, [])    Expression(pattern, [])    Expression(repeat, [])    Expression(attributes, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(// exceptions for compatibility purposes, []), AssignmentExpression(=, [VariableReference(if (repeat < -1 || repeat >, []), Expression(pattern.length) {, [])]), AssignmentExpression(=, [VariableReference(Log.e(TAG, ""vibrate called with repeat index out of bounds"" + "" (pattern.length, []), Expression("" + pattern.length + "", index, [])]), Statement(throw new ArrayIndexOutOfBoundsException(), []), Statement(}, []), Statement(try {, []), MethodCall(vibrate(VibrationEffect.createWaveform(pattern, repeat), attributes), [VariableReference(vibrate(VibrationEffect, []), Expression(pattern, []), Expression(repeat), []), Expression(attributes, [])]), Statement(} catch (IllegalArgumentException iae) {, []), MethodCall(Log.e(TAG, ""Failed to create VibrationEffect"", iae), [VariableReference(Log, []), Expression(TAG, []), Expression(""Failed to create VibrationEffect"", []), Expression(iae, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(// exceptions for compatibility purposes, [])  AssignmentExpression(=, [VariableReference(if (repeat < -1 || repeat >, []), Expression(pattern.length) {, [])])    VariableReference(if (repeat < -1 || repeat >, [])    Expression(pattern.length) {, [])  AssignmentExpression(=, [VariableReference(Log.e(TAG, ""vibrate called with repeat index out of bounds"" + "" (pattern.length, []), Expression("" + pattern.length + "", index, [])])    VariableReference(Log.e(TAG, ""vibrate called with repeat index out of bounds"" + "" (pattern.length, [])    Expression("" + pattern.length + "", index, [])  Statement(throw new ArrayIndexOutOfBoundsException(), [])  Statement(}, [])  Statement(try {, [])  MethodCall(vibrate(VibrationEffect.createWaveform(pattern, repeat), attributes), [VariableReference(vibrate(VibrationEffect, []), Expression(pattern, []), Expression(repeat), []), Expression(attributes, [])])    VariableReference(vibrate(VibrationEffect, [])    Expression(pattern, [])    Expression(repeat), [])    Expression(attributes, [])  Statement(} catch (IllegalArgumentException iae) {, [])  MethodCall(Log.e(TAG, ""Failed to create VibrationEffect"", iae), [VariableReference(Log, []), Expression(TAG, []), Expression(""Failed to create VibrationEffect"", []), Expression(iae, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Failed to create VibrationEffect"", [])    Expression(iae, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Vibrate with a given pattern.
 *
 * <p>
 * Pass in an array of ints that are the durations for which to turn on or off
 * the vibrator in milliseconds.  The first value indicates the number of milliseconds
 * to wait before turning the vibrator on.  The next value indicates the number of milliseconds
 * for which to keep the vibrator on before turning it off.  Subsequent values alternate
 * between durations in milliseconds to turn the vibrator off or to turn the vibrator on.
 * </p><p>
 * To cause the pattern to repeat, pass the index into the pattern array at which
 * to start the repeat, or -1 to disable repeating.
 * </p>
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#VIBRATE}.
 *
 * @param pattern an array of longs of times for which to turn the vibrator on or off.
 * @param repeat the index into pattern at which to repeat, or -1 if
 * you don't want to repeat.
 * @param attributes {@link AudioAttributes} corresponding to the vibration. For example,
 * specify {@link AudioAttributes#USAGE_ALARM} for alarm vibrations or
 * {@link AudioAttributes#USAGE_NOTIFICATION_RINGTONE} for
 * vibrations associated with incoming calls.
 */
","/**
 * Vibrate with a given pattern.
 *
 * <p>
 * Pass in an array of ints that are the durations for which to turn on or off
 * the vibrator in milliseconds.  The first value indicates the number of milliseconds
 * to wait before turning the vibrator on.  The next value indicates the number of milliseconds
 * for which to keep the vibrator on before turning it off.  Subsequent values alternate
 * between durations in milliseconds to turn the vibrator off or to turn the vibrator on.
 * </p><p>
 * To cause the pattern to repeat, pass the index into the pattern array at which
 * to start the repeat, or -1 to disable repeating.
 * </p>
 *
 * @param pattern an array of longs of times for which to turn the vibrator on or off.
 * @param repeat the index into pattern at which to repeat, or -1 if
 * you don't want to repeat.
 * @param attributes {@link AudioAttributes} corresponding to the vibration. For example,
 * specify {@link AudioAttributes#USAGE_ALARM} for alarm vibrations or
 * {@link AudioAttributes#USAGE_NOTIFICATION_RINGTONE} for
 * vibrations associated with incoming calls.
 *
 * @deprecated Use {@link #vibrate(VibrationEffect, AudioAttributes)} instead.
 */
",-1,,"[@Deprecated, @RequiresPermission(android.Manifest.permission.VIBRATE)]",-1,-1,-1,-1,-1,"2,3,4,5",2,"2,5",2,"The implementation of the vibrate method has been changed between the two versions. In the early version, the method directly calls the `vibrate` method with the `Process.myUid()`, `mPackageName`, `pattern`, `repeat`, and `attributes` as arguments. However, in the late version, the implementation has been updated to use the `VibrationEffect.createWaveform` method to create a `VibrationEffect` object with the `pattern` and `repeat` as arguments and then calls the `vibrate` method with the `VibrationEffect` object and `attributes` as arguments. Additionally, the late version includes an exception handling block for the `IllegalArgumentException` and a check for the `repeat` index to be within the bounds of the `pattern` array, which is not present in the early version.","The change in the implementation of the vibrate method between the two versions can potentially lead to compatibility issues. The use of the `VibrationEffect.createWaveform` method in the late version may result in a different vibration pattern than the one specified by the `pattern` and `repeat` arguments in the early version. This can cause unexpected behavior in apps that rely on the vibration pattern to convey information to the user or to provide haptic feedback. Additionally, the exception handling block for the `IllegalArgumentException` in the late version may result in the app crashing in cases where the early version would have continued to execute. The check for the `repeat` index in the late version may also result in the vibration pattern not being repeated in cases where the early version would have repeated it."
216,<android.app.UiAutomation: void setRunAsMonkey(boolean)>,30,31,<android.app.UiAutomation: void setRunAsMonkey(boolean)>,<android.app.UiAutomation: void setRunAsMonkey(boolean)>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(synchronized (mLock) {, []), Statement(throwIfNotConnectedLocked(), []), Statement(}, []), Statement(try {, []), MethodCall(ActivityManager.getService().setUserIsMonkey(enable), [VariableReference(ActivityManager, []), Expression().setUserIsMonkey(enable, [])]), Statement(} catch (RemoteException re) {, []), MethodCall(Log.e(LOG_TAG, ""Error while setting run as monkey!"", re), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""Error while setting run as monkey!"", []), Expression(re, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(synchronized (mLock) {, [])  Statement(throwIfNotConnectedLocked(), [])  Statement(}, [])  Statement(try {, [])  MethodCall(ActivityManager.getService().setUserIsMonkey(enable), [VariableReference(ActivityManager, []), Expression().setUserIsMonkey(enable, [])])    VariableReference(ActivityManager, [])    Expression().setUserIsMonkey(enable, [])  Statement(} catch (RemoteException re) {, [])  MethodCall(Log.e(LOG_TAG, ""Error while setting run as monkey!"", re), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""Error while setting run as monkey!"", []), Expression(re, [])])    VariableReference(Log, [])    Expression(LOG_TAG, [])    Expression(""Error while setting run as monkey!"", [])    Expression(re, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(ActivityManager.getService().setUserIsMonkey(enable), [VariableReference(ActivityManager, []), Expression().setUserIsMonkey(enable, [])]), Statement(} catch (RemoteException re) {, []), MethodCall(Log.e(LOG_TAG, ""Error while setting run as monkey!"", re), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""Error while setting run as monkey!"", []), Expression(re, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(ActivityManager.getService().setUserIsMonkey(enable), [VariableReference(ActivityManager, []), Expression().setUserIsMonkey(enable, [])])    VariableReference(ActivityManager, [])    Expression().setUserIsMonkey(enable, [])  Statement(} catch (RemoteException re) {, [])  MethodCall(Log.e(LOG_TAG, ""Error while setting run as monkey!"", re), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""Error while setting run as monkey!"", []), Expression(re, [])])    VariableReference(Log, [])    Expression(LOG_TAG, [])    Expression(""Error while setting run as monkey!"", [])    Expression(re, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Sets whether this UiAutomation to run in a ""monkey"" mode. Applications can query whether
 * they are executed in a ""monkey"" mode, i.e. run by a test framework, and avoid doing
 * potentially undesirable actions such as calling 911 or posting on public forums etc.
 *
 * @param enable whether to run in a ""monkey"" mode or not. Default is not.
 * @see ActivityManager#isUserAMonkey()
 */
","/**
 * Sets whether this UiAutomation to run in a ""monkey"" mode. Applications can query whether
 * they are executed in a ""monkey"" mode, i.e. run by a test framework, and avoid doing
 * potentially undesirable actions such as calling 911 or posting on public forums etc.
 *
 * @param enable whether to run in a ""monkey"" mode or not. Default is not.
 * @see ActivityManager#isUserAMonkey()
 */
",-1,,,-1,-1,-1,-1,-1,4,0,2,2,"The code change is that the 'synchronized (mLock)' block and the 'throwIfNotConnectedLocked()' statement are removed in the late version, which is related to exception handling.","The removal of 'synchronized (mLock)' block and 'throwIfNotConnectedLocked()' statement could lead to different behaviors in the late version, such as potential thread-safety issues and different exception handling. Therefore, it is a Compatibility Issue caused by potential different exception handling."
776,<android.os.PowerManager: boolean isPowerSaveMode()>,29,30,<android.os.PowerManager: boolean isPowerSaveMode()>,<android.os.PowerManager: boolean isPowerSaveMode()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(return mService.isPowerSaveMode(), [VariableReference(return mService, []), Expression(, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(return mService.isPowerSaveMode(), [VariableReference(return mService, []), Expression(, [])])    VariableReference(return mService, [])    Expression(, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(return mPowerSaveModeCache.query(null), [VariableReference(return mPowerSaveModeCache, []), Expression(null, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return mPowerSaveModeCache.query(null), [VariableReference(return mPowerSaveModeCache, []), Expression(null, [])])    VariableReference(return mPowerSaveModeCache, [])    Expression(null, [])  Statement(}, [])",1,"/**
 * Returns true if the device is currently in power save mode.  When in this mode,
 * applications should reduce their functionality in order to conserve battery as
 * much as possible.  You can monitor for changes to this state with
 * {@link #ACTION_POWER_SAVE_MODE_CHANGED}.
 *
 * @return Returns true if currently in low power mode, else false.
 */
","/**
 * Returns true if the device is currently in power save mode.  When in this mode,
 * applications should reduce their functionality in order to conserve battery as
 * much as possible.  You can monitor for changes to this state with
 * {@link #ACTION_POWER_SAVE_MODE_CHANGED}.
 *
 * @return Returns true if currently in low power mode, else false.
 */
",-1,,,-1,-1,-1,-1,-1,"1,2,4","1,2",5,1,"The implementation of the API ""isPowerSaveMode()"" has changed from ""return mService.isPowerSaveMode()"" to ""return mPowerSaveModeCache.query(null)"". This change is considered as a modification to the dependent API, so the code change type is 5.","As the implementation of the API ""isPowerSaveMode()"" has changed from ""return mService.isPowerSaveMode()"" to ""return mPowerSaveModeCache.query(null)"", it may potentially lead to different return values, which is considered as a Compatibility Issue. So the CI type is 1."
961,<android.webkit.WebSettings: void setUseWebViewBackgroundForOverscrollBackground(boolean)>,15,16,<android.webkit.WebSettings: void setUseWebViewBackgroundForOverscrollBackground(boolean)>,<android.webkit.WebSettings: void setUseWebViewBackgroundForOverscrollBackground(boolean)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(mUseWebViewBackgroundForOverscroll, []), Expression(view, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(mUseWebViewBackgroundForOverscroll, []), Expression(view, [])])    VariableReference(mUseWebViewBackgroundForOverscroll, [])    Expression(view, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(throw new MustOverrideException(), []), Statement(}, [])])  Statement({, [])  Statement(throw new MustOverrideException(), [])  Statement(}, [])",1,"/**
 * Set whether the WebView uses its background for over scroll background.
 * If true, it will use the WebView's background. If false, it will use an
 * internal pattern. Default is true.
 * @deprecated This method is now obsolete.
 */
","/**
 * Sets whether the WebView uses its background for over scroll background.
 * If true, it will use the WebView's background. If false, it will use an
 * internal pattern. Default is true.
 *
 * @deprecated This method is now obsolete.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,2,2,2,2,"The implementation of the method setUseWebViewBackgroundForOverscrollBackground(boolean) in the class android.webkit.WebSettings has been changed between versions 15 and 16. In version 15, the method was implemented to assign the value of the passed boolean parameter to the variable mUseWebViewBackgroundForOverscroll. However, in version 16, the method implementation has been replaced with a statement that throws a new MustOverrideException().","The code change in this case can lead to a Compatibility Issue (CI) as the behavior of the method has been modified between two consecutive versions. In version 15, the method was supposed to set the value of the variable mUseWebViewBackgroundForOverscroll, but in version 16, it will always throw an exception. This means that any code that relies on the previous behavior of this method may not work correctly in the newer version. The CI in this case is caused by the potential difference in exception handling."
535,<android.text.StaticLayout: int getLineDescent(int)>,23,24,<android.text.StaticLayout: int getLineDescent(int)>,<android.text.StaticLayout: int getLineDescent(int)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(int descent, []), Expression(mLines[mColumns * line + DESCENT], [])]), Statement(if (// -1 intended, []), AssignmentExpression(=, [VariableReference(mMaximumVisibleLineCount > 0 && line >, []), Expression(mMaximumVisibleLineCount - 1 && line !, [])]), AssignmentExpression(=, [VariableReference(descent +, []), Expression(getBottomPadding(), [])]), Statement(}, []), Statement(return descent, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(int descent, []), Expression(mLines[mColumns * line + DESCENT], [])])    VariableReference(int descent, [])    Expression(mLines[mColumns * line + DESCENT], [])  Statement(if (// -1 intended, [])  AssignmentExpression(=, [VariableReference(mMaximumVisibleLineCount > 0 && line >, []), Expression(mMaximumVisibleLineCount - 1 && line !, [])])    VariableReference(mMaximumVisibleLineCount > 0 && line >, [])    Expression(mMaximumVisibleLineCount - 1 && line !, [])  AssignmentExpression(=, [VariableReference(descent +, []), Expression(getBottomPadding(), [])])    VariableReference(descent +, [])    Expression(getBottomPadding(), [])  Statement(}, [])  Statement(return descent, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return mLines[mColumns * line + DESCENT], []), Statement(}, [])])  Statement({, [])  Statement(return mLines[mColumns * line + DESCENT], [])  Statement(}, [])",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,"1,3",1,1,1,"The implementation of the method getLineDescent(int) has been simplified. In the early version, the method first assigns the value of mLines[mColumns \* line + DESCENT] to a variable called descent. Then it checks whether the line number is within the maximum visible line count, if not, it will adjust the value of descent. Finally, it adds the bottom padding to the descent and returns the result. In the late version, the method directly returns the value of mLines[mColumns \* line + DESCENT], without any adjustment or adding bottom padding.","The code change may lead to compatibility issue, as the method getLineDescent(int) may return different values in the early and late versions. In the early version, the method will adjust the value of descent if the line number is out of the maximum visible line count, and it will also add the bottom padding to the result. However, in the late version, the method will not do any adjustment or adding padding, which may cause the layout of the text to be different from the early version."
464,<android.app.ContextImpl: void sendBroadcast(Intent)>,30,31,<android.app.ContextImpl: void sendBroadcast(Intent)>,<android.app.ContextImpl: void sendBroadcast(Intent)>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(warnIfCallingFromSystemProcess(), []), AssignmentExpression(=, [VariableReference(String resolvedType, []), Expression(intent.resolveTypeIfNeeded(getContentResolver()), [])]), Statement(try {, []), MethodCall(intent.prepareToLeaveProcess(this), [VariableReference(intent, []), Expression(this, [])]), MethodCall(ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, false, getUserId()), [VariableReference(ActivityManager, []), Expression().broadcastIntentWithFeature(mMainThread.getApplicationThread(), []), Expression(getAttributionTag(), []), Expression(intent, []), Expression(resolvedType, []), Expression(null, []), Expression(Activity.RESULT_OK, []), Expression(null, []), Expression(null, []), Expression(null, []), Expression(AppOpsManager.OP_NONE, []), Expression(null, []), Expression(false, []), Expression(false, []), Expression(getUserId(), [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(warnIfCallingFromSystemProcess(), [])  AssignmentExpression(=, [VariableReference(String resolvedType, []), Expression(intent.resolveTypeIfNeeded(getContentResolver()), [])])    VariableReference(String resolvedType, [])    Expression(intent.resolveTypeIfNeeded(getContentResolver()), [])  Statement(try {, [])  MethodCall(intent.prepareToLeaveProcess(this), [VariableReference(intent, []), Expression(this, [])])    VariableReference(intent, [])    Expression(this, [])  MethodCall(ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, false, getUserId()), [VariableReference(ActivityManager, []), Expression().broadcastIntentWithFeature(mMainThread.getApplicationThread(), []), Expression(getAttributionTag(), []), Expression(intent, []), Expression(resolvedType, []), Expression(null, []), Expression(Activity.RESULT_OK, []), Expression(null, []), Expression(null, []), Expression(null, []), Expression(AppOpsManager.OP_NONE, []), Expression(null, []), Expression(false, []), Expression(false, []), Expression(getUserId(), [])])    VariableReference(ActivityManager, [])    Expression().broadcastIntentWithFeature(mMainThread.getApplicationThread(), [])    Expression(getAttributionTag(), [])    Expression(intent, [])    Expression(resolvedType, [])    Expression(null, [])    Expression(Activity.RESULT_OK, [])    Expression(null, [])    Expression(null, [])    Expression(null, [])    Expression(AppOpsManager.OP_NONE, [])    Expression(null, [])    Expression(false, [])    Expression(false, [])    Expression(getUserId(), [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(warnIfCallingFromSystemProcess(), []), AssignmentExpression(=, [VariableReference(String resolvedType, []), Expression(intent.resolveTypeIfNeeded(getContentResolver()), [])]), Statement(try {, []), MethodCall(intent.prepareToLeaveProcess(this), [VariableReference(intent, []), Expression(this, [])]), AssignmentExpression(=, [VariableReference(ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, null, /*excludedPermissions, []), Expression(*/, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(warnIfCallingFromSystemProcess(), [])  AssignmentExpression(=, [VariableReference(String resolvedType, []), Expression(intent.resolveTypeIfNeeded(getContentResolver()), [])])    VariableReference(String resolvedType, [])    Expression(intent.resolveTypeIfNeeded(getContentResolver()), [])  Statement(try {, [])  MethodCall(intent.prepareToLeaveProcess(this), [VariableReference(intent, []), Expression(this, [])])    VariableReference(intent, [])    Expression(this, [])  AssignmentExpression(=, [VariableReference(ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, null, /*excludedPermissions, []), Expression(*/, [])])    VariableReference(ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, null, /*excludedPermissions, [])    Expression(*/, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,5,0,5,1,"The code change between the two versions is in the method call to `ActivityManager.getService().broadcastIntentWithFeature()`. In the early version, the method call includes the parameter `AppOpsManager.OP_NONE`, while in the late version, this parameter is removed. This change is classified as a dependent API change since it involves a modification to the parameters of a method that the current API relies on.","The removal of the `AppOpsManager.OP_NONE` parameter in the method call to `ActivityManager.getService().broadcastIntentWithFeature()` could potentially lead to different behavior in the late version of the API. Specifically, the absence of this parameter might cause the `ActivityManager` service to handle the broadcast differently and potentially result in an exception being thrown. Therefore, this is a compatibility issue caused by potential different exception handlings."
292,<android.widget.TimePicker: void setIs24HourView(Boolean)>,18,19,<android.widget.TimePicker: void setIs24HourView(Boolean)>,<android.widget.TimePicker: void setIs24HourView(Boolean)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mIs24HourView, []), Expression(, [])]), Statement(return, []), Statement(}, []), AssignmentExpression(=, [VariableReference(mIs24HourView, []), Expression(is24HourView, [])]), Statement(// cache the current hour since spinner range changes, []), AssignmentExpression(=, [VariableReference(int currentHour, []), Expression(getCurrentHour(), [])]), Statement(updateHourControl(), []), Statement(// set value after spinner range is updated, []), Statement(setCurrentHour(currentHour), []), Statement(updateAmPmControl(), []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mIs24HourView, []), Expression(, [])])    VariableReference(if (mIs24HourView, [])    Expression(, [])  Statement(return, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mIs24HourView, []), Expression(is24HourView, [])])    VariableReference(mIs24HourView, [])    Expression(is24HourView, [])  Statement(// cache the current hour since spinner range changes, [])  AssignmentExpression(=, [VariableReference(int currentHour, []), Expression(getCurrentHour(), [])])    VariableReference(int currentHour, [])    Expression(getCurrentHour(), [])  Statement(updateHourControl(), [])  Statement(// set value after spinner range is updated, [])  Statement(setCurrentHour(currentHour), [])  Statement(updateAmPmControl(), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mIs24HourView, []), Expression(, [])]), Statement(return, []), Statement(}, []), Statement(// cache the current hour since spinner range changes and BEFORE changing mIs24HourView!!, []), AssignmentExpression(=, [VariableReference(int currentHour, []), Expression(getCurrentHour(), [])]), Statement(// Order is important here., []), AssignmentExpression(=, [VariableReference(mIs24HourView, []), Expression(is24HourView, [])]), Statement(getHourFormatData(), []), Statement(updateHourControl(), []), Statement(// set value after spinner range is updated - be aware that because mIs24HourView has, []), Statement(// changed then getCurrentHour() is not equal to the currentHour we cached before so, []), Statement(// explicitly ask for *not* propagating any onTimeChanged(), []), Statement(setCurrentHour(currentHour, false), []), Statement(updateMinuteControl(), []), Statement(updateAmPmControl(), []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mIs24HourView, []), Expression(, [])])    VariableReference(if (mIs24HourView, [])    Expression(, [])  Statement(return, [])  Statement(}, [])  Statement(// cache the current hour since spinner range changes and BEFORE changing mIs24HourView!!, [])  AssignmentExpression(=, [VariableReference(int currentHour, []), Expression(getCurrentHour(), [])])    VariableReference(int currentHour, [])    Expression(getCurrentHour(), [])  Statement(// Order is important here., [])  AssignmentExpression(=, [VariableReference(mIs24HourView, []), Expression(is24HourView, [])])    VariableReference(mIs24HourView, [])    Expression(is24HourView, [])  Statement(getHourFormatData(), [])  Statement(updateHourControl(), [])  Statement(// set value after spinner range is updated - be aware that because mIs24HourView has, [])  Statement(// changed then getCurrentHour() is not equal to the currentHour we cached before so, [])  Statement(// explicitly ask for *not* propagating any onTimeChanged(), [])  Statement(setCurrentHour(currentHour, false), [])  Statement(updateMinuteControl(), [])  Statement(updateAmPmControl(), [])  Statement(}, [])",1,"/**
 * Set whether in 24 hour or AM/PM mode.
 *
 * @param is24HourView True = 24 hour mode. False = AM/PM.
 */
","/**
 * Set whether in 24 hour or AM/PM mode.
 *
 * @param is24HourView True = 24 hour mode. False = AM/PM.
 */
",-1,,,-1,-1,-1,-1,-1,"4,5",0,3,1,"The control dependency of the method has changed. In the early version, the method sets the current hour and updates the AM/PM control after updating the hour control. In the late version, the method updates the minute control and AM/PM control after setting the current hour.","The change in control dependency can lead to different behavior in the late version. In the early version, the AM/PM control is updated based on the current hour after the hour control is updated. In the late version, the AM/PM control is updated based on the current hour after the current hour is set. This can lead to inconsistencies between the hour control and the AM/PM control if the current hour is changed during the period between the hour control is updated and the current hour is set."
344,"<android.provider.Settings.NameValueCache: boolean putStringForUser(ContentResolver,String,String,int)>",17,18,"<android.provider.Settings.NameValueCache: boolean putStringForUser(ContentResolver,String,String,int)>","<android.provider.Settings.NameValueCache: boolean putStringForUser(ContentResolver,String,String,int)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), AssignmentExpression(=, [VariableReference(Bundle arg, []), Expression(new Bundle(), [])]), MethodCall(arg.putString(Settings.NameValueTable.VALUE, value), [VariableReference(arg, []), Expression(Settings.NameValueTable.VALUE, []), Expression(value, [])]), MethodCall(arg.putInt(CALL_METHOD_USER_KEY, userHandle), [VariableReference(arg, []), Expression(CALL_METHOD_USER_KEY, []), Expression(userHandle, [])]), AssignmentExpression(=, [VariableReference(IContentProvider cp, []), Expression(lazyGetProvider(cr), [])]), MethodCall(cp.call(mCallSetCommand, name, arg), [VariableReference(cp, []), Expression(mCallSetCommand, []), Expression(name, []), Expression(arg, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(Log.w(TAG, ""Can't set key "" + name + "" in "" + mUri, e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Can't set key "" + name + "" in "" + mUri, []), Expression(e, [])]), Statement(return false, []), Statement(}, []), Statement(return true, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(Bundle arg, []), Expression(new Bundle(), [])])    VariableReference(Bundle arg, [])    Expression(new Bundle(), [])  MethodCall(arg.putString(Settings.NameValueTable.VALUE, value), [VariableReference(arg, []), Expression(Settings.NameValueTable.VALUE, []), Expression(value, [])])    VariableReference(arg, [])    Expression(Settings.NameValueTable.VALUE, [])    Expression(value, [])  MethodCall(arg.putInt(CALL_METHOD_USER_KEY, userHandle), [VariableReference(arg, []), Expression(CALL_METHOD_USER_KEY, []), Expression(userHandle, [])])    VariableReference(arg, [])    Expression(CALL_METHOD_USER_KEY, [])    Expression(userHandle, [])  AssignmentExpression(=, [VariableReference(IContentProvider cp, []), Expression(lazyGetProvider(cr), [])])    VariableReference(IContentProvider cp, [])    Expression(lazyGetProvider(cr), [])  MethodCall(cp.call(mCallSetCommand, name, arg), [VariableReference(cp, []), Expression(mCallSetCommand, []), Expression(name, []), Expression(arg, [])])    VariableReference(cp, [])    Expression(mCallSetCommand, [])    Expression(name, [])    Expression(arg, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(Log.w(TAG, ""Can't set key "" + name + "" in "" + mUri, e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Can't set key "" + name + "" in "" + mUri, []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Can't set key "" + name + "" in "" + mUri, [])    Expression(e, [])  Statement(return false, [])  Statement(}, [])  Statement(return true, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), AssignmentExpression(=, [VariableReference(Bundle arg, []), Expression(new Bundle(), [])]), MethodCall(arg.putString(Settings.NameValueTable.VALUE, value), [VariableReference(arg, []), Expression(Settings.NameValueTable.VALUE, []), Expression(value, [])]), MethodCall(arg.putInt(CALL_METHOD_USER_KEY, userHandle), [VariableReference(arg, []), Expression(CALL_METHOD_USER_KEY, []), Expression(userHandle, [])]), AssignmentExpression(=, [VariableReference(IContentProvider cp, []), Expression(lazyGetProvider(cr), [])]), MethodCall(cp.call(cr.getPackageName(), mCallSetCommand, name, arg), [VariableReference(cp, []), Expression(cr.getPackageName(), []), Expression(mCallSetCommand, []), Expression(name, []), Expression(arg, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(Log.w(TAG, ""Can't set key "" + name + "" in "" + mUri, e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Can't set key "" + name + "" in "" + mUri, []), Expression(e, [])]), Statement(return false, []), Statement(}, []), Statement(return true, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(Bundle arg, []), Expression(new Bundle(), [])])    VariableReference(Bundle arg, [])    Expression(new Bundle(), [])  MethodCall(arg.putString(Settings.NameValueTable.VALUE, value), [VariableReference(arg, []), Expression(Settings.NameValueTable.VALUE, []), Expression(value, [])])    VariableReference(arg, [])    Expression(Settings.NameValueTable.VALUE, [])    Expression(value, [])  MethodCall(arg.putInt(CALL_METHOD_USER_KEY, userHandle), [VariableReference(arg, []), Expression(CALL_METHOD_USER_KEY, []), Expression(userHandle, [])])    VariableReference(arg, [])    Expression(CALL_METHOD_USER_KEY, [])    Expression(userHandle, [])  AssignmentExpression(=, [VariableReference(IContentProvider cp, []), Expression(lazyGetProvider(cr), [])])    VariableReference(IContentProvider cp, [])    Expression(lazyGetProvider(cr), [])  MethodCall(cp.call(cr.getPackageName(), mCallSetCommand, name, arg), [VariableReference(cp, []), Expression(cr.getPackageName(), []), Expression(mCallSetCommand, []), Expression(name, []), Expression(arg, [])])    VariableReference(cp, [])    Expression(cr.getPackageName(), [])    Expression(mCallSetCommand, [])    Expression(name, [])    Expression(arg, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(Log.w(TAG, ""Can't set key "" + name + "" in "" + mUri, e), [VariableReference(Log, []), Expression(TAG, []), Expression(""Can't set key "" + name + "" in "" + mUri, []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Can't set key "" + name + "" in "" + mUri, [])    Expression(e, [])  Statement(return false, [])  Statement(}, [])  Statement(return true, [])  Statement(}, [])",1,,,-1,,,-1,-1,-1,-1,-1,"4,5",0,5,1,A new argument `cr.getPackageName()` is added to the method call `cp.call()` in the late implementation.,"The added argument `cr.getPackageName()` may cause the method `cp.call()` to behave differently, which in turn may cause the method `putStringForUser()` to return a different value, leading to a compatibility issue."
120,<android.hardware.camera2.CameraManager: CameraCharacteristics getCameraCharacteristics(String)>,29,30,<android.hardware.camera2.CameraManager: CameraCharacteristics getCameraCharacteristics(String)>,<android.hardware.camera2.CameraManager: CameraCharacteristics getCameraCharacteristics(String)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(CameraCharacteristics characteristics, []), Expression(null, [])]), Statement(throw new IllegalArgumentException(""No cameras available on device""), []), Statement(}, []), Statement(synchronized (mLock) {, []), Statement(/*, []), Statement(* Get the camera characteristics from the camera service directly if it supports it,, []), Statement(* otherwise get them from the legacy shim instead., []), Statement(*/, []), AssignmentExpression(=, [VariableReference(ICameraService cameraService, []), Expression(CameraManagerGlobal.get().getCameraService(), [])]), AssignmentExpression(=, [VariableReference(if (cameraService, []), Expression(, [])]), Statement(}, []), Statement(try {, []), AssignmentExpression(=, [VariableReference(Size displaySize, []), Expression(getDisplaySize(), [])]), Statement(// exception in case cameraId is a hidden physical camera., []), Statement(if (!isHiddenPhysicalCamera(cameraId) && !supportsCamera2ApiLocked(cameraId)) {, []), Statement(// Legacy backwards compatibility path, []), Statement(build static info from the camera, []), Statement(// parameters, []), AssignmentExpression(=, [VariableReference(int id, []), Expression(Integer.parseInt(cameraId), [])]), AssignmentExpression(=, [VariableReference(String parameters, []), Expression(cameraService.getLegacyParameters(id), [])]), AssignmentExpression(=, [VariableReference(CameraInfo info, []), Expression(cameraService.getCameraInfo(id), [])]), AssignmentExpression(=, [VariableReference(characteristics, []), Expression(LegacyMetadataMapper.createCharacteristics(parameters, info, id, displaySize), [])]), Statement(} else {, []), Statement(// Normal path: Get the camera characteristics directly from the camera service, []), AssignmentExpression(=, [VariableReference(CameraMetadataNative info, []), Expression(cameraService.getCameraCharacteristics(cameraId), [])]), Statement(try {, []), MethodCall(info.setCameraId(Integer.parseInt(cameraId)), [VariableReference(info, []), Expression(Integer.parseInt(cameraId), [])]), Statement(} catch (NumberFormatException e) {, []), MethodCall(Log.e(TAG, ""Failed to parse camera Id "" + cameraId + "" to integer""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Failed to parse camera Id "" + cameraId + "" to integer"", [])]), Statement(}, []), MethodCall(info.setDisplaySize(displaySize), [VariableReference(info, []), Expression(displaySize, [])]), AssignmentExpression(=, [VariableReference(characteristics, []), Expression(new CameraCharacteristics(info), [])]), Statement(}, []), Statement(} catch (ServiceSpecificException e) {, []), Statement(throwAsPublicException(e), []), Statement(} catch (RemoteException e) {, []), Statement(// Camera service died - act as if the camera was disconnected, []), Statement(}, []), Statement(}, []), Statement(return characteristics, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(CameraCharacteristics characteristics, []), Expression(null, [])])    VariableReference(CameraCharacteristics characteristics, [])    Expression(null, [])  Statement(throw new IllegalArgumentException(""No cameras available on device""), [])  Statement(}, [])  Statement(synchronized (mLock) {, [])  Statement(/*, [])  Statement(* Get the camera characteristics from the camera service directly if it supports it,, [])  Statement(* otherwise get them from the legacy shim instead., [])  Statement(*/, [])  AssignmentExpression(=, [VariableReference(ICameraService cameraService, []), Expression(CameraManagerGlobal.get().getCameraService(), [])])    VariableReference(ICameraService cameraService, [])    Expression(CameraManagerGlobal.get().getCameraService(), [])  AssignmentExpression(=, [VariableReference(if (cameraService, []), Expression(, [])])    VariableReference(if (cameraService, [])    Expression(, [])  Statement(}, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(Size displaySize, []), Expression(getDisplaySize(), [])])    VariableReference(Size displaySize, [])    Expression(getDisplaySize(), [])  Statement(// exception in case cameraId is a hidden physical camera., [])  Statement(if (!isHiddenPhysicalCamera(cameraId) && !supportsCamera2ApiLocked(cameraId)) {, [])  Statement(// Legacy backwards compatibility path, [])  Statement(build static info from the camera, [])  Statement(// parameters, [])  AssignmentExpression(=, [VariableReference(int id, []), Expression(Integer.parseInt(cameraId), [])])    VariableReference(int id, [])    Expression(Integer.parseInt(cameraId), [])  AssignmentExpression(=, [VariableReference(String parameters, []), Expression(cameraService.getLegacyParameters(id), [])])    VariableReference(String parameters, [])    Expression(cameraService.getLegacyParameters(id), [])  AssignmentExpression(=, [VariableReference(CameraInfo info, []), Expression(cameraService.getCameraInfo(id), [])])    VariableReference(CameraInfo info, [])    Expression(cameraService.getCameraInfo(id), [])  AssignmentExpression(=, [VariableReference(characteristics, []), Expression(LegacyMetadataMapper.createCharacteristics(parameters, info, id, displaySize), [])])    VariableReference(characteristics, [])    Expression(LegacyMetadataMapper.createCharacteristics(parameters, info, id, displaySize), [])  Statement(} else {, [])  Statement(// Normal path: Get the camera characteristics directly from the camera service, [])  AssignmentExpression(=, [VariableReference(CameraMetadataNative info, []), Expression(cameraService.getCameraCharacteristics(cameraId), [])])    VariableReference(CameraMetadataNative info, [])    Expression(cameraService.getCameraCharacteristics(cameraId), [])  Statement(try {, [])  MethodCall(info.setCameraId(Integer.parseInt(cameraId)), [VariableReference(info, []), Expression(Integer.parseInt(cameraId), [])])    VariableReference(info, [])    Expression(Integer.parseInt(cameraId), [])  Statement(} catch (NumberFormatException e) {, [])  MethodCall(Log.e(TAG, ""Failed to parse camera Id "" + cameraId + "" to integer""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Failed to parse camera Id "" + cameraId + "" to integer"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Failed to parse camera Id "" + cameraId + "" to integer"", [])  Statement(}, [])  MethodCall(info.setDisplaySize(displaySize), [VariableReference(info, []), Expression(displaySize, [])])    VariableReference(info, [])    Expression(displaySize, [])  AssignmentExpression(=, [VariableReference(characteristics, []), Expression(new CameraCharacteristics(info), [])])    VariableReference(characteristics, [])    Expression(new CameraCharacteristics(info), [])  Statement(}, [])  Statement(} catch (ServiceSpecificException e) {, [])  Statement(throwAsPublicException(e), [])  Statement(} catch (RemoteException e) {, [])  Statement(// Camera service died - act as if the camera was disconnected, [])  Statement(}, [])  Statement(}, [])  Statement(return characteristics, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(CameraCharacteristics characteristics, []), Expression(null, [])]), Statement(throw new IllegalArgumentException(""No cameras available on device""), []), Statement(}, []), Statement(synchronized (mLock) {, []), Statement(/*, []), Statement(* Get the camera characteristics from the camera service directly if it supports it,, []), Statement(* otherwise get them from the legacy shim instead., []), Statement(*/, []), AssignmentExpression(=, [VariableReference(ICameraService cameraService, []), Expression(CameraManagerGlobal.get().getCameraService(), [])]), AssignmentExpression(=, [VariableReference(if (cameraService, []), Expression(, [])]), Statement(}, []), Statement(try {, []), AssignmentExpression(=, [VariableReference(Size displaySize, []), Expression(getDisplaySize(), [])]), Statement(// exception in case cameraId is a hidden physical camera., []), Statement(if (!isHiddenPhysicalCamera(cameraId) && !supportsCamera2ApiLocked(cameraId)) {, []), Statement(// Legacy backwards compatibility path, []), Statement(build static info from the camera, []), Statement(// parameters, []), AssignmentExpression(=, [VariableReference(int id, []), Expression(Integer.parseInt(cameraId), [])]), AssignmentExpression(=, [VariableReference(String parameters, []), Expression(cameraService.getLegacyParameters(id), [])]), AssignmentExpression(=, [VariableReference(CameraInfo info, []), Expression(cameraService.getCameraInfo(id), [])]), AssignmentExpression(=, [VariableReference(characteristics, []), Expression(LegacyMetadataMapper.createCharacteristics(parameters, info, id, displaySize), [])]), Statement(} else {, []), Statement(// Normal path: Get the camera characteristics directly from the camera service, []), AssignmentExpression(=, [VariableReference(CameraMetadataNative info, []), Expression(cameraService.getCameraCharacteristics(cameraId), [])]), Statement(try {, []), MethodCall(info.setCameraId(Integer.parseInt(cameraId)), [VariableReference(info, []), Expression(Integer.parseInt(cameraId), [])]), Statement(} catch (NumberFormatException e) {, []), Statement(// For external camera, reaching here is expected., []), MethodCall(Log.v(TAG, ""Failed to parse camera Id "" + cameraId + "" to integer""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Failed to parse camera Id "" + cameraId + "" to integer"", [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(boolean hasConcurrentStreams, []), Expression(CameraManagerGlobal.get().cameraIdHasConcurrentStreamsLocked(cameraId), [])]), MethodCall(info.setHasMandatoryConcurrentStreams(hasConcurrentStreams), [VariableReference(info, []), Expression(hasConcurrentStreams, [])]), MethodCall(info.setDisplaySize(displaySize), [VariableReference(info, []), Expression(displaySize, [])]), AssignmentExpression(=, [VariableReference(characteristics, []), Expression(new CameraCharacteristics(info), [])]), Statement(}, []), Statement(} catch (ServiceSpecificException e) {, []), Statement(throwAsPublicException(e), []), Statement(} catch (RemoteException e) {, []), Statement(// Camera service died - act as if the camera was disconnected, []), Statement(}, []), Statement(}, []), Statement(return characteristics, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(CameraCharacteristics characteristics, []), Expression(null, [])])    VariableReference(CameraCharacteristics characteristics, [])    Expression(null, [])  Statement(throw new IllegalArgumentException(""No cameras available on device""), [])  Statement(}, [])  Statement(synchronized (mLock) {, [])  Statement(/*, [])  Statement(* Get the camera characteristics from the camera service directly if it supports it,, [])  Statement(* otherwise get them from the legacy shim instead., [])  Statement(*/, [])  AssignmentExpression(=, [VariableReference(ICameraService cameraService, []), Expression(CameraManagerGlobal.get().getCameraService(), [])])    VariableReference(ICameraService cameraService, [])    Expression(CameraManagerGlobal.get().getCameraService(), [])  AssignmentExpression(=, [VariableReference(if (cameraService, []), Expression(, [])])    VariableReference(if (cameraService, [])    Expression(, [])  Statement(}, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(Size displaySize, []), Expression(getDisplaySize(), [])])    VariableReference(Size displaySize, [])    Expression(getDisplaySize(), [])  Statement(// exception in case cameraId is a hidden physical camera., [])  Statement(if (!isHiddenPhysicalCamera(cameraId) && !supportsCamera2ApiLocked(cameraId)) {, [])  Statement(// Legacy backwards compatibility path, [])  Statement(build static info from the camera, [])  Statement(// parameters, [])  AssignmentExpression(=, [VariableReference(int id, []), Expression(Integer.parseInt(cameraId), [])])    VariableReference(int id, [])    Expression(Integer.parseInt(cameraId), [])  AssignmentExpression(=, [VariableReference(String parameters, []), Expression(cameraService.getLegacyParameters(id), [])])    VariableReference(String parameters, [])    Expression(cameraService.getLegacyParameters(id), [])  AssignmentExpression(=, [VariableReference(CameraInfo info, []), Expression(cameraService.getCameraInfo(id), [])])    VariableReference(CameraInfo info, [])    Expression(cameraService.getCameraInfo(id), [])  AssignmentExpression(=, [VariableReference(characteristics, []), Expression(LegacyMetadataMapper.createCharacteristics(parameters, info, id, displaySize), [])])    VariableReference(characteristics, [])    Expression(LegacyMetadataMapper.createCharacteristics(parameters, info, id, displaySize), [])  Statement(} else {, [])  Statement(// Normal path: Get the camera characteristics directly from the camera service, [])  AssignmentExpression(=, [VariableReference(CameraMetadataNative info, []), Expression(cameraService.getCameraCharacteristics(cameraId), [])])    VariableReference(CameraMetadataNative info, [])    Expression(cameraService.getCameraCharacteristics(cameraId), [])  Statement(try {, [])  MethodCall(info.setCameraId(Integer.parseInt(cameraId)), [VariableReference(info, []), Expression(Integer.parseInt(cameraId), [])])    VariableReference(info, [])    Expression(Integer.parseInt(cameraId), [])  Statement(} catch (NumberFormatException e) {, [])  Statement(// For external camera, reaching here is expected., [])  MethodCall(Log.v(TAG, ""Failed to parse camera Id "" + cameraId + "" to integer""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Failed to parse camera Id "" + cameraId + "" to integer"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Failed to parse camera Id "" + cameraId + "" to integer"", [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(boolean hasConcurrentStreams, []), Expression(CameraManagerGlobal.get().cameraIdHasConcurrentStreamsLocked(cameraId), [])])    VariableReference(boolean hasConcurrentStreams, [])    Expression(CameraManagerGlobal.get().cameraIdHasConcurrentStreamsLocked(cameraId), [])  MethodCall(info.setHasMandatoryConcurrentStreams(hasConcurrentStreams), [VariableReference(info, []), Expression(hasConcurrentStreams, [])])    VariableReference(info, [])    Expression(hasConcurrentStreams, [])  MethodCall(info.setDisplaySize(displaySize), [VariableReference(info, []), Expression(displaySize, [])])    VariableReference(info, [])    Expression(displaySize, [])  AssignmentExpression(=, [VariableReference(characteristics, []), Expression(new CameraCharacteristics(info), [])])    VariableReference(characteristics, [])    Expression(new CameraCharacteristics(info), [])  Statement(}, [])  Statement(} catch (ServiceSpecificException e) {, [])  Statement(throwAsPublicException(e), [])  Statement(} catch (RemoteException e) {, [])  Statement(// Camera service died - act as if the camera was disconnected, [])  Statement(}, [])  Statement(}, [])  Statement(return characteristics, [])  Statement(}, [])",1,"/**
 * <p>Query the capabilities of a camera device. These capabilities are
 * immutable for a given camera.</p>
 *
 * <p>From API level 29, this function can also be used to query the capabilities of physical
 * cameras that can only be used as part of logical multi-camera. These cameras cannot be
 * opened directly via {@link #openCamera}</p>
 *
 * @param cameraId The id of the camera device to query. This could be either a standalone
 * camera ID which can be directly opened by {@link #openCamera}, or a physical camera ID that
 * can only used as part of a logical multi-camera.
 * @return The properties of the given camera
 *
 * @throws IllegalArgumentException if the cameraId does not match any
 * known camera device.
 * @throws CameraAccessException if the camera device has been disconnected.
 *
 * @see #getCameraIdList
 * @see android.app.admin.DevicePolicyManager#setCameraDisabled
 */
","/**
 * <p>Query the capabilities of a camera device. These capabilities are
 * immutable for a given camera.</p>
 *
 * <p>From API level 29, this function can also be used to query the capabilities of physical
 * cameras that can only be used as part of logical multi-camera. These cameras cannot be
 * opened directly via {@link #openCamera}</p>
 *
 * <p>Also starting with API level 29, while most basic camera information is still available
 * even without the CAMERA permission, some values are not available to apps that do not hold
 * that permission. The keys not available are listed by
 * {@link CameraCharacteristics#getKeysNeedingPermission}.</p>
 *
 * @param cameraId The id of the camera device to query. This could be either a standalone
 * camera ID which can be directly opened by {@link #openCamera}, or a physical camera ID that
 * can only used as part of a logical multi-camera.
 * @return The properties of the given camera
 *
 * @throws IllegalArgumentException if the cameraId does not match any
 * known camera device.
 * @throws CameraAccessException if the camera device has been disconnected.
 *
 * @see #getCameraIdList
 * @see android.app.admin.DevicePolicyManager#setCameraDisabled
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,4,0,"3,4",1,The implementation of the method `getCameraCharacteristics(String)` has changed in two ways:,
851,<android.accounts.AccountManager: AuthenticatorDescription[] getAuthenticatorTypes()>,29,30,<android.accounts.AccountManager: AuthenticatorDescription[] getAuthenticatorTypes()>,<android.accounts.AccountManager: AuthenticatorDescription[] getAuthenticatorTypes()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(return mService.getAuthenticatorTypes(UserHandle.getCallingUserId()), [VariableReference(return mService, []), Expression(UserHandle.getCallingUserId(), [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(return mService.getAuthenticatorTypes(UserHandle.getCallingUserId()), [VariableReference(return mService, []), Expression(UserHandle.getCallingUserId(), [])])    VariableReference(return mService, [])    Expression(UserHandle.getCallingUserId(), [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(return getAuthenticatorTypesAsUser(mContext.getUserId()), [VariableReference(return getAuthenticatorTypesAsUser(mContext, []), Expression(), [])]), Statement(}, [])])  Statement({, [])  MethodCall(return getAuthenticatorTypesAsUser(mContext.getUserId()), [VariableReference(return getAuthenticatorTypesAsUser(mContext, []), Expression(), [])])    VariableReference(return getAuthenticatorTypesAsUser(mContext, [])    Expression(), [])  Statement(}, [])",1,"/**
 * Lists the currently registered authenticators.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>No permission is required to call this method.
 *
 * @return An array of {@link AuthenticatorDescription} for every
 * authenticator known to the AccountManager service.  Empty (never
 * null) if no authenticators are known.
 */
","/**
 * Lists the currently registered authenticators.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>No permission is required to call this method.
 *
 * @return An array of {@link AuthenticatorDescription} for every
 * authenticator known to the AccountManager service.  Empty (never
 * null) if no authenticators are known.
 */
",-1,,[@UserHandleAware],-1,-1,-1,-1,-1,"1,2,4,5","1,2",5,"1,2","The implementation of the API has been changed from ""return mService.getAuthenticatorTypes(UserHandle.getCallingUserId())"" to ""return getAuthenticatorTypesAsUser(mContext.getUserId())"". In the early version, the method is directly called from mService, while in the late version, a new method ""getAuthenticatorTypesAsUser"" is used. This is a dependent API change, as the method used to retrieve the authenticator types has been changed. Additionally, the exception handling has been removed in the late version.","The dependent API change could potentially lead to different behaviors of the API. The authenticator types retrieved by ""mService.getAuthenticatorTypes(UserHandle.getCallingUserId())"" and ""getAuthenticatorTypesAsUser(mContext.getUserId())"" may not be the same, which could cause compatibility issues. Furthermore, the removal of exception handling in the late version could also lead to different exception handling behaviors, which could cause compatibility issues as well."
541,<android.widget.TextView: int getImeActionId()>,15,16,<android.widget.TextView: int getImeActionId()>,<android.widget.TextView: int getImeActionId()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(return mInputContentType !, []), Expression(null ? mInputContentType.imeActionId : 0, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(return mInputContentType !, []), Expression(null ? mInputContentType.imeActionId : 0, [])])    VariableReference(return mInputContentType !, [])    Expression(null ? mInputContentType.imeActionId : 0, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(return mEditor !, []), Expression(null && mEditor.mInputContentType !, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(return mEditor !, []), Expression(null && mEditor.mInputContentType !, [])])    VariableReference(return mEditor !, [])    Expression(null && mEditor.mInputContentType !, [])  Statement(}, [])",1,"/**
 * Get the IME action ID previous set with {@link #setImeActionLabel}.
 *
 * @see #setImeActionLabel
 * @see android.view.inputmethod.EditorInfo
 */
","/**
 * Get the IME action ID previous set with {@link #setImeActionLabel}.
 *
 * @see #setImeActionLabel
 * @see android.view.inputmethod.EditorInfo
 */
",-1,,,-1,-1,-1,-1,-1,"1,3",1,"1,5",1,"The return statement has been modified from ""return mInputContentType != null ? mInputContentType.imeActionId : 0"" to ""return mEditor != null && mEditor.mInputContentType != null ? mEditor.mInputContentType.imeActionId : 0"". The variable mInputContentType is replaced by mEditor.mInputContentType, and the null check is also modified. This is a code change type 1 (return statement changed) and 5 (dependent API changed).","The modification of the return statement can lead to different return values. The condition for the null check is different between the two versions, and the variable used for the calculation is also changed. Therefore, it is possible that the returned value is different between the two versions, which is a compatibility issue type 1 (Compatibility Issue caused by potential different return values or types)."
137,<android.permission.PermissionManager.SplitPermissionInfo: int getTargetSdk()>,29,30,<android.permission.PermissionManager.SplitPermissionInfo: int getTargetSdk()>,<android.permission.PermissionManager.SplitPermissionInfo: int getTargetSdk()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(return mTargetSdk, []), Statement(}, [])])  Statement({, [])  Statement(return mTargetSdk, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(return mSplitPermissionInfoParcelable.getTargetSdk(), [VariableReference(return mSplitPermissionInfoParcelable, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return mSplitPermissionInfoParcelable.getTargetSdk(), [VariableReference(return mSplitPermissionInfoParcelable, []), Expression(, [])])    VariableReference(return mSplitPermissionInfoParcelable, [])    Expression(, [])  Statement(}, [])",1,"/**
 * Get the target API level when the permission was split.
 */
","/**
 * Get the target API level when the permission was split.
 */
",-1,,,-1,-1,-1,-1,-1,"1,4",1,"1,4",1,"The reason for this classification is that the implementation of the API has been changed from `return mTargetSdk` in the early version to `return mSplitPermissionInfoParcelable.getTargetSdk()` in the late version. This change involves a modification to the dependent API, specifically the method used to retrieve the target SDK value.","The reason for this classification is that the change in the dependent API used to retrieve the target SDK value could potentially result in a different value or type being returned by the API, which could in turn lead to compatibility issues with any code that relies on the API."
323,<android.bluetooth.BluetoothAdapter: String getName()>,16,17,<android.bluetooth.BluetoothAdapter: String getName()>,<android.bluetooth.BluetoothAdapter: String getName()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(return mService.getName(), [VariableReference(return mService, []), Expression(, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(Log.e(TAG, """", e), [VariableReference(Log, []), Expression(TAG, []), Expression("""", []), Expression(e, [])]), Statement(}, []), Statement(return null, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(return mService.getName(), [VariableReference(return mService, []), Expression(, [])])    VariableReference(return mService, [])    Expression(, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(Log.e(TAG, """", e), [VariableReference(Log, []), Expression(TAG, []), Expression("""", []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression("""", [])    Expression(e, [])  Statement(}, [])  Statement(return null, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(return mManagerService.getName(), [VariableReference(return mManagerService, []), Expression(, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(Log.e(TAG, """", e), [VariableReference(Log, []), Expression(TAG, []), Expression("""", []), Expression(e, [])]), Statement(}, []), Statement(return null, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(return mManagerService.getName(), [VariableReference(return mManagerService, []), Expression(, [])])    VariableReference(return mManagerService, [])    Expression(, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(Log.e(TAG, """", e), [VariableReference(Log, []), Expression(TAG, []), Expression("""", []), Expression(e, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression("""", [])    Expression(e, [])  Statement(}, [])  Statement(return null, [])  Statement(}, [])",1,"/**
 * Get the friendly Bluetooth name of the local Bluetooth adapter.
 * <p>This name is visible to remote Bluetooth devices.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
 *
 * @return the Bluetooth name, or null on error
 */
","/**
 * Get the friendly Bluetooth name of the local Bluetooth adapter.
 * <p>This name is visible to remote Bluetooth devices.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
 *
 * @return the Bluetooth name, or null on error
 */
",-1,,,-1,-1,-1,-1,-1,"1,5",1,5,1,"The name of the service object has been changed from ""mService"" to ""mManagerService"". This is a change in the dependent API, as the method ""getName()"" is now being called on a different object.","The change in the dependent API can potentially lead to a different return value for the ""getName()"" method, as it is now being called on a different object. This can cause compatibility issues for any code that relies on the consistent behavior of the ""getName()"" method."
683,<android.app.admin.DevicePolicyManager: boolean getCameraDisabled(ComponentName)>,23,24,<android.app.admin.DevicePolicyManager: boolean getCameraDisabled(ComponentName)>,<android.app.admin.DevicePolicyManager: boolean getCameraDisabled(ComponentName)>,0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(return getCameraDisabled(admin, UserHandle.myUserId()), [VariableReference(return getCameraDisabled(admin, UserHandle, []), Expression(), [])]), Statement(}, [])])  Statement({, [])  MethodCall(return getCameraDisabled(admin, UserHandle.myUserId()), [VariableReference(return getCameraDisabled(admin, UserHandle, []), Expression(), [])])    VariableReference(return getCameraDisabled(admin, UserHandle, [])    Expression(), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(throwIfParentInstance(""getCameraDisabled""), []), Statement(return getCameraDisabled(admin, myUserId()), []), Statement(}, [])])  Statement({, [])  Statement(throwIfParentInstance(""getCameraDisabled""), [])  Statement(return getCameraDisabled(admin, myUserId()), [])  Statement(}, [])",1,"/**
 * Determine whether or not the device's cameras have been disabled for this user,
 * either by the current admin, if specified, or all admins.
 * @param admin The name of the admin component to check, or {@code null} to check whether any admins
 * have disabled the camera
 */
","/**
 * Determine whether or not the device's cameras have been disabled for this user,
 * either by the calling admin, if specified, or all admins.
 * @param admin The name of the admin component to check, or {@code null} to check whether any admins
 * have disabled the camera
 */
",-1,,,-1,-1,-1,-1,-1,"2,4,5",2,"2,5","1,2","A new statement ""throwIfParentInstance(""getCameraDisabled"")"" is added in the late version, and the method call ""getCameraDisabled(admin, UserHandle.myUserId())"" is changed to ""getCameraDisabled(admin, myUserId())"". Additionally, the return statement is moved to a separate statement. These changes are classified as Exception handling statement changed (2), and Dependent API changed (5).","The new exception handling statement in the late version could potentially cause the method to throw an exception that was not thrown in the early version, which could lead to Compatibility Issue caused by potential different exception handlings (2). The change in the dependent API could potentially cause the method to return a different value, which could lead to Compatibility Issue caused by potential different return values or types (1)."
1288,"<android.app.ContextImpl: void revokeUriPermission(Uri,int)>",23,24,"<android.app.ContextImpl: void revokeUriPermission(Uri,int)>","<android.app.ContextImpl: void revokeUriPermission(Uri,int)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(ActivityManagerNative.getDefault().revokeUriPermission(mMainThread.getApplicationThread(), ContentProvider.getUriWithoutUserId(uri), modeFlags, resolveUserId(uri)), [VariableReference(ActivityManagerNative, []), Expression().revokeUriPermission(mMainThread.getApplicationThread(), []), Expression(ContentProvider.getUriWithoutUserId(uri), []), Expression(modeFlags, []), Expression(resolveUserId(uri), [])]), Statement(} catch (RemoteException e) {, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(ActivityManagerNative.getDefault().revokeUriPermission(mMainThread.getApplicationThread(), ContentProvider.getUriWithoutUserId(uri), modeFlags, resolveUserId(uri)), [VariableReference(ActivityManagerNative, []), Expression().revokeUriPermission(mMainThread.getApplicationThread(), []), Expression(ContentProvider.getUriWithoutUserId(uri), []), Expression(modeFlags, []), Expression(resolveUserId(uri), [])])    VariableReference(ActivityManagerNative, [])    Expression().revokeUriPermission(mMainThread.getApplicationThread(), [])    Expression(ContentProvider.getUriWithoutUserId(uri), [])    Expression(modeFlags, [])    Expression(resolveUserId(uri), [])  Statement(} catch (RemoteException e) {, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(ActivityManagerNative.getDefault().revokeUriPermission(mMainThread.getApplicationThread(), ContentProvider.getUriWithoutUserId(uri), modeFlags, resolveUserId(uri)), [VariableReference(ActivityManagerNative, []), Expression().revokeUriPermission(mMainThread.getApplicationThread(), []), Expression(ContentProvider.getUriWithoutUserId(uri), []), Expression(modeFlags, []), Expression(resolveUserId(uri), [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(ActivityManagerNative.getDefault().revokeUriPermission(mMainThread.getApplicationThread(), ContentProvider.getUriWithoutUserId(uri), modeFlags, resolveUserId(uri)), [VariableReference(ActivityManagerNative, []), Expression().revokeUriPermission(mMainThread.getApplicationThread(), []), Expression(ContentProvider.getUriWithoutUserId(uri), []), Expression(modeFlags, []), Expression(resolveUserId(uri), [])])    VariableReference(ActivityManagerNative, [])    Expression().revokeUriPermission(mMainThread.getApplicationThread(), [])    Expression(ContentProvider.getUriWithoutUserId(uri), [])    Expression(modeFlags, [])    Expression(resolveUserId(uri), [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,2,2,2,2,A new exception handling statement "throw e.rethrowFromSystemServer()" is added in the late version of the API.,"The new exception handling statement ""throw e.rethrowFromSystemServer()"" in the late version of the API can potentially cause different exceptions to be thrown compared to the early version, leading to a Compatibility Issue."
348,<android.webkit.LoadListener: boolean handleSslErrorRequest(SslError)>,4,5,<android.webkit.LoadListener: boolean handleSslErrorRequest(SslError)>,<android.webkit.LoadListener: boolean handleSslErrorRequest(SslError)>,0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(Log.v(LOGTAG, ""LoadListener.handleSslErrorRequest(): url:"" + url() + "" primary error: "" + error.getPrimaryError() + "" certificate: "" + error.getCertificate()), [VariableReference(Log, []), Expression(LOGTAG, []), Expression(""LoadListener.handleSslErrorRequest(): url:"" + url() + "" primary error: "" + error.getPrimaryError() + "" certificate: "" + error.getCertificate(), [])]), Statement(}, []), Statement(sendMessageInternal(obtainMessage(MSG_SSL_ERROR, error)), []), Statement(// to unblock the network thread., []), Statement(if (!mCancelled) {, []), AssignmentExpression(=, [VariableReference(mSslErrorRequestHandle, []), Expression(mRequestHandle, [])]), Statement(}, []), Statement(return !mCancelled, []), Statement(}, [])])  Statement({, [])  MethodCall(Log.v(LOGTAG, ""LoadListener.handleSslErrorRequest(): url:"" + url() + "" primary error: "" + error.getPrimaryError() + "" certificate: "" + error.getCertificate()), [VariableReference(Log, []), Expression(LOGTAG, []), Expression(""LoadListener.handleSslErrorRequest(): url:"" + url() + "" primary error: "" + error.getPrimaryError() + "" certificate: "" + error.getCertificate(), [])])    VariableReference(Log, [])    Expression(LOGTAG, [])    Expression(""LoadListener.handleSslErrorRequest(): url:"" + url() + "" primary error: "" + error.getPrimaryError() + "" certificate: "" + error.getCertificate(), [])  Statement(}, [])  Statement(sendMessageInternal(obtainMessage(MSG_SSL_ERROR, error)), [])  Statement(// to unblock the network thread., [])  Statement(if (!mCancelled) {, [])  AssignmentExpression(=, [VariableReference(mSslErrorRequestHandle, []), Expression(mRequestHandle, [])])    VariableReference(mSslErrorRequestHandle, [])    Expression(mRequestHandle, [])  Statement(}, [])  Statement(return !mCancelled, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(Log.v(LOGTAG, ""LoadListener.handleSslErrorRequest(): url:"" + url() + "" primary error: "" + error.getPrimaryError() + "" certificate: "" + error.getCertificate()), [VariableReference(Log, []), Expression(LOGTAG, []), Expression(""LoadListener.handleSslErrorRequest(): url:"" + url() + "" primary error: "" + error.getPrimaryError() + "" certificate: "" + error.getCertificate(), [])]), Statement(}, []), Statement(// will prevent waiting for an already available answer., []), MethodCall(if (Network.getInstance(mContext).checkSslPrefTable(this, error)), [VariableReference(if (Network, []), Expression(mContext).checkSslPrefTable(this, []), Expression(error), [])]), Statement(return true, []), Statement(}, []), Statement(// deadlock. Just bail on the request., []), Statement(if (isSynchronous()) {, []), MethodCall(mRequestHandle.handleSslErrorResponse(false), [VariableReference(mRequestHandle, []), Expression(false, [])]), Statement(return true, []), Statement(}, []), Statement(sendMessageInternal(obtainMessage(MSG_SSL_ERROR, error)), []), Statement(// to unblock the network thread., []), Statement(if (!mCancelled) {, []), AssignmentExpression(=, [VariableReference(mSslErrorRequestHandle, []), Expression(mRequestHandle, [])]), Statement(}, []), Statement(return !mCancelled, []), Statement(}, [])])  Statement({, [])  MethodCall(Log.v(LOGTAG, ""LoadListener.handleSslErrorRequest(): url:"" + url() + "" primary error: "" + error.getPrimaryError() + "" certificate: "" + error.getCertificate()), [VariableReference(Log, []), Expression(LOGTAG, []), Expression(""LoadListener.handleSslErrorRequest(): url:"" + url() + "" primary error: "" + error.getPrimaryError() + "" certificate: "" + error.getCertificate(), [])])    VariableReference(Log, [])    Expression(LOGTAG, [])    Expression(""LoadListener.handleSslErrorRequest(): url:"" + url() + "" primary error: "" + error.getPrimaryError() + "" certificate: "" + error.getCertificate(), [])  Statement(}, [])  Statement(// will prevent waiting for an already available answer., [])  MethodCall(if (Network.getInstance(mContext).checkSslPrefTable(this, error)), [VariableReference(if (Network, []), Expression(mContext).checkSslPrefTable(this, []), Expression(error), [])])    VariableReference(if (Network, [])    Expression(mContext).checkSslPrefTable(this, [])    Expression(error), [])  Statement(return true, [])  Statement(}, [])  Statement(// deadlock. Just bail on the request., [])  Statement(if (isSynchronous()) {, [])  MethodCall(mRequestHandle.handleSslErrorResponse(false), [VariableReference(mRequestHandle, []), Expression(false, [])])    VariableReference(mRequestHandle, [])    Expression(false, [])  Statement(return true, [])  Statement(}, [])  Statement(sendMessageInternal(obtainMessage(MSG_SSL_ERROR, error)), [])  Statement(// to unblock the network thread., [])  Statement(if (!mCancelled) {, [])  AssignmentExpression(=, [VariableReference(mSslErrorRequestHandle, []), Expression(mRequestHandle, [])])    VariableReference(mSslErrorRequestHandle, [])    Expression(mRequestHandle, [])  Statement(}, [])  Statement(return !mCancelled, [])  Statement(}, [])",1,"/**
 * SSL certificate error callback. Handles SSL error(s) on the way up
 * to the user.
 * IMPORTANT: as this is called from network thread, can't call native
 * directly
 */
","/**
 * SSL certificate error callback. Handles SSL error(s) on the way up
 * to the user.
 * IMPORTANT: as this is called from network thread, can't call native
 * directly
 */
",-1,,,-1,-1,-1,-1,-1,"3,4",1,"2,5","1,2","The return statements and the control dependencies (if statements) have changed in the late version of the API. In the early version, there is only one return statement at the end of the method, and its value is determined by the variable `mCancelled`. In the late version, there are two additional return statements, one is inside an if statement that checks the result of `Network.getInstance(mContext).checkSslPrefTable(this, error)`, and the other is inside an if statement that checks the result of `isSynchronous()`. These changes can potentially lead to the API returning different values or throwing different exceptions.","The compatibility issues can be classified into two categories. The first one is caused by the potential different return values. In the early version, the API only returns `!mCancelled`, while in the late version, it can also return `true` in two different scenarios. This can cause compatibility issues if the client code is not prepared to handle these new return values. The second one is caused by the potential different exception handlings. The changes in the control dependencies can potentially lead to different exceptions being thrown in the late version of the API. For example, if the `Network.getInstance(mContext).checkSslPrefTable(this, error)` method throws an exception in the late version, it will not be caught by the client code that is only prepared to handle the exceptions in the early version."
297,"<android.pim.vcard.VCardUtils: String constructNameFromElements(int,String,String,String,String,String)>",7,8,"<android.pim.vcard.VCardUtils: String constructNameFromElements(int,String,String,String,String,String)>","<android.pim.vcard.VCardUtils: String constructNameFromElements(int,String,String,String,String,String)>",0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(StringBuilder builder, []), Expression(new StringBuilder(), [])]), AssignmentExpression(=, [VariableReference(String[] nameList, []), Expression(sortNameElements(nameOrderType, familyName, middleName, givenName), [])]), AssignmentExpression(=, [VariableReference(boolean first, []), Expression(true, [])]), MethodCall(if (!TextUtils.isEmpty(prefix)), [VariableReference(if (!TextUtils, []), Expression(prefix), [])]), AssignmentExpression(=, [VariableReference(first, []), Expression(false, [])]), MethodCall(builder.append(prefix), [VariableReference(builder, []), Expression(prefix, [])]), Statement(}, []), Statement(for (String namePart : nameList) {, []), MethodCall(if (!TextUtils.isEmpty(namePart)), [VariableReference(if (!TextUtils, []), Expression(namePart), [])]), Statement(if (first) {, []), AssignmentExpression(=, [VariableReference(first, []), Expression(false, [])]), Statement(} else {, []), MethodCall(builder.append(' '), [VariableReference(builder, []), Expression(' ', [])]), Statement(}, []), MethodCall(builder.append(namePart), [VariableReference(builder, []), Expression(namePart, [])]), Statement(}, []), Statement(}, []), MethodCall(if (!TextUtils.isEmpty(suffix)), [VariableReference(if (!TextUtils, []), Expression(suffix), [])]), Statement(if (!first) {, []), MethodCall(builder.append(' '), [VariableReference(builder, []), Expression(' ', [])]), Statement(}, []), MethodCall(builder.append(suffix), [VariableReference(builder, []), Expression(suffix, [])]), Statement(}, []), MethodCall(return builder.toString(), [VariableReference(return builder, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(StringBuilder builder, []), Expression(new StringBuilder(), [])])    VariableReference(StringBuilder builder, [])    Expression(new StringBuilder(), [])  AssignmentExpression(=, [VariableReference(String[] nameList, []), Expression(sortNameElements(nameOrderType, familyName, middleName, givenName), [])])    VariableReference(String[] nameList, [])    Expression(sortNameElements(nameOrderType, familyName, middleName, givenName), [])  AssignmentExpression(=, [VariableReference(boolean first, []), Expression(true, [])])    VariableReference(boolean first, [])    Expression(true, [])  MethodCall(if (!TextUtils.isEmpty(prefix)), [VariableReference(if (!TextUtils, []), Expression(prefix), [])])    VariableReference(if (!TextUtils, [])    Expression(prefix), [])  AssignmentExpression(=, [VariableReference(first, []), Expression(false, [])])    VariableReference(first, [])    Expression(false, [])  MethodCall(builder.append(prefix), [VariableReference(builder, []), Expression(prefix, [])])    VariableReference(builder, [])    Expression(prefix, [])  Statement(}, [])  Statement(for (String namePart : nameList) {, [])  MethodCall(if (!TextUtils.isEmpty(namePart)), [VariableReference(if (!TextUtils, []), Expression(namePart), [])])    VariableReference(if (!TextUtils, [])    Expression(namePart), [])  Statement(if (first) {, [])  AssignmentExpression(=, [VariableReference(first, []), Expression(false, [])])    VariableReference(first, [])    Expression(false, [])  Statement(} else {, [])  MethodCall(builder.append(' '), [VariableReference(builder, []), Expression(' ', [])])    VariableReference(builder, [])    Expression(' ', [])  Statement(}, [])  MethodCall(builder.append(namePart), [VariableReference(builder, []), Expression(namePart, [])])    VariableReference(builder, [])    Expression(namePart, [])  Statement(}, [])  Statement(}, [])  MethodCall(if (!TextUtils.isEmpty(suffix)), [VariableReference(if (!TextUtils, []), Expression(suffix), [])])    VariableReference(if (!TextUtils, [])    Expression(suffix), [])  Statement(if (!first) {, [])  MethodCall(builder.append(' '), [VariableReference(builder, []), Expression(' ', [])])    VariableReference(builder, [])    Expression(' ', [])  Statement(}, [])  MethodCall(builder.append(suffix), [VariableReference(builder, []), Expression(suffix, [])])    VariableReference(builder, [])    Expression(suffix, [])  Statement(}, [])  MethodCall(return builder.toString(), [VariableReference(return builder, []), Expression(, [])])    VariableReference(return builder, [])    Expression(, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final StringBuilder builder, []), Expression(new StringBuilder(), [])]), AssignmentExpression(=, [VariableReference(final String[] nameList, []), Expression(sortNameElements(vcardType, familyName, middleName, givenName), [])]), AssignmentExpression(=, [VariableReference(boolean first, []), Expression(true, [])]), MethodCall(if (!TextUtils.isEmpty(prefix)), [VariableReference(if (!TextUtils, []), Expression(prefix), [])]), AssignmentExpression(=, [VariableReference(first, []), Expression(false, [])]), MethodCall(builder.append(prefix), [VariableReference(builder, []), Expression(prefix, [])]), Statement(}, []), Statement(for (final String namePart : nameList) {, []), MethodCall(if (!TextUtils.isEmpty(namePart)), [VariableReference(if (!TextUtils, []), Expression(namePart), [])]), Statement(if (first) {, []), AssignmentExpression(=, [VariableReference(first, []), Expression(false, [])]), Statement(} else {, []), MethodCall(builder.append(' '), [VariableReference(builder, []), Expression(' ', [])]), Statement(}, []), MethodCall(builder.append(namePart), [VariableReference(builder, []), Expression(namePart, [])]), Statement(}, []), Statement(}, []), MethodCall(if (!TextUtils.isEmpty(suffix)), [VariableReference(if (!TextUtils, []), Expression(suffix), [])]), Statement(if (!first) {, []), MethodCall(builder.append(' '), [VariableReference(builder, []), Expression(' ', [])]), Statement(}, []), MethodCall(builder.append(suffix), [VariableReference(builder, []), Expression(suffix, [])]), Statement(}, []), MethodCall(return builder.toString(), [VariableReference(return builder, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final StringBuilder builder, []), Expression(new StringBuilder(), [])])    VariableReference(final StringBuilder builder, [])    Expression(new StringBuilder(), [])  AssignmentExpression(=, [VariableReference(final String[] nameList, []), Expression(sortNameElements(vcardType, familyName, middleName, givenName), [])])    VariableReference(final String[] nameList, [])    Expression(sortNameElements(vcardType, familyName, middleName, givenName), [])  AssignmentExpression(=, [VariableReference(boolean first, []), Expression(true, [])])    VariableReference(boolean first, [])    Expression(true, [])  MethodCall(if (!TextUtils.isEmpty(prefix)), [VariableReference(if (!TextUtils, []), Expression(prefix), [])])    VariableReference(if (!TextUtils, [])    Expression(prefix), [])  AssignmentExpression(=, [VariableReference(first, []), Expression(false, [])])    VariableReference(first, [])    Expression(false, [])  MethodCall(builder.append(prefix), [VariableReference(builder, []), Expression(prefix, [])])    VariableReference(builder, [])    Expression(prefix, [])  Statement(}, [])  Statement(for (final String namePart : nameList) {, [])  MethodCall(if (!TextUtils.isEmpty(namePart)), [VariableReference(if (!TextUtils, []), Expression(namePart), [])])    VariableReference(if (!TextUtils, [])    Expression(namePart), [])  Statement(if (first) {, [])  AssignmentExpression(=, [VariableReference(first, []), Expression(false, [])])    VariableReference(first, [])    Expression(false, [])  Statement(} else {, [])  MethodCall(builder.append(' '), [VariableReference(builder, []), Expression(' ', [])])    VariableReference(builder, [])    Expression(' ', [])  Statement(}, [])  MethodCall(builder.append(namePart), [VariableReference(builder, []), Expression(namePart, [])])    VariableReference(builder, [])    Expression(namePart, [])  Statement(}, [])  Statement(}, [])  MethodCall(if (!TextUtils.isEmpty(suffix)), [VariableReference(if (!TextUtils, []), Expression(suffix), [])])    VariableReference(if (!TextUtils, [])    Expression(suffix), [])  Statement(if (!first) {, [])  MethodCall(builder.append(' '), [VariableReference(builder, []), Expression(' ', [])])    VariableReference(builder, [])    Expression(' ', [])  Statement(}, [])  MethodCall(builder.append(suffix), [VariableReference(builder, []), Expression(suffix, [])])    VariableReference(builder, [])    Expression(suffix, [])  Statement(}, [])  MethodCall(return builder.toString(), [VariableReference(return builder, []), Expression(, [])])    VariableReference(return builder, [])    Expression(, [])  Statement(}, [])",1,,,-1,,,-1,-1,-1,-1,-1,"4,5",1,4,0,The code change is about the addition of the keyword 'final' in the declaration of 'StringBuilder builder' and 'String[] nameList' variables in the late version.,"The addition of the 'final' keyword only affects the mutability of the variable within the method, and does not have any impact on the behaviour of the API, hence no Compatibility Issue exists."
147,<android.widget.TextView: float getLeftFadingEdgeStrength()>,18,19,<android.widget.TextView: float getLeftFadingEdgeStrength()>,<android.widget.TextView: float getLeftFadingEdgeStrength()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mEllipsize, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(if (mMarquee !, []), Expression(null && !mMarquee.isStopped()) {, [])]), AssignmentExpression(=, [VariableReference(final Marquee marquee, []), Expression(mMarquee, [])]), MethodCall(if (marquee.shouldDrawLeftFade()), [VariableReference(if (marquee, []), Expression(), [])]), AssignmentExpression(=, [VariableReference(final float scroll, []), Expression(marquee.getScroll(), [])]), Statement(return scroll / getHorizontalFadingEdgeLength(), []), Statement(} else {, []), Statement(return 0.0f, []), Statement(}, []), AssignmentExpression(=, [VariableReference(} else if (getLineCount(), []), Expression(, [])]), AssignmentExpression(=, [VariableReference(final int layoutDirection, []), Expression(getLayoutDirection(), [])]), AssignmentExpression(=, [VariableReference(final int absoluteGravity, []), Expression(Gravity.getAbsoluteGravity(mGravity, layoutDirection), [])]), Statement(case Gravity.LEFT:, []), Statement(return 0.0f, []), Statement(case Gravity.RIGHT:, []), MethodCall(return (mLayout.getLineRight(0) - (mRight - mLeft) - getCompoundPaddingLeft() - getCompoundPaddingRight() - mLayout.getLineLeft(0)) / getHorizontalFadingEdgeLength(), [VariableReference(return (mLayout, []), Expression(0) - (mRight - mLeft) - getCompoundPaddingLeft() - getCompoundPaddingRight() - mLayout.getLineLeft(0)) / getHorizontalFadingEdgeLength(, [])]), Statement(case Gravity.CENTER_HORIZONTAL:, []), Statement(return 0.0f, []), Statement(}, []), Statement(}, []), Statement(}, []), MethodCall(return super.getLeftFadingEdgeStrength(), [VariableReference(return super, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mEllipsize, []), Expression(, [])])    VariableReference(if (mEllipsize, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(if (mMarquee !, []), Expression(null && !mMarquee.isStopped()) {, [])])    VariableReference(if (mMarquee !, [])    Expression(null && !mMarquee.isStopped()) {, [])  AssignmentExpression(=, [VariableReference(final Marquee marquee, []), Expression(mMarquee, [])])    VariableReference(final Marquee marquee, [])    Expression(mMarquee, [])  MethodCall(if (marquee.shouldDrawLeftFade()), [VariableReference(if (marquee, []), Expression(), [])])    VariableReference(if (marquee, [])    Expression(), [])  AssignmentExpression(=, [VariableReference(final float scroll, []), Expression(marquee.getScroll(), [])])    VariableReference(final float scroll, [])    Expression(marquee.getScroll(), [])  Statement(return scroll / getHorizontalFadingEdgeLength(), [])  Statement(} else {, [])  Statement(return 0.0f, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(} else if (getLineCount(), []), Expression(, [])])    VariableReference(} else if (getLineCount(), [])    Expression(, [])  AssignmentExpression(=, [VariableReference(final int layoutDirection, []), Expression(getLayoutDirection(), [])])    VariableReference(final int layoutDirection, [])    Expression(getLayoutDirection(), [])  AssignmentExpression(=, [VariableReference(final int absoluteGravity, []), Expression(Gravity.getAbsoluteGravity(mGravity, layoutDirection), [])])    VariableReference(final int absoluteGravity, [])    Expression(Gravity.getAbsoluteGravity(mGravity, layoutDirection), [])  Statement(case Gravity.LEFT:, [])  Statement(return 0.0f, [])  Statement(case Gravity.RIGHT:, [])  MethodCall(return (mLayout.getLineRight(0) - (mRight - mLeft) - getCompoundPaddingLeft() - getCompoundPaddingRight() - mLayout.getLineLeft(0)) / getHorizontalFadingEdgeLength(), [VariableReference(return (mLayout, []), Expression(0) - (mRight - mLeft) - getCompoundPaddingLeft() - getCompoundPaddingRight() - mLayout.getLineLeft(0)) / getHorizontalFadingEdgeLength(, [])])    VariableReference(return (mLayout, [])    Expression(0) - (mRight - mLeft) - getCompoundPaddingLeft() - getCompoundPaddingRight() - mLayout.getLineLeft(0)) / getHorizontalFadingEdgeLength(, [])  Statement(case Gravity.CENTER_HORIZONTAL:, [])  Statement(return 0.0f, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  MethodCall(return super.getLeftFadingEdgeStrength(), [VariableReference(return super, []), Expression(, [])])    VariableReference(return super, [])    Expression(, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mEllipsize, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(if (mMarquee !, []), Expression(null && !mMarquee.isStopped()) {, [])]), AssignmentExpression(=, [VariableReference(final Marquee marquee, []), Expression(mMarquee, [])]), MethodCall(if (marquee.shouldDrawLeftFade()), [VariableReference(if (marquee, []), Expression(), [])]), AssignmentExpression(=, [VariableReference(final float scroll, []), Expression(marquee.getScroll(), [])]), Statement(return scroll / getHorizontalFadingEdgeLength(), []), Statement(} else {, []), Statement(return 0.0f, []), Statement(}, []), AssignmentExpression(=, [VariableReference(} else if (getLineCount(), []), Expression(, [])]), AssignmentExpression(=, [VariableReference(final int layoutDirection, []), Expression(getLayoutDirection(), [])]), AssignmentExpression(=, [VariableReference(final int absoluteGravity, []), Expression(Gravity.getAbsoluteGravity(mGravity, layoutDirection), [])]), Statement(case Gravity.LEFT:, []), Statement(return 0.0f, []), Statement(case Gravity.RIGHT:, []), MethodCall(return (mLayout.getLineRight(0) - (mRight - mLeft) - getCompoundPaddingLeft() - getCompoundPaddingRight() - mLayout.getLineLeft(0)) / getHorizontalFadingEdgeLength(), [VariableReference(return (mLayout, []), Expression(0) - (mRight - mLeft) - getCompoundPaddingLeft() - getCompoundPaddingRight() - mLayout.getLineLeft(0)) / getHorizontalFadingEdgeLength(, [])]), Statement(case Gravity.CENTER_HORIZONTAL:, []), Statement(case Gravity.FILL_HORIZONTAL:, []), AssignmentExpression(=, [VariableReference(final int textDirection, []), Expression(mLayout.getParagraphDirection(0), [])]), AssignmentExpression(=, [VariableReference(if (textDirection, []), Expression(, [])]), Statement(return 0.0f, []), Statement(} else {, []), MethodCall(return (mLayout.getLineRight(0) - (mRight - mLeft) - getCompoundPaddingLeft() - getCompoundPaddingRight() - mLayout.getLineLeft(0)) / getHorizontalFadingEdgeLength(), [VariableReference(return (mLayout, []), Expression(0) - (mRight - mLeft) - getCompoundPaddingLeft() - getCompoundPaddingRight() - mLayout.getLineLeft(0)) / getHorizontalFadingEdgeLength(, [])]), Statement(}, []), Statement(}, []), Statement(}, []), Statement(}, []), MethodCall(return super.getLeftFadingEdgeStrength(), [VariableReference(return super, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mEllipsize, []), Expression(, [])])    VariableReference(if (mEllipsize, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(if (mMarquee !, []), Expression(null && !mMarquee.isStopped()) {, [])])    VariableReference(if (mMarquee !, [])    Expression(null && !mMarquee.isStopped()) {, [])  AssignmentExpression(=, [VariableReference(final Marquee marquee, []), Expression(mMarquee, [])])    VariableReference(final Marquee marquee, [])    Expression(mMarquee, [])  MethodCall(if (marquee.shouldDrawLeftFade()), [VariableReference(if (marquee, []), Expression(), [])])    VariableReference(if (marquee, [])    Expression(), [])  AssignmentExpression(=, [VariableReference(final float scroll, []), Expression(marquee.getScroll(), [])])    VariableReference(final float scroll, [])    Expression(marquee.getScroll(), [])  Statement(return scroll / getHorizontalFadingEdgeLength(), [])  Statement(} else {, [])  Statement(return 0.0f, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(} else if (getLineCount(), []), Expression(, [])])    VariableReference(} else if (getLineCount(), [])    Expression(, [])  AssignmentExpression(=, [VariableReference(final int layoutDirection, []), Expression(getLayoutDirection(), [])])    VariableReference(final int layoutDirection, [])    Expression(getLayoutDirection(), [])  AssignmentExpression(=, [VariableReference(final int absoluteGravity, []), Expression(Gravity.getAbsoluteGravity(mGravity, layoutDirection), [])])    VariableReference(final int absoluteGravity, [])    Expression(Gravity.getAbsoluteGravity(mGravity, layoutDirection), [])  Statement(case Gravity.LEFT:, [])  Statement(return 0.0f, [])  Statement(case Gravity.RIGHT:, [])  MethodCall(return (mLayout.getLineRight(0) - (mRight - mLeft) - getCompoundPaddingLeft() - getCompoundPaddingRight() - mLayout.getLineLeft(0)) / getHorizontalFadingEdgeLength(), [VariableReference(return (mLayout, []), Expression(0) - (mRight - mLeft) - getCompoundPaddingLeft() - getCompoundPaddingRight() - mLayout.getLineLeft(0)) / getHorizontalFadingEdgeLength(, [])])    VariableReference(return (mLayout, [])    Expression(0) - (mRight - mLeft) - getCompoundPaddingLeft() - getCompoundPaddingRight() - mLayout.getLineLeft(0)) / getHorizontalFadingEdgeLength(, [])  Statement(case Gravity.CENTER_HORIZONTAL:, [])  Statement(case Gravity.FILL_HORIZONTAL:, [])  AssignmentExpression(=, [VariableReference(final int textDirection, []), Expression(mLayout.getParagraphDirection(0), [])])    VariableReference(final int textDirection, [])    Expression(mLayout.getParagraphDirection(0), [])  AssignmentExpression(=, [VariableReference(if (textDirection, []), Expression(, [])])    VariableReference(if (textDirection, [])    Expression(, [])  Statement(return 0.0f, [])  Statement(} else {, [])  MethodCall(return (mLayout.getLineRight(0) - (mRight - mLeft) - getCompoundPaddingLeft() - getCompoundPaddingRight() - mLayout.getLineLeft(0)) / getHorizontalFadingEdgeLength(), [VariableReference(return (mLayout, []), Expression(0) - (mRight - mLeft) - getCompoundPaddingLeft() - getCompoundPaddingRight() - mLayout.getLineLeft(0)) / getHorizontalFadingEdgeLength(, [])])    VariableReference(return (mLayout, [])    Expression(0) - (mRight - mLeft) - getCompoundPaddingLeft() - getCompoundPaddingRight() - mLayout.getLineLeft(0)) / getHorizontalFadingEdgeLength(, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  MethodCall(return super.getLeftFadingEdgeStrength(), [VariableReference(return super, []), Expression(, [])])    VariableReference(return super, [])    Expression(, [])  Statement(}, [])",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,"1,3,4",1,3,1,"A new case, ""case Gravity.FILL\_HORIZONTAL:"", has been added in the switch statement, and the code inside the case is not the same as the default code.",The new case "case Gravity.FILL\_HORIZONTAL:" will lead to different return value when the absoluteGravity is Gravity.FILL\_HORIZONTAL in the late version.
615,"<android.webkit.CallbackProxy: void onTooManyRedirects(Message,Message)>",7,8,"<android.webkit.CallbackProxy: void onTooManyRedirects(Message,Message)>","<android.webkit.CallbackProxy: void onTooManyRedirects(Message,Message)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(// been set., []), AssignmentExpression(=, [VariableReference(if (mWebViewClient, []), Expression(, [])]), MethodCall(cancelMsg.sendToTarget(), [VariableReference(cancelMsg, []), Expression(, [])]), Statement(return, []), Statement(}, []), AssignmentExpression(=, [VariableReference(Message msg, []), Expression(obtainMessage(TOO_MANY_REDIRECTS), [])]), AssignmentExpression(=, [VariableReference(Bundle bundle, []), Expression(msg.getData(), [])]), MethodCall(bundle.putParcelable(""cancelMsg"", cancelMsg), [VariableReference(bundle, []), Expression(""cancelMsg"", []), Expression(cancelMsg, [])]), MethodCall(bundle.putParcelable(""continueMsg"", continueMsg), [VariableReference(bundle, []), Expression(""continueMsg"", []), Expression(continueMsg, [])]), Statement(sendMessage(msg), []), Statement(}, [])])  Statement({, [])  Statement(// been set., [])  AssignmentExpression(=, [VariableReference(if (mWebViewClient, []), Expression(, [])])    VariableReference(if (mWebViewClient, [])    Expression(, [])  MethodCall(cancelMsg.sendToTarget(), [VariableReference(cancelMsg, []), Expression(, [])])    VariableReference(cancelMsg, [])    Expression(, [])  Statement(return, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(Message msg, []), Expression(obtainMessage(TOO_MANY_REDIRECTS), [])])    VariableReference(Message msg, [])    Expression(obtainMessage(TOO_MANY_REDIRECTS), [])  AssignmentExpression(=, [VariableReference(Bundle bundle, []), Expression(msg.getData(), [])])    VariableReference(Bundle bundle, [])    Expression(msg.getData(), [])  MethodCall(bundle.putParcelable(""cancelMsg"", cancelMsg), [VariableReference(bundle, []), Expression(""cancelMsg"", []), Expression(cancelMsg, [])])    VariableReference(bundle, [])    Expression(""cancelMsg"", [])    Expression(cancelMsg, [])  MethodCall(bundle.putParcelable(""continueMsg"", continueMsg), [VariableReference(bundle, []), Expression(""continueMsg"", []), Expression(continueMsg, [])])    VariableReference(bundle, [])    Expression(""continueMsg"", [])    Expression(continueMsg, [])  Statement(sendMessage(msg), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(// deprecated., []), Statement(}, [])])  Statement({, [])  Statement(// deprecated., [])  Statement(}, [])",1,,"// party of the public classes, we cannot remove this method.
",-1,,,-1,-1,-1,-1,-1,4,1,5,1,"The implementation of the API has been entirely changed. In the early version, it has a more complex implementation that involves control dependency, method calls, and return statements. In the late version, the implementation is much simpler and only has a comment that indicates the method is deprecated.","The change in the implementation could potentially lead to compatibility issues as the API might not function as expected in the late version. The return statement in the early version might be used to return a specific value or object, but this is no longer present in the late version. This might cause issues for the code that relies on the returned value or object from this API."
209,<android.content.Intent: String toUri(int)>,21,22,<android.content.Intent: String toUri(int)>,<android.content.Intent: String toUri(int)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(StringBuilder uri, []), Expression(new StringBuilder(128), [])]), AssignmentExpression(=, [VariableReference(String scheme, []), Expression(null, [])]), AssignmentExpression(=, [VariableReference(if (mData !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(String data, []), Expression(mData.toString(), [])]), AssignmentExpression(=, [VariableReference(if ((flags & URI_INTENT_SCHEME) !, []), Expression(0) {, [])]), AssignmentExpression(=, [VariableReference(final int N, []), Expression(data.length(), [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < N, []), Statement(i++) {, []), AssignmentExpression(=, [VariableReference(char c, []), Expression(data.charAt(i), [])]), AssignmentExpression(=, [VariableReference(if ((c >, []), Expression('a' && c <, [])]), Statement(continue, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (c, []), Expression(, [])]), Statement(// Valid scheme., []), AssignmentExpression(=, [VariableReference(scheme, []), Expression(data.substring(0, i), [])]), MethodCall(uri.append(""intent:""), [VariableReference(uri, []), Expression(""intent:"", [])]), AssignmentExpression(=, [VariableReference(data, []), Expression(data.substring(i + 1), [])]), Statement(break, []), Statement(}, []), Statement(// No scheme., []), Statement(break, []), Statement(}, []), Statement(}, []), MethodCall(uri.append(data), [VariableReference(uri, []), Expression(data, [])]), AssignmentExpression(=, [VariableReference(} else if ((flags & URI_INTENT_SCHEME) !, []), Expression(0) {, [])]), MethodCall(uri.append(""intent:""), [VariableReference(uri, []), Expression(""intent:"", [])]), Statement(}, []), Statement(""), []), Statement(toUriInner(uri, scheme, flags), []), AssignmentExpression(=, [VariableReference(if (mSelector !, []), Expression(null) {, [])]), Statement(""), []), Statement(// Note that for now we are not going to try to handle the, []), Statement(// data part, []), Statement(not clear how to represent this as a URI, and, []), Statement(// not much utility in it., []), MethodCall(mSelector.toUriInner(uri, null, flags), [VariableReference(mSelector, []), Expression(uri, []), Expression(null, []), Expression(flags, [])]), Statement(}, []), MethodCall(uri.append(""end""), [VariableReference(uri, []), Expression(""end"", [])]), MethodCall(return uri.toString(), [VariableReference(return uri, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(StringBuilder uri, []), Expression(new StringBuilder(128), [])])    VariableReference(StringBuilder uri, [])    Expression(new StringBuilder(128), [])  AssignmentExpression(=, [VariableReference(String scheme, []), Expression(null, [])])    VariableReference(String scheme, [])    Expression(null, [])  AssignmentExpression(=, [VariableReference(if (mData !, []), Expression(null) {, [])])    VariableReference(if (mData !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(String data, []), Expression(mData.toString(), [])])    VariableReference(String data, [])    Expression(mData.toString(), [])  AssignmentExpression(=, [VariableReference(if ((flags & URI_INTENT_SCHEME) !, []), Expression(0) {, [])])    VariableReference(if ((flags & URI_INTENT_SCHEME) !, [])    Expression(0) {, [])  AssignmentExpression(=, [VariableReference(final int N, []), Expression(data.length(), [])])    VariableReference(final int N, [])    Expression(data.length(), [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < N, [])  Statement(i++) {, [])  AssignmentExpression(=, [VariableReference(char c, []), Expression(data.charAt(i), [])])    VariableReference(char c, [])    Expression(data.charAt(i), [])  AssignmentExpression(=, [VariableReference(if ((c >, []), Expression('a' && c <, [])])    VariableReference(if ((c >, [])    Expression('a' && c <, [])  Statement(continue, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (c, []), Expression(, [])])    VariableReference(if (c, [])    Expression(, [])  Statement(// Valid scheme., [])  AssignmentExpression(=, [VariableReference(scheme, []), Expression(data.substring(0, i), [])])    VariableReference(scheme, [])    Expression(data.substring(0, i), [])  MethodCall(uri.append(""intent:""), [VariableReference(uri, []), Expression(""intent:"", [])])    VariableReference(uri, [])    Expression(""intent:"", [])  AssignmentExpression(=, [VariableReference(data, []), Expression(data.substring(i + 1), [])])    VariableReference(data, [])    Expression(data.substring(i + 1), [])  Statement(break, [])  Statement(}, [])  Statement(// No scheme., [])  Statement(break, [])  Statement(}, [])  Statement(}, [])  MethodCall(uri.append(data), [VariableReference(uri, []), Expression(data, [])])    VariableReference(uri, [])    Expression(data, [])  AssignmentExpression(=, [VariableReference(} else if ((flags & URI_INTENT_SCHEME) !, []), Expression(0) {, [])])    VariableReference(} else if ((flags & URI_INTENT_SCHEME) !, [])    Expression(0) {, [])  MethodCall(uri.append(""intent:""), [VariableReference(uri, []), Expression(""intent:"", [])])    VariableReference(uri, [])    Expression(""intent:"", [])  Statement(}, [])  Statement(""), [])  Statement(toUriInner(uri, scheme, flags), [])  AssignmentExpression(=, [VariableReference(if (mSelector !, []), Expression(null) {, [])])    VariableReference(if (mSelector !, [])    Expression(null) {, [])  Statement(""), [])  Statement(// Note that for now we are not going to try to handle the, [])  Statement(// data part, [])  Statement(not clear how to represent this as a URI, and, [])  Statement(// not much utility in it., [])  MethodCall(mSelector.toUriInner(uri, null, flags), [VariableReference(mSelector, []), Expression(uri, []), Expression(null, []), Expression(flags, [])])    VariableReference(mSelector, [])    Expression(uri, [])    Expression(null, [])    Expression(flags, [])  Statement(}, [])  MethodCall(uri.append(""end""), [VariableReference(uri, []), Expression(""end"", [])])    VariableReference(uri, [])    Expression(""end"", [])  MethodCall(return uri.toString(), [VariableReference(return uri, []), Expression(, [])])    VariableReference(return uri, [])    Expression(, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(StringBuilder uri, []), Expression(new StringBuilder(128), [])]), AssignmentExpression(=, [VariableReference(if ((flags & URI_ANDROID_APP_SCHEME) !, []), Expression(0) {, [])]), AssignmentExpression(=, [VariableReference(if (mPackage, []), Expression(, [])]), Statement(throw new IllegalArgumentException(""Intent must include an explicit package name to build an android-app: "" + this), []), Statement(}, []), MethodCall(uri.append(""android-app://""), [VariableReference(uri, []), Expression(""android-app://"", [])]), MethodCall(uri.append(mPackage), [VariableReference(uri, []), Expression(mPackage, [])]), AssignmentExpression(=, [VariableReference(String scheme, []), Expression(null, [])]), AssignmentExpression(=, [VariableReference(if (mData !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(scheme, []), Expression(mData.getScheme(), [])]), AssignmentExpression(=, [VariableReference(if (scheme !, []), Expression(null) {, [])]), MethodCall(uri.append('/'), [VariableReference(uri, []), Expression('/', [])]), MethodCall(uri.append(scheme), [VariableReference(uri, []), Expression(scheme, [])]), AssignmentExpression(=, [VariableReference(String authority, []), Expression(mData.getEncodedAuthority(), [])]), AssignmentExpression(=, [VariableReference(if (authority !, []), Expression(null) {, [])]), MethodCall(uri.append('/'), [VariableReference(uri, []), Expression('/', [])]), MethodCall(uri.append(authority), [VariableReference(uri, []), Expression(authority, [])]), AssignmentExpression(=, [VariableReference(String path, []), Expression(mData.getEncodedPath(), [])]), AssignmentExpression(=, [VariableReference(if (path !, []), Expression(null) {, [])]), MethodCall(uri.append(path), [VariableReference(uri, []), Expression(path, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(String queryParams, []), Expression(mData.getEncodedQuery(), [])]), AssignmentExpression(=, [VariableReference(if (queryParams !, []), Expression(null) {, [])]), MethodCall(uri.append('?'), [VariableReference(uri, []), Expression('?', [])]), MethodCall(uri.append(queryParams), [VariableReference(uri, []), Expression(queryParams, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(String fragment, []), Expression(mData.getEncodedFragment(), [])]), AssignmentExpression(=, [VariableReference(if (fragment !, []), Expression(null) {, [])]), MethodCall(uri.append('#'), [VariableReference(uri, []), Expression('#', [])]), MethodCall(uri.append(fragment), [VariableReference(uri, []), Expression(fragment, [])]), Statement(}, []), Statement(}, []), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(toUriFragment(uri, null, scheme, []), Expression(, [])]), MethodCall(return uri.toString(), [VariableReference(return uri, []), Expression(, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(String scheme, []), Expression(null, [])]), AssignmentExpression(=, [VariableReference(if (mData !, []), Expression(null) {, [])]), AssignmentExpression(=, [VariableReference(String data, []), Expression(mData.toString(), [])]), AssignmentExpression(=, [VariableReference(if ((flags & URI_INTENT_SCHEME) !, []), Expression(0) {, [])]), AssignmentExpression(=, [VariableReference(final int N, []), Expression(data.length(), [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < N, []), Statement(i++) {, []), AssignmentExpression(=, [VariableReference(char c, []), Expression(data.charAt(i), [])]), AssignmentExpression(=, [VariableReference(if ((c >, []), Expression('a' && c <, [])]), Statement(continue, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (c, []), Expression(, [])]), Statement(// Valid scheme., []), AssignmentExpression(=, [VariableReference(scheme, []), Expression(data.substring(0, i), [])]), MethodCall(uri.append(""intent:""), [VariableReference(uri, []), Expression(""intent:"", [])]), AssignmentExpression(=, [VariableReference(data, []), Expression(data.substring(i + 1), [])]), Statement(break, []), Statement(}, []), Statement(// No scheme., []), Statement(break, []), Statement(}, []), Statement(}, []), MethodCall(uri.append(data), [VariableReference(uri, []), Expression(data, [])]), AssignmentExpression(=, [VariableReference(} else if ((flags & URI_INTENT_SCHEME) !, []), Expression(0) {, [])]), MethodCall(uri.append(""intent:""), [VariableReference(uri, []), Expression(""intent:"", [])]), Statement(}, []), MethodCall(return uri.toString(), [VariableReference(return uri, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(StringBuilder uri, []), Expression(new StringBuilder(128), [])])    VariableReference(StringBuilder uri, [])    Expression(new StringBuilder(128), [])  AssignmentExpression(=, [VariableReference(if ((flags & URI_ANDROID_APP_SCHEME) !, []), Expression(0) {, [])])    VariableReference(if ((flags & URI_ANDROID_APP_SCHEME) !, [])    Expression(0) {, [])  AssignmentExpression(=, [VariableReference(if (mPackage, []), Expression(, [])])    VariableReference(if (mPackage, [])    Expression(, [])  Statement(throw new IllegalArgumentException(""Intent must include an explicit package name to build an android-app: "" + this), [])  Statement(}, [])  MethodCall(uri.append(""android-app://""), [VariableReference(uri, []), Expression(""android-app://"", [])])    VariableReference(uri, [])    Expression(""android-app://"", [])  MethodCall(uri.append(mPackage), [VariableReference(uri, []), Expression(mPackage, [])])    VariableReference(uri, [])    Expression(mPackage, [])  AssignmentExpression(=, [VariableReference(String scheme, []), Expression(null, [])])    VariableReference(String scheme, [])    Expression(null, [])  AssignmentExpression(=, [VariableReference(if (mData !, []), Expression(null) {, [])])    VariableReference(if (mData !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(scheme, []), Expression(mData.getScheme(), [])])    VariableReference(scheme, [])    Expression(mData.getScheme(), [])  AssignmentExpression(=, [VariableReference(if (scheme !, []), Expression(null) {, [])])    VariableReference(if (scheme !, [])    Expression(null) {, [])  MethodCall(uri.append('/'), [VariableReference(uri, []), Expression('/', [])])    VariableReference(uri, [])    Expression('/', [])  MethodCall(uri.append(scheme), [VariableReference(uri, []), Expression(scheme, [])])    VariableReference(uri, [])    Expression(scheme, [])  AssignmentExpression(=, [VariableReference(String authority, []), Expression(mData.getEncodedAuthority(), [])])    VariableReference(String authority, [])    Expression(mData.getEncodedAuthority(), [])  AssignmentExpression(=, [VariableReference(if (authority !, []), Expression(null) {, [])])    VariableReference(if (authority !, [])    Expression(null) {, [])  MethodCall(uri.append('/'), [VariableReference(uri, []), Expression('/', [])])    VariableReference(uri, [])    Expression('/', [])  MethodCall(uri.append(authority), [VariableReference(uri, []), Expression(authority, [])])    VariableReference(uri, [])    Expression(authority, [])  AssignmentExpression(=, [VariableReference(String path, []), Expression(mData.getEncodedPath(), [])])    VariableReference(String path, [])    Expression(mData.getEncodedPath(), [])  AssignmentExpression(=, [VariableReference(if (path !, []), Expression(null) {, [])])    VariableReference(if (path !, [])    Expression(null) {, [])  MethodCall(uri.append(path), [VariableReference(uri, []), Expression(path, [])])    VariableReference(uri, [])    Expression(path, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(String queryParams, []), Expression(mData.getEncodedQuery(), [])])    VariableReference(String queryParams, [])    Expression(mData.getEncodedQuery(), [])  AssignmentExpression(=, [VariableReference(if (queryParams !, []), Expression(null) {, [])])    VariableReference(if (queryParams !, [])    Expression(null) {, [])  MethodCall(uri.append('?'), [VariableReference(uri, []), Expression('?', [])])    VariableReference(uri, [])    Expression('?', [])  MethodCall(uri.append(queryParams), [VariableReference(uri, []), Expression(queryParams, [])])    VariableReference(uri, [])    Expression(queryParams, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(String fragment, []), Expression(mData.getEncodedFragment(), [])])    VariableReference(String fragment, [])    Expression(mData.getEncodedFragment(), [])  AssignmentExpression(=, [VariableReference(if (fragment !, []), Expression(null) {, [])])    VariableReference(if (fragment !, [])    Expression(null) {, [])  MethodCall(uri.append('#'), [VariableReference(uri, []), Expression('#', [])])    VariableReference(uri, [])    Expression('#', [])  MethodCall(uri.append(fragment), [VariableReference(uri, []), Expression(fragment, [])])    VariableReference(uri, [])    Expression(fragment, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(toUriFragment(uri, null, scheme, []), Expression(, [])])    VariableReference(toUriFragment(uri, null, scheme, [])    Expression(, [])  MethodCall(return uri.toString(), [VariableReference(return uri, []), Expression(, [])])    VariableReference(return uri, [])    Expression(, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(String scheme, []), Expression(null, [])])    VariableReference(String scheme, [])    Expression(null, [])  AssignmentExpression(=, [VariableReference(if (mData !, []), Expression(null) {, [])])    VariableReference(if (mData !, [])    Expression(null) {, [])  AssignmentExpression(=, [VariableReference(String data, []), Expression(mData.toString(), [])])    VariableReference(String data, [])    Expression(mData.toString(), [])  AssignmentExpression(=, [VariableReference(if ((flags & URI_INTENT_SCHEME) !, []), Expression(0) {, [])])    VariableReference(if ((flags & URI_INTENT_SCHEME) !, [])    Expression(0) {, [])  AssignmentExpression(=, [VariableReference(final int N, []), Expression(data.length(), [])])    VariableReference(final int N, [])    Expression(data.length(), [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < N, [])  Statement(i++) {, [])  AssignmentExpression(=, [VariableReference(char c, []), Expression(data.charAt(i), [])])    VariableReference(char c, [])    Expression(data.charAt(i), [])  AssignmentExpression(=, [VariableReference(if ((c >, []), Expression('a' && c <, [])])    VariableReference(if ((c >, [])    Expression('a' && c <, [])  Statement(continue, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (c, []), Expression(, [])])    VariableReference(if (c, [])    Expression(, [])  Statement(// Valid scheme., [])  AssignmentExpression(=, [VariableReference(scheme, []), Expression(data.substring(0, i), [])])    VariableReference(scheme, [])    Expression(data.substring(0, i), [])  MethodCall(uri.append(""intent:""), [VariableReference(uri, []), Expression(""intent:"", [])])    VariableReference(uri, [])    Expression(""intent:"", [])  AssignmentExpression(=, [VariableReference(data, []), Expression(data.substring(i + 1), [])])    VariableReference(data, [])    Expression(data.substring(i + 1), [])  Statement(break, [])  Statement(}, [])  Statement(// No scheme., [])  Statement(break, [])  Statement(}, [])  Statement(}, [])  MethodCall(uri.append(data), [VariableReference(uri, []), Expression(data, [])])    VariableReference(uri, [])    Expression(data, [])  AssignmentExpression(=, [VariableReference(} else if ((flags & URI_INTENT_SCHEME) !, []), Expression(0) {, [])])    VariableReference(} else if ((flags & URI_INTENT_SCHEME) !, [])    Expression(0) {, [])  MethodCall(uri.append(""intent:""), [VariableReference(uri, []), Expression(""intent:"", [])])    VariableReference(uri, [])    Expression(""intent:"", [])  Statement(}, [])  MethodCall(return uri.toString(), [VariableReference(return uri, []), Expression(, [])])    VariableReference(return uri, [])    Expression(, [])  Statement(}, [])",1,"/**
 * Convert this Intent into a String holding a URI representation of it.
 * The returned URI string has been properly URI encoded, so it can be
 * used with {@link Uri#parse Uri.parse(String)}.  The URI contains the
 * Intent's data as the base URI, with an additional fragment describing
 * the action, categories, type, flags, package, component, and extras.
 *
 * <p>You can convert the returned string back to an Intent with
 * {@link #getIntent}.
 *
 * @param flags Additional operating flags.  Either 0 or
 * {@link #URI_INTENT_SCHEME}.
 *
 * @return Returns a URI encoding URI string describing the entire contents
 * of the Intent.
 */
","/**
 * Convert this Intent into a String holding a URI representation of it.
 * The returned URI string has been properly URI encoded, so it can be
 * used with {@link Uri#parse Uri.parse(String)}.  The URI contains the
 * Intent's data as the base URI, with an additional fragment describing
 * the action, categories, type, flags, package, component, and extras.
 *
 * <p>You can convert the returned string back to an Intent with
 * {@link #getIntent}.
 *
 * @param flags Additional operating flags.  Either 0,
 * {@link #URI_INTENT_SCHEME}, or {@link #URI_ANDROID_APP_SCHEME}.
 *
 * @return Returns a URI encoding URI string describing the entire contents
 * of the Intent.
 */
",-1,,,-1,-1,-1,-1,-1,"1,3,4",1,"1,2,3","1,2","The early version implementation firstly checks whether the data part of the Intent exists or not. If it does, the method will parse the data part to find the scheme of the URI and append ""intent:"" to the StringBuilder. Then, the method appends the remaining part of the data to the StringBuilder. If the data part does not exist, the method directly appends ""intent:"" to the StringBuilder. In the late version implementation, the method directly appends ""android-app://"" to the StringBuilder and then appends the package name of the Intent. After that, the method checks whether the data part of the Intent exists or not. If it does, the method parses the data part to find the scheme and authority of the URI and append them to the StringBuilder. Then, the method appends the remaining part of the data to the StringBuilder. If the data part does not exist, the method directly appends the path, query, and fragment of the Intent to the StringBuilder. The control dependency has changed from depending on the existence of the data part to the existence of the package name and the data part. The return statement and exception handling statement have also changed.","The compatibility issue arises from the different behaviors of the early and late version implementations when parsing the Intent to a URI. In the early version, the method only supports parsing the data part of the Intent to a URI with the scheme ""intent:"". In the late version, the method supports parsing the Intent to a URI with the scheme ""android-app://"" and also supports parsing the data part of the Intent to a URI with different schemes and authorities. Therefore, if an application uses the early version implementation to parse an Intent with a data part that has a scheme other than ""intent:,"" or has an authority, the resulting URI will be different from the one generated by the late version implementation. This difference can cause compatibility issues when the application tries to use the URI to perform further actions. Additionally, the late version implementation throws an IllegalArgumentException if the Intent does not have an explicit package name, which is not the case in the early version. This can also cause compatibility issues if the application does not handle this exception."
178,"<android.hardware.Sensor: int getMaxLengthValuesArray(Sensor,int)>",18,19,"<android.hardware.Sensor: int getMaxLengthValuesArray(Sensor,int)>","<android.hardware.Sensor: int getMaxLengthValuesArray(Sensor,int)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(// mType starts from offset 1., []), AssignmentExpression(=, [VariableReference(int len, []), Expression(sMaxLengthValuesArray[sensor.mType - 1], [])]), Statement(// Set it to 3 for backward compatibility., []), AssignmentExpression(=, [VariableReference(if (sensor.getType(), []), Expression(, [])]), AssignmentExpression(=, [VariableReference(len, []), Expression(3, [])]), Statement(}, []), Statement(return len, []), Statement(}, [])])  Statement({, [])  Statement(// mType starts from offset 1., [])  AssignmentExpression(=, [VariableReference(int len, []), Expression(sMaxLengthValuesArray[sensor.mType - 1], [])])    VariableReference(int len, [])    Expression(sMaxLengthValuesArray[sensor.mType - 1], [])  Statement(// Set it to 3 for backward compatibility., [])  AssignmentExpression(=, [VariableReference(if (sensor.getType(), []), Expression(, [])])    VariableReference(if (sensor.getType(), [])    Expression(, [])  AssignmentExpression(=, [VariableReference(len, []), Expression(3, [])])    VariableReference(len, [])    Expression(3, [])  Statement(}, [])  Statement(return len, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(int type, []), Expression(sensor.mType, [])]), Statement(// Set it to 3 for backward compatibility., []), AssignmentExpression(=, [VariableReference(if (type, []), Expression(, [])]), Statement(return 3, []), Statement(}, []), AssignmentExpression(=, [VariableReference(int offset, []), Expression(type * 2 + 1, [])]), AssignmentExpression(=, [VariableReference(if (offset >, []), Expression(sSensorReportingModes.length) {, [])]), Statement(// sensor, []), Statement(return 16, []), Statement(}, []), Statement(return sSensorReportingModes[offset], []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(int type, []), Expression(sensor.mType, [])])    VariableReference(int type, [])    Expression(sensor.mType, [])  Statement(// Set it to 3 for backward compatibility., [])  AssignmentExpression(=, [VariableReference(if (type, []), Expression(, [])])    VariableReference(if (type, [])    Expression(, [])  Statement(return 3, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(int offset, []), Expression(type * 2 + 1, [])])    VariableReference(int offset, [])    Expression(type * 2 + 1, [])  AssignmentExpression(=, [VariableReference(if (offset >, []), Expression(sSensorReportingModes.length) {, [])])    VariableReference(if (offset >, [])    Expression(sSensorReportingModes.length) {, [])  Statement(// sensor, [])  Statement(return 16, [])  Statement(}, [])  Statement(return sSensorReportingModes[offset], [])  Statement(}, [])",1,,,-1,,,-1,-1,-1,-1,-1,"1,3,4",1,"1,3,4",1,"The code change involves the removal of some statements, the introduction of new statements, and the modification of the control dependency. The removed statements are related to the calculation of the ""len"" variable, and the new statements are related to the calculation of the ""type"" and ""offset"" variables. The control dependency has also been changed, as the new code uses the ""type"" and ""offset"" variables to determine the return value, while the old code uses the ""len"" variable.","The Compatibility Issue arises due to the potential for the API to return different values in the two versions. The new code uses the ""type"" and ""offset"" variables to determine the return value, while the old code uses the ""len"" variable. Therefore, if the values of the ""type"", ""offset"", and ""len"" variables are different in the two versions, the API will return different values, which can lead to compatibility issues in the applications that use this API."
666,<android.view.ScaleGestureDetector: float getCurrentSpanX()>,16,17,<android.view.ScaleGestureDetector: float getCurrentSpanX()>,<android.view.ScaleGestureDetector: float getCurrentSpanX()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(return mCurrFingerDiffX, []), Statement(}, [])])  Statement({, [])  Statement(return mCurrFingerDiffX, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return mCurrSpanX, []), Statement(}, [])])  Statement({, [])  Statement(return mCurrSpanX, [])  Statement(}, [])",1,"/**
 * Return the current x distance between the two pointers forming the
 * gesture in progress.
 *
 * @return Distance between pointers in pixels.
 */
","/**
 * Return the average X distance between each of the pointers forming the
 * gesture in progress through the focal point.
 *
 * @return Distance between pointers in pixels.
 */
",-1,,,-1,-1,-1,-1,-1,"1,4",1,1,1,"The code change between the two versions involves a modification in the return statement. Specifically, the variable being returned in the early version (`mCurrFingerDiffX`) is different from the one in the late version (`mCurrSpanX`). This change could potentially lead to different return values, as the calculations for these two variables might differ.","The Compatibility Issue (CI) arises due to the potential for different return values in the two versions of the API. If the calculations for `mCurrFingerDiffX` and `mCurrSpanX` are not the same, then clients using the early version of the API might receive different results than those using the late version. This could potentially break the functionality of the clients, or lead to unexpected behavior. Therefore, this situation is classified as a CI caused by potential different return values or types (1)."
1077,<android.hardware.camera2.legacy.LegacyCameraDevice: int detectSurfaceType(Surface)>,25,26,<android.hardware.camera2.legacy.LegacyCameraDevice: int detectSurfaceType(Surface)>,<android.hardware.camera2.legacy.LegacyCameraDevice: int detectSurfaceType(Surface)>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(checkNotNull(surface), []), MethodCall(return LegacyExceptionUtils.throwOnError(nativeDetectSurfaceType(surface)), [VariableReference(return LegacyExceptionUtils, []), Expression(nativeDetectSurfaceType(surface), [])]), Statement(}, [])])  Statement({, [])  Statement(checkNotNull(surface), [])  MethodCall(return LegacyExceptionUtils.throwOnError(nativeDetectSurfaceType(surface)), [VariableReference(return LegacyExceptionUtils, []), Expression(nativeDetectSurfaceType(surface), [])])    VariableReference(return LegacyExceptionUtils, [])    Expression(nativeDetectSurfaceType(surface), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(checkNotNull(surface), []), AssignmentExpression(=, [VariableReference(int surfaceType, []), Expression(nativeDetectSurfaceType(surface), [])]), Statement(// ImageFormat.PRIVATE. b/9487482, []), AssignmentExpression(=, [VariableReference(if ((surfaceType >, []), Expression(LegacyMetadataMapper.HAL_PIXEL_FORMAT_RGBA_8888 && surfaceType <, [])]), AssignmentExpression(=, [VariableReference(surfaceType, []), Expression(ImageFormat.PRIVATE, [])]), Statement(}, []), MethodCall(return LegacyExceptionUtils.throwOnError(surfaceType), [VariableReference(return LegacyExceptionUtils, []), Expression(surfaceType, [])]), Statement(}, [])])  Statement({, [])  Statement(checkNotNull(surface), [])  AssignmentExpression(=, [VariableReference(int surfaceType, []), Expression(nativeDetectSurfaceType(surface), [])])    VariableReference(int surfaceType, [])    Expression(nativeDetectSurfaceType(surface), [])  Statement(// ImageFormat.PRIVATE. b/9487482, [])  AssignmentExpression(=, [VariableReference(if ((surfaceType >, []), Expression(LegacyMetadataMapper.HAL_PIXEL_FORMAT_RGBA_8888 && surfaceType <, [])])    VariableReference(if ((surfaceType >, [])    Expression(LegacyMetadataMapper.HAL_PIXEL_FORMAT_RGBA_8888 && surfaceType <, [])  AssignmentExpression(=, [VariableReference(surfaceType, []), Expression(ImageFormat.PRIVATE, [])])    VariableReference(surfaceType, [])    Expression(ImageFormat.PRIVATE, [])  Statement(}, [])  MethodCall(return LegacyExceptionUtils.throwOnError(surfaceType), [VariableReference(return LegacyExceptionUtils, []), Expression(surfaceType, [])])    VariableReference(return LegacyExceptionUtils, [])    Expression(surfaceType, [])  Statement(}, [])",1,"/**
 * Query the surface for its currently configured format
 */
","/**
 * Query the surface for its currently configured format
 */
",-1,,,-1,-1,-1,-1,-1,"1,3,4",1,"1,5","1,2","In the early version, the method directly returns the result of `LegacyExceptionUtils.throwOnError(nativeDetectSurfaceType(surface))`. In the late version, the method first assigns the result of `nativeDetectSurfaceType(surface)` to a local variable `surfaceType`. Then, if `surfaceType` is greater than `LegacyMetadataMapper.HAL_PIXEL_FORMAT_YCbCr_420_888` and less than `LegacyMetadataMapper.HAL_PIXEL_FORMAT_PRIVATE_END`, it will assign `LegacyMetadataMapper.HAL_PIXEL_FORMAT_RGBA_8888` to `surfaceType`. Otherwise, it will assign `ImageFormat.PRIVATE` to `surfaceType`. Finally, the method returns the result of `LegacyExceptionUtils.throwOnError(surfaceType)`. Therefore, the code change includes the introduction of a local variable, the addition of conditional statements, and the modification of the return statement.","In the early version, the method directly returns the result of `nativeDetectSurfaceType(surface)`. If the surface is of a format that is greater than `LegacyMetadataMapper.HAL_PIXEL_FORMAT_YCbCr_420_888` and less than `LegacyMetadataMapper.HAL_PIXEL_FORMAT_PRIVATE_END`, the method will return the format as it is. However, in the late version, the method will return `LegacyMetadataMapper.HAL_PIXEL_FORMAT_RGBA_8888` for surfaces of such formats. Therefore, the code change may cause the method to return a different value for surfaces of certain formats, which may lead to compatibility issues. Moreover, it is unclear from the provided code whether the method `LegacyExceptionUtils.throwOnError` may throw an exception or not. If it does, the modification of the argument to this method may also lead to a different exception being thrown, which is another potential compatibility issue."
668,"<android.app.PendingIntent: PendingIntent getService(Context,int,Intent,int)>",16,17,"<android.app.PendingIntent: PendingIntent getService(Context,int,Intent,int)>","<android.app.PendingIntent: PendingIntent getService(Context,int,Intent,int)>",0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(String packageName, []), Expression(context.getPackageName(), [])]), AssignmentExpression(=, [VariableReference(String resolvedType, []), Expression(intent !, [])]), Statement(try {, []), MethodCall(intent.setAllowFds(false), [VariableReference(intent, []), Expression(false, [])]), AssignmentExpression(=, [VariableReference(IIntentSender target, []), Expression(ActivityManagerNative.getDefault().getIntentSender(ActivityManager.INTENT_SENDER_SERVICE, packageName, null, null, requestCode, new Intent[] { intent }, resolvedType !, [])]), AssignmentExpression(=, [VariableReference(return target !, []), Expression(null ? new PendingIntent(target) : null, [])]), Statement(} catch (RemoteException e) {, []), Statement(}, []), Statement(return null, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(String packageName, []), Expression(context.getPackageName(), [])])    VariableReference(String packageName, [])    Expression(context.getPackageName(), [])  AssignmentExpression(=, [VariableReference(String resolvedType, []), Expression(intent !, [])])    VariableReference(String resolvedType, [])    Expression(intent !, [])  Statement(try {, [])  MethodCall(intent.setAllowFds(false), [VariableReference(intent, []), Expression(false, [])])    VariableReference(intent, [])    Expression(false, [])  AssignmentExpression(=, [VariableReference(IIntentSender target, []), Expression(ActivityManagerNative.getDefault().getIntentSender(ActivityManager.INTENT_SENDER_SERVICE, packageName, null, null, requestCode, new Intent[] { intent }, resolvedType !, [])])    VariableReference(IIntentSender target, [])    Expression(ActivityManagerNative.getDefault().getIntentSender(ActivityManager.INTENT_SENDER_SERVICE, packageName, null, null, requestCode, new Intent[] { intent }, resolvedType !, [])  AssignmentExpression(=, [VariableReference(return target !, []), Expression(null ? new PendingIntent(target) : null, [])])    VariableReference(return target !, [])    Expression(null ? new PendingIntent(target) : null, [])  Statement(} catch (RemoteException e) {, [])  Statement(}, [])  Statement(return null, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(String packageName, []), Expression(context.getPackageName(), [])]), AssignmentExpression(=, [VariableReference(String resolvedType, []), Expression(intent !, [])]), Statement(try {, []), MethodCall(intent.setAllowFds(false), [VariableReference(intent, []), Expression(false, [])]), AssignmentExpression(=, [VariableReference(IIntentSender target, []), Expression(ActivityManagerNative.getDefault().getIntentSender(ActivityManager.INTENT_SENDER_SERVICE, packageName, null, null, requestCode, new Intent[] { intent }, resolvedType !, [])]), AssignmentExpression(=, [VariableReference(return target !, []), Expression(null ? new PendingIntent(target) : null, [])]), Statement(} catch (RemoteException e) {, []), Statement(}, []), Statement(return null, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(String packageName, []), Expression(context.getPackageName(), [])])    VariableReference(String packageName, [])    Expression(context.getPackageName(), [])  AssignmentExpression(=, [VariableReference(String resolvedType, []), Expression(intent !, [])])    VariableReference(String resolvedType, [])    Expression(intent !, [])  Statement(try {, [])  MethodCall(intent.setAllowFds(false), [VariableReference(intent, []), Expression(false, [])])    VariableReference(intent, [])    Expression(false, [])  AssignmentExpression(=, [VariableReference(IIntentSender target, []), Expression(ActivityManagerNative.getDefault().getIntentSender(ActivityManager.INTENT_SENDER_SERVICE, packageName, null, null, requestCode, new Intent[] { intent }, resolvedType !, [])])    VariableReference(IIntentSender target, [])    Expression(ActivityManagerNative.getDefault().getIntentSender(ActivityManager.INTENT_SENDER_SERVICE, packageName, null, null, requestCode, new Intent[] { intent }, resolvedType !, [])  AssignmentExpression(=, [VariableReference(return target !, []), Expression(null ? new PendingIntent(target) : null, [])])    VariableReference(return target !, [])    Expression(null ? new PendingIntent(target) : null, [])  Statement(} catch (RemoteException e) {, [])  Statement(}, [])  Statement(return null, [])  Statement(}, [])",1,"/**
 * Retrieve a PendingIntent that will start a service, like calling
 * {@link Context#startService Context.startService()}.  The start
 * arguments given to the service will come from the extras of the Intent.
 *
 * @param context The Context in which this PendingIntent should start
 * the service.
 * @param requestCode Private request code for the sender (currently
 * not used).
 * @param intent An Intent describing the service to be started.
 * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},
 * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},
 * or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been
 * supplied.
 */
","/**
 * Retrieve a PendingIntent that will start a service, like calling
 * {@link Context#startService Context.startService()}.  The start
 * arguments given to the service will come from the extras of the Intent.
 *
 * @param context The Context in which this PendingIntent should start
 * the service.
 * @param requestCode Private request code for the sender (currently
 * not used).
 * @param intent An Intent describing the service to be started.
 * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},
 * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},
 * or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been
 * supplied.
 */
",-1,,,-1,-1,-1,-1,-1,"4,5",1,0,0,N/A,N/A
67,<android.os.VibrationAttributes: int hashCode()>,30,31,<android.os.VibrationAttributes: int hashCode()>,<android.os.VibrationAttributes: int hashCode()>,0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(return Objects.hash(mUsage, mFlags), [VariableReference(return Objects, []), Expression(mUsage, []), Expression(mFlags, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return Objects.hash(mUsage, mFlags), [VariableReference(return Objects, []), Expression(mUsage, []), Expression(mFlags, [])])    VariableReference(return Objects, [])    Expression(mUsage, [])    Expression(mFlags, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(return Objects.hash(mUsage, mOriginalAudioUsage, mFlags), [VariableReference(return Objects, []), Expression(mUsage, []), Expression(mOriginalAudioUsage, []), Expression(mFlags, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return Objects.hash(mUsage, mOriginalAudioUsage, mFlags), [VariableReference(return Objects, []), Expression(mUsage, []), Expression(mOriginalAudioUsage, []), Expression(mFlags, [])])    VariableReference(return Objects, [])    Expression(mUsage, [])    Expression(mOriginalAudioUsage, [])    Expression(mFlags, [])  Statement(}, [])",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,"1,4,5",1,1,1,"The return statement of the method has been changed between the two versions. In the early version, the method returns the hash code of two fields: mUsage and mFlags. However, in the late version, the method returns the hash code of three fields: mUsage, mOriginalAudioUsage, and mFlags. Therefore, the method may return different values between the two versions, which leads to a compatibility issue.","The compatibility issue is caused by the potential different return values of the method. Since the method is used to generate the hash code of an object, any change to the fields involved in the hash code calculation may lead to a different hash code. In this case, the introduction of a new field mOriginalAudioUsage in the late version may cause the method to generate a different hash code for the same object in the early version, which violates the compatibility principle."
192,<android.widget.TextView: int getCompoundPaddingRight()>,22,23,<android.widget.TextView: int getCompoundPaddingRight()>,<android.widget.TextView: int getCompoundPaddingRight()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final Drawables dr, []), Expression(mDrawables, [])]), AssignmentExpression(=, [VariableReference(if (dr, []), Expression(, [])]), Statement(return mPaddingRight, []), Statement(} else {, []), Statement(return mPaddingRight + dr.mDrawablePadding + dr.mDrawableSizeRight, []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final Drawables dr, []), Expression(mDrawables, [])])    VariableReference(final Drawables dr, [])    Expression(mDrawables, [])  AssignmentExpression(=, [VariableReference(if (dr, []), Expression(, [])])    VariableReference(if (dr, [])    Expression(, [])  Statement(return mPaddingRight, [])  Statement(} else {, [])  Statement(return mPaddingRight + dr.mDrawablePadding + dr.mDrawableSizeRight, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final Drawables dr, []), Expression(mDrawables, [])]), AssignmentExpression(=, [VariableReference(if (dr, []), Expression(, [])]), Statement(return mPaddingRight, []), Statement(} else {, []), Statement(return mPaddingRight + dr.mDrawablePadding + dr.mDrawableSizeRight, []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final Drawables dr, []), Expression(mDrawables, [])])    VariableReference(final Drawables dr, [])    Expression(mDrawables, [])  AssignmentExpression(=, [VariableReference(if (dr, []), Expression(, [])])    VariableReference(if (dr, [])    Expression(, [])  Statement(return mPaddingRight, [])  Statement(} else {, [])  Statement(return mPaddingRight + dr.mDrawablePadding + dr.mDrawableSizeRight, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Returns the right padding of the view, plus space for the right
 * Drawable if any.
 */
","/**
 * Returns the right padding of the view, plus space for the right
 * Drawable if any.
 */
",-1,,,-1,-1,-1,-1,-1,4,0,0,0,There is no difference between the early and late implementations of the getCompoundPaddingRight() method in the android.widget.TextView class.,There is no Compatibility Issue exist for the API.
980,<android.os.PowerManager: boolean isPowerSaveMode()>,23,24,<android.os.PowerManager: boolean isPowerSaveMode()>,<android.os.PowerManager: boolean isPowerSaveMode()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(return mService.isPowerSaveMode(), [VariableReference(return mService, []), Expression(, [])]), Statement(} catch (RemoteException e) {, []), Statement(return false, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(return mService.isPowerSaveMode(), [VariableReference(return mService, []), Expression(, [])])    VariableReference(return mService, [])    Expression(, [])  Statement(} catch (RemoteException e) {, [])  Statement(return false, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(return mService.isPowerSaveMode(), [VariableReference(return mService, []), Expression(, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(return mService.isPowerSaveMode(), [VariableReference(return mService, []), Expression(, [])])    VariableReference(return mService, [])    Expression(, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Returns true if the device is currently in power save mode.  When in this mode,
 * applications should reduce their functionality in order to conserve battery as
 * much as possible.  You can monitor for changes to this state with
 * {@link #ACTION_POWER_SAVE_MODE_CHANGED}.
 *
 * @return Returns true if currently in low power mode, else false.
 */
","/**
 * Returns true if the device is currently in power save mode.  When in this mode,
 * applications should reduce their functionality in order to conserve battery as
 * much as possible.  You can monitor for changes to this state with
 * {@link #ACTION_POWER_SAVE_MODE_CHANGED}.
 *
 * @return Returns true if currently in low power mode, else false.
 */
",-1,,,-1,-1,-1,-1,-1,2,2,2,2,A new exception handling statement `throw e.rethrowFromSystemServer()` is added in the late version of the implementation.,"The new exception handling statement `throw e.rethrowFromSystemServer()` may cause the API to throw a different exception in the late version, leading to a compatibility issue."
269,"<android.hardware.usb.UsbDeviceConnection: int controlTransfer(int,int,int,int,byte[],int,int)>",17,18,"<android.hardware.usb.UsbDeviceConnection: int controlTransfer(int,int,int,int,byte[],int,int)>","<android.hardware.usb.UsbDeviceConnection: int controlTransfer(int,int,int,int,byte[],int,int)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(return native_control_request(requestType, request, value, index, buffer, length, timeout), []), Statement(}, [])])  Statement({, [])  Statement(return native_control_request(requestType, request, value, index, buffer, length, timeout), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return controlTransfer(requestType, request, value, index, buffer, 0, length, timeout), []), Statement(}, [])])  Statement({, [])  Statement(return controlTransfer(requestType, request, value, index, buffer, 0, length, timeout), [])  Statement(}, [])",1,"/**
 * Performs a control transaction on endpoint zero for this device.
 * The direction of the transfer is determined by the request type.
 * If requestType & {@link UsbConstants#USB_ENDPOINT_DIR_MASK} is
 * {@link UsbConstants#USB_DIR_OUT}, then the transfer is a write,
 * and if it is {@link UsbConstants#USB_DIR_IN}, then the transfer
 * is a read.
 *
 * @param requestType request type for this transaction
 * @param request request ID for this transaction
 * @param value value field for this transaction
 * @param index index field for this transaction
 * @param buffer buffer for data portion of transaction,
 * or null if no data needs to be sent or received
 * @param length the length of the data to send or receive
 * @param timeout in milliseconds
 * @return length of data transferred (or zero) for success,
 * or negative value for failure
 */
","/**
 * Performs a control transaction on endpoint zero for this device.
 * The direction of the transfer is determined by the request type.
 * If requestType & {@link UsbConstants#USB_ENDPOINT_DIR_MASK} is
 * {@link UsbConstants#USB_DIR_OUT}, then the transfer is a write,
 * and if it is {@link UsbConstants#USB_DIR_IN}, then the transfer
 * is a read.
 * <p>
 * This method transfers data starting from index 0 in the buffer.
 * To specify a different offset, use
 * {@link #controlTransfer(int, int, int, int, byte[], int, int, int)}.
 * </p>
 *
 * @param requestType request type for this transaction
 * @param request request ID for this transaction
 * @param value value field for this transaction
 * @param index index field for this transaction
 * @param buffer buffer for data portion of transaction,
 * or null if no data needs to be sent or received
 * @param length the length of the data to send or receive
 * @param timeout in milliseconds
 * @return length of data transferred (or zero) for success,
 * or negative value for failure
 */
",-1,,,-1,-1,-1,-1,-1,"1,4",1,5,1,"The API has undergone a dependent API change, where the return statement was changed from `native_control_request(requestType, request, value, index, buffer, length, timeout)` to `controlTransfer(requestType, request, value, index, buffer, 0, length, timeout)`. This indicates that the current API implementation now relies on the `controlTransfer` API, which has a different method signature with an additional `offset` parameter.","The dependent API change in the current API implementation could potentially lead to a Compatibility Issue, as the new method being called has a different method signature. This may result in the API returning a different variable (value or type) if the added `offset` parameter in the dependent API affects the data being transferred. Additionally, if the client code has not been updated to include the added `offset` parameter when calling the dependent API, it may result in runtime errors."
213,"<android.content.ContentResolver: void takePersistableUriPermission(Uri,int)>",27,28,"<android.content.ContentResolver: void takePersistableUriPermission(Uri,int)>","<android.content.ContentResolver: void takePersistableUriPermission(Uri,int)>",0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(Preconditions.checkNotNull(uri, ""uri""), [VariableReference(Preconditions, []), Expression(uri, []), Expression(""uri"", [])]), Statement(try {, []), MethodCall(ActivityManager.getService().takePersistableUriPermission(ContentProvider.getUriWithoutUserId(uri), modeFlags, resolveUserId(uri)), [VariableReference(ActivityManager, []), Expression().takePersistableUriPermission(ContentProvider.getUriWithoutUserId(uri), []), Expression(modeFlags, []), Expression(resolveUserId(uri), [])]), Statement(} catch (RemoteException e) {, []), Statement(}, []), Statement(}, [])])  Statement({, [])  MethodCall(Preconditions.checkNotNull(uri, ""uri""), [VariableReference(Preconditions, []), Expression(uri, []), Expression(""uri"", [])])    VariableReference(Preconditions, [])    Expression(uri, [])    Expression(""uri"", [])  Statement(try {, [])  MethodCall(ActivityManager.getService().takePersistableUriPermission(ContentProvider.getUriWithoutUserId(uri), modeFlags, resolveUserId(uri)), [VariableReference(ActivityManager, []), Expression().takePersistableUriPermission(ContentProvider.getUriWithoutUserId(uri), []), Expression(modeFlags, []), Expression(resolveUserId(uri), [])])    VariableReference(ActivityManager, [])    Expression().takePersistableUriPermission(ContentProvider.getUriWithoutUserId(uri), [])    Expression(modeFlags, [])    Expression(resolveUserId(uri), [])  Statement(} catch (RemoteException e) {, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(Preconditions.checkNotNull(uri, ""uri""), [VariableReference(Preconditions, []), Expression(uri, []), Expression(""uri"", [])]), Statement(try {, []), AssignmentExpression(=, [VariableReference(ActivityManager.getService().takePersistableUriPermission(ContentProvider.getUriWithoutUserId(uri), modeFlags, /* toPackage, []), Expression(*/, [])]), Statement(null, resolveUserId(uri)), []), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  MethodCall(Preconditions.checkNotNull(uri, ""uri""), [VariableReference(Preconditions, []), Expression(uri, []), Expression(""uri"", [])])    VariableReference(Preconditions, [])    Expression(uri, [])    Expression(""uri"", [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(ActivityManager.getService().takePersistableUriPermission(ContentProvider.getUriWithoutUserId(uri), modeFlags, /* toPackage, []), Expression(*/, [])])    VariableReference(ActivityManager.getService().takePersistableUriPermission(ContentProvider.getUriWithoutUserId(uri), modeFlags, /* toPackage, [])    Expression(*/, [])  Statement(null, resolveUserId(uri)), [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Take a persistable URI permission grant that has been offered. Once
 * taken, the permission grant will be remembered across device reboots.
 * Only URI permissions granted with
 * {@link Intent#FLAG_GRANT_PERSISTABLE_URI_PERMISSION} can be persisted. If
 * the grant has already been persisted, taking it again will touch
 * {@link UriPermission#getPersistedTime()}.
 *
 * @see #getPersistedUriPermissions()
 */
","/**
 * Take a persistable URI permission grant that has been offered. Once
 * taken, the permission grant will be remembered across device reboots.
 * Only URI permissions granted with
 * {@link Intent#FLAG_GRANT_PERSISTABLE_URI_PERMISSION} can be persisted. If
 * the grant has already been persisted, taking it again will touch
 * {@link UriPermission#getPersistedTime()}.
 *
 * @see #getPersistedUriPermissions()
 */
",-1,,,-1,-1,-1,-1,-1,"2,4,5",2,"2,5","1,2","The implementation of the method has changed from directly calling the ""takePersistableUriPermission"" method to first assigning the result of the method call to a variable and then passing the variable to the ""null"" method. Additionally, the exception handling has been modified, with the ""rethrowFromSystemServer"" method being called on the caught exception before it is re-thrown.","The changes to the implementation of the method and the exception handling could potentially lead to different behaviors in the two versions. The modification of the method call could result in different return values or types if the ""null"" method has an impact on the result. The alteration of the exception handling could also cause the API to throw different exceptions in the two versions, as the ""rethrowFromSystemServer"" method might modify the caught exception before it is re-thrown."
218,<android.widget.Switch: Mode getThumbTintMode()>,28,29,<android.widget.Switch: Mode getThumbTintMode()>,<android.widget.Switch: Mode getThumbTintMode()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(return mThumbTintMode, []), Statement(}, [])])  Statement({, [])  Statement(return mThumbTintMode, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(BlendMode mode, []), Expression(getThumbTintBlendMode(), [])]), AssignmentExpression(=, [VariableReference(return mode !, []), Expression(null ? BlendMode.blendModeToPorterDuffMode(mode) : null, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(BlendMode mode, []), Expression(getThumbTintBlendMode(), [])])    VariableReference(BlendMode mode, [])    Expression(getThumbTintBlendMode(), [])  AssignmentExpression(=, [VariableReference(return mode !, []), Expression(null ? BlendMode.blendModeToPorterDuffMode(mode) : null, [])])    VariableReference(return mode !, [])    Expression(null ? BlendMode.blendModeToPorterDuffMode(mode) : null, [])  Statement(}, [])",1,"/**
 * @return the blending mode used to apply the tint to the thumb
 * drawable
 * @attr ref android.R.styleable#Switch_thumbTintMode
 * @see #setThumbTintMode(PorterDuff.Mode)
 */
","/**
 * @return the blending mode used to apply the tint to the thumb
 * drawable
 * @attr ref android.R.styleable#Switch_thumbTintMode
 * @see #setThumbTintMode(PorterDuff.Mode)
 */
",-1,[@Nullable],"[@InspectableProperty, @Nullable]",-1,-1,-1,-1,-1,"1,4",1,"1,5",1,"In the late version implementation, a new variable ""BlendMode mode"" is introduced, and its value is assigned by calling the method ""getThumbTintBlendMode()"". Then, the return value is determined by a ternary operator, which checks whether ""mode"" is null. If it is null, the method returns null. Otherwise, it returns the result of calling ""BlendMode.blendModeToPorterDuffMode(mode)"". In the early version, the method directly returns the value of ""mThumbTintMode"". Therefore, the code change type is 1 (Return statement changed) and 5 (Dependent API changed).","The Compatibility Issue arises because the late version implementation may potentially return a different value than the early version. In the early version, the method always returns the value of ""mThumbTintMode"". However, in the late version, the return value is determined by the value of ""mode"", which is assigned by calling ""getThumbTintBlendMode()"". If ""getThumbTintBlendMode()"" returns a different value in the late version, or if the implementation of ""BlendMode.blendModeToPorterDuffMode(mode)"" changes, the method may return a different value, which may cause unexpected behavior in the app. Therefore, the CI type is 1 (Compatibility Issue caused by potential different return values or types)."
533,"<android.speech.tts.PlaybackSynthesisCallback: int start(int,int,int)>",23,24,"<android.speech.tts.PlaybackSynthesisCallback: int start(int,int,int)>","<android.speech.tts.PlaybackSynthesisCallback: int start(int,int,int)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(if (DBG), []), MethodCall(Log.d(TAG, ""start("" + sampleRateInHz + "", "" + audioFormat + "", "" + channelCount + "")""), [VariableReference(Log, []), Expression(TAG, []), Expression(""start("" + sampleRateInHz + "", []), Expression("" + audioFormat + "", []), Expression("" + channelCount + "")"", [])]), AssignmentExpression(=, [VariableReference(int channelConfig, []), Expression(BlockingAudioTrack.getChannelConfig(channelCount), [])]), Statement(synchronized (mStateLock) {, []), AssignmentExpression(=, [VariableReference(if (channelConfig, []), Expression(, [])]), MethodCall(Log.e(TAG, ""Unsupported number of channels :"" + channelCount), [VariableReference(Log, []), Expression(TAG, []), Expression(""Unsupported number of channels :"" + channelCount, [])]), AssignmentExpression(=, [VariableReference(mStatusCode, []), Expression(TextToSpeech.ERROR_OUTPUT, [])]), Statement(return TextToSpeech.ERROR, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mStatusCode, []), Expression(, [])]), Statement(if (DBG), []), MethodCall(Log.d(TAG, ""stop() called before start(), returning.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""stop() called before start(), []), Expression(returning."", [])]), Statement(return errorCodeOnStop(), []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mStatusCode !, []), Expression(TextToSpeech.SUCCESS) {, [])]), Statement(if (DBG), []), MethodCall(Log.d(TAG, ""Error was raised""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Error was raised"", [])]), Statement(return TextToSpeech.ERROR, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mItem !, []), Expression(null) {, [])]), MethodCall(Log.e(TAG, ""Start called twice""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Start called twice"", [])]), Statement(return TextToSpeech.ERROR, []), Statement(}, []), AssignmentExpression(=, [VariableReference(SynthesisPlaybackQueueItem item, []), Expression(new SynthesisPlaybackQueueItem(mAudioParams, sampleRateInHz, audioFormat, channelCount, mDispatcher, mCallerIdentity, mLogger), [])]), MethodCall(mAudioTrackHandler.enqueue(item), [VariableReference(mAudioTrackHandler, []), Expression(item, [])]), AssignmentExpression(=, [VariableReference(mItem, []), Expression(item, [])]), Statement(}, []), Statement(return TextToSpeech.SUCCESS, []), Statement(}, [])])  Statement({, [])  Statement(if (DBG), [])  MethodCall(Log.d(TAG, ""start("" + sampleRateInHz + "", "" + audioFormat + "", "" + channelCount + "")""), [VariableReference(Log, []), Expression(TAG, []), Expression(""start("" + sampleRateInHz + "", []), Expression("" + audioFormat + "", []), Expression("" + channelCount + "")"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""start("" + sampleRateInHz + "", [])    Expression("" + audioFormat + "", [])    Expression("" + channelCount + "")"", [])  AssignmentExpression(=, [VariableReference(int channelConfig, []), Expression(BlockingAudioTrack.getChannelConfig(channelCount), [])])    VariableReference(int channelConfig, [])    Expression(BlockingAudioTrack.getChannelConfig(channelCount), [])  Statement(synchronized (mStateLock) {, [])  AssignmentExpression(=, [VariableReference(if (channelConfig, []), Expression(, [])])    VariableReference(if (channelConfig, [])    Expression(, [])  MethodCall(Log.e(TAG, ""Unsupported number of channels :"" + channelCount), [VariableReference(Log, []), Expression(TAG, []), Expression(""Unsupported number of channels :"" + channelCount, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Unsupported number of channels :"" + channelCount, [])  AssignmentExpression(=, [VariableReference(mStatusCode, []), Expression(TextToSpeech.ERROR_OUTPUT, [])])    VariableReference(mStatusCode, [])    Expression(TextToSpeech.ERROR_OUTPUT, [])  Statement(return TextToSpeech.ERROR, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mStatusCode, []), Expression(, [])])    VariableReference(if (mStatusCode, [])    Expression(, [])  Statement(if (DBG), [])  MethodCall(Log.d(TAG, ""stop() called before start(), returning.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""stop() called before start(), []), Expression(returning."", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""stop() called before start(), [])    Expression(returning."", [])  Statement(return errorCodeOnStop(), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mStatusCode !, []), Expression(TextToSpeech.SUCCESS) {, [])])    VariableReference(if (mStatusCode !, [])    Expression(TextToSpeech.SUCCESS) {, [])  Statement(if (DBG), [])  MethodCall(Log.d(TAG, ""Error was raised""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Error was raised"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Error was raised"", [])  Statement(return TextToSpeech.ERROR, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mItem !, []), Expression(null) {, [])])    VariableReference(if (mItem !, [])    Expression(null) {, [])  MethodCall(Log.e(TAG, ""Start called twice""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Start called twice"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Start called twice"", [])  Statement(return TextToSpeech.ERROR, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(SynthesisPlaybackQueueItem item, []), Expression(new SynthesisPlaybackQueueItem(mAudioParams, sampleRateInHz, audioFormat, channelCount, mDispatcher, mCallerIdentity, mLogger), [])])    VariableReference(SynthesisPlaybackQueueItem item, [])    Expression(new SynthesisPlaybackQueueItem(mAudioParams, sampleRateInHz, audioFormat, channelCount, mDispatcher, mCallerIdentity, mLogger), [])  MethodCall(mAudioTrackHandler.enqueue(item), [VariableReference(mAudioTrackHandler, []), Expression(item, [])])    VariableReference(mAudioTrackHandler, [])    Expression(item, [])  AssignmentExpression(=, [VariableReference(mItem, []), Expression(item, [])])    VariableReference(mItem, [])    Expression(item, [])  Statement(}, [])  Statement(return TextToSpeech.SUCCESS, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (DBG), []), MethodCall(Log.d(TAG, ""start("" + sampleRateInHz + "", "" + audioFormat + "", "" + channelCount + "")""), [VariableReference(Log, []), Expression(TAG, []), Expression(""start("" + sampleRateInHz + "", []), Expression("" + audioFormat + "", []), Expression("" + channelCount + "")"", [])]), AssignmentExpression(=, [VariableReference(if (audioFormat !, []), Expression(AudioFormat.ENCODING_PCM_8BIT && audioFormat !, [])]), MethodCall(Log.w(TAG, ""Audio format encoding "" + audioFormat + "" not supported. Please use one "" + ""of AudioFormat.ENCODING_PCM_8BIT, AudioFormat.ENCODING_PCM_16BIT or "" + ""AudioFormat.ENCODING_PCM_FLOAT""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Audio format encoding "" + audioFormat + "" not supported. Please use one "" + ""of AudioFormat.ENCODING_PCM_8BIT, []), Expression(AudioFormat.ENCODING_PCM_16BIT or "" + ""AudioFormat.ENCODING_PCM_FLOAT"", [])]), Statement(}, []), MethodCall(mDispatcher.dispatchOnBeginSynthesis(sampleRateInHz, audioFormat, channelCount), [VariableReference(mDispatcher, []), Expression(sampleRateInHz, []), Expression(audioFormat, []), Expression(channelCount, [])]), AssignmentExpression(=, [VariableReference(int channelConfig, []), Expression(BlockingAudioTrack.getChannelConfig(channelCount), [])]), Statement(synchronized (mStateLock) {, []), AssignmentExpression(=, [VariableReference(if (channelConfig, []), Expression(, [])]), MethodCall(Log.e(TAG, ""Unsupported number of channels :"" + channelCount), [VariableReference(Log, []), Expression(TAG, []), Expression(""Unsupported number of channels :"" + channelCount, [])]), AssignmentExpression(=, [VariableReference(mStatusCode, []), Expression(TextToSpeech.ERROR_OUTPUT, [])]), Statement(return TextToSpeech.ERROR, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mStatusCode, []), Expression(, [])]), Statement(if (DBG), []), MethodCall(Log.d(TAG, ""stop() called before start(), returning.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""stop() called before start(), []), Expression(returning."", [])]), Statement(return errorCodeOnStop(), []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mStatusCode !, []), Expression(TextToSpeech.SUCCESS) {, [])]), Statement(if (DBG), []), MethodCall(Log.d(TAG, ""Error was raised""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Error was raised"", [])]), Statement(return TextToSpeech.ERROR, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mItem !, []), Expression(null) {, [])]), MethodCall(Log.e(TAG, ""Start called twice""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Start called twice"", [])]), Statement(return TextToSpeech.ERROR, []), Statement(}, []), AssignmentExpression(=, [VariableReference(SynthesisPlaybackQueueItem item, []), Expression(new SynthesisPlaybackQueueItem(mAudioParams, sampleRateInHz, audioFormat, channelCount, mDispatcher, mCallerIdentity, mLogger), [])]), MethodCall(mAudioTrackHandler.enqueue(item), [VariableReference(mAudioTrackHandler, []), Expression(item, [])]), AssignmentExpression(=, [VariableReference(mItem, []), Expression(item, [])]), Statement(}, []), Statement(return TextToSpeech.SUCCESS, []), Statement(}, [])])  Statement({, [])  Statement(if (DBG), [])  MethodCall(Log.d(TAG, ""start("" + sampleRateInHz + "", "" + audioFormat + "", "" + channelCount + "")""), [VariableReference(Log, []), Expression(TAG, []), Expression(""start("" + sampleRateInHz + "", []), Expression("" + audioFormat + "", []), Expression("" + channelCount + "")"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""start("" + sampleRateInHz + "", [])    Expression("" + audioFormat + "", [])    Expression("" + channelCount + "")"", [])  AssignmentExpression(=, [VariableReference(if (audioFormat !, []), Expression(AudioFormat.ENCODING_PCM_8BIT && audioFormat !, [])])    VariableReference(if (audioFormat !, [])    Expression(AudioFormat.ENCODING_PCM_8BIT && audioFormat !, [])  MethodCall(Log.w(TAG, ""Audio format encoding "" + audioFormat + "" not supported. Please use one "" + ""of AudioFormat.ENCODING_PCM_8BIT, AudioFormat.ENCODING_PCM_16BIT or "" + ""AudioFormat.ENCODING_PCM_FLOAT""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Audio format encoding "" + audioFormat + "" not supported. Please use one "" + ""of AudioFormat.ENCODING_PCM_8BIT, []), Expression(AudioFormat.ENCODING_PCM_16BIT or "" + ""AudioFormat.ENCODING_PCM_FLOAT"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Audio format encoding "" + audioFormat + "" not supported. Please use one "" + ""of AudioFormat.ENCODING_PCM_8BIT, [])    Expression(AudioFormat.ENCODING_PCM_16BIT or "" + ""AudioFormat.ENCODING_PCM_FLOAT"", [])  Statement(}, [])  MethodCall(mDispatcher.dispatchOnBeginSynthesis(sampleRateInHz, audioFormat, channelCount), [VariableReference(mDispatcher, []), Expression(sampleRateInHz, []), Expression(audioFormat, []), Expression(channelCount, [])])    VariableReference(mDispatcher, [])    Expression(sampleRateInHz, [])    Expression(audioFormat, [])    Expression(channelCount, [])  AssignmentExpression(=, [VariableReference(int channelConfig, []), Expression(BlockingAudioTrack.getChannelConfig(channelCount), [])])    VariableReference(int channelConfig, [])    Expression(BlockingAudioTrack.getChannelConfig(channelCount), [])  Statement(synchronized (mStateLock) {, [])  AssignmentExpression(=, [VariableReference(if (channelConfig, []), Expression(, [])])    VariableReference(if (channelConfig, [])    Expression(, [])  MethodCall(Log.e(TAG, ""Unsupported number of channels :"" + channelCount), [VariableReference(Log, []), Expression(TAG, []), Expression(""Unsupported number of channels :"" + channelCount, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Unsupported number of channels :"" + channelCount, [])  AssignmentExpression(=, [VariableReference(mStatusCode, []), Expression(TextToSpeech.ERROR_OUTPUT, [])])    VariableReference(mStatusCode, [])    Expression(TextToSpeech.ERROR_OUTPUT, [])  Statement(return TextToSpeech.ERROR, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mStatusCode, []), Expression(, [])])    VariableReference(if (mStatusCode, [])    Expression(, [])  Statement(if (DBG), [])  MethodCall(Log.d(TAG, ""stop() called before start(), returning.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""stop() called before start(), []), Expression(returning."", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""stop() called before start(), [])    Expression(returning."", [])  Statement(return errorCodeOnStop(), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mStatusCode !, []), Expression(TextToSpeech.SUCCESS) {, [])])    VariableReference(if (mStatusCode !, [])    Expression(TextToSpeech.SUCCESS) {, [])  Statement(if (DBG), [])  MethodCall(Log.d(TAG, ""Error was raised""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Error was raised"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Error was raised"", [])  Statement(return TextToSpeech.ERROR, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mItem !, []), Expression(null) {, [])])    VariableReference(if (mItem !, [])    Expression(null) {, [])  MethodCall(Log.e(TAG, ""Start called twice""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Start called twice"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Start called twice"", [])  Statement(return TextToSpeech.ERROR, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(SynthesisPlaybackQueueItem item, []), Expression(new SynthesisPlaybackQueueItem(mAudioParams, sampleRateInHz, audioFormat, channelCount, mDispatcher, mCallerIdentity, mLogger), [])])    VariableReference(SynthesisPlaybackQueueItem item, [])    Expression(new SynthesisPlaybackQueueItem(mAudioParams, sampleRateInHz, audioFormat, channelCount, mDispatcher, mCallerIdentity, mLogger), [])  MethodCall(mAudioTrackHandler.enqueue(item), [VariableReference(mAudioTrackHandler, []), Expression(item, [])])    VariableReference(mAudioTrackHandler, [])    Expression(item, [])  AssignmentExpression(=, [VariableReference(mItem, []), Expression(item, [])])    VariableReference(mItem, [])    Expression(item, [])  Statement(}, [])  Statement(return TextToSpeech.SUCCESS, [])  Statement(}, [])",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,"3,4",1,"3,5","1,2","The control dependency has changed as a new 'if' statement is added to check the audio format before dispatching the synthesis. Meanwhile, a new dependent API 'mDispatcher.dispatchOnBeginSynthesis(sampleRateInHz, audioFormat, channelCount)' is called, which could potentially affect the return value or exception handling.","The new 'if' statement for audio format checking could lead to different behavior between the two versions. If the audio format is not supported in the late version, the dispatch of synthesis will not be called, and the method will not return an error. However, in the early version, the dispatch of synthesis will still be called, and if the audio format is not supported, it will return an error. This is a Compatibility Issue caused by potential different return values."
949,<android.accounts.AccountManager: AuthenticatorDescription[] getAuthenticatorTypes()>,20,21,<android.accounts.AccountManager: AuthenticatorDescription[] getAuthenticatorTypes()>,<android.accounts.AccountManager: AuthenticatorDescription[] getAuthenticatorTypes()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(return mService.getAuthenticatorTypes(), [VariableReference(return mService, []), Expression(, [])]), Statement(} catch (RemoteException e) {, []), Statement(// will never happen, []), Statement(throw new RuntimeException(e), []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(return mService.getAuthenticatorTypes(), [VariableReference(return mService, []), Expression(, [])])    VariableReference(return mService, [])    Expression(, [])  Statement(} catch (RemoteException e) {, [])  Statement(// will never happen, [])  Statement(throw new RuntimeException(e), [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(return mService.getAuthenticatorTypes(UserHandle.getCallingUserId()), [VariableReference(return mService, []), Expression(UserHandle.getCallingUserId(), [])]), Statement(} catch (RemoteException e) {, []), Statement(// will never happen, []), Statement(throw new RuntimeException(e), []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(return mService.getAuthenticatorTypes(UserHandle.getCallingUserId()), [VariableReference(return mService, []), Expression(UserHandle.getCallingUserId(), [])])    VariableReference(return mService, [])    Expression(UserHandle.getCallingUserId(), [])  Statement(} catch (RemoteException e) {, [])  Statement(// will never happen, [])  Statement(throw new RuntimeException(e), [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Lists the currently registered authenticators.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>No permission is required to call this method.
 *
 * @return An array of {@link AuthenticatorDescription} for every
 * authenticator known to the AccountManager service.  Empty (never
 * null) if no authenticators are known.
 */
","/**
 * Lists the currently registered authenticators.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>No permission is required to call this method.
 *
 * @return An array of {@link AuthenticatorDescription} for every
 * authenticator known to the AccountManager service.  Empty (never
 * null) if no authenticators are known.
 */
",-1,,,-1,-1,-1,-1,-1,"1,4,5",0,5,1,The method call `mService.getAuthenticatorTypes()` in the early version has been changed to `mService.getAuthenticatorTypes(UserHandle.getCallingUserId())` in the late version. This is a change in the dependent API.,"The change in the dependent API could potentially lead to different return values. In the early version, the method `getAuthenticatorTypes()` returns an array of `AuthenticatorDescription` for every authenticator known to the AccountManager service. In the late version, the method `getAuthenticatorTypes(UserHandle.getCallingUserId())` returns an array of `AuthenticatorDescription` for every authenticator known to the AccountManager service for the specified user. Therefore, if the specified user in the late version has different authenticators known to the AccountManager service, the return values will be different."
17,"<android.view.GLES20Canvas: boolean quickReject(Path,EdgeType)>",15,16,"<android.view.GLES20Canvas: boolean quickReject(Path,EdgeType)>","<android.view.GLES20Canvas: boolean quickReject(Path,EdgeType)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(throw new UnsupportedOperationException(), []), Statement(}, [])])  Statement({, [])  Statement(throw new UnsupportedOperationException(), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(path.computeBounds(mPathBounds, true), [VariableReference(path, []), Expression(mPathBounds, []), Expression(true, [])]), Statement(}, [])])  Statement({, [])  MethodCall(path.computeBounds(mPathBounds, true), [VariableReference(path, []), Expression(mPathBounds, []), Expression(true, [])])    VariableReference(path, [])    Expression(mPathBounds, [])    Expression(true, [])  Statement(}, [])",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,"1,2","1,2",1,1,"The implementation of the method `quickReject(Path,EdgeType)` has been changed. In the early version, it throws an `UnsupportedOperationException` when called, while in the late version, it has a proper implementation that calls the `path.computeBounds(mPathBounds, true)` method.","The change in the implementation of the method `quickReject(Path,EdgeType)` can cause a compatibility issue. In the early version, the method throws an exception when called, while in the late version, it has a proper implementation. Therefore, if an app that was developed using the early version of the API calls this method without handling the exception, it will crash in the late version."
129,"<android.util.Log: int v(String,String)>",7,8,"<android.util.Log: int v(String,String)>","<android.util.Log: int v(String,String)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(return println(VERBOSE, tag, msg), []), Statement(}, [])])  Statement({, [])  Statement(return println(VERBOSE, tag, msg), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return println_native(LOG_ID_MAIN, VERBOSE, tag, msg), []), Statement(}, [])])  Statement({, [])  Statement(return println_native(LOG_ID_MAIN, VERBOSE, tag, msg), [])  Statement(}, [])",1,"/**
 * Send a {@link #VERBOSE} log message.
 * @param tag Used to identify the source of a log message.  It usually identifies
 * the class or activity where the log call occurs.
 * @param msg The message you would like logged.
 */
","/**
 * Send a {@link #VERBOSE} log message.
 * @param tag Used to identify the source of a log message.  It usually identifies
 * the class or activity where the log call occurs.
 * @param msg The message you would like logged.
 */
",-1,,,-1,-1,-1,-1,-1,"1,4",1,5,0,The implementation of the API has been changed from using `println` method to using `println_native` method. This change is considered as a dependent API change.,"The change in the implementation of the API does not affect the behavior of the API. The API still sends a verbose log message with the same tag and message. Therefore, there is no compatibility issue in this case."
424,<android.view.autofill.AutofillId: int hashCode()>,28,29,<android.view.autofill.AutofillId: int hashCode()>,<android.view.autofill.AutofillId: int hashCode()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final int prime, []), Expression(31, [])]), AssignmentExpression(=, [VariableReference(int result, []), Expression(1, [])]), AssignmentExpression(=, [VariableReference(result, []), Expression(prime * result + mViewId, [])]), AssignmentExpression(=, [VariableReference(result, []), Expression(prime * result + mVirtualId, [])]), Statement(return result, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final int prime, []), Expression(31, [])])    VariableReference(final int prime, [])    Expression(31, [])  AssignmentExpression(=, [VariableReference(int result, []), Expression(1, [])])    VariableReference(int result, [])    Expression(1, [])  AssignmentExpression(=, [VariableReference(result, []), Expression(prime * result + mViewId, [])])    VariableReference(result, [])    Expression(prime * result + mViewId, [])  AssignmentExpression(=, [VariableReference(result, []), Expression(prime * result + mVirtualId, [])])    VariableReference(result, [])    Expression(prime * result + mVirtualId, [])  Statement(return result, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final int prime, []), Expression(31, [])]), AssignmentExpression(=, [VariableReference(int result, []), Expression(1, [])]), AssignmentExpression(=, [VariableReference(result, []), Expression(prime * result + mViewId, [])]), AssignmentExpression(=, [VariableReference(result, []), Expression(prime * result + mVirtualIntId, [])]), AssignmentExpression(=, [VariableReference(result, []), Expression(prime * result + (int) (mVirtualLongId ^ (mVirtualLongId >>> 32)), [])]), AssignmentExpression(=, [VariableReference(result, []), Expression(prime * result + mSessionId, [])]), Statement(return result, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final int prime, []), Expression(31, [])])    VariableReference(final int prime, [])    Expression(31, [])  AssignmentExpression(=, [VariableReference(int result, []), Expression(1, [])])    VariableReference(int result, [])    Expression(1, [])  AssignmentExpression(=, [VariableReference(result, []), Expression(prime * result + mViewId, [])])    VariableReference(result, [])    Expression(prime * result + mViewId, [])  AssignmentExpression(=, [VariableReference(result, []), Expression(prime * result + mVirtualIntId, [])])    VariableReference(result, [])    Expression(prime * result + mVirtualIntId, [])  AssignmentExpression(=, [VariableReference(result, []), Expression(prime * result + (int) (mVirtualLongId ^ (mVirtualLongId >>> 32)), [])])    VariableReference(result, [])    Expression(prime * result + (int) (mVirtualLongId ^ (mVirtualLongId >>> 32)), [])  AssignmentExpression(=, [VariableReference(result, []), Expression(prime * result + mSessionId, [])])    VariableReference(result, [])    Expression(prime * result + mSessionId, [])  Statement(return result, [])  Statement(}, [])",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,"1,4",1,"1,5",1,"The late version implementation of the `hashCode()` method has additional statements compared to the early version. Specifically, there are two more assignment statements that update the `result` variable by adding the values of `mVirtualLongId` and `mSessionId` to it. This means that the `hashCode()` method in the late version is likely to return a different value than the early version for the same `AutofillId` object if the values of `mVirtualLongId` or `mSessionId` are non-zero.","The Compatibility Issue (CI) in this case is that the `hashCode()` method in the late version may return a different value than the early version for the same `AutofillId` object. This can potentially break the functionality of any code that relies on the `hashCode()` method to compare or store `AutofillId` objects. For example, if a `HashMap` is used to store `AutofillId` objects as keys, updating to the late version of the library may cause the `HashMap` to behave incorrectly if the `hashCode()` method returns a different value for the same `AutofillId` object."
741,"<android.bluetooth.BluetoothHidDevice: boolean reportError(BluetoothDevice,byte)>",28,29,"<android.bluetooth.BluetoothHidDevice: boolean reportError(BluetoothDevice,byte)>","<android.bluetooth.BluetoothHidDevice: boolean reportError(BluetoothDevice,byte)>",0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(boolean result, []), Expression(false, [])]), AssignmentExpression(=, [VariableReference(final IBluetoothHidDevice service, []), Expression(mService, [])]), AssignmentExpression(=, [VariableReference(if (service !, []), Expression(null) {, [])]), Statement(try {, []), AssignmentExpression(=, [VariableReference(result, []), Expression(service.reportError(device, error), [])]), Statement(} catch (RemoteException e) {, []), MethodCall(Log.e(TAG, e.toString()), [VariableReference(Log, []), Expression(TAG, []), Expression(e.toString(), [])]), Statement(}, []), Statement(} else {, []), MethodCall(Log.w(TAG, ""Proxy not attached to service""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Proxy not attached to service"", [])]), Statement(}, []), Statement(return result, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(boolean result, []), Expression(false, [])])    VariableReference(boolean result, [])    Expression(false, [])  AssignmentExpression(=, [VariableReference(final IBluetoothHidDevice service, []), Expression(mService, [])])    VariableReference(final IBluetoothHidDevice service, [])    Expression(mService, [])  AssignmentExpression(=, [VariableReference(if (service !, []), Expression(null) {, [])])    VariableReference(if (service !, [])    Expression(null) {, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(result, []), Expression(service.reportError(device, error), [])])    VariableReference(result, [])    Expression(service.reportError(device, error), [])  Statement(} catch (RemoteException e) {, [])  MethodCall(Log.e(TAG, e.toString()), [VariableReference(Log, []), Expression(TAG, []), Expression(e.toString(), [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(e.toString(), [])  Statement(}, [])  Statement(} else {, [])  MethodCall(Log.w(TAG, ""Proxy not attached to service""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Proxy not attached to service"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Proxy not attached to service"", [])  Statement(}, [])  Statement(return result, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(boolean result, []), Expression(false, [])]), AssignmentExpression(=, [VariableReference(final IBluetoothHidDevice service, []), Expression(getService(), [])]), AssignmentExpression(=, [VariableReference(if (service !, []), Expression(null) {, [])]), Statement(try {, []), AssignmentExpression(=, [VariableReference(result, []), Expression(service.reportError(device, error), [])]), Statement(} catch (RemoteException e) {, []), MethodCall(Log.e(TAG, e.toString()), [VariableReference(Log, []), Expression(TAG, []), Expression(e.toString(), [])]), Statement(}, []), Statement(} else {, []), MethodCall(Log.w(TAG, ""Proxy not attached to service""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Proxy not attached to service"", [])]), Statement(}, []), Statement(return result, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(boolean result, []), Expression(false, [])])    VariableReference(boolean result, [])    Expression(false, [])  AssignmentExpression(=, [VariableReference(final IBluetoothHidDevice service, []), Expression(getService(), [])])    VariableReference(final IBluetoothHidDevice service, [])    Expression(getService(), [])  AssignmentExpression(=, [VariableReference(if (service !, []), Expression(null) {, [])])    VariableReference(if (service !, [])    Expression(null) {, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(result, []), Expression(service.reportError(device, error), [])])    VariableReference(result, [])    Expression(service.reportError(device, error), [])  Statement(} catch (RemoteException e) {, [])  MethodCall(Log.e(TAG, e.toString()), [VariableReference(Log, []), Expression(TAG, []), Expression(e.toString(), [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(e.toString(), [])  Statement(}, [])  Statement(} else {, [])  MethodCall(Log.w(TAG, ""Proxy not attached to service""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Proxy not attached to service"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Proxy not attached to service"", [])  Statement(}, [])  Statement(return result, [])  Statement(}, [])",1,"/**
 * Sends error handshake message as reply for invalid SET_REPORT request from {@link
 * Callback#onSetReport(BluetoothDevice, byte, byte, byte[])}.
 *
 * @param error Error to be sent for SET_REPORT via HANDSHAKE.
 * @return true if the command is successfully sent; otherwise false.
 */
","/**
 * Sends error handshake message as reply for invalid SET_REPORT request from {@link
 * Callback#onSetReport(BluetoothDevice, byte, byte, byte[])}.
 *
 * @param error Error to be sent for SET_REPORT via HANDSHAKE.
 * @return true if the command is successfully sent; otherwise false.
 */
",-1,,,-1,-1,-1,-1,-1,4,0,5,1,"The second assignment statement within the method declaration has been changed from 'Expression(mService, [])' to 'Expression(getService(), [])' in the late version. This implies that the way the service object is being obtained has been modified between the two versions.","The change in the way the service object is obtained (from 'mService' to 'getService()') could potentially lead to a different value or type being returned in the late version. This, in turn, could impact the behavior of the API and hence, is classified as a Compatibility Issue (CI) caused by potential different return values or types."
350,"<android.database.sqlite.SQLiteDatabase: SQLiteDatabase openDatabase(String,CursorFactory,int,DatabaseErrorHandler)>",27,28,"<android.database.sqlite.SQLiteDatabase: SQLiteDatabase openDatabase(String,CursorFactory,int,DatabaseErrorHandler)>","<android.database.sqlite.SQLiteDatabase: SQLiteDatabase openDatabase(String,CursorFactory,int,DatabaseErrorHandler)>",0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(SQLiteDatabase db, []), Expression(new SQLiteDatabase(path, flags, factory, errorHandler, -1, -1, -1), [])]), MethodCall(db.open(), [VariableReference(db, []), Expression(, [])]), Statement(return db, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(SQLiteDatabase db, []), Expression(new SQLiteDatabase(path, flags, factory, errorHandler, -1, -1, -1), [])])    VariableReference(SQLiteDatabase db, [])    Expression(new SQLiteDatabase(path, flags, factory, errorHandler, -1, -1, -1), [])  MethodCall(db.open(), [VariableReference(db, []), Expression(, [])])    VariableReference(db, [])    Expression(, [])  Statement(return db, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(SQLiteDatabase db, []), Expression(new SQLiteDatabase(path, flags, factory, errorHandler, -1, -1, -1, null, null), [])]), MethodCall(db.open(), [VariableReference(db, []), Expression(, [])]), Statement(return db, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(SQLiteDatabase db, []), Expression(new SQLiteDatabase(path, flags, factory, errorHandler, -1, -1, -1, null, null), [])])    VariableReference(SQLiteDatabase db, [])    Expression(new SQLiteDatabase(path, flags, factory, errorHandler, -1, -1, -1, null, null), [])  MethodCall(db.open(), [VariableReference(db, []), Expression(, [])])    VariableReference(db, [])    Expression(, [])  Statement(return db, [])  Statement(}, [])",1,"/**
 * Open the database according to the flags {@link #OPEN_READWRITE}
 * {@link #OPEN_READONLY} {@link #CREATE_IF_NECESSARY} and/or {@link #NO_LOCALIZED_COLLATORS}.
 *
 * <p>Sets the locale of the database to the  the system's current locale.
 * Call {@link #setLocale} if you would like something else.</p>
 *
 * <p>Accepts input param: a concrete instance of {@link DatabaseErrorHandler} to be
 * used to handle corruption when sqlite reports database corruption.</p>
 *
 * @param path to database file to open and/or create
 * @param factory an optional factory class that is called to instantiate a
 * cursor when query is called, or null for default
 * @param flags to control database access mode
 * @param errorHandler the {@link DatabaseErrorHandler} obj to be used to handle corruption
 * when sqlite reports database corruption
 * @return the newly opened database
 * @throws SQLiteException if the database cannot be opened
 */
","/**
 * Open the database according to the flags {@link #OPEN_READWRITE}
 * {@link #OPEN_READONLY} {@link #CREATE_IF_NECESSARY} and/or {@link #NO_LOCALIZED_COLLATORS}.
 *
 * <p>Sets the locale of the database to the  the system's current locale.
 * Call {@link #setLocale} if you would like something else.</p>
 *
 * <p>Accepts input param: a concrete instance of {@link DatabaseErrorHandler} to be
 * used to handle corruption when sqlite reports database corruption.</p>
 *
 * @param path to database file to open and/or create
 * @param factory an optional factory class that is called to instantiate a
 * cursor when query is called, or null for default
 * @param flags to control database access mode
 * @param errorHandler the {@link DatabaseErrorHandler} obj to be used to handle corruption
 * when sqlite reports database corruption
 * @return the newly opened database
 * @throws SQLiteException if the database cannot be opened
 */
",-1,,,-1,-1,-1,-1,-1,5,0,5,1,"The constructor of SQLiteDatabase has changed, with two additional null parameters in the late version. This change is classified as 5, Dependent API changed.","The different constructor of SQLiteDatabase in the late version may cause the API to return a different object, which could lead to compatibility issues. Therefore, the CI type is 1."
571,<android.animation.PropertyValuesHolder.IntPropertyValuesHolder: IntPropertyValuesHolder clone()>,20,21,<android.animation.PropertyValuesHolder.IntPropertyValuesHolder: IntPropertyValuesHolder clone()>,<android.animation.PropertyValuesHolder.IntPropertyValuesHolder: IntPropertyValuesHolder clone()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(IntPropertyValuesHolder newPVH, []), Expression((IntPropertyValuesHolder) super.clone(), [])]), AssignmentExpression(=, [VariableReference(newPVH.mIntKeyframeSet, []), Expression((IntKeyframeSet) newPVH.mKeyframeSet, [])]), Statement(return newPVH, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(IntPropertyValuesHolder newPVH, []), Expression((IntPropertyValuesHolder) super.clone(), [])])    VariableReference(IntPropertyValuesHolder newPVH, [])    Expression((IntPropertyValuesHolder) super.clone(), [])  AssignmentExpression(=, [VariableReference(newPVH.mIntKeyframeSet, []), Expression((IntKeyframeSet) newPVH.mKeyframeSet, [])])    VariableReference(newPVH.mIntKeyframeSet, [])    Expression((IntKeyframeSet) newPVH.mKeyframeSet, [])  Statement(return newPVH, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(IntPropertyValuesHolder newPVH, []), Expression((IntPropertyValuesHolder) super.clone(), [])]), AssignmentExpression(=, [VariableReference(newPVH.mIntKeyframes, []), Expression((Keyframes.IntKeyframes) newPVH.mKeyframes, [])]), Statement(return newPVH, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(IntPropertyValuesHolder newPVH, []), Expression((IntPropertyValuesHolder) super.clone(), [])])    VariableReference(IntPropertyValuesHolder newPVH, [])    Expression((IntPropertyValuesHolder) super.clone(), [])  AssignmentExpression(=, [VariableReference(newPVH.mIntKeyframes, []), Expression((Keyframes.IntKeyframes) newPVH.mKeyframes, [])])    VariableReference(newPVH.mIntKeyframes, [])    Expression((Keyframes.IntKeyframes) newPVH.mKeyframes, [])  Statement(return newPVH, [])  Statement(}, [])",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,4,0,5,1,"A new statement 'newPVH.mIntKeyframes = (Keyframes.IntKeyframes) newPVH.mKeyframes;' is added, which is a type cast statement that changes the control dependency. The added statement will potentially change the value of 'mIntKeyframes' of the object 'newPVH', thus the 'return newPVH' statement can potentially return a different object. Therefore, the change type is 5.","The added statement can potentially change the value of 'mIntKeyframes' of the object 'newPVH', thus the 'return newPVH' statement can potentially return a different object. This is a compatibility issue that can cause the application to behave differently in the two versions. The CI type is 1."
206,<android.app.SharedPreferencesImpl.EditorImpl: Editor remove(String)>,25,26,<android.app.SharedPreferencesImpl.EditorImpl: Editor remove(String)>,<android.app.SharedPreferencesImpl.EditorImpl: Editor remove(String)>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(synchronized (this) {, []), MethodCall(mModified.put(key, this), [VariableReference(mModified, []), Expression(key, []), Expression(this, [])]), Statement(return this, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(synchronized (this) {, [])  MethodCall(mModified.put(key, this), [VariableReference(mModified, []), Expression(key, []), Expression(this, [])])    VariableReference(mModified, [])    Expression(key, [])    Expression(this, [])  Statement(return this, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(synchronized (mLock) {, []), MethodCall(mModified.put(key, this), [VariableReference(mModified, []), Expression(key, []), Expression(this, [])]), Statement(return this, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(synchronized (mLock) {, [])  MethodCall(mModified.put(key, this), [VariableReference(mModified, []), Expression(key, []), Expression(this, [])])    VariableReference(mModified, [])    Expression(key, [])    Expression(this, [])  Statement(return this, [])  Statement(}, [])  Statement(}, [])",1,,,-1,,,-1,-1,-1,-1,-1,4,0,3,0,The code change is that the synchronization object has been changed from "this" to "mLock". This is a control dependency change as it affects the synchronization of the method.,"The code change does not affect the return value or the exception handling of the method. Therefore, there is no compatibility issue."
126,<android.animation.ValueAnimator: void resume()>,23,24,<android.animation.ValueAnimator: void resume()>,<android.animation.ValueAnimator: void resume()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(if (mPaused) {, []), AssignmentExpression(=, [VariableReference(mResumed, []), Expression(true, [])]), Statement(}, []), MethodCall(super.resume(), [VariableReference(super, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  Statement(if (mPaused) {, [])  AssignmentExpression(=, [VariableReference(mResumed, []), Expression(true, [])])    VariableReference(mResumed, [])    Expression(true, [])  Statement(}, [])  MethodCall(super.resume(), [VariableReference(super, []), Expression(, [])])    VariableReference(super, [])    Expression(, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (Looper.myLooper(), []), Expression(, [])]), Statement(throw new AndroidRuntimeException(""Animators may only be resumed from the same "" + ""thread that the animator was started on""), []), Statement(}, []), Statement(if (mPaused && !mResumed) {, []), AssignmentExpression(=, [VariableReference(mResumed, []), Expression(true, [])]), Statement(if (mPauseTime > 0) {, []), AssignmentExpression(=, [VariableReference(AnimationHandler handler, []), Expression(AnimationHandler.getInstance(), [])]), MethodCall(handler.addAnimationFrameCallback(this, 0), [VariableReference(handler, []), Expression(this, []), Expression(0, [])]), Statement(}, []), Statement(}, []), MethodCall(super.resume(), [VariableReference(super, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (Looper.myLooper(), []), Expression(, [])])    VariableReference(if (Looper.myLooper(), [])    Expression(, [])  Statement(throw new AndroidRuntimeException(""Animators may only be resumed from the same "" + ""thread that the animator was started on""), [])  Statement(}, [])  Statement(if (mPaused && !mResumed) {, [])  AssignmentExpression(=, [VariableReference(mResumed, []), Expression(true, [])])    VariableReference(mResumed, [])    Expression(true, [])  Statement(if (mPauseTime > 0) {, [])  AssignmentExpression(=, [VariableReference(AnimationHandler handler, []), Expression(AnimationHandler.getInstance(), [])])    VariableReference(AnimationHandler handler, [])    Expression(AnimationHandler.getInstance(), [])  MethodCall(handler.addAnimationFrameCallback(this, 0), [VariableReference(handler, []), Expression(this, []), Expression(0, [])])    VariableReference(handler, [])    Expression(this, [])    Expression(0, [])  Statement(}, [])  Statement(}, [])  MethodCall(super.resume(), [VariableReference(super, []), Expression(, [])])    VariableReference(super, [])    Expression(, [])  Statement(}, [])",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,"2,3,4","1,2","2,5","1,2","The implementation of the `resume()` method has been modified in the later version. In the early version, the method simply sets the `mResumed` variable to `true` and calls `super.resume()`. However, in the later version, there is an additional check for the current thread using `Looper.myLooper()` and an exception is thrown if the current thread is not the same as the one the animator was started on. There is also an additional `if` statement that checks the value of `mPaused` and `mResumed` and calls the `addAnimationFrameCallback()` method of the `AnimationHandler` class if `mPauseTime > 0`.","The modification in the later version can potentially lead to compatibility issues. The additional thread check and exception can cause the `resume()` method to behave differently in the later version, potentially causing the application to crash if the animator is resumed from a different thread. The additional `if` statement and the call to `addAnimationFrameCallback()` can also lead to different behavior in the later version, potentially causing the animation to not resume or resume incorrectly."
1096,<android.speech.SpeechRecognizer: void destroy()>,20,21,<android.speech.SpeechRecognizer: void destroy()>,<android.speech.SpeechRecognizer: void destroy()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mConnection !, []), Expression(null) {, [])]), MethodCall(mContext.unbindService(mConnection), [VariableReference(mContext, []), Expression(mConnection, [])]), Statement(}, []), MethodCall(mPendingTasks.clear(), [VariableReference(mPendingTasks, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(mService, []), Expression(null, [])]), AssignmentExpression(=, [VariableReference(mConnection, []), Expression(null, [])]), AssignmentExpression(=, [VariableReference(mListener.mInternalListener, []), Expression(null, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mConnection !, []), Expression(null) {, [])])    VariableReference(if (mConnection !, [])    Expression(null) {, [])  MethodCall(mContext.unbindService(mConnection), [VariableReference(mContext, []), Expression(mConnection, [])])    VariableReference(mContext, [])    Expression(mConnection, [])  Statement(}, [])  MethodCall(mPendingTasks.clear(), [VariableReference(mPendingTasks, []), Expression(, [])])    VariableReference(mPendingTasks, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(mService, []), Expression(null, [])])    VariableReference(mService, [])    Expression(null, [])  AssignmentExpression(=, [VariableReference(mConnection, []), Expression(null, [])])    VariableReference(mConnection, [])    Expression(null, [])  AssignmentExpression(=, [VariableReference(mListener.mInternalListener, []), Expression(null, [])])    VariableReference(mListener.mInternalListener, [])    Expression(null, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mService !, []), Expression(null) {, [])]), Statement(try {, []), MethodCall(mService.cancel(mListener), [VariableReference(mService, []), Expression(mListener, [])]), Statement(} catch (final RemoteException e) {, []), Statement(// Not important, []), Statement(}, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (mConnection !, []), Expression(null) {, [])]), MethodCall(mContext.unbindService(mConnection), [VariableReference(mContext, []), Expression(mConnection, [])]), Statement(}, []), MethodCall(mPendingTasks.clear(), [VariableReference(mPendingTasks, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(mService, []), Expression(null, [])]), AssignmentExpression(=, [VariableReference(mConnection, []), Expression(null, [])]), AssignmentExpression(=, [VariableReference(mListener.mInternalListener, []), Expression(null, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mService !, []), Expression(null) {, [])])    VariableReference(if (mService !, [])    Expression(null) {, [])  Statement(try {, [])  MethodCall(mService.cancel(mListener), [VariableReference(mService, []), Expression(mListener, [])])    VariableReference(mService, [])    Expression(mListener, [])  Statement(} catch (final RemoteException e) {, [])  Statement(// Not important, [])  Statement(}, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (mConnection !, []), Expression(null) {, [])])    VariableReference(if (mConnection !, [])    Expression(null) {, [])  MethodCall(mContext.unbindService(mConnection), [VariableReference(mContext, []), Expression(mConnection, [])])    VariableReference(mContext, [])    Expression(mConnection, [])  Statement(}, [])  MethodCall(mPendingTasks.clear(), [VariableReference(mPendingTasks, []), Expression(, [])])    VariableReference(mPendingTasks, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(mService, []), Expression(null, [])])    VariableReference(mService, [])    Expression(null, [])  AssignmentExpression(=, [VariableReference(mConnection, []), Expression(null, [])])    VariableReference(mConnection, [])    Expression(null, [])  AssignmentExpression(=, [VariableReference(mListener.mInternalListener, []), Expression(null, [])])    VariableReference(mListener.mInternalListener, [])    Expression(null, [])  Statement(}, [])",1,"/**
 * Destroys the {@code SpeechRecognizer} object.
 */
","/**
 * Destroys the {@code SpeechRecognizer} object.
 */
",-1,,,-1,-1,-1,-1,-1,"2,3,4",2,"2,5","1,2","The method body has changed significantly between the two versions. In the early version, it only unbinds the service and clears the pending tasks. In the late version, it first checks if the service is not null, then cancels the service and catches the RemoteException exception. It also unbinds the service, clears the pending tasks, and sets the service, connection, and listener to null.","The changes in the method body could potentially lead to compatibility issues. The cancellation of the service in the late version could cause different behavior if the service was not cancelled in the early version. The exception handling of the RemoteException in the late version could also cause different behavior if the exception was not handled in the early version. The setting of the service, connection, and listener to null in the late version could cause different behavior if they were not set to null in the early version."
90,<android.widget.RemoteViewsAdapter.FixedSizeRemoteViewsCache: RemoteViewsIndexMetaData getMetaDataAt(int)>,23,24,<android.widget.RemoteViewsAdapter.FixedSizeRemoteViewsCache: RemoteViewsIndexMetaData getMetaDataAt(int)>,<android.widget.RemoteViewsAdapter.FixedSizeRemoteViewsCache: RemoteViewsIndexMetaData getMetaDataAt(int)>,0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(if (mIndexMetaData.containsKey(position)), [VariableReference(if (mIndexMetaData, []), Expression(position), [])]), MethodCall(return mIndexMetaData.get(position), [VariableReference(return mIndexMetaData, []), Expression(position, [])]), Statement(}, []), Statement(return null, []), Statement(}, [])])  Statement({, [])  MethodCall(if (mIndexMetaData.containsKey(position)), [VariableReference(if (mIndexMetaData, []), Expression(position), [])])    VariableReference(if (mIndexMetaData, [])    Expression(position), [])  MethodCall(return mIndexMetaData.get(position), [VariableReference(return mIndexMetaData, []), Expression(position, [])])    VariableReference(return mIndexMetaData, [])    Expression(position, [])  Statement(}, [])  Statement(return null, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(return mIndexMetaData.get(position), [VariableReference(return mIndexMetaData, []), Expression(position, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return mIndexMetaData.get(position), [VariableReference(return mIndexMetaData, []), Expression(position, [])])    VariableReference(return mIndexMetaData, [])    Expression(position, [])  Statement(}, [])",1,,,-1,,,-1,-1,-1,-1,-1,"1,3",1,"1,4",1,"The implementation of the method `getMetaDataAt(int)` in the class `FixedSizeRemoteViewsCache` has changed between version 23 and 24. In the early version, the method first checks if the `mIndexMetaData` map contains the specified position using the `containsKey()` method. If it does, it returns the corresponding `RemoteViewsIndexMetaData` object using the `get()` method. If it doesn't, it returns `null`. In the late version, the method directly calls the `get()` method on the `mIndexMetaData` map without checking if the key exists. If the key doesn't exist, the `get()` method will also return `null`. The change type is 1,4: the return statement has changed (the condition for returning has been removed), and other statement has changed (the `containsKey()` method call has been removed).","The Compatibility Issue (CI) arises because the code change between the two versions could potentially lead to different behaviors. Specifically, in the early version, if the `mIndexMetaData` map is modified concurrently and the specified position is removed between the `containsKey()` and `get()` method calls, the method will still return the corresponding `RemoteViewsIndexMetaData` object, which is incorrect. In the late version, this problem is avoided because the `get()` method is called directly without checking if the key exists. Therefore, the CI type is 1: Compatibility Issue caused by potential different return values or types."
497,"<android.view.GLES20Canvas: void drawHardwareLayer(HardwareLayer,float,float,Paint)>",16,17,"<android.view.GLES20Canvas: void drawHardwareLayer(HardwareLayer,float,float,Paint)>","<android.view.GLES20Canvas: void drawHardwareLayer(HardwareLayer,float,float,Paint)>",0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final GLES20Layer glLayer, []), Expression((GLES20Layer) layer, [])]), AssignmentExpression(=, [VariableReference(int modifier, []), Expression(paint !, [])]), Statement(try {, []), AssignmentExpression(=, [VariableReference(final int nativePaint, []), Expression(paint, [])]), MethodCall(nDrawLayer(mRenderer, glLayer.getLayer(), x, y, nativePaint), [VariableReference(nDrawLayer(mRenderer, glLayer, []), Expression(), []), Expression(x, []), Expression(y, []), Expression(nativePaint, [])]), Statement(} finally {, []), AssignmentExpression(=, [VariableReference(if (modifier !, []), Expression(MODIFIER_NONE), [])]), Statement(nResetModifiers(mRenderer, modifier), []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final GLES20Layer glLayer, []), Expression((GLES20Layer) layer, [])])    VariableReference(final GLES20Layer glLayer, [])    Expression((GLES20Layer) layer, [])  AssignmentExpression(=, [VariableReference(int modifier, []), Expression(paint !, [])])    VariableReference(int modifier, [])    Expression(paint !, [])  Statement(try {, [])  AssignmentExpression(=, [VariableReference(final int nativePaint, []), Expression(paint, [])])    VariableReference(final int nativePaint, [])    Expression(paint, [])  MethodCall(nDrawLayer(mRenderer, glLayer.getLayer(), x, y, nativePaint), [VariableReference(nDrawLayer(mRenderer, glLayer, []), Expression(), []), Expression(x, []), Expression(y, []), Expression(nativePaint, [])])    VariableReference(nDrawLayer(mRenderer, glLayer, [])    Expression(), [])    Expression(x, [])    Expression(y, [])    Expression(nativePaint, [])  Statement(} finally {, [])  AssignmentExpression(=, [VariableReference(if (modifier !, []), Expression(MODIFIER_NONE), [])])    VariableReference(if (modifier !, [])    Expression(MODIFIER_NONE), [])  Statement(nResetModifiers(mRenderer, modifier), [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final GLES20Layer glLayer, []), Expression((GLES20Layer) layer, [])]), AssignmentExpression(=, [VariableReference(final int nativePaint, []), Expression(paint, [])]), MethodCall(nDrawLayer(mRenderer, glLayer.getLayer(), x, y, nativePaint), [VariableReference(nDrawLayer(mRenderer, glLayer, []), Expression(), []), Expression(x, []), Expression(y, []), Expression(nativePaint, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final GLES20Layer glLayer, []), Expression((GLES20Layer) layer, [])])    VariableReference(final GLES20Layer glLayer, [])    Expression((GLES20Layer) layer, [])  AssignmentExpression(=, [VariableReference(final int nativePaint, []), Expression(paint, [])])    VariableReference(final int nativePaint, [])    Expression(paint, [])  MethodCall(nDrawLayer(mRenderer, glLayer.getLayer(), x, y, nativePaint), [VariableReference(nDrawLayer(mRenderer, glLayer, []), Expression(), []), Expression(x, []), Expression(y, []), Expression(nativePaint, [])])    VariableReference(nDrawLayer(mRenderer, glLayer, [])    Expression(), [])    Expression(x, [])    Expression(y, [])    Expression(nativePaint, [])  Statement(}, [])",1,,,-1,,,-1,-1,-1,-1,-1,"2,3,4",0,4,0,The "finally" block and the code inside it have been removed in the late version.,"The removal of the ""finally"" block does not affect the behavior of the API since it only performs some cleanup work that does not affect the return value or exception handling. Therefore, there is no compatibility issue."
288,"<android.speech.tts.PlaybackSynthesisCallback: int audioAvailable(byte[],int,int)>",15,16,"<android.speech.tts.PlaybackSynthesisCallback: int audioAvailable(byte[],int,int)>","<android.speech.tts.PlaybackSynthesisCallback: int audioAvailable(byte[],int,int)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(if (DBG) {, []), MethodCall(Log.d(TAG, ""audioAvailable(byte["" + buffer.length + ""], "" + offset + "", "" + length + "")""), [VariableReference(Log, []), Expression(TAG, []), Expression(""audioAvailable(byte["" + buffer.length + ""], []), Expression("" + offset + "", []), Expression("" + length + "")"", [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (length > getMaxBufferSize() || length <, []), Expression(0) {, [])]), Statement(throw new IllegalArgumentException(""buffer is too large or of zero length ("" + +length + "" bytes)""), []), Statement(}, []), AssignmentExpression(=, [VariableReference(SynthesisMessageParams token, []), Expression(null, [])]), Statement(synchronized (mStateLock) {, []), AssignmentExpression(=, [VariableReference(if (mToken, []), Expression(, [])]), Statement(return TextToSpeech.ERROR, []), Statement(}, []), AssignmentExpression(=, [VariableReference(token, []), Expression(mToken, [])]), Statement(}, []), Statement(// Sigh, another copy., []), AssignmentExpression(=, [VariableReference(final byte[] bufferCopy, []), Expression(new byte[length], [])]), MethodCall(System.arraycopy(buffer, offset, bufferCopy, 0, length), [VariableReference(System, []), Expression(buffer, []), Expression(offset, []), Expression(bufferCopy, []), Expression(0, []), Expression(length, [])]), Statement(// Might block on mToken.this, if there are too many buffers waiting to, []), Statement(// be consumed., []), MethodCall(token.addBuffer(bufferCopy), [VariableReference(token, []), Expression(bufferCopy, [])]), MethodCall(mAudioTrackHandler.enqueueSynthesisDataAvailable(token), [VariableReference(mAudioTrackHandler, []), Expression(token, [])]), MethodCall(mLogger.onEngineDataReceived(), [VariableReference(mLogger, []), Expression(, [])]), Statement(return TextToSpeech.SUCCESS, []), Statement(}, [])])  Statement({, [])  Statement(if (DBG) {, [])  MethodCall(Log.d(TAG, ""audioAvailable(byte["" + buffer.length + ""], "" + offset + "", "" + length + "")""), [VariableReference(Log, []), Expression(TAG, []), Expression(""audioAvailable(byte["" + buffer.length + ""], []), Expression("" + offset + "", []), Expression("" + length + "")"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""audioAvailable(byte["" + buffer.length + ""], [])    Expression("" + offset + "", [])    Expression("" + length + "")"", [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (length > getMaxBufferSize() || length <, []), Expression(0) {, [])])    VariableReference(if (length > getMaxBufferSize() || length <, [])    Expression(0) {, [])  Statement(throw new IllegalArgumentException(""buffer is too large or of zero length ("" + +length + "" bytes)""), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(SynthesisMessageParams token, []), Expression(null, [])])    VariableReference(SynthesisMessageParams token, [])    Expression(null, [])  Statement(synchronized (mStateLock) {, [])  AssignmentExpression(=, [VariableReference(if (mToken, []), Expression(, [])])    VariableReference(if (mToken, [])    Expression(, [])  Statement(return TextToSpeech.ERROR, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(token, []), Expression(mToken, [])])    VariableReference(token, [])    Expression(mToken, [])  Statement(}, [])  Statement(// Sigh, another copy., [])  AssignmentExpression(=, [VariableReference(final byte[] bufferCopy, []), Expression(new byte[length], [])])    VariableReference(final byte[] bufferCopy, [])    Expression(new byte[length], [])  MethodCall(System.arraycopy(buffer, offset, bufferCopy, 0, length), [VariableReference(System, []), Expression(buffer, []), Expression(offset, []), Expression(bufferCopy, []), Expression(0, []), Expression(length, [])])    VariableReference(System, [])    Expression(buffer, [])    Expression(offset, [])    Expression(bufferCopy, [])    Expression(0, [])    Expression(length, [])  Statement(// Might block on mToken.this, if there are too many buffers waiting to, [])  Statement(// be consumed., [])  MethodCall(token.addBuffer(bufferCopy), [VariableReference(token, []), Expression(bufferCopy, [])])    VariableReference(token, [])    Expression(bufferCopy, [])  MethodCall(mAudioTrackHandler.enqueueSynthesisDataAvailable(token), [VariableReference(mAudioTrackHandler, []), Expression(token, [])])    VariableReference(mAudioTrackHandler, [])    Expression(token, [])  MethodCall(mLogger.onEngineDataReceived(), [VariableReference(mLogger, []), Expression(, [])])    VariableReference(mLogger, [])    Expression(, [])  Statement(return TextToSpeech.SUCCESS, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (DBG) {, []), MethodCall(Log.d(TAG, ""audioAvailable(byte["" + buffer.length + ""], "" + offset + "", "" + length + "")""), [VariableReference(Log, []), Expression(TAG, []), Expression(""audioAvailable(byte["" + buffer.length + ""], []), Expression("" + offset + "", []), Expression("" + length + "")"", [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (length > getMaxBufferSize() || length <, []), Expression(0) {, [])]), Statement(throw new IllegalArgumentException(""buffer is too large or of zero length ("" + +length + "" bytes)""), []), Statement(}, []), AssignmentExpression(=, [VariableReference(SynthesisPlaybackQueueItem item, []), Expression(null, [])]), Statement(synchronized (mStateLock) {, []), AssignmentExpression(=, [VariableReference(if (mItem, []), Expression(, [])]), Statement(return TextToSpeech.ERROR, []), Statement(}, []), AssignmentExpression(=, [VariableReference(item, []), Expression(mItem, [])]), Statement(}, []), Statement(// Sigh, another copy., []), AssignmentExpression(=, [VariableReference(final byte[] bufferCopy, []), Expression(new byte[length], [])]), MethodCall(System.arraycopy(buffer, offset, bufferCopy, 0, length), [VariableReference(System, []), Expression(buffer, []), Expression(offset, []), Expression(bufferCopy, []), Expression(0, []), Expression(length, [])]), Statement(// be consumed., []), Statement(try {, []), MethodCall(item.put(bufferCopy), [VariableReference(item, []), Expression(bufferCopy, [])]), Statement(} catch (InterruptedException ie) {, []), Statement(return TextToSpeech.ERROR, []), Statement(}, []), MethodCall(mLogger.onEngineDataReceived(), [VariableReference(mLogger, []), Expression(, [])]), Statement(return TextToSpeech.SUCCESS, []), Statement(}, [])])  Statement({, [])  Statement(if (DBG) {, [])  MethodCall(Log.d(TAG, ""audioAvailable(byte["" + buffer.length + ""], "" + offset + "", "" + length + "")""), [VariableReference(Log, []), Expression(TAG, []), Expression(""audioAvailable(byte["" + buffer.length + ""], []), Expression("" + offset + "", []), Expression("" + length + "")"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""audioAvailable(byte["" + buffer.length + ""], [])    Expression("" + offset + "", [])    Expression("" + length + "")"", [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (length > getMaxBufferSize() || length <, []), Expression(0) {, [])])    VariableReference(if (length > getMaxBufferSize() || length <, [])    Expression(0) {, [])  Statement(throw new IllegalArgumentException(""buffer is too large or of zero length ("" + +length + "" bytes)""), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(SynthesisPlaybackQueueItem item, []), Expression(null, [])])    VariableReference(SynthesisPlaybackQueueItem item, [])    Expression(null, [])  Statement(synchronized (mStateLock) {, [])  AssignmentExpression(=, [VariableReference(if (mItem, []), Expression(, [])])    VariableReference(if (mItem, [])    Expression(, [])  Statement(return TextToSpeech.ERROR, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(item, []), Expression(mItem, [])])    VariableReference(item, [])    Expression(mItem, [])  Statement(}, [])  Statement(// Sigh, another copy., [])  AssignmentExpression(=, [VariableReference(final byte[] bufferCopy, []), Expression(new byte[length], [])])    VariableReference(final byte[] bufferCopy, [])    Expression(new byte[length], [])  MethodCall(System.arraycopy(buffer, offset, bufferCopy, 0, length), [VariableReference(System, []), Expression(buffer, []), Expression(offset, []), Expression(bufferCopy, []), Expression(0, []), Expression(length, [])])    VariableReference(System, [])    Expression(buffer, [])    Expression(offset, [])    Expression(bufferCopy, [])    Expression(0, [])    Expression(length, [])  Statement(// be consumed., [])  Statement(try {, [])  MethodCall(item.put(bufferCopy), [VariableReference(item, []), Expression(bufferCopy, [])])    VariableReference(item, [])    Expression(bufferCopy, [])  Statement(} catch (InterruptedException ie) {, [])  Statement(return TextToSpeech.ERROR, [])  Statement(}, [])  MethodCall(mLogger.onEngineDataReceived(), [VariableReference(mLogger, []), Expression(, [])])    VariableReference(mLogger, [])    Expression(, [])  Statement(return TextToSpeech.SUCCESS, [])  Statement(}, [])",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,"1,2,4","1,2","1,2,3","1,2",The code change includes the following three types:,"2. Exception handling statement changed: In the late version, a `try-catch` block is added to handle the `InterruptedException` when calling `item.put(bufferCopy)`."
317,<android.view.inputmethod.BaseInputConnection: boolean finishComposingText()>,30,31,<android.view.inputmethod.BaseInputConnection: boolean finishComposingText()>,<android.view.inputmethod.BaseInputConnection: boolean finishComposingText()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(if (DEBUG), []), MethodCall(Log.v(TAG, ""finishComposingText""), [VariableReference(Log, []), Expression(TAG, []), Expression(""finishComposingText"", [])]), AssignmentExpression(=, [VariableReference(final Editable content, []), Expression(getEditable(), [])]), AssignmentExpression(=, [VariableReference(if (content !, []), Expression(null) {, [])]), Statement(beginBatchEdit(), []), Statement(removeComposingSpans(content), []), Statement(// Note: sendCurrentText does nothing unless mDummyMode is set, []), Statement(sendCurrentText(), []), Statement(endBatchEdit(), []), Statement(}, []), Statement(return true, []), Statement(}, [])])  Statement({, [])  Statement(if (DEBUG), [])  MethodCall(Log.v(TAG, ""finishComposingText""), [VariableReference(Log, []), Expression(TAG, []), Expression(""finishComposingText"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""finishComposingText"", [])  AssignmentExpression(=, [VariableReference(final Editable content, []), Expression(getEditable(), [])])    VariableReference(final Editable content, [])    Expression(getEditable(), [])  AssignmentExpression(=, [VariableReference(if (content !, []), Expression(null) {, [])])    VariableReference(if (content !, [])    Expression(null) {, [])  Statement(beginBatchEdit(), [])  Statement(removeComposingSpans(content), [])  Statement(// Note: sendCurrentText does nothing unless mDummyMode is set, [])  Statement(sendCurrentText(), [])  Statement(endBatchEdit(), [])  Statement(}, [])  Statement(return true, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (DEBUG), []), MethodCall(Log.v(TAG, ""finishComposingText""), [VariableReference(Log, []), Expression(TAG, []), Expression(""finishComposingText"", [])]), AssignmentExpression(=, [VariableReference(final Editable content, []), Expression(getEditable(), [])]), AssignmentExpression(=, [VariableReference(if (content !, []), Expression(null) {, [])]), Statement(beginBatchEdit(), []), Statement(removeComposingSpans(content), []), Statement(// Note: sendCurrentText does nothing unless mFallbackMode is set, []), Statement(sendCurrentText(), []), Statement(endBatchEdit(), []), Statement(endComposingRegionEditInternal(), []), Statement(}, []), Statement(return true, []), Statement(}, [])])  Statement({, [])  Statement(if (DEBUG), [])  MethodCall(Log.v(TAG, ""finishComposingText""), [VariableReference(Log, []), Expression(TAG, []), Expression(""finishComposingText"", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""finishComposingText"", [])  AssignmentExpression(=, [VariableReference(final Editable content, []), Expression(getEditable(), [])])    VariableReference(final Editable content, [])    Expression(getEditable(), [])  AssignmentExpression(=, [VariableReference(if (content !, []), Expression(null) {, [])])    VariableReference(if (content !, [])    Expression(null) {, [])  Statement(beginBatchEdit(), [])  Statement(removeComposingSpans(content), [])  Statement(// Note: sendCurrentText does nothing unless mFallbackMode is set, [])  Statement(sendCurrentText(), [])  Statement(endBatchEdit(), [])  Statement(endComposingRegionEditInternal(), [])  Statement(}, [])  Statement(return true, [])  Statement(}, [])",1,"/**
 * The default implementation removes the composing state from the
 * current editable text.  In addition, only if dummy mode, a key event is
 * sent for the new text and the current editable buffer cleared.
 */
","/**
 * The default implementation removes the composing state from the
 * current editable text.  In addition, only if fallback mode, a key event is
 * sent for the new text and the current editable buffer cleared.
 */
",-1,,,-1,-1,-1,-1,-1,4,0,5,1,"The code change is a new statement added in the late version: `endComposingRegionEditInternal()`. This new statement is not just a simple method call, but it is related to the internal implementation of the `BaseInputConnection` class. The `endComposingRegionEditInternal()` method is responsible for ending the composing region edit, which is related to the text being input by the user. Therefore, this new statement added in the late version could potentially cause the API to return a different value.","The Compatibility Issue is caused by the potential different return values. In the early version, the `finishComposingText()` method only removes the composing state from the current editable text, and returns `true`. However, in the late version, the `finishComposingText()` method not only removes the composing state, but also ends the composing region edit. This new internal implementation could potentially cause the API to return a different value, especially when there are errors or exceptions in the `endComposingRegionEditInternal()` method. For example, if the `endComposingRegionEditInternal()` method throws an exception, the `finishComposingText()` method will not be able to return `true`, which is different from the behavior in the early version."
650,"<android.view.View: boolean awakenScrollBars(int,boolean)>",22,23,"<android.view.View: boolean awakenScrollBars(int,boolean)>","<android.view.View: boolean awakenScrollBars(int,boolean)>",0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final ScrollabilityCache scrollCache, []), Expression(mScrollCache, [])]), AssignmentExpression(=, [VariableReference(if (scrollCache, []), Expression(, [])]), Statement(return false, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (scrollCache.scrollBar, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(scrollCache.scrollBar, []), Expression(new ScrollBarDrawable(), [])]), Statement(}, []), Statement(if (isHorizontalScrollBarEnabled() || isVerticalScrollBarEnabled()) {, []), Statement(if (invalidate) {, []), Statement(// Invalidate to show the scrollbars, []), Statement(postInvalidateOnAnimation(), []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (scrollCache.state, []), Expression(, [])]), Statement(// FIXME: this is copied from WindowManagerService., []), Statement(// We should get this value from the system when it, []), Statement(// is possible to do so., []), AssignmentExpression(=, [VariableReference(final int KEY_REPEAT_FIRST_DELAY, []), Expression(750, [])]), AssignmentExpression(=, [VariableReference(startDelay, []), Expression(Math.max(KEY_REPEAT_FIRST_DELAY, startDelay), [])]), Statement(}, []), Statement(// Tell mScrollCache when we should start fading. This may, []), Statement(// extend the fade start time if one was already scheduled, []), AssignmentExpression(=, [VariableReference(long fadeStartTime, []), Expression(AnimationUtils.currentAnimationTimeMillis() + startDelay, [])]), AssignmentExpression(=, [VariableReference(scrollCache.fadeStartTime, []), Expression(fadeStartTime, [])]), AssignmentExpression(=, [VariableReference(scrollCache.state, []), Expression(ScrollabilityCache.ON, [])]), Statement(// Schedule our fader to run, unscheduling any old ones first, []), AssignmentExpression(=, [VariableReference(if (mAttachInfo !, []), Expression(null) {, [])]), Statement(}, []), Statement(return true, []), Statement(}, []), Statement(return false, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final ScrollabilityCache scrollCache, []), Expression(mScrollCache, [])])    VariableReference(final ScrollabilityCache scrollCache, [])    Expression(mScrollCache, [])  AssignmentExpression(=, [VariableReference(if (scrollCache, []), Expression(, [])])    VariableReference(if (scrollCache, [])    Expression(, [])  Statement(return false, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (scrollCache.scrollBar, []), Expression(, [])])    VariableReference(if (scrollCache.scrollBar, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(scrollCache.scrollBar, []), Expression(new ScrollBarDrawable(), [])])    VariableReference(scrollCache.scrollBar, [])    Expression(new ScrollBarDrawable(), [])  Statement(}, [])  Statement(if (isHorizontalScrollBarEnabled() || isVerticalScrollBarEnabled()) {, [])  Statement(if (invalidate) {, [])  Statement(// Invalidate to show the scrollbars, [])  Statement(postInvalidateOnAnimation(), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (scrollCache.state, []), Expression(, [])])    VariableReference(if (scrollCache.state, [])    Expression(, [])  Statement(// FIXME: this is copied from WindowManagerService., [])  Statement(// We should get this value from the system when it, [])  Statement(// is possible to do so., [])  AssignmentExpression(=, [VariableReference(final int KEY_REPEAT_FIRST_DELAY, []), Expression(750, [])])    VariableReference(final int KEY_REPEAT_FIRST_DELAY, [])    Expression(750, [])  AssignmentExpression(=, [VariableReference(startDelay, []), Expression(Math.max(KEY_REPEAT_FIRST_DELAY, startDelay), [])])    VariableReference(startDelay, [])    Expression(Math.max(KEY_REPEAT_FIRST_DELAY, startDelay), [])  Statement(}, [])  Statement(// Tell mScrollCache when we should start fading. This may, [])  Statement(// extend the fade start time if one was already scheduled, [])  AssignmentExpression(=, [VariableReference(long fadeStartTime, []), Expression(AnimationUtils.currentAnimationTimeMillis() + startDelay, [])])    VariableReference(long fadeStartTime, [])    Expression(AnimationUtils.currentAnimationTimeMillis() + startDelay, [])  AssignmentExpression(=, [VariableReference(scrollCache.fadeStartTime, []), Expression(fadeStartTime, [])])    VariableReference(scrollCache.fadeStartTime, [])    Expression(fadeStartTime, [])  AssignmentExpression(=, [VariableReference(scrollCache.state, []), Expression(ScrollabilityCache.ON, [])])    VariableReference(scrollCache.state, [])    Expression(ScrollabilityCache.ON, [])  Statement(// Schedule our fader to run, unscheduling any old ones first, [])  AssignmentExpression(=, [VariableReference(if (mAttachInfo !, []), Expression(null) {, [])])    VariableReference(if (mAttachInfo !, [])    Expression(null) {, [])  Statement(}, [])  Statement(return true, [])  Statement(}, [])  Statement(return false, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(final ScrollabilityCache scrollCache, []), Expression(mScrollCache, [])]), AssignmentExpression(=, [VariableReference(if (scrollCache, []), Expression(, [])]), Statement(return false, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (scrollCache.scrollBar, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(scrollCache.scrollBar, []), Expression(new ScrollBarDrawable(), [])]), Statement(}, []), Statement(if (isHorizontalScrollBarEnabled() || isVerticalScrollBarEnabled()) {, []), Statement(if (invalidate) {, []), Statement(// Invalidate to show the scrollbars, []), Statement(postInvalidateOnAnimation(), []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (scrollCache.state, []), Expression(, [])]), Statement(// FIXME: this is copied from WindowManagerService., []), Statement(// We should get this value from the system when it, []), Statement(// is possible to do so., []), AssignmentExpression(=, [VariableReference(final int KEY_REPEAT_FIRST_DELAY, []), Expression(750, [])]), AssignmentExpression(=, [VariableReference(startDelay, []), Expression(Math.max(KEY_REPEAT_FIRST_DELAY, startDelay), [])]), Statement(}, []), Statement(// Tell mScrollCache when we should start fading. This may, []), Statement(// extend the fade start time if one was already scheduled, []), AssignmentExpression(=, [VariableReference(long fadeStartTime, []), Expression(AnimationUtils.currentAnimationTimeMillis() + startDelay, [])]), AssignmentExpression(=, [VariableReference(scrollCache.fadeStartTime, []), Expression(fadeStartTime, [])]), AssignmentExpression(=, [VariableReference(scrollCache.state, []), Expression(ScrollabilityCache.ON, [])]), Statement(// Schedule our fader to run, unscheduling any old ones first, []), AssignmentExpression(=, [VariableReference(if (mAttachInfo !, []), Expression(null) {, [])]), Statement(}, []), Statement(return true, []), Statement(}, []), Statement(return false, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(final ScrollabilityCache scrollCache, []), Expression(mScrollCache, [])])    VariableReference(final ScrollabilityCache scrollCache, [])    Expression(mScrollCache, [])  AssignmentExpression(=, [VariableReference(if (scrollCache, []), Expression(, [])])    VariableReference(if (scrollCache, [])    Expression(, [])  Statement(return false, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (scrollCache.scrollBar, []), Expression(, [])])    VariableReference(if (scrollCache.scrollBar, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(scrollCache.scrollBar, []), Expression(new ScrollBarDrawable(), [])])    VariableReference(scrollCache.scrollBar, [])    Expression(new ScrollBarDrawable(), [])  Statement(}, [])  Statement(if (isHorizontalScrollBarEnabled() || isVerticalScrollBarEnabled()) {, [])  Statement(if (invalidate) {, [])  Statement(// Invalidate to show the scrollbars, [])  Statement(postInvalidateOnAnimation(), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (scrollCache.state, []), Expression(, [])])    VariableReference(if (scrollCache.state, [])    Expression(, [])  Statement(// FIXME: this is copied from WindowManagerService., [])  Statement(// We should get this value from the system when it, [])  Statement(// is possible to do so., [])  AssignmentExpression(=, [VariableReference(final int KEY_REPEAT_FIRST_DELAY, []), Expression(750, [])])    VariableReference(final int KEY_REPEAT_FIRST_DELAY, [])    Expression(750, [])  AssignmentExpression(=, [VariableReference(startDelay, []), Expression(Math.max(KEY_REPEAT_FIRST_DELAY, startDelay), [])])    VariableReference(startDelay, [])    Expression(Math.max(KEY_REPEAT_FIRST_DELAY, startDelay), [])  Statement(}, [])  Statement(// Tell mScrollCache when we should start fading. This may, [])  Statement(// extend the fade start time if one was already scheduled, [])  AssignmentExpression(=, [VariableReference(long fadeStartTime, []), Expression(AnimationUtils.currentAnimationTimeMillis() + startDelay, [])])    VariableReference(long fadeStartTime, [])    Expression(AnimationUtils.currentAnimationTimeMillis() + startDelay, [])  AssignmentExpression(=, [VariableReference(scrollCache.fadeStartTime, []), Expression(fadeStartTime, [])])    VariableReference(scrollCache.fadeStartTime, [])    Expression(fadeStartTime, [])  AssignmentExpression(=, [VariableReference(scrollCache.state, []), Expression(ScrollabilityCache.ON, [])])    VariableReference(scrollCache.state, [])    Expression(ScrollabilityCache.ON, [])  Statement(// Schedule our fader to run, unscheduling any old ones first, [])  AssignmentExpression(=, [VariableReference(if (mAttachInfo !, []), Expression(null) {, [])])    VariableReference(if (mAttachInfo !, [])    Expression(null) {, [])  Statement(}, [])  Statement(return true, [])  Statement(}, [])  Statement(return false, [])  Statement(}, [])",1,"/**
 * <p>
 * Trigger the scrollbars to draw. When invoked this method starts an
 * animation to fade the scrollbars out after a fixed delay. If a subclass
 * provides animated scrolling, the start delay should equal the duration of
 * the scrolling animation.
 * </p>
 *
 * <p>
 * The animation starts only if at least one of the scrollbars is enabled,
 * as specified by {@link #isHorizontalScrollBarEnabled()} and
 * {@link #isVerticalScrollBarEnabled()}. When the animation is started,
 * this method returns true, and false otherwise. If the animation is
 * started, this method calls {@link #invalidate()} if the invalidate parameter
 * is set to true; in that case the caller
 * should not call {@link #invalidate()}.
 * </p>
 *
 * <p>
 * This method should be invoked everytime a subclass directly updates the
 * scroll parameters.
 * </p>
 *
 * @param startDelay the delay, in milliseconds, after which the animation
 * should start; when the delay is 0, the animation starts
 * immediately
 *
 * @param invalidate Wheter this method should call invalidate
 *
 * @return true if the animation is played, false otherwise
 *
 * @see #scrollBy(int, int)
 * @see #scrollTo(int, int)
 * @see #isHorizontalScrollBarEnabled()
 * @see #isVerticalScrollBarEnabled()
 * @see #setHorizontalScrollBarEnabled(boolean)
 * @see #setVerticalScrollBarEnabled(boolean)
 */
","/**
 * <p>
 * Trigger the scrollbars to draw. When invoked this method starts an
 * animation to fade the scrollbars out after a fixed delay. If a subclass
 * provides animated scrolling, the start delay should equal the duration of
 * the scrolling animation.
 * </p>
 *
 * <p>
 * The animation starts only if at least one of the scrollbars is enabled,
 * as specified by {@link #isHorizontalScrollBarEnabled()} and
 * {@link #isVerticalScrollBarEnabled()}. When the animation is started,
 * this method returns true, and false otherwise. If the animation is
 * started, this method calls {@link #invalidate()} if the invalidate parameter
 * is set to true; in that case the caller
 * should not call {@link #invalidate()}.
 * </p>
 *
 * <p>
 * This method should be invoked every time a subclass directly updates the
 * scroll parameters.
 * </p>
 *
 * @param startDelay the delay, in milliseconds, after which the animation
 * should start; when the delay is 0, the animation starts
 * immediately
 *
 * @param invalidate Whether this method should call invalidate
 *
 * @return true if the animation is played, false otherwise
 *
 * @see #scrollBy(int, int)
 * @see #scrollTo(int, int)
 * @see #isHorizontalScrollBarEnabled()
 * @see #isVerticalScrollBarEnabled()
 * @see #setHorizontalScrollBarEnabled(boolean)
 * @see #setVerticalScrollBarEnabled(boolean)
 */
",-1,,,-1,-1,-1,-1,-1,4,0,0,0,"There is no difference between the AST nodes of the two versions, therefore the change type is 0 (No change).","As there is no difference between the two versions, therefore there is no Compatibility Issue (CI) exist."
475,<android.preference.Preference: int compareTo(Preference)>,18,19,<android.preference.Preference: int compareTo(Preference)>,<android.preference.Preference: int compareTo(Preference)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mOrder !, []), Expression(DEFAULT_ORDER || (mOrder, [])]), Statement(// Do order comparison, []), Statement(return mOrder - another.mOrder, []), AssignmentExpression(=, [VariableReference(} else if (mTitle, []), Expression(, [])]), Statement(return 1, []), AssignmentExpression(=, [VariableReference(} else if (another.mTitle, []), Expression(, [])]), Statement(return -1, []), Statement(} else {, []), Statement(// Do name comparison, []), MethodCall(return CharSequences.compareToIgnoreCase(mTitle, another.mTitle), [VariableReference(return CharSequences, []), Expression(mTitle, []), Expression(another.mTitle, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mOrder !, []), Expression(DEFAULT_ORDER || (mOrder, [])])    VariableReference(if (mOrder !, [])    Expression(DEFAULT_ORDER || (mOrder, [])  Statement(// Do order comparison, [])  Statement(return mOrder - another.mOrder, [])  AssignmentExpression(=, [VariableReference(} else if (mTitle, []), Expression(, [])])    VariableReference(} else if (mTitle, [])    Expression(, [])  Statement(return 1, [])  AssignmentExpression(=, [VariableReference(} else if (another.mTitle, []), Expression(, [])])    VariableReference(} else if (another.mTitle, [])    Expression(, [])  Statement(return -1, [])  Statement(} else {, [])  Statement(// Do name comparison, [])  MethodCall(return CharSequences.compareToIgnoreCase(mTitle, another.mTitle), [VariableReference(return CharSequences, []), Expression(mTitle, []), Expression(another.mTitle, [])])    VariableReference(return CharSequences, [])    Expression(mTitle, [])    Expression(another.mTitle, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mOrder !, []), Expression(DEFAULT_ORDER || (mOrder, [])]), Statement(// Do order comparison, []), Statement(return mOrder - another.mOrder, []), AssignmentExpression(=, [VariableReference(} else if (mTitle, []), Expression(, [])]), Statement(// If titles are null or share same object comparison, []), Statement(return 0, []), AssignmentExpression(=, [VariableReference(} else if (mTitle, []), Expression(, [])]), Statement(return 1, []), AssignmentExpression(=, [VariableReference(} else if (another.mTitle, []), Expression(, [])]), Statement(return -1, []), Statement(} else {, []), Statement(// Do name comparison, []), MethodCall(return CharSequences.compareToIgnoreCase(mTitle, another.mTitle), [VariableReference(return CharSequences, []), Expression(mTitle, []), Expression(another.mTitle, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mOrder !, []), Expression(DEFAULT_ORDER || (mOrder, [])])    VariableReference(if (mOrder !, [])    Expression(DEFAULT_ORDER || (mOrder, [])  Statement(// Do order comparison, [])  Statement(return mOrder - another.mOrder, [])  AssignmentExpression(=, [VariableReference(} else if (mTitle, []), Expression(, [])])    VariableReference(} else if (mTitle, [])    Expression(, [])  Statement(// If titles are null or share same object comparison, [])  Statement(return 0, [])  AssignmentExpression(=, [VariableReference(} else if (mTitle, []), Expression(, [])])    VariableReference(} else if (mTitle, [])    Expression(, [])  Statement(return 1, [])  AssignmentExpression(=, [VariableReference(} else if (another.mTitle, []), Expression(, [])])    VariableReference(} else if (another.mTitle, [])    Expression(, [])  Statement(return -1, [])  Statement(} else {, [])  Statement(// Do name comparison, [])  MethodCall(return CharSequences.compareToIgnoreCase(mTitle, another.mTitle), [VariableReference(return CharSequences, []), Expression(mTitle, []), Expression(another.mTitle, [])])    VariableReference(return CharSequences, [])    Expression(mTitle, [])    Expression(another.mTitle, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Compares Preference objects based on order (if set), otherwise alphabetically on the titles.
 *
 * @param another The Preference to compare to this one.
 * @return 0 if the same; less than 0 if this Preference sorts ahead of <var>another</var>;
 * greater than 0 if this Preference sorts after <var>another</var>.
 */
","/**
 * Compares Preference objects based on order (if set), otherwise alphabetically on the titles.
 *
 * @param another The Preference to compare to this one.
 * @return 0 if the same; less than 0 if this Preference sorts ahead of <var>another</var>;
 * greater than 0 if this Preference sorts after <var>another</var>.
 */
",-1,,,-1,-1,-1,-1,-1,"1,3",1,"1,3,4",1,"The code change is a combination of return statement change, control dependency change, and other statement change. In the early version, if the `mTitle` of the current preference is null and the `mTitle` of the other preference is not null, the method will return -1. Similarly, if the `mTitle` of the other preference is null and the `mTitle` of the current preference is not null, the method will return 1. In the late version, if the `mTitle` of both preferences are null or they share the same object, the method will return 0. Also, in the late version, the comments ""// Do name comparison"" and ""// If titles are null or share same object comparison"" are added.","The compatibility issue is caused by potential different return values. In the early version, if the `mTitle` of the current preference is null and the `mTitle` of the other preference is not null, the method will return -1. However, in the late version, if the `mTitle` of the current preference is null and the `mTitle` of the other preference is not null but they share the same object, the method will return 0. This can lead to different behaviors in the application."
47,<android.text.PrecomputedText.Params.Builder: Params build()>,32,33,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(return new Params(mPaint, mTextDir, mBreakStrategy, mHyphenationFrequency), []), Statement(}, [])])  Statement({, [])  Statement(return new Params(mPaint, mTextDir, mBreakStrategy, mHyphenationFrequency), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return new Params(mPaint, mLineBreakConfig, mTextDir, mBreakStrategy, mHyphenationFrequency), []), Statement(}, [])])  Statement({, [])  Statement(return new Params(mPaint, mLineBreakConfig, mTextDir, mBreakStrategy, mHyphenationFrequency), [])  Statement(}, [])",1,"/**
 * Build the {@link Params}.
 *
 * @return the layout parameter
 */
","/**
 * Build the {@link Params}.
 *
 * @return the layout parameter
 */
",0,[@NonNull],[@NonNull],0,,,,,"1,5",1,1,1,"The early version's implementation returns `new Params(mPaint, mTextDir, mBreakStrategy, mHyphenationFrequency)` while the late version's implementation returns `new Params(mPaint, mLineBreakConfig, mTextDir, mBreakStrategy, mHyphenationFrequency)`. The difference in the arguments of the `Params` constructor indicates that the return value of the `build()` method might be different between the two versions.","Since the arguments of the `Params` constructor are different between the two versions, it is likely that the `Params` object created by the `build()` method might have different internal state and behave differently. Therefore, there is a compatibility issue caused by potential different return values or types."
1019,<android.webkit.WebSettings: String getDatabasePath()>,15,16,<android.webkit.WebSettings: String getDatabasePath()>,<android.webkit.WebSettings: String getDatabasePath()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(return mDatabasePath, []), Statement(}, [])])  Statement({, [])  Statement(return mDatabasePath, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(throw new MustOverrideException(), []), Statement(}, [])])  Statement({, [])  Statement(throw new MustOverrideException(), [])  Statement(}, [])",1,"/**
 * Return the path to where database storage API databases are saved for
 * the current WebView.
 * @return the String path to the database storage API databases.
 */
","/**
 * Gets the path to where database storage API databases are saved for
 * the current WebView.
 *
 * @return the String path to the database storage API databases
 */
",-1,,,-1,-1,-1,-1,-1,"1,2","1,2","1,2","1,2","The return statement in the early version of the API has been replaced by a throw statement in the late version. This change affects the potential behavior of the API, as it no longer returns a String path but instead throws an exception.","The code change has potential to cause Compatibility Issues of two types: 1) Compatibility Issue caused by potential different return values or types, as the API no longer returns a String but instead throws an exception; 2) Compatibility Issue caused by potential different exception handlings, as the API now throws a new exception that may not be handled by the existing code."
210,<android.hardware.camera2.legacy.LegacyCameraDevice: void finalize()>,23,24,<android.hardware.camera2.legacy.LegacyCameraDevice: void finalize()>,<android.hardware.camera2.legacy.LegacyCameraDevice: void finalize()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), Statement(close(), []), Statement(} catch (CameraRuntimeException e) {, []), MethodCall(Log.e(TAG, ""Got error while trying to finalize, ignoring: "" + e.getMessage()), [VariableReference(Log, []), Expression(TAG, []), Expression(""Got error while trying to finalize, []), Expression(ignoring: "" + e.getMessage(), [])]), Statement(} finally {, []), MethodCall(super.finalize(), [VariableReference(super, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  Statement(close(), [])  Statement(} catch (CameraRuntimeException e) {, [])  MethodCall(Log.e(TAG, ""Got error while trying to finalize, ignoring: "" + e.getMessage()), [VariableReference(Log, []), Expression(TAG, []), Expression(""Got error while trying to finalize, []), Expression(ignoring: "" + e.getMessage(), [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Got error while trying to finalize, [])    Expression(ignoring: "" + e.getMessage(), [])  Statement(} finally {, [])  MethodCall(super.finalize(), [VariableReference(super, []), Expression(, [])])    VariableReference(super, [])    Expression(, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), Statement(close(), []), Statement(} catch (ServiceSpecificException e) {, []), MethodCall(Log.e(TAG, ""Got error while trying to finalize, ignoring: "" + e.getMessage()), [VariableReference(Log, []), Expression(TAG, []), Expression(""Got error while trying to finalize, []), Expression(ignoring: "" + e.getMessage(), [])]), Statement(} finally {, []), MethodCall(super.finalize(), [VariableReference(super, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  Statement(close(), [])  Statement(} catch (ServiceSpecificException e) {, [])  MethodCall(Log.e(TAG, ""Got error while trying to finalize, ignoring: "" + e.getMessage()), [VariableReference(Log, []), Expression(TAG, []), Expression(""Got error while trying to finalize, []), Expression(ignoring: "" + e.getMessage(), [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Got error while trying to finalize, [])    Expression(ignoring: "" + e.getMessage(), [])  Statement(} finally {, [])  MethodCall(super.finalize(), [VariableReference(super, []), Expression(, [])])    VariableReference(super, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,"2,4",2,2,2,"The code change is that the catch block has been modified. Specifically, the exception being caught has changed from ""CameraRuntimeException"" to ""ServiceSpecificException"".","This change can lead to a compatibility issue. In the early version, if any other type of exception (other than CameraRuntimeException) is thrown during the execution of the try block, it will not be caught and will propagate up the call stack. However, in the late version, the catch block will catch ServiceSpecificException, which could potentially be a different type of exception that was not intended to be caught. This can lead to unexpected behavior and make it harder to debug errors."
849,<android.widget.NumberPicker: void onDraw(Canvas)>,15,16,<android.widget.NumberPicker: void onDraw(Canvas)>,<android.widget.NumberPicker: void onDraw(Canvas)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mSelectorWheelState, []), Expression(, [])]), Statement(return, []), Statement(}, []), AssignmentExpression(=, [VariableReference(float x, []), Expression((mRight - mLeft) / 2, [])]), AssignmentExpression(=, [VariableReference(float y, []), Expression(mCurrentScrollOffset, [])]), AssignmentExpression(=, [VariableReference(final int restoreCount, []), Expression(canvas.save(), [])]), AssignmentExpression(=, [VariableReference(if (mSelectorWheelState, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(Rect clipBounds, []), Expression(canvas.getClipBounds(), [])]), MethodCall(clipBounds.inset(0, mSelectorElementHeight), [VariableReference(clipBounds, []), Expression(0, []), Expression(mSelectorElementHeight, [])]), MethodCall(canvas.clipRect(clipBounds), [VariableReference(canvas, []), Expression(clipBounds, [])]), Statement(}, []), Statement(// draw the selector wheel, []), AssignmentExpression(=, [VariableReference(int[] selectorIndices, []), Expression(mSelectorIndices, [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < selectorIndices.length, []), Statement(i++) {, []), AssignmentExpression(=, [VariableReference(int selectorIndex, []), Expression(selectorIndices[i], [])]), AssignmentExpression(=, [VariableReference(String scrollSelectorValue, []), Expression(mSelectorIndexToStringCache.get(selectorIndex), [])]), Statement(// value intermixed with the new one., []), AssignmentExpression(=, [VariableReference(if (i !, []), Expression(SELECTOR_MIDDLE_ITEM_INDEX || mInputText.getVisibility() !, [])]), MethodCall(canvas.drawText(scrollSelectorValue, x, y, mSelectorWheelPaint), [VariableReference(canvas, []), Expression(scrollSelectorValue, []), Expression(x, []), Expression(y, []), Expression(mSelectorWheelPaint, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(y +, []), Expression(mSelectorElementHeight, [])]), Statement(}, []), Statement(// draw the selection dividers (only if scrolling and drawable specified), []), AssignmentExpression(=, [VariableReference(if (mSelectionDivider !, []), Expression(null) {, [])]), Statement(// draw the top divider, []), AssignmentExpression(=, [VariableReference(int topOfTopDivider, []), Expression((getHeight() - mSelectorElementHeight - mSelectionDividerHeight) / 2, [])]), AssignmentExpression(=, [VariableReference(int bottomOfTopDivider, []), Expression(topOfTopDivider + mSelectionDividerHeight, [])]), MethodCall(mSelectionDivider.setBounds(0, topOfTopDivider, mRight, bottomOfTopDivider), [VariableReference(mSelectionDivider, []), Expression(0, []), Expression(topOfTopDivider, []), Expression(mRight, []), Expression(bottomOfTopDivider, [])]), MethodCall(mSelectionDivider.draw(canvas), [VariableReference(mSelectionDivider, []), Expression(canvas, [])]), Statement(// draw the bottom divider, []), AssignmentExpression(=, [VariableReference(int topOfBottomDivider, []), Expression(topOfTopDivider + mSelectorElementHeight, [])]), AssignmentExpression(=, [VariableReference(int bottomOfBottomDivider, []), Expression(bottomOfTopDivider + mSelectorElementHeight, [])]), MethodCall(mSelectionDivider.setBounds(0, topOfBottomDivider, mRight, bottomOfBottomDivider), [VariableReference(mSelectionDivider, []), Expression(0, []), Expression(topOfBottomDivider, []), Expression(mRight, []), Expression(bottomOfBottomDivider, [])]), MethodCall(mSelectionDivider.draw(canvas), [VariableReference(mSelectionDivider, []), Expression(canvas, [])]), Statement(}, []), MethodCall(canvas.restoreToCount(restoreCount), [VariableReference(canvas, []), Expression(restoreCount, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mSelectorWheelState, []), Expression(, [])])    VariableReference(if (mSelectorWheelState, [])    Expression(, [])  Statement(return, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(float x, []), Expression((mRight - mLeft) / 2, [])])    VariableReference(float x, [])    Expression((mRight - mLeft) / 2, [])  AssignmentExpression(=, [VariableReference(float y, []), Expression(mCurrentScrollOffset, [])])    VariableReference(float y, [])    Expression(mCurrentScrollOffset, [])  AssignmentExpression(=, [VariableReference(final int restoreCount, []), Expression(canvas.save(), [])])    VariableReference(final int restoreCount, [])    Expression(canvas.save(), [])  AssignmentExpression(=, [VariableReference(if (mSelectorWheelState, []), Expression(, [])])    VariableReference(if (mSelectorWheelState, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(Rect clipBounds, []), Expression(canvas.getClipBounds(), [])])    VariableReference(Rect clipBounds, [])    Expression(canvas.getClipBounds(), [])  MethodCall(clipBounds.inset(0, mSelectorElementHeight), [VariableReference(clipBounds, []), Expression(0, []), Expression(mSelectorElementHeight, [])])    VariableReference(clipBounds, [])    Expression(0, [])    Expression(mSelectorElementHeight, [])  MethodCall(canvas.clipRect(clipBounds), [VariableReference(canvas, []), Expression(clipBounds, [])])    VariableReference(canvas, [])    Expression(clipBounds, [])  Statement(}, [])  Statement(// draw the selector wheel, [])  AssignmentExpression(=, [VariableReference(int[] selectorIndices, []), Expression(mSelectorIndices, [])])    VariableReference(int[] selectorIndices, [])    Expression(mSelectorIndices, [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < selectorIndices.length, [])  Statement(i++) {, [])  AssignmentExpression(=, [VariableReference(int selectorIndex, []), Expression(selectorIndices[i], [])])    VariableReference(int selectorIndex, [])    Expression(selectorIndices[i], [])  AssignmentExpression(=, [VariableReference(String scrollSelectorValue, []), Expression(mSelectorIndexToStringCache.get(selectorIndex), [])])    VariableReference(String scrollSelectorValue, [])    Expression(mSelectorIndexToStringCache.get(selectorIndex), [])  Statement(// value intermixed with the new one., [])  AssignmentExpression(=, [VariableReference(if (i !, []), Expression(SELECTOR_MIDDLE_ITEM_INDEX || mInputText.getVisibility() !, [])])    VariableReference(if (i !, [])    Expression(SELECTOR_MIDDLE_ITEM_INDEX || mInputText.getVisibility() !, [])  MethodCall(canvas.drawText(scrollSelectorValue, x, y, mSelectorWheelPaint), [VariableReference(canvas, []), Expression(scrollSelectorValue, []), Expression(x, []), Expression(y, []), Expression(mSelectorWheelPaint, [])])    VariableReference(canvas, [])    Expression(scrollSelectorValue, [])    Expression(x, [])    Expression(y, [])    Expression(mSelectorWheelPaint, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(y +, []), Expression(mSelectorElementHeight, [])])    VariableReference(y +, [])    Expression(mSelectorElementHeight, [])  Statement(}, [])  Statement(// draw the selection dividers (only if scrolling and drawable specified), [])  AssignmentExpression(=, [VariableReference(if (mSelectionDivider !, []), Expression(null) {, [])])    VariableReference(if (mSelectionDivider !, [])    Expression(null) {, [])  Statement(// draw the top divider, [])  AssignmentExpression(=, [VariableReference(int topOfTopDivider, []), Expression((getHeight() - mSelectorElementHeight - mSelectionDividerHeight) / 2, [])])    VariableReference(int topOfTopDivider, [])    Expression((getHeight() - mSelectorElementHeight - mSelectionDividerHeight) / 2, [])  AssignmentExpression(=, [VariableReference(int bottomOfTopDivider, []), Expression(topOfTopDivider + mSelectionDividerHeight, [])])    VariableReference(int bottomOfTopDivider, [])    Expression(topOfTopDivider + mSelectionDividerHeight, [])  MethodCall(mSelectionDivider.setBounds(0, topOfTopDivider, mRight, bottomOfTopDivider), [VariableReference(mSelectionDivider, []), Expression(0, []), Expression(topOfTopDivider, []), Expression(mRight, []), Expression(bottomOfTopDivider, [])])    VariableReference(mSelectionDivider, [])    Expression(0, [])    Expression(topOfTopDivider, [])    Expression(mRight, [])    Expression(bottomOfTopDivider, [])  MethodCall(mSelectionDivider.draw(canvas), [VariableReference(mSelectionDivider, []), Expression(canvas, [])])    VariableReference(mSelectionDivider, [])    Expression(canvas, [])  Statement(// draw the bottom divider, [])  AssignmentExpression(=, [VariableReference(int topOfBottomDivider, []), Expression(topOfTopDivider + mSelectorElementHeight, [])])    VariableReference(int topOfBottomDivider, [])    Expression(topOfTopDivider + mSelectorElementHeight, [])  AssignmentExpression(=, [VariableReference(int bottomOfBottomDivider, []), Expression(bottomOfTopDivider + mSelectorElementHeight, [])])    VariableReference(int bottomOfBottomDivider, [])    Expression(bottomOfTopDivider + mSelectorElementHeight, [])  MethodCall(mSelectionDivider.setBounds(0, topOfBottomDivider, mRight, bottomOfBottomDivider), [VariableReference(mSelectionDivider, []), Expression(0, []), Expression(topOfBottomDivider, []), Expression(mRight, []), Expression(bottomOfBottomDivider, [])])    VariableReference(mSelectionDivider, [])    Expression(0, [])    Expression(topOfBottomDivider, [])    Expression(mRight, [])    Expression(bottomOfBottomDivider, [])  MethodCall(mSelectionDivider.draw(canvas), [VariableReference(mSelectionDivider, []), Expression(canvas, [])])    VariableReference(mSelectionDivider, [])    Expression(canvas, [])  Statement(}, [])  MethodCall(canvas.restoreToCount(restoreCount), [VariableReference(canvas, []), Expression(restoreCount, [])])    VariableReference(canvas, [])    Expression(restoreCount, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (!mHasSelectorWheel) {, []), MethodCall(super.onDraw(canvas), [VariableReference(super, []), Expression(canvas, [])]), Statement(return, []), Statement(}, []), AssignmentExpression(=, [VariableReference(float x, []), Expression((mRight - mLeft) / 2, [])]), AssignmentExpression(=, [VariableReference(float y, []), Expression(mCurrentScrollOffset, [])]), Statement(// draw the virtual buttons pressed state if needed, []), AssignmentExpression(=, [VariableReference(if (mVirtualButtonPressedDrawable !, []), Expression(null && mScrollState, [])]), Statement(if (mDecrementVirtualButtonPressed) {, []), MethodCall(mVirtualButtonPressedDrawable.setState(PRESSED_STATE_SET), [VariableReference(mVirtualButtonPressedDrawable, []), Expression(PRESSED_STATE_SET, [])]), MethodCall(mVirtualButtonPressedDrawable.setBounds(0, 0, mRight, mTopSelectionDividerTop), [VariableReference(mVirtualButtonPressedDrawable, []), Expression(0, []), Expression(0, []), Expression(mRight, []), Expression(mTopSelectionDividerTop, [])]), MethodCall(mVirtualButtonPressedDrawable.draw(canvas), [VariableReference(mVirtualButtonPressedDrawable, []), Expression(canvas, [])]), Statement(}, []), Statement(if (mIncrementVirtualButtonPressed) {, []), MethodCall(mVirtualButtonPressedDrawable.setState(PRESSED_STATE_SET), [VariableReference(mVirtualButtonPressedDrawable, []), Expression(PRESSED_STATE_SET, [])]), MethodCall(mVirtualButtonPressedDrawable.setBounds(0, mBottomSelectionDividerBottom, mRight, mBottom), [VariableReference(mVirtualButtonPressedDrawable, []), Expression(0, []), Expression(mBottomSelectionDividerBottom, []), Expression(mRight, []), Expression(mBottom, [])]), MethodCall(mVirtualButtonPressedDrawable.draw(canvas), [VariableReference(mVirtualButtonPressedDrawable, []), Expression(canvas, [])]), Statement(}, []), Statement(}, []), Statement(// draw the selector wheel, []), AssignmentExpression(=, [VariableReference(int[] selectorIndices, []), Expression(mSelectorIndices, [])]), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < selectorIndices.length, []), Statement(i++) {, []), AssignmentExpression(=, [VariableReference(int selectorIndex, []), Expression(selectorIndices[i], [])]), AssignmentExpression(=, [VariableReference(String scrollSelectorValue, []), Expression(mSelectorIndexToStringCache.get(selectorIndex), [])]), Statement(// with the new one., []), AssignmentExpression(=, [VariableReference(if (i !, []), Expression(SELECTOR_MIDDLE_ITEM_INDEX || mInputText.getVisibility() !, [])]), MethodCall(canvas.drawText(scrollSelectorValue, x, y, mSelectorWheelPaint), [VariableReference(canvas, []), Expression(scrollSelectorValue, []), Expression(x, []), Expression(y, []), Expression(mSelectorWheelPaint, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(y +, []), Expression(mSelectorElementHeight, [])]), Statement(}, []), Statement(// draw the selection dividers, []), AssignmentExpression(=, [VariableReference(if (mSelectionDivider !, []), Expression(null) {, [])]), Statement(// draw the top divider, []), AssignmentExpression(=, [VariableReference(int topOfTopDivider, []), Expression(mTopSelectionDividerTop, [])]), AssignmentExpression(=, [VariableReference(int bottomOfTopDivider, []), Expression(topOfTopDivider + mSelectionDividerHeight, [])]), MethodCall(mSelectionDivider.setBounds(0, topOfTopDivider, mRight, bottomOfTopDivider), [VariableReference(mSelectionDivider, []), Expression(0, []), Expression(topOfTopDivider, []), Expression(mRight, []), Expression(bottomOfTopDivider, [])]), MethodCall(mSelectionDivider.draw(canvas), [VariableReference(mSelectionDivider, []), Expression(canvas, [])]), Statement(// draw the bottom divider, []), AssignmentExpression(=, [VariableReference(int bottomOfBottomDivider, []), Expression(mBottomSelectionDividerBottom, [])]), AssignmentExpression(=, [VariableReference(int topOfBottomDivider, []), Expression(bottomOfBottomDivider - mSelectionDividerHeight, [])]), MethodCall(mSelectionDivider.setBounds(0, topOfBottomDivider, mRight, bottomOfBottomDivider), [VariableReference(mSelectionDivider, []), Expression(0, []), Expression(topOfBottomDivider, []), Expression(mRight, []), Expression(bottomOfBottomDivider, [])]), MethodCall(mSelectionDivider.draw(canvas), [VariableReference(mSelectionDivider, []), Expression(canvas, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(if (!mHasSelectorWheel) {, [])  MethodCall(super.onDraw(canvas), [VariableReference(super, []), Expression(canvas, [])])    VariableReference(super, [])    Expression(canvas, [])  Statement(return, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(float x, []), Expression((mRight - mLeft) / 2, [])])    VariableReference(float x, [])    Expression((mRight - mLeft) / 2, [])  AssignmentExpression(=, [VariableReference(float y, []), Expression(mCurrentScrollOffset, [])])    VariableReference(float y, [])    Expression(mCurrentScrollOffset, [])  Statement(// draw the virtual buttons pressed state if needed, [])  AssignmentExpression(=, [VariableReference(if (mVirtualButtonPressedDrawable !, []), Expression(null && mScrollState, [])])    VariableReference(if (mVirtualButtonPressedDrawable !, [])    Expression(null && mScrollState, [])  Statement(if (mDecrementVirtualButtonPressed) {, [])  MethodCall(mVirtualButtonPressedDrawable.setState(PRESSED_STATE_SET), [VariableReference(mVirtualButtonPressedDrawable, []), Expression(PRESSED_STATE_SET, [])])    VariableReference(mVirtualButtonPressedDrawable, [])    Expression(PRESSED_STATE_SET, [])  MethodCall(mVirtualButtonPressedDrawable.setBounds(0, 0, mRight, mTopSelectionDividerTop), [VariableReference(mVirtualButtonPressedDrawable, []), Expression(0, []), Expression(0, []), Expression(mRight, []), Expression(mTopSelectionDividerTop, [])])    VariableReference(mVirtualButtonPressedDrawable, [])    Expression(0, [])    Expression(0, [])    Expression(mRight, [])    Expression(mTopSelectionDividerTop, [])  MethodCall(mVirtualButtonPressedDrawable.draw(canvas), [VariableReference(mVirtualButtonPressedDrawable, []), Expression(canvas, [])])    VariableReference(mVirtualButtonPressedDrawable, [])    Expression(canvas, [])  Statement(}, [])  Statement(if (mIncrementVirtualButtonPressed) {, [])  MethodCall(mVirtualButtonPressedDrawable.setState(PRESSED_STATE_SET), [VariableReference(mVirtualButtonPressedDrawable, []), Expression(PRESSED_STATE_SET, [])])    VariableReference(mVirtualButtonPressedDrawable, [])    Expression(PRESSED_STATE_SET, [])  MethodCall(mVirtualButtonPressedDrawable.setBounds(0, mBottomSelectionDividerBottom, mRight, mBottom), [VariableReference(mVirtualButtonPressedDrawable, []), Expression(0, []), Expression(mBottomSelectionDividerBottom, []), Expression(mRight, []), Expression(mBottom, [])])    VariableReference(mVirtualButtonPressedDrawable, [])    Expression(0, [])    Expression(mBottomSelectionDividerBottom, [])    Expression(mRight, [])    Expression(mBottom, [])  MethodCall(mVirtualButtonPressedDrawable.draw(canvas), [VariableReference(mVirtualButtonPressedDrawable, []), Expression(canvas, [])])    VariableReference(mVirtualButtonPressedDrawable, [])    Expression(canvas, [])  Statement(}, [])  Statement(}, [])  Statement(// draw the selector wheel, [])  AssignmentExpression(=, [VariableReference(int[] selectorIndices, []), Expression(mSelectorIndices, [])])    VariableReference(int[] selectorIndices, [])    Expression(mSelectorIndices, [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < selectorIndices.length, [])  Statement(i++) {, [])  AssignmentExpression(=, [VariableReference(int selectorIndex, []), Expression(selectorIndices[i], [])])    VariableReference(int selectorIndex, [])    Expression(selectorIndices[i], [])  AssignmentExpression(=, [VariableReference(String scrollSelectorValue, []), Expression(mSelectorIndexToStringCache.get(selectorIndex), [])])    VariableReference(String scrollSelectorValue, [])    Expression(mSelectorIndexToStringCache.get(selectorIndex), [])  Statement(// with the new one., [])  AssignmentExpression(=, [VariableReference(if (i !, []), Expression(SELECTOR_MIDDLE_ITEM_INDEX || mInputText.getVisibility() !, [])])    VariableReference(if (i !, [])    Expression(SELECTOR_MIDDLE_ITEM_INDEX || mInputText.getVisibility() !, [])  MethodCall(canvas.drawText(scrollSelectorValue, x, y, mSelectorWheelPaint), [VariableReference(canvas, []), Expression(scrollSelectorValue, []), Expression(x, []), Expression(y, []), Expression(mSelectorWheelPaint, [])])    VariableReference(canvas, [])    Expression(scrollSelectorValue, [])    Expression(x, [])    Expression(y, [])    Expression(mSelectorWheelPaint, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(y +, []), Expression(mSelectorElementHeight, [])])    VariableReference(y +, [])    Expression(mSelectorElementHeight, [])  Statement(}, [])  Statement(// draw the selection dividers, [])  AssignmentExpression(=, [VariableReference(if (mSelectionDivider !, []), Expression(null) {, [])])    VariableReference(if (mSelectionDivider !, [])    Expression(null) {, [])  Statement(// draw the top divider, [])  AssignmentExpression(=, [VariableReference(int topOfTopDivider, []), Expression(mTopSelectionDividerTop, [])])    VariableReference(int topOfTopDivider, [])    Expression(mTopSelectionDividerTop, [])  AssignmentExpression(=, [VariableReference(int bottomOfTopDivider, []), Expression(topOfTopDivider + mSelectionDividerHeight, [])])    VariableReference(int bottomOfTopDivider, [])    Expression(topOfTopDivider + mSelectionDividerHeight, [])  MethodCall(mSelectionDivider.setBounds(0, topOfTopDivider, mRight, bottomOfTopDivider), [VariableReference(mSelectionDivider, []), Expression(0, []), Expression(topOfTopDivider, []), Expression(mRight, []), Expression(bottomOfTopDivider, [])])    VariableReference(mSelectionDivider, [])    Expression(0, [])    Expression(topOfTopDivider, [])    Expression(mRight, [])    Expression(bottomOfTopDivider, [])  MethodCall(mSelectionDivider.draw(canvas), [VariableReference(mSelectionDivider, []), Expression(canvas, [])])    VariableReference(mSelectionDivider, [])    Expression(canvas, [])  Statement(// draw the bottom divider, [])  AssignmentExpression(=, [VariableReference(int bottomOfBottomDivider, []), Expression(mBottomSelectionDividerBottom, [])])    VariableReference(int bottomOfBottomDivider, [])    Expression(mBottomSelectionDividerBottom, [])  AssignmentExpression(=, [VariableReference(int topOfBottomDivider, []), Expression(bottomOfBottomDivider - mSelectionDividerHeight, [])])    VariableReference(int topOfBottomDivider, [])    Expression(bottomOfBottomDivider - mSelectionDividerHeight, [])  MethodCall(mSelectionDivider.setBounds(0, topOfBottomDivider, mRight, bottomOfBottomDivider), [VariableReference(mSelectionDivider, []), Expression(0, []), Expression(topOfBottomDivider, []), Expression(mRight, []), Expression(bottomOfBottomDivider, [])])    VariableReference(mSelectionDivider, [])    Expression(0, [])    Expression(topOfBottomDivider, [])    Expression(mRight, [])    Expression(bottomOfBottomDivider, [])  MethodCall(mSelectionDivider.draw(canvas), [VariableReference(mSelectionDivider, []), Expression(canvas, [])])    VariableReference(mSelectionDivider, [])    Expression(canvas, [])  Statement(}, [])  Statement(}, [])",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,"3,4",0,"3,5","1,2",The implementation of the API has been changed significantly from early version to late version. The changes include:,3. The late version has a new dependent API `mVirtualButtonPressedDrawable.setState(PRESSED_STATE_SET)`.
1109,<android.hardware.camera2.legacy.CameraDeviceUserShim: int createStream(OutputConfiguration)>,23,24,<android.hardware.camera2.legacy.CameraDeviceUserShim: int createStream(OutputConfiguration)>,<android.hardware.camera2.legacy.CameraDeviceUserShim: int createStream(OutputConfiguration)>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(if (DEBUG) {, []), MethodCall(Log.d(TAG, ""createStream called.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""createStream called."", [])]), Statement(}, []), MethodCall(if (mLegacyDevice.isClosed()), [VariableReference(if (mLegacyDevice, []), Expression(), [])]), MethodCall(Log.e(TAG, ""Cannot create stream, device has been closed.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Cannot create stream, []), Expression(device has been closed."", [])]), Statement(return CameraBinderDecorator.ENODEV, []), Statement(}, []), Statement(synchronized (mConfigureLock) {, []), Statement(if (!mConfiguring) {, []), MethodCall(Log.e(TAG, ""Cannot create stream, beginConfigure hasn't been called yet.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Cannot create stream, []), Expression(beginConfigure hasn't been called yet."", [])]), Statement(return CameraBinderDecorator.INVALID_OPERATION, []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (outputConfiguration.getRotation() !, []), Expression(OutputConfiguration.ROTATION_0) {, [])]), MethodCall(Log.e(TAG, ""Cannot create stream, stream rotation is not supported.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Cannot create stream, []), Expression(stream rotation is not supported."", [])]), Statement(return CameraBinderDecorator.INVALID_OPERATION, []), Statement(}, []), AssignmentExpression(=, [VariableReference(int id, []), Expression(++mSurfaceIdCounter, [])]), MethodCall(mSurfaces.put(id, outputConfiguration.getSurface()), [VariableReference(mSurfaces, []), Expression(id, []), Expression(outputConfiguration.getSurface(), [])]), Statement(return id, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(if (DEBUG) {, [])  MethodCall(Log.d(TAG, ""createStream called.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""createStream called."", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""createStream called."", [])  Statement(}, [])  MethodCall(if (mLegacyDevice.isClosed()), [VariableReference(if (mLegacyDevice, []), Expression(), [])])    VariableReference(if (mLegacyDevice, [])    Expression(), [])  MethodCall(Log.e(TAG, ""Cannot create stream, device has been closed.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Cannot create stream, []), Expression(device has been closed."", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Cannot create stream, [])    Expression(device has been closed."", [])  Statement(return CameraBinderDecorator.ENODEV, [])  Statement(}, [])  Statement(synchronized (mConfigureLock) {, [])  Statement(if (!mConfiguring) {, [])  MethodCall(Log.e(TAG, ""Cannot create stream, beginConfigure hasn't been called yet.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Cannot create stream, []), Expression(beginConfigure hasn't been called yet."", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Cannot create stream, [])    Expression(beginConfigure hasn't been called yet."", [])  Statement(return CameraBinderDecorator.INVALID_OPERATION, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (outputConfiguration.getRotation() !, []), Expression(OutputConfiguration.ROTATION_0) {, [])])    VariableReference(if (outputConfiguration.getRotation() !, [])    Expression(OutputConfiguration.ROTATION_0) {, [])  MethodCall(Log.e(TAG, ""Cannot create stream, stream rotation is not supported.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""Cannot create stream, []), Expression(stream rotation is not supported."", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""Cannot create stream, [])    Expression(stream rotation is not supported."", [])  Statement(return CameraBinderDecorator.INVALID_OPERATION, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(int id, []), Expression(++mSurfaceIdCounter, [])])    VariableReference(int id, [])    Expression(++mSurfaceIdCounter, [])  MethodCall(mSurfaces.put(id, outputConfiguration.getSurface()), [VariableReference(mSurfaces, []), Expression(id, []), Expression(outputConfiguration.getSurface(), [])])    VariableReference(mSurfaces, [])    Expression(id, [])    Expression(outputConfiguration.getSurface(), [])  Statement(return id, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (DEBUG) {, []), MethodCall(Log.d(TAG, ""createStream called.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""createStream called."", [])]), Statement(}, []), MethodCall(if (mLegacyDevice.isClosed()), [VariableReference(if (mLegacyDevice, []), Expression(), [])]), AssignmentExpression(=, [VariableReference(String err, []), Expression(""Cannot create stream, device has been closed."", [])]), MethodCall(Log.e(TAG, err), [VariableReference(Log, []), Expression(TAG, []), Expression(err, [])]), Statement(}, []), Statement(synchronized (mConfigureLock) {, []), Statement(if (!mConfiguring) {, []), AssignmentExpression(=, [VariableReference(String err, []), Expression(""Cannot create stream, beginConfigure hasn't been called yet."", [])]), MethodCall(Log.e(TAG, err), [VariableReference(Log, []), Expression(TAG, []), Expression(err, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(if (outputConfiguration.getRotation() !, []), Expression(OutputConfiguration.ROTATION_0) {, [])]), AssignmentExpression(=, [VariableReference(String err, []), Expression(""Cannot create stream, stream rotation is not supported."", [])]), MethodCall(Log.e(TAG, err), [VariableReference(Log, []), Expression(TAG, []), Expression(err, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(int id, []), Expression(++mSurfaceIdCounter, [])]), MethodCall(mSurfaces.put(id, outputConfiguration.getSurface()), [VariableReference(mSurfaces, []), Expression(id, []), Expression(outputConfiguration.getSurface(), [])]), Statement(return id, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(if (DEBUG) {, [])  MethodCall(Log.d(TAG, ""createStream called.""), [VariableReference(Log, []), Expression(TAG, []), Expression(""createStream called."", [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(""createStream called."", [])  Statement(}, [])  MethodCall(if (mLegacyDevice.isClosed()), [VariableReference(if (mLegacyDevice, []), Expression(), [])])    VariableReference(if (mLegacyDevice, [])    Expression(), [])  AssignmentExpression(=, [VariableReference(String err, []), Expression(""Cannot create stream, device has been closed."", [])])    VariableReference(String err, [])    Expression(""Cannot create stream, device has been closed."", [])  MethodCall(Log.e(TAG, err), [VariableReference(Log, []), Expression(TAG, []), Expression(err, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(err, [])  Statement(}, [])  Statement(synchronized (mConfigureLock) {, [])  Statement(if (!mConfiguring) {, [])  AssignmentExpression(=, [VariableReference(String err, []), Expression(""Cannot create stream, beginConfigure hasn't been called yet."", [])])    VariableReference(String err, [])    Expression(""Cannot create stream, beginConfigure hasn't been called yet."", [])  MethodCall(Log.e(TAG, err), [VariableReference(Log, []), Expression(TAG, []), Expression(err, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(err, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (outputConfiguration.getRotation() !, []), Expression(OutputConfiguration.ROTATION_0) {, [])])    VariableReference(if (outputConfiguration.getRotation() !, [])    Expression(OutputConfiguration.ROTATION_0) {, [])  AssignmentExpression(=, [VariableReference(String err, []), Expression(""Cannot create stream, stream rotation is not supported."", [])])    VariableReference(String err, [])    Expression(""Cannot create stream, stream rotation is not supported."", [])  MethodCall(Log.e(TAG, err), [VariableReference(Log, []), Expression(TAG, []), Expression(err, [])])    VariableReference(Log, [])    Expression(TAG, [])    Expression(err, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(int id, []), Expression(++mSurfaceIdCounter, [])])    VariableReference(int id, [])    Expression(++mSurfaceIdCounter, [])  MethodCall(mSurfaces.put(id, outputConfiguration.getSurface()), [VariableReference(mSurfaces, []), Expression(id, []), Expression(outputConfiguration.getSurface(), [])])    VariableReference(mSurfaces, [])    Expression(id, [])    Expression(outputConfiguration.getSurface(), [])  Statement(return id, [])  Statement(}, [])  Statement(}, [])",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,"1,2,4","1,2",4,1,"The code change between the two versions is that the return statement `return CameraBinderDecorator.ENODEV` and `return CameraBinderDecorator.INVALID_OPERATION` in the early version have been replaced with the assignment statement `String err = ""Cannot create stream, device has been closed.""` and `String err = ""Cannot create stream, beginConfigure hasn't been called yet.""` in the late version, respectively. This change potentially leads to different return values in the two versions, as the early version returns the error code while the late version only assigns the error message to a variable without returning it.","The Compatibility Issue (CI) exists due to the potential different return values caused by the code change. In the early version, the error code (`CameraBinderDecorator.ENODEV` or `CameraBinderDecorator.INVALID_OPERATION`) is returned, which can be used by the calling code to handle the error. However, in the late version, the error message is only assigned to a variable without returning it, which may cause the calling code to fail to handle the error properly, resulting in unexpected behavior or crashes."
1148,<android.view.TextureView: HardwareLayer getHardwareLayer()>,20,21,<android.view.TextureView: HardwareLayer getHardwareLayer()>,<android.view.TextureView: HardwareLayer getHardwareLayer()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(mPrivateFlags |, []), Expression(PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID, [])]), AssignmentExpression(=, [VariableReference(mPrivateFlags &, []), Expression(~PFLAG_DIRTY_MASK, [])]), AssignmentExpression(=, [VariableReference(if (mLayer, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(if (mAttachInfo, []), Expression(, [])]), Statement(return null, []), Statement(}, []), AssignmentExpression(=, [VariableReference(mLayer, []), Expression(mAttachInfo.mHardwareRenderer.createHardwareLayer(mOpaque), [])]), Statement(if (!mUpdateSurface) {, []), Statement(// Create a new SurfaceTexture for the layer., []), AssignmentExpression(=, [VariableReference(mSurface, []), Expression(mAttachInfo.mHardwareRenderer.createSurfaceTexture(mLayer), [])]), Statement(}, []), MethodCall(mSurface.setDefaultBufferSize(getWidth(), getHeight()), [VariableReference(mSurface, []), Expression(getWidth(), []), Expression(getHeight(), [])]), Statement(nCreateNativeWindow(mSurface), []), AssignmentExpression(=, [VariableReference(mUpdateListener, []), Expression(new SurfaceTexture.OnFrameAvailableListener() {, [])]), Statement(@Override, []), Statement(public void onFrameAvailable(SurfaceTexture surfaceTexture) {, []), Statement(// Per SurfaceTexture's documentation, the callback may be invoked, []), Statement(// from an arbitrary thread, []), Statement(updateLayer(), []), AssignmentExpression(=, [VariableReference(if (Looper.myLooper(), []), Expression(, [])]), Statement(invalidate(), []), Statement(} else {, []), Statement(postInvalidate(), []), Statement(}, []), Statement(}, []), Statement(}, []), MethodCall(mSurface.setOnFrameAvailableListener(mUpdateListener), [VariableReference(mSurface, []), Expression(mUpdateListener, [])]), AssignmentExpression(=, [VariableReference(if (mListener !, []), Expression(null && !mUpdateSurface) {, [])]), MethodCall(mListener.onSurfaceTextureAvailable(mSurface, getWidth(), getHeight()), [VariableReference(mListener, []), Expression(mSurface, []), Expression(getWidth(), []), Expression(getHeight(), [])]), Statement(}, []), MethodCall(mLayer.setLayerPaint(mLayerPaint), [VariableReference(mLayer, []), Expression(mLayerPaint, [])]), Statement(}, []), Statement(if (mUpdateSurface) {, []), Statement(// Someone has requested that we use a specific SurfaceTexture, so, []), Statement(// tell mLayer about it and set the SurfaceTexture to use the, []), Statement(// current view size., []), AssignmentExpression(=, [VariableReference(mUpdateSurface, []), Expression(false, [])]), Statement(// Since we are updating the layer, force an update to ensure its, []), Statement(updateLayer(), []), AssignmentExpression(=, [VariableReference(mMatrixChanged, []), Expression(true, [])]), MethodCall(mSurface.setDefaultBufferSize(getWidth(), getHeight()), [VariableReference(mSurface, []), Expression(getWidth(), []), Expression(getHeight(), [])]), Statement(}, []), Statement(applyUpdate(), []), Statement(applyTransformMatrix(), []), Statement(return mLayer, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(mPrivateFlags |, []), Expression(PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID, [])])    VariableReference(mPrivateFlags |, [])    Expression(PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID, [])  AssignmentExpression(=, [VariableReference(mPrivateFlags &, []), Expression(~PFLAG_DIRTY_MASK, [])])    VariableReference(mPrivateFlags &, [])    Expression(~PFLAG_DIRTY_MASK, [])  AssignmentExpression(=, [VariableReference(if (mLayer, []), Expression(, [])])    VariableReference(if (mLayer, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(if (mAttachInfo, []), Expression(, [])])    VariableReference(if (mAttachInfo, [])    Expression(, [])  Statement(return null, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mLayer, []), Expression(mAttachInfo.mHardwareRenderer.createHardwareLayer(mOpaque), [])])    VariableReference(mLayer, [])    Expression(mAttachInfo.mHardwareRenderer.createHardwareLayer(mOpaque), [])  Statement(if (!mUpdateSurface) {, [])  Statement(// Create a new SurfaceTexture for the layer., [])  AssignmentExpression(=, [VariableReference(mSurface, []), Expression(mAttachInfo.mHardwareRenderer.createSurfaceTexture(mLayer), [])])    VariableReference(mSurface, [])    Expression(mAttachInfo.mHardwareRenderer.createSurfaceTexture(mLayer), [])  Statement(}, [])  MethodCall(mSurface.setDefaultBufferSize(getWidth(), getHeight()), [VariableReference(mSurface, []), Expression(getWidth(), []), Expression(getHeight(), [])])    VariableReference(mSurface, [])    Expression(getWidth(), [])    Expression(getHeight(), [])  Statement(nCreateNativeWindow(mSurface), [])  AssignmentExpression(=, [VariableReference(mUpdateListener, []), Expression(new SurfaceTexture.OnFrameAvailableListener() {, [])])    VariableReference(mUpdateListener, [])    Expression(new SurfaceTexture.OnFrameAvailableListener() {, [])  Statement(@Override, [])  Statement(public void onFrameAvailable(SurfaceTexture surfaceTexture) {, [])  Statement(// Per SurfaceTexture's documentation, the callback may be invoked, [])  Statement(// from an arbitrary thread, [])  Statement(updateLayer(), [])  AssignmentExpression(=, [VariableReference(if (Looper.myLooper(), []), Expression(, [])])    VariableReference(if (Looper.myLooper(), [])    Expression(, [])  Statement(invalidate(), [])  Statement(} else {, [])  Statement(postInvalidate(), [])  Statement(}, [])  Statement(}, [])  Statement(}, [])  MethodCall(mSurface.setOnFrameAvailableListener(mUpdateListener), [VariableReference(mSurface, []), Expression(mUpdateListener, [])])    VariableReference(mSurface, [])    Expression(mUpdateListener, [])  AssignmentExpression(=, [VariableReference(if (mListener !, []), Expression(null && !mUpdateSurface) {, [])])    VariableReference(if (mListener !, [])    Expression(null && !mUpdateSurface) {, [])  MethodCall(mListener.onSurfaceTextureAvailable(mSurface, getWidth(), getHeight()), [VariableReference(mListener, []), Expression(mSurface, []), Expression(getWidth(), []), Expression(getHeight(), [])])    VariableReference(mListener, [])    Expression(mSurface, [])    Expression(getWidth(), [])    Expression(getHeight(), [])  Statement(}, [])  MethodCall(mLayer.setLayerPaint(mLayerPaint), [VariableReference(mLayer, []), Expression(mLayerPaint, [])])    VariableReference(mLayer, [])    Expression(mLayerPaint, [])  Statement(}, [])  Statement(if (mUpdateSurface) {, [])  Statement(// Someone has requested that we use a specific SurfaceTexture, so, [])  Statement(// tell mLayer about it and set the SurfaceTexture to use the, [])  Statement(// current view size., [])  AssignmentExpression(=, [VariableReference(mUpdateSurface, []), Expression(false, [])])    VariableReference(mUpdateSurface, [])    Expression(false, [])  Statement(// Since we are updating the layer, force an update to ensure its, [])  Statement(updateLayer(), [])  AssignmentExpression(=, [VariableReference(mMatrixChanged, []), Expression(true, [])])    VariableReference(mMatrixChanged, [])    Expression(true, [])  MethodCall(mSurface.setDefaultBufferSize(getWidth(), getHeight()), [VariableReference(mSurface, []), Expression(getWidth(), []), Expression(getHeight(), [])])    VariableReference(mSurface, [])    Expression(getWidth(), [])    Expression(getHeight(), [])  Statement(}, [])  Statement(applyUpdate(), [])  Statement(applyTransformMatrix(), [])  Statement(return mLayer, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(mPrivateFlags |, []), Expression(PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID, [])]), AssignmentExpression(=, [VariableReference(mPrivateFlags &, []), Expression(~PFLAG_DIRTY_MASK, [])]), AssignmentExpression(=, [VariableReference(if (mLayer, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(if (mAttachInfo, []), Expression(, [])]), Statement(return null, []), Statement(}, []), AssignmentExpression(=, [VariableReference(mLayer, []), Expression(mAttachInfo.mHardwareRenderer.createTextureLayer(), [])]), Statement(if (!mUpdateSurface) {, []), Statement(// Create a new SurfaceTexture for the layer., []), AssignmentExpression(=, [VariableReference(mSurface, []), Expression(new SurfaceTexture(false), [])]), MethodCall(mLayer.setSurfaceTexture(mSurface), [VariableReference(mLayer, []), Expression(mSurface, [])]), Statement(}, []), MethodCall(mSurface.setDefaultBufferSize(getWidth(), getHeight()), [VariableReference(mSurface, []), Expression(getWidth(), []), Expression(getHeight(), [])]), Statement(nCreateNativeWindow(mSurface), []), MethodCall(mSurface.setOnFrameAvailableListener(mUpdateListener, mAttachInfo.mHandler), [VariableReference(mSurface, []), Expression(mUpdateListener, []), Expression(mAttachInfo.mHandler, [])]), AssignmentExpression(=, [VariableReference(if (mListener !, []), Expression(null && !mUpdateSurface) {, [])]), MethodCall(mListener.onSurfaceTextureAvailable(mSurface, getWidth(), getHeight()), [VariableReference(mListener, []), Expression(mSurface, []), Expression(getWidth(), []), Expression(getHeight(), [])]), Statement(}, []), MethodCall(mLayer.setLayerPaint(mLayerPaint), [VariableReference(mLayer, []), Expression(mLayerPaint, [])]), Statement(}, []), Statement(if (mUpdateSurface) {, []), Statement(// Someone has requested that we use a specific SurfaceTexture, so, []), Statement(// tell mLayer about it and set the SurfaceTexture to use the, []), Statement(// current view size., []), AssignmentExpression(=, [VariableReference(mUpdateSurface, []), Expression(false, [])]), Statement(// Since we are updating the layer, force an update to ensure its, []), Statement(updateLayer(), []), AssignmentExpression(=, [VariableReference(mMatrixChanged, []), Expression(true, [])]), MethodCall(mLayer.setSurfaceTexture(mSurface), [VariableReference(mLayer, []), Expression(mSurface, [])]), MethodCall(mSurface.setDefaultBufferSize(getWidth(), getHeight()), [VariableReference(mSurface, []), Expression(getWidth(), []), Expression(getHeight(), [])]), Statement(}, []), Statement(applyUpdate(), []), Statement(applyTransformMatrix(), []), Statement(return mLayer, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(mPrivateFlags |, []), Expression(PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID, [])])    VariableReference(mPrivateFlags |, [])    Expression(PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID, [])  AssignmentExpression(=, [VariableReference(mPrivateFlags &, []), Expression(~PFLAG_DIRTY_MASK, [])])    VariableReference(mPrivateFlags &, [])    Expression(~PFLAG_DIRTY_MASK, [])  AssignmentExpression(=, [VariableReference(if (mLayer, []), Expression(, [])])    VariableReference(if (mLayer, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(if (mAttachInfo, []), Expression(, [])])    VariableReference(if (mAttachInfo, [])    Expression(, [])  Statement(return null, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mLayer, []), Expression(mAttachInfo.mHardwareRenderer.createTextureLayer(), [])])    VariableReference(mLayer, [])    Expression(mAttachInfo.mHardwareRenderer.createTextureLayer(), [])  Statement(if (!mUpdateSurface) {, [])  Statement(// Create a new SurfaceTexture for the layer., [])  AssignmentExpression(=, [VariableReference(mSurface, []), Expression(new SurfaceTexture(false), [])])    VariableReference(mSurface, [])    Expression(new SurfaceTexture(false), [])  MethodCall(mLayer.setSurfaceTexture(mSurface), [VariableReference(mLayer, []), Expression(mSurface, [])])    VariableReference(mLayer, [])    Expression(mSurface, [])  Statement(}, [])  MethodCall(mSurface.setDefaultBufferSize(getWidth(), getHeight()), [VariableReference(mSurface, []), Expression(getWidth(), []), Expression(getHeight(), [])])    VariableReference(mSurface, [])    Expression(getWidth(), [])    Expression(getHeight(), [])  Statement(nCreateNativeWindow(mSurface), [])  MethodCall(mSurface.setOnFrameAvailableListener(mUpdateListener, mAttachInfo.mHandler), [VariableReference(mSurface, []), Expression(mUpdateListener, []), Expression(mAttachInfo.mHandler, [])])    VariableReference(mSurface, [])    Expression(mUpdateListener, [])    Expression(mAttachInfo.mHandler, [])  AssignmentExpression(=, [VariableReference(if (mListener !, []), Expression(null && !mUpdateSurface) {, [])])    VariableReference(if (mListener !, [])    Expression(null && !mUpdateSurface) {, [])  MethodCall(mListener.onSurfaceTextureAvailable(mSurface, getWidth(), getHeight()), [VariableReference(mListener, []), Expression(mSurface, []), Expression(getWidth(), []), Expression(getHeight(), [])])    VariableReference(mListener, [])    Expression(mSurface, [])    Expression(getWidth(), [])    Expression(getHeight(), [])  Statement(}, [])  MethodCall(mLayer.setLayerPaint(mLayerPaint), [VariableReference(mLayer, []), Expression(mLayerPaint, [])])    VariableReference(mLayer, [])    Expression(mLayerPaint, [])  Statement(}, [])  Statement(if (mUpdateSurface) {, [])  Statement(// Someone has requested that we use a specific SurfaceTexture, so, [])  Statement(// tell mLayer about it and set the SurfaceTexture to use the, [])  Statement(// current view size., [])  AssignmentExpression(=, [VariableReference(mUpdateSurface, []), Expression(false, [])])    VariableReference(mUpdateSurface, [])    Expression(false, [])  Statement(// Since we are updating the layer, force an update to ensure its, [])  Statement(updateLayer(), [])  AssignmentExpression(=, [VariableReference(mMatrixChanged, []), Expression(true, [])])    VariableReference(mMatrixChanged, [])    Expression(true, [])  MethodCall(mLayer.setSurfaceTexture(mSurface), [VariableReference(mLayer, []), Expression(mSurface, [])])    VariableReference(mLayer, [])    Expression(mSurface, [])  MethodCall(mSurface.setDefaultBufferSize(getWidth(), getHeight()), [VariableReference(mSurface, []), Expression(getWidth(), []), Expression(getHeight(), [])])    VariableReference(mSurface, [])    Expression(getWidth(), [])    Expression(getHeight(), [])  Statement(}, [])  Statement(applyUpdate(), [])  Statement(applyTransformMatrix(), [])  Statement(return mLayer, [])  Statement(}, [])",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,"3,4",0,"3,5","1,2",Two changes have been made in the implementation of `getHardwareLayer()` between the early and late versions.,
867,"<android.view.GLES20Canvas: boolean clipRegion(Region,Op)>",15,16,"<android.view.GLES20Canvas: boolean clipRegion(Region,Op)>","<android.view.GLES20Canvas: boolean clipRegion(Region,Op)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(throw new UnsupportedOperationException(), []), Statement(}, [])])  Statement({, [])  Statement(throw new UnsupportedOperationException(), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(// TODO: Implement, []), MethodCall(region.getBounds(mClipBounds), [VariableReference(region, []), Expression(mClipBounds, [])]), Statement(}, [])])  Statement({, [])  Statement(// TODO: Implement, [])  MethodCall(region.getBounds(mClipBounds), [VariableReference(region, []), Expression(mClipBounds, [])])    VariableReference(region, [])    Expression(mClipBounds, [])  Statement(}, [])",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,"1,2,4","1,2","1,4",1,"The early version of the method throws an UnsupportedOperationException, while the late version has a TODO comment and a method call to region.getBounds(mClipBounds). This change affects the behavior of the method and can potentially return a different value or throw a different exception.","The compatibility issue is caused by the potential different return values or types. The early version of the method always throws an exception and does not return a value, while the late version has a TODO comment and a method call that can potentially return a value. This can cause compatibility issues for any code that relies on the behavior of the early version of the method."
550,<android.os.RemoteCallbackList: int beginBroadcast()>,18,19,<android.os.RemoteCallbackList: int beginBroadcast()>,<android.os.RemoteCallbackList: int beginBroadcast()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(synchronized (mCallbacks) {, []), Statement(if (mBroadcastCount > 0) {, []), Statement(throw new IllegalStateException(""beginBroadcast() called while already in a broadcast""), []), Statement(}, []), AssignmentExpression(=, [VariableReference(final int N, []), Expression(mBroadcastCount, [])]), AssignmentExpression(=, [VariableReference(if (N <, []), Expression(0) {, [])]), Statement(return 0, []), Statement(}, []), AssignmentExpression(=, [VariableReference(Object[] active, []), Expression(mActiveBroadcast, [])]), AssignmentExpression(=, [VariableReference(if (active, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(mActiveBroadcast, []), Expression(active, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(int i, []), Expression(0, [])]), MethodCall(for (Callback cb : mCallbacks.values()), [VariableReference(for (Callback cb : mCallbacks, []), Expression(), [])]), AssignmentExpression(=, [VariableReference(active[i++], []), Expression(cb, [])]), Statement(}, []), Statement(return i, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(synchronized (mCallbacks) {, [])  Statement(if (mBroadcastCount > 0) {, [])  Statement(throw new IllegalStateException(""beginBroadcast() called while already in a broadcast""), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(final int N, []), Expression(mBroadcastCount, [])])    VariableReference(final int N, [])    Expression(mBroadcastCount, [])  AssignmentExpression(=, [VariableReference(if (N <, []), Expression(0) {, [])])    VariableReference(if (N <, [])    Expression(0) {, [])  Statement(return 0, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(Object[] active, []), Expression(mActiveBroadcast, [])])    VariableReference(Object[] active, [])    Expression(mActiveBroadcast, [])  AssignmentExpression(=, [VariableReference(if (active, []), Expression(, [])])    VariableReference(if (active, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(mActiveBroadcast, []), Expression(active, [])])    VariableReference(mActiveBroadcast, [])    Expression(active, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(int i, []), Expression(0, [])])    VariableReference(int i, [])    Expression(0, [])  MethodCall(for (Callback cb : mCallbacks.values()), [VariableReference(for (Callback cb : mCallbacks, []), Expression(), [])])    VariableReference(for (Callback cb : mCallbacks, [])    Expression(), [])  AssignmentExpression(=, [VariableReference(active[i++], []), Expression(cb, [])])    VariableReference(active[i++], [])    Expression(cb, [])  Statement(}, [])  Statement(return i, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(synchronized (mCallbacks) {, []), Statement(if (mBroadcastCount > 0) {, []), Statement(throw new IllegalStateException(""beginBroadcast() called while already in a broadcast""), []), Statement(}, []), AssignmentExpression(=, [VariableReference(final int N, []), Expression(mBroadcastCount, [])]), AssignmentExpression(=, [VariableReference(if (N <, []), Expression(0) {, [])]), Statement(return 0, []), Statement(}, []), AssignmentExpression(=, [VariableReference(Object[] active, []), Expression(mActiveBroadcast, [])]), AssignmentExpression(=, [VariableReference(if (active, []), Expression(, [])]), AssignmentExpression(=, [VariableReference(mActiveBroadcast, []), Expression(active, [])]), Statement(}, []), AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])]), Statement(i < N, []), Statement(i++) {, []), AssignmentExpression(=, [VariableReference(active[i], []), Expression(mCallbacks.valueAt(i), [])]), Statement(}, []), Statement(return N, []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(synchronized (mCallbacks) {, [])  Statement(if (mBroadcastCount > 0) {, [])  Statement(throw new IllegalStateException(""beginBroadcast() called while already in a broadcast""), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(final int N, []), Expression(mBroadcastCount, [])])    VariableReference(final int N, [])    Expression(mBroadcastCount, [])  AssignmentExpression(=, [VariableReference(if (N <, []), Expression(0) {, [])])    VariableReference(if (N <, [])    Expression(0) {, [])  Statement(return 0, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(Object[] active, []), Expression(mActiveBroadcast, [])])    VariableReference(Object[] active, [])    Expression(mActiveBroadcast, [])  AssignmentExpression(=, [VariableReference(if (active, []), Expression(, [])])    VariableReference(if (active, [])    Expression(, [])  AssignmentExpression(=, [VariableReference(mActiveBroadcast, []), Expression(active, [])])    VariableReference(mActiveBroadcast, [])    Expression(active, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(for (int i, []), Expression(0, [])])    VariableReference(for (int i, [])    Expression(0, [])  Statement(i < N, [])  Statement(i++) {, [])  AssignmentExpression(=, [VariableReference(active[i], []), Expression(mCallbacks.valueAt(i), [])])    VariableReference(active[i], [])    Expression(mCallbacks.valueAt(i), [])  Statement(}, [])  Statement(return N, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Prepare to start making calls to the currently registered callbacks.
 * This creates a copy of the callback list, which you can retrieve items
 * from using {@link #getBroadcastItem}.  Note that only one broadcast can
 * be active at a time, so you must be sure to always call this from the
 * same thread (usually by scheduling with {@link Handler}) or
 * do your own synchronization.  You must call {@link #finishBroadcast}
 * when done.
 *
 * <p>A typical loop delivering a broadcast looks like this:
 *
 * <pre>
 * int i = callbacks.beginBroadcast();
 * while (i &gt; 0) {
 * i--;
 * try {
 * callbacks.getBroadcastItem(i).somethingHappened();
 * } catch (RemoteException e) {
 * // The RemoteCallbackList will take care of removing
 * // the dead object for us.
 * }
 * }
 * callbacks.finishBroadcast();</pre>
 *
 * @return Returns the number of callbacks in the broadcast, to be used
 * with {@link #getBroadcastItem} to determine the range of indices you
 * can supply.
 *
 * @see #getBroadcastItem
 * @see #finishBroadcast
 */
","/**
 * Prepare to start making calls to the currently registered callbacks.
 * This creates a copy of the callback list, which you can retrieve items
 * from using {@link #getBroadcastItem}.  Note that only one broadcast can
 * be active at a time, so you must be sure to always call this from the
 * same thread (usually by scheduling with {@link Handler}) or
 * do your own synchronization.  You must call {@link #finishBroadcast}
 * when done.
 *
 * <p>A typical loop delivering a broadcast looks like this:
 *
 * <pre>
 * int i = callbacks.beginBroadcast();
 * while (i &gt; 0) {
 * i--;
 * try {
 * callbacks.getBroadcastItem(i).somethingHappened();
 * } catch (RemoteException e) {
 * // The RemoteCallbackList will take care of removing
 * // the dead object for us.
 * }
 * }
 * callbacks.finishBroadcast();</pre>
 *
 * @return Returns the number of callbacks in the broadcast, to be used
 * with {@link #getBroadcastItem} to determine the range of indices you
 * can supply.
 *
 * @see #getBroadcastItem
 * @see #finishBroadcast
 */
",-1,,,-1,-1,-1,-1,-1,"1,4",1,3,1,The method of iteration for populating the active array has changed from a for-each loop to a traditional for loop with an incrementing index. This could potentially lead to different behavior if the order of the elements in the mCallbacks.values() collection is not guaranteed to be the same as the order of the elements in the mCallbacks collection.,"The change in the method of iteration for populating the active array could potentially lead to a different order of elements in the active array, which could in turn lead to a different value being returned by the method (the number of elements in the active array). Therefore, the Compatibility Issue type is 1."
316,"<android.app.AppOpsManager: int unsafeCheckOpRawNoThrow(String,int,String)>",29,30,"<android.app.AppOpsManager: int unsafeCheckOpRawNoThrow(String,int,String)>","<android.app.AppOpsManager: int unsafeCheckOpRawNoThrow(String,int,String)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(return mService.checkOperationRaw(strOpToOp(op), uid, packageName), [VariableReference(return mService, []), Expression(strOpToOp(op), []), Expression(uid, []), Expression(packageName, [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(return mService.checkOperationRaw(strOpToOp(op), uid, packageName), [VariableReference(return mService, []), Expression(strOpToOp(op), []), Expression(uid, []), Expression(packageName, [])])    VariableReference(return mService, [])    Expression(strOpToOp(op), [])    Expression(uid, [])    Expression(packageName, [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return unsafeCheckOpRawNoThrow(strOpToOp(op), uid, packageName), []), Statement(}, [])])  Statement({, [])  Statement(return unsafeCheckOpRawNoThrow(strOpToOp(op), uid, packageName), [])  Statement(}, [])",1,"/**
 * Like {@link #unsafeCheckOpNoThrow(String, int, String)} but returns the <em>raw</em>
 * mode associated with the op. Does not throw a security exception, does not translate
 * {@link #MODE_FOREGROUND}.
 */
","/**
 * Like {@link #unsafeCheckOpNoThrow(String, int, String)} but returns the <em>raw</em>
 * mode associated with the op. Does not throw a security exception, does not translate
 * {@link #MODE_FOREGROUND}.
 */
",-1,,,-1,-1,-1,-1,-1,4,0,"1,5","1,2","The method implementation has been changed completely. In the early version, the method calls `mService.checkOperationRaw(strOpToOp(op), uid, packageName)` and catches `RemoteException`. In the late version, the method calls `unsafeCheckOpRawNoThrow(strOpToOp(op), uid, packageName)` directly without any exception handling.","The change of method implementation may lead to different return values or types. In the early version, the method may return the result of `mService.checkOperationRaw(strOpToOp(op), uid, packageName)` or throw a `RemoteException`. In the late version, the method may return the result of `unsafeCheckOpRawNoThrow(strOpToOp(op), uid, packageName)` without throwing any exceptions."
334,<android.accounts.AccountManager: String getPassword(Account)>,22,23,<android.accounts.AccountManager: String getPassword(Account)>,<android.accounts.AccountManager: String getPassword(Account)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (account, []), Expression(, [])]), Statement(throw new IllegalArgumentException(""account is null""), []), Statement(try {, []), MethodCall(return mService.getPassword(account), [VariableReference(return mService, []), Expression(account, [])]), Statement(} catch (RemoteException e) {, []), Statement(// will never happen, []), Statement(throw new RuntimeException(e), []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (account, []), Expression(, [])])    VariableReference(if (account, [])    Expression(, [])  Statement(throw new IllegalArgumentException(""account is null""), [])  Statement(try {, [])  MethodCall(return mService.getPassword(account), [VariableReference(return mService, []), Expression(account, [])])    VariableReference(return mService, [])    Expression(account, [])  Statement(} catch (RemoteException e) {, [])  Statement(// will never happen, [])  Statement(throw new RuntimeException(e), [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (account, []), Expression(, [])]), Statement(throw new IllegalArgumentException(""account is null""), []), Statement(try {, []), MethodCall(return mService.getPassword(account), [VariableReference(return mService, []), Expression(account, [])]), Statement(} catch (RemoteException e) {, []), Statement(// won't ever happen, []), Statement(throw new RuntimeException(e), []), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (account, []), Expression(, [])])    VariableReference(if (account, [])    Expression(, [])  Statement(throw new IllegalArgumentException(""account is null""), [])  Statement(try {, [])  MethodCall(return mService.getPassword(account), [VariableReference(return mService, []), Expression(account, [])])    VariableReference(return mService, [])    Expression(account, [])  Statement(} catch (RemoteException e) {, [])  Statement(// won't ever happen, [])  Statement(throw new RuntimeException(e), [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Gets the saved password associated with the account.
 * This is intended for authenticators and related code; applications
 * should get an auth token instead.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#AUTHENTICATE_ACCOUNTS}
 * and to have the same UID as the account's authenticator.
 *
 * @param account The account to query for a password
 * @return The account's password, null if none or if the account doesn't exist
 */
","/**
 * Gets the saved password associated with the account.
 * This is intended for authenticators and related code; applications
 * should get an auth token instead.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>This method requires the caller to have a signature match with the
 * authenticator that owns the specified account.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * AUTHENTICATE_ACCOUNTS permission is needed for those platforms. See docs for
 * this function in API level 22.
 *
 * @param account The account to query for a password. Must not be {@code null}.
 * @return The account's password, null if none or if the account doesn't exist
 */
",-1,,,-1,-1,-1,-1,-1,0,0,0,0,"Based on the provided information, there are no changes in the implementation AST nodes, comments, and annotations of the given API between the early version and the late version.","As there are no changes between the two versions, there is no compatibility issue."
725,<android.app.ActivityManager: void killBackgroundProcesses(String)>,25,26,<android.app.ActivityManager: void killBackgroundProcesses(String)>,<android.app.ActivityManager: void killBackgroundProcesses(String)>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(ActivityManagerNative.getDefault().killBackgroundProcesses(packageName, UserHandle.myUserId()), [VariableReference(ActivityManagerNative, []), Expression().killBackgroundProcesses(packageName, []), Expression(UserHandle.myUserId(), [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(ActivityManagerNative.getDefault().killBackgroundProcesses(packageName, UserHandle.myUserId()), [VariableReference(ActivityManagerNative, []), Expression().killBackgroundProcesses(packageName, []), Expression(UserHandle.myUserId(), [])])    VariableReference(ActivityManagerNative, [])    Expression().killBackgroundProcesses(packageName, [])    Expression(UserHandle.myUserId(), [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(try {, []), MethodCall(getService().killBackgroundProcesses(packageName, UserHandle.myUserId()), [VariableReference(getService(), []), Expression(packageName, []), Expression(UserHandle.myUserId(), [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(try {, [])  MethodCall(getService().killBackgroundProcesses(packageName, UserHandle.myUserId()), [VariableReference(getService(), []), Expression(packageName, []), Expression(UserHandle.myUserId(), [])])    VariableReference(getService(), [])    Expression(packageName, [])    Expression(UserHandle.myUserId(), [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",1,"/**
 * Have the system immediately kill all background processes associated
 * with the given package.  This is the same as the kernel killing those
 * processes to reclaim memory; the system will take care of restarting
 * these processes in the future as needed.
 *
 * <p>You must hold the permission
 * {@link android.Manifest.permission#KILL_BACKGROUND_PROCESSES} to be able to
 * call this method.
 *
 * @param packageName The name of the package whose processes are to
 * be killed.
 */
","/**
 * Have the system immediately kill all background processes associated
 * with the given package.  This is the same as the kernel killing those
 * processes to reclaim memory; the system will take care of restarting
 * these processes in the future as needed.
 *
 * @param packageName The name of the package whose processes are to
 * be killed.
 */
",-1,,[@RequiresPermission(Manifest.permission.KILL_BACKGROUND_PROCESSES)],-1,-1,-1,-1,-1,4,0,5,1,The method being called in the try block has changed from "ActivityManagerNative.getDefault()" to "getService()". This is a change in the dependent API.,"The change in the dependent API could potentially lead to different behavior in the method. For example, ""getService()"" might return a different implementation of the ActivityManagerService, which could have a different behavior when killing background processes. This is a Compatibility Issue caused by potential different return values or types."
60,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getChild(int)>,32,33,,,,"MethodDeclaration(method_body, [Statement({, []), Statement(enforceSealed(), []), AssignmentExpression(=, [VariableReference(if (mChildNodeIds, []), Expression(, [])]), Statement(return null, []), Statement(}, []), Statement(if (!canPerformRequestOverConnection(mConnectionId, mWindowId, mSourceNodeId)) {, []), Statement(return null, []), Statement(}, []), AssignmentExpression(=, [VariableReference(final long childId, []), Expression(mChildNodeIds.get(index), [])]), AssignmentExpression(=, [VariableReference(final AccessibilityInteractionClient client, []), Expression(AccessibilityInteractionClient.getInstance(), [])]), AssignmentExpression(=, [VariableReference(if (mLeashedChild !, []), Expression(null && childId, [])]), MethodCall(return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mLeashedChild, ROOT_NODE_ID, false, FLAG_PREFETCH_DESCENDANTS, null), [VariableReference(return client, []), Expression(mConnectionId, []), Expression(mLeashedChild, []), Expression(ROOT_NODE_ID, []), Expression(false, []), Expression(FLAG_PREFETCH_DESCENDANTS, []), Expression(null, [])]), Statement(}, []), MethodCall(return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mWindowId, childId, false, FLAG_PREFETCH_DESCENDANTS, null), [VariableReference(return client, []), Expression(mConnectionId, []), Expression(mWindowId, []), Expression(childId, []), Expression(false, []), Expression(FLAG_PREFETCH_DESCENDANTS, []), Expression(null, [])]), Statement(}, [])])  Statement({, [])  Statement(enforceSealed(), [])  AssignmentExpression(=, [VariableReference(if (mChildNodeIds, []), Expression(, [])])    VariableReference(if (mChildNodeIds, [])    Expression(, [])  Statement(return null, [])  Statement(}, [])  Statement(if (!canPerformRequestOverConnection(mConnectionId, mWindowId, mSourceNodeId)) {, [])  Statement(return null, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(final long childId, []), Expression(mChildNodeIds.get(index), [])])    VariableReference(final long childId, [])    Expression(mChildNodeIds.get(index), [])  AssignmentExpression(=, [VariableReference(final AccessibilityInteractionClient client, []), Expression(AccessibilityInteractionClient.getInstance(), [])])    VariableReference(final AccessibilityInteractionClient client, [])    Expression(AccessibilityInteractionClient.getInstance(), [])  AssignmentExpression(=, [VariableReference(if (mLeashedChild !, []), Expression(null && childId, [])])    VariableReference(if (mLeashedChild !, [])    Expression(null && childId, [])  MethodCall(return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mLeashedChild, ROOT_NODE_ID, false, FLAG_PREFETCH_DESCENDANTS, null), [VariableReference(return client, []), Expression(mConnectionId, []), Expression(mLeashedChild, []), Expression(ROOT_NODE_ID, []), Expression(false, []), Expression(FLAG_PREFETCH_DESCENDANTS, []), Expression(null, [])])    VariableReference(return client, [])    Expression(mConnectionId, [])    Expression(mLeashedChild, [])    Expression(ROOT_NODE_ID, [])    Expression(false, [])    Expression(FLAG_PREFETCH_DESCENDANTS, [])    Expression(null, [])  Statement(}, [])  MethodCall(return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mWindowId, childId, false, FLAG_PREFETCH_DESCENDANTS, null), [VariableReference(return client, []), Expression(mConnectionId, []), Expression(mWindowId, []), Expression(childId, []), Expression(false, []), Expression(FLAG_PREFETCH_DESCENDANTS, []), Expression(null, [])])    VariableReference(return client, [])    Expression(mConnectionId, [])    Expression(mWindowId, [])    Expression(childId, [])    Expression(false, [])    Expression(FLAG_PREFETCH_DESCENDANTS, [])    Expression(null, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(return getChild(index, FLAG_PREFETCH_DESCENDANTS_HYBRID), []), Statement(}, [])])  Statement({, [])  Statement(return getChild(index, FLAG_PREFETCH_DESCENDANTS_HYBRID), [])  Statement(}, [])",1,"/**
 * Get the child at given index.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @param index The child index.
 * @return The child node.
 *
 * @throws IllegalStateException If called outside of an AccessibilityService.
 */
","/**
 * Get the child at given index.
 *
 * @param index The child index.
 * @return The child node.
 *
 * @throws IllegalStateException If called outside of an AccessibilityService.
 */
",1,,,0,,,,,"1,3,4",1,1,1,"The implementation of the `getChild(int)` method has been changed. In the early version, the method body contains multiple statements including conditional checks, variable assignments, and method calls. In the late version, the method body has been simplified to a single return statement `return getChild(index, FLAG_PREFETCH_DESCENDANTS_HYBRID)`. This change has potentially modified the behavior of the method.","The Compatibility Issue (CI) arises in this case as the code change between the two continous versions of the same API could lead to different behaviors. Specifically, the return statement has been changed, and the new return statement `return getChild(index, FLAG_PREFETCH_DESCENDANTS_HYBRID)` may potentially cause the API to return a different variable (value or type) compared to the early version. Therefore, it should be regarded as a CI with type 1."
302,"<android.app.ContextImpl: void sendStickyBroadcastAsUser(Intent,UserHandle)>",29,30,"<android.app.ContextImpl: void sendStickyBroadcastAsUser(Intent,UserHandle)>","<android.app.ContextImpl: void sendStickyBroadcastAsUser(Intent,UserHandle)>",0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(String resolvedType, []), Expression(intent.resolveTypeIfNeeded(getContentResolver()), [])]), Statement(try {, []), MethodCall(intent.prepareToLeaveProcess(this), [VariableReference(intent, []), Expression(this, [])]), MethodCall(ActivityManager.getService().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, true, user.getIdentifier()), [VariableReference(ActivityManager, []), Expression().broadcastIntent(mMainThread.getApplicationThread(), []), Expression(intent, []), Expression(resolvedType, []), Expression(null, []), Expression(Activity.RESULT_OK, []), Expression(null, []), Expression(null, []), Expression(null, []), Expression(AppOpsManager.OP_NONE, []), Expression(null, []), Expression(false, []), Expression(true, []), Expression(user.getIdentifier(), [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(String resolvedType, []), Expression(intent.resolveTypeIfNeeded(getContentResolver()), [])])    VariableReference(String resolvedType, [])    Expression(intent.resolveTypeIfNeeded(getContentResolver()), [])  Statement(try {, [])  MethodCall(intent.prepareToLeaveProcess(this), [VariableReference(intent, []), Expression(this, [])])    VariableReference(intent, [])    Expression(this, [])  MethodCall(ActivityManager.getService().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, true, user.getIdentifier()), [VariableReference(ActivityManager, []), Expression().broadcastIntent(mMainThread.getApplicationThread(), []), Expression(intent, []), Expression(resolvedType, []), Expression(null, []), Expression(Activity.RESULT_OK, []), Expression(null, []), Expression(null, []), Expression(null, []), Expression(AppOpsManager.OP_NONE, []), Expression(null, []), Expression(false, []), Expression(true, []), Expression(user.getIdentifier(), [])])    VariableReference(ActivityManager, [])    Expression().broadcastIntent(mMainThread.getApplicationThread(), [])    Expression(intent, [])    Expression(resolvedType, [])    Expression(null, [])    Expression(Activity.RESULT_OK, [])    Expression(null, [])    Expression(null, [])    Expression(null, [])    Expression(AppOpsManager.OP_NONE, [])    Expression(null, [])    Expression(false, [])    Expression(true, [])    Expression(user.getIdentifier(), [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(String resolvedType, []), Expression(intent.resolveTypeIfNeeded(getContentResolver()), [])]), Statement(try {, []), MethodCall(intent.prepareToLeaveProcess(this), [VariableReference(intent, []), Expression(this, [])]), MethodCall(ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, true, user.getIdentifier()), [VariableReference(ActivityManager, []), Expression().broadcastIntentWithFeature(mMainThread.getApplicationThread(), []), Expression(getAttributionTag(), []), Expression(intent, []), Expression(resolvedType, []), Expression(null, []), Expression(Activity.RESULT_OK, []), Expression(null, []), Expression(null, []), Expression(null, []), Expression(AppOpsManager.OP_NONE, []), Expression(null, []), Expression(false, []), Expression(true, []), Expression(user.getIdentifier(), [])]), Statement(} catch (RemoteException e) {, []), MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])]), Statement(}, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(String resolvedType, []), Expression(intent.resolveTypeIfNeeded(getContentResolver()), [])])    VariableReference(String resolvedType, [])    Expression(intent.resolveTypeIfNeeded(getContentResolver()), [])  Statement(try {, [])  MethodCall(intent.prepareToLeaveProcess(this), [VariableReference(intent, []), Expression(this, [])])    VariableReference(intent, [])    Expression(this, [])  MethodCall(ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, true, user.getIdentifier()), [VariableReference(ActivityManager, []), Expression().broadcastIntentWithFeature(mMainThread.getApplicationThread(), []), Expression(getAttributionTag(), []), Expression(intent, []), Expression(resolvedType, []), Expression(null, []), Expression(Activity.RESULT_OK, []), Expression(null, []), Expression(null, []), Expression(null, []), Expression(AppOpsManager.OP_NONE, []), Expression(null, []), Expression(false, []), Expression(true, []), Expression(user.getIdentifier(), [])])    VariableReference(ActivityManager, [])    Expression().broadcastIntentWithFeature(mMainThread.getApplicationThread(), [])    Expression(getAttributionTag(), [])    Expression(intent, [])    Expression(resolvedType, [])    Expression(null, [])    Expression(Activity.RESULT_OK, [])    Expression(null, [])    Expression(null, [])    Expression(null, [])    Expression(AppOpsManager.OP_NONE, [])    Expression(null, [])    Expression(false, [])    Expression(true, [])    Expression(user.getIdentifier(), [])  Statement(} catch (RemoteException e) {, [])  MethodCall(throw e.rethrowFromSystemServer(), [VariableReference(throw e, []), Expression(, [])])    VariableReference(throw e, [])    Expression(, [])  Statement(}, [])  Statement(}, [])",1,,,-1,"[@Override, @Deprecated]","[@Override, @Deprecated]",-1,-1,-1,-1,-1,4,0,5,1,The implementation of sending the sticky broadcast has been changed from using the `broadcastIntent` method to the `broadcastIntentWithFeature` method in the late version.,"The change of the method used for sending the sticky broadcast may result in different behavior in terms of how the broadcast is delivered to the receivers. Therefore, it is a compatibility issue caused by potential different return values or types."
20,<android.widget.FrameLayout: LayoutParams generateDefaultLayoutParams()>,7,8,<android.widget.FrameLayout: LayoutParams generateDefaultLayoutParams()>,<android.widget.FrameLayout: LayoutParams generateDefaultLayoutParams()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(}, [])])  Statement({, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(}, [])])  Statement({, [])  Statement(}, [])",1,"/**
 * Returns a set of layout parameters with a width of
 * {@link android.view.ViewGroup.LayoutParams#FILL_PARENT},
 * and a height of {@link android.view.ViewGroup.LayoutParams#FILL_PARENT}.
 */
","/**
 * Returns a set of layout parameters with a width of
 * {@link android.view.ViewGroup.LayoutParams#MATCH_PARENT},
 * and a height of {@link android.view.ViewGroup.LayoutParams#MATCH_PARENT}.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,"1,4",1,1,1,"The change is in the comment where the constant `FILL_PARENT` is replaced by `MATCH_PARENT`. Despite the name change, these constants have the same value (-1), so the behavior of the code remains the same.",There is no Compatibility Issue (CI) caused by this change as the behavior of the code is not affected. The constant name change is only reflected in the documentation and does not impact the functionality.
319,"<android.app.Notification.Builder: Builder setSound(Uri,int)>",25,26,"<android.app.Notification.Builder: Builder setSound(Uri,int)>","<android.app.Notification.Builder: Builder setSound(Uri,int)>",0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(mN.sound, []), Expression(sound, [])]), AssignmentExpression(=, [VariableReference(mN.audioStreamType, []), Expression(streamType, [])]), Statement(return this, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(mN.sound, []), Expression(sound, [])])    VariableReference(mN.sound, [])    Expression(sound, [])  AssignmentExpression(=, [VariableReference(mN.audioStreamType, []), Expression(streamType, [])])    VariableReference(mN.audioStreamType, [])    Expression(streamType, [])  Statement(return this, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(PlayerBase.deprecateStreamTypeForPlayback(streamType, ""Notification"", ""setSound()""), [VariableReference(PlayerBase, []), Expression(streamType, []), Expression(""Notification"", []), Expression(""setSound()"", [])]), AssignmentExpression(=, [VariableReference(mN.sound, []), Expression(sound, [])]), AssignmentExpression(=, [VariableReference(mN.audioStreamType, []), Expression(streamType, [])]), Statement(return this, []), Statement(}, [])])  Statement({, [])  MethodCall(PlayerBase.deprecateStreamTypeForPlayback(streamType, ""Notification"", ""setSound()""), [VariableReference(PlayerBase, []), Expression(streamType, []), Expression(""Notification"", []), Expression(""setSound()"", [])])    VariableReference(PlayerBase, [])    Expression(streamType, [])    Expression(""Notification"", [])    Expression(""setSound()"", [])  AssignmentExpression(=, [VariableReference(mN.sound, []), Expression(sound, [])])    VariableReference(mN.sound, [])    Expression(sound, [])  AssignmentExpression(=, [VariableReference(mN.audioStreamType, []), Expression(streamType, [])])    VariableReference(mN.audioStreamType, [])    Expression(streamType, [])  Statement(return this, [])  Statement(}, [])",1,"/**
 * Set the sound to play, along with a specific stream on which to play it.
 *
 * See {@link android.media.AudioManager} for the <code>STREAM_</code> constants.
 *
 * <p>
 * A notification that is noisy is more likely to be presented as a heads-up notification.
 * </p>
 * @deprecated use {@link #setSound(Uri, AudioAttributes)} instead.
 * @see Notification#sound
 */
","/**
 * Set the sound to play, along with a specific stream on which to play it.
 *
 * See {@link android.media.AudioManager} for the <code>STREAM_</code> constants.
 *
 * @deprecated use {@link NotificationChannel#setSound(Uri, AudioAttributes)}.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,4,0,5,0,"A new method call (PlayerBase.deprecateStreamTypeForPlayback) has been added in the late version. This is a dependent API change, as it introduces a new dependency on the PlayerBase class and the deprecateStreamTypeForPlayback method.","The new method call does not affect the return value or the exception handling of the setSound method. Therefore, there is no compatibility issue in this case."
64,<android.app.Activity: void recreate()>,23,24,<android.app.Activity: void recreate()>,<android.app.Activity: void recreate()>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mParent !, []), Expression(null) {, [])]), Statement(throw new IllegalStateException(""Can only be called on top-level activity""), []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (Looper.myLooper() !, []), Expression(mMainThread.getLooper()) {, [])]), Statement(throw new IllegalStateException(""Must be called from main thread""), []), Statement(}, []), MethodCall(mMainThread.requestRelaunchActivity(mToken, null, null, 0, false, null, null, false), [VariableReference(mMainThread, []), Expression(mToken, []), Expression(null, []), Expression(null, []), Expression(0, []), Expression(false, []), Expression(null, []), Expression(null, []), Expression(false, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mParent !, []), Expression(null) {, [])])    VariableReference(if (mParent !, [])    Expression(null) {, [])  Statement(throw new IllegalStateException(""Can only be called on top-level activity""), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (Looper.myLooper() !, []), Expression(mMainThread.getLooper()) {, [])])    VariableReference(if (Looper.myLooper() !, [])    Expression(mMainThread.getLooper()) {, [])  Statement(throw new IllegalStateException(""Must be called from main thread""), [])  Statement(}, [])  MethodCall(mMainThread.requestRelaunchActivity(mToken, null, null, 0, false, null, null, false), [VariableReference(mMainThread, []), Expression(mToken, []), Expression(null, []), Expression(null, []), Expression(0, []), Expression(false, []), Expression(null, []), Expression(null, []), Expression(false, [])])    VariableReference(mMainThread, [])    Expression(mToken, [])    Expression(null, [])    Expression(null, [])    Expression(0, [])    Expression(false, [])    Expression(null, [])    Expression(null, [])    Expression(false, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (mParent !, []), Expression(null) {, [])]), Statement(throw new IllegalStateException(""Can only be called on top-level activity""), []), Statement(}, []), AssignmentExpression(=, [VariableReference(if (Looper.myLooper() !, []), Expression(mMainThread.getLooper()) {, [])]), Statement(throw new IllegalStateException(""Must be called from main thread""), []), Statement(}, []), MethodCall(mMainThread.requestRelaunchActivity(mToken, null, null, 0, false, null, null, false, false), [VariableReference(mMainThread, []), Expression(mToken, []), Expression(null, []), Expression(null, []), Expression(0, []), Expression(false, []), Expression(null, []), Expression(null, []), Expression(false, []), Expression(false, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (mParent !, []), Expression(null) {, [])])    VariableReference(if (mParent !, [])    Expression(null) {, [])  Statement(throw new IllegalStateException(""Can only be called on top-level activity""), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(if (Looper.myLooper() !, []), Expression(mMainThread.getLooper()) {, [])])    VariableReference(if (Looper.myLooper() !, [])    Expression(mMainThread.getLooper()) {, [])  Statement(throw new IllegalStateException(""Must be called from main thread""), [])  Statement(}, [])  MethodCall(mMainThread.requestRelaunchActivity(mToken, null, null, 0, false, null, null, false, false), [VariableReference(mMainThread, []), Expression(mToken, []), Expression(null, []), Expression(null, []), Expression(0, []), Expression(false, []), Expression(null, []), Expression(null, []), Expression(false, []), Expression(false, [])])    VariableReference(mMainThread, [])    Expression(mToken, [])    Expression(null, [])    Expression(null, [])    Expression(0, [])    Expression(false, [])    Expression(null, [])    Expression(null, [])    Expression(false, [])    Expression(false, [])  Statement(}, [])",1,"/**
 * Cause this Activity to be recreated with a new instance.  This results
 * in essentially the same flow as when the Activity is created due to
 * a configuration change -- the current instance will go through its
 * lifecycle to {@link #onDestroy} and a new instance then created after it.
 */
","/**
 * Cause this Activity to be recreated with a new instance.  This results
 * in essentially the same flow as when the Activity is created due to
 * a configuration change -- the current instance will go through its
 * lifecycle to {@link #onDestroy} and a new instance then created after it.
 */
",-1,,,-1,-1,-1,-1,-1,5,0,5,1,"The method call `mMainThread.requestRelaunchActivity(mToken, null, null, 0, false, null, null, false)` in the Early_Implementation_AST_Node has been changed to `mMainThread.requestRelaunchActivity(mToken, null, null, 0, false, null, null, false, false)` in the Late_Implementation_AST_Node. It means that a new parameter has been added to the method call.","The addition of a new parameter to the method call `mMainThread.requestRelaunchActivity` can potentially cause the API to return a different variable (value or type). This means that the behavior of the app that uses this API may change when it is upgraded to the newer version of the Android OS. Therefore, it is a compatibility issue."
807,<android.app.Activity: void setActionBar(Toolbar)>,22,23,<android.app.Activity: void setActionBar(Toolbar)>,<android.app.Activity: void setActionBar(Toolbar)>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(if (getActionBar() instanceof WindowDecorActionBar) {, []), Statement(}, []), AssignmentExpression(=, [VariableReference(ToolbarActionBar tbab, []), Expression(new ToolbarActionBar(toolbar, getTitle(), this), [])]), AssignmentExpression(=, [VariableReference(mActionBar, []), Expression(tbab, [])]), MethodCall(mWindow.setCallback(tbab.getWrappedWindowCallback()), [VariableReference(mWindow, []), Expression(tbab.getWrappedWindowCallback(), [])]), MethodCall(mActionBar.invalidateOptionsMenu(), [VariableReference(mActionBar, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  Statement(if (getActionBar() instanceof WindowDecorActionBar) {, [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(ToolbarActionBar tbab, []), Expression(new ToolbarActionBar(toolbar, getTitle(), this), [])])    VariableReference(ToolbarActionBar tbab, [])    Expression(new ToolbarActionBar(toolbar, getTitle(), this), [])  AssignmentExpression(=, [VariableReference(mActionBar, []), Expression(tbab, [])])    VariableReference(mActionBar, [])    Expression(tbab, [])  MethodCall(mWindow.setCallback(tbab.getWrappedWindowCallback()), [VariableReference(mWindow, []), Expression(tbab.getWrappedWindowCallback(), [])])    VariableReference(mWindow, [])    Expression(tbab.getWrappedWindowCallback(), [])  MethodCall(mActionBar.invalidateOptionsMenu(), [VariableReference(mActionBar, []), Expression(, [])])    VariableReference(mActionBar, [])    Expression(, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(if (getActionBar() instanceof WindowDecorActionBar) {, []), Statement(}, []), Statement(// Clear out the MenuInflater to make sure that it is valid for the new Action Bar, []), AssignmentExpression(=, [VariableReference(mMenuInflater, []), Expression(null, [])]), AssignmentExpression(=, [VariableReference(ToolbarActionBar tbab, []), Expression(new ToolbarActionBar(toolbar, getTitle(), this), [])]), AssignmentExpression(=, [VariableReference(mActionBar, []), Expression(tbab, [])]), MethodCall(mWindow.setCallback(tbab.getWrappedWindowCallback()), [VariableReference(mWindow, []), Expression(tbab.getWrappedWindowCallback(), [])]), MethodCall(mActionBar.invalidateOptionsMenu(), [VariableReference(mActionBar, []), Expression(, [])]), Statement(}, [])])  Statement({, [])  Statement(if (getActionBar() instanceof WindowDecorActionBar) {, [])  Statement(}, [])  Statement(// Clear out the MenuInflater to make sure that it is valid for the new Action Bar, [])  AssignmentExpression(=, [VariableReference(mMenuInflater, []), Expression(null, [])])    VariableReference(mMenuInflater, [])    Expression(null, [])  AssignmentExpression(=, [VariableReference(ToolbarActionBar tbab, []), Expression(new ToolbarActionBar(toolbar, getTitle(), this), [])])    VariableReference(ToolbarActionBar tbab, [])    Expression(new ToolbarActionBar(toolbar, getTitle(), this), [])  AssignmentExpression(=, [VariableReference(mActionBar, []), Expression(tbab, [])])    VariableReference(mActionBar, [])    Expression(tbab, [])  MethodCall(mWindow.setCallback(tbab.getWrappedWindowCallback()), [VariableReference(mWindow, []), Expression(tbab.getWrappedWindowCallback(), [])])    VariableReference(mWindow, [])    Expression(tbab.getWrappedWindowCallback(), [])  MethodCall(mActionBar.invalidateOptionsMenu(), [VariableReference(mActionBar, []), Expression(, [])])    VariableReference(mActionBar, [])    Expression(, [])  Statement(}, [])",1,"/**
 * Set a {@link android.widget.Toolbar Toolbar} to act as the {@link ActionBar} for this
 * Activity window.
 *
 * <p>When set to a non-null value the {@link #getActionBar()} method will return
 * an {@link ActionBar} object that can be used to control the given toolbar as if it were
 * a traditional window decor action bar. The toolbar's menu will be populated with the
 * Activity's options menu and the navigation button will be wired through the standard
 * {@link android.R.id#home home} menu select action.</p>
 *
 * <p>In order to use a Toolbar within the Activity's window content the application
 * must not request the window feature {@link Window#FEATURE_ACTION_BAR FEATURE_ACTION_BAR}.</p>
 *
 * @param toolbar Toolbar to set as the Activity's action bar
 */
","/**
 * Set a {@link android.widget.Toolbar Toolbar} to act as the {@link ActionBar} for this
 * Activity window.
 *
 * <p>When set to a non-null value the {@link #getActionBar()} method will return
 * an {@link ActionBar} object that can be used to control the given toolbar as if it were
 * a traditional window decor action bar. The toolbar's menu will be populated with the
 * Activity's options menu and the navigation button will be wired through the standard
 * {@link android.R.id#home home} menu select action.</p>
 *
 * <p>In order to use a Toolbar within the Activity's window content the application
 * must not request the window feature {@link Window#FEATURE_ACTION_BAR FEATURE_ACTION_BAR}.</p>
 *
 * @param toolbar Toolbar to set as the Activity's action bar
 */
",-1,,,-1,-1,-1,-1,-1,4,0,4,0,"Two new statements were added in the late version of the implementation AST node. The first one is a comment statement with no impact on the API behavior. The second one is an assignment statement that assigns a null value to a variable `mMenuInflater`. This variable is not used or referenced anywhere else in the method, hence it has no impact on the API behavior.","As the changes made in the late version of the API implementation have no impact on the API behavior, there are no Compatibility Issues (CI) that exist for this API."
1086,<android.print.PrintManager.PrintDocumentAdapterDelegate.MyWriteResultCallback: void onWriteCancelled()>,20,21,<android.print.PrintManager.PrintDocumentAdapterDelegate.MyWriteResultCallback: void onWriteCancelled()>,<android.print.PrintManager.PrintDocumentAdapterDelegate.MyWriteResultCallback: void onWriteCancelled()>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(synchronized (mLock) {, []), Statement(if (mDestroyed) {, []), MethodCall(Log.e(LOG_TAG, ""PrintDocumentAdapter is destroyed. Did you "" + ""finish the printing activity before print completion?""), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""PrintDocumentAdapter is destroyed. Did you "" + ""finish the printing activity before print completion?"", [])]), Statement(return, []), Statement(}, []), Statement(clearLocked(), []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(synchronized (mLock) {, [])  Statement(if (mDestroyed) {, [])  MethodCall(Log.e(LOG_TAG, ""PrintDocumentAdapter is destroyed. Did you "" + ""finish the printing activity before print completion?""), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""PrintDocumentAdapter is destroyed. Did you "" + ""finish the printing activity before print completion?"", [])])    VariableReference(Log, [])    Expression(LOG_TAG, [])    Expression(""PrintDocumentAdapter is destroyed. Did you "" + ""finish the printing activity before print completion?"", [])  Statement(return, [])  Statement(}, [])  Statement(clearLocked(), [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(final IWriteResultCallback callback, []), Statement(synchronized (mLock) {, []), AssignmentExpression(=, [VariableReference(callback, []), Expression(mCallback, [])]), Statement(}, []), Statement(// If the callback is null we are destroyed., []), AssignmentExpression(=, [VariableReference(if (callback, []), Expression(, [])]), MethodCall(Log.e(LOG_TAG, ""PrintDocumentAdapter is destroyed. Did you "" + ""finish the printing activity before print completion "" + ""or did you invoke a callback after finish?""), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""PrintDocumentAdapter is destroyed. Did you "" + ""finish the printing activity before print completion "" + ""or did you invoke a callback after finish?"", [])]), Statement(return, []), Statement(}, []), Statement(try {, []), MethodCall(callback.onWriteCanceled(mSequence), [VariableReference(callback, []), Expression(mSequence, [])]), Statement(} catch (RemoteException re) {, []), MethodCall(Log.e(LOG_TAG, ""Error calling onWriteCanceled"", re), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""Error calling onWriteCanceled"", []), Expression(re, [])]), Statement(} finally {, []), Statement(destroy(), []), Statement(}, []), Statement(}, [])])  Statement({, [])  Statement(final IWriteResultCallback callback, [])  Statement(synchronized (mLock) {, [])  AssignmentExpression(=, [VariableReference(callback, []), Expression(mCallback, [])])    VariableReference(callback, [])    Expression(mCallback, [])  Statement(}, [])  Statement(// If the callback is null we are destroyed., [])  AssignmentExpression(=, [VariableReference(if (callback, []), Expression(, [])])    VariableReference(if (callback, [])    Expression(, [])  MethodCall(Log.e(LOG_TAG, ""PrintDocumentAdapter is destroyed. Did you "" + ""finish the printing activity before print completion "" + ""or did you invoke a callback after finish?""), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""PrintDocumentAdapter is destroyed. Did you "" + ""finish the printing activity before print completion "" + ""or did you invoke a callback after finish?"", [])])    VariableReference(Log, [])    Expression(LOG_TAG, [])    Expression(""PrintDocumentAdapter is destroyed. Did you "" + ""finish the printing activity before print completion "" + ""or did you invoke a callback after finish?"", [])  Statement(return, [])  Statement(}, [])  Statement(try {, [])  MethodCall(callback.onWriteCanceled(mSequence), [VariableReference(callback, []), Expression(mSequence, [])])    VariableReference(callback, [])    Expression(mSequence, [])  Statement(} catch (RemoteException re) {, [])  MethodCall(Log.e(LOG_TAG, ""Error calling onWriteCanceled"", re), [VariableReference(Log, []), Expression(LOG_TAG, []), Expression(""Error calling onWriteCanceled"", []), Expression(re, [])])    VariableReference(Log, [])    Expression(LOG_TAG, [])    Expression(""Error calling onWriteCanceled"", [])    Expression(re, [])  Statement(} finally {, [])  Statement(destroy(), [])  Statement(}, [])  Statement(}, [])",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,"1,2,3,4","1,2","1,2,5","1,2","The implementation of the method ""onWriteCancelled()"" has undergone significant changes between the early version and the late version. In the late version, a new variable ""callback"" has been introduced, and the method ""clearLocked()"" has been replaced by ""destroy()"". Additionally, the exception handling for ""RemoteException"" has been added. These changes can be classified into three categories: (1) the return statement has been changed, as the method now returns after the ""Log.e()"" call in the case of a null callback; (2) the exception handling statement has been changed, as the late version now catches ""RemoteException"" and logs the error; (3) the dependent API has been changed, as ""clearLocked()"" has been replaced by ""destroy()"".","The changes in the return statement and exception handling can potentially lead to compatibility issues. In the case of a null callback, the early version of the method would continue executing, whereas the late version would return immediately after logging the error. This difference in behavior can cause unexpected issues in the application's flow. Additionally, the late version's exception handling for ""RemoteException"" was not present in the early version. If the application was not designed to handle this exception, it could crash or behave unpredictably in the late version."
267,<android.util.SparseIntArray: int indexOfKey(int)>,18,19,<android.util.SparseIntArray: int indexOfKey(int)>,<android.util.SparseIntArray: int indexOfKey(int)>,0,"MethodDeclaration(method_body, [Statement({, []), Statement(return binarySearch(mKeys, 0, mSize, key), []), Statement(}, [])])  Statement({, [])  Statement(return binarySearch(mKeys, 0, mSize, key), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(return ContainerHelpers.binarySearch(mKeys, mSize, key), [VariableReference(return ContainerHelpers, []), Expression(mKeys, []), Expression(mSize, []), Expression(key, [])]), Statement(}, [])])  Statement({, [])  MethodCall(return ContainerHelpers.binarySearch(mKeys, mSize, key), [VariableReference(return ContainerHelpers, []), Expression(mKeys, []), Expression(mSize, []), Expression(key, [])])    VariableReference(return ContainerHelpers, [])    Expression(mKeys, [])    Expression(mSize, [])    Expression(key, [])  Statement(}, [])",1,"/**
 * Returns the index for which {@link #keyAt} would return the
 * specified key, or a negative number if the specified
 * key is not mapped.
 */
","/**
 * Returns the index for which {@link #keyAt} would return the
 * specified key, or a negative number if the specified
 * key is not mapped.
 */
",-1,,,-1,-1,-1,-1,-1,"1,5",1,5,1,"The implementation of the method `indexOfKey` has been changed from using the `binarySearch` method directly to using the `ContainerHelpers.binarySearch` method. This is a dependent API change, as the method being used to perform the search has been changed.","This change has the potential to cause a compatibility issue, as the `ContainerHelpers.binarySearch` method may have different behavior or return values compared to the `binarySearch` method that was used previously. This could result in the `indexOfKey` method returning incorrect or unexpected values, which could in turn affect the behavior of any code that uses this method."
339,"<android.view.GLES20Canvas: void drawText(String,int,int,float,float,Paint)>",20,21,"<android.view.GLES20Canvas: void drawText(String,int,int,float,float,Paint)>","<android.view.GLES20Canvas: void drawText(String,int,int,float,float,Paint)>",0,"MethodDeclaration(method_body, [Statement({, []), MethodCall(if ((start | end | (end - start) | (text.length() - end)) < 0), [VariableReference(if ((start | end | (end - start) | (text, []), Expression() - end)) < 0, [])]), Statement(throw new IndexOutOfBoundsException(), []), Statement(}, []), AssignmentExpression(=, [VariableReference(int modifiers, []), Expression(setupModifiers(paint), [])]), Statement(try {, []), Statement(} finally {, []), AssignmentExpression(=, [VariableReference(if (modifiers !, []), Expression(MODIFIER_NONE), [])]), Statement(nResetModifiers(mRenderer, modifiers), []), Statement(}, []), Statement(}, [])])  Statement({, [])  MethodCall(if ((start | end | (end - start) | (text.length() - end)) < 0), [VariableReference(if ((start | end | (end - start) | (text, []), Expression() - end)) < 0, [])])    VariableReference(if ((start | end | (end - start) | (text, [])    Expression() - end)) < 0, [])  Statement(throw new IndexOutOfBoundsException(), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(int modifiers, []), Expression(setupModifiers(paint), [])])    VariableReference(int modifiers, [])    Expression(setupModifiers(paint), [])  Statement(try {, [])  Statement(} finally {, [])  AssignmentExpression(=, [VariableReference(if (modifiers !, []), Expression(MODIFIER_NONE), [])])    VariableReference(if (modifiers !, [])    Expression(MODIFIER_NONE), [])  Statement(nResetModifiers(mRenderer, modifiers), [])  Statement(}, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), MethodCall(if ((start | end | (end - start) | (text.length() - end)) < 0), [VariableReference(if ((start | end | (end - start) | (text, []), Expression() - end)) < 0, [])]), Statement(throw new IndexOutOfBoundsException(), []), Statement(}, []), Statement(}, [])])  Statement({, [])  MethodCall(if ((start | end | (end - start) | (text.length() - end)) < 0), [VariableReference(if ((start | end | (end - start) | (text, []), Expression() - end)) < 0, [])])    VariableReference(if ((start | end | (end - start) | (text, [])    Expression() - end)) < 0, [])  Statement(throw new IndexOutOfBoundsException(), [])  Statement(}, [])  Statement(}, [])",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,"2,4",2,4,1,The code change is the removal of the following block from the early version:,} finally {
685,<android.content.pm.ShortcutInfo.Builder: Builder setActivity(ComponentName)>,29,30,<android.content.pm.ShortcutInfo.Builder: Builder setActivity(ComponentName)>,<android.content.pm.ShortcutInfo.Builder: Builder setActivity(ComponentName)>,0,"MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(mActivity, []), Expression(Preconditions.checkNotNull(activity, ""activity cannot be null""), [])]), Statement(return this, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(mActivity, []), Expression(Preconditions.checkNotNull(activity, ""activity cannot be null""), [])])    VariableReference(mActivity, [])    Expression(Preconditions.checkNotNull(activity, ""activity cannot be null""), [])  Statement(return this, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(mActivity, []), Expression(Objects.requireNonNull(activity, ""activity cannot be null""), [])]), Statement(return this, []), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(mActivity, []), Expression(Objects.requireNonNull(activity, ""activity cannot be null""), [])])    VariableReference(mActivity, [])    Expression(Objects.requireNonNull(activity, ""activity cannot be null""), [])  Statement(return this, [])  Statement(}, [])",1,"/**
 * Sets the target activity.  A shortcut will be shown along with this activity's icon
 * on the launcher.
 *
 * When selecting a target activity, keep the following in mind:
 * <ul>
 * <li>All dynamic shortcuts must have a target activity.  When a shortcut with no target
 * activity is published using
 * {@link ShortcutManager#addDynamicShortcuts(List)} or
 * {@link ShortcutManager#setDynamicShortcuts(List)},
 * the first main activity defined in the app's <code>AndroidManifest.xml</code>
 * file is used.
 *
 * <li>Only ""main"" activities&mdash;ones that define the {@link Intent#ACTION_MAIN}
 * and {@link Intent#CATEGORY_LAUNCHER} intent filters&mdash;can be target
 * activities.
 *
 * <li>By default, the first main activity defined in the app's manifest is
 * the target activity.
 *
 * <li>A target activity must belong to the publisher app.
 * </ul>
 *
 * @see ShortcutInfo#getActivity()
 */
","/**
 * Sets the target activity.  A shortcut will be shown along with this activity's icon
 * on the launcher.
 *
 * When selecting a target activity, keep the following in mind:
 * <ul>
 * <li>All dynamic shortcuts must have a target activity.  When a shortcut with no target
 * activity is published using
 * {@link ShortcutManager#addDynamicShortcuts(List)} or
 * {@link ShortcutManager#setDynamicShortcuts(List)},
 * the first main activity defined in the app's <code>AndroidManifest.xml</code>
 * file is used.
 *
 * <li>Only ""main"" activities&mdash;ones that define the {@link Intent#ACTION_MAIN}
 * and {@link Intent#CATEGORY_LAUNCHER} intent filters&mdash;can be target
 * activities.
 *
 * <li>By default, the first main activity defined in the app's manifest is
 * the target activity.
 *
 * <li>A target activity must belong to the publisher app.
 * </ul>
 *
 * @see ShortcutInfo#getActivity()
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,4,0,4,0,"The method implementation has changed from using `Preconditions.checkNotNull(activity, ""activity cannot be null"")` to `Objects.requireNonNull(activity, ""activity cannot be null"")`. This is an example of ""Other statement changed"" as per the given instructions, hence the code change type is 4.","The change in the method implementation does not affect the API's return value or exception handling. The `Preconditions.checkNotNull` and `Objects.requireNonNull` methods have the same functionality, which is to throw a `NullPointerException` if the first argument is null. Therefore, there is no Compatibility Issue (CI) in this case, and the CI type is 0."
2,"<android.util.LongSparseArray: void setValueAt(int,E)>",28,29,"<android.util.LongSparseArray: void setValueAt(int,E)>","<android.util.LongSparseArray: void setValueAt(int,E)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(if (mGarbage) {, []), Statement(gc(), []), Statement(}, []), AssignmentExpression(=, [VariableReference(mValues[index], []), Expression(value, [])]), Statement(}, [])])  Statement({, [])  Statement(if (mGarbage) {, [])  Statement(gc(), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mValues[index], []), Expression(value, [])])    VariableReference(mValues[index], [])    Expression(value, [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), AssignmentExpression(=, [VariableReference(if (index >, []), Expression(mSize && UtilConfig.sThrowExceptionForUpperArrayOutOfBounds) {, [])]), Statement(// Check if exception should be thrown outside of the critical path., []), Statement(throw new ArrayIndexOutOfBoundsException(index), []), Statement(}, []), Statement(if (mGarbage) {, []), Statement(gc(), []), Statement(}, []), AssignmentExpression(=, [VariableReference(mValues[index], []), Expression(value, [])]), Statement(}, [])])  Statement({, [])  AssignmentExpression(=, [VariableReference(if (index >, []), Expression(mSize && UtilConfig.sThrowExceptionForUpperArrayOutOfBounds) {, [])])    VariableReference(if (index >, [])    Expression(mSize && UtilConfig.sThrowExceptionForUpperArrayOutOfBounds) {, [])  Statement(// Check if exception should be thrown outside of the critical path., [])  Statement(throw new ArrayIndexOutOfBoundsException(index), [])  Statement(}, [])  Statement(if (mGarbage) {, [])  Statement(gc(), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(mValues[index], []), Expression(value, [])])    VariableReference(mValues[index], [])    Expression(value, [])  Statement(}, [])",1,"/**
 * Given an index in the range <code>0...size()-1</code>, sets a new
 * value for the <code>index</code>th key-value mapping that this
 * LongSparseArray stores.
 */
","/**
 * Given an index in the range <code>0...size()-1</code>, sets a new
 * value for the <code>index</code>th key-value mapping that this
 * LongSparseArray stores.
 *
 * <p>For indices outside of the range <code>0...size()-1</code>, the behavior is undefined for
 * apps targeting {@link android.os.Build.VERSION_CODES#P} and earlier, and an
 * {@link ArrayIndexOutOfBoundsException} is thrown for apps targeting
 * {@link android.os.Build.VERSION_CODES#Q} and later.</p>
 */
",-1,,,-1,-1,-1,-1,-1,"2,3,4",2,"2,3",2,"The early implementation does not check for array index out of bounds and does not throw an exception for it. The late implementation, on the other hand, checks for array index out of bounds and throws an ArrayIndexOutOfBoundsException for it. This is a control dependency change (if statement) and an exception handling statement change (throw statement).","The compatibility issue arises due to the different behavior of the API in the two versions with respect to array index out of bounds. In the early version, the API does not throw an exception for array index out of bounds, and the behavior is undefined for apps targeting Android Pie or earlier. In the late version, the API throws an ArrayIndexOutOfBoundsException for array index out of bounds, and the behavior is well-defined for apps targeting Android Q or later. This can potentially cause crashes or unexpected behavior in apps that are not updated to handle the new behavior of the API."
1053,"<android.content.res.AssetManager: XmlBlock openXmlBlockAsset(int,String)>",20,21,"<android.content.res.AssetManager: XmlBlock openXmlBlockAsset(int,String)>","<android.content.res.AssetManager: XmlBlock openXmlBlockAsset(int,String)>",0,"MethodDeclaration(method_body, [Statement({, []), Statement(synchronized (this) {, []), Statement(if (!mOpen) {, []), Statement(throw new RuntimeException(""Assetmanager has been closed""), []), Statement(}, []), AssignmentExpression(=, [VariableReference(int xmlBlock, []), Expression(openXmlAssetNative(cookie, fileName), [])]), AssignmentExpression(=, [VariableReference(if (xmlBlock !, []), Expression(0) {, [])]), AssignmentExpression(=, [VariableReference(XmlBlock res, []), Expression(new XmlBlock(this, xmlBlock), [])]), MethodCall(incRefsLocked(res.hashCode()), [VariableReference(incRefsLocked(res, []), Expression(), [])]), Statement(return res, []), Statement(}, []), Statement(}, []), Statement(throw new FileNotFoundException(""Asset XML file: "" + fileName), []), Statement(}, [])])  Statement({, [])  Statement(synchronized (this) {, [])  Statement(if (!mOpen) {, [])  Statement(throw new RuntimeException(""Assetmanager has been closed""), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(int xmlBlock, []), Expression(openXmlAssetNative(cookie, fileName), [])])    VariableReference(int xmlBlock, [])    Expression(openXmlAssetNative(cookie, fileName), [])  AssignmentExpression(=, [VariableReference(if (xmlBlock !, []), Expression(0) {, [])])    VariableReference(if (xmlBlock !, [])    Expression(0) {, [])  AssignmentExpression(=, [VariableReference(XmlBlock res, []), Expression(new XmlBlock(this, xmlBlock), [])])    VariableReference(XmlBlock res, [])    Expression(new XmlBlock(this, xmlBlock), [])  MethodCall(incRefsLocked(res.hashCode()), [VariableReference(incRefsLocked(res, []), Expression(), [])])    VariableReference(incRefsLocked(res, [])    Expression(), [])  Statement(return res, [])  Statement(}, [])  Statement(}, [])  Statement(throw new FileNotFoundException(""Asset XML file: "" + fileName), [])  Statement(}, [])","MethodDeclaration(method_body, [Statement({, []), Statement(synchronized (this) {, []), Statement(if (!mOpen) {, []), Statement(throw new RuntimeException(""Assetmanager has been closed""), []), Statement(}, []), AssignmentExpression(=, [VariableReference(long xmlBlock, []), Expression(openXmlAssetNative(cookie, fileName), [])]), AssignmentExpression(=, [VariableReference(if (xmlBlock !, []), Expression(0) {, [])]), AssignmentExpression(=, [VariableReference(XmlBlock res, []), Expression(new XmlBlock(this, xmlBlock), [])]), MethodCall(incRefsLocked(res.hashCode()), [VariableReference(incRefsLocked(res, []), Expression(), [])]), Statement(return res, []), Statement(}, []), Statement(}, []), Statement(throw new FileNotFoundException(""Asset XML file: "" + fileName), []), Statement(}, [])])  Statement({, [])  Statement(synchronized (this) {, [])  Statement(if (!mOpen) {, [])  Statement(throw new RuntimeException(""Assetmanager has been closed""), [])  Statement(}, [])  AssignmentExpression(=, [VariableReference(long xmlBlock, []), Expression(openXmlAssetNative(cookie, fileName), [])])    VariableReference(long xmlBlock, [])    Expression(openXmlAssetNative(cookie, fileName), [])  AssignmentExpression(=, [VariableReference(if (xmlBlock !, []), Expression(0) {, [])])    VariableReference(if (xmlBlock !, [])    Expression(0) {, [])  AssignmentExpression(=, [VariableReference(XmlBlock res, []), Expression(new XmlBlock(this, xmlBlock), [])])    VariableReference(XmlBlock res, [])    Expression(new XmlBlock(this, xmlBlock), [])  MethodCall(incRefsLocked(res.hashCode()), [VariableReference(incRefsLocked(res, []), Expression(), [])])    VariableReference(incRefsLocked(res, [])    Expression(), [])  Statement(return res, [])  Statement(}, [])  Statement(}, [])  Statement(throw new FileNotFoundException(""Asset XML file: "" + fileName), [])  Statement(}, [])",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,4,0,1,0,"1. Return statement changed: In the early version, the type of the variable `xmlBlock` is `int`, whereas in the late version, it's `long`. This change affects the constructor of the `XmlBlock` class, which is called in the return statement.",CI_description:
