Number,Signature,Early_Version,Late_Version,Early_Signature,Late_Signature,Diff_Signature,Early_Implementation,Late_Implementation,Diff_Implementation,Early_Comment,Late_Comment,Diff_Comment,Early_Annotation,Late_Annotation,Diff_Annotation,Early_Callback,Late_Callback,Diff_Callback,GT_CI_ControlFlow,GT_Change_Type,GT_CI_Type,pred_change,pred_CI,change_description,CI_description
1,<android.os.StrictMode.ThreadPolicy.Builder: Builder permitUnbufferedIo()>,28,29,<android.os.StrictMode.ThreadPolicy.Builder: Builder permitUnbufferedIo()>,<android.os.StrictMode.ThreadPolicy.Builder: Builder permitUnbufferedIo()>,0,"{
    return disable(DETECT_UNBUFFERED_IO);
}","{
    return disable(DETECT_THREAD_UNBUFFERED_IO);
}",1,"/**
 * Disable detection of unbuffered input/output operations.
 */","/**
 * Disable detection of unbuffered input/output operations.
 */",0,,[@NonNull],1,0,0,0,1,1,1,1,1,"The return statement has changed from `disable(DETECT_UNBUFFERED_IO)` to `disable(DETECT_THREAD_UNBUFFERED_IO)`. This means that the API potentially returns a different value, leading to a Compatibility Issue.","The change in return statement can cause the API to return a different value. Therefore, it is a Compatibility Issue caused by potential different return values."
2,<android.app.NotificationManager: int getCurrentInterruptionFilter()>,23,24,<android.app.NotificationManager: int getCurrentInterruptionFilter()>,<android.app.NotificationManager: int getCurrentInterruptionFilter()>,0,"{
    final INotificationManager service = getService();
    try {
        return zenModeToInterruptionFilter(service.getZenMode());
    } catch (RemoteException e) {
        Log.e(TAG, ""Unable to talk to notification manager. Woe!"", e);
    }
    return INTERRUPTION_FILTER_UNKNOWN;
}","{
    final INotificationManager service = getService();
    try {
        return zenModeToInterruptionFilter(service.getZenMode());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Gets the current notification interruption filter.
 *
 * <p>
 * The interruption filter defines which notifications are allowed to interrupt the user
 * (e.g. via sound &amp; vibration) and is applied globally.
 * @return One of the INTERRUPTION_FILTER_ constants, or INTERRUPTION_FILTER_UNKNOWN when
 * unavailable.
 *
 * <p>
 * Only available if policy access is granted to this package.
 * See {@link #isNotificationPolicyAccessGranted}.
 */","/**
 * Gets the current notification interruption filter.
 *
 * <p>
 * The interruption filter defines which notifications are allowed to interrupt the user
 * (e.g. via sound &amp; vibration) and is applied globally.
 * @return One of the INTERRUPTION_FILTER_ constants, or INTERRUPTION_FILTER_UNKNOWN when
 * unavailable.
 */",1,,[@InterruptionFilter],0,0,0,0,"1,2","1,2","1,2","1,2","1,2","The return statement ""return INTERRUPTION\_FILTER\_UNKNOWN;"" has been removed from the catch block in the late version. Additionally, the exception handling has also changed from ""Log.e(TAG, ""Unable to talk to notification manager. Woe!"", e);"" to ""throw e.rethrowFromSystemServer();"".","The removal of the return statement in the catch block could potentially cause the API to return a different value in case of an exception. Furthermore, the change in exception handling could also lead to a different behavior in case of an exception. Therefore, the compatibility issue is caused by potential different return values or types (1) and potential different exception handlings (2)."
3,<android.app.NotificationManager: int getCurrentInterruptionFilter()>,25,26,<android.app.NotificationManager: int getCurrentInterruptionFilter()>,<android.app.NotificationManager: int getCurrentInterruptionFilter()>,0,"{
    final INotificationManager service = getService();
    try {
        return zenModeToInterruptionFilter(service.getZenMode());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    final INotificationManager service = getService();
    try {
        return zenModeToInterruptionFilter(service.getZenMode());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",0,"/**
 * Gets the current notification interruption filter.
 *
 * <p>
 * The interruption filter defines which notifications are allowed to interrupt the user
 * (e.g. via sound &amp; vibration) and is applied globally.
 * @return One of the INTERRUPTION_FILTER_ constants, or INTERRUPTION_FILTER_UNKNOWN when
 * unavailable.
 */","/**
 * Gets the current notification interruption filter.
 * <p>
 * The interruption filter defines which notifications are allowed to
 * interrupt the user (e.g. via sound &amp; vibration) and is applied
 * globally.
 */",1,[@InterruptionFilter],[@InterruptionFilter],0,0,0,0,0,0,0,0,0,There is no change between the two implementations of the `getCurrentInterruptionFilter()` method.,"As there is no code change, there is no potential Compatibility Issue."
9,<android.os.Environment: boolean isExternalStorageEmulated()>,27,28,<android.os.Environment: boolean isExternalStorageEmulated()>,<android.os.Environment: boolean isExternalStorageEmulated()>,0,"{
    if (isStorageDisabled())
        return false;
    final File externalDir = sCurrentUser.getExternalDirs()[0];
    return isExternalStorageEmulated(externalDir);
}","{
    final File externalDir = sCurrentUser.getExternalDirs()[0];
    return isExternalStorageEmulated(externalDir);
}",1,"/**
 * Returns whether the primary shared/external storage media is emulated.
 * <p>
 * The contents of emulated storage devices are backed by a private user
 * data partition, which means there is little benefit to apps storing data
 * here instead of the private directories returned by
 * {@link Context#getFilesDir()}, etc.
 * <p>
 * This returns true when emulated storage is backed by either internal
 * storage or an adopted storage device.
 *
 * @see DevicePolicyManager#setStorageEncryption(android.content.ComponentName,
 * boolean)
 */","/**
 * Returns whether the primary shared/external storage media is emulated.
 * <p>
 * The contents of emulated storage devices are backed by a private user
 * data partition, which means there is little benefit to apps storing data
 * here instead of the private directories returned by
 * {@link Context#getFilesDir()}, etc.
 * <p>
 * This returns true when emulated storage is backed by either internal
 * storage or an adopted storage device.
 *
 * @see DevicePolicyManager#setStorageEncryption(android.content.ComponentName,
 * boolean)
 */",0,,,0,0,0,0,1,"1,3",1,"1, 3",1,"The implementation of the API has changed, specifically, a conditional statement (if-statement) has been removed, which is a control dependency change (type 3). Additionally, a return statement has also been removed, which is a return statement change (type 1).","The removal of the conditional statement ""if (isStorageDisabled())"" could lead to different behavior in the late version of the API. If the storage is disabled, the early version of the API will return false, while the late version will continue to execute the next line of code and return the result of isExternalStorageEmulated(externalDir). This difference in behavior could cause a Compatibility Issue (type 1) where the return value of the API could potentially be different between the two versions."
10,"<android.app.usage.NetworkStatsManager: NetworkStats queryDetails(int,String,long,long)>",23,24,"<android.app.usage.NetworkStatsManager: NetworkStats queryDetails(int,String,long,long)>",android.app.usage.NetworkStatsManager.queryDetails,0,"{
    NetworkTemplate template = createTemplate(networkType, subscriberId);
    if (template == null) {
        return null;
    }
    NetworkStats result;
    result = new NetworkStats(mContext, template, startTime, endTime);
    result.startUserUidEnumeration();
    return result;
}","{
    NetworkTemplate template;
    try {
        template = createTemplate(networkType, subscriberId);
    } catch (IllegalArgumentException e) {
        if (DBG)
            Log.e(TAG, ""Cannot create template"", e);
        return null;
    }
    NetworkStats result;
    result = new NetworkStats(mContext, template, startTime, endTime);
    result.startUserUidEnumeration();
    return result;
}",1,"/**
 * Query network usage statistics details. Result filtered to include only uids belonging to
 * calling user. Result is aggregated over state but not aggregated over time or uid. This means
 * buckets' start and end timestamps are going to be between 'startTime' and 'endTime'
 * parameters, state is going to be {@link NetworkStats.Bucket#STATE_ALL} and uid will vary.
 * <p>Only includes buckets that atomically occur in the inclusive time range. Doesn't
 * interpolate across partial buckets. Since bucket length is in the order of hours, this
 * method cannot be used to measure data usage on a fine grained time scale.
 *
 * @param networkType As defined in {@link ConnectivityManager}, e.g.
 * {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}
 * etc.
 * @param subscriberId If applicable, the subscriber id of the network interface.
 * @param startTime Start of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime End of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @return Statistics object or null if permissions are insufficient or error happened during
 * statistics collection.
 */","/**
 * Query network usage statistics details. Result filtered to include only uids belonging to
 * calling user. Result is aggregated over state but not aggregated over time or uid. This means
 * buckets' start and end timestamps are going to be between 'startTime' and 'endTime'
 * parameters. State is going to be {@link NetworkStats.Bucket#STATE_ALL}, uid will vary,
 * tag {@link NetworkStats.Bucket#TAG_NONE} and roaming is going to be
 * {@link NetworkStats.Bucket#ROAMING_ALL}.
 * <p>Only includes buckets that atomically occur in the inclusive time range. Doesn't
 * interpolate across partial buckets. Since bucket length is in the order of hours, this
 * method cannot be used to measure data usage on a fine grained time scale.
 *
 * @param networkType As defined in {@link ConnectivityManager}, e.g.
 * {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}
 * etc.
 * @param subscriberId If applicable, the subscriber id of the network interface.
 * @param startTime Start of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime End of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @return Statistics object or null if permissions are insufficient or error happened during
 * statistics collection.
 */",1,,,0,0,0,0,1,"1,2,3","1,2","1,2","1,2","The return statement has changed from returning `null` directly after `createTemplate()` to only returning `null` if an exception is caught. Additionally, an exception handling statement has been introduced (catching `IllegalArgumentException`), so the code change type is 1,2.","The change in the return statement could lead to different behavior when the late version API is invoked, as `null` may not be returned when an exception is caught. The introduced exception handling statement could also lead to different behavior when the late version API is invoked, as an exception may be caught and handled instead of being thrown. Therefore, the CI type is 1,2."
11,"<android.app.usage.NetworkStatsManager: NetworkStats queryDetails(int,String,long,long)>",25,26,"<android.app.usage.NetworkStatsManager: NetworkStats queryDetails(int,String,long,long)>","<android.app.usage.NetworkStatsManager: NetworkStats queryDetails(int,String,long,long)>",0,"{
    NetworkTemplate template;
    try {
        template = createTemplate(networkType, subscriberId);
    } catch (IllegalArgumentException e) {
        if (DBG)
            Log.e(TAG, ""Cannot create template"", e);
        return null;
    }
    NetworkStats result;
    result = new NetworkStats(mContext, template, startTime, endTime);
    result.startUserUidEnumeration();
    return result;
}","{
    NetworkTemplate template;
    try {
        template = createTemplate(networkType, subscriberId);
    } catch (IllegalArgumentException e) {
        if (DBG)
            Log.e(TAG, ""Cannot create template"", e);
        return null;
    }
    NetworkStats result;
    result = new NetworkStats(mContext, template, startTime, endTime);
    result.startUserUidEnumeration();
    return result;
}",0,"/**
 * Query network usage statistics details. Result filtered to include only uids belonging to
 * calling user. Result is aggregated over state but not aggregated over time or uid. This means
 * buckets' start and end timestamps are going to be between 'startTime' and 'endTime'
 * parameters. State is going to be {@link NetworkStats.Bucket#STATE_ALL}, uid will vary,
 * tag {@link NetworkStats.Bucket#TAG_NONE} and roaming is going to be
 * {@link NetworkStats.Bucket#ROAMING_ALL}.
 * <p>Only includes buckets that atomically occur in the inclusive time range. Doesn't
 * interpolate across partial buckets. Since bucket length is in the order of hours, this
 * method cannot be used to measure data usage on a fine grained time scale.
 *
 * @param networkType As defined in {@link ConnectivityManager}, e.g.
 * {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}
 * etc.
 * @param subscriberId If applicable, the subscriber id of the network interface.
 * @param startTime Start of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime End of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @return Statistics object or null if permissions are insufficient or error happened during
 * statistics collection.
 */","/**
 * Query network usage statistics details. Result filtered to include only uids belonging to
 * calling user. Result is aggregated over state but not aggregated over time, uid, tag,
 * metered, nor roaming. This means buckets' start and end timestamps are going to be between
 * 'startTime' and 'endTime' parameters. State is going to be
 * {@link NetworkStats.Bucket#STATE_ALL}, uid will vary,
 * tag {@link NetworkStats.Bucket#TAG_NONE}, metered is going to be
 * {@link NetworkStats.Bucket#METERED_ALL}, and roaming is going to be
 * {@link NetworkStats.Bucket#ROAMING_ALL}.
 * <p>Only includes buckets that atomically occur in the inclusive time range. Doesn't
 * interpolate across partial buckets. Since bucket length is in the order of hours, this
 * method cannot be used to measure data usage on a fine grained time scale.
 *
 * @param networkType As defined in {@link ConnectivityManager}, e.g.
 * {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}
 * etc.
 * @param subscriberId If applicable, the subscriber id of the network interface.
 * @param startTime Start of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime End of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @return Statistics object or null if permissions are insufficient or error happened during
 * statistics collection.
 */",1,,,0,0,0,0,1,0,0,0,0,"The implementation and annotation of the given API are the same between the early and late versions, so there is no code change.","As there is no change in the implementation and annotation, there is no Compatibility Issue between the two versions."
12,"<android.app.usage.NetworkStatsManager: NetworkStats queryDetails(int,String,long,long)>",26,27,"<android.app.usage.NetworkStatsManager: NetworkStats queryDetails(int,String,long,long)>","<android.app.usage.NetworkStatsManager: NetworkStats queryDetails(int,String,long,long)>",0,"{
    NetworkTemplate template;
    try {
        template = createTemplate(networkType, subscriberId);
    } catch (IllegalArgumentException e) {
        if (DBG)
            Log.e(TAG, ""Cannot create template"", e);
        return null;
    }
    NetworkStats result;
    result = new NetworkStats(mContext, template, startTime, endTime);
    result.startUserUidEnumeration();
    return result;
}","{
    NetworkTemplate template;
    try {
        template = createTemplate(networkType, subscriberId);
    } catch (IllegalArgumentException e) {
        if (DBG)
            Log.e(TAG, ""Cannot create template"", e);
        return null;
    }
    NetworkStats result;
    result = new NetworkStats(mContext, template, mFlags, startTime, endTime);
    result.startUserUidEnumeration();
    return result;
}",1,"/**
 * Query network usage statistics details. Result filtered to include only uids belonging to
 * calling user. Result is aggregated over state but not aggregated over time, uid, tag,
 * metered, nor roaming. This means buckets' start and end timestamps are going to be between
 * 'startTime' and 'endTime' parameters. State is going to be
 * {@link NetworkStats.Bucket#STATE_ALL}, uid will vary,
 * tag {@link NetworkStats.Bucket#TAG_NONE}, metered is going to be
 * {@link NetworkStats.Bucket#METERED_ALL}, and roaming is going to be
 * {@link NetworkStats.Bucket#ROAMING_ALL}.
 * <p>Only includes buckets that atomically occur in the inclusive time range. Doesn't
 * interpolate across partial buckets. Since bucket length is in the order of hours, this
 * method cannot be used to measure data usage on a fine grained time scale.
 *
 * @param networkType As defined in {@link ConnectivityManager}, e.g.
 * {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}
 * etc.
 * @param subscriberId If applicable, the subscriber id of the network interface.
 * @param startTime Start of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime End of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @return Statistics object or null if permissions are insufficient or error happened during
 * statistics collection.
 */","/**
 * Query network usage statistics details. Result filtered to include only uids belonging to
 * calling user. Result is aggregated over state but not aggregated over time, uid, tag,
 * metered, nor roaming. This means buckets' start and end timestamps are going to be between
 * 'startTime' and 'endTime' parameters. State is going to be
 * {@link NetworkStats.Bucket#STATE_ALL}, uid will vary,
 * tag {@link NetworkStats.Bucket#TAG_NONE}, metered is going to be
 * {@link NetworkStats.Bucket#METERED_ALL}, and roaming is going to be
 * {@link NetworkStats.Bucket#ROAMING_ALL}.
 * <p>Only includes buckets that atomically occur in the inclusive time range. Doesn't
 * interpolate across partial buckets. Since bucket length is in the order of hours, this
 * method cannot be used to measure data usage on a fine grained time scale.
 *
 * @param networkType As defined in {@link ConnectivityManager}, e.g.
 * {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}
 * etc.
 * @param subscriberId If applicable, the subscriber id of the network interface.
 * @param startTime Start of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime End of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @return Statistics object or null if permissions are insufficient or error happened during
 * statistics collection.
 */",0,,,0,0,0,0,"1,2","1,5",1,"1, 5",1,"There is a new parameter `mFlags` added to the constructor call of `NetworkStats` class in the late version. Also, the constructor call is considered as a dependent API, so the change type is 1, 5.","As a new parameter is added to the constructor call, it could potentially lead to a different object of `NetworkStats` being created, which may have different behaviors when `result.startUserUidEnumeration()` is called. Therefore, it could be a Compatibility Issue caused by potential different return values or types (1)."
13,"<android.app.usage.NetworkStatsManager: NetworkStats queryDetails(int,String,long,long)>",27,28,"<android.app.usage.NetworkStatsManager: NetworkStats queryDetails(int,String,long,long)>","<android.app.usage.NetworkStatsManager: NetworkStats queryDetails(int,String,long,long)>",0,"{
    NetworkTemplate template;
    try {
        template = createTemplate(networkType, subscriberId);
    } catch (IllegalArgumentException e) {
        if (DBG)
            Log.e(TAG, ""Cannot create template"", e);
        return null;
    }
    NetworkStats result;
    result = new NetworkStats(mContext, template, mFlags, startTime, endTime);
    result.startUserUidEnumeration();
    return result;
}","{
    NetworkTemplate template;
    try {
        template = createTemplate(networkType, subscriberId);
    } catch (IllegalArgumentException e) {
        if (DBG)
            Log.e(TAG, ""Cannot create template"", e);
        return null;
    }
    NetworkStats result;
    result = new NetworkStats(mContext, template, mFlags, startTime, endTime, mService);
    result.startUserUidEnumeration();
    return result;
}",1,"/**
 * Query network usage statistics details. Result filtered to include only uids belonging to
 * calling user. Result is aggregated over state but not aggregated over time, uid, tag,
 * metered, nor roaming. This means buckets' start and end timestamps are going to be between
 * 'startTime' and 'endTime' parameters. State is going to be
 * {@link NetworkStats.Bucket#STATE_ALL}, uid will vary,
 * tag {@link NetworkStats.Bucket#TAG_NONE}, metered is going to be
 * {@link NetworkStats.Bucket#METERED_ALL}, and roaming is going to be
 * {@link NetworkStats.Bucket#ROAMING_ALL}.
 * <p>Only includes buckets that atomically occur in the inclusive time range. Doesn't
 * interpolate across partial buckets. Since bucket length is in the order of hours, this
 * method cannot be used to measure data usage on a fine grained time scale.
 *
 * @param networkType As defined in {@link ConnectivityManager}, e.g.
 * {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}
 * etc.
 * @param subscriberId If applicable, the subscriber id of the network interface.
 * @param startTime Start of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime End of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @return Statistics object or null if permissions are insufficient or error happened during
 * statistics collection.
 */","/**
 * Query network usage statistics details. Result filtered to include only uids belonging to
 * calling user. Result is aggregated over state but not aggregated over time, uid, tag,
 * metered, nor roaming. This means buckets' start and end timestamps are going to be between
 * 'startTime' and 'endTime' parameters. State is going to be
 * {@link NetworkStats.Bucket#STATE_ALL}, uid will vary,
 * tag {@link NetworkStats.Bucket#TAG_NONE},
 * default network is going to be {@link NetworkStats.Bucket#DEFAULT_NETWORK_ALL},
 * metered is going to be {@link NetworkStats.Bucket#METERED_ALL},
 * and roaming is going to be {@link NetworkStats.Bucket#ROAMING_ALL}.
 * <p>Only includes buckets that atomically occur in the inclusive time range. Doesn't
 * interpolate across partial buckets. Since bucket length is in the order of hours, this
 * method cannot be used to measure data usage on a fine grained time scale.
 *
 * @param networkType As defined in {@link ConnectivityManager}, e.g.
 * {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}
 * etc.
 * @param subscriberId If applicable, the subscriber id of the network interface.
 * @param startTime Start of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime End of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @return Statistics object or null if permissions are insufficient or error happened during
 * statistics collection.
 */",1,,,0,0,0,0,"1,2","1,5",1,"1,5",1,"The constructor of NetworkStats has changed from new NetworkStats(mContext, template, mFlags, startTime, endTime) to new NetworkStats(mContext, template, mFlags, startTime, endTime, mService), which means the dependent API NetworkStats has changed. This is a return statement change and dependent API change, so the code change type is 1,5.","The constructor change of NetworkStats may lead to different value of the object variable ""result"", which is returned by the API. Therefore, the Compatibility Issue type is 1."
14,<android.animation.ValueAnimator: long getFrameDelay()>,23,24,<android.animation.ValueAnimator: long getFrameDelay()>,<android.animation.ValueAnimator: long getFrameDelay()>,0,"{
    return Choreographer.getFrameDelay();
}","{
    return AnimationHandler.getInstance().getFrameDelay();
}",1,"/**
 * The amount of time, in milliseconds, between each frame of the animation. This is a
 * requested time that the animation will attempt to honor, but the actual delay between
 * frames may be different, depending on system load and capabilities. This is a static
 * function because the same delay will be applied to all animations, since they are all
 * run off of a single timing loop.
 *
 * The frame delay may be ignored when the animation system uses an external timing
 * source, such as the display refresh rate (vsync), to govern animations.
 *
 * @return the requested time between frames, in milliseconds
 */","/**
 * The amount of time, in milliseconds, between each frame of the animation. This is a
 * requested time that the animation will attempt to honor, but the actual delay between
 * frames may be different, depending on system load and capabilities. This is a static
 * function because the same delay will be applied to all animations, since they are all
 * run off of a single timing loop.
 *
 * The frame delay may be ignored when the animation system uses an external timing
 * source, such as the display refresh rate (vsync), to govern animations.
 *
 * Note that this method should be called from the same thread that {@link #start()} is
 * called in order to check the frame delay for that animation. A runtime exception will be
 * thrown if the calling thread does not have a Looper.
 *
 * @return the requested time between frames, in milliseconds
 */",1,,,0,0,0,0,1,1,1,5,1,"The method which gets called in the return statement has changed from 'Choreographer.getFrameDelay()' to 'AnimationHandler.getInstance().getFrameDelay()', this is considered as a Dependent API change.","As the method used to calculate the frame delay has changed, it is possible that the value returned by the late version of the API may differ from the early version, leading to a Compatibility Issue (CI) due to potential different return values."
16,<android.provider.Settings: boolean canDrawOverlays(Context)>,23,24,<android.provider.Settings: boolean canDrawOverlays(Context)>,<android.provider.Settings: boolean canDrawOverlays(Context)>,0,"{
    int uid = Binder.getCallingUid();
    return Settings.isCallingPackageAllowedToDrawOverlays(context, uid, Settings.getPackageNameForUid(context, uid), false);
}","{
    return Settings.isCallingPackageAllowedToDrawOverlays(context, Process.myUid(), context.getOpPackageName(), false);
}",1,"/**
 * An app can use this method to check if it is currently allowed to draw on top of other
 * apps. In order to be allowed to do so, an app must first declare the
 * {@link android.Manifest.permission#SYSTEM_ALERT_WINDOW} permission in its manifest. If it
 * is currently disallowed, it can prompt the user to grant it this capability through a
 * management UI by sending an Intent with action
 * {@link android.provider.Settings#ACTION_MANAGE_OVERLAY_PERMISSION}.
 *
 * @param context A context
 * @return true if the calling app can draw on top of other apps, false otherwise.
 */","/**
 * Checks if the specified context can draw on top of other apps. As of API
 * level 23, an app cannot draw on top of other apps unless it declares the
 * {@link android.Manifest.permission#SYSTEM_ALERT_WINDOW} permission in its
 * manifest, <em>and</em> the user specifically grants the app this
 * capability. To prompt the user to grant this approval, the app must send an
 * intent with the action
 * {@link android.provider.Settings#ACTION_MANAGE_OVERLAY_PERMISSION}, which
 * causes the system to display a permission management screen.
 *
 * @param context App context.
 * @return true if the specified context can draw on top of other apps, false otherwise
 */",1,,,0,0,0,0,"1,2","1,5",1,5,1,"The implementation of the method has changed from using `Binder.getCallingUid()` to `Process.myUid()` and from `Settings.getPackageNameForUid(context, uid)` to `context.getOpPackageName()`. These changes are considered as dependent API changes, thus the change type is 5.","The changes in the API implementation could lead to different return values, as the `Binder.getCallingUid()` may not always return the same value as `Process.myUid()`, and `Settings.getPackageNameForUid(context, uid)` may not always return the same value as `context.getOpPackageName()`. Therefore, it is a compatibility issue caused by potential different return values, so the CI type is 1."
18,<android.app.NotificationManager.Policy: String toString()>,23,24,<android.app.NotificationManager.Policy: String toString()>,<android.app.NotificationManager.Policy: String toString()>,0,"{
    return ""NotificationManager.Policy["" + ""priorityCategories="" + priorityCategoriesToString(priorityCategories) + "",priorityCallSenders="" + prioritySendersToString(priorityCallSenders) + "",priorityMessageSenders="" + prioritySendersToString(priorityMessageSenders) + ""]"";
}","{
    return ""NotificationManager.Policy["" + ""priorityCategories="" + priorityCategoriesToString(priorityCategories) + "",priorityCallSenders="" + prioritySendersToString(priorityCallSenders) + "",priorityMessageSenders="" + prioritySendersToString(priorityMessageSenders) + "",suppressedVisualEffects="" + suppressedEffectsToString(suppressedVisualEffects) + ""]"";
}",1,,,0,[@Override],[@Override],0,0,0,0,1,1,1,1,1,"The return statement in the late version has an additional parameter ""suppressedVisualEffects="" + suppressedEffectsToString(suppressedVisualEffects) compared to the early version, so the code change type is 1.","As the return statement has changed, the API potentially returns a different value, which could leads to different behaviours. Therefore, the CI type is 1."
19,<android.app.NotificationManager.Policy: String toString()>,27,28,<android.app.NotificationManager.Policy: String toString()>,<android.app.NotificationManager.Policy: String toString()>,0,"{
    return ""NotificationManager.Policy["" + ""priorityCategories="" + priorityCategoriesToString(priorityCategories) + "",priorityCallSenders="" + prioritySendersToString(priorityCallSenders) + "",priorityMessageSenders="" + prioritySendersToString(priorityMessageSenders) + "",suppressedVisualEffects="" + suppressedEffectsToString(suppressedVisualEffects) + ""]"";
}","{
    return ""NotificationManager.Policy["" + ""priorityCategories="" + priorityCategoriesToString(priorityCategories) + "",priorityCallSenders="" + prioritySendersToString(priorityCallSenders) + "",priorityMessageSenders="" + prioritySendersToString(priorityMessageSenders) + "",suppressedVisualEffects="" + suppressedEffectsToString(suppressedVisualEffects) + "",areChannelsBypassingDnd="" + (((state & STATE_CHANNELS_BYPASSING_DND) != 0) ? ""true"" : ""false"") + ""]"";
}",1,,,0,[@Override],[@Override],0,0,0,0,1,1,1,1,1,"The return statement is changed. Specifically, in the late version, an additional attribute ""areChannelsBypassingDnd"" is appended to the string to be returned.","The change in return statement can lead to different behaviours, as the string representation of the object has been changed. Therefore, the Compatibility Issue type is 1 -- Compatibility Issue caused by potential different return values or types."
23,<android.text.Html: String toHtml(Spanned)>,23,24,<android.text.Html: String toHtml(Spanned)>,<android.text.Html: String toHtml(Spanned)>,0,"{
    StringBuilder out = new StringBuilder();
    withinHtml(out, text);
    return out.toString();
}","{
    return toHtml(text, TO_HTML_PARAGRAPH_LINES_CONSECUTIVE);
}",1,"/**
 * Returns an HTML representation of the provided Spanned text. A best effort is
 * made to add HTML tags corresponding to spans. Also note that HTML metacharacters
 * (such as ""&lt;"" and ""&amp;"") within the input text are escaped.
 *
 * @param text input text to convert
 * @return string containing input converted to HTML
 */","/**
 * @deprecated use {@link #toHtml(Spanned, int)} instead.
 */",1,,[@Deprecated],1,0,0,0,1,"1,4,5",1,"1,5",1,"The code change type is 1,5 because the return statement has changed and a new dependent API is introduced. In the early version, the API uses a StringBuilder to build the HTML string and returns it. In the late version, the API calls the `toHtml` method with two arguments and returns the result. The second argument is a constant that determines whether consecutive paragraphs should be separated by a `<br>` tag.","The Compatibility Issue type is 1 because the change in return statements could lead to different behaviors. In the early version, the HTML string is built using the `withinHtml` method, which might not be the same as the `toHtml` method used in the late version. Additionally, the early version does not have the option to separate consecutive paragraphs with a `<br>` tag. These differences in implementation could lead to different return values for the same input."
27,<android.app.Activity: void stopLockTask()>,27,28,<android.app.Activity: void stopLockTask()>,<android.app.Activity: void stopLockTask()>,0,"{
    try {
        ActivityManager.getService().stopLockTaskMode();
    } catch (RemoteException e) {
    }
}","{
    try {
        ActivityManager.getService().stopLockTaskModeByToken(mToken);
    } catch (RemoteException e) {
    }
}",1,"/**
 * Allow the user to switch away from the current task.
 *
 * Called to end the mode started by {@link Activity#startLockTask}. This
 * can only be called by activities that have successfully called
 * startLockTask previously.
 *
 * This will allow the user to exit this app and move onto other activities.
 * <p>Note: This method should only be called when the activity is user-facing. That is,
 * between onResume() and onPause().
 * <p>Note: If there are other tasks below this one that are also locked then calling this
 * method will immediately finish this task and resume the previous locked one, remaining in
 * lockTask mode.
 *
 * @see android.R.attr#lockTaskMode
 * @see ActivityManager#getLockTaskModeState()
 */","/**
 * Stop the current task from being locked.
 *
 * <p>Called to end the LockTask or screen pinning mode started by {@link #startLockTask()}.
 * This can only be called by activities that have called {@link #startLockTask()} previously.
 *
 * <p><strong>Note:</strong> If the device is in LockTask mode that is not initially started
 * by this activity, then calling this method will not terminate the LockTask mode, but only
 * finish its own task. The device will remain in LockTask mode, until the activity which
 * started the LockTask mode calls this method, or until its whitelist authorization is revoked
 * by {@link DevicePolicyManager#setLockTaskPackages(ComponentName, String[])}.
 *
 * @see #startLockTask()
 * @see android.R.attr#lockTaskMode
 * @see ActivityManager#getLockTaskModeState()
 */",1,,,0,0,0,0,1,4,0,5,1,The method call `ActivityManager.getService().stopLockTaskMode();` has been changed to `ActivityManager.getService().stopLockTaskModeByToken(mToken);`. This is a dependent API change as the method name and its parameter have been modified.,"Since the called method has been changed, this could lead to different behaviors in the late version, potentially causing the API to return a different variable (value or type) or throw exceptions differently. Therefore, it is a compatibility issue caused by potential different return values or types."
28,<android.app.Activity: void stopLockTask()>,28,29,<android.app.Activity: void stopLockTask()>,<android.app.Activity: void stopLockTask()>,0,"{
    try {
        ActivityManager.getService().stopLockTaskModeByToken(mToken);
    } catch (RemoteException e) {
    }
}","{
    try {
        ActivityTaskManager.getService().stopLockTaskModeByToken(mToken);
    } catch (RemoteException e) {
    }
}",1,"/**
 * Stop the current task from being locked.
 *
 * <p>Called to end the LockTask or screen pinning mode started by {@link #startLockTask()}.
 * This can only be called by activities that have called {@link #startLockTask()} previously.
 *
 * <p><strong>Note:</strong> If the device is in LockTask mode that is not initially started
 * by this activity, then calling this method will not terminate the LockTask mode, but only
 * finish its own task. The device will remain in LockTask mode, until the activity which
 * started the LockTask mode calls this method, or until its whitelist authorization is revoked
 * by {@link DevicePolicyManager#setLockTaskPackages(ComponentName, String[])}.
 *
 * @see #startLockTask()
 * @see android.R.attr#lockTaskMode
 * @see ActivityManager#getLockTaskModeState()
 */","/**
 * Stop the current task from being locked.
 *
 * <p>Called to end the LockTask or screen pinning mode started by {@link #startLockTask()}.
 * This can only be called by activities that have called {@link #startLockTask()} previously.
 *
 * <p><strong>Note:</strong> If the device is in LockTask mode that is not initially started
 * by this activity, then calling this method will not terminate the LockTask mode, but only
 * finish its own task. The device will remain in LockTask mode, until the activity which
 * started the LockTask mode calls this method, or until its whitelist authorization is revoked
 * by {@link DevicePolicyManager#setLockTaskPackages(ComponentName, String[])}.
 *
 * @see #startLockTask()
 * @see android.R.attr#lockTaskMode
 * @see ActivityManager#getLockTaskModeState()
 */",0,,,0,0,0,0,1,4,0,5,1,"The implementation of the stopLockTask() API has changed the class name from 'ActivityManager' to 'ActivityTaskManager' in order to use a different service. This is a Dependent API change, thus the code change type is 5.","As the stopLockTask() API now relies on a different service, it could potentially return different values or throw different exceptions, leading to a Compatibility Issue. Therefore, the CI type is 1."
29,<android.animation.ValueAnimator: void end()>,23,24,<android.animation.ValueAnimator: void end()>,<android.animation.ValueAnimator: void end()>,0,"{
    AnimationHandler handler = getOrCreateAnimationHandler();
    if (!handler.mAnimations.contains(this) && !handler.mPendingAnimations.contains(this)) {
        // Special case if the animation has not yet started; get it ready for ending
        mStartedDelay = false;
        startAnimation(handler);
        mStarted = true;
    } else if (!mInitialized) {
        initAnimation();
    }
    animateValue(mPlayingBackwards ? 0f : 1f);
    endAnimation(handler);
}","{
    if (Looper.myLooper() == null) {
        throw new AndroidRuntimeException(""Animators may only be run on Looper threads"");
    }
    if (!mRunning) {
        // Special case if the animation has not yet started; get it ready for ending
        startAnimation();
        mStarted = true;
    } else if (!mInitialized) {
        initAnimation();
    }
    animateValue(shouldPlayBackward(mRepeatCount) ? 0f : 1f);
    endAnimation();
}",1,,,0,[@Override],[@Override],0,0,0,0,1,"2,3,4",2,"1,2,3,5","1,2",There are several changes between the early and late implementation:,"3. The `animateValue()` method call has a new argument `shouldPlayBackward(mRepeatCount) ? 0f : 1f`, which is a return statement change (1)."
31,"<android.content.res.Resources: Drawable loadDrawable(TypedValue,int,Theme)>",23,24,"<android.content.res.Resources: Drawable loadDrawable(TypedValue,int,Theme)>","<android.content.res.Resources: Drawable loadDrawable(TypedValue,int,Theme)>",0,"{
    if (TRACE_FOR_PRELOAD) {
        // Log only framework resources
        if ((id >>> 24) == 0x1) {
            final String name = getResourceName(id);
            if (name != null) {
                Log.d(""PreloadDrawable"", name);
            }
        }
    }
    final boolean isColorDrawable;
    final DrawableCache caches;
    final long key;
    if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {
        isColorDrawable = true;
        caches = mColorDrawableCache;
        key = value.data;
    } else {
        isColorDrawable = false;
        caches = mDrawableCache;
        key = (((long) value.assetCookie) << 32) | value.data;
    }
    // that was inflated against the specified theme.
    if (!mPreloading) {
        final Drawable cachedDrawable = caches.getInstance(key, theme);
        if (cachedDrawable != null) {
            return cachedDrawable;
        }
    }
    // Next, check preloaded drawables. These may contain unresolved theme
    // attributes.
    final ConstantState cs;
    if (isColorDrawable) {
        cs = sPreloadedColorDrawables.get(key);
    } else {
        cs = sPreloadedDrawables[mConfiguration.getLayoutDirection()].get(key);
    }
    Drawable dr;
    if (cs != null) {
        dr = cs.newDrawable(this);
    } else if (isColorDrawable) {
        dr = new ColorDrawable(value.data);
    } else {
        dr = loadDrawableForCookie(value, id, null);
    }
    // Determine if the drawable has unresolved theme attributes. If it
    // does, we'll need to apply a theme and store it in a theme-specific
    // cache.
    final boolean canApplyTheme = dr != null && dr.canApplyTheme();
    if (canApplyTheme && theme != null) {
        dr = dr.mutate();
        dr.applyTheme(theme);
        dr.clearMutated();
    }
    // cache: preload, not themed, null theme, or theme-specific.
    if (dr != null) {
        dr.setChangingConfigurations(value.changingConfigurations);
        cacheDrawable(value, isColorDrawable, caches, theme, canApplyTheme, key, dr);
    }
    return dr;
}","{
    return mResourcesImpl.loadDrawable(this, value, id, theme, true);
}",1,,,0,[@Nullable],[@NonNull],1,0,0,0,"1,2","1,3,4",1,5,1,"The implementation of the method has been completely changed, from a long block of code to a single line calling a different method. This is a dependent API change, so the change type is 5.","The new implementation of the method calls a different method, so it is possible that the method will return a different value, leading to a compatibility issue. Therefore, the CI type is 1."
32,<android.os.BatteryManager: boolean isCharging()>,23,24,<android.os.BatteryManager: boolean isCharging()>,<android.os.BatteryManager: boolean isCharging()>,0,"{
    try {
        return mBatteryStats.isCharging();
    } catch (RemoteException e) {
        return true;
    }
}","{
    try {
        return mBatteryStats.isCharging();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Return true if the battery is currently considered to be charging.  This means that
 * the device is plugged in and is supplying sufficient power that the battery level is
 * going up (or the battery is fully charged).  Changes in this state are matched by
 * broadcasts of {@link #ACTION_CHARGING} and {@link #ACTION_DISCHARGING}.
 */
","/**
 * Return true if the battery is currently considered to be charging.  This means that
 * the device is plugged in and is supplying sufficient power that the battery level is
 * going up (or the battery is fully charged).  Changes in this state are matched by
 * broadcasts of {@link #ACTION_CHARGING} and {@link #ACTION_DISCHARGING}.
 */
",0,,,0,0,0,0,1,"1,2","1,2","1,2","1,2","The code change is in the catch block of the try-catch statement. In the early version, the catch block returns a boolean value (true), whereas in the late version, it throws an exception using the rethrowFromSystemServer() method. This change affects both the return value and the exception handling of the method.",The change in code can lead to compatibility issues of both types:
33,<android.app.ApplicationContext: Drawable peekWallpaper()>,4,5,<android.app.ApplicationContext: Drawable peekWallpaper()>,<android.app.ApplicationContext: Drawable peekWallpaper()>,0,"{
    if (mWallpaper != null) {
        return mWallpaper;
    }
    mWallpaperCallback = new WallpaperCallback(this);
    mWallpaper = getCurrentWallpaperLocked();
    return mWallpaper;
}","{
    return getWallpaperManager().peekDrawable();
}",1,,,0,[@Override],[@Override],0,0,0,0,1,"1,3,4",1,"1, 5",1,The original implementation of peekWallpaper() which returned the value of mWallpaper has been replaced with a call to getWallpaperManager().peekDrawable().,"Since the implementation of getWallpaperManager().peekDrawable() may return a different Drawable than mWallpaper, this change can lead to compatibility issues due to different return values."
35,"<android.content.pm.ResolveInfo: void dump(Printer,String)>",4,5,"<android.content.pm.ResolveInfo: void dump(Printer,String)>","<android.content.pm.ResolveInfo: void dump(Printer,String)>",0,"{
    if (filter != null) {
        pw.println(prefix + ""Filter:"");
        filter.dump(pw, prefix + ""  "");
    } else {
        pw.println(prefix + ""Filter: null"");
    }
    pw.println(prefix + ""priority="" + priority + "" preferredOrder="" + preferredOrder + "" match=0x"" + Integer.toHexString(match) + "" specificIndex="" + specificIndex + "" isDefault="" + isDefault);
    pw.println(prefix + ""labelRes=0x"" + Integer.toHexString(labelRes) + "" nonLocalizedLabel="" + nonLocalizedLabel + "" icon=0x"" + Integer.toHexString(icon));
    if (activityInfo != null) {
        pw.println(prefix + ""ActivityInfo:"");
        activityInfo.dump(pw, prefix + ""  "");
    } else if (serviceInfo != null) {
        pw.println(prefix + ""ServiceInfo:"");
    // TODO
    // serviceInfo.dump(pw, prefix + ""  "");
    }
}","{
    if (filter != null) {
        pw.println(prefix + ""Filter:"");
        filter.dump(pw, prefix + ""  "");
    }
    pw.println(prefix + ""priority="" + priority + "" preferredOrder="" + preferredOrder + "" match=0x"" + Integer.toHexString(match) + "" specificIndex="" + specificIndex + "" isDefault="" + isDefault);
    if (resolvePackageName != null) {
        pw.println(prefix + ""resolvePackageName="" + resolvePackageName);
    }
    if (labelRes != 0 || nonLocalizedLabel != null || icon != 0) {
        pw.println(prefix + ""labelRes=0x"" + Integer.toHexString(labelRes) + "" nonLocalizedLabel="" + nonLocalizedLabel + "" icon=0x"" + Integer.toHexString(icon));
    }
    if (activityInfo != null) {
        pw.println(prefix + ""ActivityInfo:"");
        activityInfo.dump(pw, prefix + ""  "");
    } else if (serviceInfo != null) {
        pw.println(prefix + ""ServiceInfo:"");
        serviceInfo.dump(pw, prefix + ""  "");
    }
}",1,,,0,,,0,0,0,0,1,"2,4",0,3,1,"The addition of a new condition statement for printing ""resolvePackageName"" and the modification of the condition statement for printing labelRes, nonLocalizedLabel, and icon are control dependency changes.","As the new condition statement has been added and the old one has been modified, the printed output could be different between the two versions, leading to a compatibility issue caused by potential different return values."
36,<android.webkit.WebView: void clearMatches()>,4,5,<android.webkit.WebView: void clearMatches()>,<android.webkit.WebView: void clearMatches()>,0,"{
    mFindIsUp = false;
    nativeSetFindIsDown();
    // Now that the dialog has been removed, ensure that we scroll to a
    // location that is not beyond the end of the page.
    pinScrollTo(mScrollX, mScrollY, false, 0);
    invalidate();
}","{
    if (mFindIsUp) {
        recordNewContentSize(mContentWidth, mContentHeight - mFindHeight, false);
        mFindIsUp = false;
    }
    nativeSetFindIsDown();
    // Now that the dialog has been removed, ensure that we scroll to a
    // location that is not beyond the end of the page.
    pinScrollTo(mScrollX, mScrollY, false, 0);
    invalidate();
}",1,"/*
     * Clear the highlighting surrounding text matches created by findAll.
     */
","/*
     * Clear the highlighting surrounding text matches created by findAll.
     */
",0,,,0,0,0,0,1,"2,4",0,3,1,"The early version of the method does not have the if statement that checks whether ""mFindIsUp"" is true before executing ""recordNewContentSize"" and setting ""mFindIsUp"" to false. In the late version, this if statement was added.","If ""mFindIsUp"" is true, the late version of the method will execute ""recordNewContentSize"" and set ""mFindIsUp"" to false, while the early version will just set ""mFindIsUp"" to false. This difference in behavior could lead to a compatibility issue, as the late version may have different return values or types compared to the early version."
37,<android.widget.VideoView: boolean isPlaying()>,4,5,<android.widget.VideoView: boolean isPlaying()>,<android.widget.VideoView: boolean isPlaying()>,0,"{
    if (mMediaPlayer != null && mIsPrepared) {
        return mMediaPlayer.isPlaying();
    }
    return false;
}","{
    return isInPlaybackState() && mMediaPlayer.isPlaying();
}",1,,,0,,,0,0,0,0,1,"1,2",1,"1,5",1,"The return statement has changed from checking if `mMediaPlayer` is not null and `mIsPrepared` is true, to checking if the result of `isInPlaybackState()` and `mMediaPlayer.isPlaying()` is true, thus the code change type is 1 (Return statement changed) and 5 (Dependent API changed).","The new return statement may return a different value than the previous one as the condition for returning true has changed, thus there is a compatibility issue caused by potential different return values (CI type 1)."
39,<android.view.Surface: String toString()>,4,5,<android.view.Surface: String toString()>,<android.view.Surface: String toString()>,0,"{
    return ""Surface(native-token="" + mSurface + "")"";
}","{
    return ""Surface(native-token="" + mSurfaceControl + "")"";
}",1,,,0,[@Override],[@Override],0,0,0,0,1,1,1,1,1,"The return statement has changed from ""Surface(native-token="" + mSurface + "")"" to ""Surface(native-token="" + mSurfaceControl + "")"", which means the value of the returned string has changed.","The return value of the API has changed, which means that the API could potentially return a different string value in the late version. This could lead to compatibility issues in the calling code if it relies on the specific string format being returned. Therefore, the compatibility issue type is 1."
40,<android.webkit.BrowserFrame: void didFirstLayout()>,4,5,<android.webkit.BrowserFrame: void didFirstLayout()>,<android.webkit.BrowserFrame: void didFirstLayout()>,0,"{
    if (!mFirstLayoutDone) {
        mFirstLayoutDone = true;
        // ensure {@link WebViewCore#webkitDraw} is called as we were
        // blocking the update in {@link #loadStarted}
        mWebViewCore.contentDraw();
    }
    mWebViewCore.mEndScaleZoom = true;
}","{
    if (!mFirstLayoutDone) {
        mFirstLayoutDone = true;
        // ensure {@link WebViewCore#webkitDraw} is called as we were
        // blocking the update in {@link #loadStarted}
        mWebViewCore.contentDraw();
    }
}",1,"/* package */
","/* package */
",0,,,0,0,0,0,1,"3,4",0,3,1,The code change is a control dependency change as the statement `mWebViewCore.mEndScaleZoom = true;` has been removed from the late implementation.,"As the statement `mWebViewCore.mEndScaleZoom = true;` has been removed from the late implementation, this could lead to a different behavior of the API, specifically, the value of `mEndScaleZoom` in `mWebViewCore` will not be set as `true` in the late version, and this potentially leads to different return values or types in the dependent API, so it is a Compatibility Issue caused by potential different return values or types."
41,<android.hardware.Camera.Parameters: void setPictureFormat(int)>,4,5,<android.hardware.Camera.Parameters: void setPictureFormat(int)>,<android.hardware.Camera.Parameters: void setPictureFormat(int)>,0,"{
    String s = cameraFormatForPixelFormat(pixel_format);
    if (s == null) {
        throw new IllegalArgumentException();
    }
    set(""picture-format"", s);
}","{
    String s = cameraFormatForPixelFormat(pixel_format);
    if (s == null) {
        throw new IllegalArgumentException(""Invalid pixel_format="" + pixel_format);
    }
    set(KEY_PICTURE_FORMAT, s);
}",1,"/**
 * Sets the image format for pictures.
 *
 * @param pixel_format the desired picture format
 * (<var>PixelFormat.YCbCr_420_SP</var>,
 * <var>PixelFormat.RGB_565</var>, or
 * <var>PixelFormat.JPEG</var>)
 * @see android.graphics.PixelFormat
 */
","/**
 * Sets the image format for pictures.
 *
 * @param pixel_format the desired picture format
 * (<var>PixelFormat.YCbCr_420_SP (NV21)</var>,
 * <var>PixelFormat.RGB_565</var>, or
 * <var>PixelFormat.JPEG</var>)
 * @see android.graphics.PixelFormat
 */
",1,,,0,0,0,0,"1,2","2,3,4,5",2,"2, 4","1, 2","The exception handling statement has changed: a new message is added to the IllegalArgumentException. Also, the string parameter in the set() method has changed.","The new message in the IllegalArgumentException may cause different behaviors in the exception handling process, leading to a compatibility issue. The change in the string parameter of the set() method may also cause different behaviors in the API, potentially resulting in a compatibility issue."
42,<android.hardware.Camera.Parameters: Size getPictureSize()>,4,5,<android.hardware.Camera.Parameters: Size getPictureSize()>,<android.hardware.Camera.Parameters: Size getPictureSize()>,0,"{
    String pair = get(""picture-size"");
    if (pair == null)
        return null;
    String[] dims = pair.split(""x"");
    if (dims.length != 2)
        return null;
    return new Size(Integer.parseInt(dims[0]), Integer.parseInt(dims[1]));
}","{
    String pair = get(KEY_PICTURE_SIZE);
    return strToSize(pair);
}",1,"/**
 * Returns the dimension setting for pictures.
 *
 * @return a Size object with the height and width setting
 * for pictures
 */
","/**
 * Returns the dimension setting for pictures.
 *
 * @return a Size object with the height and width setting
 * for pictures
 */
",0,,,0,0,0,0,1,"1,3,4",1,"1,5",1,"The code change involves both a return statement change and a dependent API change. The early version returns the result of `new Size(Integer.parseInt(dims[0]), Integer.parseInt(dims[1]))`, while the late version returns the result of `strToSize(pair)`. Additionally, the dependent API has been changed from `get(""picture-size"")` to `get(KEY_PICTURE_SIZE)`.","The CI type is 1 because the change of the return statement can lead to different return values, and the change of dependent API `get(""picture-size"")` to `get(KEY_PICTURE_SIZE)` may also lead to different return values."
43,<android.animation.ValueAnimator: void end()>,15,16,<android.animation.ValueAnimator: void end()>,<android.animation.ValueAnimator: void end()>,0,"{
    if (!sAnimations.get().contains(this) && !sPendingAnimations.get().contains(this)) {
        // Special case if the animation has not yet started; get it ready for ending
        mStartedDelay = false;
        startAnimation();
    } else if (!mInitialized) {
        initAnimation();
    }
    // was supposed to repeat an odd number of times
    if (mRepeatCount > 0 && (mRepeatCount & 0x01) == 1) {
        animateValue(0f);
    } else {
        animateValue(1f);
    }
    endAnimation();
}","{
    AnimationHandler handler = getOrCreateAnimationHandler();
    if (!handler.mAnimations.contains(this) && !handler.mPendingAnimations.contains(this)) {
        // Special case if the animation has not yet started; get it ready for ending
        mStartedDelay = false;
        startAnimation(handler);
        mStarted = true;
    } else if (!mInitialized) {
        initAnimation();
    }
    // was supposed to repeat an odd number of times
    if (mRepeatCount > 0 && (mRepeatCount & 0x01) == 1) {
        animateValue(0f);
    } else {
        animateValue(1f);
    }
    endAnimation(handler);
}",1,,,0,[@Override],[@Override],0,0,0,0,"1,2","3,4",0,"3,5","1,2","The implementation of the `end()` method has undergone changes that affect both control dependency and dependent API. Specifically, the `getOrCreateAnimationHandler()` method is introduced, and the `startAnimation()` and `endAnimation()` methods have been changed to include the `handler` parameter.","The changes in the `end()` method could lead to different behaviors in the late version. The `getOrCreateAnimationHandler()` method could return a different `handler` object, which would affect the behaviors of the `startAnimation(handler)` and `endAnimation(handler)` methods. Moreover, if the `handler` is not properly set, it could throw a different exception in the late version. Therefore, the compatibility issue could arise due to potential different return values or types, or potential different exception handlings."
44,<android.app.Activity: void onConfigurationChanged(Configuration)>,15,16,<android.app.Activity: void onConfigurationChanged(Configuration)>,<android.app.Activity: void onConfigurationChanged(Configuration)>,0,"{
    mCalled = true;
    mFragments.dispatchConfigurationChanged(newConfig);
    if (mWindow != null) {
        // Pass the configuration changed event to the window
        mWindow.onConfigurationChanged(newConfig);
    }
    if (mActionBar != null) {
        // Do this last; the action bar will need to access
        // view changes from above.
        mActionBar.onConfigurationChanged(newConfig);
    }
}","{
    if (DEBUG_LIFECYCLE)
        Slog.v(TAG, ""onConfigurationChanged "" + this + "": "" + newConfig);
    mCalled = true;
    mFragments.dispatchConfigurationChanged(newConfig);
    if (mWindow != null) {
        // Pass the configuration changed event to the window
        mWindow.onConfigurationChanged(newConfig);
    }
    if (mActionBar != null) {
        // Do this last; the action bar will need to access
        // view changes from above.
        mActionBar.onConfigurationChanged(newConfig);
    }
}",1,"/**
 * Called by the system when the device configuration changes while your
 * activity is running.  Note that this will <em>only</em> be called if
 * you have selected configurations you would like to handle with the
 * {@link android.R.attr#configChanges} attribute in your manifest.  If
 * any configuration change occurs that is not selected to be reported
 * by that attribute, then instead of reporting it the system will stop
 * and restart the activity (to have it launched with the new
 * configuration).
 *
 * <p>At the time that this function has been called, your Resources
 * object will have been updated to return resource values matching the
 * new configuration.
 *
 * @param newConfig The new device configuration.
 */
","/**
 * Called by the system when the device configuration changes while your
 * activity is running.  Note that this will <em>only</em> be called if
 * you have selected configurations you would like to handle with the
 * {@link android.R.attr#configChanges} attribute in your manifest.  If
 * any configuration change occurs that is not selected to be reported
 * by that attribute, then instead of reporting it the system will stop
 * and restart the activity (to have it launched with the new
 * configuration).
 *
 * <p>At the time that this function has been called, your Resources
 * object will have been updated to return resource values matching the
 * new configuration.
 *
 * @param newConfig The new device configuration.
 */
",0,,,0,0,0,0,1,"3,4",0,4,0,"Only a logging statement has been added before `mCalled = true;` in the late version. Thus, the code change type is 4 - Other statement changed.",The added logging statement has no impact on the execution flow or output of the API. So there is no Compatibility Issue.
45,<android.webkit.WebSettings: void setBuiltInZoomControls(boolean)>,15,16,<android.webkit.WebSettings: void setBuiltInZoomControls(boolean)>,<android.webkit.WebSettings: void setBuiltInZoomControls(boolean)>,0,"{
    mBuiltInZoomControls = enabled;
    mWebView.updateMultiTouchSupport(mContext);
}","{
    throw new MustOverrideException();
}",1,"/**
 * Sets whether the zoom mechanism built into WebView is used.
 */
","// {@link WebView#getZoomControls}, which is now hidden.
",1,,,0,0,0,0,1,"2,4",2,"1, 5",1,"The implementation of the method has changed completely, where the early version sets a variable and calls a method, while the late version throws an exception. This is a combination of a return statement change (1) and dependent API change (5), as the behavior of the method is completely different and it now relies on the MustOverrideException class.","The change in implementation can lead to a compatibility issue (CI) of type 1, as the behavior of the method has changed completely. In the early version, the method sets a variable and calls a method, while in the late version, it throws an exception. This can cause different behaviors in client code that calls this method, as it may not expect an exception to be thrown."
47,<android.view.MenuInflater.InflatedOnMenuItemClickListener: boolean onMenuItemClick(MenuItem)>,15,16,<android.view.MenuInflater.InflatedOnMenuItemClickListener: boolean onMenuItemClick(MenuItem)>,<android.view.MenuInflater.InflatedOnMenuItemClickListener: boolean onMenuItemClick(MenuItem)>,0,"{
    try {
        if (mMethod.getReturnType() == Boolean.TYPE) {
            return (Boolean) mMethod.invoke(mContext, item);
        } else {
            mMethod.invoke(mContext, item);
            return true;
        }
    } catch (Exception e) {
        throw new RuntimeException(e);
    }
}","{
    try {
        if (mMethod.getReturnType() == Boolean.TYPE) {
            return (Boolean) mMethod.invoke(mRealOwner, item);
        } else {
            mMethod.invoke(mRealOwner, item);
            return true;
        }
    } catch (Exception e) {
        throw new RuntimeException(e);
    }
}",1,,,0,,,0,0,0,0,"1,2","1,5",1,5,1,"The API implementation relies on another API (mMethod.invoke), and the dependent API has undergone changes. Specifically, the argument of the mMethod.invoke method has changed from mContext to mRealOwner. This change type belongs to class 5) Dependent API changed.","As the argument of the mMethod.invoke method has changed, the API potentially returns different values, which could lead to different behaviours. Therefore, it should be regarded as a Compatibility Issue caused by potential different return values or types, which belongs to class 1) Compatibility Issue caused by potential different return values or types."
49,"<android.content.ContentProviderClient: int update(Uri,ContentValues,String,String[])>",15,16,"<android.content.ContentProviderClient: int update(Uri,ContentValues,String,String[])>","<android.content.ContentProviderClient: int update(Uri,ContentValues,String,String[])>",0,"{
    return mContentProvider.update(url, values, selection, selectionArgs);
}","{
    try {
        return mContentProvider.update(url, values, selection, selectionArgs);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    }
}",1,"/**
 * See {@link ContentProvider#update ContentProvider.update}
 */
","/**
 * See {@link ContentProvider#update ContentProvider.update}
 */
",0,,,0,0,0,0,1,"1,2,3,4","1,2","1,2",2,"The return statement is still the same, but a try-catch block has been introduced to handle the DeadObjectException in the late version.","The change in the exception handling can cause the API to throw a different exception, potentially leading to a compatibility issue. Specifically, the API in the late version can throw a DeadObjectException, while the early version does not have this exception handling. Therefore, this is a Compatibility Issue caused by potential different exception handlings."
52,<android.widget.TextView: void onStartTemporaryDetach()>,15,16,<android.widget.TextView: void onStartTemporaryDetach()>,<android.widget.TextView: void onStartTemporaryDetach()>,0,"{
    super.onStartTemporaryDetach();
    // usually because this instance is an editable field in a list
    if (!mDispatchTemporaryDetach)
        mTemporaryDetach = true;
    // Because of View recycling in ListView, there is no easy way to know when a TextView with
    // selection becomes visible again. Until a better solution is found, stop text selection
    // mode (if any) as soon as this TextView is recycled.
    hideControllers();
}","{
    super.onStartTemporaryDetach();
    // usually because this instance is an editable field in a list
    if (!mDispatchTemporaryDetach)
        mTemporaryDetach = true;
    // selection state as needed.
    if (mEditor != null)
        mEditor.mTemporaryDetach = true;
}",1,,,0,[@Override],[@Override],0,0,0,0,1,"3,4",0,4,0,"A new statement ""if (mEditor != null) mEditor.mTemporaryDetach = true;"" has been added, while the statement ""hideControllers();"" has been deleted. The change of code does not belong to any of the first four categories, so it is classified as ""Other statement changed"".","The added statement ""if (mEditor != null) mEditor.mTemporaryDetach = true;"" does not affect the returns or exceptions of the API. The deleted statement ""hideControllers();"" only hides the controllers of the TextView, which does not have any impact on the returns or exceptions of the API either. Therefore, there is no Compatibility Issue caused by this code change."
53,<android.widget.NumberPicker: void setEnabled(boolean)>,15,16,<android.widget.NumberPicker: void setEnabled(boolean)>,<android.widget.NumberPicker: void setEnabled(boolean)>,0,"{
    super.setEnabled(enabled);
    mIncrementButton.setEnabled(enabled);
    mDecrementButton.setEnabled(enabled);
    mInputText.setEnabled(enabled);
}","{
    super.setEnabled(enabled);
    if (!mHasSelectorWheel) {
        mIncrementButton.setEnabled(enabled);
    }
    if (!mHasSelectorWheel) {
        mDecrementButton.setEnabled(enabled);
    }
    mInputText.setEnabled(enabled);
}",1,,,0,[@Override],[@Override],0,0,0,0,1,"3,4",0,3,1,"The code change is a control dependency change, where two ""if"" statements have been added to check if ""mHasSelectorWheel"" is false before enabling/disabling the increment and decrement buttons.","This control dependency change could potentially lead to different behaviors of the API, where the increment and decrement buttons may not be enabled/disabled depending on the value of ""mHasSelectorWheel"". Therefore, this change could cause compatibility issues due to potential different return values or types."
56,<android.webkit.WebView: void onResume()>,15,16,<android.webkit.WebView: void onResume()>,<android.webkit.WebView: void onResume()>,0,"{
    checkThread();
    if (mIsPaused) {
        mIsPaused = false;
        mWebViewCore.sendMessage(EventHub.ON_RESUME);
        if (mNativeClass != 0) {
            nativeSetPauseDrawing(mNativeClass, false);
        }
    }
}","{
    checkThread();
    mProvider.onResume();
}",1,"/**
 * Call this to resume a WebView after a previous call to onPause().
 */
","/**
 * Resumes a WebView after a previous call to onPause().
 */
",1,,,0,0,0,0,1,3,0,5,1,"The implementation of the onResume() method has been completely changed. In the early version, it checks if the WebView is paused and sends a message to the WebViewCore to resume and sets pause drawing to false. In the late version, it calls the onResume() method of the WebViewProvider. So the change is categorized as a ""Dependent API changed"" (code change type 5).","The change in the implementation of the onResume() method could potentially lead to different behaviors. In the early version, the method sends a message to the WebViewCore to resume and sets pause drawing to false, while in the late version, it calls the onResume() method of the WebViewProvider. The difference in implementation could potentially lead to a compatibility issue caused by potential different return values or types (CI type 1)."
57,"<android.view.ViewGroup: void dispatchAttachedToWindow(AttachInfo,int)>",15,16,"<android.view.ViewGroup: void dispatchAttachedToWindow(AttachInfo,int)>","<android.view.ViewGroup: void dispatchAttachedToWindow(AttachInfo,int)>",0,"{
    mGroupFlags |= FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW;
    super.dispatchAttachedToWindow(info, visibility);
    mGroupFlags &= ~FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW;
    visibility |= mViewFlags & VISIBILITY_MASK;
    final int count = mChildrenCount;
    final View[] children = mChildren;
    for (int i = 0; i < count; i++) {
        children[i].dispatchAttachedToWindow(info, visibility);
    }
}","{
    mGroupFlags |= FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW;
    super.dispatchAttachedToWindow(info, visibility);
    mGroupFlags &= ~FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW;
    final int count = mChildrenCount;
    final View[] children = mChildren;
    for (int i = 0; i < count; i++) {
        final View child = children[i];
        child.dispatchAttachedToWindow(info, visibility | (child.mViewFlags & VISIBILITY_MASK));
    }
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",0,[@Override],[@Override],0,0,0,0,1,"3,4",0,3,1,"The code change is about the control dependency of the for loop. In the early version, the visibility variable is only modified once, and then passed to the dispatchAttachedToWindow() method for all children. In the late version, however, the visibility variable is modified for each child and passed to the dispatchAttachedToWindow() method.","As the visibility variable is modified differently in the two versions, the API potentially returns different values in the two versions. This can lead to compatibility issues if the application is relying on the behavior of the early version. Therefore, this change should be classified as Compatibility Issue caused by potential different return values or types (1)."
60,<android.database.sqlite.SQLiteStatement: long simpleQueryForLong()>,15,16,<android.database.sqlite.SQLiteStatement: long simpleQueryForLong()>,<android.database.sqlite.SQLiteStatement: long simpleQueryForLong()>,0,"{
    try {
        long timeStart = acquireAndLock(READ);
        long retValue = native_1x1_long();
        mDatabase.logTimeStat(mSql, timeStart);
        return retValue;
    } catch (SQLiteDoneException e) {
        throw new SQLiteDoneException(""expected 1 row from this query but query returned no data. check the query: "" + mSql);
    } finally {
        releaseAndUnlock();
    }
}","{
    acquireReference();
    try {
        return getSession().executeForLong(getSql(), getBindArgs(), getConnectionFlags(), null);
    } catch (SQLiteDatabaseCorruptException ex) {
        onCorruption();
        throw ex;
    } finally {
        releaseReference();
    }
}",1,"/**
 * Execute a statement that returns a 1 by 1 table with a numeric value.
 * For example, SELECT COUNT(*) FROM table;
 *
 * @return The result of the query.
 *
 * @throws android.database.sqlite.SQLiteDoneException if the query returns zero rows
 */
","/**
 * Execute a statement that returns a 1 by 1 table with a numeric value.
 * For example, SELECT COUNT(*) FROM table;
 *
 * @return The result of the query.
 *
 * @throws android.database.sqlite.SQLiteDoneException if the query returns zero rows
 */
",0,,,0,0,0,0,1,"1,2,4","1,2","1,2,5","1,2","1. Return statement changed: The API potentially returns different values in the two versions. In the early version, the API returns the value from `native_1x1_long()`, while in the late version, the API returns the value from `getSession().executeForLong(getSql(), getBindArgs(), getConnectionFlags(), null)`.",
61,<android.view.InputDevice: int[] getDeviceIds()>,15,16,<android.view.InputDevice: int[] getDeviceIds()>,<android.view.InputDevice: int[] getDeviceIds()>,0,"{
    IWindowManager wm = Display.getWindowManager();
    try {
        return wm.getInputDeviceIds();
    } catch (RemoteException ex) {
        throw new RuntimeException(""Could not get input device ids from Window Manager."", ex);
    }
}","{
    return InputManager.getInstance().getInputDeviceIds();
}",1,"/**
 * Gets the ids of all input devices in the system.
 * @return The input device ids.
 */
","/**
 * Gets the ids of all input devices in the system.
 * @return The input device ids.
 */
",0,,,0,0,0,0,1,"1,2,4","1,2",5,1,The implementation of the API has changed from calling the getInputDeviceIds() method of the IWindowManager object to calling the getInputDeviceIds() method of the InputManager object. This is a dependent API change.,"The API now relies on a different dependent API to get the input device ids. This change could potentially cause the API to return a different set of device ids, leading to a compatibility issue. Therefore, the CI type is 1."
63,<android.database.ContentObservable: void notifyChange(boolean)>,15,16,<android.database.ContentObservable: void notifyChange(boolean)>,<android.database.ContentObservable: void notifyChange(boolean)>,0,"{
    synchronized (mObservers) {
        for (ContentObserver observer : mObservers) {
            observer.onChange(selfChange);
        }
    }
}","{
    synchronized (mObservers) {
        for (ContentObserver observer : mObservers) {
            observer.onChange(selfChange, null);
        }
    }
}",1,"/**
 * invokes onChange on each observer
 * @param selfChange
 */
","/**
 * Invokes {@link ContentObserver#onChange} on each observer.
 *
 * @param selfChange True if this is a self-change notification.
 *
 * @deprecated Use {@link #dispatchChange} instead.
 */
",1,,[@Deprecated],1,0,0,0,2,5,0,1,1,"The method `onChange()` of the `ContentObserver` class is called differently in the two versions. In the early version, it is called with one argument `selfChange`, while in the late version, it is called with two arguments `selfChange` and `null`. This is a change in the return statement because the API potentially returns different values to the observer objects.","This change may cause compatibility issues because the observer objects may not be expecting the second argument in the `onChange()` method. This can result in unexpected behavior or errors in the application that uses the observer objects. Therefore, this is a compatibility issue caused by potential different return values or types."
64,<android.webkit.WebSettings: int getTextZoom()>,15,16,<android.webkit.WebSettings: int getTextZoom()>,<android.webkit.WebSettings: int getTextZoom()>,0,"{
    return mTextSize;
}","{
    throw new MustOverrideException();
}",1,"/**
 * Get the text zoom of the page in percent.
 * @return A percent value describing the text zoom.
 * @see setTextSizeZoom
 */
","/**
 * Gets the text zoom of the page in percent.
 *
 * @return a percent value describing the text zoom
 * @see #setTextSizeZoom
 */
",1,,,0,0,0,0,1,"1,2","1,2",1,1,The return statement in the early version has been changed to a throw statement in the late version.,"Since the return statement in the early version is replaced by a throw statement in the late version, the API will not return a value anymore and will throw an exception instead, which may lead to different behaviors and may cause compatibility issue."
65,<android.webkit.WebView: void freeMemory()>,15,16,<android.webkit.WebView: void freeMemory()>,<android.webkit.WebView: void freeMemory()>,0,"{
    checkThread();
    mWebViewCore.sendMessage(EventHub.FREE_MEMORY);
}","{
    checkThread();
    mProvider.freeMemory();
}",1,"/**
 * Call this to inform the view that memory is low so that it can
 * free any available memory.
 */
","/**
 * Informs this WebView that memory is low so that it can free any available
 * memory.
 */
",1,,,0,0,0,0,1,4,0,5,1,"The method that was called to free memory changed from 'mWebViewCore.sendMessage(EventHub.FREE_MEMORY)' to 'mProvider.freeMemory()'. This is a dependent API change, so the code change type is 5.","Since the method that is called to free memory changed, it is possible that the way memory is freed has also changed, potentially leading to different behavior. This could cause a compatibility issue, specifically a CI caused by potential different return values or types. Therefore, the CI type is 1."
67,"<android.database.DatabaseUtils: ParcelFileDescriptor blobFileDescriptorForQuery(SQLiteStatement,String[])>",15,16,"<android.database.DatabaseUtils: ParcelFileDescriptor blobFileDescriptorForQuery(SQLiteStatement,String[])>","<android.database.DatabaseUtils: ParcelFileDescriptor blobFileDescriptorForQuery(SQLiteDatabase,String,String[])>",0,"{
    prog.bindAllArgsAsStrings(selectionArgs);
    return prog.simpleQueryForBlobFileDescriptor();
}","{
    SQLiteStatement prog = db.compileStatement(query);
    try {
        return blobFileDescriptorForQuery(prog, selectionArgs);
    } finally {
        prog.close();
    }
}",1,"/**
 * Utility method to run the pre-compiled query and return the blob value in the
 * first column of the first row.
 *
 * @return A read-only file descriptor for a copy of the blob value.
 */
","/**
 * Utility method to run the query on the db and return the blob value in the
 * first column of the first row.
 *
 * @return A read-only file descriptor for a copy of the blob value.
 */
",0,,,0,0,0,0,1,"1,2,4",1,5,1,The implementation of the method has changed completely. The late version uses a new SQLiteStatement object and calls a new method `blobFileDescriptorForQuery`.,"The API potentially returns different values in the two versions. The early version uses the `simpleQueryForBlobFileDescriptor` method while the late version uses the `blobFileDescriptorForQuery` method. This change may lead to different behaviors when the API is invoked. Therefore, the CI type is 1."
68,<android.webkit.WebSettings: void setDefaultFixedFontSize(int)>,15,16,<android.webkit.WebSettings: void setDefaultFixedFontSize(int)>,<android.webkit.WebSettings: void setDefaultFixedFontSize(int)>,0,"{
    size = pin(size);
    if (mDefaultFixedFontSize != size) {
        mDefaultFixedFontSize = size;
        postSync();
    }
}","{
    throw new MustOverrideException();
}",1,"/**
 * Set the default fixed font size.
 * @param size A non-negative integer between 1 and 72.
 * Any number outside the specified range will be pinned.
 */
","/**
 * Sets the default fixed font size. The default is 16.
 *
 * @param size a non-negative integer between 1 and 72. Any number outside
 * the specified range will be pinned.
 */
",1,,,0,0,0,0,1,"2,3,4",2,"1,5",1,"The implementation of the method has changed completely, the original implementation sets the default fixed font size, while the new implementation throws a MustOverrideException. This is a return statement change and a dependent API change, because the method now relies on the MustOverrideException.","The new implementation of the method throws a MustOverrideException, which means that the method must be overridden in a subclass. If a developer is using the method without overriding it, the new implementation will throw an exception, which is a compatibility issue caused by potential different return values or types."
69,<android.webkit.WebView: void setHorizontalScrollbarOverlay(boolean)>,15,16,<android.webkit.WebView: void setHorizontalScrollbarOverlay(boolean)>,<android.webkit.WebView: void setHorizontalScrollbarOverlay(boolean)>,0,"{
    checkThread();
    mOverlayHorizontalScrollbar = overlay;
}","{
    checkThread();
    mProvider.setHorizontalScrollbarOverlay(overlay);
}",1,"/**
 * Specify whether the horizontal scrollbar has overlay style.
 * @param overlay TRUE if horizontal scrollbar should have overlay style.
 */
","/**
 * Specifies whether the horizontal scrollbar has overlay style.
 *
 * @param overlay true if horizontal scrollbar should have overlay style
 */
",0,,,0,0,0,0,1,4,0,5,1,"The implementation of the method has changed, the variable 'mOverlayHorizontalScrollbar' in the early version is replaced by a dependent API 'mProvider.setHorizontalScrollbarOverlay(overlay)' in the late version. So this change belongs to the category 5) Dependent API changed.","This change potentially leads to different behaviors as the dependent API 'mProvider.setHorizontalScrollbarOverlay(overlay)' may change the value or type of the return value. Therefore, this is a Compatibility Issue caused by potential different return values or types, which belongs to the category 1) Compatibility Issue caused by potential different return values or types."
70,<android.database.sqlite.SQLiteDatabase: boolean isOpen()>,15,16,<android.database.sqlite.SQLiteDatabase: boolean isOpen()>,<android.database.sqlite.SQLiteDatabase: boolean isOpen()>,0,"{
    return mNativeHandle != 0;
}","{
    synchronized (mLock) {
        return mConnectionPoolLocked != null;
    }
}",1,"/**
 * @return true if the DB is currently open (has not been closed)
 */
","/**
 * Returns true if the database is currently open.
 *
 * @return True if the database is currently open (has not been closed).
 */
",1,,,0,0,0,0,1,"1,4",1,"1,3",1,"The return statement has changed from ""return mNativeHandle != 0"" to ""return mConnectionPoolLocked != null"", and a synchronized block has been added, so the code change type is 1,3.","The mNativeHandle variable in early implementation is replaced by mConnectionPoolLocked in late implementation, which can produce different return values. Also, the synchronized block added in late implementation can also lead to different program behaviors, such as blocking the execution of other threads. Therefore, the CI type is 1."
72,"<android.app.FragmentManagerImpl: void attachFragment(Fragment,int,int)>",15,16,"<android.app.FragmentManagerImpl: void attachFragment(Fragment,int,int)>","<android.app.FragmentManagerImpl: void attachFragment(Fragment,int,int)>",0,"{
    if (DEBUG)
        Log.v(TAG, ""attach: "" + fragment);
    if (fragment.mDetached) {
        fragment.mDetached = false;
        if (!fragment.mAdded) {
            mAdded.add(fragment);
            fragment.mAdded = true;
            if (fragment.mHasMenu && fragment.mMenuVisible) {
                mNeedMenuInvalidate = true;
            }
            moveToState(fragment, mCurState, transition, transitionStyle);
        }
    }
}","{
    if (DEBUG)
        Log.v(TAG, ""attach: "" + fragment);
    if (fragment.mDetached) {
        fragment.mDetached = false;
        if (!fragment.mAdded) {
            if (mAdded == null) {
                mAdded = new ArrayList<Fragment>();
            }
            mAdded.add(fragment);
            fragment.mAdded = true;
            if (fragment.mHasMenu && fragment.mMenuVisible) {
                mNeedMenuInvalidate = true;
            }
            moveToState(fragment, mCurState, transition, transitionStyle, false);
        }
    }
}",1,,,0,,,0,0,0,0,"1,2","3,4,5",0,"3,5",1,"The implementation of the API has changed in terms of control dependency and dependent API. Specifically, a new `if` statement has been added to check if `mAdded` is null before adding the `fragment` to it, and the `moveToState` method has been updated to include an additional parameter `moveStateNow` with a default value of `false`.","As the change in the control dependency and dependent API potentially affects the behavior of the API, it could lead to a Compatibility Issue caused by potential different return values or types (CI type 1). Specifically, the new `if` statement could result in a different outcome if `mAdded` is null, and the additional parameter in `moveToState` could lead to different behavior in the state transition of the `fragment`."
74,<android.view.View: void getLocationInWindow(int[])>,15,16,<android.view.View: void getLocationInWindow(int[])>,<android.view.View: void getLocationInWindow(int[])>,0,"{
    // When the view is not attached to a window, this method does not make sense
    if (mAttachInfo == null)
        return;
    if (location == null || location.length < 2) {
        throw new IllegalArgumentException(""location must be an array of two integers"");
    }
    float[] position = mAttachInfo.mTmpTransformLocation;
    position[0] = position[1] = 0.0f;
    if (!hasIdentityMatrix()) {
        getMatrix().mapPoints(position);
    }
    position[0] += mLeft;
    position[1] += mTop;
    ViewParent viewParent = mParent;
    while (viewParent instanceof View) {
        final View view = (View) viewParent;
        position[0] -= view.mScrollX;
        position[1] -= view.mScrollY;
        if (!view.hasIdentityMatrix()) {
            view.getMatrix().mapPoints(position);
        }
        position[0] += view.mLeft;
        position[1] += view.mTop;
        viewParent = view.mParent;
    }
    if (viewParent instanceof ViewRootImpl) {
        // *cough*
        final ViewRootImpl vr = (ViewRootImpl) viewParent;
        position[1] -= vr.mCurScrollY;
    }
    location[0] = (int) (position[0] + 0.5f);
    location[1] = (int) (position[1] + 0.5f);
}","{
    if (location == null || location.length < 2) {
        throw new IllegalArgumentException(""location must be an array of two integers"");
    }
    if (mAttachInfo == null) {
        // When the view is not attached to a window, this method does not make sense
        location[0] = location[1] = 0;
        return;
    }
    float[] position = mAttachInfo.mTmpTransformLocation;
    position[0] = position[1] = 0.0f;
    if (!hasIdentityMatrix()) {
        getMatrix().mapPoints(position);
    }
    position[0] += mLeft;
    position[1] += mTop;
    ViewParent viewParent = mParent;
    while (viewParent instanceof View) {
        final View view = (View) viewParent;
        position[0] -= view.mScrollX;
        position[1] -= view.mScrollY;
        if (!view.hasIdentityMatrix()) {
            view.getMatrix().mapPoints(position);
        }
        position[0] += view.mLeft;
        position[1] += view.mTop;
        viewParent = view.mParent;
    }
    if (viewParent instanceof ViewRootImpl) {
        // *cough*
        final ViewRootImpl vr = (ViewRootImpl) viewParent;
        position[1] -= vr.mCurScrollY;
    }
    location[0] = (int) (position[0] + 0.5f);
    location[1] = (int) (position[1] + 0.5f);
}",1,"/**
 * <p>Computes the coordinates of this view in its window. The argument
 * must be an array of two integers. After the method returns, the array
 * contains the x and y location in that order.</p>
 *
 * @param location an array of two integers in which to hold the coordinates
 */
","/**
 * <p>Computes the coordinates of this view in its window. The argument
 * must be an array of two integers. After the method returns, the array
 * contains the x and y location in that order.</p>
 *
 * @param location an array of two integers in which to hold the coordinates
 */
",0,,,0,0,0,0,1,"1,3",1,3,1,"The implementation of the API for the early and late versions has changed in terms of control dependency. Specifically, the order of the if-statement for checking the nullity of the `mAttachInfo` and the nullity or length of the `location` array has been swapped.","The change in control dependency can potentially lead to a different behavior of the API. In the early version, if `mAttachInfo` is null, the method will directly return without throwing any exception. However, in the late version, if `location` is null or its length is less than 2, an `IllegalArgumentException` will be thrown even if `mAttachInfo` is null. Therefore, this change can cause a compatibility issue due to potential different return values or types."
76,"<android.widget.ExpandableListView: ContextMenuInfo createContextMenuInfo(View,int,long)>",15,16,"<android.widget.ExpandableListView: ContextMenuInfo createContextMenuInfo(View,int,long)>","<android.widget.ExpandableListView: ContextMenuInfo createContextMenuInfo(View,int,long)>",0,"{
    if (isHeaderOrFooterPosition(flatListPosition)) {
        // Return normal info for header/footer view context menus
        return new AdapterContextMenuInfo(view, flatListPosition, id);
    }
    final int adjustedPosition = getFlatPositionForConnector(flatListPosition);
    PositionMetadata pm = mConnector.getUnflattenedPos(adjustedPosition);
    ExpandableListPosition pos = pm.position;
    pm.recycle();
    id = getChildOrGroupId(pos);
    long packedPosition = pos.getPackedPosition();
    pos.recycle();
    return new ExpandableListContextMenuInfo(view, packedPosition, id);
}","{
    if (isHeaderOrFooterPosition(flatListPosition)) {
        // Return normal info for header/footer view context menus
        return new AdapterContextMenuInfo(view, flatListPosition, id);
    }
    final int adjustedPosition = getFlatPositionForConnector(flatListPosition);
    PositionMetadata pm = mConnector.getUnflattenedPos(adjustedPosition);
    ExpandableListPosition pos = pm.position;
    id = getChildOrGroupId(pos);
    long packedPosition = pos.getPackedPosition();
    pm.recycle();
    return new ExpandableListContextMenuInfo(view, packedPosition, id);
}",1,,,0,[@Override],[@Override],0,0,0,0,1,4,0,3,1,"The position of the statement 'pm.recycle();' has been changed in the late version compared to the early version. The statement is now called after the variable 'id' is assigned a value, instead of before.","Since the position of the statement 'pm.recycle();' has been changed, it may affect the value of the variable 'id'. If the 'pm' object is modified by other parts of the code before the 'id' variable is assigned, it could result in different values for the 'id' variable. As a result, the API may return different values in different versions, leading to a Compatibility Issue of type 1."
78,<android.animation.KeyframeSet: KeyframeSet ofFloat(float)>,17,18,<android.animation.KeyframeSet: KeyframeSet ofFloat(float)>,<android.animation.KeyframeSet: KeyframeSet ofFloat(float)>,0,"{
    int numKeyframes = values.length;
    FloatKeyframe[] keyframes = new FloatKeyframe[Math.max(numKeyframes, 2)];
    if (numKeyframes == 1) {
        keyframes[0] = (FloatKeyframe) Keyframe.ofFloat(0f);
        keyframes[1] = (FloatKeyframe) Keyframe.ofFloat(1f, values[0]);
    } else {
        keyframes[0] = (FloatKeyframe) Keyframe.ofFloat(0f, values[0]);
        for (int i = 1; i < numKeyframes; ++i) {
            keyframes[i] = (FloatKeyframe) Keyframe.ofFloat((float) i / (numKeyframes - 1), values[i]);
        }
    }
    return new FloatKeyframeSet(keyframes);
}","{
    boolean badValue = false;
    int numKeyframes = values.length;
    FloatKeyframe[] keyframes = new FloatKeyframe[Math.max(numKeyframes, 2)];
    if (numKeyframes == 1) {
        keyframes[0] = (FloatKeyframe) Keyframe.ofFloat(0f);
        keyframes[1] = (FloatKeyframe) Keyframe.ofFloat(1f, values[0]);
        if (Float.isNaN(values[0])) {
            badValue = true;
        }
    } else {
        keyframes[0] = (FloatKeyframe) Keyframe.ofFloat(0f, values[0]);
        for (int i = 1; i < numKeyframes; ++i) {
            keyframes[i] = (FloatKeyframe) Keyframe.ofFloat((float) i / (numKeyframes - 1), values[i]);
            if (Float.isNaN(values[i])) {
                badValue = true;
            }
        }
    }
    if (badValue) {
        Log.w(""Animator"", ""Bad value (NaN) in float animator"");
    }
    return new FloatKeyframeSet(keyframes);
}",1,,,0,,,0,0,0,0,1,"3,4",0,"3,4",1,"In the late version, a new variable 'badValue' is introduced to check if the values in the input array contain 'NaN'. If there is 'NaN' in the input, a warning log will be printed out. The change in code leads to the different behaviors of the API, which is a control dependency change (3) and an other statement change (4).","The code change in the late version only affects the printing of warning logs, and the API still returns the same value as the early version. However, as the code change could potentially cause the API to return a different value (although it doesn't in this case), it is classified as a Compatibility Issue caused by potential different return values or types (1)."
79,<android.view.ViewGroup.MarginLayoutParams: void resolveLayoutDirection(int)>,17,18,<android.view.ViewGroup.MarginLayoutParams: void resolveLayoutDirection(int)>,<android.view.ViewGroup.MarginLayoutParams: void resolveLayoutDirection(int)>,0,"{
    setLayoutDirection(layoutDirection);
    if (!isMarginRelative())
        return;
    switch(layoutDirection) {
        case View.LAYOUT_DIRECTION_RTL:
            leftMargin = (endMargin > DEFAULT_RELATIVE) ? endMargin : initialLeftMargin;
            rightMargin = (startMargin > DEFAULT_RELATIVE) ? startMargin : initialRightMargin;
            break;
        case View.LAYOUT_DIRECTION_LTR:
        default:
            leftMargin = (startMargin > DEFAULT_RELATIVE) ? startMargin : initialLeftMargin;
            rightMargin = (endMargin > DEFAULT_RELATIVE) ? endMargin : initialRightMargin;
            break;
    }
}","{
    setLayoutDirection(layoutDirection);
    // Will use the left and right margins if no relative margin is defined.
    if (!isMarginRelative() || (mMarginFlags & NEED_RESOLUTION_MASK) != NEED_RESOLUTION_MASK)
        return;
    // Proceed with resolution
    doResolveMargins();
}",1,"/**
 * This will be called by {@link android.view.View#requestLayout()}. Left and Right margins
 * may be overridden depending on layout direction.
 */
","/**
 * This will be called by {@link android.view.View#requestLayout()}. Left and Right margins
 * may be overridden depending on layout direction.
 */
",0,[@Override],[@Override],0,0,0,0,1,"1,3",1,"3,5",1,"The switch statement has been removed, and the method 'doResolveMargins()' has been introduced in the late version, which changes the control dependency and also involves a dependent API. This change affects the values of leftMargin and rightMargin.","As the method 'doResolveMargins()' has been introduced and the switch statement has been removed, the implementation of resolving margins has changed, which can potentially lead to different values of leftMargin and rightMargin. Therefore, the CI type is 1."
81,"<android.appwidget.AppWidgetHost: AppWidgetHostView createView(Context,int,AppWidgetProviderInfo)>",17,18,"<android.appwidget.AppWidgetHost: AppWidgetHostView createView(Context,int,AppWidgetProviderInfo)>","<android.appwidget.AppWidgetHost: AppWidgetHostView createView(Context,int,AppWidgetProviderInfo)>",0,"{
    AppWidgetHostView view = onCreateView(context, appWidgetId, appWidget);
    view.setOnClickHandler(mOnClickHandler);
    view.setAppWidget(appWidgetId, appWidget);
    synchronized (mViews) {
        mViews.put(appWidgetId, view);
    }
    RemoteViews views;
    try {
        views = sService.getAppWidgetViews(appWidgetId);
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
    view.updateAppWidget(views);
    return view;
}","{
    final int userId = mContext.getUserId();
    AppWidgetHostView view = onCreateView(mContext, appWidgetId, appWidget);
    view.setUserId(userId);
    view.setOnClickHandler(mOnClickHandler);
    view.setAppWidget(appWidgetId, appWidget);
    synchronized (mViews) {
        mViews.put(appWidgetId, view);
    }
    RemoteViews views;
    try {
        views = sService.getAppWidgetViews(appWidgetId, userId);
        if (views != null) {
            views.setUser(new UserHandle(mContext.getUserId()));
        }
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
    view.updateAppWidget(views);
    return view;
}",1,"/**
 * Create the AppWidgetHostView for the given widget.
 * The AppWidgetHost retains a pointer to the newly-created View.
 */
","/**
 * Create the AppWidgetHostView for the given widget.
 * The AppWidgetHost retains a pointer to the newly-created View.
 */
",0,,,0,0,0,0,1|2,"1,3,4,5",1,"1,4",1,The code change includes three aspects:,"3) The API `sService.getAppWidgetViews(appWidgetId)` in the early version has changed to `sService.getAppWidgetViews(appWidgetId, userId)` in the late version."
82,<android.view.accessibility.AccessibilityNodeInfo: void setFocused(boolean)>,17,18,<android.view.accessibility.AccessibilityNodeInfo: void setFocused(boolean)>,<android.view.accessibility.AccessibilityNodeInfo: void setFocused(boolean)>,0,"{
    setBooleanProperty(PROPERTY_FOCUSED, focused);
}","{
    setBooleanProperty(BOOLEAN_PROPERTY_FOCUSED, focused);
}",1,"/**
 * Sets whether this node is focused.
 * <p>
 * <strong>Note:</strong> Cannot be called from an
 * {@link android.accessibilityservice.AccessibilityService}.
 * This class is made immutable before being delivered to an AccessibilityService.
 * </p>
 *
 * @param focused True if the node is focused.
 *
 * @throws IllegalStateException If called from an AccessibilityService.
 */
","/**
 * Sets whether this node is focused.
 * <p>
 * <strong>Note:</strong> Cannot be called from an
 * {@link android.accessibilityservice.AccessibilityService}.
 * This class is made immutable before being delivered to an AccessibilityService.
 * </p>
 *
 * @param focused True if the node is focused.
 *
 * @throws IllegalStateException If called from an AccessibilityService.
 */
",0,,,0,0,0,0,2,5,0,5,0,"The code change is that the argument of the method 'setBooleanProperty(PROPERTY_FOCUSED, focused)' has changed to 'setBooleanProperty(BOOLEAN\_PROPERTY\_FOCUSED, focused)'. This is a change in a dependent API, as the argument 'PROPERTY\_FOCUSED' has been replaced by 'BOOLEAN\_PROPERTY\_FOCUSED'.","The change in dependent API does not have any impact on the return type or exception handling of the API 'setFocused(boolean)'. Therefore, there is no compatibility issue detected."
83,<android.os.Looper: void quit()>,17,18,<android.os.Looper: void quit()>,<android.os.Looper: void quit()>,0,"{
    mQueue.quit();
}","{
    mQueue.quit(false);
}",1,"/**
 * Quits the looper.
 *
 * Causes the {@link #loop} method to terminate as soon as possible.
 */
","/**
 * Quits the looper.
 * <p>
 * Causes the {@link #loop} method to terminate without processing any
 * more messages in the message queue.
 * </p><p>
 * Any attempt to post messages to the queue after the looper is asked to quit will fail.
 * For example, the {@link Handler#sendMessage(Message)} method will return false.
 * </p><p class=""note"">
 * Using this method may be unsafe because some messages may not be delivered
 * before the looper terminates.  Consider using {@link #quitSafely} instead to ensure
 * that all pending work is completed in an orderly manner.
 * </p>
 *
 * @see #quitSafely
 */
",1,,,0,0,0,0,2,5,0,5,1,"The method implementation of the `quit()` method has changed between the two versions. In the early version, it calls the `quit()` method of the `mQueue` object without any arguments. However, in the late version, it calls the `quit(false)` method with a boolean argument. This is an example of a Dependent API change, as the method being called on the `mQueue` object has changed.","This change could lead to a Compatibility Issue, as the behavior of the `quit()` method may differ depending on whether it is called with or without arguments. Specifically, it may cause the API to return a different value or behave differently, leading to a potential Compatibility Issue of type 1."
84,<android.os.Parcel: T readParcelable(ClassLoader)>,17,18,<android.os.Parcel: T readParcelable(ClassLoader)>,<android.os.Parcel: T readParcelable(ClassLoader)>,0,"{
    String name = readString();
    if (name == null) {
        return null;
    }
    Parcelable.Creator<T> creator;
    synchronized (mCreators) {
        HashMap<String, Parcelable.Creator> map = mCreators.get(loader);
        if (map == null) {
            map = new HashMap<String, Parcelable.Creator>();
            mCreators.put(loader, map);
        }
        creator = map.get(name);
        if (creator == null) {
            try {
                Class c = loader == null ? Class.forName(name) : Class.forName(name, true, loader);
                Field f = c.getField(""CREATOR"");
                creator = (Parcelable.Creator) f.get(null);
            } catch (IllegalAccessException e) {
                Log.e(TAG, ""Class not found when unmarshalling: "" + name + "", e: "" + e);
                throw new BadParcelableException(""IllegalAccessException when unmarshalling: "" + name);
            } catch (ClassNotFoundException e) {
                Log.e(TAG, ""Class not found when unmarshalling: "" + name + "", e: "" + e);
                throw new BadParcelableException(""ClassNotFoundException when unmarshalling: "" + name);
            } catch (ClassCastException e) {
                throw new BadParcelableException(""Parcelable protocol requires a "" + ""Parcelable.Creator object called "" + "" CREATOR on class "" + name);
            } catch (NoSuchFieldException e) {
                throw new BadParcelableException(""Parcelable protocol requires a "" + ""Parcelable.Creator object called "" + "" CREATOR on class "" + name);
            }
            if (creator == null) {
                throw new BadParcelableException(""Parcelable protocol requires a "" + ""Parcelable.Creator object called "" + "" CREATOR on class "" + name);
            }
            map.put(name, creator);
        }
    }
    if (creator instanceof Parcelable.ClassLoaderCreator<?>) {
        return ((Parcelable.ClassLoaderCreator<T>) creator).createFromParcel(this, loader);
    }
    return creator.createFromParcel(this);
}","{
    Parcelable.Creator<T> creator = readParcelableCreator(loader);
    if (creator == null) {
        return null;
    }
    if (creator instanceof Parcelable.ClassLoaderCreator<?>) {
        return ((Parcelable.ClassLoaderCreator<T>) creator).createFromParcel(this, loader);
    }
    return creator.createFromParcel(this);
}",1,"/**
 * Read and return a new Parcelable from the parcel.  The given class loader
 * will be used to load any enclosed Parcelables.  If it is null, the default
 * class loader will be used.
 * @param loader A ClassLoader from which to instantiate the Parcelable
 * object, or null for the default class loader.
 * @return Returns the newly created Parcelable, or null if a null
 * object has been written.
 * @throws BadParcelableException Throws BadParcelableException if there
 * was an error trying to instantiate the Parcelable.
 */
","/**
 * Read and return a new Parcelable from the parcel.  The given class loader
 * will be used to load any enclosed Parcelables.  If it is null, the default
 * class loader will be used.
 * @param loader A ClassLoader from which to instantiate the Parcelable
 * object, or null for the default class loader.
 * @return Returns the newly created Parcelable, or null if a null
 * object has been written.
 * @throws BadParcelableException Throws BadParcelableException if there
 * was an error trying to instantiate the Parcelable.
 */
",0,,,0,0,0,0,1,"2,3,4",2,5,1,"In the Early_Implementation, the implementation of reading a parcelable object is done by retrieving the name and the creator of the object, and then creating the object using the creator. In the Late_Implementation, the implementation is simplified by directly reading the creator using the new method readParcelableCreator(loader). This change simplifies the code, and it also changes the dependent API used in the implementation, so the code change type is 5.","The change in the dependent API used in the implementation could lead to different behaviors in the Late_Implementation compared to the Early_Implementation. For example, if the readParcelableCreator(loader) method in the Late_Implementation behaves differently from the original implementation of retrieving the creator using the mCreators map in the Early_Implementation, it could lead to a different creator being used, resulting in a different object being returned. Therefore, the Compatibility Issue type is 1."
89,<android.widget.TextView: void onRtlPropertiesChanged(int)>,19,20,<android.widget.TextView: void onRtlPropertiesChanged(int)>,<android.widget.TextView: void onRtlPropertiesChanged(int)>,0,"{
    super.onRtlPropertiesChanged(layoutDirection);
    mTextDir = getTextDirectionHeuristic();
}","{
    super.onRtlPropertiesChanged(layoutDirection);
    mTextDir = getTextDirectionHeuristic();
    if (mLayout != null) {
        checkForRelayout();
    }
}",1,,,-1,[@Override],[@Override],0,0,0,0,1,3,0,3,1,"The change is about control dependency. In the late version, a new 'if' statement has been added, which could affect the logic flow of the method.","The newly added 'if' statement could lead to different behavior of the API, as the 'checkForRelayout()' method may be called, which could further affect the layout of the TextView. Therefore, it is a Compatibility Issue caused by potential different return values or types."
97,"<android.app.AlertDialog: void setButton3(CharSequence,Message)>",19,20,"<android.app.AlertDialog: void setButton3(CharSequence,Message)>","<android.app.AlertDialog: void setButton3(CharSequence,OnClickListener)>",0,"{
    setButton(BUTTON_NEUTRAL, text, msg);
}","{
    setButton(BUTTON_NEUTRAL, text, listener);
}",1,"/**
 * @deprecated Use {@link #setButton(int, CharSequence, Message)} with
 * {@link DialogInterface#BUTTON_NEUTRAL}.
 */
","/**
 * Set a listener to be invoked when button 3 of the dialog is pressed.
 * @param text The text to display in button 3.
 * @param listener The {@link DialogInterface.OnClickListener} to use.
 * @deprecated Use
 * {@link #setButton(int, CharSequence, android.content.DialogInterface.OnClickListener)}
 * with {@link DialogInterface#BUTTON_POSITIVE}
 */
",1,[@Deprecated],[@Deprecated],0,0,0,0,1,5,0,"1,5",1,"The type of the second parameter in the `setButton` method has changed from `Message` to `DialogInterface.OnClickListener`, so the code change type is 1,5.","The change of the type of the second parameter in the `setButton` method could make the API potentially return a different value, so the CI type is 1."
98,<android.speech.tts.TextToSpeech: Set<String> getFeatures(Locale)>,19,20,<android.speech.tts.TextToSpeech: Set<String> getFeatures(Locale)>,<android.speech.tts.TextToSpeech: Set<String> getFeatures(Locale)>,0,"{
    return runAction(new Action<Set<String>>() {

        @Override
        public Set<String> run(ITextToSpeechService service) throws RemoteException {
            String[] features = service.getFeaturesForLanguage(locale.getISO3Language(), locale.getISO3Country(), locale.getVariant());
            if (features != null) {
                final Set<String> featureSet = new HashSet<String>();
                Collections.addAll(featureSet, features);
                return featureSet;
            }
            return null;
        }
    }, null, ""getFeatures"");
}","{
    return runAction(new Action<Set<String>>() {

        @Override
        public Set<String> run(ITextToSpeechService service) throws RemoteException {
            String[] features = null;
            try {
                features = service.getFeaturesForLanguage(locale.getISO3Language(), locale.getISO3Country(), locale.getVariant());
            } catch (MissingResourceException e) {
                Log.w(TAG, ""Couldn't retrieve 3 letter ISO 639-2/T language and/or ISO 3166 "" + ""country code for locale: "" + locale, e);
                return null;
            }
            if (features != null) {
                final Set<String> featureSet = new HashSet<String>();
                Collections.addAll(featureSet, features);
                return featureSet;
            }
            return null;
        }
    }, null, ""getFeatures"");
}",1,"/**
 * Queries the engine for the set of features it supports for a given locale.
 * Features can either be framework defined, e.g.
 * {@link TextToSpeech.Engine#KEY_FEATURE_NETWORK_SYNTHESIS} or engine specific.
 * Engine specific keys must be prefixed by the name of the engine they
 * are intended for. These keys can be used as parameters to
 * {@link TextToSpeech#speak(String, int, java.util.HashMap)} and
 * {@link TextToSpeech#synthesizeToFile(String, java.util.HashMap, String)}.
 *
 * Features are boolean flags, and their values in the synthesis parameters
 * must be behave as per {@link Boolean#parseBoolean(String)}.
 *
 * @param locale The locale to query features for.
 */
","/**
 * Queries the engine for the set of features it supports for a given locale.
 * Features can either be framework defined, e.g.
 * {@link TextToSpeech.Engine#KEY_FEATURE_NETWORK_SYNTHESIS} or engine specific.
 * Engine specific keys must be prefixed by the name of the engine they
 * are intended for. These keys can be used as parameters to
 * {@link TextToSpeech#speak(String, int, java.util.HashMap)} and
 * {@link TextToSpeech#synthesizeToFile(String, java.util.HashMap, String)}.
 *
 * Features are boolean flags, and their values in the synthesis parameters
 * must be behave as per {@link Boolean#parseBoolean(String)}.
 *
 * @param locale The locale to query features for.
 */
",1,,,0,0,0,0,1,"1,2,4","1,2","2, 3","1,2","There has been a change in exception handling and control dependency. In the late version, a new exception handling statement (catching MissingResourceException) has been introduced, and the control dependency has changed as the new exception handling statement affects the flow of the program.","The Compatibility Issue could arise in this case due to changes in exception handling and control dependency. In the late version, if a MissingResourceException is thrown, the method will return null instead of continuing to execute the code that retrieves features and adds them to a set, which could result in a different behavior than the early version."
100,"<android.app.ActivityThread.ApplicationThread: void dumpProvider(FileDescriptor,IBinder,String[])>",19,20,"<android.app.ActivityThread.ApplicationThread: void dumpProvider(FileDescriptor,IBinder,String[])>","<android.app.ActivityThread.ApplicationThread: void dumpProvider(FileDescriptor,IBinder,String[])>",0,"{
    DumpComponentInfo data = new DumpComponentInfo();
    try {
        data.fd = ParcelFileDescriptor.dup(fd);
        data.token = providertoken;
        data.args = args;
        queueOrSendMessage(H.DUMP_PROVIDER, data);
    } catch (IOException e) {
        Slog.w(TAG, ""dumpProvider failed"", e);
    }
}","{
    DumpComponentInfo data = new DumpComponentInfo();
    try {
        data.fd = ParcelFileDescriptor.dup(fd);
        data.token = providertoken;
        data.args = args;
        sendMessage(H.DUMP_PROVIDER, data, 0, 0, true);
    } catch (IOException e) {
        Slog.w(TAG, ""dumpProvider failed"", e);
    }
}",1,,,0,,,0,0,0,0,1,4,0,5,0,"The method `queueOrSendMessage` has been changed to `sendMessage`. This is a dependent API change, so the code change type is 5.","The change from `queueOrSendMessage` to `sendMessage` does not affect the return value or exception handling of the `dumpProvider` method. Therefore, there is no potential compatibility issue."
101,<android.widget.PopupWindow.PopupDecorView: void requestEnterTransition(Transition)>,23,24,<android.widget.PopupWindow.PopupDecorView: void requestEnterTransition(Transition)>,<android.widget.PopupWindow.PopupDecorView: void requestEnterTransition(Transition)>,0,"{
    final ViewTreeObserver observer = getViewTreeObserver();
    if (observer != null && transition != null) {
        final Transition enterTransition = transition.clone();
        // Postpone the enter transition after the first layout pass.
        observer.addOnGlobalLayoutListener(new OnGlobalLayoutListener() {

            @Override
            public void onGlobalLayout() {
                final ViewTreeObserver observer = getViewTreeObserver();
                if (observer != null) {
                    observer.removeOnGlobalLayoutListener(this);
                }
                final Rect epicenter = getRelativeAnchorBounds();
                enterTransition.setEpicenterCallback(new EpicenterCallback() {

                    @Override
                    public Rect onGetEpicenter(Transition transition) {
                        return epicenter;
                    }
                });
                startEnterTransition(enterTransition);
            }
        });
    }
}","{
    final ViewTreeObserver observer = getViewTreeObserver();
    if (observer != null && transition != null) {
        final Transition enterTransition = transition.clone();
        // Postpone the enter transition after the first layout pass.
        observer.addOnGlobalLayoutListener(new OnGlobalLayoutListener() {

            @Override
            public void onGlobalLayout() {
                final ViewTreeObserver observer = getViewTreeObserver();
                if (observer != null) {
                    observer.removeOnGlobalLayoutListener(this);
                }
                final Rect epicenter = getTransitionEpicenter();
                enterTransition.setEpicenterCallback(new EpicenterCallback() {

                    @Override
                    public Rect onGetEpicenter(Transition transition) {
                        return epicenter;
                    }
                });
                startEnterTransition(enterTransition);
            }
        });
    }
}",1,"/**
 * Requests that an enter transition run after the next layout pass.
 */","/**
 * Requests that an enter transition run after the next layout pass.
 */",0,,,0,,,,1,4,0,5,1,"The method `getRelativeAnchorBounds()` has been changed to `getTransitionEpicenter()`. This is a Dependent API change, so the code change type is 5.","As the method `getRelativeAnchorBounds()` has been changed to `getTransitionEpicenter()`, it may return a different value for the `epicenter` variable, which could lead to different behaviors in the `enterTransition.setEpicenterCallback(new EpicenterCallback()` and `startEnterTransition(enterTransition)`. Therefore, it is a Compatibility Issue caused by potential different return values or types, which means the CI type is 1."
102,<android.view.ViewRootImpl.ImeInputStage: int onProcess(QueuedInputEvent)>,23,24,<android.view.ViewRootImpl.ImeInputStage: int onProcess(QueuedInputEvent)>,<android.view.ViewRootImpl.ImeInputStage: int onProcess(QueuedInputEvent)>,0,"{
    if (mLastWasImTarget && !isInLocalFocusMode()) {
        InputMethodManager imm = InputMethodManager.peekInstance();
        if (imm != null) {
            final InputEvent event = q.mEvent;
            if (DEBUG_IMF)
                Log.v(TAG, ""Sending input event to IME: "" + event);
            int result = imm.dispatchInputEvent(event, q, this, mHandler);
            if (result == InputMethodManager.DISPATCH_HANDLED) {
                return FINISH_HANDLED;
            } else if (result == InputMethodManager.DISPATCH_NOT_HANDLED) {
                // The IME could not handle it, so skip along to the next InputStage
                return FORWARD;
            } else {
                // callback will be invoked later
                return DEFER;
            }
        }
    }
    return FORWARD;
}","{
    if (mLastWasImTarget && !isInLocalFocusMode()) {
        InputMethodManager imm = InputMethodManager.peekInstance();
        if (imm != null) {
            final InputEvent event = q.mEvent;
            if (DEBUG_IMF)
                Log.v(mTag, ""Sending input event to IME: "" + event);
            int result = imm.dispatchInputEvent(event, q, this, mHandler);
            if (result == InputMethodManager.DISPATCH_HANDLED) {
                return FINISH_HANDLED;
            } else if (result == InputMethodManager.DISPATCH_NOT_HANDLED) {
                // The IME could not handle it, so skip along to the next InputStage
                return FORWARD;
            } else {
                // callback will be invoked later
                return DEFER;
            }
        }
    }
    return FORWARD;
}",1,,,0,[@Override],[@Override],0,,,,1,4,0,3,0,"Only the log statement has changed, specifically, the argument for the `Log.v()` method has changed from `TAG` to `mTag`. This is an example of an ""Other statement changed"" change type.","The change of log statement will not affect the return value or exception handling of the API, so there is no Compatibility Issue."
104,"<android.view.View: void scheduleDrawable(Drawable,Runnable,long)>",23,24,"<android.view.View: void scheduleDrawable(Drawable,Runnable,long)>","<android.view.View: void scheduleDrawable(Drawable,Runnable,long)>",0,"{
    if (verifyDrawable(who) && what != null) {
        final long delay = when - SystemClock.uptimeMillis();
        if (mAttachInfo != null) {
            mAttachInfo.mViewRootImpl.mChoreographer.postCallbackDelayed(Choreographer.CALLBACK_ANIMATION, what, who, Choreographer.subtractFrameDelay(delay));
        } else {
            ViewRootImpl.getRunQueue().postDelayed(what, delay);
        }
    }
}","{
    if (verifyDrawable(who) && what != null) {
        final long delay = when - SystemClock.uptimeMillis();
        if (mAttachInfo != null) {
            mAttachInfo.mViewRootImpl.mChoreographer.postCallbackDelayed(Choreographer.CALLBACK_ANIMATION, what, who, Choreographer.subtractFrameDelay(delay));
        } else {
            // Postpone the runnable until we know
            // on which thread it needs to run.
            getRunQueue().postDelayed(what, delay);
        }
    }
}",1,"/**
 * Schedules an action on a drawable to occur at a specified time.
 *
 * @param who the recipient of the action
 * @param what the action to run on the drawable
 * @param when the time at which the action must occur. Uses the
 * {@link SystemClock#uptimeMillis} timebase.
 */","/**
 * Schedules an action on a drawable to occur at a specified time.
 *
 * @param who the recipient of the action
 * @param what the action to run on the drawable
 * @param when the time at which the action must occur. Uses the
 * {@link SystemClock#uptimeMillis} timebase.
 */",0,[@Override],[@Override],0,,,,1,3,0,3,0,"The implementation of the ""else"" branch inside the ""if"" statement has been changed from ""ViewRootImpl.getRunQueue().postDelayed(what, delay)"" to ""getRunQueue().postDelayed(what, delay)"". This change belongs to the category of ""Control dependency changed"".","The change of implementation inside the ""else"" branch does not affect the return value or the exception handling behavior of the API. The postponed runnable will still be executed on the correct thread, and the behavior of the API remains the same. Therefore, there is no compatibility issue in this case."
105,"<android.widget.RemoteViewsAdapter.RemoteViewsFrameLayout: void onRemoteViewsLoaded(RemoteViews,OnClickHandler)>",23,24,"<android.widget.RemoteViewsAdapter.RemoteViewsFrameLayout: void onRemoteViewsLoaded(RemoteViews,OnClickHandler)>","<android.widget.RemoteViewsAdapter.RemoteViewsFrameLayout: void onRemoteViewsLoaded(RemoteViews,OnClickHandler)>",0,"{
    try {
        // Remove all the children of this layout first
        removeAllViews();
        addView(view.apply(getContext(), this, handler));
    } catch (Exception e) {
        Log.e(TAG, ""Failed to apply RemoteViews."");
    }
}","{
    setOnClickHandler(handler);
    applyRemoteViews(view);
}",1,"/**
 * Updates this RemoteViewsFrameLayout depending on the view that was loaded.
 * @param view the RemoteViews that was loaded. If null, the RemoteViews was not loaded
 * successfully.
 */","/**
 * Updates this RemoteViewsFrameLayout depending on the view that was loaded.
 * @param view the RemoteViews that was loaded. If null, the RemoteViews was not loaded
 * successfully.
 */",0,,,0,,,,1,"2,4",2,"1,2,5","1,2","The implementation of the API has completely changed. In the early version, it uses try-catch statement to handle the exception, while the late version removes the try-catch statement. Also, the statements inside the try-catch block are also changed. The old implementation uses 'removeAllViews()' and 'addView()' methods, while the new implementation uses 'setOnClickHandler()' and 'applyRemoteViews()'.","The change of implementation can potentially lead to different behaviours. In the early version, if there is an exception thrown during the processing, the exception will be caught and logged; while in the late version, the exception will be directly thrown. Also, the late version API has the potential to return different values or types as the statements inside try-catch block are changed, and the dependent APIs (setOnClickHandler() and applyRemoteViews()) are changed too."
107,<android.text.style.TtsSpan.DecimalBuilder: DecimalBuilder setIntegerPart(String)>,23,24,<android.text.style.TtsSpan.DecimalBuilder: DecimalBuilder setIntegerPart(String)>,<android.text.style.TtsSpan.DecimalBuilder: DecimalBuilder setIntegerPart(String)>,0,"{
    return setStringArgument(TtsSpan.ARG_INTEGER_PART, integerPart);
}","{
    return setIntegerPart(String.valueOf(integerPart));
}",1,"/**
 * Sets the {@link #ARG_INTEGER_PART} argument.
 * @param integerPart A non-empty string of digits with an optional
 * leading + or -.
 * @return This instance.
 */","/**
 * Convenience method that converts the number to a String and sets it
 * to the value for {@link #ARG_INTEGER_PART}.
 * @param integerPart The integer part of the decimal.
 * @return This instance.
 */",1,,,0,,,,1,1,1,1,1,"The method implementation has changed from setStringArgument(TtsSpan.ARG\_INTEGER\_PART, integerPart) to setIntegerPart(String.valueOf(integerPart)). This is a change in the return statement, since the method is now using a different method to set the integer part.","The change in the implementation could lead to a different behavior, as the method setStringArgument and setIntegerPart may handle the input differently. This could lead to a compatibility issue if the input integerPart is not handled correctly by the new implementation."
109,"<android.accounts.AccountManager: void setAuthToken(Account,String,String)>",23,24,"<android.accounts.AccountManager: void setAuthToken(Account,String,String)>","<android.accounts.AccountManager: void setAuthToken(Account,String,String)>",0,"{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    if (authTokenType == null)
        throw new IllegalArgumentException(""authTokenType is null"");
    try {
        mService.setAuthToken(account, authTokenType, authToken);
    } catch (RemoteException e) {
        // won't ever happen
        throw new RuntimeException(e);
    }
}","{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    if (authTokenType == null)
        throw new IllegalArgumentException(""authTokenType is null"");
    try {
        mService.setAuthToken(account, authTokenType, authToken);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Adds an auth token to the AccountManager cache for an account.
 * If the account does not exist then this call has no effect.
 * Replaces any previous auth token for this account and auth token type.
 * Intended for use by the authenticator, not directly by applications.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>This method requires the caller to have a signature match with the
 * authenticator that manages the specified account.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * AUTHENTICATE_ACCOUNTS permission and same UID as account's authenticator
 * is needed for those platforms. See docs for this function in API level 22.
 *
 * @param account The account to set an auth token for
 * @param authTokenType The type of the auth token, see {#getAuthToken}
 * @param authToken The auth token to add to the cache
 */","/**
 * Adds an auth token to the AccountManager cache for an account.
 * If the account does not exist then this call has no effect.
 * Replaces any previous auth token for this account and auth token type.
 * Intended for use by the authenticator, not directly by applications.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>This method requires the caller to have a signature match with the
 * authenticator that manages the specified account.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * AUTHENTICATE_ACCOUNTS permission and same UID as account's authenticator
 * is needed for those platforms. See docs for this function in API level 22.
 *
 * @param account The account to set an auth token for
 * @param authTokenType The type of the auth token, see {#getAuthToken}
 * @param authToken The auth token to add to the cache
 */",0,,,0,,,,1,2,2,2,2,The catch block of the try-catch statement in the implementation of the API "setAuthToken" has been changed from throwing a new RuntimeException to throwing the rethrowFromSystemServer() method of the caught RemoteException.,"The change in the exception handling of the API could lead to different behaviors when the API is invoked. In the early version, if a RemoteException is caught, a new RuntimeException will be thrown. However, in the late version, if a RemoteException is caught, the rethrowFromSystemServer() method of the caught exception will be thrown. This difference could cause compatibility issues, as the late version may throw a different exception than the early version, which could potentially break the code that calls this API if it's not properly handled. Therefore, this change can be classified as a Compatibility Issue caused by potential different exception handlings."
115,<android.hardware.camera2.impl.CameraCaptureSessionImpl: void close()>,24,25,<android.hardware.camera2.impl.CameraCaptureSessionImpl: void close()>,<android.hardware.camera2.impl.CameraCaptureSessionImpl: void close()>,0,"{
    if (mClosed) {
        if (DEBUG)
            Log.v(TAG, mIdString + ""close - reentering"");
        return;
    }
    if (DEBUG)
        Log.v(TAG, mIdString + ""close - first time"");
    mClosed = true;
    /*
         * Flush out any repeating request. Since camera is closed, no new requests
         * can be queued, and eventually the entire request queue will be drained.
         *
         * If the camera device was already closed, short circuit and do nothing; since
         * no more internal device callbacks will fire anyway.
         *
         * Otherwise, once stopRepeating is done, wait for camera to idle, then unconfigure the
         * camera. Once that's done, fire #onClosed.
         */
    try {
        mDeviceImpl.stopRepeating();
    } catch (IllegalStateException e) {
        // OK: Camera device may already be closed, nothing else to do
        // TODO: Fire onClosed anytime we get the device onClosed or the ISE?
        // or just suppress the ISE only and rely onClosed.
        // Also skip any of the draining work if this is already closed.
        // Short-circuit; queue callback immediately and return
        mStateCallback.onClosed(this);
        return;
    } catch (CameraAccessException e) {
        // OK: close does not throw checked exceptions.
        Log.e(TAG, mIdString + ""Exception while stopping repeating: "", e);
    // TODO: call onError instead of onClosed if this happens
    }
    // If no sequences are pending, fire #onClosed immediately
    mSequenceDrainer.beginDrain();
}","{
    synchronized (this) {
        if (mClosed) {
            if (DEBUG)
                Log.v(TAG, mIdString + ""close - reentering"");
            return;
        }
        if (DEBUG)
            Log.v(TAG, mIdString + ""close - first time"");
        mClosed = true;
    }
    synchronized (mDeviceImpl.mInterfaceLock) {
        synchronized (this) {
            /*
                 * Flush out any repeating request. Since camera is closed, no new requests
                 * can be queued, and eventually the entire request queue will be drained.
                 *
                 * If the camera device was already closed, short circuit and do nothing; since
                 * no more internal device callbacks will fire anyway.
                 *
                 * Otherwise, once stopRepeating is done, wait for camera to idle, then unconfigure
                 * the camera. Once that's done, fire #onClosed.
                 */
            try {
                mDeviceImpl.stopRepeating();
            } catch (IllegalStateException e) {
                // OK: Camera device may already be closed, nothing else to do
                // TODO: Fire onClosed anytime we get the device onClosed or the ISE?
                // or just suppress the ISE only and rely onClosed.
                // Also skip any of the draining work if this is already closed.
                // Short-circuit; queue callback immediately and return
                mStateCallback.onClosed(this);
                return;
            } catch (CameraAccessException e) {
                // OK: close does not throw checked exceptions.
                Log.e(TAG, mIdString + ""Exception while stopping repeating: "", e);
            // TODO: call onError instead of onClosed if this happens
            }
        }
    }
    synchronized (this) {
        // If no sequences are pending, fire #onClosed immediately
        mSequenceDrainer.beginDrain();
    }
}",1,,,0,[@Override],[@Override],0,,,,1,"1,3,4",1,3,0,"The change in the code is related to control dependency. Specifically, in the late version, several synchronized blocks have been added, which modifies the control flow of the method.","Although the control flow has been modified, the behavior of the API remains the same. The added synchronized blocks do not affect the method's return values or exceptions. Therefore, there is no compatibility issue in this case."
120,<android.app.usage.NetworkStats: void finalize()>,25,26,<android.app.usage.NetworkStats: void finalize()>,<android.app.usage.NetworkStats: void finalize()>,0,"{
    try {
        if (mCloseGuard != null) {
            mCloseGuard.warnIfOpen();
        }
        close();
    } finally {
        super.finalize();
    }
}","{
    try {
        if (mCloseGuard != null) {
            mCloseGuard.warnIfOpen();
        }
        close();
    } finally {
        super.finalize();
    }
}",0,,,0,[@Override],[@Override],0,,,,0,0,0,0,0,"No changes have been made to the method implementation or annotations, so the code change type is 0.","As there are no changes in the method implementation or annotations, there is no potential for a Compatibility Issue (CI) to arise in the late version of the API. Therefore, the CI type is 0."
122,<android.widget.DatePickerCalendarDelegate: void onLocaleChanged(Locale)>,25,26,<android.widget.DatePickerCalendarDelegate: void onLocaleChanged(Locale)>,<android.widget.DatePickerCalendarDelegate: void onLocaleChanged(Locale)>,0,"{
    final TextView headerYear = mHeaderYear;
    if (headerYear == null) {
        // again later after everything has been set up.
        return;
    }
    // Update the date formatter.
    final String datePattern = DateFormat.getBestDateTimePattern(locale, ""EMMMd"");
    mMonthDayFormat = new SimpleDateFormat(datePattern, locale);
    mMonthDayFormat.setContext(DisplayContext.CAPITALIZATION_FOR_STANDALONE);
    mYearFormat = new SimpleDateFormat(""y"", locale);
    // Clear out the lazily-initialized accessibility event formatter.
    mAccessibilityEventFormat = null;
    // Update the header text.
    onCurrentDateChanged(false);
}","{
    final TextView headerYear = mHeaderYear;
    if (headerYear == null) {
        // again later after everything has been set up.
        return;
    }
    // Update the date formatter.
    final String datePattern = DateFormat.getBestDateTimePattern(locale, ""EMMMd"");
    mMonthDayFormat = new SimpleDateFormat(datePattern, locale);
    mMonthDayFormat.setContext(DisplayContext.CAPITALIZATION_FOR_STANDALONE);
    mYearFormat = new SimpleDateFormat(""y"", locale);
    // Update the header text.
    onCurrentDateChanged(false);
}",1,,,0,[@Override],[@Override],0,,,,1,4,0,4,0,"The statement ""mAccessibilityEventFormat = null;"" is removed from the late version. This statement is not related to return or exception handling, so it is categorized as ""Other statement changed"" with code 4.","The removed statement only clears out the lazily-initialized accessibility event formatter and doesn't affect the return value or exception handling, thus no Compatibility Issue arises in the given method between two continuous versions."
123,<android.view.ContextThemeWrapper: Theme getTheme()>,25,26,<android.view.ContextThemeWrapper: Theme getTheme()>,<android.view.ContextThemeWrapper: Theme getTheme()>,0,"{
    if (mTheme != null) {
        return mTheme;
    }
    mThemeResource = Resources.selectDefaultTheme(mThemeResource, getApplicationInfo().targetSdkVersion);
    initializeTheme();
    return mTheme;
}","{
    if (mTheme != null) {
        return mTheme;
    }
    mThemeResource = Resources.selectDefaultTheme(mThemeResource, getApplicationInfo().targetSdkVersion);
    initializeTheme();
    return mTheme;
}",0,,,0,[@Override],[@Override],0,,,,0,0,0,0,0,There is no change in the code implementation and annotation between the early and late versions of the API.,"Since there is no change in the code implementation, no Compatibility Issue arises for the API."
130,"<android.net.ConnectivityManager: void requestNetwork(NetworkRequest,PendingIntent)>",26,27,"<android.net.ConnectivityManager: void requestNetwork(NetworkRequest,PendingIntent)>","<android.net.ConnectivityManager: void requestNetwork(NetworkRequest,PendingIntent)>",0,"{
    checkPendingIntent(operation);
    try {
        mService.pendingRequestForNetwork(request.networkCapabilities, operation);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    checkPendingIntentNotNull(operation);
    try {
        mService.pendingRequestForNetwork(request.networkCapabilities, operation);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    } catch (ServiceSpecificException e) {
        throw convertServiceException(e);
    }
}",1,"/**
 * Request a network to satisfy a set of {@link android.net.NetworkCapabilities}.
 *
 * This function behaves identically to the version that takes a NetworkCallback, but instead
 * of {@link NetworkCallback} a {@link PendingIntent} is used.  This means
 * the request may outlive the calling application and get called back when a suitable
 * network is found.
 * <p>
 * The operation is an Intent broadcast that goes to a broadcast receiver that
 * you registered with {@link Context#registerReceiver} or through the
 * &lt;receiver&gt; tag in an AndroidManifest.xml file
 * <p>
 * The operation Intent is delivered with two extras, a {@link Network} typed
 * extra called {@link #EXTRA_NETWORK} and a {@link NetworkRequest}
 * typed extra called {@link #EXTRA_NETWORK_REQUEST} containing
 * the original requests parameters.  It is important to create a new,
 * {@link NetworkCallback} based request before completing the processing of the
 * Intent to reserve the network or it will be released shortly after the Intent
 * is processed.
 * <p>
 * If there is already a request for this Intent registered (with the equality of
 * two Intents defined by {@link Intent#filterEquals}), then it will be removed and
 * replaced by this one, effectively releasing the previous {@link NetworkRequest}.
 * <p>
 * The request may be released normally by calling
 * {@link #releaseNetworkRequest(android.app.PendingIntent)}.
 * <p>It is presently unsupported to request a network with either
 * {@link NetworkCapabilities#NET_CAPABILITY_VALIDATED} or
 * {@link NetworkCapabilities#NET_CAPABILITY_CAPTIVE_PORTAL}
 * as these {@code NetworkCapabilities} represent states that a particular
 * network may never attain, and whether a network will attain these states
 * is unknown prior to bringing up the network so the framework does not
 * know how to go about satisfing a request with these capabilities.
 *
 * <p>This method requires the caller to hold either the
 * {@link android.Manifest.permission#CHANGE_NETWORK_STATE} permission
 * or the ability to modify system settings as determined by
 * {@link android.provider.Settings.System#canWrite}.</p>
 *
 * @param request {@link NetworkRequest} describing this request.
 * @param operation Action to perform when the network is available (corresponds
 * to the {@link NetworkCallback#onAvailable} call.  Typically
 * comes from {@link PendingIntent#getBroadcast}. Cannot be null.
 * @throws IllegalArgumentException if {@code request} contains either
 * {@link NetworkCapabilities#NET_CAPABILITY_VALIDATED} or
 * {@link NetworkCapabilities#NET_CAPABILITY_CAPTIVE_PORTAL}.
 */","/**
 * Request a network to satisfy a set of {@link android.net.NetworkCapabilities}.
 *
 * This function behaves identically to the version that takes a NetworkCallback, but instead
 * of {@link NetworkCallback} a {@link PendingIntent} is used.  This means
 * the request may outlive the calling application and get called back when a suitable
 * network is found.
 * <p>
 * The operation is an Intent broadcast that goes to a broadcast receiver that
 * you registered with {@link Context#registerReceiver} or through the
 * &lt;receiver&gt; tag in an AndroidManifest.xml file
 * <p>
 * The operation Intent is delivered with two extras, a {@link Network} typed
 * extra called {@link #EXTRA_NETWORK} and a {@link NetworkRequest}
 * typed extra called {@link #EXTRA_NETWORK_REQUEST} containing
 * the original requests parameters.  It is important to create a new,
 * {@link NetworkCallback} based request before completing the processing of the
 * Intent to reserve the network or it will be released shortly after the Intent
 * is processed.
 * <p>
 * If there is already a request for this Intent registered (with the equality of
 * two Intents defined by {@link Intent#filterEquals}), then it will be removed and
 * replaced by this one, effectively releasing the previous {@link NetworkRequest}.
 * <p>
 * The request may be released normally by calling
 * {@link #releaseNetworkRequest(android.app.PendingIntent)}.
 * <p>It is presently unsupported to request a network with either
 * {@link NetworkCapabilities#NET_CAPABILITY_VALIDATED} or
 * {@link NetworkCapabilities#NET_CAPABILITY_CAPTIVE_PORTAL}
 * as these {@code NetworkCapabilities} represent states that a particular
 * network may never attain, and whether a network will attain these states
 * is unknown prior to bringing up the network so the framework does not
 * know how to go about satisfing a request with these capabilities.
 *
 * <p>This method requires the caller to hold either the
 * {@link android.Manifest.permission#CHANGE_NETWORK_STATE} permission
 * or the ability to modify system settings as determined by
 * {@link android.provider.Settings.System#canWrite}.</p>
 *
 * @param request {@link NetworkRequest} describing this request.
 * @param operation Action to perform when the network is available (corresponds
 * to the {@link NetworkCallback#onAvailable} call.  Typically
 * comes from {@link PendingIntent#getBroadcast}. Cannot be null.
 * @throws IllegalArgumentException if {@code request} contains either
 * {@link NetworkCapabilities#NET_CAPABILITY_VALIDATED} or
 * {@link NetworkCapabilities#NET_CAPABILITY_CAPTIVE_PORTAL}.
 */",0,,,0,,,,1,2,2,"2, 4",2,The implementation of the `requestNetwork` method has changed in two ways:,
131,"<android.app.FragmentManagerImpl: void dispatchOnFragmentActivityCreated(Fragment,Bundle,boolean)>",26,27,"<android.app.FragmentManagerImpl: void dispatchOnFragmentActivityCreated(Fragment,Bundle,boolean)>","<android.app.FragmentManagerImpl: void dispatchOnFragmentActivityCreated(Fragment,Bundle,boolean)>",0,"{
    if (mParent != null) {
        FragmentManager parentManager = mParent.getFragmentManager();
        if (parentManager instanceof FragmentManagerImpl) {
            ((FragmentManagerImpl) parentManager).dispatchOnFragmentActivityCreated(f, savedInstanceState, true);
        }
    }
    if (mLifecycleCallbacks == null) {
        return;
    }
    for (Pair<FragmentLifecycleCallbacks, Boolean> p : mLifecycleCallbacks) {
        if (!onlyRecursive || p.second) {
            p.first.onFragmentActivityCreated(this, f, savedInstanceState);
        }
    }
}","{
    if (mParent != null) {
        FragmentManager parentManager = mParent.getFragmentManager();
        if (parentManager instanceof FragmentManagerImpl) {
            ((FragmentManagerImpl) parentManager).dispatchOnFragmentActivityCreated(f, savedInstanceState, true);
        }
    }
    for (Pair<FragmentLifecycleCallbacks, Boolean> p : mLifecycleCallbacks) {
        if (!onlyRecursive || p.second) {
            p.first.onFragmentActivityCreated(this, f, savedInstanceState);
        }
    }
}",1,,,0,,,0,,,,1,"1,3",1,3,0,"The control dependency has changed. Specifically, the early version has an additional if statement ""if (mLifecycleCallbacks == null) { return; }"" which is removed in the late version.","No Compatibility Issue arises in this case. Although the control dependency has changed, the return statement and exception handling have not been affected, and the behavior of the API remains the same."
132,<android.service.autofill.SaveInfo.Builder: Builder setDescription(CharSequence)>,26,27,<android.service.autofill.SaveInfo.Builder: Builder setDescription(CharSequence)>,<android.service.autofill.SaveInfo.Builder: Builder setDescription(CharSequence)>,0,"{
    throwIfDestroyed();
    mDescription = description;
    return this;
}","{
    throwIfDestroyed();
    Preconditions.checkState(mCustomDescription == null, ""Can call setDescription() or setCustomDescription(), but not both"");
    mDescription = description;
    return this;
}",1,"/**
 * Sets an optional description to be shown in the UI when the user is asked to save.
 *
 * <p>Typically, it describes how the data will be stored by the service, so it can help
 * users to decide whether they can trust the service to save their data.
 *
 * @param description a succint description.
 * @return This Builder.
 */","/**
 * Sets an optional description to be shown in the UI when the user is asked to save.
 *
 * <p>Typically, it describes how the data will be stored by the service, so it can help
 * users to decide whether they can trust the service to save their data.
 *
 * @param description a succint description.
 * @return This Builder.
 *
 * @throws IllegalStateException if this call was made after calling
 * {@link #setCustomDescription(CustomDescription)}.
 */",1,[@NonNull],[@NonNull],0,,,,1,4,0,"4,5",1,"An additional statement has been introduced (Preconditions.checkState(mCustomDescription == null, ""Can call setDescription() or setCustomDescription(), but not both"")), thus the change type is 4,5.","The introduced statement could lead to different behavior when the late version API is invoked, as it could throw a different exception (IllegalStateException) in certain situations, leading to a Compatibility Issue. The CI type is 1."
137,<android.view.textclassifier.TextSelection.Builder: TextSelection build()>,26,27,<android.view.textclassifier.TextSelection.Builder: TextSelection build()>,<android.view.textclassifier.TextSelection.Builder: TextSelection build()>,0,"{
    return new TextSelection(mStartIndex, mEndIndex, mEntityConfidence, mLogSource);
}","{
    return new TextSelection(mStartIndex, mEndIndex, mEntityConfidence, mLogSource, mVersionInfo);
}",1,"/**
 * Builds and returns {@link TextSelection} object.
 */","/**
 * Builds and returns {@link TextSelection} object.
 */",0,,,0,,,,"1,2","1,5",1,1,1,"The implementation of the ""build"" method in the ""TextSelection.Builder"" class has changed between versions 26 and 27. In the early version, the method returns a ""TextSelection"" object created with four arguments, while in the late version, the method returns a ""TextSelection"" object created with five arguments. The additional argument ""mVersionInfo"" is passed to the constructor in the late version.","This change in the implementation can lead to a compatibility issue, as the returned ""TextSelection"" object in the late version may have different properties or behavior compared to the one returned in the early version due to the additional argument ""mVersionInfo"" passed to the constructor. This may cause issues in the code that depends on the properties or behavior of the ""TextSelection"" object returned by the ""build"" method. Therefore, this change can be classified as a compatibility issue caused by potential different return values or types."
138,"<android.app.Notification.BigTextStyle: void applyBigTextContentView(Builder,RemoteViews,CharSequence)>",26,27,"<android.app.Notification.BigTextStyle: void applyBigTextContentView(Builder,RemoteViews,CharSequence)>","<android.app.Notification.BigTextStyle: void applyBigTextContentView(Builder,RemoteViews,CharSequence)>",0,"{
    contentView.setTextViewText(R.id.big_text, bigTextText);
    builder.setTextViewColorSecondary(contentView, R.id.big_text);
    contentView.setViewVisibility(R.id.big_text, TextUtils.isEmpty(bigTextText) ? View.GONE : View.VISIBLE);
    contentView.setBoolean(R.id.big_text, ""setHasImage"", builder.mN.hasLargeIcon());
}","{
    contentView.setTextViewText(R.id.big_text, builder.processTextSpans(bigTextText));
    builder.setTextViewColorSecondary(contentView, R.id.big_text);
    contentView.setViewVisibility(R.id.big_text, TextUtils.isEmpty(bigTextText) ? View.GONE : View.VISIBLE);
    contentView.setBoolean(R.id.big_text, ""setHasImage"", builder.mN.hasLargeIcon());
}",1,,,0,,,0,,,,"1,2",5,0,"4,5",1,"The method `setTextViewText()` has changed in the way it processes the input `bigTextText`. In the early version, it directly sets the text using the input `bigTextText`. In the late version, the method `processTextSpans()` is called on builder object to process the input `bigTextText` before setting it as the text. This is a change in dependent API, hence code change type is 4,5.","Due to the change in the way `bigTextText` is processed, the text displayed in the big text style notification may differ between the two versions. Hence, it is a compatibility issue caused by potential different return values or types, which is CI type 1."
139,<android.widget.Editor.HandleView: void show()>,26,27,<android.widget.Editor.HandleView: void show()>,<android.widget.Editor.HandleView: void show()>,0,"{
    if (isShowing())
        return;
    getPositionListener().addSubscriber(this, true);
    // Make sure the offset is always considered new, even when focusing at same position
    mPreviousOffset = -1;
    positionAtCursorOffset(getCurrentCursorOffset(), false);
}","{
    if (isShowing())
        return;
    getPositionListener().addSubscriber(this, true);
    // Make sure the offset is always considered new, even when focusing at same position
    mPreviousOffset = -1;
    positionAtCursorOffset(getCurrentCursorOffset(), false, false);
}",1,,,0,,,0,,,,2,5,0,5,1,"The change is related to a dependent API called 'positionAtCursorOffset()'. The method signature of the dependent API has changed from positionAtCursorOffset(int offset, boolean fromUser) to positionAtCursorOffset(int offset, boolean fromUser, boolean forceGravity). Thus, the code change type is 5.","The new parameter 'forceGravity' added to the 'positionAtCursorOffset()' method may affect the behavior of the method, leading to different return values or types, which could result in a Compatibility Issue with a CI type of 1."
140,<android.os.WorkSource: void clear()>,27,28,<android.os.WorkSource: void clear()>,<android.os.WorkSource: void clear()>,0,"{
    mNum = 0;
}","{
    mNum = 0;
    if (mChains != null) {
        mChains.clear();
    }
}",1,"/**
 * Clear this WorkSource to be empty.
 */","/**
 * Clear this WorkSource to be empty.
 */",0,,,0,,,,1,3,0,3,1,"In the late version of the WorkSource.clear() method, a new condition statement has been added to clear the 'mChains' variable if it is not null. This is a control dependency change as it affects the behavior of the method.","The new control dependency added in the late version of the WorkSource.clear() method can potentially lead to different behaviors. If the 'mChains' variable is not null, the method will clear it, which was not the case in the early version. This can potentially cause the API to return a different value, leading to a Compatibility Issue (CI)."
141,<android.app.Notification.Action.Builder: Action build()>,27,28,<android.app.Notification.Action.Builder: Action build()>,<android.app.Notification.Action.Builder: Action build()>,0,"{
    ArrayList<RemoteInput> dataOnlyInputs = new ArrayList<>();
    RemoteInput[] previousDataInputs = (RemoteInput[]) mExtras.getParcelableArray(EXTRA_DATA_ONLY_INPUTS);
    if (previousDataInputs != null) {
        for (RemoteInput input : previousDataInputs) {
            dataOnlyInputs.add(input);
        }
    }
    List<RemoteInput> textInputs = new ArrayList<>();
    if (mRemoteInputs != null) {
        for (RemoteInput input : mRemoteInputs) {
            if (input.isDataOnly()) {
                dataOnlyInputs.add(input);
            } else {
                textInputs.add(input);
            }
        }
    }
    if (!dataOnlyInputs.isEmpty()) {
        RemoteInput[] dataInputsArr = dataOnlyInputs.toArray(new RemoteInput[dataOnlyInputs.size()]);
        mExtras.putParcelableArray(EXTRA_DATA_ONLY_INPUTS, dataInputsArr);
    }
    RemoteInput[] textInputsArr = textInputs.isEmpty() ? null : textInputs.toArray(new RemoteInput[textInputs.size()]);
    return new Action(mIcon, mTitle, mIntent, mExtras, textInputsArr, mAllowGeneratedReplies);
}","{
    ArrayList<RemoteInput> dataOnlyInputs = new ArrayList<>();
    RemoteInput[] previousDataInputs = (RemoteInput[]) mExtras.getParcelableArray(EXTRA_DATA_ONLY_INPUTS);
    if (previousDataInputs != null) {
        for (RemoteInput input : previousDataInputs) {
            dataOnlyInputs.add(input);
        }
    }
    List<RemoteInput> textInputs = new ArrayList<>();
    if (mRemoteInputs != null) {
        for (RemoteInput input : mRemoteInputs) {
            if (input.isDataOnly()) {
                dataOnlyInputs.add(input);
            } else {
                textInputs.add(input);
            }
        }
    }
    if (!dataOnlyInputs.isEmpty()) {
        RemoteInput[] dataInputsArr = dataOnlyInputs.toArray(new RemoteInput[dataOnlyInputs.size()]);
        mExtras.putParcelableArray(EXTRA_DATA_ONLY_INPUTS, dataInputsArr);
    }
    RemoteInput[] textInputsArr = textInputs.isEmpty() ? null : textInputs.toArray(new RemoteInput[textInputs.size()]);
    return new Action(mIcon, mTitle, mIntent, mExtras, textInputsArr, mAllowGeneratedReplies, mSemanticAction);
}",1,"/**
 * Combine all of the options that have been set and return a new {@link Action}
 * object.
 * @return the built action
 */","/**
 * Combine all of the options that have been set and return a new {@link Action}
 * object.
 * @return the built action
 */",0,,,0,,,,2,"1,5",1,5,1,"The addition of a new parameter is observed in the constructor of the return statement. Specifically, the code change is the inclusion of 'mSemanticAction' in the constructor call of 'Action' class in the late version of the API. This change belongs to the category 5, Dependent API changed.","This change in the constructor of the 'Action' class potentially leads to a different behaviour of the API. Specifically, this CI is caused by potential different return values or types (category 1), as the newly added parameter in the constructor might affect the internal state of the returned 'Action' object."
142,"<android.net.NetworkCapabilities: void writeToParcel(Parcel,int)>",27,28,"<android.net.NetworkCapabilities: void writeToParcel(Parcel,int)>","<android.net.NetworkCapabilities: void writeToParcel(Parcel,int)>",0,"{
    dest.writeLong(mNetworkCapabilities);
    dest.writeLong(mTransportTypes);
    dest.writeInt(mLinkUpBandwidthKbps);
    dest.writeInt(mLinkDownBandwidthKbps);
    dest.writeParcelable((Parcelable) mNetworkSpecifier, flags);
    dest.writeInt(mSignalStrength);
}","{
    dest.writeLong(mNetworkCapabilities);
    dest.writeLong(mUnwantedNetworkCapabilities);
    dest.writeLong(mTransportTypes);
    dest.writeInt(mLinkUpBandwidthKbps);
    dest.writeInt(mLinkDownBandwidthKbps);
    dest.writeParcelable((Parcelable) mNetworkSpecifier, flags);
    dest.writeInt(mSignalStrength);
    dest.writeArraySet(mUids);
    dest.writeString(mSSID);
}",1,,,0,[@Override],[@Override],0,,,,1,4,0,"5,4",1,"The Late_Implementation includes two new statements: dest.writeLong(mUnwantedNetworkCapabilities); and dest.writeArraySet(mUids); dest.writeString(mSSID); which are not present in the Early_Implementation, so the code change type is 5,4.","The new statements added in the Late_Implementation write the values of mUnwantedNetworkCapabilities, mUids, and mSSID to the Parcel object. This might lead to different behavior when the method is called in the late version, so the CI type is 1."
143,<android.view.textclassifier.TextClassification: String toString()>,27,28,<android.view.textclassifier.TextClassification: String toString()>,<android.view.textclassifier.TextClassification: String toString()>,0,"{
    return String.format(""TextClassification {"" + ""text=%s, entities=%s, label=%s, intent=%s}"", mText, mEntityConfidence, mLabel, mIntent);
}","{
    return String.format(Locale.US, ""TextClassification {text=%s, entities=%s, actions=%s, id=%s}"", mText, mEntityConfidence, mActions, mId);
}",1,,,0,[@Override],[@Override],0,,,,"1,2","1,5",1,1,1,"The return statement has changed between the early and late versions. In the early version, the return statement is using `String.format` to concatenate the values of `mText`, `mEntityConfidence`, `mLabel`, and `mIntent`. However, in the late version, the return statement is using `String.format` with `Locale.US` to concatenate the values of `mText`, `mEntityConfidence`, `mActions`, and `mId`.","The change in the return statement can lead to a different string representation of the `TextClassification` object. This can cause compatibility issues for any code that relies on the specific format of the string returned by the `toString` method, such as logging, debugging, or testing. Therefore, this change can potentially cause a Compatibility Issue of type 1: Compatibility Issue caused by potential different return values or types."
145,"<android.util.proto.ProtoOutputStream: void writeRepeatedObject(long,byte[])>",27,28,"<android.util.proto.ProtoOutputStream: void writeRepeatedObject(long,byte[])>","<android.util.proto.ProtoOutputStream: void writeRepeatedObject(long,byte[])>",0,"{
    assertNotCompacted();
    final int id = checkFieldId(fieldId, FIELD_COUNT_REPEATED | FIELD_TYPE_OBJECT);
    writeRepeatedObjectImpl(id, value);
}","{
    assertNotCompacted();
    final int id = checkFieldId(fieldId, FIELD_COUNT_REPEATED | FIELD_TYPE_MESSAGE);
    writeRepeatedObjectImpl(id, value);
}",1,"/**
 * Write an object that has already been flattend.
 *
 * @deprecated Use #write instead.
 */","/**
 * Write an object that has already been flattend.
 *
 * @deprecated Use #write instead.
 */",0,[@Deprecated],[@Deprecated],0,,,,2,5,0,5,1,The second argument in the checkFieldId() method has changed from FIELD\_TYPE\_OBJECT to FIELD\_TYPE\_MESSAGE. This is a dependent API change (change type 5).,"As the second argument of checkFieldId() has changed, the id assigned by checkFieldId() could be different, which in turn affects the behavior of writeRepeatedObjectImpl(). Therefore, the API potentially returns different values or throws different exceptions, leading to a Compatibility Issue of type 1."
146,<android.view.textclassifier.TextClassification: int getEntityCount()>,27,28,<android.view.textclassifier.TextClassification: int getEntityCount()>,<android.view.textclassifier.TextClassification: int getEntityCount()>,0,"{
    return mEntities.size();
}","{
    return mEntityConfidence.getEntities().size();
}",1,"/**
 * Returns the number of entities found in the classified text.
 */","/**
 * Returns the number of entities found in the classified text.
 */",1,[@IntRange(from = 0)],[@IntRange(from = 0)],0,,,,1.2,"1,5",1,"1,5",1,"The return statement has changed from mEntities.size() to mEntityConfidence.getEntities().size(), and the variable used to get the size has changed, so the code change type is 1,5.","The change of return statement will make the API potentially return a different value, so the CI type is 1."
147,<android.view.accessibility.AccessibilityWindowInfo: boolean isInPictureInPictureMode()>,27,28,<android.view.accessibility.AccessibilityWindowInfo: boolean isInPictureInPictureMode()>,<android.view.accessibility.AccessibilityWindowInfo: boolean isInPictureInPictureMode()>,0,"{
    return mInPictureInPicture;
}","{
    return getBooleanProperty(BOOLEAN_PROPERTY_PICTURE_IN_PICTURE);
}",1,"/**
 * Check if the window is in picture-in-picture mode.
 *
 * @return {@code true} if the window is in picture-in-picture mode, {@code false} otherwise.
 */","/**
 * Check if the window is in picture-in-picture mode.
 *
 * @return {@code true} if the window is in picture-in-picture mode, {@code false} otherwise.
 */",0,,,0,,,,1,1,1,"1,5",1,"The return statement of the method has been changed. In the early version, the method returns the value of the `mInPictureInPicture` variable, while in the late version, the method returns the value of the `BOOLEAN_PROPERTY_PICTURE_IN_PICTURE` property using the `getBooleanProperty` method. This change may lead to different return values.","The change of the return statement may cause the method to return different values, which may lead to compatibility issues. For example, if a client app relies on the `isInPictureInPictureMode` method to check whether the app is in picture-in-picture mode, it may get a different result between the two versions, which may affect the app's behavior. Therefore, this is a compatibility issue caused by potential different return values or types."
149,<android.companion.CompanionDeviceManager.CallbackProxy: void onSuccess(PendingIntent)>,27,28,<android.companion.CompanionDeviceManager.CallbackProxy: void onSuccess(PendingIntent)>,<android.companion.CompanionDeviceManager.CallbackProxy: void onSuccess(PendingIntent)>,0,"{
    Handler handler = mHandler;
    if (handler == null)
        return;
    handler.post(() -> {
        Callback callback = mCallback;
        if (callback == null)
            return;
        callback.onDeviceFound(launcher.getIntentSender());
    });
}","{
    lockAndPost(Callback::onDeviceFound, launcher.getIntentSender());
}",1,,,0,[@Override],[@Override],0,,,,1,"1,3,4",1,5,1,"The implementation of the method has changed from using a Handler to post a task to the queue, to using a lockAndPost method. The lockAndPost method is a new method introduced in the late version, and it changes the way the callback is triggered, potentially leading to different behavior.","The change in the implementation could lead to different behavior, and it could potentially cause the API to return different values, as the callback may not be called in the same manner as in the previous version. Therefore, it is a Compatibility Issue caused by potential different return values or types."
158,"<android.service.notification.ZenModeConfig.ZenRule: void writeToParcel(Parcel,int)>",28,29,"<android.service.notification.ZenModeConfig.ZenRule: void writeToParcel(Parcel,int)>","<android.service.notification.ZenModeConfig.ZenRule: void writeToParcel(Parcel,int)>",0,"{
    dest.writeInt(enabled ? 1 : 0);
    dest.writeInt(snoozing ? 1 : 0);
    if (name != null) {
        dest.writeInt(1);
        dest.writeString(name);
    } else {
        dest.writeInt(0);
    }
    dest.writeInt(zenMode);
    dest.writeParcelable(conditionId, 0);
    dest.writeParcelable(condition, 0);
    dest.writeParcelable(component, 0);
    if (id != null) {
        dest.writeInt(1);
        dest.writeString(id);
    } else {
        dest.writeInt(0);
    }
    dest.writeLong(creationTime);
    if (enabler != null) {
        dest.writeInt(1);
        dest.writeString(enabler);
    } else {
        dest.writeInt(0);
    }
}","{
    dest.writeInt(enabled ? 1 : 0);
    dest.writeInt(snoozing ? 1 : 0);
    if (name != null) {
        dest.writeInt(1);
        dest.writeString(name);
    } else {
        dest.writeInt(0);
    }
    dest.writeInt(zenMode);
    dest.writeParcelable(conditionId, 0);
    dest.writeParcelable(condition, 0);
    dest.writeParcelable(component, 0);
    dest.writeParcelable(configurationActivity, 0);
    if (id != null) {
        dest.writeInt(1);
        dest.writeString(id);
    } else {
        dest.writeInt(0);
    }
    dest.writeLong(creationTime);
    if (enabler != null) {
        dest.writeInt(1);
        dest.writeString(enabler);
    } else {
        dest.writeInt(0);
    }
    dest.writeParcelable(zenPolicy, 0);
    dest.writeInt(modified ? 1 : 0);
    dest.writeString(pkg);
}",1,,,0,[@Override],[@Override],0,,,,1,4,0,"4,5",1,"The implementation of the `writeToParcel` method has changed by adding two new statements `dest.writeParcelable(configurationActivity, 0);` and `dest.writeParcelable(zenPolicy, 0);` and modifying the statement `dest.writeInt(modified ? 1 : 0);` and `dest.writeString(pkg);` that were not present in the early version.","The changes made in the implementation of the `writeToParcel` method can cause a compatibility issue as the method now writes a different set of data to the `Parcel` object. This can lead to the API returning a different value or type, which can cause compatibility issues with applications that rely on the original behavior of the method."
159,<android.view.View: void setAutofillId(AutofillId)>,28,29,<android.view.View: void setAutofillId(AutofillId)>,<android.view.View: void setAutofillId(AutofillId)>,0,"{
    // TODO(b/37566627): add unit / CTS test for all possible combinations below
    if (android.view.autofill.Helper.sVerbose) {
        Log.v(VIEW_LOG_TAG, ""setAutofill(): from "" + mAutofillId + "" to "" + id);
    }
    if (isAttachedToWindow()) {
        throw new IllegalStateException(""Cannot set autofill id when view is attached"");
    }
    if (id != null && id.isVirtual()) {
        throw new IllegalStateException(""Cannot set autofill id assigned to virtual views"");
    }
    if (id == null && (mPrivateFlags3 & PFLAG3_AUTOFILLID_EXPLICITLY_SET) == 0) {
        // Ignore reset because it was never explicitly set before.
        return;
    }
    mAutofillId = id;
    if (id != null) {
        mAutofillViewId = id.getViewId();
        mPrivateFlags3 |= PFLAG3_AUTOFILLID_EXPLICITLY_SET;
    } else {
        mAutofillViewId = NO_ID;
        mPrivateFlags3 &= ~PFLAG3_AUTOFILLID_EXPLICITLY_SET;
    }
}","{
    // TODO(b/37566627): add unit / CTS test for all possible combinations below
    if (Log.isLoggable(AUTOFILL_LOG_TAG, Log.VERBOSE)) {
        Log.v(AUTOFILL_LOG_TAG, ""setAutofill(): from "" + mAutofillId + "" to "" + id);
    }
    if (isAttachedToWindow()) {
        throw new IllegalStateException(""Cannot set autofill id when view is attached"");
    }
    if (id != null && !id.isNonVirtual()) {
        throw new IllegalStateException(""Cannot set autofill id assigned to virtual views"");
    }
    if (id == null && (mPrivateFlags3 & PFLAG3_AUTOFILLID_EXPLICITLY_SET) == 0) {
        // Ignore reset because it was never explicitly set before.
        return;
    }
    mAutofillId = id;
    if (id != null) {
        mAutofillViewId = id.getViewId();
        mPrivateFlags3 |= PFLAG3_AUTOFILLID_EXPLICITLY_SET;
    } else {
        mAutofillViewId = NO_ID;
        mPrivateFlags3 &= ~PFLAG3_AUTOFILLID_EXPLICITLY_SET;
    }
}",1,"/**
 * Sets the unique, logical identifier of this view in the activity, for autofill purposes.
 *
 * <p>The autofill id is created on demand, and this method should only be called when a view is
 * reused after {@link #dispatchProvideAutofillStructure(ViewStructure, int)} is called, as
 * that method creates a snapshot of the view that is passed along to the autofill service.
 *
 * <p>This method is typically used when view subtrees are recycled to represent different
 * content* &mdash;in this case, the autofill id can be saved before the view content is swapped
 * out, and restored later when it's swapped back in. For example:
 *
 * <pre>
 * EditText reusableView = ...;
 * ViewGroup parentView = ...;
 * AutofillManager afm = ...;
 *
 * // Swap out the view and change its contents
 * AutofillId oldId = reusableView.getAutofillId();
 * CharSequence oldText = reusableView.getText();
 * parentView.removeView(reusableView);
 * AutofillId newId = afm.getNextAutofillId();
 * reusableView.setText(""New I am"");
 * reusableView.setAutofillId(newId);
 * parentView.addView(reusableView);
 *
 * // Later, swap the old content back in
 * parentView.removeView(reusableView);
 * reusableView.setAutofillId(oldId);
 * reusableView.setText(oldText);
 * parentView.addView(reusableView);
 * </pre>
 *
 * @param id an autofill ID that is unique in the {@link android.app.Activity} hosting the view,
 * or {@code null} to reset it. Usually it's an id previously allocated to another view (and
 * obtained through {@link #getAutofillId()}), or a new value obtained through
 * {@link AutofillManager#getNextAutofillId()}.
 *
 * @throws IllegalStateException if the view is already {@link #isAttachedToWindow() attached to
 * a window}.
 *
 * @throws IllegalArgumentException if the id is an autofill id associated with a virtual view.
 */","/**
 * Sets the unique, logical identifier of this view in the activity, for autofill purposes.
 *
 * <p>The autofill id is created on demand, and this method should only be called when a view is
 * reused after {@link #dispatchProvideAutofillStructure(ViewStructure, int)} is called, as
 * that method creates a snapshot of the view that is passed along to the autofill service.
 *
 * <p>This method is typically used when view subtrees are recycled to represent different
 * content* &mdash;in this case, the autofill id can be saved before the view content is swapped
 * out, and restored later when it's swapped back in. For example:
 *
 * <pre>
 * EditText reusableView = ...;
 * ViewGroup parentView = ...;
 * AutofillManager afm = ...;
 *
 * // Swap out the view and change its contents
 * AutofillId oldId = reusableView.getAutofillId();
 * CharSequence oldText = reusableView.getText();
 * parentView.removeView(reusableView);
 * AutofillId newId = afm.getNextAutofillId();
 * reusableView.setText(""New I am"");
 * reusableView.setAutofillId(newId);
 * parentView.addView(reusableView);
 *
 * // Later, swap the old content back in
 * parentView.removeView(reusableView);
 * reusableView.setAutofillId(oldId);
 * reusableView.setText(oldText);
 * parentView.addView(reusableView);
 * </pre>
 *
 * @param id an autofill ID that is unique in the {@link android.app.Activity} hosting the view,
 * or {@code null} to reset it. Usually it's an id previously allocated to another view (and
 * obtained through {@link #getAutofillId()}), or a new value obtained through
 * {@link AutofillManager#getNextAutofillId()}.
 *
 * @throws IllegalStateException if the view is already {@link #isAttachedToWindow() attached to
 * a window}.
 *
 * @throws IllegalArgumentException if the id is an autofill id associated with a virtual view.
 */",0,,,0,,,,1,3,2,2,2,"The log statement has been updated from using `android.view.autofill.Helper.sVerbose` to using `Log.isLoggable(AUTOFILL_LOG_TAG, Log.VERBOSE)`. Additionally, the condition for throwing the `IllegalStateException` has been updated from `id != null && id.isVirtual()` to `id != null && !id.isNonVirtual()`. These changes do not affect the return value of the method, but they do affect the conditions under which an exception is thrown.","The change in the condition for throwing the `IllegalStateException` could potentially result in different exception handling behavior between the two versions. If the `id` passed to the method is a non-virtual autofill id in the late version, an exception will not be thrown, whereas in the early version, an exception would have been thrown for a virtual autofill id. Therefore, this change has the potential to cause a compatibility issue due to different exception handling behavior."
160,<android.companion.WifiDeviceFilter.Builder: WifiDeviceFilter build()>,29,30,<android.companion.WifiDeviceFilter.Builder: WifiDeviceFilter build()>,<android.companion.WifiDeviceFilter.Builder: WifiDeviceFilter build()>,0,"{
    markUsed();
    return new WifiDeviceFilter(mNamePattern);
}","{
    checkNotUsed();
    // Mark builder used
    mBuilderFieldsSet |= 0x8;
    if ((mBuilderFieldsSet & 0x1) == 0) {
        mNamePattern = null;
    }
    if ((mBuilderFieldsSet & 0x2) == 0) {
        mBssid = null;
    }
    if ((mBuilderFieldsSet & 0x4) == 0) {
        mBssidMask = MacAddress.BROADCAST_ADDRESS;
    }
    WifiDeviceFilter o = new WifiDeviceFilter(mNamePattern, mBssid, mBssidMask);
    return o;
}",1,"/**
 * @inheritDoc
 */","/**
 * Builds the instance. This builder should not be touched after calling this!
 */",1,"[@Override, @NonNull]",[@NonNull],1,,,,"1,2","1,3,4,5",1,"1,5",1,"The implementation of the build() method has been changed significantly. In the early version, the method directly creates a new WifiDeviceFilter object using mNamePattern as the parameter. In the late version, the method first checks whether the builder is used, sets a flag to mark the builder as used, initializes the fields (mNamePattern, mBssid, mBssidMask) based on the builder fields set, and then creates a new WifiDeviceFilter object using the initialized fields. Moreover, the constructor of WifiDeviceFilter class has also been changed to accept three parameters (mNamePattern, mBssid, mBssidMask) in the late version.","The change in the build() method can cause different behaviors in the late version. Specifically, the late version of the build() method may return a WifiDeviceFilter object with different field values compared to the early version, depending on the values of the builder fields set. Therefore, it is a compatibility issue caused by potential different return values."
161,<android.hardware.camera2.impl.CameraDeviceImpl: void tearDown(Surface)>,29,30,<android.hardware.camera2.impl.CameraDeviceImpl: void tearDown(Surface)>,<android.hardware.camera2.impl.CameraDeviceImpl: void tearDown(Surface)>,0,"{
    if (surface == null)
        throw new IllegalArgumentException(""Surface is null"");
    synchronized (mInterfaceLock) {
        int streamId = -1;
        for (int i = 0; i < mConfiguredOutputs.size(); i++) {
            if (surface == mConfiguredOutputs.valueAt(i).getSurface()) {
                streamId = mConfiguredOutputs.keyAt(i);
                break;
            }
        }
        if (streamId == -1) {
            throw new IllegalArgumentException(""Surface is not part of this session"");
        }
        mRemoteDevice.tearDown(streamId);
    }
}","{
    if (surface == null)
        throw new IllegalArgumentException(""Surface is null"");
    synchronized (mInterfaceLock) {
        checkIfCameraClosedOrInError();
        int streamId = -1;
        for (int i = 0; i < mConfiguredOutputs.size(); i++) {
            if (surface == mConfiguredOutputs.valueAt(i).getSurface()) {
                streamId = mConfiguredOutputs.keyAt(i);
                break;
            }
        }
        if (streamId == -1) {
            throw new IllegalArgumentException(""Surface is not part of this session"");
        }
        mRemoteDevice.tearDown(streamId);
    }
}",1,,,0,,,0,,,,1,4,0,3,1,"A new statement ""checkIfCameraClosedOrInError();"" is added in the late version, which is a control dependency change.","As the new statement ""checkIfCameraClosedOrInError();"" is added, if the camera is closed or in error, it may cause the API to return a different value, leading to a Compatibility Issue. Therefore, the CI type is 1."
163,<android.view.DisplayCutout: boolean equals(Object)>,29,30,<android.view.DisplayCutout: boolean equals(Object)>,<android.view.DisplayCutout: boolean equals(Object)>,0,"{
    if (o == this) {
        return true;
    }
    if (o instanceof DisplayCutout) {
        DisplayCutout c = (DisplayCutout) o;
        return mSafeInsets.equals(c.mSafeInsets) && mBounds.equals(c.mBounds);
    }
    return false;
}","{
    if (o == this) {
        return true;
    }
    if (o instanceof DisplayCutout) {
        DisplayCutout c = (DisplayCutout) o;
        return mSafeInsets.equals(c.mSafeInsets) && mBounds.equals(c.mBounds) && mWaterfallInsets.equals(c.mWaterfallInsets);
    }
    return false;
}",1,,,0,[@Override],[@Override],0,,,,1,1,1,"1,3",1,"The return statement in the if-branch has been modified, and a new variable 'mWaterfallInsets' has been added into the equality checking. Thus the code change type is 1,3","As the new variable 'mWaterfallInsets' is added into the equality checking, the API may return a different value, leading to a Compatibility Issue. The CI type is 1."
165,<android.net.TrafficStats: long getUidTxPackets(int)>,29,30,<android.net.TrafficStats: long getUidTxPackets(int)>,<android.net.TrafficStats: long getUidTxPackets(int)>,0,"{
    // This isn't actually enforcing any security; it just returns the
    // unsupported value. The real filtering is done at the kernel level.
    final int callingUid = android.os.Process.myUid();
    if (callingUid == android.os.Process.SYSTEM_UID || callingUid == uid) {
        try {
            return getStatsService().getUidStats(uid, TYPE_TX_PACKETS);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    } else {
        return UNSUPPORTED;
    }
}","{
    try {
        return getStatsService().getUidStats(uid, TYPE_TX_PACKETS);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Return number of packets transmitted by the given UID since device boot.
 * Counts packets across all network interfaces, and always increases
 * monotonically since device boot. Statistics are measured at the network
 * layer, so they include both TCP and UDP usage.
 * <p>
 * Before {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, this may return
 * {@link #UNSUPPORTED} on devices where statistics aren't available.
 * <p>
 * Starting in {@link android.os.Build.VERSION_CODES#N} this will only
 * report traffic statistics for the calling UID. It will return
 * {@link #UNSUPPORTED} for all other UIDs for privacy reasons. To access
 * historical network statistics belonging to other UIDs, use
 * {@link NetworkStatsManager}.
 *
 * @see android.os.Process#myUid()
 * @see android.content.pm.ApplicationInfo#uid
 */","/**
 * Return number of packets transmitted by the given UID since device boot.
 * Counts packets across all network interfaces, and always increases
 * monotonically since device boot. Statistics are measured at the network
 * layer, so they include both TCP and UDP usage.
 * <p>
 * Before {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, this may return
 * {@link #UNSUPPORTED} on devices where statistics aren't available.
 * <p>
 * Starting in {@link android.os.Build.VERSION_CODES#N} this will only
 * report traffic statistics for the calling UID. It will return
 * {@link #UNSUPPORTED} for all other UIDs for privacy reasons. To access
 * historical network statistics belonging to other UIDs, use
 * {@link NetworkStatsManager}.
 *
 * @see android.os.Process#myUid()
 * @see android.content.pm.ApplicationInfo#uid
 */",0,,,0,,,,"1,2","1,2,3,4","1,2","1, 3",1,"The early version has a security check based on the callingUid, and it will return UNSUPPORTED if the callingUid is not equal to android.os.Process.SYSTEM_UID or uid. However, the late version does not have this check, and it will always return the result of getStatsService().getUidStats(uid, TYPE_TX_PACKETS).","The late version API potentially returns different variable values compared to the early version API. Specifically, for the same input uid, if the callingUid is not equal to android.os.Process.SYSTEM_UID or uid, the early version API will return UNSUPPORTED, while the late version API will return the result of getStatsService().getUidStats(uid, TYPE_TX_PACKETS). This difference leads to compatibility issues."
166,<android.security.keystore.recovery.KeyChainProtectionParams.Builder: KeyChainProtectionParams build()>,29,30,<android.security.keystore.recovery.KeyChainProtectionParams.Builder: KeyChainProtectionParams build()>,<android.security.keystore.recovery.KeyChainProtectionParams.Builder: KeyChainProtectionParams build()>,0,"{
    if (mInstance.mUserSecretType == null) {
        mInstance.mUserSecretType = TYPE_LOCKSCREEN;
    }
    Preconditions.checkNotNull(mInstance.mLockScreenUiFormat);
    Preconditions.checkNotNull(mInstance.mKeyDerivationParams);
    if (mInstance.mSecret == null) {
        mInstance.mSecret = new byte[] {};
    }
    return mInstance;
}","{
    if (mInstance.mUserSecretType == null) {
        mInstance.mUserSecretType = TYPE_LOCKSCREEN;
    }
    Objects.requireNonNull(mInstance.mLockScreenUiFormat);
    Objects.requireNonNull(mInstance.mKeyDerivationParams);
    if (mInstance.mSecret == null) {
        mInstance.mSecret = new byte[] {};
    }
    return mInstance;
}",1,"/**
 * Creates a new {@link KeyChainProtectionParams} instance.
 * The instance will include default values, if {@link #setSecret}
 * or {@link #setUserSecretType} were not called.
 *
 * @return new instance
 * @throws NullPointerException if some required fields were not set.
 */
","/**
 * Creates a new {@link KeyChainProtectionParams} instance.
 * The instance will include default values, if {@link #setSecret}
 * or {@link #setUserSecretType} were not called.
 *
 * @return new instance
 * @throws NullPointerException if some required fields were not set.
 */
",0,[@NonNull],[@NonNull],0,,,,1,5,0,4,0,"The method `Preconditions.checkNotNull()` has been replaced by `Objects.requireNonNull()`. This is considered as an ""Other statement changed"" since it is not related to return statements, exception handling statements, and control dependency.","The replacement of `Preconditions.checkNotNull()` with `Objects.requireNonNull()` does not affect the behavior of the API. Both methods have the same functionality, which is to check if the given object is not null. Therefore, there is no Compatibility Issue."
167,<android.app.ContextImpl: Context createContextForSplit(String)>,29,30,<android.app.ContextImpl: Context createContextForSplit(String)>,<android.app.ContextImpl: Context createContextForSplit(String)>,0,"{
    if (!mPackageInfo.getApplicationInfo().requestsIsolatedSplitLoading()) {
        // All Splits are always loaded.
        return this;
    }
    final ClassLoader classLoader = mPackageInfo.getSplitClassLoader(splitName);
    final String[] paths = mPackageInfo.getSplitPaths(splitName);
    final ContextImpl context = new ContextImpl(this, mMainThread, mPackageInfo, splitName, mActivityToken, mUser, mFlags, classLoader, null);
    final int displayId = getDisplayId();
    context.setResources(ResourcesManager.getInstance().getResources(mActivityToken, mPackageInfo.getResDir(), paths, mPackageInfo.getOverlayDirs(), mPackageInfo.getApplicationInfo().sharedLibraryFiles, displayId, null, mPackageInfo.getCompatibilityInfo(), classLoader));
    return context;
}","{
    if (!mPackageInfo.getApplicationInfo().requestsIsolatedSplitLoading()) {
        // All Splits are always loaded.
        return this;
    }
    final ClassLoader classLoader = mPackageInfo.getSplitClassLoader(splitName);
    final String[] paths = mPackageInfo.getSplitPaths(splitName);
    final ContextImpl context = new ContextImpl(this, mMainThread, mPackageInfo, mAttributionTag, splitName, mToken, mUser, mFlags, classLoader, null);
    final int displayId = getDisplayId();
    context.setResources(ResourcesManager.getInstance().getResources(mToken, mPackageInfo.getResDir(), paths, mPackageInfo.getOverlayDirs(), mPackageInfo.getApplicationInfo().sharedLibraryFiles, displayId, null, mPackageInfo.getCompatibilityInfo(), classLoader, mResources.getLoaders()));
    return context;
}",1,,,0,[@Override],[@Override],0,,,,"1,2",4,1,"4,5",1,"The constructor of ContextImpl has changed, with an additional parameter 'mAttributionTag' being added, and the method 'setResources' has an additional parameter 'mResources.getLoaders()'.",#CI_description
168,"<android.content.ContentResolver: boolean refresh(Uri,Bundle,CancellationSignal)>",29,30,"<android.content.ContentResolver: boolean refresh(Uri,Bundle,CancellationSignal)>","<android.content.ContentResolver: boolean refresh(Uri,Bundle,CancellationSignal)>",0,"{
    Preconditions.checkNotNull(url, ""url"");
    try {
        if (mWrapped != null)
            return mWrapped.refresh(url, args, cancellationSignal);
    } catch (RemoteException e) {
        return false;
    }
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        return false;
    }
    try {
        ICancellationSignal remoteCancellationSignal = null;
        if (cancellationSignal != null) {
            cancellationSignal.throwIfCanceled();
            remoteCancellationSignal = provider.createCancellationSignal();
            cancellationSignal.setRemote(remoteCancellationSignal);
        }
        return provider.refresh(mPackageName, url, args, remoteCancellationSignal);
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return false;
    } finally {
        releaseProvider(provider);
    }
}","{
    Objects.requireNonNull(url, ""url"");
    try {
        if (mWrapped != null)
            return mWrapped.refresh(url, extras, cancellationSignal);
    } catch (RemoteException e) {
        return false;
    }
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        return false;
    }
    try {
        ICancellationSignal remoteCancellationSignal = null;
        if (cancellationSignal != null) {
            cancellationSignal.throwIfCanceled();
            remoteCancellationSignal = provider.createCancellationSignal();
            cancellationSignal.setRemote(remoteCancellationSignal);
        }
        return provider.refresh(mPackageName, mAttributionTag, url, extras, remoteCancellationSignal);
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return false;
    } finally {
        releaseProvider(provider);
    }
}",1,"/**
 * This allows clients to request an explicit refresh of content identified by {@code uri}.
 * <p>
 * Client code should only invoke this method when there is a strong indication (such as a user
 * initiated pull to refresh gesture) that the content is stale.
 * <p>
 *
 * @param url The Uri identifying the data to refresh.
 * @param args Additional options from the client. The definitions of these are specific to the
 * content provider being called.
 * @param cancellationSignal A signal to cancel the operation in progress, or {@code null} if
 * none. For example, if you called refresh on a particular uri, you should call
 * {@link CancellationSignal#throwIfCanceled()} to check whether the client has
 * canceled the refresh request.
 * @return true if the provider actually tried refreshing.
 */
","/**
 * This allows clients to request an explicit refresh of content identified
 * by {@code uri}.
 * <p>
 * Client code should only invoke this method when there is a strong
 * indication (such as a user initiated pull to refresh gesture) that the
 * content is stale.
 * <p>
 *
 * @param url The Uri identifying the data to refresh.
 * @param extras Additional options from the client. The definitions of
 * these are specific to the content provider being called.
 * @param cancellationSignal A signal to cancel the operation in progress,
 * or {@code null} if none. For example, if you called refresh on
 * a particular uri, you should call
 * {@link CancellationSignal#throwIfCanceled()} to check whether
 * the client has canceled the refresh request.
 * @return true if the provider actually tried refreshing.
 */
",1,[@Override],[@Override],0,,,,"1,2","1,4,5",1,"5,1",1,"The method parameter name has changed from 'args' to 'extras', and the dependent API 'provider.refresh' has a new parameter 'mAttributionTag'. This is a Dependent API changed (5) and a Return statement changed (1).","The new parameter added to the dependent API 'provider.refresh' could cause different return values in the late version, thus, it is a Compatibility Issue caused by potential different return values or types (1)."
170,<android.database.sqlite.SQLiteQueryBuilder: boolean isStrict()>,29,30,<android.database.sqlite.SQLiteQueryBuilder: boolean isStrict()>,<android.database.sqlite.SQLiteQueryBuilder: boolean isStrict()>,0,"{
    return mStrict;
}","{
    return (mStrictFlags & STRICT_PARENTHESES) != 0;
}",1,"/**
 * Get if the query is marked as strict, as last configured by
 * {@link #setStrict(boolean)}.
 */
","/**
 * Get if the query is marked as strict, as last configured by
 * {@link #setStrict(boolean)}.
 */
",0,,,0,,,,1,1,1,1,1,"The return statement has been changed between the two versions. In the early version, the method returns a boolean value mStrict directly. However, in the late version, the method returns a boolean value by checking whether the STRICT\_PARENTHESES bit is set in the mStrictFlags variable.","The change in the return statement can cause a compatibility issue. Since the return value in the late version is calculated based on the value of the mStrictFlags variable, it could potentially return a different value from the early version, which could result in unexpected behavior in the application that uses the API. Therefore, the compatibility issue type is 1."
171,<android.view.View: View getRootView()>,31,32,<android.view.View: View getRootView()>,<android.view.View: View getRootView()>,0,"{
    if (mAttachInfo != null) {
        final View v = mAttachInfo.mRootView;
        if (v != null) {
            return v;
        }
    }
    View parent = this;
    while (parent.mParent != null && parent.mParent instanceof View) {
        parent = (View) parent.mParent;
    }
    return parent;
}","{
    if (mAttachInfo != null) {
        final View v = mAttachInfo.mRootView;
        if (v != null) {
            return v;
        }
    }
    View parent = this;
    while (parent.mParent instanceof View) {
        parent = (View) parent.mParent;
    }
    return parent;
}",1,"/**
 * <p>Finds the topmost view in the current view hierarchy.</p>
 *
 * @return the topmost view containing this view
 */
","/**
 * <p>Finds the topmost view in the current view hierarchy.</p>
 *
 * @return the topmost view containing this view
 */
",0,,,0,,,,1,3,1,3,1,"In the late version of the implementation, the condition of the while loop has been changed from `parent.mParent != null && parent.mParent instanceof View` to `parent.mParent instanceof View`. This is a control dependency change, hence the code change type is 3.","The change of the while loop condition can lead to different behavior of the API. Specifically, the value of `parent` might be different in the late version, which can cause the API to return a different value. Therefore, this change potentially causes a compatibility issue of type 1 (Compatibility Issue caused by potential different return values or types)."
172,<android.window.TaskSnapshot.Builder: TaskSnapshot build()>,31,32,<android.window.TaskSnapshot.Builder: TaskSnapshot build()>,<android.window.TaskSnapshot.Builder: TaskSnapshot build()>,0,"{
    return new TaskSnapshot(mId, mTopActivity, mSnapshot, mColorSpace, mOrientation, mRotation, mTaskSize, mContentInsets, // disk.
    false, /* isLowResolution */
    mIsRealSnapshot, mWindowingMode, mAppearance, mIsTranslucent, mHasImeSurface);
}","{
    return new TaskSnapshot(mId, mTopActivity, mSnapshot, mColorSpace, mOrientation, mRotation, mTaskSize, mContentInsets, mLetterboxInsets, // disk.
    false, /* isLowResolution */
    mIsRealSnapshot, mWindowingMode, mAppearance, mIsTranslucent, mHasImeSurface);
}",1,,,0,,,0,,,,2,"1,5",1,"1, 5",1,"The return statement has changed with the addition of a new parameter 'mLetterboxInsets' in the constructor call of TaskSnapshot. Additionally, the dependent API TaskSnapshot has also changed, as its constructor now takes an additional parameter.","As the return statement has changed with the addition of a new parameter, it can potentially lead to a different value being returned, causing a Compatibility Issue of type 1."
173,<android.companion.CompanionDeviceManager: List<String> getAssociations()>,32,33,<android.companion.CompanionDeviceManager: List<String> getAssociations()>,<android.companion.CompanionDeviceManager: List<String> getAssociations()>,0,"{
    if (!checkFeaturePresent()) {
        return Collections.emptyList();
    }
    try {
        return mService.getAssociations(getCallingPackage(), mContext.getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    return CollectionUtils.mapNotNull(getMyAssociations(), a -> a.isSelfManaged() ? null : a.getDeviceMacAddressAsString());
}",1,"/**
 * <p>Calling this API requires a uses-feature
 * {@link PackageManager#FEATURE_COMPANION_DEVICE_SETUP} declaration in the manifest</p>
 *
 * @return a list of MAC addresses of devices that have been previously associated with the
 * current app. You can use these with {@link #disassociate}
 */
","/**
 * <p>Calling this API requires a uses-feature
 * {@link PackageManager#FEATURE_COMPANION_DEVICE_SETUP} declaration in the manifest</p>
 *
 * @return a list of MAC addresses of devices that have been previously associated with the
 * current app are managed by CompanionDeviceManager (ie. does not include devices managed by
 * application itself even if they have a MAC address).
 *
 * @deprecated use {@link #getMyAssociations()}
 */
",0,[@NonNull],"[@Deprecated, @UserHandleAware, @NonNull]",1,,,,1,"1,2,3","1,2","1,5",1,"The implementation of the API has changed from returning the result of ""mService.getAssociations(getCallingPackage(), mContext.getUserId())"" to returning the result of ""CollectionUtils.mapNotNull(getMyAssociations(), a -> a.isSelfManaged() ? null : a.getDeviceMacAddressAsString())"". This is a change in return statement (type 1) and dependent API (type 5) as ""mService.getAssociations()"" and ""CollectionUtils.mapNotNull()"" are different methods.","The code change could cause the API to potentially return different values or types, as the two implementations may not necessarily return the same list of strings. Therefore, this is a Compatibility Issue caused by potential different return values or types (type 1)."
174,android.hardware.camera2.CameraCharacteristics.get,31,32,<android.hardware.camera2.CameraCharacteristics: T get(Key<T>)>,<android.hardware.camera2.CameraCharacteristics: T get(Key<T>)>,0,"{
    return mProperties.get(key);
}","{
    T propertyOverride = overrideProperty(key);
    return (propertyOverride != null) ? propertyOverride : mProperties.get(key);
}",1,"/**
 * Get a camera characteristics field value.
 *
 * <p>The field definitions can be
 * found in {@link CameraCharacteristics}.</p>
 *
 * <p>Querying the value for the same key more than once will return a value
 * which is equal to the previous queried value.</p>
 *
 * @throws IllegalArgumentException if the key was not valid
 *
 * @param key The characteristics field to read.
 * @return The value of that key, or {@code null} if the field is not set.
 */
","/**
 * Get a camera characteristics field value.
 *
 * <p>The field definitions can be
 * found in {@link CameraCharacteristics}.</p>
 *
 * <p>Querying the value for the same key more than once will return a value
 * which is equal to the previous queried value.</p>
 *
 * @throws IllegalArgumentException if the key was not valid
 *
 * @param key The characteristics field to read.
 * @return The value of that key, or {@code null} if the field is not set.
 */
",0,[@Nullable],[@Nullable],0,,,,1,"1,4",1,"1,5",1,The return statement has changed from returning the value of `mProperties.get(key)` directly to returning either the overridden property value or the original value from `mProperties.get(key)`. This is a change in return statement and also a dependent API change since it relies on the `overrideProperty(key)` method.,"As the return statement has changed, the API may potentially return different values in the two versions. If `overrideProperty(key)` returns a non-null value, the API will return that instead of the value from `mProperties.get(key)`. Therefore, it is a Compatibility Issue caused by potential different return values."
175,android.accessibilityservice.AccessibilityService.createDisplayContext,31,32,<android.accessibilityservice.AccessibilityService: Context createDisplayContext(Display)>,<android.accessibilityservice.AccessibilityService: Context createDisplayContext(Display)>,0,"{
    final Context context = super.createDisplayContext(display);
    final int displayId = display.getDisplayId();
    setDefaultTokenInternal(context, displayId);
    return context;
}","{
    return new AccessibilityContext(super.createDisplayContext(display), mConnectionId);
}",1,,,0,[@Override],"[@NonNull, @Override]",1,,,,1,"1,4",1,"1,4",1,"The return statement has changed from returning the result of `super.createDisplayContext(display)` to returning a new `AccessibilityContext` object created with that result and `mConnectionId`. Additionally, the method body has been simplified by removing the calls to `setDefaultTokenInternal` and `getDisplayId`.","The change in return statement can cause the API to return a different value, which can lead to a compatibility issue. Specifically, the API used to return a `Context` object created by the superclass' `createDisplayContext` method, but now it returns a new `AccessibilityContext` object created with that `Context` and an additional parameter `mConnectionId`. This change can potentially affect the behavior of any code that relies on the API's return value."
176,android.app.ActivityThread.ProviderKey.hashCode,31,32,<android.app.ActivityThread.ProviderKey: int hashCode()>,<android.app.ActivityThread.ProviderKey: int hashCode()>,0,"{
    return hashCode(authority, userId);
}","{
    return ((authority != null) ? authority.hashCode() : 0) ^ userId;
}",1,,,0,[@Override],[@Override],0,,,,1,"1,5",1,1,1,"The implementation of the hashCode() method has changed. In the early version, it calls a separate hashCode() method with two parameters (authority and userId). In the late version, it calculates the hashCode of the authority and userId itself using the ternary operator and bitwise XOR operator.","The change in the hashCode() method implementation can lead to different hashCode values for the same input, which is a Compatibility Issue caused by potential different return values."
177,android.view.MotionEvent.PointerCoords.clear,31,32,<android.view.MotionEvent.PointerCoords: void clear()>,<android.view.MotionEvent.PointerCoords: void clear()>,0,"{
    mPackedAxisBits = 0;
    x = 0;
    y = 0;
    pressure = 0;
    size = 0;
    touchMajor = 0;
    touchMinor = 0;
    toolMajor = 0;
    toolMinor = 0;
    orientation = 0;
}","{
    mPackedAxisBits = 0;
    x = 0;
    y = 0;
    pressure = 0;
    size = 0;
    touchMajor = 0;
    touchMinor = 0;
    toolMajor = 0;
    toolMinor = 0;
    orientation = 0;
    relativeX = 0;
    relativeY = 0;
}",1,"/**
 * Clears the contents of this object.
 * Resets all axes to zero.
 */
","/**
 * Clears the contents of this object.
 * Resets all axes to zero.
 */
",0,,,0,,,,1,4,0,4,0,The late version has 2 more variables (relativeX and relativeY) that are initialized in the implementation. This is an example of an other statement changed.,"The new variables added in the late version does not cause any change in return values or exception handling, so it does not lead to compatibility issues."
1,<android.widget.TextView: void setInputType(int)>,30,31,,,,"{
    final boolean wasPassword = isPasswordInputType(getInputType());
    final boolean wasVisiblePassword = isVisiblePasswordInputType(getInputType());
    setInputType(type, false);
    final boolean isPassword = isPasswordInputType(type);
    final boolean isVisiblePassword = isVisiblePasswordInputType(type);
    boolean forceUpdate = false;
    if (isPassword) {
        setTransformationMethod(PasswordTransformationMethod.getInstance());
        setTypefaceFromAttrs(null, /* fontTypeface */
        null, /* fontFamily */
        MONOSPACE, Typeface.NORMAL, -1);
    } else if (isVisiblePassword) {
        if (mTransformation == PasswordTransformationMethod.getInstance()) {
            forceUpdate = true;
        }
        setTypefaceFromAttrs(null, /* fontTypeface */
        null, /* fontFamily */
        MONOSPACE, Typeface.NORMAL, -1);
    } else if (wasPassword || wasVisiblePassword) {
        // not in password mode, clean up typeface and transformation
        setTypefaceFromAttrs(null, /* fontTypeface */
        null, /* fontFamily */
        DEFAULT_TYPEFACE, /* typeface index */
        Typeface.NORMAL, -1);
        if (mTransformation == PasswordTransformationMethod.getInstance()) {
            forceUpdate = true;
        }
    }
    boolean singleLine = !isMultilineInputType(type);
    // were previously in password mode.
    if (mSingleLine != singleLine || forceUpdate) {
        // Change single line mode, but only change the transformation if
        // we are not in password mode.
        applySingleLine(singleLine, !isPassword, true);
    }
    if (!isSuggestionsEnabled()) {
        setTextInternal(removeSuggestionSpans(mText));
    }
    InputMethodManager imm = getInputMethodManager();
    if (imm != null)
        imm.restartInput(this);
}","{
    final boolean wasPassword = isPasswordInputType(getInputType());
    final boolean wasVisiblePassword = isVisiblePasswordInputType(getInputType());
    setInputType(type, false);
    final boolean isPassword = isPasswordInputType(type);
    final boolean isVisiblePassword = isVisiblePasswordInputType(type);
    boolean forceUpdate = false;
    if (isPassword) {
        setTransformationMethod(PasswordTransformationMethod.getInstance());
        setTypefaceFromAttrs(null, /* fontTypeface */
        null, /* fontFamily */
        MONOSPACE, Typeface.NORMAL, -1);
    } else if (isVisiblePassword) {
        if (mTransformation == PasswordTransformationMethod.getInstance()) {
            forceUpdate = true;
        }
        setTypefaceFromAttrs(null, /* fontTypeface */
        null, /* fontFamily */
        MONOSPACE, Typeface.NORMAL, -1);
    } else if (wasPassword || wasVisiblePassword) {
        // not in password mode, clean up typeface and transformation
        setTypefaceFromAttrs(null, /* fontTypeface */
        null, /* fontFamily */
        DEFAULT_TYPEFACE, /* typeface index */
        Typeface.NORMAL, -1);
        if (mTransformation == PasswordTransformationMethod.getInstance()) {
            forceUpdate = true;
        }
    }
    boolean singleLine = !isMultilineInputType(type);
    // were previously in password mode.
    if (mSingleLine != singleLine || forceUpdate) {
        // Change single line mode, but only change the transformation if
        // we are not in password mode.
        applySingleLine(singleLine, !isPassword, true, true);
    }
    if (!isSuggestionsEnabled()) {
        setTextInternal(removeSuggestionSpans(mText));
    }
    InputMethodManager imm = getInputMethodManager();
    if (imm != null)
        imm.restartInput(this);
}",1,"/**
 * Set the type of the content with a constant as defined for {@link EditorInfo#inputType}. This
 * will take care of changing the key listener, by calling {@link #setKeyListener(KeyListener)},
 * to match the given content type.  If the given content type is {@link EditorInfo#TYPE_NULL}
 * then a soft keyboard will not be displayed for this text view.
 *
 * Note that the maximum number of displayed lines (see {@link #setMaxLines(int)}) will be
 * modified if you change the {@link EditorInfo#TYPE_TEXT_FLAG_MULTI_LINE} flag of the input
 * type.
 *
 * @see #getInputType()
 * @see #setRawInputType(int)
 * @see android.text.InputType
 * @attr ref android.R.styleable#TextView_inputType
 */
","/**
 * Set the type of the content with a constant as defined for {@link EditorInfo#inputType}. This
 * will take care of changing the key listener, by calling {@link #setKeyListener(KeyListener)},
 * to match the given content type.  If the given content type is {@link EditorInfo#TYPE_NULL}
 * then a soft keyboard will not be displayed for this text view.
 *
 * Note that the maximum number of displayed lines (see {@link #setMaxLines(int)}) will be
 * modified if you change the {@link EditorInfo#TYPE_TEXT_FLAG_MULTI_LINE} flag of the input
 * type.
 *
 * @see #getInputType()
 * @see #setRawInputType(int)
 * @see android.text.InputType
 * @attr ref android.R.styleable#TextView_inputType
 */
",0,,,0,,,,2,5,0,4,0,"The change is in the `applySingleLine()` method, where the late version has an additional boolean parameter. This change falls under the ""Other statement changed"" category.","As per the provided code changes, there is no potential Compatibility Issue (CI) that could arise. The change in the `applySingleLine()` method does not affect the return value or exception handling of the `setInputType()` method. Therefore, the CI type is 0."
2,<android.os.UserManager: boolean isUserUnlocked(UserHandle)>,30,31,,,,"{
    return isUserUnlocked(user.getIdentifier());
}","{
    return isUserUnlocked(user.getIdentifier());
}",0,"/**
 * Return whether the given user is running in an ""unlocked"" state.
 * <p>
 * On devices with direct boot, a user is unlocked only after they've
 * entered their credentials (such as a lock pattern or PIN). On devices
 * without direct boot, a user is unlocked as soon as it starts.
 * <p>
 * When a user is locked, only device-protected data storage is available.
 * When a user is unlocked, both device-protected and credential-protected
 * private app data storage is available.
 * <p>Requires {@code android.permission.MANAGE_USERS} or
 * {@code android.permission.INTERACT_ACROSS_USERS}, otherwise specified {@link UserHandle user}
 * must be the calling user or a managed profile associated with it.
 *
 * @param user to retrieve the unlocked state for.
 * @see Intent#ACTION_USER_UNLOCKED
 * @see Context#createDeviceProtectedStorageContext()
 */
","/**
 * Return whether the given user is running in an ""unlocked"" state.
 * <p>
 * On devices with direct boot, a user is unlocked only after they've
 * entered their credentials (such as a lock pattern or PIN). On devices
 * without direct boot, a user is unlocked as soon as it starts.
 * <p>
 * When a user is locked, only device-protected data storage is available.
 * When a user is unlocked, both device-protected and credential-protected
 * private app data storage is available.
 * <p>Requires {@code android.permission.MANAGE_USERS} or
 * {@code android.permission.INTERACT_ACROSS_USERS}, otherwise specified {@link UserHandle user}
 * must be the calling user or a profile associated with it.
 *
 * @param user to retrieve the unlocked state for.
 * @see Intent#ACTION_USER_UNLOCKED
 * @see Context#createDeviceProtectedStorageContext()
 */
",1,"[@RequiresPermission(anyOf = { Manifest.permission.MANAGE_USERS, Manifest.permission.INTERACT_ACROSS_USERS }, conditional = true)]","[@RequiresPermission(anyOf = { Manifest.permission.MANAGE_USERS, Manifest.permission.INTERACT_ACROSS_USERS }, conditional = true)]",0,,,,0,0,0,0,0,"The implementation and the annotation of the API `isUserUnlocked(UserHandle)` in the early version and the late version are exactly the same, so no change in the code.","Since there is no change in the code, there is no potential for different behavior, and thus no Compatibility Issue."
4,<android.view.textclassifier.TextClassificationSession: TextLanguage detectLanguage(Request)>,30,31,,,,"{
    checkDestroyed();
    return mDelegate.detectLanguage(request);
}","{
    return checkDestroyedAndRun(() -> mDelegate.detectLanguage(request));
}",1,,,0,[@Override],[@Override],0,,,,2,"1,5",1,5,1,"The implementation of the method has changed from calling `checkDestroyed()` followed by `mDelegate.detectLanguage(request)` to using a lambda expression with `checkDestroyedAndRun()` to call `mDelegate.detectLanguage(request)`. This change indicates that the method `checkDestroyedAndRun()` has been introduced to handle the check of destroyed state and execution of the lambda expression, which is a new dependent API.","The new implementation could cause a Compatibility Issue as it potentially leads to different return values. The change of the method implementation from calling `checkDestroyed()` to using `checkDestroyedAndRun()` could lead to different behavior, especially when the state of the object is destroyed. The previous implementation would throw an `IllegalStateException` if the object is destroyed, while the new implementation could return a different value (e.g., null or default value) or throw a different exception depending on the implementation of `checkDestroyedAndRun()`."
5,<android.inputmethodservice.InputMethodService: void requestShowSelf(int)>,30,31,,,,"{
    mPrivOps.showMySoftInput(flags);
}","{
    ImeTracing.getInstance().triggerServiceDump(""InputMethodService#requestShowSelf"", this, null);
    mPrivOps.showMySoftInput(flags);
}",1,"/**
 * Show the input method's soft input area, so the user sees the input method window and can
 * interact with it.
 *
 * @see InputMethodManager#SHOW_IMPLICIT
 * @see InputMethodManager#SHOW_FORCED
 * @param flags Provides additional operating flags.
 */
","/**
 * Show the input method's soft input area, so the user sees the input method window and can
 * interact with it.
 *
 * @see InputMethodManager#SHOW_IMPLICIT
 * @see InputMethodManager#SHOW_FORCED
 * @param flags Provides additional operating flags.
 */
",0,,,0,,,,"1,2",4,0,4,0,"A new statement has been added in the late version, which calls the `triggerServiceDump` method of `ImeTracing` class. This change belongs to the ""other statement changed"" category.","Although a new statement has been added, it does not affect the return value or the exception handling of the API. Therefore, there is no compatibility issue."
6,<android.app.LoadedApk.ReceiverDispatcher.Args: Runnable getRunnable()>,30,31,,,,"{
    return () -> {
        final BroadcastReceiver receiver = mReceiver;
        final boolean ordered = mOrdered;
        if (ActivityThread.DEBUG_BROADCAST) {
            int seq = mCurIntent.getIntExtra(""seq"", -1);
            Slog.i(ActivityThread.TAG, ""Dispatching broadcast "" + mCurIntent.getAction() + "" seq="" + seq + "" to "" + mReceiver);
            Slog.i(ActivityThread.TAG, ""  mRegistered="" + mRegistered + "" mOrderedHint="" + ordered);
        }
        final IActivityManager mgr = ActivityManager.getService();
        final Intent intent = mCurIntent;
        if (intent == null) {
            Log.wtf(TAG, ""Null intent being dispatched, mDispatched="" + mDispatched + (mRunCalled ? "", run() has already been called"" : """"));
        }
        mCurIntent = null;
        mDispatched = true;
        mRunCalled = true;
        if (receiver == null || intent == null || mForgotten) {
            if (mRegistered && ordered) {
                if (ActivityThread.DEBUG_BROADCAST)
                    Slog.i(ActivityThread.TAG, ""Finishing null broadcast to "" + mReceiver);
                sendFinished(mgr);
            }
            return;
        }
        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastReceiveReg"");
        try {
            ClassLoader cl = mReceiver.getClass().getClassLoader();
            intent.setExtrasClassLoader(cl);
            intent.prepareToEnterProcess();
            setExtrasClassLoader(cl);
            receiver.setPendingResult(this);
            receiver.onReceive(mContext, intent);
        } catch (Exception e) {
            if (mRegistered && ordered) {
                if (ActivityThread.DEBUG_BROADCAST)
                    Slog.i(ActivityThread.TAG, ""Finishing failed broadcast to "" + mReceiver);
                sendFinished(mgr);
            }
            if (mInstrumentation == null || !mInstrumentation.onException(mReceiver, e)) {
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
                throw new RuntimeException(""Error receiving broadcast "" + intent + "" in "" + mReceiver, e);
            }
        }
        if (receiver.getPendingResult() != null) {
            finish();
        }
        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
    };
}","{
    return () -> {
        final BroadcastReceiver receiver = mReceiver;
        final boolean ordered = mOrdered;
        if (ActivityThread.DEBUG_BROADCAST) {
            int seq = mCurIntent.getIntExtra(""seq"", -1);
            Slog.i(ActivityThread.TAG, ""Dispatching broadcast "" + mCurIntent.getAction() + "" seq="" + seq + "" to "" + mReceiver);
            Slog.i(ActivityThread.TAG, ""  mRegistered="" + mRegistered + "" mOrderedHint="" + ordered);
        }
        final IActivityManager mgr = ActivityManager.getService();
        final Intent intent = mCurIntent;
        if (intent == null) {
            Log.wtf(TAG, ""Null intent being dispatched, mDispatched="" + mDispatched + (mRunCalled ? "", run() has already been called"" : """"));
        }
        mCurIntent = null;
        mDispatched = true;
        mRunCalled = true;
        if (receiver == null || intent == null || mForgotten) {
            if (mRegistered && ordered) {
                if (ActivityThread.DEBUG_BROADCAST)
                    Slog.i(ActivityThread.TAG, ""Finishing null broadcast to "" + mReceiver);
                sendFinished(mgr);
            }
            return;
        }
        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastReceiveReg"");
        try {
            ClassLoader cl = mReceiver.getClass().getClassLoader();
            intent.setExtrasClassLoader(cl);
            // TODO: determine at registration time if caller is
            // protecting themselves with signature permission
            intent.prepareToEnterProcess(ActivityThread.isProtectedBroadcast(intent), mContext.getAttributionSource());
            setExtrasClassLoader(cl);
            receiver.setPendingResult(this);
            receiver.onReceive(mContext, intent);
        } catch (Exception e) {
            if (mRegistered && ordered) {
                if (ActivityThread.DEBUG_BROADCAST)
                    Slog.i(ActivityThread.TAG, ""Finishing failed broadcast to "" + mReceiver);
                sendFinished(mgr);
            }
            if (mInstrumentation == null || !mInstrumentation.onException(mReceiver, e)) {
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
                throw new RuntimeException(""Error receiving broadcast "" + intent + "" in "" + mReceiver, e);
            }
        }
        if (receiver.getPendingResult() != null) {
            finish();
        }
        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
    };
}",1,,,0,,,0,,,,2,5,0,5,1,"The API implementation relies on another API, and the dependent API has undergone changes. Specifically, the statement ""intent.prepareToEnterProcess()"" in the early version has been changed to ""intent.prepareToEnterProcess(ActivityThread.isProtectedBroadcast(intent), mContext.getAttributionSource())"" in the late version.","The dependent API ""intent.prepareToEnterProcess()"" has been modified to include additional parameters, which could potentially lead to different behaviors in the late version. Therefore, it is a Compatibility Issue caused by potential different return values or types."
7,<android.app.admin.DevicePolicyManager: DevicePolicyManager getParentProfileInstance(ComponentName)>,30,31,,,,"{
    throwIfParentInstance(""getParentProfileInstance"");
    try {
        if (!mService.isManagedProfile(admin)) {
            throw new SecurityException(""The current user does not have a parent profile."");
        }
        return new DevicePolicyManager(mContext, mService, true);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    throwIfParentInstance(""getParentProfileInstance"");
    try {
        if (!mService.isManagedProfile(admin)) {
            throw new SecurityException(""The current user does not have a parent profile."");
        }
        return new DevicePolicyManager(mContext, mService, true);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",0,"/**
 * Called by the profile owner of a managed profile to obtain a {@link DevicePolicyManager}
 * whose calls act on the parent profile.
 *
 * <p>The following methods are supported for the parent instance, all other methods will
 * throw a SecurityException when called on the parent instance:
 * <ul>
 * <li>{@link #getPasswordQuality}</li>
 * <li>{@link #setPasswordQuality}</li>
 * <li>{@link #getPasswordMinimumLength}</li>
 * <li>{@link #setPasswordMinimumLength}</li>
 * <li>{@link #getPasswordMinimumUpperCase}</li>
 * <li>{@link #setPasswordMinimumUpperCase}</li>
 * <li>{@link #getPasswordMinimumLowerCase}</li>
 * <li>{@link #setPasswordMinimumLowerCase}</li>
 * <li>{@link #getPasswordMinimumLetters}</li>
 * <li>{@link #setPasswordMinimumLetters}</li>
 * <li>{@link #getPasswordMinimumNumeric}</li>
 * <li>{@link #setPasswordMinimumNumeric}</li>
 * <li>{@link #getPasswordMinimumSymbols}</li>
 * <li>{@link #setPasswordMinimumSymbols}</li>
 * <li>{@link #getPasswordMinimumNonLetter}</li>
 * <li>{@link #setPasswordMinimumNonLetter}</li>
 * <li>{@link #getPasswordHistoryLength}</li>
 * <li>{@link #setPasswordHistoryLength}</li>
 * <li>{@link #getPasswordExpirationTimeout}</li>
 * <li>{@link #setPasswordExpirationTimeout}</li>
 * <li>{@link #getPasswordExpiration}</li>
 * <li>{@link #getPasswordMaximumLength}</li>
 * <li>{@link #isActivePasswordSufficient}</li>
 * <li>{@link #getCurrentFailedPasswordAttempts}</li>
 * <li>{@link #getMaximumFailedPasswordsForWipe}</li>
 * <li>{@link #setMaximumFailedPasswordsForWipe}</li>
 * <li>{@link #getMaximumTimeToLock}</li>
 * <li>{@link #setMaximumTimeToLock}</li>
 * <li>{@link #lockNow}</li>
 * <li>{@link #getKeyguardDisabledFeatures}</li>
 * <li>{@link #setKeyguardDisabledFeatures}</li>
 * <li>{@link #getTrustAgentConfiguration}</li>
 * <li>{@link #setTrustAgentConfiguration}</li>
 * <li>{@link #getRequiredStrongAuthTimeout}</li>
 * <li>{@link #setRequiredStrongAuthTimeout}</li>
 * <li>{@link #getAccountTypesWithManagementDisabled}</li>
 * </ul>
 * <p>
 * The following methods are supported for the parent instance but can only be called by the
 * profile owner of a managed profile that was created during the device provisioning flow:
 * <ul>
 * <li>{@link #getPasswordComplexity}</li>
 * <li>{@link #setCameraDisabled}</li>
 * <li>{@link #getCameraDisabled}</li>
 * <li>{@link #setAccountManagementDisabled(ComponentName, String, boolean)}</li>
 * </ul>
 *
 * <p>The following methods can be called by the profile owner of a managed profile
 * on an organization-owned device:
 * <ul>
 * <li>{@link #wipeData}</li>
 * </ul>
 *
 * @return a new instance of {@link DevicePolicyManager} that acts on the parent profile.
 * @throws SecurityException if {@code admin} is not a profile owner.
 */
","/**
 * Called by the profile owner of a managed profile to obtain a {@link DevicePolicyManager}
 * whose calls act on the parent profile.
 *
 * <p>The following methods are supported for the parent instance, all other methods will
 * throw a SecurityException when called on the parent instance:
 * <ul>
 * <li>{@link #getPasswordQuality}</li>
 * <li>{@link #setPasswordQuality}</li>
 * <li>{@link #getPasswordMinimumLength}</li>
 * <li>{@link #setPasswordMinimumLength}</li>
 * <li>{@link #getPasswordMinimumUpperCase}</li>
 * <li>{@link #setPasswordMinimumUpperCase}</li>
 * <li>{@link #getPasswordMinimumLowerCase}</li>
 * <li>{@link #setPasswordMinimumLowerCase}</li>
 * <li>{@link #getPasswordMinimumLetters}</li>
 * <li>{@link #setPasswordMinimumLetters}</li>
 * <li>{@link #getPasswordMinimumNumeric}</li>
 * <li>{@link #setPasswordMinimumNumeric}</li>
 * <li>{@link #getPasswordMinimumSymbols}</li>
 * <li>{@link #setPasswordMinimumSymbols}</li>
 * <li>{@link #getPasswordMinimumNonLetter}</li>
 * <li>{@link #setPasswordMinimumNonLetter}</li>
 * <li>{@link #getPasswordHistoryLength}</li>
 * <li>{@link #setPasswordHistoryLength}</li>
 * <li>{@link #getPasswordExpirationTimeout}</li>
 * <li>{@link #setPasswordExpirationTimeout}</li>
 * <li>{@link #getPasswordExpiration}</li>
 * <li>{@link #getPasswordMaximumLength}</li>
 * <li>{@link #isActivePasswordSufficient}</li>
 * <li>{@link #getCurrentFailedPasswordAttempts}</li>
 * <li>{@link #getMaximumFailedPasswordsForWipe}</li>
 * <li>{@link #setMaximumFailedPasswordsForWipe}</li>
 * <li>{@link #getMaximumTimeToLock}</li>
 * <li>{@link #setMaximumTimeToLock}</li>
 * <li>{@link #lockNow}</li>
 * <li>{@link #getKeyguardDisabledFeatures}</li>
 * <li>{@link #setKeyguardDisabledFeatures}</li>
 * <li>{@link #getTrustAgentConfiguration}</li>
 * <li>{@link #setTrustAgentConfiguration}</li>
 * <li>{@link #getRequiredStrongAuthTimeout}</li>
 * <li>{@link #setRequiredStrongAuthTimeout}</li>
 * <li>{@link #getAccountTypesWithManagementDisabled}</li>
 * <li>{@link #setRequiredPasswordComplexity(int)} </li>
 * <li>{@link #getRequiredPasswordComplexity()}</li>
 * </ul>
 * <p>
 * The following methods are supported for the parent instance but can only be called by the
 * profile owner of a managed profile that was created during the device provisioning flow:
 * <ul>
 * <li>{@link #getPasswordComplexity}</li>
 * <li>{@link #setCameraDisabled}</li>
 * <li>{@link #getCameraDisabled}</li>
 * <li>{@link #setAccountManagementDisabled(ComponentName, String, boolean)}</li>
 * <li>{@link #setPermittedInputMethods}</li>
 * <li>{@link #getPermittedInputMethods}</li>
 * </ul>
 *
 * <p>The following methods can be called by the profile owner of a managed profile
 * on an organization-owned device:
 * <ul>
 * <li>{@link #wipeData}</li>
 * </ul>
 *
 * @return a new instance of {@link DevicePolicyManager} that acts on the parent profile.
 * @throws SecurityException if {@code admin} is not a profile owner.
 */
",1,[@NonNull],[@NonNull],0,,,,0,0,0,0,0,The code implementation and annotation of the given API between the two versions are the same.,"There is no code change between the two versions, so there is no Compatibility Issue arises."
9,"<android.text.method.NumberKeyListener: boolean addAmPmChars(Collection<Character>,Locale)>",30,31,,,,"{
    if (locale == null) {
        return false;
    }
    final String[] amPm = LocaleData.get(locale).amPm;
    for (int i = 0; i < amPm.length; i++) {
        for (int j = 0; j < amPm[i].length(); j++) {
            final char ch = amPm[i].charAt(j);
            if (Character.isBmpCodePoint(ch)) {
                collection.add(Character.valueOf(ch));
            } else {
                // We don't support non-BMP characters.
                return false;
            }
        }
    }
    return true;
}","{
    if (locale == null) {
        return false;
    }
    final String[] amPm = DateFormat.getIcuDateFormatSymbols(locale).getAmPmStrings();
    for (int i = 0; i < amPm.length; i++) {
        for (int j = 0; j < amPm[i].length(); j++) {
            final char ch = amPm[i].charAt(j);
            if (Character.isBmpCodePoint(ch)) {
                collection.add(Character.valueOf(ch));
            } else {
                // We don't support non-BMP characters.
                return false;
            }
        }
    }
    return true;
}",1,"/* package */
","/* package */
",0,,,0,,,,2,"4,5",0,5,1,"The change is in the method used to obtain the ""amPm"" array. In the early version, ""LocaleData.get(locale).amPm"" is used while in the late version, ""DateFormat.getIcuDateFormatSymbols(locale).getAmPmStrings()"" is used. This is a change in dependent API, so the code change type is 5.","The change in the dependent API used to obtain the ""amPm"" array could lead to different values being returned by the ""addAmPmChars"" method. Therefore, this is a compatibility issue caused by potential different return values, so the CI type is 1."
10,<android.app.UiAutomation: void clearWindowAnimationFrameStats()>,30,31,,,,"{
    synchronized (mLock) {
        throwIfNotConnectedLocked();
    }
    try {
        if (DEBUG) {
            Log.i(LOG_TAG, ""Clearing window animation frame stats"");
        }
        // Calling out without a lock held.
        mUiAutomationConnection.clearWindowAnimationFrameStats();
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error clearing window animation frame stats!"", re);
    }
}","{
    try {
        if (DEBUG) {
            Log.i(LOG_TAG, ""Clearing window animation frame stats"");
        }
        // Calling out without a lock held.
        mUiAutomationConnection.clearWindowAnimationFrameStats();
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error clearing window animation frame stats!"", re);
    }
}",1,"/**
 * Clears the window animation rendering statistics. These statistics contain
 * information about the most recently rendered window animation frames, i.e.
 * for window transition animations.
 *
 * @see android.view.WindowAnimationFrameStats
 * @see #getWindowAnimationFrameStats()
 * @see android.R.styleable#WindowAnimation
 */
","/**
 * Clears the window animation rendering statistics. These statistics contain
 * information about the most recently rendered window animation frames, i.e.
 * for window transition animations.
 *
 * @see android.view.WindowAnimationFrameStats
 * @see #getWindowAnimationFrameStats()
 * @see android.R.styleable#WindowAnimation
 */
",0,,,0,,,,"1,2",4,2,4,0,"The code change is that the 'synchronized (mLock)' statement and the 'throwIfNotConnectedLocked()' method call have been removed. These statements are not return statements, exception handling statements, or control dependency statements, so the change type is 4 (Other statement changed).","The removed statements are not related to the return value or exception handling of the API. So the change does not potentially lead to different behaviours. Therefore, there is no Compatibility Issue caused by this change."
11,"<android.view.ViewGroup: boolean requestFocus(int,Rect)>",30,31,,,,"{
    if (DBG) {
        System.out.println(this + "" ViewGroup.requestFocus direction="" + direction);
    }
    int descendantFocusability = getDescendantFocusability();
    boolean result;
    switch(descendantFocusability) {
        case FOCUS_BLOCK_DESCENDANTS:
            result = super.requestFocus(direction, previouslyFocusedRect);
            break;
        case FOCUS_BEFORE_DESCENDANTS:
            {
                final boolean took = super.requestFocus(direction, previouslyFocusedRect);
                result = took ? took : onRequestFocusInDescendants(direction, previouslyFocusedRect);
                break;
            }
        case FOCUS_AFTER_DESCENDANTS:
            {
                final boolean took = onRequestFocusInDescendants(direction, previouslyFocusedRect);
                result = took ? took : super.requestFocus(direction, previouslyFocusedRect);
                break;
            }
        default:
            throw new IllegalStateException(""descendant focusability must be one of FOCUS_BEFORE_DESCENDANTS,"" + "" FOCUS_AFTER_DESCENDANTS, FOCUS_BLOCK_DESCENDANTS but is "" + descendantFocusability);
    }
    if (result && !isLayoutValid() && ((mPrivateFlags & PFLAG_WANTS_FOCUS) == 0)) {
        mPrivateFlags |= PFLAG_WANTS_FOCUS;
    }
    return result;
}","{
    if (DBG) {
        System.out.println(this + "" ViewGroup.requestFocus direction="" + direction);
    }
    int descendantFocusability = getDescendantFocusability();
    boolean result;
    switch(descendantFocusability) {
        case FOCUS_BLOCK_DESCENDANTS:
            result = super.requestFocus(direction, previouslyFocusedRect);
            break;
        case FOCUS_BEFORE_DESCENDANTS:
            {
                final boolean took = super.requestFocus(direction, previouslyFocusedRect);
                result = took ? took : onRequestFocusInDescendants(direction, previouslyFocusedRect);
                break;
            }
        case FOCUS_AFTER_DESCENDANTS:
            {
                final boolean took = onRequestFocusInDescendants(direction, previouslyFocusedRect);
                result = took ? took : super.requestFocus(direction, previouslyFocusedRect);
                break;
            }
        default:
            throw new IllegalStateException(""descendant focusability must be "" + ""one of FOCUS_BEFORE_DESCENDANTS, FOCUS_AFTER_DESCENDANTS, FOCUS_BLOCK_DESCENDANTS "" + ""but is "" + descendantFocusability);
    }
    if (result && !isLayoutValid() && ((mPrivateFlags & PFLAG_WANTS_FOCUS) == 0)) {
        mPrivateFlags |= PFLAG_WANTS_FOCUS;
    }
    return result;
}",1,"/**
 * {@inheritDoc}
 *
 * Looks for a view to give focus to respecting the setting specified by
 * {@link #getDescendantFocusability()}.
 *
 * Uses {@link #onRequestFocusInDescendants(int, android.graphics.Rect)} to
 * find focus within the children of this group when appropriate.
 *
 * @see #FOCUS_BEFORE_DESCENDANTS
 * @see #FOCUS_AFTER_DESCENDANTS
 * @see #FOCUS_BLOCK_DESCENDANTS
 * @see #onRequestFocusInDescendants(int, android.graphics.Rect)
 */
","/**
 * {@inheritDoc}
 *
 * Looks for a view to give focus to respecting the setting specified by
 * {@link #getDescendantFocusability()}.
 *
 * Uses {@link #onRequestFocusInDescendants(int, android.graphics.Rect)} to
 * find focus within the children of this group when appropriate.
 *
 * @see #FOCUS_BEFORE_DESCENDANTS
 * @see #FOCUS_AFTER_DESCENDANTS
 * @see #FOCUS_BLOCK_DESCENDANTS
 * @see #onRequestFocusInDescendants(int, android.graphics.Rect)
 */
",0,[@Override],[@Override],0,,,,1,2,2,3,1,"The implementation of the switch statement has not changed, only the default case of the switch statement has changed the error message of the exception thrown.","The new error message of the exception thrown in the default case of the switch statement does not affect the behavior of the method, so there is no compatibility issue."
12,<android.os.Parcel: void setDataSize(int)>,30,31,,,,"{
    updateNativeSize(nativeSetDataSize(mNativePtr, size));
}","{
    nativeSetDataSize(mNativePtr, size);
}",1,"/**
 * Change the amount of data in the parcel.  Can be either smaller or
 * larger than the current size.  If larger than the current capacity,
 * more memory will be allocated.
 *
 * @param size The new number of bytes in the Parcel.
 */
","/**
 * Change the amount of data in the parcel.  Can be either smaller or
 * larger than the current size.  If larger than the current capacity,
 * more memory will be allocated.
 *
 * @param size The new number of bytes in the Parcel.
 */
",0,,,0,,,,2,5,0,4,0,"The updateNativeSize() method call has been removed in the late version, which is considered an 'other statement changed' type of change.","The removal of the updateNativeSize() method call does not seem to affect the return value or the exception handling of the setDataSize() method, so it is not expected to cause a compatibility issue."
13,"<android.view.inputmethod.InlineSuggestionsRequest: void writeToParcel(Parcel,int)>",30,31,,,,"{
    // You can override field parcelling by defining methods like:
    // void parcelFieldName(Parcel dest, int flags) { ... }
    byte flg = 0;
    if (mHostInputToken != null)
        flg |= 0x20;
    dest.writeByte(flg);
    dest.writeInt(mMaxSuggestionCount);
    dest.writeParcelableList(mInlinePresentationSpecs, flags);
    dest.writeString(mHostPackageName);
    dest.writeTypedObject(mSupportedLocales, flags);
    dest.writeBundle(mExtras);
    parcelHostInputToken(dest, flags);
    dest.writeInt(mHostDisplayId);
}","{
    // You can override field parcelling by defining methods like:
    // void parcelFieldName(Parcel dest, int flags) { ... }
    int flg = 0;
    if (mHostInputToken != null)
        flg |= 0x20;
    if (mInlineTooltipPresentationSpec != null)
        flg |= 0x80;
    dest.writeInt(flg);
    dest.writeInt(mMaxSuggestionCount);
    dest.writeParcelableList(mInlinePresentationSpecs, flags);
    dest.writeString(mHostPackageName);
    dest.writeTypedObject(mSupportedLocales, flags);
    dest.writeBundle(mExtras);
    parcelHostInputToken(dest, flags);
    dest.writeInt(mHostDisplayId);
    if (mInlineTooltipPresentationSpec != null)
        dest.writeTypedObject(mInlineTooltipPresentationSpec, flags);
}",1,,,0,"[@Override, @DataClass.Generated.Member]","[@Override, @DataClass.Generated.Member]",0,,,,"1,2","3,4,5",0,"3,5","1,2","The code change added a new condition check (if (mInlineTooltipPresentationSpec != null)), and a new write statement (dest.writeTypedObject(mInlineTooltipPresentationSpec, flags)). Also, the writeByte() statement has been replaced by writeInt() statement. This indicates that the control dependency and the dependent API have changed. So the code change type is 3,5.","The change in control dependency and the dependent API can affect the return value of the method, as well as the exception thrown. Specifically, if mInlineTooltipPresentationSpec is not null, the writeInt() method will write a different flag value to the parcel, and the new write statement will write a different object to the parcel. This can lead to compatibility issues, as the API may return a different value or throw a different exception. So the CI type is 1,2."
14,<android.service.voice.VoiceInteractionSession: void onHandleAssist(AssistState)>,31,32,,,,"{
    if (state.getAssistData() == null && state.getAssistStructure() == null && state.getAssistContent() == null) {
        return;
    } else if (state.getIndex() == 0) {
        onHandleAssist(state.getAssistData(), state.getAssistStructure(), state.getAssistContent());
    } else {
        onHandleAssistSecondary(state.getAssistData(), state.getAssistStructure(), state.getAssistContent(), state.getIndex(), state.getCount());
    }
}","{
    if (state.getAssistData() == null && state.getAssistStructure() == null && state.getAssistContent() == null) {
        return;
    } else if (state.getIndex() == 0) {
        onHandleAssist(state.getAssistData(), state.getAssistStructure(), state.getAssistContent());
    } else {
        onHandleAssistSecondary(state.getAssistData(), state.getAssistStructure(), state.getAssistContent(), state.getIndex(), state.getCount());
    }
}",0,"/**
 * Called to receive data from the application that the user was currently viewing when
 * an assist session is started. If the original show request did not specify
 * {@link #SHOW_WITH_ASSIST}, {@link AssistState} parameter will only provide
 * {@link ActivityId}.
 *
 * <p>This method is called for all activities along with an index and count that indicates
 * which activity the data is for. {@code index} will be between 0 and {@code count}-1 and
 * this method is called once for each activity in no particular order. The {@code count}
 * indicates how many activities to expect assist data for, including the top focused one.
 * The focused activity can be determined by calling {@link AssistState#isFocused()}.
 *
 * <p>To be responsive to assist requests, process assist data as soon as it is received,
 * without waiting for all queued activities to return assist data.
 *
 * @param state The state object capturing the state of an activity.
 */
","/**
 * Called to receive data from the application that the user was currently viewing when
 * an assist session is started. If the original show request did not specify
 * {@link #SHOW_WITH_ASSIST}, {@link AssistState} parameter will only provide
 * {@link ActivityId}. If there was a failure to write the assist data to
 * {@link AssistStructure}, the {@link AssistState#getAssistStructure()} will return null.
 *
 * <p>This method is called for all activities along with an index and count that indicates
 * which activity the data is for. {@code index} will be between 0 and {@code count}-1 and
 * this method is called once for each activity in no particular order. The {@code count}
 * indicates how many activities to expect assist data for, including the top focused one.
 * The focused activity can be determined by calling {@link AssistState#isFocused()}.
 *
 * <p>To be responsive to assist requests, process assist data as soon as it is received,
 * without waiting for all queued activities to return assist data.
 *
 * @param state The state object capturing the state of an activity.
 */
",1,,,0,,,,0,0,0,0,0,There is no difference between the two versions of the code.,"As the code is exactly the same, there is no potential for compatibility issues."
15,<android.view.contentcapture.ContentCaptureManager: ComponentName getServiceComponentName()>,31,32,,,,"{
    if (!isContentCaptureEnabled() && !mOptions.lite)
        return null;
    final SyncResultReceiver resultReceiver = new SyncResultReceiver(SYNC_CALLS_TIMEOUT_MS);
    try {
        mService.getServiceComponentName(resultReceiver);
        return resultReceiver.getParcelableResult();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    } catch (SyncResultReceiver.TimeoutException e) {
        throw new RuntimeException(""Fail to get service componentName."");
    }
}","{
    if (!isContentCaptureEnabled() && !mOptions.lite)
        return null;
    final SyncResultReceiver resultReceiver = new SyncResultReceiver(SYNC_CALLS_TIMEOUT_MS);
    try {
        mService.getServiceComponentName(resultReceiver);
        return resultReceiver.getParcelableResult();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    } catch (SyncResultReceiver.TimeoutException e) {
        throw new RuntimeException(""Fail to get service componentName."");
    }
}",0,"/**
 * Returns the component name of the system service that is consuming the captured events for
 * the current user.
 */
","/**
 * Returns the component name of the system service that is consuming the captured events for
 * the current user.
 *
 * @throws RuntimeException if getting the component name is timed out.
 */
",1,[@Nullable],[@Nullable],0,,,,0,0,0,0,0,"As the implementation of the API has not been changed, there is no code change and the code change type is 0.",There is no potential Compatibility Issue in this case as there is no code change.
16,<android.view.translation.TranslationResponseValue: CharSequence getTransliteration()>,31,32,,,,"{
    return mTransliteration;
}","{
    return mTransliteration;
}",0,"/**
 * The transliteration result of the translated text.
 * TODO: Describe the result structure.
 */
","/**
 * The transliteration result of the translated text.
 *
 * <p>This returns a CharSequence representation of the transliteration of the translated text.
 */
",1,"[@DataClass.Generated.Member, @Nullable]","[@DataClass.Generated.Member, @Nullable]",0,,,,0,0,0,0,0,The implementation code and annotations for the `getTransliteration` method in the `android.view.translation.TranslationResponseValue` class have not changed between version 31 and 32.,"As there are no changes in the implementation code and annotations, there is no potential for compatibility issues to arise in the `getTransliteration` method between version 31 and 32."
17,<android.view.contentcapture.ContentCaptureContext: void dump(PrintWriter)>,31,32,,,,"{
    if (mComponentName != null) {
        pw.print(""activity="");
        pw.print(mComponentName.flattenToShortString());
    }
    if (mId != null) {
        pw.print("", id="");
        mId.dump(pw);
    }
    pw.print("", activityId="");
    pw.print(mActivityId);
    pw.print("", displayId="");
    pw.print(mDisplayId);
    if (mParentSessionId != NO_SESSION_ID) {
        pw.print("", parentId="");
        pw.print(mParentSessionId);
    }
    if (mFlags > 0) {
        pw.print("", flags="");
        pw.print(mFlags);
    }
    if (mExtras != null) {
        // NOTE: cannot dump because it could contain PII
        pw.print("", hasExtras"");
    }
}","{
    if (mComponentName != null) {
        pw.print(""activity="");
        pw.print(mComponentName.flattenToShortString());
    }
    if (mId != null) {
        pw.print("", id="");
        mId.dump(pw);
    }
    pw.print("", activityId="");
    pw.print(mActivityId);
    pw.print("", displayId="");
    pw.print(mDisplayId);
    pw.print("", windowToken="");
    pw.print(mWindowToken);
    if (mParentSessionId != NO_SESSION_ID) {
        pw.print("", parentId="");
        pw.print(mParentSessionId);
    }
    if (mFlags > 0) {
        pw.print("", flags="");
        pw.print(mFlags);
    }
    if (mExtras != null) {
        // NOTE: cannot dump because it could contain PII
        pw.print("", hasExtras"");
    }
}",1,"// TODO(b/111276913): dump to proto as well
","// TODO(b/111276913): dump to proto as well
",0,,,0,,,,"1,2","4,5",0,4,0,"A new statement `pw.print("", windowToken=""); pw.print(mWindowToken);` has been added in the late version. This change belongs to ""Other statement changed"" category, so the code change type is 4.","The new statement only prints additional information, it will not cause the API to return a different value or throw an exception differently, thus there is no Compatibility Issue for the API."
18,<android.appwidget.AppWidgetHostView.ViewApplyListener: void onViewApplied(View)>,31,32,,,,"{
    AppWidgetHostView.this.mLayoutId = mLayoutId;
    mViewMode = VIEW_MODE_CONTENT;
    applyContent(v, mIsReapply, null);
    mLastInflatedRemoteViewsId = mViews.computeUniqueId(mLastInflatedRemoteViews);
    restoreInstanceState();
    mLastExecutionSignal = null;
}","{
    mViewMode = VIEW_MODE_CONTENT;
    applyContent(v, mIsReapply, null);
    mLastInflatedRemoteViewsId = mViews.computeUniqueId(mLastInflatedRemoteViews);
    restoreInstanceState();
    mLastExecutionSignal = null;
}",1,,,0,[@Override],[@Override],0,,,,"1,2",4,0,4,0,"The first statement ""AppWidgetHostView.this.mLayoutId = mLayoutId;"" has been deleted in the late version, which is not a return statement, exception handling statement, control dependency statement or dependent API statement. Therefore, the code change type is 4 (other statement changed).","Although a statement is deleted in the late version, it does not lead to different behaviours of the API. Therefore, there is no compatibility issue (CI) in this case."
19,"<android.app.admin.DevicePolicyManager: void setPasswordMinimumLowerCase(ComponentName,int)>",31,32,,,,"{
    if (mService != null) {
        try {
            mService.setPasswordMinimumLowerCase(admin, length, mParentInstance);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}","{
    if (mService != null) {
        try {
            mService.setPasswordMinimumLowerCase(admin, length, mParentInstance);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",0,"/**
 * Called by an application that is administering the device to set the minimum number of lower
 * case letters required in the password. After setting this, the user will not be able to enter
 * a new password that is not at least as restrictive as what has been set. Note that the
 * current password will remain until the user has set a new one, so the change does not take
 * place immediately. To prompt the user for a new password, use
 * {@link #ACTION_SET_NEW_PASSWORD} or {@link #ACTION_SET_NEW_PARENT_PROFILE_PASSWORD} after
 * setting this value. This constraint is only imposed if the administrator has also requested
 * {@link #PASSWORD_QUALITY_COMPLEX} with {@link #setPasswordQuality}. If an app targeting
 * SDK level {@link android.os.Build.VERSION_CODES#R} and above enforces this constraint without
 * settings password quality to {@link #PASSWORD_QUALITY_COMPLEX} first, this method will throw
 * {@link IllegalStateException}. The default value is 0.
 * <p>
 * On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the
 * password is always treated as empty.
 * <p>
 * The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call this method; if it has
 * not, a security exception will be thrown.
 * <p>
 *
 * Apps targeting {@link android.os.Build.VERSION_CODES#R} and below can call this method on the
 * {@link DevicePolicyManager} instance returned by
 * {@link #getParentProfileInstance(ComponentName)} in order to set restrictions on the parent
 * profile.
 *
 * @deprecated see {@link #setPasswordQuality(ComponentName, int)} for details.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param length The new desired minimum number of lower case letters required in the password.
 * A value of 0 means there is no restriction.
 * @throws SecurityException if {@code admin} is not an active administrator or {@code admin}
 * does not use {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD}
 * @throws IllegalStateException if the calling app is targeting SDK level
 * {@link android.os.Build.VERSION_CODES#R} and above and didn't set a sufficient password
 * quality requirement prior to calling this method.
 */
","/**
 * Called by an application that is administering the device to set the minimum number of lower
 * case letters required in the password. After setting this, the user will not be able to enter
 * a new password that is not at least as restrictive as what has been set. Note that the
 * current password will remain until the user has set a new one, so the change does not take
 * place immediately. To prompt the user for a new password, use
 * {@link #ACTION_SET_NEW_PASSWORD} or {@link #ACTION_SET_NEW_PARENT_PROFILE_PASSWORD} after
 * setting this value. This constraint is only imposed if the administrator has also requested
 * {@link #PASSWORD_QUALITY_COMPLEX} with {@link #setPasswordQuality}. If an app targeting
 * SDK level {@link android.os.Build.VERSION_CODES#R} and above enforces this constraint without
 * settings password quality to {@link #PASSWORD_QUALITY_COMPLEX} first, this method will throw
 * {@link IllegalStateException}. The default value is 0.
 * <p>
 * On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the
 * password is always treated as empty.
 * <p>
 * The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call this method; if it has
 * not, a security exception will be thrown.
 * <p>
 * Apps targeting {@link android.os.Build.VERSION_CODES#R} and below can call this method on the
 * {@link DevicePolicyManager} instance returned by
 * {@link #getParentProfileInstance(ComponentName)} in order to set restrictions on the parent
 * profile.
 *
 * <p><string>Note:</strong> this method is ignored on
 * {PackageManager#FEATURE_AUTOMOTIVE automotive builds}.
 *
 * @deprecated see {@link #setPasswordQuality(ComponentName, int)} for details.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param length The new desired minimum number of lower case letters required in the password.
 * A value of 0 means there is no restriction.
 * @throws SecurityException if {@code admin} is not an active administrator or {@code admin}
 * does not use {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD}
 * @throws IllegalStateException if the calling app is targeting SDK level
 * {@link android.os.Build.VERSION_CODES#R} and above and didn't set a sufficient password
 * quality requirement prior to calling this method.
 */
",1,[@Deprecated],[@Deprecated],0,,,,0,0,0,0,0,"There is no change between the early and late versions of the implementation and annotation, so the code change type is 0.","As the implementation and annotation are the same in both versions, there is no Compatibility Issue."
20,<android.inputmethodservice.IInputMethodWrapper: void executeMessage(Message)>,31,32,,,,"{
    InputMethod inputMethod = mInputMethod.get();
    // Need a valid reference to the inputMethod for everything except a dump.
    if (inputMethod == null && msg.what != DO_DUMP) {
        Log.w(TAG, ""Input method reference was null, ignoring message: "" + msg.what);
        return;
    }
    switch(msg.what) {
        case DO_DUMP:
            {
                AbstractInputMethodService target = mTarget.get();
                if (target == null) {
                    return;
                }
                SomeArgs args = (SomeArgs) msg.obj;
                try {
                    target.dump((FileDescriptor) args.arg1, (PrintWriter) args.arg2, (String[]) args.arg3);
                } catch (RuntimeException e) {
                    ((PrintWriter) args.arg2).println(""Exception: "" + e);
                }
                synchronized (args.arg4) {
                    ((CountDownLatch) args.arg4).countDown();
                }
                args.recycle();
                return;
            }
        case DO_INITIALIZE_INTERNAL:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                try {
                    inputMethod.initializeInternal((IBinder) args.arg1, msg.arg1, (IInputMethodPrivilegedOperations) args.arg2, (int) args.arg3);
                } finally {
                    args.recycle();
                }
                return;
            }
        case DO_SET_INPUT_CONTEXT:
            {
                inputMethod.bindInput((InputBinding) msg.obj);
                return;
            }
        case DO_UNSET_INPUT_CONTEXT:
            inputMethod.unbindInput();
            return;
        case DO_START_INPUT:
            {
                final SomeArgs args = (SomeArgs) msg.obj;
                final IBinder startInputToken = (IBinder) args.arg1;
                final IInputContext inputContext = (IInputContext) args.arg2;
                final EditorInfo info = (EditorInfo) args.arg3;
                final CancellationGroup cancellationGroup = (CancellationGroup) args.arg4;
                SomeArgs moreArgs = (SomeArgs) args.arg5;
                final InputConnection ic = inputContext != null ? new InputConnectionWrapper(mTarget, inputContext, moreArgs.argi3, cancellationGroup) : null;
                info.makeCompatible(mTargetSdkVersion);
                inputMethod.dispatchStartInputWithToken(ic, info, moreArgs.argi1 == 1, /* restarting */
                startInputToken);
                args.recycle();
                moreArgs.recycle();
                return;
            }
        case DO_CREATE_SESSION:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                inputMethod.createSession(new InputMethodSessionCallbackWrapper(mContext, (InputChannel) args.arg1, (IInputSessionCallback) args.arg2));
                args.recycle();
                return;
            }
        case DO_SET_SESSION_ENABLED:
            inputMethod.setSessionEnabled((InputMethodSession) msg.obj, msg.arg1 != 0);
            return;
        case DO_REVOKE_SESSION:
            inputMethod.revokeSession((InputMethodSession) msg.obj);
            return;
        case DO_SHOW_SOFT_INPUT:
            {
                final SomeArgs args = (SomeArgs) msg.obj;
                inputMethod.showSoftInputWithToken(msg.arg1, (ResultReceiver) args.arg2, (IBinder) args.arg1);
                args.recycle();
                return;
            }
        case DO_HIDE_SOFT_INPUT:
            {
                final SomeArgs args = (SomeArgs) msg.obj;
                inputMethod.hideSoftInputWithToken(msg.arg1, (ResultReceiver) args.arg2, (IBinder) args.arg1);
                args.recycle();
                return;
            }
        case DO_CHANGE_INPUTMETHOD_SUBTYPE:
            inputMethod.changeInputMethodSubtype((InputMethodSubtype) msg.obj);
            return;
        case DO_CREATE_INLINE_SUGGESTIONS_REQUEST:
            final SomeArgs args = (SomeArgs) msg.obj;
            inputMethod.onCreateInlineSuggestionsRequest((InlineSuggestionsRequestInfo) args.arg1, (IInlineSuggestionsRequestCallback) args.arg2);
            args.recycle();
            return;
    }
    Log.w(TAG, ""Unhandled message code: "" + msg.what);
}","{
    InputMethod inputMethod = mInputMethod.get();
    // Need a valid reference to the inputMethod for everything except a dump.
    if (inputMethod == null && msg.what != DO_DUMP) {
        Log.w(TAG, ""Input method reference was null, ignoring message: "" + msg.what);
        return;
    }
    switch(msg.what) {
        case DO_DUMP:
            {
                AbstractInputMethodService target = mTarget.get();
                if (target == null) {
                    return;
                }
                SomeArgs args = (SomeArgs) msg.obj;
                try {
                    target.dump((FileDescriptor) args.arg1, (PrintWriter) args.arg2, (String[]) args.arg3);
                } catch (RuntimeException e) {
                    ((PrintWriter) args.arg2).println(""Exception: "" + e);
                }
                synchronized (args.arg4) {
                    ((CountDownLatch) args.arg4).countDown();
                }
                args.recycle();
                return;
            }
        case DO_INITIALIZE_INTERNAL:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                try {
                    inputMethod.initializeInternal((IBinder) args.arg1, (IInputMethodPrivilegedOperations) args.arg2, msg.arg1);
                } finally {
                    args.recycle();
                }
                return;
            }
        case DO_SET_INPUT_CONTEXT:
            {
                inputMethod.bindInput((InputBinding) msg.obj);
                return;
            }
        case DO_UNSET_INPUT_CONTEXT:
            inputMethod.unbindInput();
            return;
        case DO_START_INPUT:
            {
                final SomeArgs args = (SomeArgs) msg.obj;
                final IBinder startInputToken = (IBinder) args.arg1;
                final IInputContext inputContext = (IInputContext) args.arg2;
                final EditorInfo info = (EditorInfo) args.arg3;
                final CancellationGroup cancellationGroup = (CancellationGroup) args.arg4;
                SomeArgs moreArgs = (SomeArgs) args.arg5;
                final InputConnection ic = inputContext != null ? new InputConnectionWrapper(mTarget, inputContext, moreArgs.argi3, cancellationGroup) : null;
                info.makeCompatible(mTargetSdkVersion);
                inputMethod.dispatchStartInputWithToken(ic, info, moreArgs.argi1 == 1, /* restarting */
                startInputToken);
                args.recycle();
                moreArgs.recycle();
                return;
            }
        case DO_CREATE_SESSION:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                inputMethod.createSession(new InputMethodSessionCallbackWrapper(mContext, (InputChannel) args.arg1, (IInputSessionCallback) args.arg2));
                args.recycle();
                return;
            }
        case DO_SET_SESSION_ENABLED:
            inputMethod.setSessionEnabled((InputMethodSession) msg.obj, msg.arg1 != 0);
            return;
        case DO_REVOKE_SESSION:
            inputMethod.revokeSession((InputMethodSession) msg.obj);
            return;
        case DO_SHOW_SOFT_INPUT:
            {
                final SomeArgs args = (SomeArgs) msg.obj;
                inputMethod.showSoftInputWithToken(msg.arg1, (ResultReceiver) args.arg2, (IBinder) args.arg1);
                args.recycle();
                return;
            }
        case DO_HIDE_SOFT_INPUT:
            {
                final SomeArgs args = (SomeArgs) msg.obj;
                inputMethod.hideSoftInputWithToken(msg.arg1, (ResultReceiver) args.arg2, (IBinder) args.arg1);
                args.recycle();
                return;
            }
        case DO_CHANGE_INPUTMETHOD_SUBTYPE:
            inputMethod.changeInputMethodSubtype((InputMethodSubtype) msg.obj);
            return;
        case DO_CREATE_INLINE_SUGGESTIONS_REQUEST:
            final SomeArgs args = (SomeArgs) msg.obj;
            inputMethod.onCreateInlineSuggestionsRequest((InlineSuggestionsRequestInfo) args.arg1, (IInlineSuggestionsRequestCallback) args.arg2);
            args.recycle();
            return;
    }
    Log.w(TAG, ""Unhandled message code: "" + msg.what);
}",1,,,0,"[@MainThread, @Override]","[@MainThread, @Override]",0,,,,2,5,0,5,1,"The method signature of the dependent API ""initializeInternal"" has changed in the late version, with the parameter ""int"" being removed.","Since the dependent API has undergone changes in its method signature, it may cause compatibility issues as the input provided by the early version may not be compatible with the late version. Therefore, this is a compatibility issue caused by potential different return values or types."
21,<android.text.style.StyleSpan: void updateMeasureState(TextPaint)>,31,32,,,,"{
    apply(paint, mStyle);
}","{
    apply(paint, mStyle, mFontWeightAdjustment);
}",1,,,0,[@Override],[@Override],0,,,,2,5,0,5,1,"The `apply` method in the late version has an additional argument `mFontWeightAdjustment`, which indicates that the `updateMeasureState` method now uses a different version of the `apply` method. This is considered as a Dependent API change.","As the `apply` method in the late version has an additional argument, the behavior of the method could potentially change, leading to a different return value or type. Therefore, this change could potentially cause a Compatibility Issue of type 1."
24,"<android.content.Context: int[] checkUriPermissions(List<Uri>,int,int,int)>",31,32,,,,"{
    throw new RuntimeException(""Not implemented. Must override in a subclass."");
}","{
    throw new RuntimeException(""Not implemented. Must override in a subclass."");
}",0,"/**
 * Determine whether a particular process and user ID has been granted
 * permission to access a list of URIs.  This only checks for permissions
 * that have been explicitly granted -- if the given process/uid has
 * more general access to the URI's content provider then this check will
 * always fail.
 *
 * @param uris The list of URIs that is being checked.
 * @param pid The process ID being checked against.  Must be &gt; 0.
 * @param uid The user ID being checked against.  A uid of 0 is the root
 * user, which will pass every permission check.
 * @param modeFlags The access modes to check for the list of uris
 *
 * @return Array of permission grants corresponding to each entry in the list of uris.
 * {@link PackageManager#PERMISSION_GRANTED} if the given pid/uid is allowed to access that uri,
 * or {@link PackageManager#PERMISSION_DENIED} if it is not.
 *
 * @see #checkCallingUriPermission
 */
","/**
 * Determine whether a particular process and user ID has been granted
 * permission to access a list of URIs.  This only checks for permissions
 * that have been explicitly granted -- if the given process/uid has
 * more general access to the URI's content provider then this check will
 * always fail.
 *
 * <strong>Note:</strong> On SDK Version {@link android.os.Build.VERSION_CODES#S},
 * calling this method from a secondary-user's context will incorrectly return
 * {@link PackageManager#PERMISSION_DENIED} for all {code uris}.
 *
 * @param uris The list of URIs that is being checked.
 * @param pid The process ID being checked against.  Must be &gt; 0.
 * @param uid The user ID being checked against.  A uid of 0 is the root
 * user, which will pass every permission check.
 * @param modeFlags The access modes to check for the list of uris
 *
 * @return Array of permission grants corresponding to each entry in the list of uris.
 * {@link PackageManager#PERMISSION_GRANTED} if the given pid/uid is allowed to access that uri,
 * or {@link PackageManager#PERMISSION_DENIED} if it is not.
 *
 * @see #checkCallingUriPermission
 */
",1,"[@NonNull, @PackageManager.PermissionResult]","[@NonNull, @PackageManager.PermissionResult]",0,,,,0,0,0,0,0,No changes have been made in the given API between the two versions.,"As there are no changes, there is no potential for a Compatibility Issue to arise."
25,<android.content.res.TypedArray: ColorStateList getColorStateList(int)>,32,33,,,,"{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    final TypedValue value = mValue;
    if (getValueAt(index * STYLE_NUM_ENTRIES, value)) {
        if (value.type == TypedValue.TYPE_ATTRIBUTE) {
            throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + index + "": "" + value);
        }
        return mResources.loadColorStateList(value, value.resourceId, mTheme);
    }
    return null;
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    final TypedValue value = mValue;
    if (getValueAt(index * STYLE_NUM_ENTRIES, value)) {
        if (value.type == TypedValue.TYPE_ATTRIBUTE) {
            throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + index + "": "" + value + "", theme="" + mTheme);
        }
        return mResources.loadColorStateList(value, value.resourceId, mTheme);
    }
    return null;
}",1,"/**
 * Retrieve the ColorStateList for the attribute at <var>index</var>.
 * The value may be either a single solid color or a reference to
 * a color or complex {@link android.content.res.ColorStateList}
 * description.
 * <p>
 * This method will return {@code null} if the attribute is not defined or
 * is not an integer color or color state list.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return ColorStateList for the attribute, or {@code null} if not
 * defined.
 * @throws RuntimeException if the attribute if the TypedArray has already
 * been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not an integer color or color state list.
 */
","/**
 * Retrieve the ColorStateList for the attribute at <var>index</var>.
 * The value may be either a single solid color or a reference to
 * a color or complex {@link android.content.res.ColorStateList}
 * description.
 * <p>
 * This method will return {@code null} if the attribute is not defined or
 * is not an integer color or color state list.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return ColorStateList for the attribute, or {@code null} if not
 * defined.
 * @throws RuntimeException if the attribute if the TypedArray has already
 * been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not an integer color or color state list.
 */
",0,[@Nullable],[@Nullable],0,,,,2,5,0,2,2,"In the late implementation, a new variable ""mTheme"" is added to the exception message of the UnsupportedOperationException.","This change in exception message does not affect the behavior of the API, but it will provide additional information when the UnsupportedOperationException is thrown, which could potentially lead to different exception handling. Therefore, it is a Compatibility Issue caused by potential different exception handlings."
26,<android.app.admin.DevicePolicyManager: int logoutUser(ComponentName)>,32,33,,,,"{
    throwIfParentInstance(""logoutUser"");
    try {
        return mService.logoutUser(admin);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}","{
    throwIfParentInstance(""logoutUser"");
    try {
        return mService.logoutUser(admin);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}",0,"/**
 * Called by a profile owner of secondary user that is affiliated with the device to stop the
 * calling user and switch back to primary user.
 *
 * <p>Notice that on devices running with
 * {@link UserManager#isHeadlessSystemUserMode() headless system user mode}, there is no primary
 * user, so it switches back to the user that was in the foreground before the first call to
 * {@link #switchUser(ComponentName, UserHandle)} (or fails with
 * {@link UserManager#USER_OPERATION_ERROR_UNKNOWN} if that method was not called prior to this
 * call).
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @return one of the following result codes:
 * {@link UserManager#USER_OPERATION_ERROR_UNKNOWN},
 * {@link UserManager#USER_OPERATION_SUCCESS},
 * {@link UserManager#USER_OPERATION_ERROR_MANAGED_PROFILE},
 * {@link UserManager#USER_OPERATION_ERROR_CURRENT_USER}
 * @throws SecurityException if {@code admin} is not a profile owner affiliated with the device.
 * @see #getSecondaryUsers(ComponentName)
 */
","/**
 * Called by a profile owner of secondary user that is affiliated with the device to stop the
 * calling user and switch back to primary user (when the user was
 * {@link #switchUser(ComponentName, UserHandle)} switched to) or stop the user (when it was
 * {@link #startUserInBackground(ComponentName, UserHandle) started in background}.
 *
 * <p>Notice that on devices running with
 * {@link UserManager#isHeadlessSystemUserMode() headless system user mode}, there is no primary
 * user, so it switches back to the user that was in the foreground before the first call to
 * {@link #switchUser(ComponentName, UserHandle)} (or fails with
 * {@link UserManager#USER_OPERATION_ERROR_UNKNOWN} if that method was not called prior to this
 * call).
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @return one of the following result codes:
 * {@link UserManager#USER_OPERATION_ERROR_UNKNOWN},
 * {@link UserManager#USER_OPERATION_SUCCESS},
 * {@link UserManager#USER_OPERATION_ERROR_MANAGED_PROFILE},
 * {@link UserManager#USER_OPERATION_ERROR_CURRENT_USER}
 * @throws SecurityException if {@code admin} is not a profile owner affiliated with the device.
 * @see #getSecondaryUsers(ComponentName)
 */
",1,[@UserOperationResult],[@UserOperationResult],0,,,,0,0,0,0,0,"The code in the early version and the late version is exactly the same, so there is no change.","Since there is no change in the code, the API will not lead to different behaviours, and thus there is no potential Compatibility Issue."
27,"<android.view.contentcapture.DataRemovalRequest.Builder: Builder addLocusId(LocusId,int)>",32,33,,,,"{
    throwIfDestroyed();
    Preconditions.checkState(!mForEverything, ""Already is for everything"");
    Preconditions.checkNotNull(locusId);
    if (mLocusIds == null) {
        mLocusIds = new ArrayList<>();
        mFlags = new IntArray();
    }
    mLocusIds.add(locusId);
    mFlags.add(flags);
    return this;
}","{
    throwIfDestroyed();
    Preconditions.checkState(!mForEverything, ""Already is for everything"");
    Objects.requireNonNull(locusId);
    if (mLocusIds == null) {
        mLocusIds = new ArrayList<>();
        mFlags = new IntArray();
    }
    mLocusIds.add(locusId);
    mFlags.add(flags);
    return this;
}",1,"/**
 * Request service to remove data associated with a given {@link LocusId}.
 *
 * @param locusId the {@link LocusId} being requested to be removed.
 * @param flags either {@link DataRemovalRequest#FLAG_IS_PREFIX} or {@code 0}
 *
 * @return this builder
 */
","/**
 * Request service to remove data associated with a given {@link LocusId}.
 *
 * @param locusId the {@link LocusId} being requested to be removed.
 * @param flags either {@link DataRemovalRequest#FLAG_IS_PREFIX} or {@code 0}
 *
 * @return this builder
 */
",0,[@NonNull],[@NonNull],0,,,,2,5,0,4,0,The method of checking the non-null condition for the locusId parameter has been changed from `Preconditions.checkNotNull(locusId)` to `Objects.requireNonNull(locusId)`. This change belongs to the "Other statement changed" category (4).,"The change in the non-null checking method does not affect the overall behavior of the API. Both methods throw a NullPointerException if the locusId parameter is null, so the API will not return different values or throw different exceptions. Therefore, there is no compatibility issue (0)."
28,"<android.text.BoringLayout: BoringLayout replaceOrMake(CharSequence,TextPaint,int,Alignment,float,float,Metrics,boolean,TruncateAt,int)>",32,33,,,,"{
    boolean trust;
    if (ellipsize == null || ellipsize == TextUtils.TruncateAt.MARQUEE) {
        replaceWith(source, paint, outerWidth, align, spacingMult, spacingAdd);
        mEllipsizedWidth = outerWidth;
        mEllipsizedStart = 0;
        mEllipsizedCount = 0;
        trust = true;
    } else {
        replaceWith(TextUtils.ellipsize(source, paint, ellipsizedWidth, ellipsize, true, this), paint, outerWidth, align, spacingMult, spacingAdd);
        mEllipsizedWidth = ellipsizedWidth;
        trust = false;
    }
    init(getText(), paint, align, metrics, includePad, trust);
    return this;
}","{
    return replaceOrMake(source, paint, outerWidth, align, metrics, includePad, ellipsize, ellipsizedWidth, false);
}",1,"/**
 * Returns a BoringLayout for the specified text, potentially reusing
 * this one if it is already suitable.  The caller must make sure that
 * no one is still using this Layout.
 *
 * @param source the text to render
 * @param paint the default paint for the layout
 * @param outerWidth the wrapping width for the text
 * @param align whether to left, right, or center the text
 * @param spacingMult this value is no longer used by BoringLayout
 * @param spacingAdd this value is no longer used by BoringLayout
 * @param metrics {@code #Metrics} instance that contains information about FontMetrics and
 * line width
 * @param includePad set whether to include extra space beyond font ascent and descent which is
 * needed to avoid clipping in some scripts
 * @param ellipsize whether to ellipsize the text if width of the text is longer than the
 * requested width
 * @param ellipsizedWidth the width to which this Layout is ellipsizing. If {@code ellipsize} is
 * {@code null}, or is {@link TextUtils.TruncateAt#MARQUEE} this value is
 * not used, {@code outerwidth} is used instead
 */
","/**
 * Returns a BoringLayout for the specified text, potentially reusing
 * this one if it is already suitable.  The caller must make sure that
 * no one is still using this Layout.
 *
 * @param source the text to render
 * @param paint the default paint for the layout
 * @param outerWidth the wrapping width for the text
 * @param align whether to left, right, or center the text
 * @param spacingMult this value is no longer used by BoringLayout
 * @param spacingAdd this value is no longer used by BoringLayout
 * @param metrics {@code #Metrics} instance that contains information about FontMetrics and
 * line width
 * @param includePad set whether to include extra space beyond font ascent and descent which is
 * needed to avoid clipping in some scripts
 * @param ellipsize whether to ellipsize the text if width of the text is longer than the
 * requested width
 * @param ellipsizedWidth the width to which this Layout is ellipsizing. If {@code ellipsize} is
 * {@code null}, or is {@link TextUtils.TruncateAt#MARQUEE} this value is
 * not used, {@code outerWidth} is used instead
 */
",1,,,0,,,,"1,2","1,3,4,5",1,"1,5",1,"The implementation of the API has been completely changed, with the old code being replaced with a single call to another method. This constitutes a change in the control dependency, as well as a change in the dependent API. Therefore, the code change type is 1,5.","The new implementation relies on another method, whose behavior may differ from the original implementation. This could potentially cause the API to return a different value, leading to a Compatibility Issue of type 1."
29,<android.service.dreams.DreamService: boolean isFullscreen()>,32,33,,,,"{
    return mFullscreen;
}","{
    return mFullscreen;
}",0,"/**
 * Returns whether or not this dream is in fullscreen mode. Defaults to false.
 *
 * @see #setFullscreen(boolean)
 */
","/**
 * Returns whether this dream is in fullscreen mode. Defaults to false.
 *
 * @see #setFullscreen(boolean)
 */
",1,,,0,,,,0,0,0,0,0,"There is no change in the method implementation, hence the code change type is 0.","As there is no change in the method implementation, there will be no compatibility issues, hence the CI type is 0."
30,<android.os.Binder: void joinThreadPool()>,32,33,,,,"{
    BinderInternal.joinThreadPool();
}","{
    BinderInternal.joinThreadPool();
}",0,"/**
 * Add the calling thread to the IPC thread pool.  This function does
 * not return until the current process is exiting.
 */
","/**
 * Add the calling thread to the IPC thread pool. This function does
 * not return until the current process is exiting.
 */
",1,,,0,,,,0,0,0,0,0,There is no change in the implementation of `joinThreadPool()` method between the two versions.,There is no compatibility issue as there is no change in the method implementation.
31,<android.view.ViewRootImpl.NativePreImeInputStage: int onProcess(QueuedInputEvent)>,32,33,,,,"{
    if (mInputQueue != null && q.mEvent instanceof KeyEvent) {
        mInputQueue.sendInputEvent(q.mEvent, q, true, this);
        return DEFER;
    }
    return FORWARD;
}","{
    if (q.mEvent instanceof KeyEvent) {
        final KeyEvent event = (KeyEvent) q.mEvent;
        // view tree or IME, and invoke the appropriate {@link OnBackInvokedCallback}.
        if (isBack(event) && mContext != null && WindowOnBackInvokedDispatcher.isOnBackInvokedCallbackEnabled(mContext)) {
            OnBackInvokedCallback topCallback = getOnBackInvokedDispatcher().getTopCallback();
            if (event.getAction() == KeyEvent.ACTION_UP) {
                if (topCallback != null) {
                    topCallback.onBackInvoked();
                    return FINISH_HANDLED;
                }
            } else {
                // Drop other actions such as {@link KeyEvent.ACTION_DOWN}.
                return FINISH_NOT_HANDLED;
            }
        }
    }
    if (mInputQueue != null && q.mEvent instanceof KeyEvent) {
        mInputQueue.sendInputEvent(q.mEvent, q, true, this);
        return DEFER;
    }
    return FORWARD;
}",1,,,0,[@Override],[@Override],0,,,,"1,2","1,3,4,5",1,"1,3,5","1,2","The Late\_Implementation introduces new if-else statements to handle the 'KeyEvent' instance differently. There is a new method call 'isBack(event)' in the Late\_Implementation, which is a dependent API change. Additionally, there is a new return value 'FINISH\_HANDLED' and 'FINISH\_NOT\_HANDLED' in the Late\_Implementation.","The new if-else statements and the dependent API change can potentially lead to different behaviors and return values. The new return values 'FINISH\_HANDLED' and 'FINISH\_NOT\_HANDLED' can cause compatibility issues. Additionally, there is a new method call 'isBack(event)' in the Late\_Implementation, which can potentially throw a new exception and cause compatibility issues."
32,"<android.view.translation.UiTranslationManager: void registerUiTranslationStateCallback(Executor,UiTranslationStateCallback)>",32,33,,,,"{
    Objects.requireNonNull(executor);
    Objects.requireNonNull(callback);
    synchronized (mCallbacks) {
        if (mCallbacks.containsKey(callback)) {
            Log.w(TAG, ""registerUiTranslationStateCallback: callback already registered;"" + "" ignoring."");
            return;
        }
        final IRemoteCallback remoteCallback = new UiTranslationStateRemoteCallback(executor, callback);
        try {
            mService.registerUiTranslationStateCallback(remoteCallback, mContext.getUserId());
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
        mCallbacks.put(callback, remoteCallback);
    }
}","{
    Objects.requireNonNull(executor);
    Objects.requireNonNull(callback);
    synchronized (mCallbacks) {
        if (mCallbacks.containsKey(callback)) {
            Log.w(TAG, ""registerUiTranslationStateCallback: callback already registered;"" + "" ignoring."");
            return;
        }
        final IRemoteCallback remoteCallback = new UiTranslationStateRemoteCallback(executor, callback);
        try {
            mService.registerUiTranslationStateCallback(remoteCallback, mContext.getUserId());
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
        mCallbacks.put(callback, remoteCallback);
    }
}",0,"/**
 * Register for notifications of UI Translation state changes on the foreground activity. This
 * is available to the owning application itself and also the current input method.
 * <p>
 * The application whose UI is being translated can use this to customize the UI Translation
 * behavior in ways that aren't made easy by methods like
 * {@link View#onCreateViewTranslationRequest(int[], Consumer)}.
 *
 * <p>
 * Input methods can use this to offer complementary features to UI Translation; for example,
 * enabling outgoing message translation when the system is translating incoming messages in a
 * communication app.
 *
 * @param callback the callback to register for receiving the state change
 * notifications
 */
","/**
 * Register for notifications of UI Translation state changes on the foreground Activity. This
 * is available to the owning application itself and also the current input method.
 * <p>
 * The application whose UI is being translated can use this to customize the UI Translation
 * behavior in ways that aren't made easy by methods like
 * {@link View#onCreateViewTranslationRequest(int[], Consumer)}.
 * <p>
 * Input methods can use this to offer complementary features to UI Translation; for example,
 * enabling outgoing message translation when the system is translating incoming messages in a
 * communication app.
 * <p>
 * Starting from {@link android.os.Build.VERSION_CODES#TIRAMISU}, if Activities are already
 * being translated when a callback is registered, methods on the callback will be invoked for
 * each translated activity, depending on the state of translation:
 * <ul>
 * <li>If translation is <em>not</em> paused,
 * {@link UiTranslationStateCallback#onStarted} will be invoked.</li>
 * <li>If translation <em>is</em> paused, {@link UiTranslationStateCallback#onStarted}
 * will first be invoked, followed by {@link UiTranslationStateCallback#onPaused}.</li>
 * </ul>
 *
 * @param callback the callback to register for receiving the state change
 * notifications
 */
",1,,,0,,,,0,0,0,0,0,There is no difference between the Early_Implementation and Late_Implementation of the given API.,"Since there is no change between the two versions, there will be no Compatibility Issue."
33,<android.view.ViewRootImpl.ViewRootHandler: String getMessageName(Message)>,32,33,,,,"{
    switch(message.what) {
        case MSG_INVALIDATE:
            return ""MSG_INVALIDATE"";
        case MSG_INVALIDATE_RECT:
            return ""MSG_INVALIDATE_RECT"";
        case MSG_DIE:
            return ""MSG_DIE"";
        case MSG_RESIZED:
            return ""MSG_RESIZED"";
        case MSG_RESIZED_REPORT:
            return ""MSG_RESIZED_REPORT"";
        case MSG_WINDOW_FOCUS_CHANGED:
            return ""MSG_WINDOW_FOCUS_CHANGED"";
        case MSG_DISPATCH_INPUT_EVENT:
            return ""MSG_DISPATCH_INPUT_EVENT"";
        case MSG_DISPATCH_APP_VISIBILITY:
            return ""MSG_DISPATCH_APP_VISIBILITY"";
        case MSG_DISPATCH_GET_NEW_SURFACE:
            return ""MSG_DISPATCH_GET_NEW_SURFACE"";
        case MSG_DISPATCH_KEY_FROM_IME:
            return ""MSG_DISPATCH_KEY_FROM_IME"";
        case MSG_DISPATCH_KEY_FROM_AUTOFILL:
            return ""MSG_DISPATCH_KEY_FROM_AUTOFILL"";
        case MSG_CHECK_FOCUS:
            return ""MSG_CHECK_FOCUS"";
        case MSG_CLOSE_SYSTEM_DIALOGS:
            return ""MSG_CLOSE_SYSTEM_DIALOGS"";
        case MSG_DISPATCH_DRAG_EVENT:
            return ""MSG_DISPATCH_DRAG_EVENT"";
        case MSG_DISPATCH_DRAG_LOCATION_EVENT:
            return ""MSG_DISPATCH_DRAG_LOCATION_EVENT"";
        case MSG_DISPATCH_SYSTEM_UI_VISIBILITY:
            return ""MSG_DISPATCH_SYSTEM_UI_VISIBILITY"";
        case MSG_UPDATE_CONFIGURATION:
            return ""MSG_UPDATE_CONFIGURATION"";
        case MSG_PROCESS_INPUT_EVENTS:
            return ""MSG_PROCESS_INPUT_EVENTS"";
        case MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST:
            return ""MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST"";
        case MSG_WINDOW_MOVED:
            return ""MSG_WINDOW_MOVED"";
        case MSG_SYNTHESIZE_INPUT_EVENT:
            return ""MSG_SYNTHESIZE_INPUT_EVENT"";
        case MSG_DISPATCH_WINDOW_SHOWN:
            return ""MSG_DISPATCH_WINDOW_SHOWN"";
        case MSG_UPDATE_POINTER_ICON:
            return ""MSG_UPDATE_POINTER_ICON"";
        case MSG_POINTER_CAPTURE_CHANGED:
            return ""MSG_POINTER_CAPTURE_CHANGED"";
        case MSG_DRAW_FINISHED:
            return ""MSG_DRAW_FINISHED"";
        case MSG_INSETS_CHANGED:
            return ""MSG_INSETS_CHANGED"";
        case MSG_INSETS_CONTROL_CHANGED:
            return ""MSG_INSETS_CONTROL_CHANGED"";
        case MSG_SYSTEM_GESTURE_EXCLUSION_CHANGED:
            return ""MSG_SYSTEM_GESTURE_EXCLUSION_CHANGED"";
        case MSG_LOCATION_IN_PARENT_DISPLAY_CHANGED:
            return ""MSG_LOCATION_IN_PARENT_DISPLAY_CHANGED"";
        case MSG_SHOW_INSETS:
            return ""MSG_SHOW_INSETS"";
        case MSG_HIDE_INSETS:
            return ""MSG_HIDE_INSETS"";
    }
    return super.getMessageName(message);
}","{
    switch(message.what) {
        case MSG_INVALIDATE:
            return ""MSG_INVALIDATE"";
        case MSG_INVALIDATE_RECT:
            return ""MSG_INVALIDATE_RECT"";
        case MSG_DIE:
            return ""MSG_DIE"";
        case MSG_RESIZED:
            return ""MSG_RESIZED"";
        case MSG_RESIZED_REPORT:
            return ""MSG_RESIZED_REPORT"";
        case MSG_WINDOW_FOCUS_CHANGED:
            return ""MSG_WINDOW_FOCUS_CHANGED"";
        case MSG_DISPATCH_INPUT_EVENT:
            return ""MSG_DISPATCH_INPUT_EVENT"";
        case MSG_DISPATCH_APP_VISIBILITY:
            return ""MSG_DISPATCH_APP_VISIBILITY"";
        case MSG_DISPATCH_GET_NEW_SURFACE:
            return ""MSG_DISPATCH_GET_NEW_SURFACE"";
        case MSG_DISPATCH_KEY_FROM_IME:
            return ""MSG_DISPATCH_KEY_FROM_IME"";
        case MSG_DISPATCH_KEY_FROM_AUTOFILL:
            return ""MSG_DISPATCH_KEY_FROM_AUTOFILL"";
        case MSG_CHECK_FOCUS:
            return ""MSG_CHECK_FOCUS"";
        case MSG_CLOSE_SYSTEM_DIALOGS:
            return ""MSG_CLOSE_SYSTEM_DIALOGS"";
        case MSG_DISPATCH_DRAG_EVENT:
            return ""MSG_DISPATCH_DRAG_EVENT"";
        case MSG_DISPATCH_DRAG_LOCATION_EVENT:
            return ""MSG_DISPATCH_DRAG_LOCATION_EVENT"";
        case MSG_DISPATCH_SYSTEM_UI_VISIBILITY:
            return ""MSG_DISPATCH_SYSTEM_UI_VISIBILITY"";
        case MSG_UPDATE_CONFIGURATION:
            return ""MSG_UPDATE_CONFIGURATION"";
        case MSG_PROCESS_INPUT_EVENTS:
            return ""MSG_PROCESS_INPUT_EVENTS"";
        case MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST:
            return ""MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST"";
        case MSG_WINDOW_MOVED:
            return ""MSG_WINDOW_MOVED"";
        case MSG_SYNTHESIZE_INPUT_EVENT:
            return ""MSG_SYNTHESIZE_INPUT_EVENT"";
        case MSG_DISPATCH_WINDOW_SHOWN:
            return ""MSG_DISPATCH_WINDOW_SHOWN"";
        case MSG_UPDATE_POINTER_ICON:
            return ""MSG_UPDATE_POINTER_ICON"";
        case MSG_POINTER_CAPTURE_CHANGED:
            return ""MSG_POINTER_CAPTURE_CHANGED"";
        case MSG_INSETS_CONTROL_CHANGED:
            return ""MSG_INSETS_CONTROL_CHANGED"";
        case MSG_SYSTEM_GESTURE_EXCLUSION_CHANGED:
            return ""MSG_SYSTEM_GESTURE_EXCLUSION_CHANGED"";
        case MSG_SHOW_INSETS:
            return ""MSG_SHOW_INSETS"";
        case MSG_HIDE_INSETS:
            return ""MSG_HIDE_INSETS"";
        case MSG_WINDOW_TOUCH_MODE_CHANGED:
            return ""MSG_WINDOW_TOUCH_MODE_CHANGED"";
        case MSG_KEEP_CLEAR_RECTS_CHANGED:
            return ""MSG_KEEP_CLEAR_RECTS_CHANGED"";
    }
    return super.getMessageName(message);
}",1,,,0,[@Override],[@Override],0,,,,1,"1,3",1,3,0,"Two new message cases have been added in the switch statement, namely ""MSG\_WINDOW\_TOUCH\_MODE\_CHANGED"" and ""MSG\_KEEP\_CLEAR\_RECTS\_CHANGED"".","As the new cases only add additional mapping between message code and message name without affecting the behavior of other message codes, this change does not introduce any compatibility issue."
34,<android.view.autofill.AutofillManager.TrackedViews: void onVisibleForAutofillChangedLocked()>,32,33,,,,"{
    // The visibility of the views might have changed while the client was not be visible,
    // hence update the visibility state for all views.
    AutofillClient client = getClient();
    ArraySet<AutofillId> updatedVisibleTrackedIds = null;
    ArraySet<AutofillId> updatedInvisibleTrackedIds = null;
    if (client != null) {
        if (sVerbose) {
            Log.v(TAG, ""onVisibleForAutofillChangedLocked(): inv= "" + mInvisibleTrackedIds + "" vis="" + mVisibleTrackedIds);
        }
        if (mInvisibleTrackedIds != null) {
            final ArrayList<AutofillId> orderedInvisibleIds = new ArrayList<>(mInvisibleTrackedIds);
            final boolean[] isVisible = client.autofillClientGetViewVisibility(Helper.toArray(orderedInvisibleIds));
            final int numInvisibleTrackedIds = orderedInvisibleIds.size();
            for (int i = 0; i < numInvisibleTrackedIds; i++) {
                final AutofillId id = orderedInvisibleIds.get(i);
                if (isVisible[i]) {
                    updatedVisibleTrackedIds = addToSet(updatedVisibleTrackedIds, id);
                    if (sDebug) {
                        Log.d(TAG, ""onVisibleForAutofill() "" + id + "" became visible"");
                    }
                } else {
                    updatedInvisibleTrackedIds = addToSet(updatedInvisibleTrackedIds, id);
                }
            }
        }
        if (mVisibleTrackedIds != null) {
            final ArrayList<AutofillId> orderedVisibleIds = new ArrayList<>(mVisibleTrackedIds);
            final boolean[] isVisible = client.autofillClientGetViewVisibility(Helper.toArray(orderedVisibleIds));
            final int numVisibleTrackedIds = orderedVisibleIds.size();
            for (int i = 0; i < numVisibleTrackedIds; i++) {
                final AutofillId id = orderedVisibleIds.get(i);
                if (isVisible[i]) {
                    updatedVisibleTrackedIds = addToSet(updatedVisibleTrackedIds, id);
                } else {
                    updatedInvisibleTrackedIds = addToSet(updatedInvisibleTrackedIds, id);
                    if (sDebug) {
                        Log.d(TAG, ""onVisibleForAutofill() "" + id + "" became invisible"");
                    }
                }
            }
        }
        mInvisibleTrackedIds = updatedInvisibleTrackedIds;
        mVisibleTrackedIds = updatedVisibleTrackedIds;
    }
    if (mVisibleTrackedIds == null) {
        if (sVerbose) {
            Log.v(TAG, ""onVisibleForAutofillChangedLocked(): no more visible ids"");
        }
        finishSessionLocked();
    }
}","{
    // The visibility of the views might have changed while the client was not be visible,
    // hence update the visibility state for all views.
    AutofillClient client = getClient();
    ArraySet<AutofillId> updatedVisibleTrackedIds = null;
    ArraySet<AutofillId> updatedInvisibleTrackedIds = null;
    if (client != null) {
        if (sVerbose) {
            Log.v(TAG, ""onVisibleForAutofillChangedLocked(): inv= "" + mInvisibleTrackedIds + "" vis="" + mVisibleTrackedIds);
        }
        if (mInvisibleTrackedIds != null) {
            final ArrayList<AutofillId> orderedInvisibleIds = new ArrayList<>(mInvisibleTrackedIds);
            final boolean[] isVisible = client.autofillClientGetViewVisibility(Helper.toArray(orderedInvisibleIds));
            final int numInvisibleTrackedIds = orderedInvisibleIds.size();
            for (int i = 0; i < numInvisibleTrackedIds; i++) {
                final AutofillId id = orderedInvisibleIds.get(i);
                if (isVisible[i]) {
                    updatedVisibleTrackedIds = addToSet(updatedVisibleTrackedIds, id);
                    if (sDebug) {
                        Log.d(TAG, ""onVisibleForAutofill() "" + id + "" became visible"");
                    }
                } else {
                    updatedInvisibleTrackedIds = addToSet(updatedInvisibleTrackedIds, id);
                }
            }
        }
        if (mVisibleTrackedIds != null) {
            final ArrayList<AutofillId> orderedVisibleIds = new ArrayList<>(mVisibleTrackedIds);
            final boolean[] isVisible = client.autofillClientGetViewVisibility(Helper.toArray(orderedVisibleIds));
            final int numVisibleTrackedIds = orderedVisibleIds.size();
            for (int i = 0; i < numVisibleTrackedIds; i++) {
                final AutofillId id = orderedVisibleIds.get(i);
                if (isVisible[i]) {
                    updatedVisibleTrackedIds = addToSet(updatedVisibleTrackedIds, id);
                } else {
                    updatedInvisibleTrackedIds = addToSet(updatedInvisibleTrackedIds, id);
                    if (sDebug) {
                        Log.d(TAG, ""onVisibleForAutofill() "" + id + "" became invisible"");
                    }
                }
            }
        }
        mInvisibleTrackedIds = updatedInvisibleTrackedIds;
        mVisibleTrackedIds = updatedVisibleTrackedIds;
    }
    if (mVisibleTrackedIds == null) {
        if (sVerbose) {
            Log.v(TAG, ""onVisibleForAutofillChangedLocked(): no more visible ids"");
        }
        finishSessionLocked(/* commitReason= */
        COMMIT_REASON_VIEW_CHANGED);
    }
}",1,"/**
 * Called once the client becomes visible.
 *
 * @see AutofillClient#autofillClientIsVisibleForAutofill()
 */
","/**
 * Called once the client becomes visible.
 *
 * @see AutofillClient#autofillClientIsVisibleForAutofill()
 */
",0,[@GuardedBy("mLock")],[@GuardedBy("mLock")],0,,,,2,5,0,5,0,"The dependent API `finishSessionLocked` has changed, specifically, the call to `finishSessionLocked` in the late version has an additional parameter `COMMIT_REASON_VIEW_CHANGED` that is not present in the early version.","The change in the dependent API does not lead to different return values or types or different exception handlings, so there is no compatibility issue caused by this change."
35,"<android.os.Vibrator: void vibrate(long[],int,AudioAttributes)>",32,33,,,,"{
    // exceptions for compatibility purposes
    if (repeat < -1 || repeat >= pattern.length) {
        Log.e(TAG, ""vibrate called with repeat index out of bounds"" + "" (pattern.length="" + pattern.length + "", index="" + repeat + "")"");
        throw new ArrayIndexOutOfBoundsException();
    }
    try {
        vibrate(VibrationEffect.createWaveform(pattern, repeat), attributes);
    } catch (IllegalArgumentException iae) {
        Log.e(TAG, ""Failed to create VibrationEffect"", iae);
    }
}","{
    // exceptions for compatibility purposes
    if (repeat < -1 || repeat >= pattern.length) {
        Log.e(TAG, ""vibrate called with repeat index out of bounds"" + "" (pattern.length="" + pattern.length + "", index="" + repeat + "")"");
        throw new ArrayIndexOutOfBoundsException();
    }
    try {
        vibrate(VibrationEffect.createWaveform(pattern, repeat), attributes);
    } catch (IllegalArgumentException iae) {
        Log.e(TAG, ""Failed to create VibrationEffect"", iae);
    }
}",0,"/**
 * Vibrate with a given pattern.
 *
 * <p>
 * Pass in an array of ints that are the durations for which to turn on or off
 * the vibrator in milliseconds.  The first value indicates the number of milliseconds
 * to wait before turning the vibrator on.  The next value indicates the number of milliseconds
 * for which to keep the vibrator on before turning it off.  Subsequent values alternate
 * between durations in milliseconds to turn the vibrator off or to turn the vibrator on.
 * </p><p>
 * To cause the pattern to repeat, pass the index into the pattern array at which
 * to start the repeat, or -1 to disable repeating.
 * </p>
 *
 * @param pattern    an array of longs of times for which to turn the vibrator on or off.
 * @param repeat     the index into pattern at which to repeat, or -1 if
 * you don't want to repeat.
 * @param attributes {@link AudioAttributes} corresponding to the vibration. For example,
 * specify {@link AudioAttributes#USAGE_ALARM} for alarm vibrations or
 * {@link AudioAttributes#USAGE_NOTIFICATION_RINGTONE} for
 * vibrations associated with incoming calls.
 * @deprecated Use {@link #vibrate(VibrationEffect, AudioAttributes)} instead.
 */
","/**
 * Vibrate with a given pattern.
 *
 * <p>
 * Pass in an array of ints that are the durations for which to turn on or off
 * the vibrator in milliseconds.  The first value indicates the number of milliseconds
 * to wait before turning the vibrator on.  The next value indicates the number of milliseconds
 * for which to keep the vibrator on before turning it off.  Subsequent values alternate
 * between durations in milliseconds to turn the vibrator off or to turn the vibrator on.
 * </p><p>
 * To cause the pattern to repeat, pass the index into the pattern array at which
 * to start the repeat, or -1 to disable repeating.
 * </p>
 *
 * <p>The app should be in the foreground for the vibration to happen. Background apps should
 * specify a ringtone, notification or alarm usage in order to vibrate.</p>
 *
 * @param pattern    an array of longs of times for which to turn the vibrator on or off.
 * @param repeat     the index into pattern at which to repeat, or -1 if
 * you don't want to repeat.
 * @param attributes {@link AudioAttributes} corresponding to the vibration. For example,
 * specify {@link AudioAttributes#USAGE_ALARM} for alarm vibrations or
 * {@link AudioAttributes#USAGE_NOTIFICATION_RINGTONE} for
 * vibrations associated with incoming calls.
 * @deprecated Use {@link #vibrate(VibrationEffect, VibrationAttributes)} instead.
 */
",1,"[@Deprecated, @RequiresPermission(android.Manifest.permission.VIBRATE)]","[@Deprecated, @RequiresPermission(android.Manifest.permission.VIBRATE)]",0,,,,0,0,0,0,0,"There is no change between the two versions of vibrate(long[],int,AudioAttributes) method.","No Compatibility Issue, since the method implementation and annotation have not changed between the two versions."
36,<android.companion.AssociationRequest.Builder: Builder setSingleDevice(boolean)>,32,33,,,,"{
    checkNotUsed();
    this.mSingleDevice = singleDevice;
    return this;
}","{
    checkNotUsed();
    this.mSingleDevice = singleDevice;
    return this;
}",0,"/**
 * Whether only a single device should match the provided filter.
 *
 * When scanning for a single device with a specifc {@link BluetoothDeviceFilter} mac
 * address, bonded devices are also searched among. This allows to obtain the necessary app
 * privileges even if the device is already paired.
 *
 * @param singleDevice if true, scanning for a device will stop as soon as at least one
 * fitting device is found
 */
","/**
 * Whether only a single device should match the provided filter.
 *
 * When scanning for a single device with a specific {@link BluetoothDeviceFilter} mac
 * address, bonded devices are also searched among. This allows to obtain the necessary app
 * privileges even if the device is already paired.
 *
 * @param singleDevice if true, scanning for a device will stop as soon as at least one
 * fitting device is found
 */
",1,[@NonNull],[@NonNull],0,,,,0,0,0,0,0,None. The implementation and annotation of the API are the same between the two versions.,None. The API has not undergone any changes that could potentially result in different behaviors.
37,<android.app.Activity: void onLowMemory()>,32,33,,,,"{
    if (DEBUG_LIFECYCLE)
        Slog.v(TAG, ""onLowMemory "" + this);
    mCalled = true;
    mFragments.dispatchLowMemory();
}","{
    if (DEBUG_LIFECYCLE)
        Slog.v(TAG, ""onLowMemory "" + this);
    mCalled = true;
    mFragments.dispatchLowMemory();
    if (mCallbacksController != null) {
        mCallbacksController.dispatchLowMemory();
    }
}",1,,,0,,,0,,,,"1,2","3,4",0,4,0,"A new statement `if (mCallbacksController != null) { mCallbacksController.dispatchLowMemory(); }` has been introduced in the late version. This new statement is not related to a return statement, exception handling statement, or control dependency change, so it falls under the category ""Other statement changed"".","The new statement only introduces an additional method call that does not modify the behavior of the API in terms of return values or exception handling. Therefore, this change does not lead to a Compatibility Issue."
38,"<android.hardware.camera2.params.OutputConfiguration: void writeToParcel(Parcel,int)>",32,33,,,,"{
    if (dest == null) {
        throw new IllegalArgumentException(""dest must not be null"");
    }
    dest.writeInt(mRotation);
    dest.writeInt(mSurfaceGroupId);
    dest.writeInt(mSurfaceType);
    dest.writeInt(mConfiguredSize.getWidth());
    dest.writeInt(mConfiguredSize.getHeight());
    dest.writeInt(mIsDeferredConfig ? 1 : 0);
    dest.writeInt(mIsShared ? 1 : 0);
    dest.writeTypedList(mSurfaces);
    dest.writeString(mPhysicalCameraId);
    dest.writeInt(mIsMultiResolution ? 1 : 0);
    // writeList doesn't seem to work well with Integer list.
    dest.writeIntArray(convertIntegerToIntList(mSensorPixelModesUsed));
}","{
    if (dest == null) {
        throw new IllegalArgumentException(""dest must not be null"");
    }
    dest.writeInt(mRotation);
    dest.writeInt(mSurfaceGroupId);
    dest.writeInt(mSurfaceType);
    dest.writeInt(mConfiguredSize.getWidth());
    dest.writeInt(mConfiguredSize.getHeight());
    dest.writeInt(mIsDeferredConfig ? 1 : 0);
    dest.writeInt(mIsShared ? 1 : 0);
    dest.writeTypedList(mSurfaces);
    dest.writeString(mPhysicalCameraId);
    dest.writeInt(mIsMultiResolution ? 1 : 0);
    // writeList doesn't seem to work well with Integer list.
    dest.writeIntArray(convertIntegerToIntList(mSensorPixelModesUsed));
    dest.writeLong(mDynamicRangeProfile);
    dest.writeLong(mStreamUseCase);
    dest.writeInt(mTimestampBase);
    dest.writeInt(mMirrorMode);
}",1,,,0,[@Override],[@Override],0,,,,"1,2",4,0,4,0,"In the late version, there are 4 new statements added to the implementation of the writeToParcel method. These statements are related to writing additional data to the Parcel object.","As the added statements in the late version are only writing additional data to the Parcel object and there is no change in the existing statements, this change does not lead to any Compatibility Issue. The API still returns the same value and does not throw any new exception differently. Therefore, the CI type is 0."
39,<android.os.BaseBundle: ArrayList<Integer> getIntegerArrayList(String)>,32,33,,,,"{
    unparcel();
    Object o = mMap.get(key);
    if (o == null) {
        return null;
    }
    try {
        return (ArrayList<Integer>) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, ""ArrayList<Integer>"", e);
        return null;
    }
}","{
    return getArrayList(key, Integer.class);
}",1,"/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return an ArrayList<String> value, or null
 */
","/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return an ArrayList<String> value, or null
 */
",0,[@Nullable],[@Nullable],0,,,,"1,2","1,2,3,4,5","1,2","1,5",1,"The return statement has changed from casting an Object to ArrayList<Integer> to calling another method (getArrayList) with different parameters, so the code change type is 1,5.","The change of return statement will make the API potentially return a different value, so the CI type is 1."
41,<android.service.dreams.DreamService: void onDreamingStarted()>,32,33,,,,"{
    if (mDebug)
        Slog.v(TAG, ""onDreamingStarted()"");
// hook for subclasses
}","{
    if (mDebug)
        Slog.v(mTag, ""onDreamingStarted()"");
// hook for subclasses
}",1,"/**
 * Called when the dream's window has been created and is visible and animation may now begin.
 */
","/**
 * Called when the dream's window has been created and is visible and animation may now begin.
 */
",0,,,0,,,,1,4,0,4,0,"The change is only in the log statement, where the variable `TAG` is replaced with `mTag`. This is not a control dependency change, return statement change, exception handling change, or dependent API change. Therefore, it can be classified as ""Other statement changed"".","The change in log statement does not affect the behavior of the API, and it will not lead to different return values or exceptions. Therefore, there is no Compatibility Issue."
42,<android.os.PowerComponents.Builder: double getTotalPower()>,32,33,,,,"{
    double totalPowerMah = 0;
    for (int i = mPowerComponentsMah.length - 1; i >= 0; i--) {
        totalPowerMah += mPowerComponentsMah[i];
    }
    return totalPowerMah;
}","{
    double totalPowerMah = 0;
    for (int componentId = 0; componentId < BatteryConsumer.POWER_COMPONENT_COUNT; componentId++) {
        totalPowerMah += mData.getDouble(mData.getKeyOrThrow(componentId, PROCESS_STATE_ANY).mPowerColumnIndex);
    }
    for (int i = 0; i < mData.layout.customPowerComponentCount; i++) {
        totalPowerMah += mData.getDouble(mData.layout.firstCustomConsumedPowerColumn + i);
    }
    return totalPowerMah;
}",1,"/**
 * Returns the total power accumulated by this builder so far. It may change
 * by the time the {@code build()} method is called.
 */
","/**
 * Returns the total power accumulated by this builder so far. It may change
 * by the time the {@code build()} method is called.
 */
",0,,,0,,,,"1,2","1,3,4",1,"1,3",1,"The code change between the two versions is mainly in the 'for' loop statement, the original implementation loops over the 'mPowerComponentsMah' array to accumulate the total power consumption, while the new implementation loops over the 'mData' object to accumulate the total power consumption. The return statement remains the same.","The new implementation might lead to a different total power consumption value compared with the older version. The new implementation might take into account more power components or different power components than the older version. Thus, this change could potentially cause the API to return different values, which is a compatibility issue."
43,<android.hardware.camera2.CameraDevice: void createExtensionSession(ExtensionSessionConfiguration)>,32,33,,,,"{
    throw new UnsupportedOperationException(""No default implementation"");
}","{
    throw new UnsupportedOperationException(""No default implementation"");
}",0,"/**
 * Initialize a specific device-specific extension augmented camera capture
 * session.
 *
 * <p>Extension sessions can be used to enable device-specific operation modes like
 * {@link CameraExtensionCharacteristics#EXTENSION_NIGHT} or
 * {@link CameraExtensionCharacteristics#EXTENSION_HDR}. These modes are less flexible than the
 * full camera API, but enable access to more sophisticated processing algorithms that can
 * capture multi-frame bursts to generate single output images. To query for available
 * extensions on this device call
 * {@link CameraExtensionCharacteristics#getSupportedExtensions()}.</p>
 *
 * <p>This method will also trigger the setup of the internal
 * processing pipeline for extension augmented preview and multi-frame
 * still capture.</p>
 *
 * <p>If a prior CameraCaptureSession already exists when this method is called, the previous
 * session will no longer be able to accept new capture requests and will be closed. Any
 * in-progress capture requests made on the prior session will be completed before it's closed.
 * </p>
 *
 * <p>The CameraExtensionSession will be active until the client
 * either calls CameraExtensionSession.close() or creates a new camera
 * capture session. In both cases all internal resources will be
 * released, continuous repeating requests stopped and any pending
 * multi-frame capture requests flushed.</p>
 *
 * <p>Note that the CameraExtensionSession currently supports at most wo
 * multi frame capture surface formats: ImageFormat.JPEG will be supported
 * by all extensions and ImageFormat.YUV_420_888 may or may not be supported.
 * Clients must query the multi-frame capture format support using
 * {@link CameraExtensionCharacteristics#getExtensionSupportedSizes(int, int)}.
 * For repeating requests CameraExtensionSession supports only
 * {@link android.graphics.SurfaceTexture} as output. Clients can query the supported resolution
 * for the repeating request output using
 * {@link CameraExtensionCharacteristics#getExtensionSupportedSizes(int, Class)
 * getExtensionSupportedSizes(..., Class)}.</p>
 *
 * <p>At the very minimum the initialization expects either one valid output
 * surface for repeating or one valid output for high-quality single requests registered in the
 * outputs argument of the extension configuration argument. At the maximum the initialization
 * will accept two valid output surfaces, one for repeating and the other for single requests.
 * Additional unsupported surfaces passed to ExtensionSessionConfiguration will cause an
 * {@link IllegalArgumentException} to be thrown.</p>
 *
 * @param extensionConfiguration extension configuration
 * @throws IllegalArgumentException If both the preview and still
 * capture surfaces are not set or invalid, or if any of the
 * registered surfaces do not meet the device-specific
 * extension requirements such as dimensions and/or
 * (output format)/(surface type), or if the extension is not
 * supported.
 * @see CameraExtensionCharacteristics#getSupportedExtensions
 * @see CameraExtensionCharacteristics#getExtensionSupportedSizes
 */
","/**
 * Initialize a specific device-specific extension augmented camera capture
 * session.
 *
 * <p>Extension sessions can be used to enable device-specific operation modes like
 * {@link CameraExtensionCharacteristics#EXTENSION_NIGHT} or
 * {@link CameraExtensionCharacteristics#EXTENSION_HDR}. These modes are less flexible than the
 * full camera API, but enable access to more sophisticated processing algorithms that can
 * capture multi-frame bursts to generate single output images. To query for available
 * extensions on this device call
 * {@link CameraExtensionCharacteristics#getSupportedExtensions()}.</p>
 *
 * <p>This method will also trigger the setup of the internal
 * processing pipeline for extension augmented preview and multi-frame
 * still capture.</p>
 *
 * <p>If a prior CameraCaptureSession already exists when this method is called, the previous
 * session will no longer be able to accept new capture requests and will be closed. Any
 * in-progress capture requests made on the prior session will be completed before it's closed.
 * </p>
 *
 * <p>The CameraExtensionSession will be active until the client
 * either calls CameraExtensionSession.close() or creates a new camera
 * capture session. In both cases all internal resources will be
 * released, continuous repeating requests stopped and any pending
 * multi-frame capture requests flushed.</p>
 *
 * <p>Note that the CameraExtensionSession currently supports at most wo
 * multi frame capture surface formats: ImageFormat.JPEG will be supported
 * by all extensions and ImageFormat.YUV_420_888 may or may not be supported.
 * Clients must query the multi-frame capture format support using
 * {@link CameraExtensionCharacteristics#getExtensionSupportedSizes(int, int)}.
 * For repeating requests CameraExtensionSession supports only
 * {@link android.graphics.SurfaceTexture} as output. Clients can query the supported resolution
 * for the repeating request output using
 * {@link CameraExtensionCharacteristics#getExtensionSupportedSizes(int, Class)
 * getExtensionSupportedSizes(..., Class)}.</p>
 *
 * <p>At the very minimum the initialization expects either one valid output
 * surface for repeating or one valid output for high-quality single requests registered in the
 * outputs argument of the extension configuration argument. At the maximum the initialization
 * will accept two valid output surfaces, one for repeating and the other for single requests.
 * Additional unsupported surfaces passed to ExtensionSessionConfiguration will cause an
 * {@link IllegalArgumentException} to be thrown.</p>
 *
 * @param extensionConfiguration extension configuration
 * @throws IllegalArgumentException If both the preview and still
 * capture surfaces are not set or invalid, or if any of the
 * registered surfaces do not meet the device-specific
 * extension requirements such as dimensions and/or
 * (output format)/(surface type), or if the extension is not
 * supported, or if any of the output configurations select
 * a dynamic range different from
 * {@link android.hardware.camera2.params.DynamicRangeProfiles#STANDARD},
 * or if any of the output configurations sets a stream use
 * case different from {@link
 * android.hardware.camera2.CameraCharacteristics#SCALER_AVAILABLE_STREAM_USE_CASES_DEFAULT}.
 * @see CameraExtensionCharacteristics#getSupportedExtensions
 * @see CameraExtensionCharacteristics#getExtensionSupportedSizes
 */
",1,,,0,,,,0,0,0,0,0,No changes were found between the two versions of the API.,"Since there are no changes between the two versions of the API, there is no compatibility issue."
44,"<android.text.TextShaper: void shapeText(CharSequence,int,int,TextDirectionHeuristic,TextPaint,GlyphsConsumer)>",32,33,,,,"{
    MeasuredParagraph mp = MeasuredParagraph.buildForBidi(text, start, start + count, dir, null);
    TextLine tl = TextLine.obtain();
    try {
        tl.set(paint, text, start, start + count, mp.getParagraphDir(), mp.getDirections(0, count), false, /* tabstop is not supported */
        null, // ellipsis is not supported.
        -1, // ellipsis is not supported.
        -1);
        tl.shape(consumer);
    } finally {
        TextLine.recycle(tl);
    }
}","{
    MeasuredParagraph mp = MeasuredParagraph.buildForBidi(text, start, start + count, dir, null);
    TextLine tl = TextLine.obtain();
    try {
        tl.set(paint, text, start, start + count, mp.getParagraphDir(), mp.getDirections(0, count), false, /* tabstop is not supported */
        null, // ellipsis is not supported.
        -1, // ellipsis is not supported.
        -1, false);
        tl.shape(consumer);
    } finally {
        TextLine.recycle(tl);
    }
}",1,"/**
 * Shape multi-styled text.
 *
 * In the LTR context, the shape result will go from left to right, thus you may want to draw
 * glyphs from left most position of the canvas. In the RTL context, the shape result will go
 * from right to left, thus you may want to draw glyphs from right most position of the canvas.
 *
 * @param text a styled text.
 * @param start a start index of shaping target in the text.
 * @param count a length of shaping target in the text.
 * @param dir a text direction.
 * @param paint a paint
 * @param consumer a consumer of the shape result.
 */
","/**
 * Shape multi-styled text.
 *
 * In the LTR context, the shape result will go from left to right, thus you may want to draw
 * glyphs from left most position of the canvas. In the RTL context, the shape result will go
 * from right to left, thus you may want to draw glyphs from right most position of the canvas.
 *
 * @param text a styled text.
 * @param start a start index of shaping target in the text.
 * @param count a length of shaping target in the text.
 * @param dir a text direction.
 * @param paint a paint
 * @param consumer a consumer of the shape result.
 */
",0,,,0,,,,2,5,0,5,1,"The code change is a dependent API change. In the late version, a new boolean argument is added to the `tl.set()` method.","The new boolean argument in the `tl.set()` method may cause the method to behave differently, leading to potential compatibility issues. Therefore, the CI type is 1."
45,<android.app.admin.DevicePolicyManager: List<ApnSetting> getOverrideApns(ComponentName)>,32,33,,,,"{
    throwIfParentInstance(""getOverrideApns"");
    if (mService != null) {
        try {
            return mService.getOverrideApns(admin);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return Collections.emptyList();
}","{
    throwIfParentInstance(""getOverrideApns"");
    if (mService != null) {
        try {
            return mService.getOverrideApns(admin);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return Collections.emptyList();
}",0,"/**
 * Called by device owner to get all override APNs inserted by device owner.
 *
 * @param admin which {@link DeviceAdminReceiver} this request is associated with
 * @return A list of override APNs inserted by device owner.
 * @throws SecurityException if {@code admin} is not a device owner.
 *
 * @see #setOverrideApnsEnabled(ComponentName, boolean)
 */
","/**
 * Called by device owner or managed profile owner to get all override APNs inserted by
 * device owner or managed profile owner previously using {@link #addOverrideApn}.
 *
 * @param admin which {@link DeviceAdminReceiver} this request is associated with
 * @return A list of override APNs inserted by device owner.
 * @throws SecurityException if {@code admin} is not a device owner.
 *
 * @see #setOverrideApnsEnabled(ComponentName, boolean)
 */
",1,,,0,,,,0,0,0,0,0,There is no change in the code between the early and late versions.,"The code remains the same, so there is no compatibility issue."
46,<android.app.admin.DevicePolicyManager: boolean isPreferentialNetworkServiceEnabled()>,32,33,,,,"{
    throwIfParentInstance(""isPreferentialNetworkServiceEnabled"");
    if (mService == null) {
        return false;
    }
    try {
        return mService.isPreferentialNetworkServiceEnabled(myUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    throwIfParentInstance(""isPreferentialNetworkServiceEnabled"");
    return getPreferentialNetworkServiceConfigs().stream().anyMatch(c -> c.isEnabled());
}",1,"/**
 * Indicates whether preferential network service is enabled.
 *
 * <p>This method can be called by the profile owner of a managed profile.
 *
 * @return whether preferential network service is enabled.
 * @throws SecurityException if the caller is not the profile owner.
 */
","/**
 * Indicates whether preferential network service is enabled.
 *
 * <p> Before Android version {@link android.os.Build.VERSION_CODES#TIRAMISU}:
 * This method can be called by the profile owner of a managed profile.
 * <p> Starting from Android version {@link android.os.Build.VERSION_CODES#TIRAMISU}:
 * This method can be called by the profile owner of a managed profile
 * or device owner.
 *
 * @return whether preferential network service is enabled.
 * @throws SecurityException if the caller is not the profile owner or device owner.
 */
",1,,,0,,,,"1,2","1,2,3,4","1,2","1,5",1,"The return statement has changed from returning the value of mService.isPreferentialNetworkServiceEnabled(myUserId()) to returning the value of the lambda expression which uses the stream() method to check if any preferential network service configuration is enabled. Also, the implementation of the API now relies on the getPreferentialNetworkServiceConfigs() method, which is a dependent API change. Thus, the code change type is 1,5.","The change of return statement and dependent API can make the API potentially return a different value, so the CI type is 1."
47,"<android.service.autofill.Dataset.Builder: Builder setValue(AutofillId,AutofillValue,RemoteViews,InlinePresentation)>",32,33,,,,"{
    throwIfDestroyed();
    Preconditions.checkNotNull(presentation, ""presentation cannot be null"");
    Preconditions.checkNotNull(inlinePresentation, ""inlinePresentation cannot be null"");
    setLifeTheUniverseAndEverything(id, value, presentation, inlinePresentation, null);
    return this;
}","{
    throwIfDestroyed();
    Objects.requireNonNull(presentation, ""presentation cannot be null"");
    Objects.requireNonNull(inlinePresentation, ""inlinePresentation cannot be null"");
    setLifeTheUniverseAndEverything(id, value, presentation, inlinePresentation, null, null, null);
    return this;
}",1,"/**
 * Sets the value of a field, using a custom {@link RemoteViews presentation} to
 * visualize it and an {@link InlinePresentation} to visualize it as an inline suggestion.
 *
 * <p><b>Note:</b> If the dataset requires authentication but the service knows its text
 * value it's easier to filter by calling
 * {@link #setValue(AutofillId, AutofillValue, RemoteViews)} and using the value to filter.
 *
 * @param id id returned by {@link
 * android.app.assist.AssistStructure.ViewNode#getAutofillId()}.
 * @param value the value to be autofilled. Pass {@code null} if you do not have the value
 * but the target view is a logical part of the dataset. For example, if
 * the dataset needs authentication and you have no access to the value.
 * @param presentation the presentation used to visualize this field.
 * @param inlinePresentation The {@link InlinePresentation} used to visualize this dataset
 * as inline suggestions. If the dataset supports inline suggestions,
 * this should not be null.
 *
 * @throws IllegalStateException if {@link #build()} was already called.
 *
 * @return this builder.
 */
","/**
 * Sets the value of a field, using a custom {@link RemoteViews presentation} to
 * visualize it and an {@link InlinePresentation} to visualize it as an inline suggestion.
 *
 * <p><b>Note:</b> If the dataset requires authentication but the service knows its text
 * value it's easier to filter by calling
 * {@link #setValue(AutofillId, AutofillValue, RemoteViews)} and using the value to filter.
 *
 * @param id id returned by {@link
 * android.app.assist.AssistStructure.ViewNode#getAutofillId()}.
 * @param value the value to be autofilled. Pass {@code null} if you do not have the value
 * but the target view is a logical part of the dataset. For example, if
 * the dataset needs authentication and you have no access to the value.
 * @param presentation the presentation used to visualize this field.
 * @param inlinePresentation The {@link InlinePresentation} used to visualize this dataset
 * as inline suggestions. If the dataset supports inline suggestions,
 * this should not be null.
 *
 * @throws IllegalStateException if {@link #build()} was already called.
 *
 * @return this builder.
 * @deprecated Use {@link #setField(AutofillId, Field)} instead.
 */
",1,[@NonNull],"[@Deprecated, @NonNull]",1,,,,2,"1,5",1,5,0,"The implementation of the method has changed from using `Preconditions.checkNotNull` to using `Objects.requireNonNull`. Also, the dependent API `setLifeTheUniverseAndEverything` has undergone changes in the method signature by adding three new parameters. Therefore, the code change type is 5.","Although the implementation of the method has changed, the behavior of the API remains the same. The added parameters in the dependent API do not affect the behavior of the current API. Therefore, there is no Compatibility Issue."
48,"<android.widget.RemoteViews.ViewGroupActionAdd: void apply(View,ViewGroup,InteractionHandler,ColorResources)>",32,33,,,,"{
    final Context context = root.getContext();
    final ViewGroup target = root.findViewById(viewId);
    if (target == null) {
        return;
    }
    // If removeAllViews was called, this returns the next potential recycled view.
    // If there are no more views to recycle (or removeAllViews was not called), this
    // will return -1.
    final int nextChild = getNextRecyclableChild(target);
    RemoteViews rvToApply = mNestedViews.getRemoteViewsToApply(context);
    if (nextChild >= 0 && mStableId != NO_ID) {
        // At that point, the views starting at index nextChild are the ones recyclable but
        // not yet recycled. All views added on that round of application are placed before.
        // Find the next view with the same stable id, or -1.
        int recycledViewIndex = findViewIndexToRecycle(target, rvToApply);
        if (recycledViewIndex >= 0) {
            View child = target.getChildAt(recycledViewIndex);
            if (rvToApply.canRecycleView(child)) {
                if (nextChild < recycledViewIndex) {
                    target.removeViews(nextChild, recycledViewIndex - nextChild);
                }
                setNextRecyclableChild(target, nextChild + 1, target.getChildCount());
                rvToApply.reapply(context, child, handler, null, /* size */
                colorResources, false);
                return;
            }
            // If we cannot recycle the views, we still remove all views in between to
            // avoid weird behaviors and insert the new view in place of the old one.
            target.removeViews(nextChild, recycledViewIndex - nextChild + 1);
        }
    }
    // If we cannot recycle, insert the new view before the next recyclable child.
    // Inflate nested views and add as children
    View nestedView = rvToApply.apply(context, target, handler, null, /* size */
    colorResources);
    if (mStableId != NO_ID) {
        setStableId(nestedView, mStableId);
    }
    target.addView(nestedView, mIndex >= 0 ? mIndex : nextChild);
    if (nextChild >= 0) {
        // If we are at the end, there is no reason to try to recycle anymore
        setNextRecyclableChild(target, nextChild + 1, target.getChildCount());
    }
}","{
    final Context context = root.getContext();
    final ViewGroup target = root.findViewById(viewId);
    if (target == null) {
        return;
    }
    // If removeAllViews was called, this returns the next potential recycled view.
    // If there are no more views to recycle (or removeAllViews was not called), this
    // will return -1.
    final int nextChild = getNextRecyclableChild(target);
    RemoteViews rvToApply = mNestedViews.getRemoteViewsToApply(context);
    int flagsToPropagate = mApplyFlags & FLAG_MASK_TO_PROPAGATE;
    if (flagsToPropagate != 0)
        rvToApply.addFlags(flagsToPropagate);
    if (nextChild >= 0 && mStableId != NO_ID) {
        // At that point, the views starting at index nextChild are the ones recyclable but
        // not yet recycled. All views added on that round of application are placed before.
        // Find the next view with the same stable id, or -1.
        int recycledViewIndex = findViewIndexToRecycle(target, rvToApply);
        if (recycledViewIndex >= 0) {
            View child = target.getChildAt(recycledViewIndex);
            if (rvToApply.canRecycleView(child)) {
                if (nextChild < recycledViewIndex) {
                    target.removeViews(nextChild, recycledViewIndex - nextChild);
                }
                setNextRecyclableChild(target, nextChild + 1, target.getChildCount());
                rvToApply.reapplyNestedViews(context, child, rootParent, handler, null, /* size */
                colorResources);
                return;
            }
            // If we cannot recycle the views, we still remove all views in between to
            // avoid weird behaviors and insert the new view in place of the old one.
            target.removeViews(nextChild, recycledViewIndex - nextChild + 1);
        }
    }
    // If we cannot recycle, insert the new view before the next recyclable child.
    // Inflate nested views and add as children
    View nestedView = rvToApply.applyNestedViews(context, target, rootParent, handler, null, /* size */
    colorResources);
    if (mStableId != NO_ID) {
        setStableId(nestedView, mStableId);
    }
    target.addView(nestedView, mIndex >= 0 ? mIndex : nextChild);
    if (nextChild >= 0) {
        // If we are at the end, there is no reason to try to recycle anymore
        setNextRecyclableChild(target, nextChild + 1, target.getChildCount());
    }
}",1,,,0,[@Override],[@Override],0,,,,"1,2","3,4,5",1,5,1,"The API implementation has been changed as the method name of the dependent API has been modified from ""apply"" to ""applyNestedViews"" and ""reapply"" to ""reapplyNestedViews"". Also, the new statement ""int flagsToPropagate = mApplyFlags & FLAG\_MASK\_TO\_PROPAGATE; if (flagsToPropagate != 0) rvToApply.addFlags(flagsToPropagate);"" has been introduced. So the code change type is 5.","As the dependent API has been changed, the behavior of the API between the two versions could be different. Therefore, the API may return a different value or variable type, which leads to a compatibility issue (CI type 1)."
49,<android.view.contentcapture.ContentCaptureSession: void notifyViewDisappeared(AutofillId)>,32,33,,,,"{
    Preconditions.checkNotNull(id);
    if (!isContentCaptureEnabled())
        return;
    internalNotifyViewDisappeared(id);
}","{
    Objects.requireNonNull(id);
    if (!isContentCaptureEnabled())
        return;
    internalNotifyViewDisappeared(id);
}",1,"/**
 * Notifies the Content Capture Service that a node has been removed from the view structure.
 *
 * <p>Typically called ""manually"" by views that handle their own virtual view hierarchy, or
 * automatically by the Android System for standard views.
 *
 * @param id id of the node that has been removed.
 */
","/**
 * Notifies the Content Capture Service that a node has been removed from the view structure.
 *
 * <p>Typically called ""manually"" by views that handle their own virtual view hierarchy, or
 * automatically by the Android System for standard views.
 *
 * @param id id of the node that has been removed.
 */
",0,,,0,,,,2,5,0,4,0,"The method of checking the argument `id` for null has changed from `Preconditions.checkNotNull(id)` to `Objects.requireNonNull(id)`. This is not a return statement, exception handling statement, or control dependency change, so it falls under ""Other statement changed"" (category 4).","Although the method of checking for null has changed, the behavior remains the same. The method will still throw a `NullPointerException` if `id` is null, so there is no potential for different return values or exception handling. Therefore, there is no Compatibility Issue (category 0)."
50,"<android.webkit.WebView: String[] getHttpAuthUsernamePassword(String,String)>",27,28,,,,"{
    checkThread();
    return mProvider.getHttpAuthUsernamePassword(host, realm);
}","{
    checkThread();
    return mProvider.getHttpAuthUsernamePassword(host, realm);
}",0,"/**
 * Retrieves HTTP authentication credentials for a given host and realm from the {@link
 * WebViewDatabase} instance.
 * @param host the host to which the credentials apply
 * @param realm the realm to which the credentials apply
 * @return the credentials as a String array, if found. The first element
 * is the username and the second element is the password. Null if
 * no credentials are found.
 * @deprecated Use {@link WebViewDatabase#getHttpAuthUsernamePassword} instead
 */
","/**
 * Retrieves HTTP authentication credentials for a given host and realm from the {@link
 * WebViewDatabase} instance.
 * @param host the host to which the credentials apply
 * @param realm the realm to which the credentials apply
 * @return the credentials as a String array, if found. The first element
 * is the username and the second element is the password. {@code null} if
 * no credentials are found.
 * @deprecated Use {@link WebViewDatabase#getHttpAuthUsernamePassword} instead
 */
",1,[@Deprecated],"[@Deprecated, @Nullable]",1,,,,0,0,0,4,1,"The annotation of the method has changed, with the addition of `@Nullable` annotation in the late version.","The change in annotation could potentially lead to different behaviours as the return value of the method could be null in the late version, while in the early version, there is no such indication. This could cause a compatibility issue if the callers are not expecting a null value to be returned."
51,<android.widget.TextView: void setText(int)>,27,28,,,,"{
    setText(getContext().getResources().getText(resid));
    mTextFromResource = true;
}","{
    setText(getContext().getResources().getText(resid));
    mTextSetFromXmlOrResourceId = true;
    mTextId = resid;
}",1,"/**
 * Sets the text to be displayed using a string resource identifier.
 *
 * @param resid the resource identifier of the string resource to be displayed
 *
 * @see #setText(CharSequence)
 *
 * @attr ref android.R.styleable#TextView_text
 */
","/**
 * Sets the text to be displayed using a string resource identifier.
 *
 * @param resid the resource identifier of the string resource to be displayed
 *
 * @see #setText(CharSequence)
 *
 * @attr ref android.R.styleable#TextView_text
 */
",0,[@android.view.RemotableViewMethod],[@android.view.RemotableViewMethod],0,,,,1,4,1,"4,5",1,"The variable that is set to true has changed from `mTextFromResource` to `mTextSetFromXmlOrResourceId`, and a new statement `mTextId = resid;` has been introduced. This change does not belong to return statement change, exception handling statement change, or control dependency change, so it is classified as other statement changed (4). Meanwhile, the dependent API `setText(int)` has been changed in a way that it relies on a new variable `mTextId`, so it is classified as dependent API changed (5).","The change of variable that is set to true may affect the behavior of the API, as it may lead to different values being returned or used in later code. Additionally, the introduction of the new variable `mTextId` may also affect the behavior of dependent APIs that rely on it. Therefore, this change may cause a compatibility issue (1)."
52,<android.view.inputmethod.InputMethodManager: boolean switchToLastInputMethod(IBinder)>,27,28,,,,"{
    synchronized (mH) {
        try {
            return mService.switchToLastInputMethod(imeToken);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}","{
    return switchToPreviousInputMethodInternal(imeToken);
}",1,"/**
 * Force switch to the last used input method and subtype. If the last input method didn't have
 * any subtypes, the framework will simply switch to the last input method with no subtype
 * specified.
 * @param imeToken Supplies the identifying token given to an input method when it was started,
 * which allows it to perform this operation on itself.
 * @return true if the current input method and subtype was successfully switched to the last
 * used input method and subtype.
 */
","/**
 * Force switch to the last used input method and subtype. If the last input method didn't have
 * any subtypes, the framework will simply switch to the last input method with no subtype
 * specified.
 * @param imeToken Supplies the identifying token given to an input method when it was started,
 * which allows it to perform this operation on itself.
 * @return true if the current input method and subtype was successfully switched to the last
 * used input method and subtype.
 * @deprecated Use {@link InputMethodService#switchToPreviousInputMethod()} instead. This method
 * was intended for IME developers who should be accessing APIs through the service. APIs in
 * this class are intended for app developers interacting with the IME.
 */
",1,,[@Deprecated],1,,,,"1,2","1,2,5","1,2","1,5",1,"The return statement has changed from calling 'mService.switchToLastInputMethod(imeToken)' to calling a new method 'switchToPreviousInputMethodInternal(imeToken)'. Additionally, the method implementation is now using a different dependent API, so the code change types are 1 and 5.","The change of return statement and dependent API potentially leads to different return values in the late version. Therefore, the CI type is 1."
53,<android.net.IpSecManager.UdpEncapsulationSocket: void close()>,27,28,,,,"{
    try {
        mService.closeUdpEncapsulationSocket(mResourceId);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
    try {
        mPfd.close();
    } catch (IOException e) {
        Log.e(TAG, ""Failed to close UDP Encapsulation Socket with Port= "" + mPort);
        throw e;
    }
    mCloseGuard.close();
}","{
    try {
        mService.closeUdpEncapsulationSocket(mResourceId);
        mResourceId = INVALID_RESOURCE_ID;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    } catch (Exception e) {
        // On close we swallow all random exceptions since failure to close is not
        // actionable by the user.
        Log.e(TAG, ""Failed to close "" + this + "", Exception="" + e);
    } finally {
        mResourceId = INVALID_RESOURCE_ID;
        mCloseGuard.close();
    }
    try {
        mPfd.close();
    } catch (IOException e) {
        Log.e(TAG, ""Failed to close UDP Encapsulation Socket with Port= "" + mPort);
        throw e;
    }
}",1,,"/**
 * Close this socket.
 *
 * <p>This closes the wrapped socket. Open encapsulation sockets count against a user's
 * resource limits, and forgetting to close them eventually will result in {@link
 * ResourceUnavailableException} being thrown.
 */
",1,[@Override],[@Override],0,,,,"1,2","2,4,5",2,"2, 3",2,"The code change between the two versions involves exception handling statement changed and control dependency changed. In the late version, a new exception handling statement is introduced (catch (Exception e)) and the control flow is changed by adding a finally block that resets mResourceId.","A compatibility issue could arise due to the potential different exception handling in the two versions. Specifically, the new exception handling statement (catch (Exception e)) in the late version could catch and swallow an exception that would have been thrown in the early version. This could lead to the API behaving differently and potentially hiding errors."
54,<android.webkit.WebView: WebBackForwardList restoreState(Bundle)>,27,28,,,,"{
    checkThread();
    return mProvider.restoreState(inState);
}","{
    checkThread();
    return mProvider.restoreState(inState);
}",0,"/**
 * Restores the state of this WebView from the given Bundle. This method is
 * intended for use in {@link android.app.Activity#onRestoreInstanceState}
 * and should be called to restore the state of this WebView. If
 * it is called after this WebView has had a chance to build state (load
 * pages, create a back/forward list, etc.) there may be undesirable
 * side-effects. Please note that this method no longer restores the
 * display data for this WebView.
 *
 * @param inState the incoming Bundle of state
 * @return the restored back/forward list or null if restoreState failed
 */
","/**
 * Restores the state of this WebView from the given Bundle. This method is
 * intended for use in {@link android.app.Activity#onRestoreInstanceState}
 * and should be called to restore the state of this WebView. If
 * it is called after this WebView has had a chance to build state (load
 * pages, create a back/forward list, etc.) there may be undesirable
 * side-effects. Please note that this method no longer restores the
 * display data for this WebView.
 *
 * @param inState the incoming Bundle of state
 * @return the restored back/forward list or {@code null} if restoreState failed
 */
",1,,[@Nullable],1,,,,0,0,0,0,0,There is no difference between the early version and late version of the `WebView.restoreState` API.,"As the implementation of the `WebView.restoreState` API remains the same, there is no compatibility issue that may arise."
55,<android.widget.TextView: void setElegantTextHeight(boolean)>,27,28,,,,"{
    if (elegant != mTextPaint.isElegantTextHeight()) {
        mTextPaint.setElegantTextHeight(elegant);
        if (mLayout != null) {
            nullLayouts();
            requestLayout();
            invalidate();
        }
    }
}","{
    if (elegant != mTextPaint.isElegantTextHeight()) {
        mTextPaint.setElegantTextHeight(elegant);
        if (mLayout != null) {
            nullLayouts();
            requestLayout();
            invalidate();
        }
    }
}",0,"/**
 * Set the TextView's elegant height metrics flag. This setting selects font
 * variants that have not been compacted to fit Latin-based vertical
 * metrics, and also increases top and bottom bounds to provide more space.
 *
 * @param elegant set the paint's elegant metrics flag.
 *
 * @attr ref android.R.styleable#TextView_elegantTextHeight
 */
","/**
 * Set the TextView's elegant height metrics flag. This setting selects font
 * variants that have not been compacted to fit Latin-based vertical
 * metrics, and also increases top and bottom bounds to provide more space.
 *
 * @param elegant set the paint's elegant metrics flag.
 *
 * @see #isElegantTextHeight()
 * @see Paint#isElegantTextHeight()
 *
 * @attr ref android.R.styleable#TextView_elegantTextHeight
 */
",1,,,0,,,,0,0,0,0,0,There is no change detected between the early and late implementation of the API.,"Since there is no change in the code, it will not lead to different behaviors, thus no Compatibility Issue arises."
56,<android.widget.Toast.TN: void handleHide()>,27,28,,,,"{
    if (localLOGV)
        Log.v(TAG, ""HANDLE HIDE: "" + this + "" mView="" + mView);
    if (mView != null) {
        // the view isn't yet added, so let's try not to crash.
        if (mView.getParent() != null) {
            if (localLOGV)
                Log.v(TAG, ""REMOVE! "" + mView + "" in "" + this);
            mWM.removeViewImmediate(mView);
        }
        mView = null;
    }
}","{
    if (localLOGV)
        Log.v(TAG, ""HANDLE HIDE: "" + this + "" mView="" + mView);
    if (mView != null) {
        // the view isn't yet added, so let's try not to crash.
        if (mView.getParent() != null) {
            if (localLOGV)
                Log.v(TAG, ""REMOVE! "" + mView + "" in "" + this);
            mWM.removeViewImmediate(mView);
        }
        // the resources.
        try {
            getService().finishToken(mPackageName, this);
        } catch (RemoteException e) {
        }
        mView = null;
    }
}",1,,,0,,,0,,,,"1,2","2,4",2,5,1,"The change is in the ""dependent API"" category, as a new API ""getService().finishToken(mPackageName, this)"" is introduced in the late version.","This change can lead to a Compatibility Issue (CI) because the introduced API ""getService().finishToken(mPackageName, this)"" potentially causes the current API to return a different value or throw a different exception. Therefore, the CI type is 1."
57,"<android.provider.Settings.System: boolean putString(ContentResolver,String,String)>",27,28,,,,"{
    return putStringForUser(resolver, name, value, UserHandle.myUserId());
}","{
    return putStringForUser(resolver, name, value, resolver.getUserId());
}",1,"/**
 * Store a name/value pair into the database.
 * @param resolver to access the database with
 * @param name to store
 * @param value to associate with the name
 * @return true if the value was set, false on database errors
 */
","/**
 * Store a name/value pair into the database.
 * @param resolver to access the database with
 * @param name to store
 * @param value to associate with the name
 * @return true if the value was set, false on database errors
 */
",0,,,0,,,,"1,2","1,5",1,5,1,"The only change between the two versions is that the user ID used in the `putStringForUser` method call has been changed from `UserHandle.myUserId()` to `resolver.getUserId()`, which means that the user ID is now obtained from the `ContentResolver` object instead of the current user handle.","This change could cause a compatibility issue if the user ID obtained from the `ContentResolver` object is different from the current user handle. In that case, the string value may be stored for a different user, resulting in unexpected behavior and potentially leading to data corruption. Therefore, this is a compatibility issue caused by potential different return values or types (class 1)."
58,"<android.webkit.WebChromeClient: void onReceivedTouchIconUrl(WebView,String,boolean)>",27,28,,,,"{
}","{
}",0,"/**
 * Notify the host application of the url for an apple-touch-icon.
 * @param view The WebView that initiated the callback.
 * @param url The icon url.
 * @param precomposed True if the url is for a precomposed touch icon.
 */
","/**
 * Notify the host application of the url for an apple-touch-icon.
 * @param view The WebView that initiated the callback.
 * @param url The icon url.
 * @param precomposed {@code true} if the url is for a precomposed touch icon.
 */
",1,,,0,,,,0,0,0,0,0,The implementation of the method has not changed between the two versions.,"Since there is no change in the implementation, there is no potential compatibility issue."
59,"<android.bluetooth.le.ScanFilter.Builder: Builder setServiceUuid(ParcelUuid,ParcelUuid)>",27,28,,,,"{
    if (mUuidMask != null && mServiceUuid == null) {
        throw new IllegalArgumentException(""uuid is null while uuidMask is not null!"");
    }
    mServiceUuid = serviceUuid;
    mUuidMask = uuidMask;
    return this;
}","{
    if (mUuidMask != null && mServiceUuid == null) {
        throw new IllegalArgumentException(""uuid is null while uuidMask is not null!"");
    }
    mServiceUuid = serviceUuid;
    mUuidMask = uuidMask;
    return this;
}",0,"/**
 * Set filter on partial service uuid. The {@code uuidMask} is the bit mask for the
 * {@code serviceUuid}. Set any bit in the mask to 1 to indicate a match is needed for the
 * bit in {@code serviceUuid}, and 0 to ignore that bit.
 *
 * @throws IllegalArgumentException If {@code serviceUuid} is {@code null} but
 * {@code uuidMask} is not {@code null}.
 */
","/**
 * Set filter on partial service uuid. The {@code uuidMask} is the bit mask for the
 * {@code serviceUuid}. Set any bit in the mask to 1 to indicate a match is needed for the
 * bit in {@code serviceUuid}, and 0 to ignore that bit.
 *
 * @throws IllegalArgumentException If {@code serviceUuid} is {@code null} but {@code
 * uuidMask} is not {@code null}.
 */
",1,,,0,,,,0,0,0,0,0,There are no changes in the code between the early and late versions of the Android API.,"As there are no changes in the code, there will not be any compatibility issues that could arise."
60,"<android.app.usage.NetworkStatsManager: NetworkStats queryDetailsForUid(int,String,long,long,int)>",27,28,,,,"{
    return queryDetailsForUidTag(networkType, subscriberId, startTime, endTime, uid, NetworkStats.Bucket.TAG_NONE);
}","{
    return queryDetailsForUidTagState(networkType, subscriberId, startTime, endTime, uid, NetworkStats.Bucket.TAG_NONE, NetworkStats.Bucket.STATE_ALL);
}",1,"/**
 * Query network usage statistics details for a given uid.
 *
 * #see queryDetailsForUidTag(int, String, long, long, int, int)
 */
","/**
 * Query network usage statistics details for a given uid.
 *
 * #see queryDetailsForUidTagState(int, String, long, long, int, int, int)
 */
",1,,,0,,,,"1,2","1,5",1,"1, 5",1,"The return statement has changed, with the late version using the method `queryDetailsForUidTagState` instead of the early version's `queryDetailsForUidTag`. Additionally, the late version includes an additional parameter `NetworkStats.Bucket.STATE_ALL` that is not present in the early version.","The change in the return statement and the additional parameter could cause the API to return different values, potentially leading to a compatibility issue. Therefore, this change is classified as a Compatibility Issue caused by potential different return values or types, with a CI type of 1."
61,<android.net.NetworkStats.Entry: String toString()>,27,28,,,,"{
    final StringBuilder builder = new StringBuilder();
    builder.append(""iface="").append(iface);
    builder.append("" uid="").append(uid);
    builder.append("" set="").append(setToString(set));
    builder.append("" tag="").append(tagToString(tag));
    builder.append("" metered="").append(meteredToString(metered));
    builder.append("" roaming="").append(roamingToString(roaming));
    builder.append("" rxBytes="").append(rxBytes);
    builder.append("" rxPackets="").append(rxPackets);
    builder.append("" txBytes="").append(txBytes);
    builder.append("" txPackets="").append(txPackets);
    builder.append("" operations="").append(operations);
    return builder.toString();
}","{
    final StringBuilder builder = new StringBuilder();
    builder.append(""iface="").append(iface);
    builder.append("" uid="").append(uid);
    builder.append("" set="").append(setToString(set));
    builder.append("" tag="").append(tagToString(tag));
    builder.append("" metered="").append(meteredToString(metered));
    builder.append("" roaming="").append(roamingToString(roaming));
    builder.append("" defaultNetwork="").append(defaultNetworkToString(defaultNetwork));
    builder.append("" rxBytes="").append(rxBytes);
    builder.append("" rxPackets="").append(rxPackets);
    builder.append("" txBytes="").append(txBytes);
    builder.append("" txPackets="").append(txPackets);
    builder.append("" operations="").append(operations);
    return builder.toString();
}",1,,,0,[@Override],[@Override],0,,,,"1,2","1,4",1,4,0,"The implementation of the toString() method in the late version includes an additional attribute ""defaultNetwork="" which is not present in the early version. This is an example of an ""other statement changed"" change type, hence the classification as 4.","The addition of a new attribute in the toString() method does not affect the functionality of the API, it just provides more information. Therefore, this change does not lead to any Compatibility Issues, hence the classification as 0."
62,<android.webkit.WebChromeClient: boolean onConsoleMessage(ConsoleMessage)>,27,28,,,,"{
    // Call the old version of this function for backwards compatability.
    onConsoleMessage(consoleMessage.message(), consoleMessage.lineNumber(), consoleMessage.sourceId());
    return false;
}","{
    // Call the old version of this function for backwards compatability.
    onConsoleMessage(consoleMessage.message(), consoleMessage.lineNumber(), consoleMessage.sourceId());
    return false;
}",0,"/**
 * Report a JavaScript console message to the host application. The ChromeClient
 * should override this to process the log message as they see fit.
 * @param consoleMessage Object containing details of the console message.
 * @return true if the message is handled by the client.
 */
","/**
 * Report a JavaScript console message to the host application. The ChromeClient
 * should override this to process the log message as they see fit.
 * @param consoleMessage Object containing details of the console message.
 * @return {@code true} if the message is handled by the client.
 */
",1,,,0,,,,0,0,0,0,0,There is no change between the early and late implementation of the API.,There is no potential Compatibility Issue as the API's behavior has not changed.
63,"<android.hardware.radio.RadioManager.ModuleProperties: void writeToParcel(Parcel,int)>",26,27,,,,"{
    dest.writeInt(mId);
    dest.writeInt(mClassId);
    dest.writeString(mImplementor);
    dest.writeString(mProduct);
    dest.writeString(mVersion);
    dest.writeString(mSerial);
    dest.writeInt(mNumTuners);
    dest.writeInt(mNumAudioSources);
    dest.writeInt(mIsCaptureSupported ? 1 : 0);
    dest.writeParcelableArray(mBands, flags);
}","{
    dest.writeInt(mId);
    dest.writeString(mServiceName);
    dest.writeInt(mClassId);
    dest.writeString(mImplementor);
    dest.writeString(mProduct);
    dest.writeString(mVersion);
    dest.writeString(mSerial);
    dest.writeInt(mNumTuners);
    dest.writeInt(mNumAudioSources);
    dest.writeInt(mIsCaptureSupported ? 1 : 0);
    dest.writeParcelableArray(mBands, flags);
    dest.writeInt(mIsBgScanSupported ? 1 : 0);
    dest.writeIntArray(setToArray(mSupportedProgramTypes));
    dest.writeIntArray(setToArray(mSupportedIdentifierTypes));
    writeStringMap(dest, mVendorInfo);
}",1,,,0,[@Override],[@Override],0,,,,"1,2","1,4",1,"3,4,5",1,"The implementation of the writeToParcel() method has changed significantly. Specifically, the order of writing some properties has changed (e.g., mClassId and mServiceName), some new properties are added (e.g., mIsBgScanSupported, mSupportedProgramTypes, mSupportedIdentifierTypes, and mVendorInfo), and the writing of mBands has changed from writeParcelableArray() to writeParcelableList(). These changes fall into the categories of control dependency change (3), other statement change (4), and dependent API change (5).","The changes in the way properties are written to the Parcel object could lead to different behaviors when the method is called in different versions. Specifically, the order of writing some properties has changed, and new properties have been added, which could lead to compatibility issues when the Parcel is read in a different version of the code. Therefore, this is a compatibility issue caused by potential different return values or types (1)."
64,<android.app.Notification.Builder: Builder setGroupAlertBehavior(int)>,26,27,,,,"{
    mN.mGroupAlertBehavior = groupAlertBehavior;
    return this;
}","{
    mN.mGroupAlertBehavior = groupAlertBehavior;
    return this;
}",0,"/**
 * Sets the group alert behavior for this notification. Use this method to mute this
 * notification if alerts for this notification's group should be handled by a different
 * notification. This is only applicable for notifications that belong to a
 * {@link #setGroup(String) group}.
 *
 * <p> The default value is {@link #GROUP_ALERT_ALL}.</p>
 */
","/**
 * Sets the group alert behavior for this notification. Use this method to mute this
 * notification if alerts for this notification's group should be handled by a different
 * notification. This is only applicable for notifications that belong to a
 * {@link #setGroup(String) group}. This must be called on all notifications you want to
 * mute. For example, if you want only the summary of your group to make noise, all
 * children in the group should have the group alert behavior {@link #GROUP_ALERT_SUMMARY}.
 *
 * <p> The default value is {@link #GROUP_ALERT_ALL}.</p>
 */
",1,,,0,,,,0,0,0,0,0,"There is no change in the implementation of the API, so the change type is 0.","As there is no change in the implementation of the API, there is no potential for compatibility issues, so the CI type is 0."
65,"<android.app.FragmentManagerImpl: void dispatchOnFragmentPreAttached(Fragment,Context,boolean)>",26,27,,,,"{
    if (mParent != null) {
        FragmentManager parentManager = mParent.getFragmentManager();
        if (parentManager instanceof FragmentManagerImpl) {
            ((FragmentManagerImpl) parentManager).dispatchOnFragmentPreAttached(f, context, true);
        }
    }
    if (mLifecycleCallbacks == null) {
        return;
    }
    for (Pair<FragmentLifecycleCallbacks, Boolean> p : mLifecycleCallbacks) {
        if (!onlyRecursive || p.second) {
            p.first.onFragmentPreAttached(this, f, context);
        }
    }
}","{
    if (mParent != null) {
        FragmentManager parentManager = mParent.getFragmentManager();
        if (parentManager instanceof FragmentManagerImpl) {
            ((FragmentManagerImpl) parentManager).dispatchOnFragmentPreAttached(f, context, true);
        }
    }
    for (Pair<FragmentLifecycleCallbacks, Boolean> p : mLifecycleCallbacks) {
        if (!onlyRecursive || p.second) {
            p.first.onFragmentPreAttached(this, f, context);
        }
    }
}",1,,,0,,,0,,,,1,"1,3",1,3,1,"In the early version, there is an if condition that returns when the mLifecycleCallbacks is null, while it is removed in the late version. Thus, the code change type is control dependency change (type 3).","The removal of the if condition makes the loop in the late version be executed even when mLifecycleCallbacks is null. This could lead to a different behavior of the API and potentially cause a different return value or type, thus the CI type is 1."
66,<android.widget.ArrayAdapter: CharSequence[] getAutofillOptions()>,26,27,,,,"{
    if (!mObjectsFromResources || mObjects == null || mObjects.isEmpty()) {
        return null;
    }
    final int size = mObjects.size();
    final CharSequence[] options = new CharSequence[size];
    mObjects.toArray(options);
    return options;
}","{
    // First check if app developer explicitly set them.
    final CharSequence[] explicitOptions = super.getAutofillOptions();
    if (explicitOptions != null) {
        return explicitOptions;
    }
    // Otherwise, only return options that came from static resources.
    if (!mObjectsFromResources || mObjects == null || mObjects.isEmpty()) {
        return null;
    }
    final int size = mObjects.size();
    final CharSequence[] options = new CharSequence[size];
    mObjects.toArray(options);
    return options;
}",1,"/**
 * {@inheritDoc}
 *
 * @return values from the string array used by {@link #createFromResource(Context, int, int)},
 * or {@code null} if object was created otherwsie or if contents were dynamically changed after
 * creation.
 */
","/**
 * {@inheritDoc}
 *
 * @return values from the string array used by {@link #createFromResource(Context, int, int)},
 * or {@code null} if object was created otherwsie or if contents were dynamically changed after
 * creation.
 */
",0,[@Override],[@Override],0,,,,"1,2","1,3,4",1,"3,5",1,"The implementation of the method has changed, with a new if statement added to the beginning of the method in the later version. The new if statement checks whether the superclass implementation of the method returns any explicit options, and if so, those options are returned instead of the ones generated from the ArrayAdapter's mObjects. This represents a change in control dependency and a change in the dependent API, so the code change is classified as 3 and 5.","This change may cause the method to return different values, depending on whether the superclass implementation of the method returns any explicit options. If the superclass implementation returns explicit options, those options will be returned instead of the ones generated from the ArrayAdapter's mObjects. This represents a compatibility issue caused by potential different return values, so the CI is classified as 1."
67,<android.os.PowerManager.WakeLock: String toString()>,26,27,,,,"{
    synchronized (mToken) {
        return ""WakeLock{"" + Integer.toHexString(System.identityHashCode(this)) + "" held="" + mHeld + "", refCount="" + mCount + ""}"";
    }
}","{
    synchronized (mToken) {
        return ""WakeLock{"" + Integer.toHexString(System.identityHashCode(this)) + "" held="" + mHeld + "", refCount="" + mInternalCount + ""}"";
    }
}",1,,,0,[@Override],[@Override],0,,,,2,"1,5",1,"1,4",1,The implementation of the `toString()` method has changed in the late version. The variable `mCount` used in the early version is replaced by `mInternalCount` in the late version. This change potentially leads to a different string representation of the `WakeLock` object.,"The different string representation of the `WakeLock` object can cause compatibility issues if the string representation is used in a specific way, such as being compared with a pre-defined string or being persisted for future use. The change in the string representation can cause the comparison to fail or the persisted string to become invalid. Therefore, the CI type is 1."
68,<android.service.vr.VrListenerService.VrListenerHandler: void handleMessage(Message)>,26,27,,,,"{
    switch(msg.what) {
        case MSG_ON_CURRENT_VR_ACTIVITY_CHANGED:
            {
                VrListenerService.this.onCurrentVrActivityChanged((ComponentName) msg.obj);
            }
            break;
    }
}","{
    switch(msg.what) {
        case MSG_ON_CURRENT_VR_ACTIVITY_CHANGED:
            {
                VrListenerService.this.onCurrentVrActivityChanged((ComponentName) msg.obj, msg.arg1 == 1, msg.arg2);
            }
            break;
    }
}",1,,,0,[@Override],[@Override],0,,,,2,5,0,"1,5",1,"The onCurrentVrActivityChanged() method has changed from having one parameter in the early version to having three parameters in the late version, so the code change type is 1,5.","As the onCurrentVrActivityChanged() method has changed in the number of parameters, the behaviour of the API could potentially be different in the late version, leading to a different return value or type, therefore the CI type is 1."
69,<android.hardware.usb.UsbConfiguration: String getName()>,25,26,,,,"{
    return mName;
}","{
    return mName;
}",0,"/**
 * Returns the configuration's name.
 *
 * @return the configuration's name
 */
","/**
 * Returns the configuration's name.
 *
 * @return the configuration's name, or {@code null} if the property could not be read
 */
",1,,[@Nullable],1,,,,0,0,0,0,0,"The implementation of the method has not changed, but a nullable annotation has been added in the late version.","As the method implementation has not changed and the nullable annotation does not affect the behavior of the API, there is no compatibility issue."
70,"<android.hardware.usb.UsbDeviceConnection: int bulkTransfer(UsbEndpoint,byte[],int,int)>",25,26,,,,"{
    return bulkTransfer(endpoint, buffer, 0, length, timeout);
}","{
    return bulkTransfer(endpoint, buffer, 0, length, timeout);
}",0,"/**
 * Performs a bulk transaction on the given endpoint.
 * The direction of the transfer is determined by the direction of the endpoint.
 * <p>
 * This method transfers data starting from index 0 in the buffer.
 * To specify a different offset, use
 * {@link #bulkTransfer(UsbEndpoint, byte[], int, int, int)}.
 * </p>
 *
 * @param endpoint the endpoint for this transaction
 * @param buffer buffer for data to send or receive
 * @param length the length of the data to send or receive
 * @param timeout in milliseconds
 * @return length of data transferred (or zero) for success,
 * or negative value for failure
 */
","/**
 * Performs a bulk transaction on the given endpoint.
 * The direction of the transfer is determined by the direction of the endpoint.
 * <p>
 * This method transfers data starting from index 0 in the buffer.
 * To specify a different offset, use
 * {@link #bulkTransfer(UsbEndpoint, byte[], int, int, int)}.
 * </p>
 *
 * @param endpoint the endpoint for this transaction
 * @param buffer buffer for data to send or receive; can be {@code null} to wait for next
 * transaction without reading data
 * @param length the length of the data to send or receive
 * @param timeout in milliseconds, 0 is infinite
 * @return length of data transferred (or zero) for success,
 * or negative value for failure
 */
",1,,,0,,,,0,0,0,0,0,There is no change in the implementation or annotation of the method between the two versions.,No compatibility issue could arise for the API as there is no change in the implementation or annotation of the method between the two versions.
71,<android.app.Fragment: boolean getAllowEnterTransitionOverlap()>,25,26,,,,"{
    return (mAllowEnterTransitionOverlap == null) ? true : mAllowEnterTransitionOverlap;
}","{
    return (mAnimationInfo == null || mAnimationInfo.mAllowEnterTransitionOverlap == null) ? true : mAnimationInfo.mAllowEnterTransitionOverlap;
}",1,"/**
 * Returns whether the the exit transition and enter transition overlap or not.
 * When true, the enter transition will start as soon as possible. When false, the
 * enter transition will wait until the exit transition completes before starting.
 *
 * @return true when the enter transition should start as soon as possible or false to
 * when it should wait until the exiting transition completes.
 * @attr ref android.R.styleable#Fragment_fragmentAllowEnterTransitionOverlap
 */
","/**
 * Returns whether the the exit transition and enter transition overlap or not.
 * When true, the enter transition will start as soon as possible. When false, the
 * enter transition will wait until the exit transition completes before starting.
 *
 * @return true when the enter transition should start as soon as possible or false to
 * when it should wait until the exiting transition completes.
 * @attr ref android.R.styleable#Fragment_fragmentAllowEnterTransitionOverlap
 */
",0,,,0,,,,"1,2","1,5",1,"3, 1",1,"In the late version, the implementation of the method has changed. The return statement has been modified from using the `mAllowEnterTransitionOverlap` field directly to using the `mAllowEnterTransitionOverlap` field inside the `mAnimationInfo` object. Additionally, the condition in the ternary operator has been modified to check if `mAnimationInfo` is null before checking if `mAllowEnterTransitionOverlap` is null. This is a control dependency change as well as a return statement change.","This change can lead to different return values for the method. In the early version, if `mAllowEnterTransitionOverlap` is null, the method returns true. In the late version, if `mAnimationInfo` is null, the method returns true, and if `mAllowEnterTransitionOverlap` is null, the method also returns true. Therefore, there is a potential compatibility issue caused by potential different return values."
72,<android.content.pm.ShortcutManager: boolean setDynamicShortcuts(List<ShortcutInfo>)>,25,26,,,,"{
    try {
        return mService.setDynamicShortcuts(mContext.getPackageName(), new ParceledListSlice(shortcutInfoList), injectMyUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        return mService.setDynamicShortcuts(mContext.getPackageName(), new ParceledListSlice(shortcutInfoList), injectMyUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",0,"/**
 * Publish the list of shortcuts.  All existing dynamic shortcuts from the caller application
 * will be replaced.  If there are already pinned shortcuts with the same IDs,
 * the mutable pinned shortcuts are updated.
 *
 * <p>This API will be rate-limited.
 *
 * @return {@code true} if the call has succeeded. {@code false} if the call is rate-limited.
 *
 * @throws IllegalArgumentException if {@link #getMaxShortcutCountPerActivity()} is exceeded,
 * or when trying to update immutable shortcuts.
 *
 * @throws IllegalStateException when the user is locked.
 */
","/**
 * Publish the list of shortcuts.  All existing dynamic shortcuts from the caller app
 * will be replaced.  If there are already pinned shortcuts with the same IDs,
 * the mutable pinned shortcuts are updated.
 *
 * <p>This API will be rate-limited.
 *
 * @return {@code true} if the call has succeeded. {@code false} if the call is rate-limited.
 *
 * @throws IllegalArgumentException if {@link #getMaxShortcutCountPerActivity()} is exceeded,
 * or when trying to update immutable shortcuts.
 *
 * @throws IllegalStateException when the user is locked.
 */
",1,,,0,,,,0,0,0,0,0,"There is no change in code between two versions, so the code change type is 0.","As there is no change in code, the behaviour of the API will also not change, so the CI type is 0."
73,"<android.app.Activity: void startActivityFromFragment(Fragment,Intent,int,Bundle)>",25,26,,,,"{
    startActivityForResult(fragment.mWho, intent, requestCode, options);
}","{
    startActivityForResult(fragment.mWho, intent, requestCode, options);
}",0,"/**
 * This is called when a Fragment in this activity calls its
 * {@link Fragment#startActivity} or {@link Fragment#startActivityForResult}
 * method.
 *
 * <p>This method throws {@link android.content.ActivityNotFoundException}
 * if there was no Activity found to run the given Intent.
 *
 * @param fragment The fragment making the call.
 * @param intent The intent to start.
 * @param requestCode Reply request code.  < 0 if reply is not requested.
 * @param options Additional options for how the Activity should be started.
 * See {@link android.content.Context#startActivity(Intent, Bundle)
 * Context.startActivity(Intent, Bundle)} for more details.
 *
 * @throws android.content.ActivityNotFoundException
 *
 * @see Fragment#startActivity
 * @see Fragment#startActivityForResult
 */
","/**
 * This is called when a Fragment in this activity calls its
 * {@link Fragment#startActivity} or {@link Fragment#startActivityForResult}
 * method.
 *
 * <p>This method throws {@link android.content.ActivityNotFoundException}
 * if there was no Activity found to run the given Intent.
 *
 * @param fragment The fragment making the call.
 * @param intent The intent to start.
 * @param requestCode Reply request code.  < 0 if reply is not requested.
 * @param options Additional options for how the Activity should be started.
 * See {@link android.content.Context#startActivity(Intent, Bundle)}
 * Context.startActivity(Intent, Bundle)} for more details.
 *
 * @throws android.content.ActivityNotFoundException
 *
 * @see Fragment#startActivity
 * @see Fragment#startActivityForResult
 */
",1,,,0,,,,0,0,0,0,0,There is no change in the method implementation and annotations between the early and late version of the API.,"No change in the method implementation and annotations means that the API is expected to function the same way in both versions, thus there are no Compatibility Issues."
74,<android.app.FragmentManagerImpl: void dispatchDestroy()>,25,26,,,,"{
    mDestroyed = true;
    execPendingActions();
    moveToState(Fragment.INITIALIZING, false);
    mHost = null;
    mContainer = null;
    mParent = null;
}","{
    mDestroyed = true;
    execPendingActions();
    dispatchMoveToState(Fragment.INITIALIZING);
    mHost = null;
    mContainer = null;
    mParent = null;
}",1,,,0,,,0,,,,2,5,1,5,1,"The method 'moveToState' has been changed to 'dispatchMoveToState' in the late version, which indicates that the dependent API has changed.","As the dependent API 'moveToState' has been changed to 'dispatchMoveToState', it could potentially cause the API to return a different value or throw a different exception, leading to a CI."
75,"<android.content.res.ResourcesImpl.ThemeImpl: TypedArray obtainStyledAttributes(Theme,AttributeSet,int[],int,int)>",25,26,,,,"{
    synchronized (mKey) {
        final int len = attrs.length;
        final TypedArray array = TypedArray.obtain(wrapper.getResources(), len);
        // XXX note that for now we only work with compiled XML files.
        // To support generic XML files we will need to manually parse
        // out the attributes from the XML file (applying type information
        // contained in the resources and such).
        final XmlBlock.Parser parser = (XmlBlock.Parser) set;
        AssetManager.applyStyle(mTheme, defStyleAttr, defStyleRes, parser != null ? parser.mParseState : 0, attrs, array.mData, array.mIndices);
        array.mTheme = wrapper;
        array.mXml = parser;
        return array;
    }
}","{
    synchronized (mKey) {
        final int len = attrs.length;
        final TypedArray array = TypedArray.obtain(wrapper.getResources(), len);
        // XXX note that for now we only work with compiled XML files.
        // To support generic XML files we will need to manually parse
        // out the attributes from the XML file (applying type information
        // contained in the resources and such).
        final XmlBlock.Parser parser = (XmlBlock.Parser) set;
        AssetManager.applyStyle(mTheme, defStyleAttr, defStyleRes, parser != null ? parser.mParseState : 0, attrs, attrs.length, array.mDataAddress, array.mIndicesAddress);
        array.mTheme = wrapper;
        array.mXml = parser;
        return array;
    }
}",1,,,0,[@NonNull],[@NonNull],0,,,,2,5,1,5,1,"The AssetManager.applyStyle method in the late version takes two additional arguments, mDataAddress and mIndicesAddress, which are not present in the early version. This is a change of a dependent API.","The change of the dependent API could potentially lead to different behaviors of the obtainStyledAttributes method in the late version, as the new parameters could affect the way the method processes and returns the TypedArray. Therefore, it is a Compatibility Issue caused by potential different return values or types."
76,<android.app.admin.DevicePolicyManager: int getPermissionPolicy(ComponentName)>,25,26,,,,"{
    throwIfParentInstance(""getPermissionPolicy"");
    try {
        return mService.getPermissionPolicy(admin);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}","{
    throwIfParentInstance(""getPermissionPolicy"");
    try {
        return mService.getPermissionPolicy(admin);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}",0,"/**
 * Returns the current runtime permission policy set by the device or profile owner. The
 * default is {@link #PERMISSION_POLICY_PROMPT}.
 * @param admin Which profile or device owner this request is associated with.
 * @return the current policy for future permission requests.
 */
","/**
 * Returns the current runtime permission policy set by the device or profile owner. The
 * default is {@link #PERMISSION_POLICY_PROMPT}.
 *
 * @param admin Which profile or device owner this request is associated with.
 * @return the current policy for future permission requests.
 */
",1,,,0,,,,0,0,0,0,0,There is no change between the early version and the late version.,"As there is no change between the two versions, there will be no compatibility issue."
77,"<android.app.Notification.Builder: Builder setSound(Uri,int)>",25,26,,,,"{
    mN.sound = sound;
    mN.audioStreamType = streamType;
    return this;
}","{
    PlayerBase.deprecateStreamTypeForPlayback(streamType, ""Notification"", ""setSound()"");
    mN.sound = sound;
    mN.audioStreamType = streamType;
    return this;
}",1,"/**
 * Set the sound to play, along with a specific stream on which to play it.
 *
 * See {@link android.media.AudioManager} for the <code>STREAM_</code> constants.
 *
 * <p>
 * A notification that is noisy is more likely to be presented as a heads-up notification.
 * </p>
 * @deprecated use {@link #setSound(Uri, AudioAttributes)} instead.
 * @see Notification#sound
 */
","/**
 * Set the sound to play, along with a specific stream on which to play it.
 *
 * See {@link android.media.AudioManager} for the <code>STREAM_</code> constants.
 *
 * @deprecated use {@link NotificationChannel#setSound(Uri, AudioAttributes)}.
 */
",1,[@Deprecated],[@Deprecated],0,,,,2,4,0,4,0,"A new statement `PlayerBase.deprecateStreamTypeForPlayback(streamType, ""Notification"", ""setSound()"");` has been added before the original statements. However, it does not change the return value or exception handling of the method, so it belongs to ""Other statement changed"".","The added statement only deprecates the stream type for playback, and it does not affect the return value or exception handling of the method. Therefore, there is no Compatibility Issue."
78,"<android.provider.DocumentsProvider: String renameDocument(String,String)>",25,26,,,,"{
    throw new UnsupportedOperationException(""Rename not supported"");
}","{
    throw new UnsupportedOperationException(""Rename not supported"");
}",0,"/**
 * Rename an existing document.
 * <p>
 * If a different {@link Document#COLUMN_DOCUMENT_ID} must be used to
 * represent the renamed document, generate and return it. Any outstanding
 * URI permission grants will be updated to point at the new document. If
 * the original {@link Document#COLUMN_DOCUMENT_ID} is still valid after the
 * rename, return {@code null}.
 *
 * @param documentId the document to rename.
 * @param displayName the updated display name of the document. The provider
 * may alter this name to meet any internal constraints, such as
 * avoiding conflicting names.
 */
","/**
 * Rename an existing document.
 * <p>
 * If a different {@link Document#COLUMN_DOCUMENT_ID} must be used to
 * represent the renamed document, generate and return it. Any outstanding
 * URI permission grants will be updated to point at the new document. If
 * the original {@link Document#COLUMN_DOCUMENT_ID} is still valid after the
 * rename, return {@code null}.
 *
 * @param documentId the document to rename.
 * @param displayName the updated display name of the document. The provider
 * may alter this name to meet any internal constraints, such as
 * avoiding conflicting names.
 * @throws AuthenticationRequiredException If authentication is required from
 * the user (such as login credentials), but it is not guaranteed
 * that the client will handle this properly.
 */
",1,[@SuppressWarnings("unused")],[@SuppressWarnings("unused")],0,,,,0,0,0,0,0,There is no difference between the two versions of the implementation.,There is no compatibility issue as the implementation is the same in both versions.
79,"<android.app.admin.DevicePolicyManager: boolean isPackageSuspended(ComponentName,String)>",25,26,,,,"{
    throwIfParentInstance(""isPackageSuspended"");
    if (mService != null) {
        try {
            return mService.isPackageSuspended(admin, packageName);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        } catch (IllegalArgumentException ex) {
            throw new NameNotFoundException(packageName);
        }
    }
    return false;
}","{
    throwIfParentInstance(""isPackageSuspended"");
    if (mService != null) {
        try {
            return mService.isPackageSuspended(admin, mContext.getPackageName(), packageName);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        } catch (IllegalArgumentException ex) {
            throw new NameNotFoundException(packageName);
        }
    }
    return false;
}",1,"/**
 * Called by device or profile owners to determine if a package is suspended.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param packageName The name of the package to retrieve the suspended status of.
 * @return {@code true} if the package is suspended or {@code false} if the package is not
 * suspended, could not be found or an error occurred.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 * @throws NameNotFoundException if the package could not be found.
 */
","/**
 * Determine if a package is suspended. This function can be called by a device owner, profile
 * owner, or by a delegate given the {@link #DELEGATION_PACKAGE_ACCESS} scope via
 * {@link #setDelegatedScopes}.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or
 * {@code null} if the caller is a package access delegate.
 * @param packageName The name of the package to retrieve the suspended status of.
 * @return {@code true} if the package is suspended or {@code false} if the package is not
 * suspended, could not be found or an error occurred.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 * @throws NameNotFoundException if the package could not be found.
 * @see #setDelegatedScopes
 * @see #DELEGATION_PACKAGE_ACCESS
 */
",1,,,0,,,,2,"1,5",1,5,1,"In the late version implementation, the method ""isPackageSuspended"" has an additional parameter ""mContext.getPackageName()"" compared to the early version. This is a dependent API change.","The additional parameter in the ""isPackageSuspended"" method may cause the method to return a different value, which can lead to a Compatibility Issue caused by potential different return values."
80,<android.app.UiAutomation: AccessibilityNodeInfo findFocus(int)>,25,26,,,,"{
    return AccessibilityInteractionClient.getInstance().findFocus(mConnectionId, AccessibilityNodeInfo.ANY_WINDOW_ID, AccessibilityNodeInfo.ROOT_NODE_ID, focus);
}","{
    return AccessibilityInteractionClient.getInstance().findFocus(mConnectionId, AccessibilityWindowInfo.ANY_WINDOW_ID, AccessibilityNodeInfo.ROOT_NODE_ID, focus);
}",1,"/**
 * Find the view that has the specified focus type. The search is performed
 * across all windows.
 * <p>
 * <strong>Note:</strong> In order to access the windows you have to opt-in
 * to retrieve the interactive windows by setting the
 * {@link AccessibilityServiceInfo#FLAG_RETRIEVE_INTERACTIVE_WINDOWS} flag.
 * Otherwise, the search will be performed only in the active window.
 * </p>
 *
 * @param focus The focus to find. One of {@link AccessibilityNodeInfo#FOCUS_INPUT} or
 * {@link AccessibilityNodeInfo#FOCUS_ACCESSIBILITY}.
 * @return The node info of the focused view or null.
 *
 * @see AccessibilityNodeInfo#FOCUS_INPUT
 * @see AccessibilityNodeInfo#FOCUS_ACCESSIBILITY
 */
","/**
 * Find the view that has the specified focus type. The search is performed
 * across all windows.
 * <p>
 * <strong>Note:</strong> In order to access the windows you have to opt-in
 * to retrieve the interactive windows by setting the
 * {@link AccessibilityServiceInfo#FLAG_RETRIEVE_INTERACTIVE_WINDOWS} flag.
 * Otherwise, the search will be performed only in the active window.
 * </p>
 *
 * @param focus The focus to find. One of {@link AccessibilityNodeInfo#FOCUS_INPUT} or
 * {@link AccessibilityNodeInfo#FOCUS_ACCESSIBILITY}.
 * @return The node info of the focused view or null.
 *
 * @see AccessibilityNodeInfo#FOCUS_INPUT
 * @see AccessibilityNodeInfo#FOCUS_ACCESSIBILITY
 */
",0,,,0,,,,"1,2","1,5",1,5,1,"The change is in the dependent API. The method AccessibilityInteractionClient.getInstance().findFocus() has a different parameter in early and late versions. In the early version, the parameter is AccessibilityNodeInfo.ANY\_WINDOW\_ID, while in the late version, it is AccessibilityWindowInfo.ANY\_WINDOW\_ID.","This change could lead to compatibility issues because the method findFocus() might behave differently due to the change in the parameter. This could result in the method returning a different value, leading to a compatibility issue of type 1."
81,"<android.net.nsd.NsdServiceInfo: Map<String, byte[]> getAttributes()>",25,26,,,,"{
    return Collections.unmodifiableMap(mTxtRecord);
}","{
    return Collections.unmodifiableMap(mTxtRecord);
}",0,"/**
 * Retrive attributes as a map of String keys to byte[] values.
 *
 * <p> The returned map is unmodifiable; changes must be made through {@link #setAttribute} and
 * {@link #removeAttribute}.
 */
","/**
 * Retrieve attributes as a map of String keys to byte[] values. The attributes map is only
 * valid for a resolved service.
 *
 * <p> The returned map is unmodifiable; changes must be made through {@link #setAttribute} and
 * {@link #removeAttribute}.
 */
",1,,,0,,,,0,0,0,0,0,There is no change in the code implementation between the early and late versions.,"Since there is no change in the code implementation, there is no compatibility issue that could arise."
82,"<android.content.pm.PackageInstaller.SessionParams: void writeToParcel(Parcel,int)>",25,26,,,,"{
    dest.writeInt(mode);
    dest.writeInt(installFlags);
    dest.writeInt(installLocation);
    dest.writeLong(sizeBytes);
    dest.writeString(appPackageName);
    dest.writeParcelable(appIcon, flags);
    dest.writeString(appLabel);
    dest.writeParcelable(originatingUri, flags);
    dest.writeInt(originatingUid);
    dest.writeParcelable(referrerUri, flags);
    dest.writeString(abiOverride);
    dest.writeString(volumeUuid);
    dest.writeStringArray(grantedRuntimePermissions);
}","{
    dest.writeInt(mode);
    dest.writeInt(installFlags);
    dest.writeInt(installLocation);
    dest.writeInt(installReason);
    dest.writeLong(sizeBytes);
    dest.writeString(appPackageName);
    dest.writeParcelable(appIcon, flags);
    dest.writeString(appLabel);
    dest.writeParcelable(originatingUri, flags);
    dest.writeInt(originatingUid);
    dest.writeParcelable(referrerUri, flags);
    dest.writeString(abiOverride);
    dest.writeString(volumeUuid);
    dest.writeStringArray(grantedRuntimePermissions);
}",1,,,0,[@Override],[@Override],0,,,,1,4,1,5,0,"A new method ""writeInt(installReason)"" has been added to the writeToParcel method in the late version. This new method is writing an integer value to the parcel, which was not present in the early version. This change is classified as ""Dependent API changed"" since the writeToParcel method relies on the ""writeInt"" method, which has undergone changes in the type or number of parameters.","Although there is a change in the implementation of the writeToParcel method, this change does not affect the return type or value of the method since it is a void method. Additionally, this change does not affect the exception handling of the method. Therefore, there is no Compatibility Issue caused by this change."
83,<android.os.ParcelFileDescriptor.AutoCloseOutputStream: void close()>,28,29,,,,"{
    try {
        mPfd.close();
    } finally {
        super.close();
    }
}","{
    try {
        super.close();
    } finally {
        mPfd.close();
    }
}",1,,,0,[@Override],[@Override],0,,,,1,3,0,3,1,"The order of the try-finally block has been swapped in the late version, which is a change in control dependency.","Although the two statements mPfd.close() and super.close() still execute in both versions, the order of execution has changed. If an exception occurs in mPfd.close(), it will be suppressed in the late version and the super.close() will still be executed. However, in the early version, if an exception occurs in mPfd.close(), the exception will be thrown directly and super.close() will not be executed. This difference in behavior could lead to different results and thus is a Compatibility Issue (CI)."
84,"<android.app.usage.UsageStatsManager: List<UsageStats> queryUsageStats(int,long,long)>",28,29,,,,"{
    try {
        @SuppressWarnings(""unchecked"") ParceledListSlice<UsageStats> slice = mService.queryUsageStats(intervalType, beginTime, endTime, mContext.getOpPackageName());
        if (slice != null) {
            return slice.getList();
        }
    } catch (RemoteException e) {
    // fallthrough and return the empty list.
    }
    return Collections.emptyList();
}","{
    try {
        @SuppressWarnings(""unchecked"") ParceledListSlice<UsageStats> slice = mService.queryUsageStats(intervalType, beginTime, endTime, mContext.getOpPackageName());
        if (slice != null) {
            return slice.getList();
        }
    } catch (RemoteException e) {
    // fallthrough and return the empty list.
    }
    return Collections.emptyList();
}",0,"/**
 * Gets application usage stats for the given time range, aggregated by the specified interval.
 * <p>The returned list will contain a {@link UsageStats} object for each package that
 * has data for an interval that is a subset of the time range given. To illustrate:</p>
 * <pre>
 * intervalType = INTERVAL_YEARLY
 * beginTime = 2013
 * endTime = 2015 (exclusive)
 *
 * Results:
 * 2013 - com.example.alpha
 * 2013 - com.example.beta
 * 2014 - com.example.alpha
 * 2014 - com.example.beta
 * 2014 - com.example.charlie
 * </pre>
 *
 * <p> The caller must have {@link android.Manifest.permission#PACKAGE_USAGE_STATS} </p>
 *
 * @param intervalType The time interval by which the stats are aggregated.
 * @param beginTime The inclusive beginning of the range of stats to include in the results.
 * @param endTime The exclusive end of the range of stats to include in the results.
 * @return A list of {@link UsageStats}
 *
 * @see #INTERVAL_DAILY
 * @see #INTERVAL_WEEKLY
 * @see #INTERVAL_MONTHLY
 * @see #INTERVAL_YEARLY
 * @see #INTERVAL_BEST
 */
","/**
 * Gets application usage stats for the given time range, aggregated by the specified interval.
 *
 * <p>
 * The returned list will contain one or more {@link UsageStats} objects for each package, with
 * usage data that covers at least the given time range.
 * Note: The begin and end times of the time range may be expanded to the nearest whole interval
 * period.
 * </p>
 *
 * <p> The caller must have {@link android.Manifest.permission#PACKAGE_USAGE_STATS} </p>
 *
 * @param intervalType The time interval by which the stats are aggregated.
 * @param beginTime The inclusive beginning of the range of stats to include in the results.
 * Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime The exclusive end of the range of stats to include in the results. Defined
 * in terms of ""Unix time"", see {@link java.lang.System#currentTimeMillis}.
 * @return A list of {@link UsageStats}
 *
 * @see #INTERVAL_DAILY
 * @see #INTERVAL_WEEKLY
 * @see #INTERVAL_MONTHLY
 * @see #INTERVAL_YEARLY
 * @see #INTERVAL_BEST
 */
",1,,,0,,,,0,0,0,0,0,There is no code change between the early version and late version implementation of the API.,No Compatibility Issue will arise because the code has not changed.
85,"<android.view.LayoutInflater: View createViewFromTag(View,String,Context,AttributeSet,boolean)>",28,29,,,,"{
    if (name.equals(""view"")) {
        name = attrs.getAttributeValue(null, ""class"");
    }
    // Apply a theme wrapper, if allowed and one is specified.
    if (!ignoreThemeAttr) {
        final TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME);
        final int themeResId = ta.getResourceId(0, 0);
        if (themeResId != 0) {
            context = new ContextThemeWrapper(context, themeResId);
        }
        ta.recycle();
    }
    if (name.equals(TAG_1995)) {
        // Let's party like it's 1995!
        return new BlinkLayout(context, attrs);
    }
    try {
        View view;
        if (mFactory2 != null) {
            view = mFactory2.onCreateView(parent, name, context, attrs);
        } else if (mFactory != null) {
            view = mFactory.onCreateView(name, context, attrs);
        } else {
            view = null;
        }
        if (view == null && mPrivateFactory != null) {
            view = mPrivateFactory.onCreateView(parent, name, context, attrs);
        }
        if (view == null) {
            final Object lastContext = mConstructorArgs[0];
            mConstructorArgs[0] = context;
            try {
                if (-1 == name.indexOf('.')) {
                    view = onCreateView(parent, name, attrs);
                } else {
                    view = createView(name, null, attrs);
                }
            } finally {
                mConstructorArgs[0] = lastContext;
            }
        }
        return view;
    } catch (InflateException e) {
        throw e;
    } catch (ClassNotFoundException e) {
        final InflateException ie = new InflateException(attrs.getPositionDescription() + "": Error inflating class "" + name, e);
        ie.setStackTrace(EMPTY_STACK_TRACE);
        throw ie;
    } catch (Exception e) {
        final InflateException ie = new InflateException(attrs.getPositionDescription() + "": Error inflating class "" + name, e);
        ie.setStackTrace(EMPTY_STACK_TRACE);
        throw ie;
    }
}","{
    if (name.equals(""view"")) {
        name = attrs.getAttributeValue(null, ""class"");
    }
    // Apply a theme wrapper, if allowed and one is specified.
    if (!ignoreThemeAttr) {
        final TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME);
        final int themeResId = ta.getResourceId(0, 0);
        if (themeResId != 0) {
            context = new ContextThemeWrapper(context, themeResId);
        }
        ta.recycle();
    }
    try {
        View view = tryCreateView(parent, name, context, attrs);
        if (view == null) {
            final Object lastContext = mConstructorArgs[0];
            mConstructorArgs[0] = context;
            try {
                if (-1 == name.indexOf('.')) {
                    view = onCreateView(context, parent, name, attrs);
                } else {
                    view = createView(context, name, null, attrs);
                }
            } finally {
                mConstructorArgs[0] = lastContext;
            }
        }
        return view;
    } catch (InflateException e) {
        throw e;
    } catch (ClassNotFoundException e) {
        final InflateException ie = new InflateException(getParserStateDescription(context, attrs) + "": Error inflating class "" + name, e);
        ie.setStackTrace(EMPTY_STACK_TRACE);
        throw ie;
    } catch (Exception e) {
        final InflateException ie = new InflateException(getParserStateDescription(context, attrs) + "": Error inflating class "" + name, e);
        ie.setStackTrace(EMPTY_STACK_TRACE);
        throw ie;
    }
}",1,"/**
 * Creates a view from a tag name using the supplied attribute set.
 * <p>
 * <strong>Note:</strong> Default visibility so the BridgeInflater can
 * override it.
 *
 * @param parent the parent view, used to inflate layout params
 * @param name the name of the XML tag used to define the view
 * @param context the inflation context for the view, typically the
 * {@code parent} or base layout inflater context
 * @param attrs the attribute set for the XML tag used to define the view
 * @param ignoreThemeAttr {@code true} to ignore the {@code android:theme}
 * attribute (if set) for the view being inflated,
 * {@code false} otherwise
 */
","/**
 * Creates a view from a tag name using the supplied attribute set.
 * <p>
 * <strong>Note:</strong> Default visibility so the BridgeInflater can
 * override it.
 *
 * @param parent the parent view, used to inflate layout params
 * @param name the name of the XML tag used to define the view
 * @param context the inflation context for the view, typically the
 * {@code parent} or base layout inflater context
 * @param attrs the attribute set for the XML tag used to define the view
 * @param ignoreThemeAttr {@code true} to ignore the {@code android:theme}
 * attribute (if set) for the view being inflated,
 * {@code false} otherwise
 */
",0,,[@UnsupportedAppUsage],1,,,,"1,2","1,3,4,5",1,"1,2,3,5","1,2","The method that is used to create the view has changed from `onCreateView(parent, name, context, attrs)` to `tryCreateView(parent, name, context, attrs)` and from `onCreateView(context, parent, name, attrs)` to `createView(context, name, null, attrs)`. Also, the condition statement inside the try block has changed. The exception handling statement has changed from `attrs.getPositionDescription()` to `getParserStateDescription(context, attrs)`. A new annotation `@UnsupportedAppUsage` is added in the late version. So the change type is 1,2,3,5.","The changes in the method used to create the view could potentially cause the API to return a different view, leading to a compatibility issue of type 1. The changes in the exception handling statements could also potentially cause the API to throw a different exception, leading to a compatibility issue of type 2."
86,"<android.view.textclassifier.TextLinks.Builder: Builder addLink(int,int,Map<String, Float>)>",28,29,,,,"{
    mLinks.add(new TextLink(start, end, entityScores, null));
    return this;
}","{
    return addLink(start, end, entityScores, Bundle.EMPTY, null);
}",1,"/**
 * Adds a TextLink.
 *
 * @param start The start index of the identified subsequence
 * @param end The end index of the identified subsequence
 * @param entityScores A mapping of entity type to confidence score
 *
 * @throws IllegalArgumentException if entityScores is null or empty.
 */
","/**
 * Adds a TextLink.
 *
 * @param start The start index of the identified subsequence
 * @param end The end index of the identified subsequence
 * @param entityScores A mapping of entity type to confidence score
 *
 * @throws IllegalArgumentException if entityScores is null or empty.
 */
",0,[@NonNull],[@NonNull],0,,,,"1,2","1,5",1,5,1,"The implementation in the late version calls a new method addLink(int, int, Map<String, Float>, Bundle, Rect) with the last two arguments set to Bundle.EMPTY and null. This new method is not present in the early version. So, the code change type is 5, which is dependent API changed.","The new method addLink(int, int, Map<String, Float>, Bundle, Rect) in the late version may potentially have different behavior compared to the addLink(int, int, Map<String, Float>) method in the early version. Therefore, it may cause Compatibility Issue (CI) with the return value leading to CI type 1."
87,<android.view.inputmethod.InputMethodManager: InputMethodSubtype getLastInputMethodSubtype()>,28,29,,,,"{
    synchronized (mH) {
        try {
            return mService.getLastInputMethodSubtype();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}","{
    try {
        return mService.getLastInputMethodSubtype();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,0,,,0,,,,1,4,0,3,1,"The 'synchronized (mH)' statement has been removed, which is a control dependency change.","The 'synchronized (mH)' statement has been removed, which means that the API in the late version may return different values when being invoked by multi-threading, so the compatibility issue type is 1."
88,<android.util.ArrayMap: String toString()>,28,29,,,,"{
    if (isEmpty()) {
        return ""{}"";
    }
    StringBuilder buffer = new StringBuilder(mSize * 28);
    buffer.append('{');
    for (int i = 0; i < mSize; i++) {
        if (i > 0) {
            buffer.append("", "");
        }
        Object key = keyAt(i);
        if (key != this) {
            buffer.append(key);
        } else {
            buffer.append(""(this Map)"");
        }
        buffer.append('=');
        Object value = valueAt(i);
        if (value != this) {
            buffer.append(value);
        } else {
            buffer.append(""(this Map)"");
        }
    }
    buffer.append('}');
    return buffer.toString();
}","{
    if (isEmpty()) {
        return ""{}"";
    }
    StringBuilder buffer = new StringBuilder(mSize * 28);
    buffer.append('{');
    for (int i = 0; i < mSize; i++) {
        if (i > 0) {
            buffer.append("", "");
        }
        Object key = keyAt(i);
        if (key != this) {
            buffer.append(key);
        } else {
            buffer.append(""(this Map)"");
        }
        buffer.append('=');
        Object value = valueAt(i);
        if (value != this) {
            buffer.append(ArrayUtils.deepToString(value));
        } else {
            buffer.append(""(this Map)"");
        }
    }
    buffer.append('}');
    return buffer.toString();
}",1,"/**
 * {@inheritDoc}
 *
 * <p>This implementation composes a string by iterating over its mappings. If
 * this map contains itself as a key or a value, the string ""(this Map)""
 * will appear in its place.
 */
","/**
 * {@inheritDoc}
 *
 * <p>This implementation composes a string by iterating over its mappings. If
 * this map contains itself as a key or a value, the string ""(this Map)""
 * will appear in its place.
 */
",0,[@Override],[@Override],0,,,,"1,2",4,1,"1,5",1,"The code change is the introduction of a new method call ArrayUtils.deepToString(value) in the late version of the implementation. This is a change in the dependent API. Additionally, the return statement has been modified to include the result of this method call, which is a change in the return statement. Therefore, the code change type is 1,5.","The change in the dependent API and the return statement can potentially result in a different value being returned by the toString() method in the late version. This is because the ArrayUtils.deepToString(value) method may produce a different string representation of the value object than the default toString() method used in the early version. Therefore, the CI type is 1."
89,<android.hardware.camera2.CameraMetadata: List<TKey> getKeys()>,28,29,,,,"{
    Class<CameraMetadata<TKey>> thisClass = (Class<CameraMetadata<TKey>>) getClass();
    return Collections.unmodifiableList(getKeys(thisClass, getKeyClass(), this, /*filterTags*/
    null));
}","{
    Class<CameraMetadata<TKey>> thisClass = (Class<CameraMetadata<TKey>>) getClass();
    return Collections.unmodifiableList(getKeys(thisClass, getKeyClass(), this, /*filterTags*/
    null, /*includeSynthetic*/
    true));
}",1,"/**
 * Returns a list of the keys contained in this map.
 *
 * <p>The list returned is not modifiable, so any attempts to modify it will throw
 * a {@code UnsupportedOperationException}.</p>
 *
 * <p>All values retrieved by a key from this list with {@code #get} are guaranteed to be
 * non-{@code null}. Each key is only listed once in the list. The order of the keys
 * is undefined.</p>
 *
 * @return List of the keys contained in this map.
 */
","/**
 * Returns a list of the keys contained in this map.
 *
 * <p>The list returned is not modifiable, so any attempts to modify it will throw
 * a {@code UnsupportedOperationException}.</p>
 *
 * <p>All values retrieved by a key from this list with {@code #get} are guaranteed to be
 * non-{@code null}. Each key is only listed once in the list. The order of the keys
 * is undefined.</p>
 *
 * @return List of the keys contained in this map.
 */
",0,"[@SuppressWarnings(""unchecked""), @NonNull]","[@SuppressWarnings(""unchecked""), @NonNull]",0,,,,2,"1,5",1,5,1,"In the Late_Implementation, the getKeys method has a new boolean parameter ""includeSynthetic"" with a value of true, which is passed to the method. This indicates a dependent API change.","As the getKeys method now includes a new parameter, it may return a different list of keys in the Late_Version, which could lead to a Compatibility Issue in terms of different return values."
90,<android.app.Activity: int getRequestedOrientation()>,28,29,,,,"{
    if (mParent == null) {
        try {
            return ActivityManager.getService().getRequestedOrientation(mToken);
        } catch (RemoteException e) {
        // Empty
        }
    } else {
        return mParent.getRequestedOrientation();
    }
    return ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;
}","{
    if (mParent == null) {
        try {
            return ActivityTaskManager.getService().getRequestedOrientation(mToken);
        } catch (RemoteException e) {
        // Empty
        }
    } else {
        return mParent.getRequestedOrientation();
    }
    return ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;
}",1,"/**
 * Return the current requested orientation of the activity.  This will
 * either be the orientation requested in its component's manifest, or
 * the last requested orientation given to
 * {@link #setRequestedOrientation(int)}.
 *
 * @return Returns an orientation constant as used in
 * {@link ActivityInfo#screenOrientation ActivityInfo.screenOrientation}.
 */
","/**
 * Return the current requested orientation of the activity.  This will
 * either be the orientation requested in its component's manifest, or
 * the last requested orientation given to
 * {@link #setRequestedOrientation(int)}.
 *
 * @return Returns an orientation constant as used in
 * {@link ActivityInfo#screenOrientation ActivityInfo.screenOrientation}.
 */
",0,[@ActivityInfo.ScreenOrientation],[@ActivityInfo.ScreenOrientation],0,,,,2,"1,5",1,5,1,The implementation of the API "getRequestedOrientation()" has changed the dependent API from "ActivityManager.getService().getRequestedOrientation(mToken)" to "ActivityTaskManager.getService().getRequestedOrientation(mToken)". This is an example of Dependent API changed (class 5).,"The change of dependent API may cause the API ""getRequestedOrientation()"" to return different values, leading to a Compatibility Issue caused by potential different return values or types (class 1)."
91,<android.view.MenuItem: Mode getIconTintMode()>,28,29,,,,"{
    return null;
}","{
    return null;
}",0,"/**
 * Returns the blending mode used to apply the tint to this item's icon, if specified.
 *
 * @return the blending mode used to apply the tint to this item's icon
 * @attr ref android.R.styleable#MenuItem_iconTintMode
 * @see #setIconTintMode(PorterDuff.Mode)
 */
","/**
 * Returns the blending mode used to apply the tint to this item's icon, if specified.
 *
 * @return the blending mode used to apply the tint to this item's icon
 * @attr ref android.R.styleable#MenuItem_iconTintMode
 * @see #setIconTintMode(PorterDuff.Mode)
 * @see #setIconTintBlendMode(BlendMode)
 */
",1,[@Nullable],[@Nullable],0,,,,0,0,0,0,0,"There is no difference between the early version and the late version of the implementation, so the code change type is 0.","As there is no difference between the early version and the late version of the implementation, the return value and exception handling are all the same, so the CI type is 0."
92,<android.view.ViewTreeObserver: void merge(ViewTreeObserver)>,28,29,,,,"{
    if (observer.mOnWindowAttachListeners != null) {
        if (mOnWindowAttachListeners != null) {
            mOnWindowAttachListeners.addAll(observer.mOnWindowAttachListeners);
        } else {
            mOnWindowAttachListeners = observer.mOnWindowAttachListeners;
        }
    }
    if (observer.mOnWindowFocusListeners != null) {
        if (mOnWindowFocusListeners != null) {
            mOnWindowFocusListeners.addAll(observer.mOnWindowFocusListeners);
        } else {
            mOnWindowFocusListeners = observer.mOnWindowFocusListeners;
        }
    }
    if (observer.mOnGlobalFocusListeners != null) {
        if (mOnGlobalFocusListeners != null) {
            mOnGlobalFocusListeners.addAll(observer.mOnGlobalFocusListeners);
        } else {
            mOnGlobalFocusListeners = observer.mOnGlobalFocusListeners;
        }
    }
    if (observer.mOnGlobalLayoutListeners != null) {
        if (mOnGlobalLayoutListeners != null) {
            mOnGlobalLayoutListeners.addAll(observer.mOnGlobalLayoutListeners);
        } else {
            mOnGlobalLayoutListeners = observer.mOnGlobalLayoutListeners;
        }
    }
    if (observer.mOnPreDrawListeners != null) {
        if (mOnPreDrawListeners != null) {
            mOnPreDrawListeners.addAll(observer.mOnPreDrawListeners);
        } else {
            mOnPreDrawListeners = observer.mOnPreDrawListeners;
        }
    }
    if (observer.mOnDrawListeners != null) {
        if (mOnDrawListeners != null) {
            mOnDrawListeners.addAll(observer.mOnDrawListeners);
        } else {
            mOnDrawListeners = observer.mOnDrawListeners;
        }
    }
    if (observer.mOnTouchModeChangeListeners != null) {
        if (mOnTouchModeChangeListeners != null) {
            mOnTouchModeChangeListeners.addAll(observer.mOnTouchModeChangeListeners);
        } else {
            mOnTouchModeChangeListeners = observer.mOnTouchModeChangeListeners;
        }
    }
    if (observer.mOnComputeInternalInsetsListeners != null) {
        if (mOnComputeInternalInsetsListeners != null) {
            mOnComputeInternalInsetsListeners.addAll(observer.mOnComputeInternalInsetsListeners);
        } else {
            mOnComputeInternalInsetsListeners = observer.mOnComputeInternalInsetsListeners;
        }
    }
    if (observer.mOnScrollChangedListeners != null) {
        if (mOnScrollChangedListeners != null) {
            mOnScrollChangedListeners.addAll(observer.mOnScrollChangedListeners);
        } else {
            mOnScrollChangedListeners = observer.mOnScrollChangedListeners;
        }
    }
    if (observer.mOnWindowShownListeners != null) {
        if (mOnWindowShownListeners != null) {
            mOnWindowShownListeners.addAll(observer.mOnWindowShownListeners);
        } else {
            mOnWindowShownListeners = observer.mOnWindowShownListeners;
        }
    }
    observer.kill();
}","{
    if (observer.mOnWindowAttachListeners != null) {
        if (mOnWindowAttachListeners != null) {
            mOnWindowAttachListeners.addAll(observer.mOnWindowAttachListeners);
        } else {
            mOnWindowAttachListeners = observer.mOnWindowAttachListeners;
        }
    }
    if (observer.mOnWindowFocusListeners != null) {
        if (mOnWindowFocusListeners != null) {
            mOnWindowFocusListeners.addAll(observer.mOnWindowFocusListeners);
        } else {
            mOnWindowFocusListeners = observer.mOnWindowFocusListeners;
        }
    }
    if (observer.mOnGlobalFocusListeners != null) {
        if (mOnGlobalFocusListeners != null) {
            mOnGlobalFocusListeners.addAll(observer.mOnGlobalFocusListeners);
        } else {
            mOnGlobalFocusListeners = observer.mOnGlobalFocusListeners;
        }
    }
    if (observer.mOnGlobalLayoutListeners != null) {
        if (mOnGlobalLayoutListeners != null) {
            mOnGlobalLayoutListeners.addAll(observer.mOnGlobalLayoutListeners);
        } else {
            mOnGlobalLayoutListeners = observer.mOnGlobalLayoutListeners;
        }
    }
    if (observer.mOnPreDrawListeners != null) {
        if (mOnPreDrawListeners != null) {
            mOnPreDrawListeners.addAll(observer.mOnPreDrawListeners);
        } else {
            mOnPreDrawListeners = observer.mOnPreDrawListeners;
        }
    }
    if (observer.mOnDrawListeners != null) {
        if (mOnDrawListeners != null) {
            mOnDrawListeners.addAll(observer.mOnDrawListeners);
        } else {
            mOnDrawListeners = observer.mOnDrawListeners;
        }
    }
    if (observer.mOnFrameCommitListeners != null) {
        if (mOnFrameCommitListeners != null) {
            mOnFrameCommitListeners.addAll(observer.captureFrameCommitCallbacks());
        } else {
            mOnFrameCommitListeners = observer.captureFrameCommitCallbacks();
        }
    }
    if (observer.mOnTouchModeChangeListeners != null) {
        if (mOnTouchModeChangeListeners != null) {
            mOnTouchModeChangeListeners.addAll(observer.mOnTouchModeChangeListeners);
        } else {
            mOnTouchModeChangeListeners = observer.mOnTouchModeChangeListeners;
        }
    }
    if (observer.mOnComputeInternalInsetsListeners != null) {
        if (mOnComputeInternalInsetsListeners != null) {
            mOnComputeInternalInsetsListeners.addAll(observer.mOnComputeInternalInsetsListeners);
        } else {
            mOnComputeInternalInsetsListeners = observer.mOnComputeInternalInsetsListeners;
        }
    }
    if (observer.mOnScrollChangedListeners != null) {
        if (mOnScrollChangedListeners != null) {
            mOnScrollChangedListeners.addAll(observer.mOnScrollChangedListeners);
        } else {
            mOnScrollChangedListeners = observer.mOnScrollChangedListeners;
        }
    }
    if (observer.mOnWindowShownListeners != null) {
        if (mOnWindowShownListeners != null) {
            mOnWindowShownListeners.addAll(observer.mOnWindowShownListeners);
        } else {
            mOnWindowShownListeners = observer.mOnWindowShownListeners;
        }
    }
    if (observer.mGestureExclusionListeners != null) {
        if (mGestureExclusionListeners != null) {
            mGestureExclusionListeners.addAll(observer.mGestureExclusionListeners);
        } else {
            mGestureExclusionListeners = observer.mGestureExclusionListeners;
        }
    }
    observer.kill();
}",1,"/**
 * Merges all the listeners registered on the specified observer with the listeners
 * registered on this object. After this method is invoked, the specified observer
 * will return false in {@link #isAlive()} and should not be used anymore.
 *
 * @param observer The ViewTreeObserver whose listeners must be added to this observer
 */
","/**
 * Merges all the listeners registered on the specified observer with the listeners
 * registered on this object. After this method is invoked, the specified observer
 * will return false in {@link #isAlive()} and should not be used anymore.
 *
 * @param observer The ViewTreeObserver whose listeners must be added to this observer
 */
",0,,,0,,,,"1,2","3,4",1,5,1,"There are two new if statements added in the late version, one is related to mOnFrameCommitListeners and the other is related to mGestureExclusionListeners. Also, the method captureFrameCommitCallbacks() is called in the late version.","Since the method captureFrameCommitCallbacks() is called in the late version, it might return different value or type which leads to different behaviours. Therefore, a Compatibility Issue (CI) arises. The CI type is 1, which means the CI is caused by potential different return values or types."
93,<android.os.StrictMode.AndroidBlockGuardPolicy: int getPolicyMask()>,28,29,,,,"{
    return mPolicyMask;
}","{
    return mThreadPolicyMask;
}",1,"// Part of BlockGuard.Policy interface:
","// Part of BlockGuard.Policy interface:
",0,,,0,,,,"1,2","1,5",1,1,1,The return statement has changed from return mPolicyMask; to return mThreadPolicyMask;.,"Since the variable being returned has changed, this could potentially cause the API to return a different value, leading to a Compatibility Issue. The CI type is 1."
94,<android.net.ConnectivityManager: boolean isActiveNetworkMetered()>,22,23,,,,"{
    try {
        return mService.isActiveNetworkMetered();
    } catch (RemoteException e) {
        return false;
    }
}","{
    try {
        return mService.isActiveNetworkMetered();
    } catch (RemoteException e) {
        return false;
    }
}",0,"/**
 * Returns if the currently active data network is metered. A network is
 * classified as metered when the user is sensitive to heavy data usage on
 * that connection due to monetary costs, data limitations or
 * battery/performance issues. You should check this before doing large
 * data transfers, and warn the user or delay the operation until another
 * network is available.
 *
 * @return {@code true} if large transfers should be avoided, otherwise
 * {@code false}.
 *
 * <p>This method requires the call to hold the permission
 * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
 */
","/**
 * Returns if the currently active data network is metered. A network is
 * classified as metered when the user is sensitive to heavy data usage on
 * that connection due to monetary costs, data limitations or
 * battery/performance issues. You should check this before doing large
 * data transfers, and warn the user or delay the operation until another
 * network is available.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
 *
 * @return {@code true} if large transfers should be avoided, otherwise
 * {@code false}.
 */
",1,,,0,,,,0,0,0,0,0,There are no differences between the early and late implementation of the API.,"There are no differences between the early and late implementation of the API, so there is no Compatibility Issue."
95,<android.view.InputDevice: String toString()>,22,23,,,,"{
    StringBuilder description = new StringBuilder();
    description.append(""Input Device "").append(mId).append("": "").append(mName).append(""\n"");
    description.append(""  Descriptor: "").append(mDescriptor).append(""\n"");
    description.append(""  Generation: "").append(mGeneration).append(""\n"");
    description.append(""  Location: "").append(mIsExternal ? ""external"" : ""built-in"").append(""\n"");
    description.append(""  Keyboard Type: "");
    switch(mKeyboardType) {
        case KEYBOARD_TYPE_NONE:
            description.append(""none"");
            break;
        case KEYBOARD_TYPE_NON_ALPHABETIC:
            description.append(""non-alphabetic"");
            break;
        case KEYBOARD_TYPE_ALPHABETIC:
            description.append(""alphabetic"");
            break;
    }
    description.append(""\n"");
    description.append(""  Has Vibrator: "").append(mHasVibrator).append(""\n"");
    description.append(""  Sources: 0x"").append(Integer.toHexString(mSources)).append("" ("");
    appendSourceDescriptionIfApplicable(description, SOURCE_KEYBOARD, ""keyboard"");
    appendSourceDescriptionIfApplicable(description, SOURCE_DPAD, ""dpad"");
    appendSourceDescriptionIfApplicable(description, SOURCE_TOUCHSCREEN, ""touchscreen"");
    appendSourceDescriptionIfApplicable(description, SOURCE_MOUSE, ""mouse"");
    appendSourceDescriptionIfApplicable(description, SOURCE_STYLUS, ""stylus"");
    appendSourceDescriptionIfApplicable(description, SOURCE_TRACKBALL, ""trackball"");
    appendSourceDescriptionIfApplicable(description, SOURCE_TOUCHPAD, ""touchpad"");
    appendSourceDescriptionIfApplicable(description, SOURCE_JOYSTICK, ""joystick"");
    appendSourceDescriptionIfApplicable(description, SOURCE_GAMEPAD, ""gamepad"");
    description.append("" )\n"");
    final int numAxes = mMotionRanges.size();
    for (int i = 0; i < numAxes; i++) {
        MotionRange range = mMotionRanges.get(i);
        description.append(""    "").append(MotionEvent.axisToString(range.mAxis));
        description.append("": source=0x"").append(Integer.toHexString(range.mSource));
        description.append("" min="").append(range.mMin);
        description.append("" max="").append(range.mMax);
        description.append("" flat="").append(range.mFlat);
        description.append("" fuzz="").append(range.mFuzz);
        description.append("" resolution="").append(range.mResolution);
        description.append(""\n"");
    }
    return description.toString();
}","{
    StringBuilder description = new StringBuilder();
    description.append(""Input Device "").append(mId).append("": "").append(mName).append(""\n"");
    description.append(""  Descriptor: "").append(mDescriptor).append(""\n"");
    description.append(""  Generation: "").append(mGeneration).append(""\n"");
    description.append(""  Location: "").append(mIsExternal ? ""external"" : ""built-in"").append(""\n"");
    description.append(""  Keyboard Type: "");
    switch(mKeyboardType) {
        case KEYBOARD_TYPE_NONE:
            description.append(""none"");
            break;
        case KEYBOARD_TYPE_NON_ALPHABETIC:
            description.append(""non-alphabetic"");
            break;
        case KEYBOARD_TYPE_ALPHABETIC:
            description.append(""alphabetic"");
            break;
    }
    description.append(""\n"");
    description.append(""  Has Vibrator: "").append(mHasVibrator).append(""\n"");
    description.append(""  Has mic: "").append(mHasMicrophone).append(""\n"");
    description.append(""  Sources: 0x"").append(Integer.toHexString(mSources)).append("" ("");
    appendSourceDescriptionIfApplicable(description, SOURCE_KEYBOARD, ""keyboard"");
    appendSourceDescriptionIfApplicable(description, SOURCE_DPAD, ""dpad"");
    appendSourceDescriptionIfApplicable(description, SOURCE_TOUCHSCREEN, ""touchscreen"");
    appendSourceDescriptionIfApplicable(description, SOURCE_MOUSE, ""mouse"");
    appendSourceDescriptionIfApplicable(description, SOURCE_STYLUS, ""stylus"");
    appendSourceDescriptionIfApplicable(description, SOURCE_TRACKBALL, ""trackball"");
    appendSourceDescriptionIfApplicable(description, SOURCE_TOUCHPAD, ""touchpad"");
    appendSourceDescriptionIfApplicable(description, SOURCE_JOYSTICK, ""joystick"");
    appendSourceDescriptionIfApplicable(description, SOURCE_GAMEPAD, ""gamepad"");
    description.append("" )\n"");
    final int numAxes = mMotionRanges.size();
    for (int i = 0; i < numAxes; i++) {
        MotionRange range = mMotionRanges.get(i);
        description.append(""    "").append(MotionEvent.axisToString(range.mAxis));
        description.append("": source=0x"").append(Integer.toHexString(range.mSource));
        description.append("" min="").append(range.mMin);
        description.append("" max="").append(range.mMax);
        description.append("" flat="").append(range.mFlat);
        description.append("" fuzz="").append(range.mFuzz);
        description.append("" resolution="").append(range.mResolution);
        description.append(""\n"");
    }
    return description.toString();
}",1,,,0,[@Override],[@Override],0,,,,1,"1,4",1,4,0,"A new statement has been added to the toString() implementation: `description.append("" Has mic: "").append(mHasMicrophone).append(""\n"");`. This is an other statement changed, not belonging to return statements, exception handling statements, and statements about the control dependency. So the code change type is 4.","The newly added statement `description.append("" Has mic: "").append(mHasMicrophone).append(""\n"");` just adds more information to the output string. The API still returns a string, and the type and value of the returned string are not affected by this change. Additionally, there is no exception handling statement changed, and no control dependency changed. Therefore, there is no compatibility issue caused by potential different return values or types, nor compatibility issue caused by potential different exception handlings. So the CI type is 0."
96,<android.view.ViewGroup: boolean isAnimationCacheEnabled()>,22,23,,,,"{
    return (mGroupFlags & FLAG_ANIMATION_CACHE) == FLAG_ANIMATION_CACHE;
}","{
    return (mGroupFlags & FLAG_ANIMATION_CACHE) == FLAG_ANIMATION_CACHE;
}",0,"/**
 * Indicates whether the children's drawing cache is used during a layout
 * animation. By default, the drawing cache is enabled but this will prevent
 * nested layout animations from working. To nest animations, you must disable
 * the cache.
 *
 * @return true if the animation cache is enabled, false otherwise
 *
 * @see #setAnimationCacheEnabled(boolean)
 * @see View#setDrawingCacheEnabled(boolean)
 */
","/**
 * Indicates whether the children's drawing cache is used during a layout
 * animation. By default, the drawing cache is enabled but this will prevent
 * nested layout animations from working. To nest animations, you must disable
 * the cache.
 *
 * @return true if the animation cache is enabled, false otherwise
 *
 * @see #setAnimationCacheEnabled(boolean)
 * @see View#setDrawingCacheEnabled(boolean)
 *
 * @deprecated As of {@link android.os.Build.VERSION_CODES#M}, this property is ignored.
 * Caching behavior of children may be controlled through {@link View#setLayerType(int, Paint)}.
 */
",1,[@ViewDebug.ExportedProperty],,1,,,,0,0,0,0,0,"There is no change in the return statement, exception handling, control dependency, other statements, or dependent API between the two versions.","As there is no change in the code, there is no potential Compatibility Issue that could arise for the API."
97,"<android.hardware.SystemSensorManager.TriggerEventQueue: void dispatchSensorEvent(int,float[],int,long)>",22,23,,,,"{
    final Sensor sensor = sHandleToSensor.get(handle);
    TriggerEvent t = null;
    synchronized (mTriggerEvents) {
        t = mTriggerEvents.get(handle);
    }
    if (t == null) {
        Log.e(TAG, ""Error: Trigger Event is null for Sensor: "" + sensor);
        return;
    }
    // Copy from the values array.
    System.arraycopy(values, 0, t.values, 0, t.values.length);
    t.timestamp = timestamp;
    t.sensor = sensor;
    // A trigger sensor is auto disabled. So just clean up and don't call native
    // disable.
    mManager.cancelTriggerSensorImpl(mListener, sensor, false);
    mListener.onTrigger(t);
}","{
    final Sensor sensor = mManager.mHandleToSensor.get(handle);
    TriggerEvent t = null;
    synchronized (mTriggerEvents) {
        t = mTriggerEvents.get(handle);
    }
    if (t == null) {
        Log.e(TAG, ""Error: Trigger Event is null for Sensor: "" + sensor);
        return;
    }
    // Copy from the values array.
    System.arraycopy(values, 0, t.values, 0, t.values.length);
    t.timestamp = timestamp;
    t.sensor = sensor;
    // A trigger sensor is auto disabled. So just clean up and don't call native
    // disable.
    mManager.cancelTriggerSensorImpl(mListener, sensor, false);
    mListener.onTrigger(t);
}",1,"// Called from native code.
","// Called from native code.
",0,"[@SuppressWarnings(""unused""), @Override]","[@SuppressWarnings(""unused""), @Override]",0,,,,2,"4,5",0,5,1,"In the late implementation, the variable ""sHandleToSensor"" in the early implementation is replaced with ""mManager.mHandleToSensor"". This means that the dependent API has changed, so the code change type is 5.","As the dependent API has changed, there is a potential that this could cause the API to return a different variable, leading to a compatibility issue. Therefore, the CI type is 1."
98,<android.os.Bundle: boolean hasFileDescriptors()>,22,23,,,,"{
    if (!mFdsKnown) {
        // keep going until we find one or run out of data
        boolean fdFound = false;
        if (mParcelledData != null) {
            if (mParcelledData.hasFileDescriptors()) {
                fdFound = true;
            }
        } else {
            // It's been unparcelled, so we need to walk the map
            for (int i = mMap.size() - 1; i >= 0; i--) {
                Object obj = mMap.valueAt(i);
                if (obj instanceof Parcelable) {
                    if ((((Parcelable) obj).describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0) {
                        fdFound = true;
                        break;
                    }
                } else if (obj instanceof Parcelable[]) {
                    Parcelable[] array = (Parcelable[]) obj;
                    for (int n = array.length - 1; n >= 0; n--) {
                        if ((array[n].describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0) {
                            fdFound = true;
                            break;
                        }
                    }
                } else if (obj instanceof SparseArray) {
                    SparseArray<? extends Parcelable> array = (SparseArray<? extends Parcelable>) obj;
                    for (int n = array.size() - 1; n >= 0; n--) {
                        if ((array.valueAt(n).describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0) {
                            fdFound = true;
                            break;
                        }
                    }
                } else if (obj instanceof ArrayList) {
                    ArrayList array = (ArrayList) obj;
                    // Parcelables; only look inside for Parcelables
                    if (!array.isEmpty() && (array.get(0) instanceof Parcelable)) {
                        for (int n = array.size() - 1; n >= 0; n--) {
                            Parcelable p = (Parcelable) array.get(n);
                            if (p != null && ((p.describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0)) {
                                fdFound = true;
                                break;
                            }
                        }
                    }
                }
            }
        }
        mHasFds = fdFound;
        mFdsKnown = true;
    }
    return mHasFds;
}","{
    if (!mFdsKnown) {
        // keep going until we find one or run out of data
        boolean fdFound = false;
        if (mParcelledData != null) {
            if (mParcelledData.hasFileDescriptors()) {
                fdFound = true;
            }
        } else {
            // It's been unparcelled, so we need to walk the map
            for (int i = mMap.size() - 1; i >= 0; i--) {
                Object obj = mMap.valueAt(i);
                if (obj instanceof Parcelable) {
                    if ((((Parcelable) obj).describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0) {
                        fdFound = true;
                        break;
                    }
                } else if (obj instanceof Parcelable[]) {
                    Parcelable[] array = (Parcelable[]) obj;
                    for (int n = array.length - 1; n >= 0; n--) {
                        Parcelable p = array[n];
                        if (p != null && ((p.describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0)) {
                            fdFound = true;
                            break;
                        }
                    }
                } else if (obj instanceof SparseArray) {
                    SparseArray<? extends Parcelable> array = (SparseArray<? extends Parcelable>) obj;
                    for (int n = array.size() - 1; n >= 0; n--) {
                        Parcelable p = array.valueAt(n);
                        if (p != null && (p.describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0) {
                            fdFound = true;
                            break;
                        }
                    }
                } else if (obj instanceof ArrayList) {
                    ArrayList array = (ArrayList) obj;
                    // Parcelables; only look inside for Parcelables
                    if (!array.isEmpty() && (array.get(0) instanceof Parcelable)) {
                        for (int n = array.size() - 1; n >= 0; n--) {
                            Parcelable p = (Parcelable) array.get(n);
                            if (p != null && ((p.describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0)) {
                                fdFound = true;
                                break;
                            }
                        }
                    }
                }
            }
        }
        mHasFds = fdFound;
        mFdsKnown = true;
    }
    return mHasFds;
}",1,"/**
 * Reports whether the bundle contains any parcelled file descriptors.
 */
","/**
 * Reports whether the bundle contains any parcelled file descriptors.
 */
",0,,,0,,,,"1,2","3,4",1,3,1,"The code change is related to the control dependency. Specifically, the condition for checking the file descriptor is different between the two versions. In the early version, the condition only checks for the CONTENTS\_FILE\_DESCRIPTOR flag, while in the late version, the condition checks for both the CONTENTS\_FILE\_DESCRIPTOR flag and whether the Parcelable object is null or not. This change can potentially affect the value of the mHasFds variable, which is returned by the method.","The Compatibility Issue arises from the potential different return values of the method. Specifically, the different conditions for checking the file descriptor can potentially cause the method to return a different value for the mHasFds variable. This can lead to compatibility issues in the applications that rely on the return value of the method."
100,<android.content.res.TypedArray: Resources getResources()>,22,23,,,,"{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    return mResources;
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    return mResources;
}",0,"/**
 * Return the Resources object this array was loaded from.
 */
","/**
 * Returns the Resources object this array was loaded from.
 *
 * @throws RuntimeException if the TypedArray has already been recycled.
 */
",1,,,0,,,,0,0,0,0,0,There is no change between the early and late implementation of the API.,There is no compatibility issue as there is no change in the implementation of the API.
101,<android.widget.TimePicker: boolean is24HourView()>,22,23,,,,"{
    return mDelegate.is24HourView();
}","{
    return mDelegate.is24HourView();
}",0,"/**
 * @return true if this is in 24 hour view else false.
 */
","/**
 * @return {@code true} if this widget displays time in 24-hour mode,
 * {@code false} otherwise}
 * @see #setIs24HourView(Boolean)
 */
",1,,,0,,,,0,0,0,0,0,No code changes have been observed between the two versions.,"As there are no code changes, the behavior of the API will remain the same in both versions, and there is no compatibility issue."
102,<android.net.DhcpStateMachine.StoppedState: boolean processMessage(Message)>,22,23,,,,"{
    boolean retValue = HANDLED;
    if (DBG)
        Log.d(TAG, getName() + message.toString() + ""\n"");
    switch(message.what) {
        case CMD_START_DHCP:
            if (mRegisteredForPreDhcpNotification) {
                /* Notify controller before starting DHCP */
                mController.sendMessage(CMD_PRE_DHCP_ACTION);
                transitionTo(mWaitBeforeStartState);
            } else {
                if (runDhcp(DhcpAction.START)) {
                    transitionTo(mRunningState);
                }
            }
            break;
        case CMD_STOP_DHCP:
            // ignore
            break;
        default:
            retValue = NOT_HANDLED;
            break;
    }
    return retValue;
}","{
    boolean retValue = HANDLED;
    if (DBG)
        Log.d(TAG, getName() + message.toString() + ""\n"");
    switch(message.what) {
        case CMD_START_DHCP:
            if (mRegisteredForPreDhcpNotification) {
                /* Notify controller before starting DHCP */
                mController.sendMessage(CMD_PRE_DHCP_ACTION);
                transitionTo(mWaitBeforeStartState);
            } else {
                if (runDhcpStart()) {
                    transitionTo(mRunningState);
                }
            }
            break;
        case CMD_STOP_DHCP:
            // ignore
            break;
        default:
            retValue = NOT_HANDLED;
            break;
    }
    return retValue;
}",1,,,0,[@Override],[@Override],0,,,,2,"3,5",1,5,1,"The code change is related to a dependent API, specifically the 'runDhcp' method in the early version has been changed to 'runDhcpStart' in the late version. Therefore, the code change type is 5.","As the dependent API 'runDhcp' has been changed to 'runDhcpStart', and the implementation of these two APIs are different, it may lead to different behaviours when the 'processMessage' API is invoked. Therefore, the compatibility issue type is 1."
103,<android.widget.ProgressBar: void setProgressDrawable(Drawable)>,23,24,,,,"{
    if (mProgressDrawable != d) {
        if (mProgressDrawable != null) {
            mProgressDrawable.setCallback(null);
            unscheduleDrawable(mProgressDrawable);
        }
        mProgressDrawable = d;
        if (d != null) {
            d.setCallback(this);
            d.setLayoutDirection(getLayoutDirection());
            if (d.isStateful()) {
                d.setState(getDrawableState());
            }
            // Make sure the ProgressBar is always tall enough
            int drawableHeight = d.getMinimumHeight();
            if (mMaxHeight < drawableHeight) {
                mMaxHeight = drawableHeight;
                requestLayout();
            }
            applyProgressTints();
        }
        if (!mIndeterminate) {
            mCurrentDrawable = d;
            postInvalidate();
        }
        updateDrawableBounds(getWidth(), getHeight());
        updateDrawableState();
        doRefreshProgress(R.id.progress, mProgress, false, false);
        doRefreshProgress(R.id.secondaryProgress, mSecondaryProgress, false, false);
    }
}","{
    if (mProgressDrawable != d) {
        if (mProgressDrawable != null) {
            mProgressDrawable.setCallback(null);
            unscheduleDrawable(mProgressDrawable);
        }
        mProgressDrawable = d;
        if (d != null) {
            d.setCallback(this);
            d.setLayoutDirection(getLayoutDirection());
            if (d.isStateful()) {
                d.setState(getDrawableState());
            }
            // Make sure the ProgressBar is always tall enough
            int drawableHeight = d.getMinimumHeight();
            if (mMaxHeight < drawableHeight) {
                mMaxHeight = drawableHeight;
                requestLayout();
            }
            applyProgressTints();
        }
        if (!mIndeterminate) {
            swapCurrentDrawable(d);
            postInvalidate();
        }
        updateDrawableBounds(getWidth(), getHeight());
        updateDrawableState();
        doRefreshProgress(R.id.progress, mProgress, false, false, false);
        doRefreshProgress(R.id.secondaryProgress, mSecondaryProgress, false, false, false);
    }
}",1,"/**
 * Define the drawable used to draw the progress bar in progress mode.
 *
 * @param d the new drawable
 * @see #getProgressDrawable()
 * @see #setIndeterminate(boolean)
 */
","/**
 * Define the drawable used to draw the progress bar in progress mode.
 *
 * @param d the new drawable
 * @see #getProgressDrawable()
 * @see #setIndeterminate(boolean)
 */
",0,,,0,,,,"1,2","4,5",1,"1, 5",1,The method "setProgressDrawable" has been changed from calling "mCurrentDrawable = d;" to "swapCurrentDrawable(d);" and the "doRefreshProgress" method has also been changed from having 4 parameters to having 5 parameters. These changes are classified as return statement changed (1) and dependent API changed (5).,"The change from ""mCurrentDrawable = d;"" to ""swapCurrentDrawable(d);"" could potentially cause the API to return a different value, leading to a Compatibility Issue (1). The addition of a new parameter in the ""doRefreshProgress"" method could also lead to different behaviors, causing a Compatibility Issue (1)."
104,"<android.view.inputmethod.InputConnectionWrapper: boolean setComposingText(CharSequence,int)>",23,24,,,,"{
    return mTarget.setComposingText(text, newCursorPosition);
}","{
    return mTarget.setComposingText(text, newCursorPosition);
}",0,,"/**
 * {@inheritDoc}
 * @throws NullPointerException if the target is {@code null}.
 */
",1,,,0,,,,0,0,0,0,0,"The code snippets provided are identical in both the early and late versions, so there is no change.","Since there is no change in the code implementation, there is no compatibility issue that could arise."
105,<android.preference.PreferenceFragment: void onDestroyView()>,23,24,,,,"{
    mList = null;
    mHandler.removeCallbacks(mRequestFocus);
    mHandler.removeMessages(MSG_BIND_PREFERENCES);
    super.onDestroyView();
}","{
    if (mList != null) {
        mList.setOnKeyListener(null);
    }
    mList = null;
    mHandler.removeCallbacks(mRequestFocus);
    mHandler.removeMessages(MSG_BIND_PREFERENCES);
    super.onDestroyView();
}",1,,,0,[@Override],[@Override],0,,,,"1,2","3,4",0,3,1,An if-statement has been introduced to set the OnKeyListener to null before setting mList to null. This change falls under the category of control dependency change.,"The introduced if-statement can potentially lead to different behaviors of the API. Specifically, if mList is not null, the OnKeyListener will be set to null, which will lead to different return values or types. Therefore, there is a compatibility issue caused by potential different return values or types."
106,"<android.app.admin.DevicePolicyManager: void setUserIcon(ComponentName,Bitmap)>",23,24,,,,"{
    try {
        mService.setUserIcon(admin, icon);
    } catch (RemoteException re) {
        Log.w(TAG, ""Could not set the user icon "", re);
    }
}","{
    throwIfParentInstance(""setUserIcon"");
    try {
        mService.setUserIcon(admin, icon);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}",1,"/**
 * Called by profile or device owners to set the current user's photo.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param icon the bitmap to set as the photo.
 */
","/**
 * Called by profile or device owners to set the user's photo.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param icon the bitmap to set as the photo.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 */
",1,,,0,,,,"1,2","2,4",2,"2, 5",2,The code change includes the following:,"2. The exception handling statement has been changed. In the early version, the code catches RemoteException and logs a warning message. In the late version, the code catches RemoteException and rethrows it with ""rethrowFromSystemServer()""."
107,<android.bluetooth.BluetoothGatt: boolean readCharacteristic(BluetoothGattCharacteristic)>,23,24,,,,"{
    if ((characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_READ) == 0)
        return false;
    if (VDBG)
        Log.d(TAG, ""readCharacteristic() - uuid: "" + characteristic.getUuid());
    if (mService == null || mClientIf == 0)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusy) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.readCharacteristic(mClientIf, device.getAddress(), service.getType(), service.getInstanceId(), new ParcelUuid(service.getUuid()), characteristic.getInstanceId(), new ParcelUuid(characteristic.getUuid()), AUTHENTICATION_NONE);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}","{
    if ((characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_READ) == 0)
        return false;
    if (VDBG)
        Log.d(TAG, ""readCharacteristic() - uuid: "" + characteristic.getUuid());
    if (mService == null || mClientIf == 0)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusy) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.readCharacteristic(mClientIf, device.getAddress(), characteristic.getInstanceId(), AUTHENTICATION_NONE);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}",1,"/**
 * Reads the requested characteristic from the associated remote device.
 *
 * <p>This is an asynchronous operation. The result of the read operation
 * is reported by the {@link BluetoothGattCallback#onCharacteristicRead}
 * callback.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param characteristic Characteristic to read from the remote device
 * @return true, if the read operation was initiated successfully
 */
","/**
 * Reads the requested characteristic from the associated remote device.
 *
 * <p>This is an asynchronous operation. The result of the read operation
 * is reported by the {@link BluetoothGattCallback#onCharacteristicRead}
 * callback.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param characteristic Characteristic to read from the remote device
 * @return true, if the read operation was initiated successfully
 */
",0,,,0,,,,2,5,1,5,1,The method 'readCharacteristic' in BluetoothGatt class has undergone a dependent API change. The call to the method 'mService.readCharacteristic' has changed from including several service and characteristic parameters to only including the characteristic instance ID and authentication parameters.,"This change in the dependent API could potentially lead to different behavior in the 'readCharacteristic' method. Specifically, the different parameters passed to the 'mService.readCharacteristic' method could cause it to return different values or throw different exceptions, leading to a Compatibility Issue."
108,<android.widget.TextView: void drawableStateChanged()>,23,24,,,,"{
    super.drawableStateChanged();
    if (mTextColor != null && mTextColor.isStateful() || (mHintTextColor != null && mHintTextColor.isStateful()) || (mLinkTextColor != null && mLinkTextColor.isStateful())) {
        updateTextColors();
    }
    if (mDrawables != null) {
        final int[] state = getDrawableState();
        for (Drawable dr : mDrawables.mShowing) {
            if (dr != null && dr.isStateful()) {
                dr.setState(state);
            }
        }
    }
}","{
    super.drawableStateChanged();
    if (mTextColor != null && mTextColor.isStateful() || (mHintTextColor != null && mHintTextColor.isStateful()) || (mLinkTextColor != null && mLinkTextColor.isStateful())) {
        updateTextColors();
    }
    if (mDrawables != null) {
        final int[] state = getDrawableState();
        for (Drawable dr : mDrawables.mShowing) {
            if (dr != null && dr.isStateful() && dr.setState(state)) {
                invalidateDrawable(dr);
            }
        }
    }
}",1,,,0,[@Override],[@Override],0,,,,"1,2","3,4,5",1,3,1,"Inside the 'for' loop, an additional condition 'dr.setState(state)' has been added in the if statement, and a new statement 'invalidateDrawable(dr)' is introduced. Thus, the change type is 3.","The additional condition 'dr.setState(state)' and the new statement 'invalidateDrawable(dr)' may lead to different behaviors when invoking the late version API, causing the 'drawableStateChanged()' method to potentially return a different state or value. Therefore, the CI type is 1."
109,<android.widget.AbsSeekBar: void jumpDrawablesToCurrentState()>,23,24,,,,"{
    super.jumpDrawablesToCurrentState();
    if (mThumb != null) {
        mThumb.jumpToCurrentState();
    }
}","{
    super.jumpDrawablesToCurrentState();
    if (mThumb != null) {
        mThumb.jumpToCurrentState();
    }
    if (mTickMark != null) {
        mTickMark.jumpToCurrentState();
    }
}",1,,,0,[@Override],[@Override],0,,,,"1,2","1,3,4",0,3,1,"The late version introduces a new control dependency, i.e. an 'if' statement, which checks if 'mTickMark' is not null and calls the 'jumpToCurrentState()' method on it.","The new control dependency could cause the API to behave differently, as the 'jumpToCurrentState()' method on 'mTickMark' is only called in the late version. This means that the state of the 'mTickMark' object may be different between the two versions, potentially leading to different behavior when the API is invoked. Therefore, this change could lead to a Compatibility Issue of type 1, i.e. the API potentially returns different values or types."
110,"<android.preference.SeekBarVolumizer.Receiver: void onReceive(Context,Intent)>",23,24,,,,"{
    final String action = intent.getAction();
    if (AudioManager.VOLUME_CHANGED_ACTION.equals(action)) {
        int streamType = intent.getIntExtra(AudioManager.EXTRA_VOLUME_STREAM_TYPE, -1);
        int streamValue = intent.getIntExtra(AudioManager.EXTRA_VOLUME_STREAM_VALUE, -1);
        final boolean streamMatch = mNotificationOrRing ? isNotificationOrRing(streamType) : (streamType == mStreamType);
        if (mSeekBar != null && streamMatch && streamValue != -1) {
            final boolean muted = mAudioManager.isStreamMute(mStreamType) || streamValue == 0;
            mUiHandler.postUpdateSlider(streamValue, mLastAudibleStreamVolume, muted);
        }
    } else if (AudioManager.INTERNAL_RINGER_MODE_CHANGED_ACTION.equals(action)) {
        if (mNotificationOrRing) {
            mRingerMode = mAudioManager.getRingerModeInternal();
        }
        if (mAffectedByRingerMode) {
            updateSlider();
        }
    } else if (NotificationManager.ACTION_INTERRUPTION_FILTER_CHANGED.equals(action)) {
        mZenMode = mNotificationManager.getZenMode();
        updateSlider();
    }
}","{
    final String action = intent.getAction();
    if (AudioManager.VOLUME_CHANGED_ACTION.equals(action)) {
        int streamType = intent.getIntExtra(AudioManager.EXTRA_VOLUME_STREAM_TYPE, -1);
        int streamValue = intent.getIntExtra(AudioManager.EXTRA_VOLUME_STREAM_VALUE, -1);
        updateVolumeSlider(streamType, streamValue);
    } else if (AudioManager.INTERNAL_RINGER_MODE_CHANGED_ACTION.equals(action)) {
        if (mNotificationOrRing) {
            mRingerMode = mAudioManager.getRingerModeInternal();
        }
        if (mAffectedByRingerMode) {
            updateSlider();
        }
    } else if (AudioManager.STREAM_DEVICES_CHANGED_ACTION.equals(action)) {
        int streamType = intent.getIntExtra(AudioManager.EXTRA_VOLUME_STREAM_TYPE, -1);
        int streamVolume = mAudioManager.getStreamVolume(streamType);
        updateVolumeSlider(streamType, streamVolume);
    } else if (NotificationManager.ACTION_INTERRUPTION_FILTER_CHANGED.equals(action)) {
        mZenMode = mNotificationManager.getZenMode();
        updateSlider();
    }
}",1,,,0,[@Override],[@Override],0,,,,"1,2","3,4",0,"1,5","1,2","The implementation of the method onReceive() has changed significantly, including the deletion of the variable ""streamMatch"" and addition of a new dependent API ""updateVolumeSlider()"", and a new condition statement ""AudioManager.STREAM\_DEVICES\_CHANGED\_ACTION.equals(action)"". Hence the code change type is 1,5.","As the implementation of the method onReceive() has changed significantly, including the deletion of the variable ""streamMatch"" and addition of a new dependent API ""updateVolumeSlider()"", and a new condition statement ""AudioManager.STREAM\_DEVICES\_CHANGED\_ACTION.equals(action)"", it could potentially lead to different behaviors in the late version. Therefore, the CI type is 1,2."
111,<android.widget.Editor.PinnedPopupWindow: void hide()>,23,24,,,,"{
    mPopupWindow.dismiss();
    getPositionListener().removeSubscriber(this);
}","{
    if (!isShowing()) {
        return;
    }
    mPopupWindow.dismiss();
    getPositionListener().removeSubscriber(this);
}",1,,,0,,,0,,,,"1,2","1,3,4",1,3,1,The late version adds an if-statement that checks whether the popup window is showing before dismissing it. This is a control dependency change.,"The added if-statement may cause the late version to return early without dismissing the popup window if it is not showing, while the early version always dismisses the popup window. This could lead to different behaviors and potentially cause a Compatibility Issue (CI) if the code relies on the popup window being dismissed in all cases."
112,<android.content.pm.PackageInstaller: List<SessionInfo> getAllSessions()>,23,24,,,,"{
    final ApplicationInfo info = mContext.getApplicationInfo();
    if (""com.google.android.googlequicksearchbox"".equals(info.packageName) && info.versionCode <= 300400110) {
        Log.d(TAG, ""Ignoring callback request from old prebuilt"");
        return Collections.EMPTY_LIST;
    }
    try {
        return mInstaller.getAllSessions(mUserId).getList();
    } catch (RemoteException e) {
        throw e.rethrowAsRuntimeException();
    }
}","{
    try {
        return mInstaller.getAllSessions(mUserId).getList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Return list of all known install sessions, regardless of the installer.
 */
","/**
 * Return list of all known install sessions, regardless of the installer.
 */
",0,[@NonNull],[@NonNull],0,,,,"1,2","1,2,3,4,5","1,2","1, 2","1,2","The early version has an additional if-statement which checks the package name and version, and returns an empty list if the conditions are met. This if-statement is removed in the late version. Additionally, the exception handling statement has changed from throwing the exception as a runtime exception to throwing it as a system server exception.",The removal of the if-statement could lead to a compatibility issue as the API may return a different value (not an empty list) in the late version for the specific package name and version. The change in exception handling could also lead to a compatibility issue as the exception may not be handled correctly in the late version.
113,<android.widget.ActionMenuPresenter.OpenOverflowRunnable: void run()>,23,24,,,,"{
    mMenu.changeMenuMode();
    final View menuView = (View) mMenuView;
    if (menuView != null && menuView.getWindowToken() != null && mPopup.tryShow()) {
        mOverflowPopup = mPopup;
    }
    mPostedOpenRunnable = null;
}","{
    if (mMenu != null) {
        mMenu.changeMenuMode();
    }
    final View menuView = (View) mMenuView;
    if (menuView != null && menuView.getWindowToken() != null && mPopup.tryShow()) {
        mOverflowPopup = mPopup;
    }
    mPostedOpenRunnable = null;
}",1,,,0,,,0,,,,1,3,1,3,1,An 'if' statement is added before 'mMenu.changeMenuMode()'. Thus the code change is classified as "Control dependency changed".,"If 'mMenu' is null in the late version, 'mMenu.changeMenuMode()' will not be executed, resulting in a different behavior and potentially return different values, which is a Compatibility Issue."
114,"<android.accounts.AccountManager: AccountManagerFuture<Bundle> getAuthToken(Account,String,Bundle,boolean,AccountManagerCallback<Bundle>,Handler)>",23,24,,,,"{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    if (authTokenType == null)
        throw new IllegalArgumentException(""authTokenType is null"");
    final Bundle optionsIn = new Bundle();
    if (options != null) {
        optionsIn.putAll(options);
    }
    optionsIn.putString(KEY_ANDROID_PACKAGE_NAME, mContext.getPackageName());
    return new AmsTask(null, handler, callback) {

        public void doWork() throws RemoteException {
            mService.getAuthToken(mResponse, account, authTokenType, notifyAuthFailure, false, /* expectActivityLaunch */
            optionsIn);
        }
    }.start();
}","{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    if (authTokenType == null)
        throw new IllegalArgumentException(""authTokenType is null"");
    final Bundle optionsIn = new Bundle();
    if (options != null) {
        optionsIn.putAll(options);
    }
    optionsIn.putString(KEY_ANDROID_PACKAGE_NAME, mContext.getPackageName());
    return new AmsTask(null, handler, callback) {

        @Override
        public void doWork() throws RemoteException {
            mService.getAuthToken(mResponse, account, authTokenType, notifyAuthFailure, false, /* expectActivityLaunch */
            optionsIn);
        }
    }.start();
}",1,"/**
 * Gets an auth token of the specified type for a particular account,
 * optionally raising a notification if the user must enter credentials.
 * This method is intended for background tasks and services where the
 * user should not be immediately interrupted with a password prompt.
 *
 * <p>If a previously generated auth token is cached for this account and
 * type, then it is returned.  Otherwise, if a saved password is
 * available, it is sent to the server to generate a new auth token.
 * Otherwise, an {@link Intent} is returned which, when started, will
 * prompt the user for a password.  If the notifyAuthFailure parameter is
 * set, a status bar notification is also created with the same Intent,
 * alerting the user that they need to enter a password at some point.
 *
 * <p>In that case, you may need to wait until the user responds, which
 * could take hours or days or forever.  When the user does respond and
 * supply a new password, the account manager will broadcast the
 * {@link #LOGIN_ACCOUNTS_CHANGED_ACTION} Intent, which applications can
 * use to try again.
 *
 * <p>If notifyAuthFailure is not set, it is the application's
 * responsibility to launch the returned Intent at some point.
 * Either way, the result from this call will not wait for user action.
 *
 * <p>Some authenticators have auth token <em>types</em>, whose value
 * is authenticator-dependent.  Some services use different token types to
 * access different functionality -- for example, Google uses different auth
 * tokens to access Gmail and Google Calendar for the same account.
 *
 * <p>This method may be called from any thread, but the returned
 * {@link AccountManagerFuture} must not be used on the main thread.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * USE_CREDENTIALS permission is needed for those platforms. See docs for
 * this function in API level 22.
 *
 * @param account The account to fetch an auth token for
 * @param authTokenType The auth token type, an authenticator-dependent
 * string token, must not be null
 * @param options Authenticator-specific options for the request,
 * may be null or empty
 * @param notifyAuthFailure True to add a notification to prompt the
 * user for a password if necessary, false to leave that to the caller
 * @param callback Callback to invoke when the request completes,
 * null for no callback
 * @param handler {@link Handler} identifying the callback thread,
 * null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Bundle with
 * at least the following fields on success:
 * <ul>
 * <li> {@link #KEY_ACCOUNT_NAME} - the name of the account you supplied
 * <li> {@link #KEY_ACCOUNT_TYPE} - the type of the account
 * <li> {@link #KEY_AUTHTOKEN} - the auth token you wanted
 * </ul>
 *
 * (Other authenticator-specific values may be returned.)  If the user
 * must enter credentials, the returned Bundle contains only
 * {@link #KEY_INTENT} with the {@link Intent} needed to launch a prompt.
 *
 * If an error occurred, {@link AccountManagerFuture#getResult()} throws:
 * <ul>
 * <li> {@link AuthenticatorException} if the authenticator failed to respond
 * <li> {@link OperationCanceledException} if the operation is canceled for
 * any reason, incluidng the user canceling a credential request
 * <li> {@link IOException} if the authenticator experienced an I/O problem
 * creating a new auth token, usually because of network trouble
 * </ul>
 * If the account is no longer present on the device, the return value is
 * authenticator-dependent.  The caller should verify the validity of the
 * account before requesting an auth token.
 */
","/**
 * Gets an auth token of the specified type for a particular account,
 * optionally raising a notification if the user must enter credentials.
 * This method is intended for background tasks and services where the
 * user should not be immediately interrupted with a password prompt.
 *
 * <p>If a previously generated auth token is cached for this account and
 * type, then it is returned.  Otherwise, if a saved password is
 * available, it is sent to the server to generate a new auth token.
 * Otherwise, an {@link Intent} is returned which, when started, will
 * prompt the user for a password.  If the notifyAuthFailure parameter is
 * set, a status bar notification is also created with the same Intent,
 * alerting the user that they need to enter a password at some point.
 *
 * <p>In that case, you may need to wait until the user responds, which
 * could take hours or days or forever.  When the user does respond and
 * supply a new password, the account manager will broadcast the
 * {@link #LOGIN_ACCOUNTS_CHANGED_ACTION} Intent, which applications can
 * use to try again.
 *
 * <p>If notifyAuthFailure is not set, it is the application's
 * responsibility to launch the returned Intent at some point.
 * Either way, the result from this call will not wait for user action.
 *
 * <p>Some authenticators have auth token <em>types</em>, whose value
 * is authenticator-dependent.  Some services use different token types to
 * access different functionality -- for example, Google uses different auth
 * tokens to access Gmail and Google Calendar for the same account.
 *
 * <p>This method may be called from any thread, but the returned
 * {@link AccountManagerFuture} must not be used on the main thread.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * USE_CREDENTIALS permission is needed for those platforms. See docs for
 * this function in API level 22.
 *
 * @param account The account to fetch an auth token for
 * @param authTokenType The auth token type, an authenticator-dependent
 * string token, must not be null
 * @param options Authenticator-specific options for the request,
 * may be null or empty
 * @param notifyAuthFailure True to add a notification to prompt the
 * user for a password if necessary, false to leave that to the caller
 * @param callback Callback to invoke when the request completes,
 * null for no callback
 * @param handler {@link Handler} identifying the callback thread,
 * null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Bundle with
 * at least the following fields on success:
 * <ul>
 * <li> {@link #KEY_ACCOUNT_NAME} - the name of the account you supplied
 * <li> {@link #KEY_ACCOUNT_TYPE} - the type of the account
 * <li> {@link #KEY_AUTHTOKEN} - the auth token you wanted
 * </ul>
 *
 * (Other authenticator-specific values may be returned.)  If the user
 * must enter credentials, the returned Bundle contains only
 * {@link #KEY_INTENT} with the {@link Intent} needed to launch a prompt.
 *
 * If an error occurred, {@link AccountManagerFuture#getResult()} throws:
 * <ul>
 * <li> {@link AuthenticatorException} if the authenticator failed to respond
 * <li> {@link OperationCanceledException} if the operation is canceled for
 * any reason, incluidng the user canceling a credential request
 * <li> {@link IOException} if the authenticator experienced an I/O problem
 * creating a new auth token, usually because of network trouble
 * </ul>
 * If the account is no longer present on the device, the return value is
 * authenticator-dependent.  The caller should verify the validity of the
 * account before requesting an auth token.
 */
",0,,,0,,,,1,4,0,0,0,"There is no change between the early and late implementation of the API. The only difference is the addition of the ""@Override"" annotation in the late implementation, which does not affect the functionality of the code.","As there is no change in the implementation, there is no potential compatibility issue that can arise. The API will behave the same way in both versions."
115,<android.net.NetworkRequest: int hashCode()>,24,25,,,,"{
    return requestId + (legacyType * 1013) + (networkCapabilities.hashCode() * 1051);
}","{
    return Objects.hash(requestId, legacyType, networkCapabilities, type);
}",1,,,0,,,0,,,,"1,2","1,5",1,"1,5",1,"The implementation of hashCode() has changed. In the early version, it uses a custom calculation to generate the hash code based on requestId, legacyType and networkCapabilities, while in the late version, it uses java.util.Objects.hash() to generate the hash code based on requestId, legacyType, networkCapabilities and type. Additionally, a new variable 'type' is introduced to the calculation. This is a return statement change as well as a dependent API change, so the code change type is 1,5.","As the implementation of hashCode() has changed, the value returned by the method may be different in the late version, which could lead to different behavior when the hash code is used, such as in hash-based collections. Therefore, the CI type is 1."
117,<android.nfc.NfcAdapter: void disableReaderMode(Activity)>,24,25,,,,"{
    mNfcActivityManager.disableReaderMode(activity);
}","{
    synchronized (NfcAdapter.class) {
        if (!sHasNfcFeature) {
            throw new UnsupportedOperationException();
        }
    }
    mNfcActivityManager.disableReaderMode(activity);
}",1,"/**
 * Restore the NFC adapter to normal mode of operation: supporting
 * peer-to-peer (Android Beam), card emulation, and polling for
 * all supported tag technologies.
 *
 * @param activity the Activity that currently has reader mode enabled
 */
","/**
 * Restore the NFC adapter to normal mode of operation: supporting
 * peer-to-peer (Android Beam), card emulation, and polling for
 * all supported tag technologies.
 *
 * @param activity the Activity that currently has reader mode enabled
 * @throws UnsupportedOperationException if FEATURE_NFC is unavailable.
 */
",1,,,0,,,,"1,2","2,3,4","1,2",3,2,"The code change introduced a new control dependency, i.e., a synchronized block with a conditional check for the sHasNfcFeature variable.","The added control dependency could potentially lead to a different exception being thrown. Specifically, if the sHasNfcFeature variable is false, an UnsupportedOperationException will be thrown in the late version, while in the early version, no exception will be thrown. Therefore, this change could result in a Compatibility Issue caused by potential different exception handlings."
118,<android.app.admin.DevicePolicyManager: int getPasswordMinimumLength(ComponentName)>,24,25,,,,"{
    return getPasswordMinimumLength(admin, myUserId());
}","{
    return getPasswordMinimumLength(admin, myUserId());
}",0,"/**
 * Retrieve the current minimum password length for a particular admin or all admins that set
 * retrictions on this user and its participating profiles. Restrictions on profiles that have
 * a separate challenge are not taken into account.
 *
 * <p>This method can be called on the {@link DevicePolicyManager} instance
 * returned by {@link #getParentProfileInstance(ComponentName)} in order to retrieve
 * restrictions on the parent profile.
 *
 * user and its profiles or a particular one.
 * @param admin The name of the admin component to check, or {@code null} to aggregate
 * all admins.
 */
","/**
 * Retrieve the current minimum password length for a particular admin or all admins that set
 * restrictions on this user and its participating profiles. Restrictions on profiles that have
 * a separate challenge are not taken into account.
 *
 * <p>This method can be called on the {@link DevicePolicyManager} instance
 * returned by {@link #getParentProfileInstance(ComponentName)} in order to retrieve
 * restrictions on the parent profile.
 *
 * user and its profiles or a particular one.
 * @param admin The name of the admin component to check, or {@code null} to aggregate
 * all admins.
 */
",1,,,0,,,,0,0,0,0,0,There is no change in the code implementation between the early and late version of the API.,"Since there is no change in the code, it will not lead to different behaviours, and thus there is no Compatibility Issue."
119,"<android.provider.DocumentsProvider: String copyDocument(String,String)>",25,26,,,,"{
    throw new UnsupportedOperationException(""Copy not supported"");
}","{
    throw new UnsupportedOperationException(""Copy not supported"");
}",0,"/**
 * Copy the requested document or a document tree.
 * <p>
 * Copies a document including all child documents to another location within
 * the same document provider. Upon completion returns the document id of
 * the copied document at the target destination. {@code null} must never
 * be returned.
 *
 * @param sourceDocumentId the document to copy.
 * @param targetParentDocumentId the target document to be copied into as a child.
 */
","/**
 * Copy the requested document or a document tree.
 * <p>
 * Copies a document including all child documents to another location within
 * the same document provider. Upon completion returns the document id of
 * the copied document at the target destination. {@code null} must never
 * be returned.
 *
 * @param sourceDocumentId the document to copy.
 * @param targetParentDocumentId the target document to be copied into as a child.
 * @throws AuthenticationRequiredException If authentication is required from
 * the user (such as login credentials), but it is not guaranteed
 * that the client will handle this properly.
 */
",1,[@SuppressWarnings("unused")],[@SuppressWarnings("unused")],0,,,,0,0,0,0,0,There is no change in the implementation and annotation of the API between the early and late versions.,"Since the implementation and annotation are the same, there is no potential Compatibility Issue arising for the API between the two versions."
120,<android.widget.TextView: void onCommitCorrection(CorrectionInfo)>,25,26,,,,"{
    if (mEditor != null)
        mEditor.onCommitCorrection(info);
}","{
    if (mEditor != null)
        mEditor.onCommitCorrection(info);
}",0,"/**
 * Called by the framework in response to a text auto-correction (such as fixing a typo using a
 * a dictionnary) from the current input method, provided by it calling
 * {@link InputConnection#commitCorrection} InputConnection.commitCorrection()}. The default
 * implementation flashes the background of the corrected word to provide feedback to the user.
 *
 * @param info The auto correct info about the text that was corrected.
 */
","/**
 * Called by the framework in response to a text auto-correction (such as fixing a typo using a
 * dictionary) from the current input method, provided by it calling
 * {@link InputConnection#commitCorrection(CorrectionInfo) InputConnection.commitCorrection()}.
 * The default implementation flashes the background of the corrected word to provide
 * feedback to the user.
 *
 * @param info The auto correct info about the text that was corrected.
 */
",1,,,0,,,,0,0,0,0,0,There is no change between the early and late implementations.,There is no Compatibility Issue because there is no difference in behavior between the two versions.
121,<android.appwidget.AppWidgetManager: List<AppWidgetProviderInfo> getInstalledProvidersForProfile(UserHandle)>,25,26,,,,"{
    if (mService == null) {
        return Collections.emptyList();
    }
    return getInstalledProvidersForProfile(AppWidgetProviderInfo.WIDGET_CATEGORY_HOME_SCREEN, profile);
}","{
    if (mService == null) {
        return Collections.emptyList();
    }
    return getInstalledProvidersForProfile(AppWidgetProviderInfo.WIDGET_CATEGORY_HOME_SCREEN, profile, null);
}",1,"/**
 * Gets the AppWidget providers for the given user profile. User profile can only
 * be the current user or a profile of the current user. For example, the current
 * user may have a corporate profile. In this case the parent user profile has a
 * child profile, the corporate one.
 *
 * @param profile The profile for which to get providers. Passing null is equivaled
 * to passing only the current user handle.
 * @return The intalled providers.
 *
 * @see android.os.Process#myUserHandle()
 * @see android.os.UserManager#getUserProfiles()
 */
","/**
 * Gets the AppWidget providers for the given user profile. User profile can only
 * be the current user or a profile of the current user. For example, the current
 * user may have a corporate profile. In this case the parent user profile has a
 * child profile, the corporate one.
 *
 * @param profile The profile for which to get providers. Passing null is equivalent
 * to querying for only the calling user.
 * @return The installed providers, or an empty list if none are found for the given user.
 *
 * @see android.os.Process#myUserHandle()
 * @see android.os.UserManager#getUserProfiles()
 */
",1,,[@NonNull],1,,,,2,"1,5",1,5,1,"The method signature of the dependent API 'getInstalledProvidersForProfile()' has changed from 2 parameters to 3 parameters. The change type is 5, which is Dependent API changed.","The change of the dependent API could lead to different behaviors of the current API. Therefore, there is a Compatibility Issue caused by potential different return values or types, which is CI type 1."
122,"<android.view.View: boolean onKeyDown(int,KeyEvent)>",25,26,,,,"{
    if (KeyEvent.isConfirmKey(keyCode)) {
        if ((mViewFlags & ENABLED_MASK) == DISABLED) {
            return true;
        }
        // Long clickable items don't necessarily have to be clickable.
        if (((mViewFlags & CLICKABLE) == CLICKABLE || (mViewFlags & LONG_CLICKABLE) == LONG_CLICKABLE) && (event.getRepeatCount() == 0)) {
            // For the purposes of menu anchoring and drawable hotspots,
            // key events are considered to be at the center of the view.
            final float x = getWidth() / 2f;
            final float y = getHeight() / 2f;
            setPressed(true, x, y);
            checkForLongClick(0, x, y);
            return true;
        }
    }
    return false;
}","{
    if (KeyEvent.isConfirmKey(keyCode)) {
        if ((mViewFlags & ENABLED_MASK) == DISABLED) {
            return true;
        }
        if (event.getRepeatCount() == 0) {
            // Long clickable items don't necessarily have to be clickable.
            final boolean clickable = (mViewFlags & CLICKABLE) == CLICKABLE || (mViewFlags & LONG_CLICKABLE) == LONG_CLICKABLE;
            if (clickable || (mViewFlags & TOOLTIP) == TOOLTIP) {
                // For the purposes of menu anchoring and drawable hotspots,
                // key events are considered to be at the center of the view.
                final float x = getWidth() / 2f;
                final float y = getHeight() / 2f;
                if (clickable) {
                    setPressed(true, x, y);
                }
                checkForLongClick(0, x, y);
                return true;
            }
        }
    }
    return false;
}",1,"/**
 * Default implementation of {@link KeyEvent.Callback#onKeyDown(int, KeyEvent)
 * KeyEvent.Callback.onKeyDown()}: perform press of the view
 * when {@link KeyEvent#KEYCODE_DPAD_CENTER} or {@link KeyEvent#KEYCODE_ENTER}
 * is released, if the view is enabled and clickable.
 * <p>
 * Key presses in software keyboards will generally NOT trigger this
 * listener, although some may elect to do so in some situations. Do not
 * rely on this to catch software key presses.
 *
 * @param keyCode a key code that represents the button pressed, from
 * {@link android.view.KeyEvent}
 * @param event the KeyEvent object that defines the button action
 */
","/**
 * Default implementation of {@link KeyEvent.Callback#onKeyDown(int, KeyEvent)
 * KeyEvent.Callback.onKeyDown()}: perform press of the view
 * when {@link KeyEvent#KEYCODE_DPAD_CENTER} or {@link KeyEvent#KEYCODE_ENTER}
 * is released, if the view is enabled and clickable.
 * <p>
 * Key presses in software keyboards will generally NOT trigger this
 * listener, although some may elect to do so in some situations. Do not
 * rely on this to catch software key presses.
 *
 * @param keyCode a key code that represents the button pressed, from
 * {@link android.view.KeyEvent}
 * @param event the KeyEvent object that defines the button action
 */
",0,,,0,,,,"1,2","3,4",1,3,1,"There's a change in the control dependency of the code, specifically in the condition for the if statement that checks if the event's repeat count is equal to 0. The condition has been moved up and the long clickable check has been separated from it. A new condition has been added to check if the view flags include the TOOLTIP flag.","The change in control dependency could lead to different behavior in the API, specifically in the handling of key events. The separation of the long clickable check and the addition of the TOOLTIP check could potentially cause the API to return a different value, specifically in cases where the repeat count is not equal to 0 or the view flags include the TOOLTIP flag. This leads to a Compatibility Issue of type 1."
123,<android.text.method.TimeKeyListener: TimeKeyListener getInstance()>,25,26,,,,"{
    if (sInstance != null)
        return sInstance;
    sInstance = new TimeKeyListener();
    return sInstance;
}","{
    return getInstance(null);
}",1,,"/**
 * @deprecated Use {@link #getInstance(Locale)} instead.
 */
",1,,"[@Deprecated, @NonNull]",1,,,,"1,2","1,3,5",1,"1,5",1,"The implementation of the `getInstance()` method has changed from returning an instance of `TimeKeyListener` if it exists, or creating a new instance if it doesn't, to calling a new method `getInstance(null)`. This is a change in the return statement and also a change in the dependent API.","This change can potentially lead to a Compatibility Issue as the new implementation of `getInstance()` may return a different instance of `TimeKeyListener` than the previous implementation, or it may throw an exception if the new `getInstance(null)` method has different behavior. The CI type is 1."
124,"<android.app.assist.AssistStructure.ParcelTransferWriter: void writeView(ViewNode,Parcel,PooledStringWriter,int)>",25,26,,,,"{
    if (DEBUG_PARCEL)
        Log.d(TAG, ""write view: at "" + out.dataPosition() + "", windows="" + mNumWrittenWindows + "", views="" + mNumWrittenViews + "", level="" + (mCurViewStackPos + levelAdj));
    out.writeInt(VALIDATE_VIEW_TOKEN);
    int flags = child.writeSelfToParcel(out, pwriter, mTmpMatrix);
    mNumWrittenViews++;
    // If the child has children, push it on the stack to write them next.
    if ((flags & ViewNode.FLAGS_HAS_CHILDREN) != 0) {
        if (DEBUG_PARCEL_TREE || DEBUG_PARCEL_CHILDREN)
            Log.d(TAG, ""Preparing to write "" + child.mChildren.length + "" children: @ #"" + mNumWrittenViews + "", level "" + (mCurViewStackPos + levelAdj));
        out.writeInt(child.mChildren.length);
        int pos = ++mCurViewStackPos;
        pushViewStackEntry(child, pos);
    }
}","{
    if (DEBUG_PARCEL)
        Log.d(TAG, ""write view: at "" + out.dataPosition() + "", windows="" + mNumWrittenWindows + "", views="" + mNumWrittenViews + "", level="" + (mCurViewStackPos + levelAdj));
    out.writeInt(VALIDATE_VIEW_TOKEN);
    int flags = child.writeSelfToParcel(out, pwriter, mSanitizeOnWrite, mTmpMatrix);
    mNumWrittenViews++;
    // If the child has children, push it on the stack to write them next.
    if ((flags & ViewNode.FLAGS_HAS_CHILDREN) != 0) {
        if (DEBUG_PARCEL_TREE || DEBUG_PARCEL_CHILDREN)
            Log.d(TAG, ""Preparing to write "" + child.mChildren.length + "" children: @ #"" + mNumWrittenViews + "", level "" + (mCurViewStackPos + levelAdj));
        out.writeInt(child.mChildren.length);
        int pos = ++mCurViewStackPos;
        pushViewStackEntry(child, pos);
    }
}",1,,,0,,,0,,,,2,5,1,5,0,"In the implementation of the method ""writeView"", a new parameter has been added to the ""child.writeSelfToParcel"" method call in the late version (mSanitizeOnWrite). This change indicates a modification in the dependent API, thus the change type is 5.","As the added parameter in the dependent API call ""child.writeSelfToParcel"" is a boolean value used for sanitizing the output, it is unlikely to cause any compatibility issues in terms of return values or exception handling. Therefore, the CI type is 0."
125,<android.text.TextUtils: boolean isEmpty(CharSequence)>,25,26,,,,"{
    if (str == null || str.length() == 0)
        return true;
    else
        return false;
}","{
    return str == null || str.length() == 0;
}",1,"/**
 * Returns true if the string is null or 0-length.
 * @param str the string to be examined
 * @return true if str is null or zero length
 */
","/**
 * Returns true if the string is null or 0-length.
 * @param str the string to be examined
 * @return true if str is null or zero length
 */
",0,,,0,,,,1,"1,3",1,1,1,"The implementation of the method `isEmpty(CharSequence)` has been changed from using an if-else statement to a single return statement. The behavior of the method is still the same, which returns true if the input `CharSequence` is null or has a length of 0, and returns false otherwise. However, the code change type is 1 as it is a return statement change.","The code change potentially leads to different return values, as the previous implementation uses an if-else statement while the new implementation uses a single return statement. However, the actual behavior of the method is still the same, so it should not cause any compatibility issue in practice. But as long as the code change potentially leads to different return values, it should be classified as a CI caused by potential different return values or types, which is type 1."
126,<android.widget.TextView: void setMinWidth(int)>,25,26,,,,"{
    mMinWidth = minpixels;
    mMinWidthMode = PIXELS;
    requestLayout();
    invalidate();
}","{
    mMinWidth = minPixels;
    mMinWidthMode = PIXELS;
    requestLayout();
    invalidate();
}",1,"/**
 * Makes the TextView at least this many pixels wide
 *
 * @attr ref android.R.styleable#TextView_minWidth
 */
","/**
 * Sets the width of the TextView to be at least {@code minPixels} wide.
 * <p>
 * This value is used for width calculation if LayoutParams does not force TextView to have an
 * exact width. Setting this value overrides previous minimum width configurations such as
 * {@link #setMinEms(int)} or {@link #setEms(int)}.
 * <p>
 * The value given here is different than {@link #setMinimumWidth(int)}. Between
 * {@code minWidth} and the value set in {@link #setMinimumWidth(int)}, the greater one is used
 * to decide the final width.
 *
 * @param minPixels the minimum width of TextView in terms of pixels
 *
 * @see #getMinWidth()
 * @see #setWidth(int)
 *
 * @attr ref android.R.styleable#TextView_minWidth
 */
",1,[@android.view.RemotableViewMethod],[@android.view.RemotableViewMethod],0,,,,1,4,0,0,0,There is no actual change in the implementation. The variable name "minpixels" is changed to "minPixels" but it is just a naming change and does not affect the functionality of the API.,"There is no compatibility issue caused by the code change, the API still works the same way as before, returning no value and not throwing any exceptions."
127,<android.service.notification.NotificationListenerService.MyHandler: void handleMessage(Message)>,25,26,,,,"{
    if (!isConnected) {
        return;
    }
    switch(msg.what) {
        case MSG_ON_NOTIFICATION_POSTED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                StatusBarNotification sbn = (StatusBarNotification) args.arg1;
                RankingMap rankingMap = (RankingMap) args.arg2;
                args.recycle();
                onNotificationPosted(sbn, rankingMap);
            }
            break;
        case MSG_ON_NOTIFICATION_REMOVED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                StatusBarNotification sbn = (StatusBarNotification) args.arg1;
                RankingMap rankingMap = (RankingMap) args.arg2;
                args.recycle();
                onNotificationRemoved(sbn, rankingMap);
            }
            break;
        case MSG_ON_LISTENER_CONNECTED:
            {
                onListenerConnected();
            }
            break;
        case MSG_ON_NOTIFICATION_RANKING_UPDATE:
            {
                RankingMap rankingMap = (RankingMap) msg.obj;
                onNotificationRankingUpdate(rankingMap);
            }
            break;
        case MSG_ON_LISTENER_HINTS_CHANGED:
            {
                final int hints = msg.arg1;
                onListenerHintsChanged(hints);
            }
            break;
        case MSG_ON_INTERRUPTION_FILTER_CHANGED:
            {
                final int interruptionFilter = msg.arg1;
                onInterruptionFilterChanged(interruptionFilter);
            }
            break;
    }
}","{
    if (!isConnected) {
        return;
    }
    switch(msg.what) {
        case MSG_ON_NOTIFICATION_POSTED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                StatusBarNotification sbn = (StatusBarNotification) args.arg1;
                RankingMap rankingMap = (RankingMap) args.arg2;
                args.recycle();
                onNotificationPosted(sbn, rankingMap);
            }
            break;
        case MSG_ON_NOTIFICATION_REMOVED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                StatusBarNotification sbn = (StatusBarNotification) args.arg1;
                RankingMap rankingMap = (RankingMap) args.arg2;
                int reason = (int) args.arg3;
                args.recycle();
                onNotificationRemoved(sbn, rankingMap, reason);
            }
            break;
        case MSG_ON_LISTENER_CONNECTED:
            {
                onListenerConnected();
            }
            break;
        case MSG_ON_NOTIFICATION_RANKING_UPDATE:
            {
                RankingMap rankingMap = (RankingMap) msg.obj;
                onNotificationRankingUpdate(rankingMap);
            }
            break;
        case MSG_ON_LISTENER_HINTS_CHANGED:
            {
                final int hints = msg.arg1;
                onListenerHintsChanged(hints);
            }
            break;
        case MSG_ON_INTERRUPTION_FILTER_CHANGED:
            {
                final int interruptionFilter = msg.arg1;
                onInterruptionFilterChanged(interruptionFilter);
            }
            break;
        case MSG_ON_NOTIFICATION_CHANNEL_MODIFIED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                String pkgName = (String) args.arg1;
                UserHandle user = (UserHandle) args.arg2;
                NotificationChannel channel = (NotificationChannel) args.arg3;
                int modificationType = (int) args.arg4;
                onNotificationChannelModified(pkgName, user, channel, modificationType);
            }
            break;
        case MSG_ON_NOTIFICATION_CHANNEL_GROUP_MODIFIED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                String pkgName = (String) args.arg1;
                UserHandle user = (UserHandle) args.arg2;
                NotificationChannelGroup group = (NotificationChannelGroup) args.arg3;
                int modificationType = (int) args.arg4;
                onNotificationChannelGroupModified(pkgName, user, group, modificationType);
            }
            break;
    }
}",1,,,0,[@Override],[@Override],0,,,,"1,2","3,4,5",1,5,1,"The code change is that two new cases (MSG\_ON\_NOTIFICATION\_CHANNEL\_MODIFIED and MSG\_ON\_NOTIFICATION\_CHANNEL\_GROUP\_MODIFIED) have been added to the switch statement, and the method called in the case of MSG\_ON\_NOTIFICATION\_REMOVED has changed from onNotificationRemoved(sbn, rankingMap) to onNotificationRemoved(sbn, rankingMap, reason).","The new cases added to the switch statement won't cause compatibility issues because they are new conditions that won't affect the previous cases. However, the change of method called in the case of MSG\_ON\_NOTIFICATION\_REMOVED may cause compatibility issues because it potentially returns different values or types. Thus, the CI type is 1."
128,<android.app.EnterTransitionCoordinator: void onTransitionsComplete()>,25,26,,,,"{
    moveSharedElementsFromOverlay();
    final ViewGroup decorView = getDecor();
    if (decorView != null) {
        decorView.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED);
    }
}","{
    moveSharedElementsFromOverlay();
    final ViewGroup decorView = getDecor();
    if (decorView != null) {
        decorView.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED);
        Window window = getWindow();
        if (window != null && mReplacedBackground == decorView.getBackground()) {
            window.setBackgroundDrawable(null);
        }
    }
}",1,,,0,[@Override],[@Override],0,,,,"1,2","3,4",1,3,1,"The code change is a control dependency change. Specifically, a new if statement has been added to check whether the window is null and whether the background of the decorView is equal to mReplacedBackground. If the condition is true, the background of the window will be set to null.","The new if statement added in the late version could cause the API to behave differently. Specifically, if the window is not null and the background of the decorView is equal to mReplacedBackground, the background of the window will be set to null in the late version, while in the early version, the background of the window will not be changed. This change could lead to different return values or types, so it is a Compatibility Issue caused by potential different return values or types."
129,<android.widget.VideoView: void stopPlayback()>,25,26,,,,"{
    if (mMediaPlayer != null) {
        mMediaPlayer.stop();
        mMediaPlayer.release();
        mMediaPlayer = null;
        mCurrentState = STATE_IDLE;
        mTargetState = STATE_IDLE;
        AudioManager am = (AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE);
        am.abandonAudioFocus(null);
    }
}","{
    if (mMediaPlayer != null) {
        mMediaPlayer.stop();
        mMediaPlayer.release();
        mMediaPlayer = null;
        mCurrentState = STATE_IDLE;
        mTargetState = STATE_IDLE;
        mAudioManager.abandonAudioFocus(null);
    }
}",1,,,0,,,0,,,,"1,2",4,0,5,0,"In the implementation of the VideoView's stopPlayback() method, the way of getting the AudioManager instance has been changed from (AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE) to mAudioManager. This is an example of Dependent API changed.","Although the way of getting the AudioManager instance has been changed, the behavior of the stopPlayback() method remains the same. Therefore, this change will not cause any Compatibility Issue."
130,<android.app.Notification.Action.Builder: Action build()>,25,26,,,,"{
    RemoteInput[] remoteInputs = mRemoteInputs != null ? mRemoteInputs.toArray(new RemoteInput[mRemoteInputs.size()]) : null;
    return new Action(mIcon, mTitle, mIntent, mExtras, remoteInputs, mAllowGeneratedReplies);
}","{
    ArrayList<RemoteInput> dataOnlyInputs = new ArrayList<>();
    RemoteInput[] previousDataInputs = (RemoteInput[]) mExtras.getParcelableArray(EXTRA_DATA_ONLY_INPUTS);
    if (previousDataInputs != null) {
        for (RemoteInput input : previousDataInputs) {
            dataOnlyInputs.add(input);
        }
    }
    List<RemoteInput> textInputs = new ArrayList<>();
    if (mRemoteInputs != null) {
        for (RemoteInput input : mRemoteInputs) {
            if (input.isDataOnly()) {
                dataOnlyInputs.add(input);
            } else {
                textInputs.add(input);
            }
        }
    }
    if (!dataOnlyInputs.isEmpty()) {
        RemoteInput[] dataInputsArr = dataOnlyInputs.toArray(new RemoteInput[dataOnlyInputs.size()]);
        mExtras.putParcelableArray(EXTRA_DATA_ONLY_INPUTS, dataInputsArr);
    }
    RemoteInput[] textInputsArr = textInputs.isEmpty() ? null : textInputs.toArray(new RemoteInput[textInputs.size()]);
    return new Action(mIcon, mTitle, mIntent, mExtras, textInputsArr, mAllowGeneratedReplies);
}",1,"/**
 * Combine all of the options that have been set and return a new {@link Action}
 * object.
 * @return the built action
 */
","/**
 * Combine all of the options that have been set and return a new {@link Action}
 * object.
 * @return the built action
 */
",0,,,0,,,,"1,2","1,3,4,5",1,"1,5",1,"The late implementation has changed the way it processes the remoteInputs. Instead of directly passing the `mRemoteInputs` to the Action constructor, the late version separates the `mRemoteInputs` into two types, `dataOnlyInputs` and `textInputs`, and stores the `dataOnlyInputs` in the `mExtras` before passing the `textInputs` to the Action constructor. Thus, the change type is 1 (Return statement changed) and 5 (Dependent API changed).","The change in the processing of remoteInputs could lead to different behaviors of the API and cause compatibility issues, as the late version might pass a different set of remoteInputs to the Action constructor. Therefore, the CI type is 1 (Compatibility Issue caused by potential different return values or types)."
131,"<android.app.SharedPreferencesImpl.EditorImpl: Editor putInt(String,int)>",25,26,,,,"{
    synchronized (this) {
        mModified.put(key, value);
        return this;
    }
}","{
    synchronized (mLock) {
        mModified.put(key, value);
        return this;
    }
}",1,,,0,,,0,,,,1,4,0,4,0,"The code change only involves the object being locked in the synchronized statement, from 'this' to 'mLock'. So it belongs to the 'Other statement changed' category.","The change of the locked object does not affect the return value or exception handling of the API. Therefore, there is no Compatibility Issue."
132,<android.appwidget.AppWidgetHost: int allocateAppWidgetId()>,26,27,,,,"{
    try {
        return sService.allocateAppWidgetId(mContextOpPackageName, mHostId);
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}","{
    if (sService == null) {
        return -1;
    }
    try {
        return sService.allocateAppWidgetId(mContextOpPackageName, mHostId);
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}",1,"/**
 * Get a appWidgetId for a host in the calling process.
 *
 * @return a appWidgetId
 */
","/**
 * Get a appWidgetId for a host in the calling process.
 *
 * @return a appWidgetId
 */
",0,,,0,,,,1,"1,3",1,3,1,"In the early version, the function only has a try-catch statement and returns the result of calling the `allocateAppWidgetId` method of `sService`. In the late version, an additional if-statement has been added to check if `sService` is null, and returns -1 if it is. The try-catch statement remains unchanged. The code change type is 3 (Control dependency changed).","The change in the control dependency could lead to a compatibility issue. In the late version, if `sService` is null, the function will return -1 instead of throwing a `RuntimeException` as in the early version. Therefore, the potential different return values or types could cause a compatibility issue (CI type 1)."
133,<android.webkit.WebView: void shortPressOnTextField()>,4,5,<android.webkit.WebView: void shortPressOnTextField()>,<android.webkit.WebView: void shortPressOnTextField()>,0,"{
    if (inEditingMode()) {
        View v = mTextEntry;
        int x = viewToContent((v.getLeft() + v.getRight()) >> 1);
        int y = viewToContent((v.getTop() + v.getBottom()) >> 1);
        nativeMotionUp(x, y, mNavSlop, true);
    }
}","{
    if (inEditingMode()) {
        View v = mWebTextView;
        int x = viewToContentX((v.getLeft() + v.getRight()) >> 1);
        int y = viewToContentY((v.getTop() + v.getBottom()) >> 1);
        nativeTextInputMotionUp(x, y);
    }
}",1,"/*package*/
","/*package*/
",0,,,0,,,0,"1,2","4,5",0,"1,3,5",1,"The implementation of the `shortPressOnTextField` method has been changed between the two versions. The variable `mTextEntry` has been replaced with `mWebTextView`. The method `viewToContent` has been replaced with `viewToContentX` and `viewToContentY`. The method `nativeMotionUp` has been replaced with `nativeTextInputMotionUp`. These changes lead to changes in the return statement, control dependency, and dependent API.","The changes in the return statement, control dependency, and dependent API can lead to potential compatibility issues. The method `shortPressOnTextField` may return different values or behaviors in the two versions, which could lead to a compatibility issue. For example, the new method `nativeTextInputMotionUp` may behave differently than the old method `nativeMotionUp`, which could cause issues in certain scenarios."
134,<android.webkit.MimeTypeMap: String getFileExtensionFromUrl(String)>,4,5,<android.webkit.MimeTypeMap: String getFileExtensionFromUrl(String)>,<android.webkit.MimeTypeMap: String getFileExtensionFromUrl(String)>,0,"{
    if (url != null && url.length() > 0) {
        int query = url.lastIndexOf('?');
        if (query > 0) {
            url = url.substring(0, query);
        }
        int filenamePos = url.lastIndexOf('/');
        String filename = 0 <= filenamePos ? url.substring(filenamePos + 1) : url;
        // consider it valid for our matching purposes:
        if (filename.length() > 0 && Pattern.matches(""[a-zA-Z_0-9\\.\\-\\(\\)]+"", filename)) {
            int dotPos = filename.lastIndexOf('.');
            if (0 <= dotPos) {
                return filename.substring(dotPos + 1);
            }
        }
    }
    return """";
}","{
    if (url != null && url.length() > 0) {
        int query = url.lastIndexOf('?');
        if (query > 0) {
            url = url.substring(0, query);
        }
        int filenamePos = url.lastIndexOf('/');
        String filename = 0 <= filenamePos ? url.substring(filenamePos + 1) : url;
        // consider it valid for our matching purposes:
        if (filename.length() > 0 && Pattern.matches(""[a-zA-Z_0-9\\.\\-\\(\\)]+"", filename)) {
            int dotPos = filename.lastIndexOf('.');
            if (0 <= dotPos) {
                return filename.substring(dotPos + 1);
            }
        }
    }
    return """";
}",0,"/**
 * Returns the file extension or an empty string iff there is no
 * extension.
 */
","/**
 * Returns the file extension or an empty string iff there is no
 * extension. This method is a convenience method for obtaining the
 * extension of a url and has undefined results for other Strings.
 * @param url
 * @return The file extension of the given url.
 */
",1,,,0,,,0,0,0,0,0,0,"There is no difference between the early version and the late version of the given Android public API, including its implementations and annotations.","As there is no change in the API implementation, there is no potential compatibility issue caused by different return values or types, or different exception handlings."
135,<android.content.SyncManager.SyncQueue: void removeByKey(String)>,5,6,<android.content.SyncManager.SyncQueue: void removeByKey(String)>,<android.content.SyncManager.SyncQueue: void removeByKey(String)>,0, ,"{
    if (DEBUG_CHECK_DATA_CONSISTENCY)
        debugCheckDataStructures(true);
    SyncOperation operationToRemove = mOpsByKey.remove(operationKey);
    if (!mOpsByWhen.remove(operationToRemove)) {
        throw new IllegalStateException(""unable to find "" + operationToRemove + "" in mOpsByWhen"");
    }
    if (!mSyncStorageEngine.deleteFromPending(operationToRemove.pendingOperation)) {
        final String errorMessage = ""unable to find pending row for "" + operationToRemove;
        Log.e(TAG, errorMessage, new IllegalStateException(errorMessage));
    }
    if (DEBUG_CHECK_DATA_CONSISTENCY)
        debugCheckDataStructures(true);
}",1,,,0,,,0,,,0,"1,2","3,4",2,3,1,"The implementation of the method `removeByKey` has been added in late version, which is a control-dependency change.","The implementation of the method `removeByKey` has changed in late version, which potentially leads to different return values or types. Therefore, it is a compatibility issue caused by potential different return values or types."
136,"<android.provider.ContactsContract.QuickContact: void showQuickContact(Context,View,Uri,int,String[])>",5,6,"<android.provider.ContactsContract.QuickContact: void showQuickContact(Context,View,Uri,int,String[])>","<android.provider.ContactsContract.QuickContact: void showQuickContact(Context,View,Uri,int,String[])>",0,"{
    // Find location and bounds of target view
    final int[] location = new int[2];
    target.getLocationOnScreen(location);
    final Rect rect = new Rect();
    rect.left = location[0];
    rect.top = location[1];
    rect.right = rect.left + target.getWidth();
    rect.bottom = rect.top + target.getHeight();
    // Trigger with obtained rectangle
    showQuickContact(context, rect, lookupUri, mode, excludeMimes);
}","{
    // Find location and bounds of target view
    final int[] location = new int[2];
    target.getLocationOnScreen(location);
    final Rect rect = new Rect();
    rect.left = location[0];
    rect.top = location[1];
    rect.right = rect.left + target.getWidth();
    rect.bottom = rect.top + target.getHeight();
    // Trigger with obtained rectangle
    showQuickContact(context, rect, lookupUri, mode, excludeMimes);
}",0,"/**
 * Trigger a dialog that lists the various methods of interacting with
 * the requested {@link Contacts} entry. This may be based on available
 * {@link Data} rows under that contact, and may also include social
 * status and presence details.
 *
 * @param context The parent {@link Context} that may be used as the
 * parent for this dialog.
 * @param target Specific {@link View} from your layout that this dialog
 * should be centered around. In particular, if the dialog
 * has a ""callout"" arrow, it will be pointed and centered
 * around this {@link View}.
 * @param lookupUri A {@link ContactsContract.Contacts#CONTENT_LOOKUP_URI} style
 * {@link Uri} that describes a specific contact to feature
 * in this dialog.
 * @param mode Any of {@link #MODE_SMALL}, {@link #MODE_MEDIUM}, or
 * {@link #MODE_LARGE}, indicating the desired dialog size,
 * when supported.
 * @param excludeMimes Optional list of {@link Data#MIMETYPE} MIME-types
 * to exclude when showing this dialog. For example, when
 * already viewing the contact details card, this can be used
 * to omit the details entry from the dialog.
 */
","/**
 * Trigger a dialog that lists the various methods of interacting with
 * the requested {@link Contacts} entry. This may be based on available
 * {@link ContactsContract.Data} rows under that contact, and may also
 * include social status and presence details.
 *
 * @param context The parent {@link Context} that may be used as the
 * parent for this dialog.
 * @param target Specific {@link View} from your layout that this dialog
 * should be centered around. In particular, if the dialog
 * has a ""callout"" arrow, it will be pointed and centered
 * around this {@link View}.
 * @param lookupUri A {@link ContactsContract.Contacts#CONTENT_LOOKUP_URI} style
 * {@link Uri} that describes a specific contact to feature
 * in this dialog.
 * @param mode Any of {@link #MODE_SMALL}, {@link #MODE_MEDIUM}, or
 * {@link #MODE_LARGE}, indicating the desired dialog size,
 * when supported.
 * @param excludeMimes Optional list of {@link Data#MIMETYPE} MIME-types
 * to exclude when showing this dialog. For example, when
 * already viewing the contact details card, this can be used
 * to omit the details entry from the dialog.
 */
",1,,,0,,,0,0,0,0,0,0,"The code is exactly the same in both early and late versions, thus no change.","There is no difference in the code, so no compatibility issue could arise."
137,<android.webkit.WebView: void shortPressOnTextField()>,6,7,<android.webkit.WebView: void shortPressOnTextField()>,<android.webkit.WebView: void shortPressOnTextField()>,0,"{
    if (inEditingMode()) {
        View v = mWebTextView;
        int x = viewToContentX((v.getLeft() + v.getRight()) >> 1);
        int y = viewToContentY((v.getTop() + v.getBottom()) >> 1);
        nativeTextInputMotionUp(x, y);
    }
}","{
    if (inEditingMode()) {
        View v = mWebTextView;
        int x = viewToContentX((v.getLeft() + v.getRight()) >> 1);
        int y = viewToContentY((v.getTop() + v.getBottom()) >> 1);
        displaySoftKeyboard(true);
        nativeTextInputMotionUp(x, y);
    }
}",1,"/*package*/
","/*package*/
",0,,,0,,,0,2,4,0,4,0,"The new implementation of the method includes a call to the `displaySoftKeyboard(true)` method, which is not present in the earlier version. This is not a return statement change, exception handling change, or control dependency change, so it is classified as an ""other statement change"" (code change type 4).","Although there is a new statement in the late version, it does not cause a compatibility issue as it does not change the method's return type or value, nor does it change the exception handling. Therefore, the Compatibility Issue type is 0 (no compatibility issue)."
138,<android.hardware.Camera.Parameters: List<Integer> getSupportedPictureFormats()>,6,7,<android.hardware.Camera.Parameters: List<Integer> getSupportedPictureFormats()>,<android.hardware.Camera.Parameters: List<Integer> getSupportedPictureFormats()>,0,"{
    String str = get(KEY_PICTURE_SIZE + SUPPORTED_VALUES_SUFFIX);
    return splitInt(str);
}","{
    String str = get(KEY_PICTURE_FORMAT + SUPPORTED_VALUES_SUFFIX);
    ArrayList<Integer> formats = new ArrayList<Integer>();
    for (String s : split(str)) {
        int f = pixelFormatForCameraFormat(s);
        if (f == PixelFormat.UNKNOWN)
            continue;
        formats.add(f);
    }
    return formats;
}",1,"/**
 * Gets the supported picture formats.
 *
 * @return a List of Integer objects (values are PixelFormat.XXX). null
 * if picture setting is not supported.
 */
","/**
 * Gets the supported picture formats.
 *
 * @return a List of Integer objects (values are PixelFormat.XXX). This
 * method will always return a list with at least one element.
 */
",1,,,0,,,0,"1,2","1,3,4",1,"1,5",1,"The implementation of the `getSupportedPictureFormats` method has changed significantly between versions 6 and 7. In the early version, the method uses the `KEY_PICTURE_SIZE` constant and the `splitInt` method to return a list of supported picture formats. In the late version, the method uses the `KEY_PICTURE_FORMAT` constant and a for loop to populate and return an `ArrayList` of supported picture formats. Additionally, the late version calls the `pixelFormatForCameraFormat` method to convert camera format strings to pixel format integers.","The change in implementation could potentially lead to compatibility issues as the method may return different values in different versions. Specifically, the use of different constants (`KEY_PICTURE_SIZE` vs `KEY_PICTURE_FORMAT`) and different methods (`splitInt` vs a for loop with `pixelFormatForCameraFormat`) to retrieve and process the supported picture formats could result in differences in the returned list of supported formats. Therefore, this is classified as a compatibility issue caused by potential different return values or types."
139,<android.webkit.HTML5VideoViewProxy: void handleMessage(Message)>,7,8,<android.webkit.HTML5VideoViewProxy: void handleMessage(Message)>,<android.webkit.HTML5VideoViewProxy: void handleMessage(Message)>,0,"{
    // This executes on the UI thread.
    switch(msg.what) {
        case PLAY:
            {
                String url = (String) msg.obj;
                WebChromeClient client = mWebView.getWebChromeClient();
                if (client != null) {
                    VideoPlayer.play(url, mSeekPosition, this, client);
                }
                break;
            }
        case SEEK:
            {
                Integer time = (Integer) msg.obj;
                mSeekPosition = time;
                VideoPlayer.seek(mSeekPosition, this);
                break;
            }
        case PAUSE:
            {
                VideoPlayer.pause(this);
                break;
            }
        case ERROR:
            {
                WebChromeClient client = mWebView.getWebChromeClient();
                if (client != null) {
                    client.onHideCustomView();
                }
                break;
            }
        case LOAD_DEFAULT_POSTER:
            {
                WebChromeClient client = mWebView.getWebChromeClient();
                if (client != null) {
                    doSetPoster(client.getDefaultVideoPoster());
                }
                break;
            }
    }
}","{
    // This executes on the UI thread.
    switch(msg.what) {
        case PLAY:
            {
                String url = (String) msg.obj;
                WebChromeClient client = mWebView.getWebChromeClient();
                if (client != null) {
                    VideoPlayer.play(url, mSeekPosition, this, client);
                }
                break;
            }
        case SEEK:
            {
                Integer time = (Integer) msg.obj;
                mSeekPosition = time;
                VideoPlayer.seek(mSeekPosition, this);
                break;
            }
        case PAUSE:
            {
                VideoPlayer.pause(this);
                break;
            }
        case ENDED:
        case ERROR:
            {
                WebChromeClient client = mWebView.getWebChromeClient();
                if (client != null) {
                    client.onHideCustomView();
                }
                break;
            }
        case LOAD_DEFAULT_POSTER:
            {
                WebChromeClient client = mWebView.getWebChromeClient();
                if (client != null) {
                    doSetPoster(client.getDefaultVideoPoster());
                }
                break;
            }
        case TIMEUPDATE:
            {
                if (VideoPlayer.isPlaying(this)) {
                    sendTimeupdate();
                }
                break;
            }
    }
}",1,"// Handler for the messages from WebCore thread to the UI thread.
","// Handler for the messages from WebCore or Timer thread to the UI thread.
",1,[@Override],[@Override],0,,,0,"1,2",3,0,"3,4",1,"The implementation of the method handleMessage(Message) has changed in terms of control dependency. Specifically, a new case ""TIMEUPDATE"" is introduced. Also, the case ""ENDED"" is merged with the case ""ERROR"".","The new case ""TIMEUPDATE"" and the merged case ""ENDED"" with ""ERROR"" could cause the API to behave differently in the late version, specifically, the API may invoke different methods for different `msg.what`. Therefore, the return value or type may potentially change, which leads to a compatibility issue of type 1."
141,"<android.content.ContentProvider: int bulkInsert(Uri,ContentValues[])>",8,9,"<android.content.ContentProvider: int bulkInsert(Uri,ContentValues[])>","<android.content.ContentProvider: int bulkInsert(Uri,ContentValues[])>",0,"{
    int numValues = values.length;
    for (int i = 0; i < numValues; i++) {
        insert(uri, values[i]);
    }
    return numValues;
}","{
    int numValues = values.length;
    for (int i = 0; i < numValues; i++) {
        insert(uri, values[i]);
    }
    return numValues;
}",0,"/**
 * Implement this to insert a set of new rows, or the default implementation will
 * iterate over the values and call {@link #insert} on each of them.
 * As a courtesy, call {@link ContentResolver#notifyChange(android.net.Uri ,android.database.ContentObserver) notifyChange()}
 * after inserting.
 * This method can be called from multiple
 * threads, as described in
 * <a href=""{@docRoot}guide/topics/fundamentals.html#procthread"">Application Fundamentals:
 * Processes and Threads</a>.
 *
 * @param uri The content:// URI of the insertion request.
 * @param values An array of sets of column_name/value pairs to add to the database.
 * @return The number of values that were inserted.
 */
","/**
 * Override this to handle requests to insert a set of new rows, or the
 * default implementation will iterate over the values and call
 * {@link #insert} on each of them.
 * As a courtesy, call {@link ContentResolver#notifyChange(android.net.Uri ,android.database.ContentObserver) notifyChange()}
 * after inserting.
 * This method can be called from multiple threads, as described in
 * <a href=""{@docRoot}guide/topics/fundamentals.html#procthread"">Application Fundamentals:
 * Processes and Threads</a>.
 *
 * @param uri The content:// URI of the insertion request.
 * @param values An array of sets of column_name/value pairs to add to the database.
 * @return The number of values that were inserted.
 */
",1,,,0,,,0,0,0,0,0,0,The code snippets provided in the Early_Implementation and Late_Implementation are identical. There is no code change between the two versions.,"The API implementation and annotation in both versions are identical, so there is no potential Compatibility Issue."
142,<android.widget.ProgressBar: boolean isIndeterminate()>,8,9,<android.widget.ProgressBar: boolean isIndeterminate()>,<android.widget.ProgressBar: boolean isIndeterminate()>,0,"{
    return mIndeterminate;
}","{
    return mIndeterminate;
}",0,"/**
 * <p>Indicate whether this progress bar is in indeterminate mode.</p>
 *
 * @return true if the progress bar is in indeterminate mode
 */
","/**
 * <p>Indicate whether this progress bar is in indeterminate mode.</p>
 *
 * @return true if the progress bar is in indeterminate mode
 */
",0,[@ViewDebug.ExportedProperty],[@ViewDebug.ExportedProperty(category = "progress")],1,,,0,0,0,0,5,0,"The signature has not changed, but the annotation has changed from @ViewDebug.ExportedProperty to @ViewDebug.ExportedProperty(category = ""progress""). This is considered a dependent API change (change type 5) since the annotation is a dependent API.","The change in the annotation does not affect the behavior of the API, so there is no compatibility issue (CI type 0)."
143,<android.app.Activity: void performStop()>,9,10,<android.app.Activity: void performStop()>,<android.app.Activity: void performStop()>,0,"{
    if (!mStopped) {
        if (mWindow != null) {
            mWindow.closeAllPanels();
        }
        mCalled = false;
        mInstrumentation.callActivityOnStop(this);
        if (!mCalled) {
            throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onStop()"");
        }
        synchronized (mManagedCursors) {
            final int N = mManagedCursors.size();
            for (int i = 0; i < N; i++) {
                ManagedCursor mc = mManagedCursors.get(i);
                if (!mc.mReleased) {
                    mc.mCursor.deactivate();
                    mc.mReleased = true;
                }
            }
        }
        mStopped = true;
    }
    mResumed = false;
}","{
    if (!mStopped) {
        if (mWindow != null) {
            mWindow.closeAllPanels();
        }
        mCalled = false;
        mInstrumentation.callActivityOnStop(this);
        if (!mCalled) {
            throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onStop()"");
        }
        synchronized (mManagedCursors) {
            final int N = mManagedCursors.size();
            for (int i = 0; i < N; i++) {
                ManagedCursor mc = mManagedCursors.get(i);
                if (!mc.mReleased) {
                    mc.mCursor.deactivate();
                    mc.mReleased = true;
                }
            }
        }
        mStopped = true;
    }
}",1,,,0,,,0,,,0,1,4,0,3,0,"The only change between the two versions is that the statement `mResumed = false;` has been removed from the late version. This statement is not related to return statement, exception handling statement, or control dependency. Therefore, the code change type is 4 (Other statement changed). However, since this statement does not affect the behavior of the API, it does not belong to any of the change types 1, 2, or 3.","The change in the code does not affect the behavior of the API. Therefore, there is no Compatibility Issue (CI) in this case."
144,"<android.database.sqlite.SQLiteDatabase: long replaceOrThrow(String,String,ContentValues)>",9,10,"<android.database.sqlite.SQLiteDatabase: long replaceOrThrow(String,String,ContentValues)>","<android.database.sqlite.SQLiteDatabase: long replaceOrThrow(String,String,ContentValues)>",0,"{
    return insertWithOnConflict(table, nullColumnHack, initialValues, CONFLICT_REPLACE);
}","{
    return insertWithOnConflict(table, nullColumnHack, initialValues, CONFLICT_REPLACE);
}",0,"/**
 * Convenience method for replacing a row in the database.
 *
 * @param table the table in which to replace the row
 * @param nullColumnHack SQL doesn't allow inserting a completely empty row,
 * so if initialValues is empty this row will explicitly be
 * assigned a NULL value
 * @param initialValues this map contains the initial column values for
 * the row. The key
 * @throws SQLException
 * @return the row ID of the newly inserted row, or -1 if an error occurred
 */
","/**
 * Convenience method for replacing a row in the database.
 *
 * @param table the table in which to replace the row
 * @param nullColumnHack optional; may be <code>null</code>.
 * SQL doesn't allow inserting a completely empty row without
 * naming at least one column name.  If your provided <code>initialValues</code> is
 * empty, no column names are known and an empty row can't be inserted.
 * If not set to null, the <code>nullColumnHack</code> parameter
 * provides the name of nullable column name to explicitly insert a NULL into
 * in the case where your <code>initialValues</code> is empty.
 * @param initialValues this map contains the initial column values for
 * the row. The key
 * @throws SQLException
 * @return the row ID of the newly inserted row, or -1 if an error occurred
 */
",1,,,0,,,0,0,0,0,0,0,There's no change in the code implementation and annotation between early and late versions.,There's no potential compatibility issue since there's no changes in code implementation and annotation between early and late versions.
145,<android.widget.AbsListView: void hideSelector()>,13,14,<android.widget.AbsListView: void hideSelector()>,<android.widget.AbsListView: void hideSelector()>,0,"{
    if (mSelectedPosition != INVALID_POSITION) {
        if (mLayoutMode != LAYOUT_SPECIFIC) {
            mResurrectToPosition = mSelectedPosition;
        }
        if (mNextSelectedPosition >= 0 && mNextSelectedPosition != mSelectedPosition) {
            mResurrectToPosition = mNextSelectedPosition;
        }
        setSelectedPositionInt(INVALID_POSITION);
        setNextSelectedPositionInt(INVALID_POSITION);
        mSelectedTop = 0;
        mSelectorShowing = false;
    }
}","{
    if (mSelectedPosition != INVALID_POSITION) {
        if (mLayoutMode != LAYOUT_SPECIFIC) {
            mResurrectToPosition = mSelectedPosition;
        }
        if (mNextSelectedPosition >= 0 && mNextSelectedPosition != mSelectedPosition) {
            mResurrectToPosition = mNextSelectedPosition;
        }
        setSelectedPositionInt(INVALID_POSITION);
        setNextSelectedPositionInt(INVALID_POSITION);
        mSelectedTop = 0;
    }
}",1,,,0,,,0,,,0,1,4,0,3,0,"The control dependency has changed, specifically the statement ""mSelectorShowing = false;"" has been deleted.","The deletion of ""mSelectorShowing = false;"" does not affect the return value or exception handling of the API, so it does not cause a Compatibility Issue."
146,"<android.database.CursorWindow: String getString(int,int)>",13,14,"<android.database.CursorWindow: String getString(int,int)>","<android.database.CursorWindow: String getString(int,int)>",0,"{
    acquireReference();
    try {
        return getString_native(row - mStartPos, col);
    } finally {
        releaseReference();
    }
}","{
    acquireReference();
    try {
        return nativeGetString(mWindowPtr, row - mStartPos, column);
    } finally {
        releaseReference();
    }
}",1,"/**
 * Returns a String for the given field.
 *
 * @param row the row to read from, row - getStartPosition() being the actual row in the window
 * @param col the column to read from
 * @return a String value for the given field
 */
","/**
 * Gets the value of the field at the specified row and column index as a string.
 * <p>
 * The result is determined as follows:
 * <ul>
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_NULL}, then the result
 * is <code>null</code>.</li>
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_STRING}, then the result
 * is the string value.</li>
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_INTEGER}, then the result
 * is a string representation of the integer in decimal, obtained by formatting the
 * value with the <code>printf</code> family of functions using
 * format specifier <code>%lld</code>.</li>
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_FLOAT}, then the result
 * is a string representation of the floating-point value in decimal, obtained by
 * formatting the value with the <code>printf</code> family of functions using
 * format specifier <code>%g</code>.</li>
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_BLOB}, then a
 * {@link SQLiteException} is thrown.</li>
 * </ul>
 * </p>
 *
 * @param row The zero-based row index, relative to the cursor window's
 * start position ({@link #getStartPosition()}).
 * @param column The zero-based column index.
 * @return The value of the field as a string.
 */
",1,,,0,,,0,"1,2","1,5",1,5,1,"The method 'getString\_native(row - mStartPos, col)' has been changed to 'nativeGetString(mWindowPtr, row - mStartPos, column)', which means dependent API has changed.","The dependent API 'getString\_native(row - mStartPos, col)' has been changed to 'nativeGetString(mWindowPtr, row - mStartPos, column)', which potentially could lead to different return value, and thus the CI type is 1."
147,<android.view.View: boolean dispatchHoverEvent(MotionEvent)>,14,15,<android.view.View: boolean dispatchHoverEvent(MotionEvent)>,<android.view.View: boolean dispatchHoverEvent(MotionEvent)>,0,"{
    // noinspection SimplifiableIfStatement
    if (mOnHoverListener != null && (mViewFlags & ENABLED_MASK) == ENABLED && mOnHoverListener.onHover(this, event)) {
        return true;
    }
    return onHoverEvent(event);
}","{
    // noinspection SimplifiableIfStatement
    ListenerInfo li = mListenerInfo;
    if (li != null && li.mOnHoverListener != null && (mViewFlags & ENABLED_MASK) == ENABLED && li.mOnHoverListener.onHover(this, event)) {
        return true;
    }
    return onHoverEvent(event);
}",1,"/**
 * Dispatch a hover event.
 * <p>
 * Do not call this method directly.
 * Call {@link #dispatchGenericMotionEvent(MotionEvent)} instead.
 * </p>
 *
 * @param event The motion event to be dispatched.
 * @return True if the event was handled by the view, false otherwise.
 */
","/**
 * Dispatch a hover event.
 * <p>
 * Do not call this method directly.
 * Call {@link #dispatchGenericMotionEvent(MotionEvent)} instead.
 * </p>
 *
 * @param event The motion event to be dispatched.
 * @return True if the event was handled by the view, false otherwise.
 */
",0,,,0,,,0,1,4,1,5,1,"The Early implementation uses `mOnHoverListener` directly to check if it's not null, while the Late implementation uses `mListenerInfo` to get the `mOnHoverListener`. So the code change type is 5, Dependent API changed.","The change of dependent API could potentially lead to a different behavior, as the `li.mOnHoverListener` might be null in the late version even if `mOnHoverListener` in the early version is not null, which can result in a compatibility issue of type 1, Compatibility Issue caused by potential different return values or types."
148,"<android.database.CursorWindow: String getString(int,int)>",14,15,"<android.database.CursorWindow: String getString(int,int)>","<android.database.CursorWindow: String getString(int,int)>",0,"{
    acquireReference();
    try {
        return nativeGetString(mWindowPtr, row - mStartPos, column);
    } finally {
        releaseReference();
    }
}","{
    acquireReference();
    try {
        return nativeGetString(mWindowPtr, row - mStartPos, column);
    } finally {
        releaseReference();
    }
}",0,"/**
 * Gets the value of the field at the specified row and column index as a string.
 * <p>
 * The result is determined as follows:
 * <ul>
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_NULL}, then the result
 * is <code>null</code>.</li>
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_STRING}, then the result
 * is the string value.</li>
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_INTEGER}, then the result
 * is a string representation of the integer in decimal, obtained by formatting the
 * value with the <code>printf</code> family of functions using
 * format specifier <code>%lld</code>.</li>
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_FLOAT}, then the result
 * is a string representation of the floating-point value in decimal, obtained by
 * formatting the value with the <code>printf</code> family of functions using
 * format specifier <code>%g</code>.</li>
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_BLOB}, then a
 * {@link SQLiteException} is thrown.</li>
 * </ul>
 * </p>
 *
 * @param row The zero-based row index, relative to the cursor window's
 * start position ({@link #getStartPosition()}).
 * @param column The zero-based column index.
 * @return The value of the field as a string.
 */
","/**
 * Gets the value of the field at the specified row and column index as a string.
 * <p>
 * The result is determined as follows:
 * <ul>
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_NULL}, then the result
 * is <code>null</code>.</li>
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_STRING}, then the result
 * is the string value.</li>
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_INTEGER}, then the result
 * is a string representation of the integer in decimal, obtained by formatting the
 * value with the <code>printf</code> family of functions using
 * format specifier <code>%lld</code>.</li>
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_FLOAT}, then the result
 * is a string representation of the floating-point value in decimal, obtained by
 * formatting the value with the <code>printf</code> family of functions using
 * format specifier <code>%g</code>.</li>
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_BLOB}, then a
 * {@link SQLiteException} is thrown.</li>
 * </ul>
 * </p>
 *
 * @param row The zero-based row index.
 * @param column The zero-based column index.
 * @return The value of the field as a string.
 */
",1,,,0,,,0,0,0,0,0,0,The code did not change between the two versions.,"There is no change in the behavior of the API, so there is no compatibility issue."
149,<android.content.AsyncTaskLoader.LoadTask: void onPostExecute(D)>,15,16,<android.content.AsyncTaskLoader.LoadTask: void onPostExecute(D)>,<android.content.AsyncTaskLoader.LoadTask: void onPostExecute(D)>,0,"{
    if (DEBUG)
        Slog.v(TAG, this + "" onPostExecute"");
    try {
        AsyncTaskLoader.this.dispatchOnLoadComplete(this, data);
    } finally {
        done.countDown();
    }
}","{
    if (DEBUG)
        Slog.v(TAG, this + "" onPostExecute"");
    try {
        AsyncTaskLoader.this.dispatchOnLoadComplete(this, data);
    } finally {
        mDone.countDown();
    }
}",1,"/* Runs on the UI thread */
","/* Runs on the UI thread */
",0,[@Override],[@Override],0,,,0,"1,2",5,0,4,0,"The variable used in the finally block has changed from 'done' to 'mDone' and it is an instance variable, so it is an 'Other statement changed' change type.","Since the change is only in an instance variable, it does not affect the return value or exception handling of the API, so there is no Compatibility Issue."
150,"<android.widget.RemoteViews: void setInt(int,String,int)>",15,16,"<android.widget.RemoteViews: void setInt(int,String,int)>","<android.widget.RemoteViews: void setInt(int,String,int)>",0,"{
    addAction(new ReflectionAction(viewId, methodName, ReflectionAction.INT, value));
}","{
    addAction(new ReflectionAction(viewId, methodName, ReflectionAction.INT, value));
}",0,"/**
 * Call a method taking one int on a view in the layout for this RemoteViews.
 *
 * @param viewId The id of the view whose text should change
 * @param methodName The name of the method to call.
 * @param value The value to pass to the method.
 */
","/**
 * Call a method taking one int on a view in the layout for this RemoteViews.
 *
 * @param viewId The id of the view on which to call the method.
 * @param methodName The name of the method to call.
 * @param value The value to pass to the method.
 */
",1,,,0,,,0,0,0,0,0,0,There is no change between the early and late versions of the implementation.,"Since there is no change in the code, there is no compatibility issue that could arise."
151,<android.webkit.WebView: boolean shouldDelayChildPressedState()>,15,16,<android.webkit.WebView: boolean shouldDelayChildPressedState()>,<android.webkit.WebView: boolean shouldDelayChildPressedState()>,0,"{
    return true;
}","{
    return mProvider.getViewDelegate().shouldDelayChildPressedState();
}",1,,,0,[@Override],"[@Deprecated, @Override]",1,,,0,"1,2","1,5",1,"1,5",1,"The return statement has changed from return true to return mProvider.getViewDelegate().shouldDelayChildPressedState(). The API potentially returns a different value because the return value is now determined by the result of the method shouldDelayChildPressedState() of the view delegate object, rather than a constant value. Also, the method implementation now relies on another API mProvider.getViewDelegate().shouldDelayChildPressedState(), which is a change of dependent API. Thus the code change type is 1,5.","As the return statement has changed from return true to return mProvider.getViewDelegate().shouldDelayChildPressedState(), the API potentially returns a different value, which could cause compatibility issues when the API is invoked in a different context or with different input. Therefore, the CI type is 1."
152,<android.server.search.SearchManagerService: ComponentName getWebSearchActivity()>,16,17,<android.server.search.SearchManagerService: ComponentName getWebSearchActivity()>,<android.server.search.SearchManagerService: ComponentName getWebSearchActivity()>,0,"{
    return getSearchables().getWebSearchActivity();
}","{
    return getSearchables(UserHandle.getCallingUserId()).getWebSearchActivity();
}",1,"/**
 * Gets the name of the web search activity.
 */
","/**
 * Gets the name of the web search activity.
 */
",0,,,0,,,0,"1,2","1,5",1,5,1,The change is due to the addition of the method argument `UserHandle.getCallingUserId()` in the late version of the `getSearchables()` method.,"The added argument in the `getSearchables()` method call can potentially lead to a different return value in the late version, resulting in a different value being returned by the `getWebSearchActivity()` method. This is a compatibility issue caused by potential different return values."
153,<android.webkit.AccessibilityInjector: void addAccessibilityApisIfNecessary()>,16,17,<android.webkit.AccessibilityInjector: void addAccessibilityApisIfNecessary()>,<android.webkit.AccessibilityInjector: void addAccessibilityApisIfNecessary()>,0,"{
    if (!isAccessibilityEnabled() || !isJavaScriptEnabled()) {
        return;
    }
    addTtsApis();
    addCallbackApis();
}","{
    if (!isAccessibilityEnabled() || !isJavaScriptEnabled()) {
        return;
    }
    addTtsApis();
    addCallbackApis();
}",0,"/**
 * Attempts to load scripting interfaces for accessibility.
 * <p>
 * This should be called when the window is attached.
 * </p>
 */
","/**
 * Attempts to load scripting interfaces for accessibility.
 * <p>
 * This should only be called before a page loads.
 */
",1,,,0,,,0,0,0,0,0,0,There is no difference between the two implementations.,"The two implementations are identical, so there is no Compatibility Issue."
154,"<android.webkit.AccessibilityInjector.CallbackHandler: void onResult(String,String)>",16,17,"<android.webkit.AccessibilityInjector.CallbackHandler: void onResult(String,String)>","<android.webkit.AccessibilityInjector.CallbackHandler: void onResult(String,String)>",0,"{
    final long resultId;
    try {
        resultId = Long.parseLong(id);
    } catch (NumberFormatException e) {
        return;
    }
    synchronized (mResultLock) {
        if (resultId > mResultId) {
            mResult = Boolean.parseBoolean(result);
            mResultId = resultId;
        }
        mResultLock.notifyAll();
    }
}","{
    if (DEBUG) {
        Log.w(TAG, ""Saw CVOX result of '"" + result + ""' for ID "" + id);
    }
    final int resultId;
    try {
        resultId = Integer.parseInt(id);
    } catch (NumberFormatException e) {
        return;
    }
    synchronized (mResultLock) {
        if (resultId > mResultId) {
            mResult = Boolean.parseBoolean(result);
            mResultId = resultId;
        } else {
            if (DEBUG) {
                Log.w(TAG, ""Result with ID "" + resultId + "" was stale vesus "" + mResultId);
            }
        }
        mResultLock.notifyAll();
    }
}",1,"/**
 * Callback exposed to JavaScript. Handles returning the result of a
 * request to a waiting (or potentially timed out) thread.
 *
 * @param id The result id of the request as a {@link String}.
 * @param result The result of the request as a {@link String}.
 */
","/**
 * Callback exposed to JavaScript. Handles returning the result of a
 * request to a waiting (or potentially timed out) thread.
 *
 * @param id The result id of the request as a {@link String}.
 * @param result The result of the request as a {@link String}.
 */
",0,[@SuppressWarnings("unused")],"[@JavascriptInterface, @SuppressWarnings(""unused"")]",1,,,0,"1,2","3,4,5",1,"1,3,4",1,"The return type of the method has not changed, but there are multiple differences between the two implementations.",2. The logging statement is added and the message is different in the late version.
155,"<android.app.Activity: boolean startNextMatchingActivity(Intent,Bundle)>",17,18,"<android.app.Activity: boolean startNextMatchingActivity(Intent,Bundle)>","<android.app.Activity: boolean startNextMatchingActivity(Intent,Bundle)>",0,"{
    if (mParent == null) {
        try {
            intent.setAllowFds(false);
            return ActivityManagerNative.getDefault().startNextMatchingActivity(mToken, intent, options);
        } catch (RemoteException e) {
        // Empty
        }
        return false;
    }
    throw new UnsupportedOperationException(""startNextMatchingActivity can only be called from a top-level activity"");
}","{
    if (mParent == null) {
        try {
            intent.migrateExtraStreamToClipData();
            intent.prepareToLeaveProcess();
            return ActivityManagerNative.getDefault().startNextMatchingActivity(mToken, intent, options);
        } catch (RemoteException e) {
        // Empty
        }
        return false;
    }
    throw new UnsupportedOperationException(""startNextMatchingActivity can only be called from a top-level activity"");
}",1,"/**
 * Special version of starting an activity, for use when you are replacing
 * other activity components.  You can use this to hand the Intent off
 * to the next Activity that can handle it.  You typically call this in
 * {@link #onCreate} with the Intent returned by {@link #getIntent}.
 *
 * @param intent The intent to dispatch to the next activity.  For
 * correct behavior, this must be the same as the Intent that started
 * your own activity; the only changes you can make are to the extras
 * inside of it.
 * @param options Additional options for how the Activity should be started.
 * See {@link android.content.Context#startActivity(Intent, Bundle)
 * Context.startActivity(Intent, Bundle)} for more details.
 *
 * @return Returns a boolean indicating whether there was another Activity
 * to start: true if there was a next activity to start, false if there
 * wasn't.  In general, if true is returned you will then want to call
 * finish() on yourself.
 */
","/**
 * Special version of starting an activity, for use when you are replacing
 * other activity components.  You can use this to hand the Intent off
 * to the next Activity that can handle it.  You typically call this in
 * {@link #onCreate} with the Intent returned by {@link #getIntent}.
 *
 * @param intent The intent to dispatch to the next activity.  For
 * correct behavior, this must be the same as the Intent that started
 * your own activity; the only changes you can make are to the extras
 * inside of it.
 * @param options Additional options for how the Activity should be started.
 * See {@link android.content.Context#startActivity(Intent, Bundle)
 * Context.startActivity(Intent, Bundle)} for more details.
 *
 * @return Returns a boolean indicating whether there was another Activity
 * to start: true if there was a next activity to start, false if there
 * wasn't.  In general, if true is returned you will then want to call
 * finish() on yourself.
 */
",0,,,0,,,0,"1,2",5,0,"4,5",1,"The code change includes two additional method calls: intent.migrateExtraStreamToClipData() and intent.prepareToLeaveProcess(). These are not related to return statements or exception handling, but they involve method calls on the Intent object. This can be classified as ""Other statement changed"" (4), and since these methods are being called on the Intent object, it can also be classified as ""Dependent API changed"" (5).","The changes in the API behavior may cause different results when the method is called, depending on the state of the Intent object. Specifically, the migrateExtraStreamToClipData() method migrates any extra streams to a ClipData extra field, and the prepareToLeaveProcess() method prepares the intent to leave the current process. As a result, the API may return a different value (true or false) even if the same input parameters are provided, leading to a compatibility issue of type 1 (Compatibility Issue caused by potential different return values or types)."
156,"<android.content.ContentProvider: int bulkInsert(Uri,ContentValues[])>",17,18,"<android.content.ContentProvider: int bulkInsert(Uri,ContentValues[])>","<android.content.ContentProvider: int bulkInsert(Uri,ContentValues[])>",0,"{
    int numValues = values.length;
    for (int i = 0; i < numValues; i++) {
        insert(uri, values[i]);
    }
    return numValues;
}","{
    int numValues = values.length;
    for (int i = 0; i < numValues; i++) {
        insert(uri, values[i]);
    }
    return numValues;
}",0,"/**
 * Override this to handle requests to insert a set of new rows, or the
 * default implementation will iterate over the values and call
 * {@link #insert} on each of them.
 * As a courtesy, call {@link ContentResolver#notifyChange(android.net.Uri ,android.database.ContentObserver) notifyChange()}
 * after inserting.
 * This method can be called from multiple threads, as described in
 * <a href=""{@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads"">Processes
 * and Threads</a>.
 *
 * @param uri The content:// URI of the insertion request.
 * @param values An array of sets of column_name/value pairs to add to the database.
 * @return The number of values that were inserted.
 */
","/**
 * Override this to handle requests to insert a set of new rows, or the
 * default implementation will iterate over the values and call
 * {@link #insert} on each of them.
 * As a courtesy, call {@link ContentResolver#notifyChange(android.net.Uri ,android.database.ContentObserver) notifyChange()}
 * after inserting.
 * This method can be called from multiple threads, as described in
 * <a href=""{@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads"">Processes
 * and Threads</a>.
 *
 * @param uri The content:// URI of the insertion request.
 * @param values An array of sets of column_name/value pairs to add to the database.
 * This must not be {@code null}.
 * @return The number of values that were inserted.
 */
",1,,,0,,,0,0,0,0,0,0,There is no difference between the early and late implementation of the bulkInsert API.,"Since there is no difference between the two versions, there is no compatibility issue caused by potential different return values or types, or potential different exception handling."
158,"<android.widget.TextView: boolean onKeyDown(int,KeyEvent)>",18,19,"<android.widget.TextView: boolean onKeyDown(int,KeyEvent)>","<android.widget.TextView: boolean onKeyDown(int,KeyEvent)>",0,"{
    int which = doKeyDown(keyCode, event, null);
    if (which == 0) {
        // Go through default dispatching.
        return super.onKeyDown(keyCode, event);
    }
    return true;
}","{
    int which = doKeyDown(keyCode, event, null);
    if (which == 0) {
        return super.onKeyDown(keyCode, event);
    }
    return true;
}",1,,,0,[@Override],[@Override],0,,,0,0,0,0,0,0,There is no change between the early version and late version of the implementation and annotation of the API.,There is no Compatibility Issue as there is no change between the two versions.
159,<android.view.View: void setSystemUiVisibility(int)>,18,19,<android.view.View: void setSystemUiVisibility(int)>,<android.view.View: void setSystemUiVisibility(int)>,0,"{
    if (visibility != mSystemUiVisibility) {
        mSystemUiVisibility = visibility;
        if (mParent != null && mAttachInfo != null && !mAttachInfo.mRecomputeGlobalAttributes) {
            mParent.recomputeViewAttributes(this);
        }
    }
}","{
    if (visibility != mSystemUiVisibility) {
        mSystemUiVisibility = visibility;
        if (mParent != null && mAttachInfo != null && !mAttachInfo.mRecomputeGlobalAttributes) {
            mParent.recomputeViewAttributes(this);
        }
    }
}",0,"/**
 * Request that the visibility of the status bar or other screen/window
 * decorations be changed.
 *
 * <p>This method is used to put the over device UI into temporary modes
 * where the user's attention is focused more on the application content,
 * by dimming or hiding surrounding system affordances.  This is typically
 * used in conjunction with {@link Window#FEATURE_ACTION_BAR_OVERLAY
 * Window.FEATURE_ACTION_BAR_OVERLAY}, allowing the applications content
 * to be placed behind the action bar (and with these flags other system
 * affordances) so that smooth transitions between hiding and showing them
 * can be done.
 *
 * <p>Two representative examples of the use of system UI visibility is
 * implementing a content browsing application (like a magazine reader)
 * and a video playing application.
 *
 * <p>The first code shows a typical implementation of a View in a content
 * browsing application.  In this implementation, the application goes
 * into a content-oriented mode by hiding the status bar and action bar,
 * and putting the navigation elements into lights out mode.  The user can
 * then interact with content while in this mode.  Such an application should
 * provide an easy way for the user to toggle out of the mode (such as to
 * check information in the status bar or access notifications).  In the
 * implementation here, this is done simply by tapping on the content.
 *
 * {@sample development/samples/ApiDemos/src/com/example/android/apis/view/ContentBrowserActivity.java
 * content}
 *
 * <p>This second code sample shows a typical implementation of a View
 * in a video playing application.  In this situation, while the video is
 * playing the application would like to go into a complete full-screen mode,
 * to use as much of the display as possible for the video.  When in this state
 * the user can not interact with the application; the system intercepts
 * touching on the screen to pop the UI out of full screen mode.  See
 * {@link #fitSystemWindows(Rect)} for a sample layout that goes with this code.
 *
 * {@sample development/samples/ApiDemos/src/com/example/android/apis/view/VideoPlayerActivity.java
 * content}
 *
 * @param visibility  Bitwise-or of flags {@link #SYSTEM_UI_FLAG_LOW_PROFILE},
 * {@link #SYSTEM_UI_FLAG_HIDE_NAVIGATION}, {@link #SYSTEM_UI_FLAG_FULLSCREEN},
 * {@link #SYSTEM_UI_FLAG_LAYOUT_STABLE}, {@link #SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION},
 * and {@link #SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN}.
 */
","/**
 * Request that the visibility of the status bar or other screen/window
 * decorations be changed.
 *
 * <p>This method is used to put the over device UI into temporary modes
 * where the user's attention is focused more on the application content,
 * by dimming or hiding surrounding system affordances.  This is typically
 * used in conjunction with {@link Window#FEATURE_ACTION_BAR_OVERLAY
 * Window.FEATURE_ACTION_BAR_OVERLAY}, allowing the applications content
 * to be placed behind the action bar (and with these flags other system
 * affordances) so that smooth transitions between hiding and showing them
 * can be done.
 *
 * <p>Two representative examples of the use of system UI visibility is
 * implementing a content browsing application (like a magazine reader)
 * and a video playing application.
 *
 * <p>The first code shows a typical implementation of a View in a content
 * browsing application.  In this implementation, the application goes
 * into a content-oriented mode by hiding the status bar and action bar,
 * and putting the navigation elements into lights out mode.  The user can
 * then interact with content while in this mode.  Such an application should
 * provide an easy way for the user to toggle out of the mode (such as to
 * check information in the status bar or access notifications).  In the
 * implementation here, this is done simply by tapping on the content.
 *
 * {@sample development/samples/ApiDemos/src/com/example/android/apis/view/ContentBrowserActivity.java
 * content}
 *
 * <p>This second code sample shows a typical implementation of a View
 * in a video playing application.  In this situation, while the video is
 * playing the application would like to go into a complete full-screen mode,
 * to use as much of the display as possible for the video.  When in this state
 * the user can not interact with the application; the system intercepts
 * touching on the screen to pop the UI out of full screen mode.  See
 * {@link #fitSystemWindows(Rect)} for a sample layout that goes with this code.
 *
 * {@sample development/samples/ApiDemos/src/com/example/android/apis/view/VideoPlayerActivity.java
 * content}
 *
 * @param visibility  Bitwise-or of flags {@link #SYSTEM_UI_FLAG_LOW_PROFILE},
 * {@link #SYSTEM_UI_FLAG_HIDE_NAVIGATION}, {@link #SYSTEM_UI_FLAG_FULLSCREEN},
 * {@link #SYSTEM_UI_FLAG_LAYOUT_STABLE}, {@link #SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION},
 * {@link #SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN}, {@link #SYSTEM_UI_FLAG_IMMERSIVE},
 * and {@link #SYSTEM_UI_FLAG_IMMERSIVE_STICKY}.
 */
",1,,,0,,,0,0,0,0,0,0,No change has been made between the early and late versions of the implementation.,"As there is no change in the implementation, there is no potential Compatibility Issue that could arise."
160,"<android.webkit.WebView: void onMeasure(int,int)>",18,19,"<android.webkit.WebView: void onMeasure(int,int)>","<android.webkit.WebView: void onMeasure(int,int)>",0,"{
    super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    mProvider.getViewDelegate().onMeasure(widthMeasureSpec, heightMeasureSpec);
}","{
    super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    mProvider.getViewDelegate().onMeasure(widthMeasureSpec, heightMeasureSpec);
}",0,,,0,"[@Deprecated, @Override]",[@Override],1,,,0,0,0,0,0,0,"The annotation has changed from @Deprecated to no deprecated annotation, but the method implementation hasn't changed. So the code change type is 0.","Since the method implementation hasn't changed, it won't cause any different behaviour, thus the CI type is 0."
162,"<android.provider.DocumentsProvider: Cursor queryRecentDocuments(String,String[])>",19,20,"<android.provider.DocumentsProvider: Cursor queryRecentDocuments(String,String[])>","<android.provider.DocumentsProvider: Cursor queryRecentDocuments(String,String[])>",0,"{
    throw new UnsupportedOperationException(""Recent not supported"");
}","{
    throw new UnsupportedOperationException(""Recent not supported"");
}",0,"/**
 * Return recently modified documents under the requested root. This will
 * only be called for roots that advertise
 * {@link Root#FLAG_SUPPORTS_RECENTS}. The returned documents should be
 * sorted by {@link Document#COLUMN_LAST_MODIFIED} in descending order, and
 * limited to only return the 64 most recently modified documents.
 *
 * @param projection list of {@link Document} columns to put into the
 * cursor. If {@code null} all supported columns should be
 * included.
 * @see DocumentsContract#EXTRA_LOADING
 */
","/**
 * Return recently modified documents under the requested root. This will
 * only be called for roots that advertise
 * {@link Root#FLAG_SUPPORTS_RECENTS}. The returned documents should be
 * sorted by {@link Document#COLUMN_LAST_MODIFIED} in descending order, and
 * limited to only return the 64 most recently modified documents.
 * <p>
 * Recent documents do not support change notifications.
 *
 * @param projection list of {@link Document} columns to put into the
 * cursor. If {@code null} all supported columns should be
 * included.
 * @see DocumentsContract#EXTRA_LOADING
 */
",1,[@SuppressWarnings("unused")],[@SuppressWarnings("unused")],0,,,0,0,0,0,0,0,"There is no difference between the early version and the late version in the implementation and annotation of the given API, so the code change type is 0.","There is no difference in the behavior of the given API between the two versions, so no Compatibility Issue could arise for the API."
163,<android.app.MediaRouteActionProvider: View onCreateActionView()>,19,20,<android.app.MediaRouteActionProvider: View onCreateActionView()>,<android.app.MediaRouteActionProvider: View onCreateActionView()>,0,"{
    throw new UnsupportedOperationException(""Use onCreateActionView(MenuItem) instead."");
}","{
    throw new UnsupportedOperationException(""Use onCreateActionView(MenuItem) instead."");
}",0,,,0,[@Override],"[@Override, @SuppressWarnings(""deprecation"")]",1,,,0,0,0,0,0,0,No change.,No Compatibility Issue.
164,<android.os.CountDownTimer: CountDownTimer start()>,20,21,<android.os.CountDownTimer: CountDownTimer start()>,<android.os.CountDownTimer: CountDownTimer start()>,0,"{
    if (mMillisInFuture <= 0) {
        onFinish();
        return this;
    }
    mStopTimeInFuture = SystemClock.elapsedRealtime() + mMillisInFuture;
    mHandler.sendMessage(mHandler.obtainMessage(MSG));
    return this;
}","{
    mCancelled = false;
    if (mMillisInFuture <= 0) {
        onFinish();
        return this;
    }
    mStopTimeInFuture = SystemClock.elapsedRealtime() + mMillisInFuture;
    mHandler.sendMessage(mHandler.obtainMessage(MSG));
    return this;
}",1,"/**
 * Start the countdown.
 */
","/**
 * Start the countdown.
 */
",0,,,0,,,0,1,4,0,4,0,"The change is that an additional statement ""mCancelled = false;"" has been added. It is not a return statement change, exception handling change or control dependency change, so it belongs to the ""Other statement changed"" category.","The change of this additional statement does not affect the return value or exception handling of the CountDownTimer.start() API. Therefore, there is no Compatibility Issue caused by potential different return values or types or potential different exception handlings."
165,<android.service.dreams.DreamService: boolean isScreenBright()>,20,21,<android.service.dreams.DreamService: boolean isScreenBright()>,<android.service.dreams.DreamService: boolean isScreenBright()>,0,"{
    return getWindowFlagValue(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON, mScreenBright);
}","{
    return getWindowFlagValue(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON, mScreenBright);
}",0,"/**
 * Returns whether or not this dream keeps the screen bright while dreaming. Defaults to false,
 * allowing the screen to dim if necessary.
 *
 * @see #setScreenBright(boolean)
 */
","/**
 * Returns whether or not this dream keeps the screen bright while dreaming.
 * Defaults to false, allowing the screen to dim if necessary.
 *
 * @see #setScreenBright(boolean)
 */
",1,,,0,,,0,0,0,0,0,0,There is no code change in the implementation of the `isScreenBright()` method in the given two versions.,"As there is no code change, there will be no Compatibility Issue. The method will return the same value in both versions."
166,"<android.app.Activity: Dialog onCreateDialog(int,Bundle)>",20,21,"<android.app.Activity: Dialog onCreateDialog(int,Bundle)>","<android.app.Activity: Dialog onCreateDialog(int,Bundle)>",0,"{
    return onCreateDialog(id);
}","{
    return onCreateDialog(id);
}",0,"/**
 * Callback for creating dialogs that are managed (saved and restored) for you
 * by the activity.  The default implementation calls through to
 * {@link #onCreateDialog(int)} for compatibility.
 *
 * <em>If you are targeting {@link android.os.Build.VERSION_CODES#HONEYCOMB}
 * or later, consider instead using a {@link DialogFragment} instead.</em>
 *
 * <p>If you use {@link #showDialog(int)}, the activity will call through to
 * this method the first time, and hang onto it thereafter.  Any dialog
 * that is created by this method will automatically be saved and restored
 * for you, including whether it is showing.
 *
 * <p>If you would like the activity to manage saving and restoring dialogs
 * for you, you should override this method and handle any ids that are
 * passed to {@link #showDialog}.
 *
 * <p>If you would like an opportunity to prepare your dialog before it is shown,
 * override {@link #onPrepareDialog(int, Dialog, Bundle)}.
 *
 * @param id The id of the dialog.
 * @param args The dialog arguments provided to {@link #showDialog(int, Bundle)}.
 * @return The dialog.  If you return null, the dialog will not be created.
 *
 * @see #onPrepareDialog(int, Dialog, Bundle)
 * @see #showDialog(int, Bundle)
 * @see #dismissDialog(int)
 * @see #removeDialog(int)
 *
 * @deprecated Use the new {@link DialogFragment} class with
 * {@link FragmentManager} instead; this is also
 * available on older platforms through the Android compatibility package.
 */
","/**
 * Callback for creating dialogs that are managed (saved and restored) for you
 * by the activity.  The default implementation calls through to
 * {@link #onCreateDialog(int)} for compatibility.
 *
 * <em>If you are targeting {@link android.os.Build.VERSION_CODES#HONEYCOMB}
 * or later, consider instead using a {@link DialogFragment} instead.</em>
 *
 * <p>If you use {@link #showDialog(int)}, the activity will call through to
 * this method the first time, and hang onto it thereafter.  Any dialog
 * that is created by this method will automatically be saved and restored
 * for you, including whether it is showing.
 *
 * <p>If you would like the activity to manage saving and restoring dialogs
 * for you, you should override this method and handle any ids that are
 * passed to {@link #showDialog}.
 *
 * <p>If you would like an opportunity to prepare your dialog before it is shown,
 * override {@link #onPrepareDialog(int, Dialog, Bundle)}.
 *
 * @param id The id of the dialog.
 * @param args The dialog arguments provided to {@link #showDialog(int, Bundle)}.
 * @return The dialog.  If you return null, the dialog will not be created.
 *
 * @see #onPrepareDialog(int, Dialog, Bundle)
 * @see #showDialog(int, Bundle)
 * @see #dismissDialog(int)
 * @see #removeDialog(int)
 *
 * @deprecated Use the new {@link DialogFragment} class with
 * {@link FragmentManager} instead; this is also
 * available on older platforms through the Android compatibility package.
 */
",0,[@Deprecated],"[@Nullable, @Deprecated]",1,,,0,0,0,0,4,1,"The annotation has changed from '[@Deprecated]' to '[@Nullable, @Deprecated]', so the code change type is 4.","Adding the '[@Nullable]' annotation can indicate that the API can potentially return a null value, which may lead to compatibility issues if the calling code does not handle null values properly. Thus, the CI type is 1."
167,<android.hardware.camera2.legacy.SurfaceTextureRenderer: void drawIntoSurfaces(CaptureCollector)>,21,22,<android.hardware.camera2.legacy.SurfaceTextureRenderer: void drawIntoSurfaces(CaptureCollector)>,<android.hardware.camera2.legacy.SurfaceTextureRenderer: void drawIntoSurfaces(CaptureCollector)>,0,"{
    if ((mSurfaces == null || mSurfaces.size() == 0) && (mConversionSurfaces == null || mConversionSurfaces.size() == 0)) {
        return;
    }
    boolean doTiming = targetCollector.hasPendingPreviewCaptures();
    checkGlError(""before updateTexImage"");
    if (doTiming) {
        beginGlTiming();
    }
    mSurfaceTexture.updateTexImage();
    long timestamp = mSurfaceTexture.getTimestamp();
    Pair<RequestHolder, Long> captureHolder = targetCollector.previewCaptured(timestamp);
    // No preview request queued, drop frame.
    if (captureHolder == null) {
        if (DEBUG) {
            Log.d(TAG, ""Dropping preview frame."");
        }
        if (doTiming) {
            endGlTiming();
        }
        return;
    }
    RequestHolder request = captureHolder.first;
    Collection<Surface> targetSurfaces = request.getHolderTargets();
    if (doTiming) {
        addGlTimestamp(timestamp);
    }
    List<Long> targetSurfaceIds = LegacyCameraDevice.getSurfaceIds(targetSurfaces);
    for (EGLSurfaceHolder holder : mSurfaces) {
        if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)) {
            makeCurrent(holder.eglSurface);
            try {
                LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height);
                LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second);
                drawFrame(mSurfaceTexture, holder.width, holder.height);
                swapBuffers(holder.eglSurface);
            } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
                Log.w(TAG, ""Surface abandoned, dropping frame. "", e);
            }
        }
    }
    for (EGLSurfaceHolder holder : mConversionSurfaces) {
        if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)) {
            makeCurrent(holder.eglSurface);
            drawFrame(mSurfaceTexture, holder.width, holder.height);
            mPBufferPixels.clear();
            GLES20.glReadPixels(/*x*/
            0, /*y*/
            0, holder.width, holder.height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, mPBufferPixels);
            checkGlError(""glReadPixels"");
            try {
                int format = LegacyCameraDevice.detectSurfaceType(holder.surface);
                LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second);
                LegacyCameraDevice.produceFrame(holder.surface, mPBufferPixels.array(), holder.width, holder.height, format);
                swapBuffers(holder.eglSurface);
            } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
                Log.w(TAG, ""Surface abandoned, dropping frame. "", e);
            }
        }
    }
    targetCollector.previewProduced();
    if (doTiming) {
        endGlTiming();
    }
}","{
    if ((mSurfaces == null || mSurfaces.size() == 0) && (mConversionSurfaces == null || mConversionSurfaces.size() == 0)) {
        return;
    }
    boolean doTiming = targetCollector.hasPendingPreviewCaptures();
    checkGlError(""before updateTexImage"");
    if (doTiming) {
        beginGlTiming();
    }
    mSurfaceTexture.updateTexImage();
    long timestamp = mSurfaceTexture.getTimestamp();
    Pair<RequestHolder, Long> captureHolder = targetCollector.previewCaptured(timestamp);
    // No preview request queued, drop frame.
    if (captureHolder == null) {
        if (DEBUG) {
            Log.d(TAG, ""Dropping preview frame."");
        }
        if (doTiming) {
            endGlTiming();
        }
        return;
    }
    RequestHolder request = captureHolder.first;
    Collection<Surface> targetSurfaces = request.getHolderTargets();
    if (doTiming) {
        addGlTimestamp(timestamp);
    }
    List<Long> targetSurfaceIds = LegacyCameraDevice.getSurfaceIds(targetSurfaces);
    for (EGLSurfaceHolder holder : mSurfaces) {
        if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)) {
            try {
                LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height);
                makeCurrent(holder.eglSurface);
                LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second);
                drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing == CameraCharacteristics.LENS_FACING_FRONT) ? FLIP_TYPE_HORIZONTAL : FLIP_TYPE_NONE);
                swapBuffers(holder.eglSurface);
            } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
                Log.w(TAG, ""Surface abandoned, dropping frame. "", e);
            }
        }
    }
    for (EGLSurfaceHolder holder : mConversionSurfaces) {
        if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)) {
            makeCurrent(holder.eglSurface);
            // glReadPixels reads from the bottom of the buffer, so add an extra vertical flip
            drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing == CameraCharacteristics.LENS_FACING_FRONT) ? FLIP_TYPE_BOTH : FLIP_TYPE_VERTICAL);
            mPBufferPixels.clear();
            GLES20.glReadPixels(/*x*/
            0, /*y*/
            0, holder.width, holder.height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, mPBufferPixels);
            checkGlError(""glReadPixels"");
            try {
                int format = LegacyCameraDevice.detectSurfaceType(holder.surface);
                LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height);
                LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second);
                LegacyCameraDevice.produceFrame(holder.surface, mPBufferPixels.array(), holder.width, holder.height, format);
            } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
                Log.w(TAG, ""Surface abandoned, dropping frame. "", e);
            }
        }
    }
    targetCollector.previewProduced();
    if (doTiming) {
        endGlTiming();
    }
}",1,"/**
 * Draw the current buffer in the {@link SurfaceTexture} returned from
 * {@link #getSurfaceTexture()} into the set of target {@link Surface}s
 * in the next request from the given {@link CaptureCollector}, or drop
 * the frame if none is available.
 *
 * <p>
 * Any {@link Surface}s targeted must be a subset of the {@link Surface}s
 * set in the last {@link #configureSurfaces(java.util.Collection)} call.
 * </p>
 *
 * @param targetCollector the surfaces to draw to.
 */
","/**
 * Draw the current buffer in the {@link SurfaceTexture} returned from
 * {@link #getSurfaceTexture()} into the set of target {@link Surface}s
 * in the next request from the given {@link CaptureCollector}, or drop
 * the frame if none is available.
 *
 * <p>
 * Any {@link Surface}s targeted must be a subset of the {@link Surface}s
 * set in the last {@link #configureSurfaces(java.util.Collection)} call.
 * </p>
 *
 * @param targetCollector the surfaces to draw to.
 */
",0,,,0,,,0,"1,2","4,5",0,3,1,"The code change between the early and late versions involves the addition of a new parameter in the `drawFrame` method calls, specifically `(mFacing == CameraCharacteristics.LENS_FACING_FRONT) ? FLIP_TYPE_HORIZONTAL : FLIP_TYPE_NONE` and `(mFacing == CameraCharacteristics.LENS_FACING_FRONT) ? FLIP_TYPE_BOTH : FLIP_TYPE_VERTICAL`. This change affects the control dependency as it modifies the behavior of the `drawFrame` method based on the condition.","The Compatibility Issue arises due to the potential different return values or types caused by the change in the `drawFrame` method calls. The addition of a new parameter in the method call could lead to different behavior in the late version, as it might result in different flipping types for the frames being drawn. This, in turn, could cause the API to produce different outputs in different versions, leading to a compatibility issue."
168,"<android.accounts.AccountManager: AccountManagerFuture<Boolean> removeAccount(Account,AccountManagerCallback<Boolean>,Handler)>",21,22,"<android.accounts.AccountManager: AccountManagerFuture<Boolean> removeAccount(Account,AccountManagerCallback<Boolean>,Handler)>","<android.accounts.AccountManager: AccountManagerFuture<Boolean> removeAccount(Account,AccountManagerCallback<Boolean>,Handler)>",0,"{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    return new Future2Task<Boolean>(handler, callback) {

        public void doWork() throws RemoteException {
            mService.removeAccount(mResponse, account);
        }

        public Boolean bundleToResult(Bundle bundle) throws AuthenticatorException {
            if (!bundle.containsKey(KEY_BOOLEAN_RESULT)) {
                throw new AuthenticatorException(""no result in response"");
            }
            return bundle.getBoolean(KEY_BOOLEAN_RESULT);
        }
    }.start();
}","{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    return new Future2Task<Boolean>(handler, callback) {

        public void doWork() throws RemoteException {
            mService.removeAccount(mResponse, account, false);
        }

        public Boolean bundleToResult(Bundle bundle) throws AuthenticatorException {
            if (!bundle.containsKey(KEY_BOOLEAN_RESULT)) {
                throw new AuthenticatorException(""no result in response"");
            }
            return bundle.getBoolean(KEY_BOOLEAN_RESULT);
        }
    }.start();
}",1,"/**
 * Removes an account from the AccountManager.  Does nothing if the account
 * does not exist.  Does not delete the account from the server.
 * The authenticator may have its own policies preventing account
 * deletion, in which case the account will not be deleted.
 *
 * <p>This method may be called from any thread, but the returned
 * {@link AccountManagerFuture} must not be used on the main thread.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#MANAGE_ACCOUNTS}.
 *
 * @param account The {@link Account} to remove
 * @param callback Callback to invoke when the request completes,
 * null for no callback
 * @param handler {@link Handler} identifying the callback thread,
 * null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Boolean,
 * true if the account has been successfully removed
 */
","/**
 * Removes an account from the AccountManager.  Does nothing if the account
 * does not exist.  Does not delete the account from the server.
 * The authenticator may have its own policies preventing account
 * deletion, in which case the account will not be deleted.
 *
 * <p>This method may be called from any thread, but the returned
 * {@link AccountManagerFuture} must not be used on the main thread.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#MANAGE_ACCOUNTS}.
 *
 * @param account The {@link Account} to remove
 * @param callback Callback to invoke when the request completes,
 * null for no callback
 * @param handler {@link Handler} identifying the callback thread,
 * null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Boolean,
 * true if the account has been successfully removed
 * @deprecated use
 * {@link #removeAccount(Account, Activity, AccountManagerCallback, Handler)}
 * instead
 */
",1,,[@Deprecated],1,,,0,"1,2",5,0,5,1,"The number of parameters in the method mService.removeAccount() has changed from 2 to 3, so the change type is 5.","The added parameter in the method mService.removeAccount() may cause the method to behave differently, potentially leading to a different return value, so the CI type is 1."
169,<android.widget.TextView: void setExtractedText(ExtractedText)>,22,23,<android.widget.TextView: void setExtractedText(ExtractedText)>,<android.widget.TextView: void setExtractedText(ExtractedText)>,0,"{
    Editable content = getEditableText();
    if (text.text != null) {
        if (content == null) {
            setText(text.text, TextView.BufferType.EDITABLE);
        } else if (text.partialStartOffset < 0) {
            removeParcelableSpans(content, 0, content.length());
            content.replace(0, content.length(), text.text);
        } else {
            final int N = content.length();
            int start = text.partialStartOffset;
            if (start > N)
                start = N;
            int end = text.partialEndOffset;
            if (end > N)
                end = N;
            removeParcelableSpans(content, start, end);
            content.replace(start, end, text.text);
        }
    }
    // Now set the selection position...  make sure it is in range, to
    // avoid crashes.  If this is a partial update, it is possible that
    // the underlying text may have changed, causing us problems here.
    // Also we just don't want to trust clients to do the right thing.
    Spannable sp = (Spannable) getText();
    final int N = sp.length();
    int start = text.selectionStart;
    if (start < 0)
        start = 0;
    else if (start > N)
        start = N;
    int end = text.selectionEnd;
    if (end < 0)
        end = 0;
    else if (end > N)
        end = N;
    Selection.setSelection(sp, start, end);
    // Finally, update the selection mode.
    if ((text.flags & ExtractedText.FLAG_SELECTING) != 0) {
        MetaKeyKeyListener.startSelecting(this, sp);
    } else {
        MetaKeyKeyListener.stopSelecting(this, sp);
    }
}","{
    Editable content = getEditableText();
    if (text.text != null) {
        if (content == null) {
            setText(text.text, TextView.BufferType.EDITABLE);
        } else {
            int start = 0;
            int end = content.length();
            if (text.partialStartOffset >= 0) {
                final int N = content.length();
                start = text.partialStartOffset;
                if (start > N)
                    start = N;
                end = text.partialEndOffset;
                if (end > N)
                    end = N;
            }
            removeParcelableSpans(content, start, end);
            if (TextUtils.equals(content.subSequence(start, end), text.text)) {
                if (text.text instanceof Spanned) {
                    // OK to copy spans only.
                    TextUtils.copySpansFrom((Spanned) text.text, start, end, Object.class, content, start);
                }
            } else {
                content.replace(start, end, text.text);
            }
        }
    }
    // Now set the selection position...  make sure it is in range, to
    // avoid crashes.  If this is a partial update, it is possible that
    // the underlying text may have changed, causing us problems here.
    // Also we just don't want to trust clients to do the right thing.
    Spannable sp = (Spannable) getText();
    final int N = sp.length();
    int start = text.selectionStart;
    if (start < 0)
        start = 0;
    else if (start > N)
        start = N;
    int end = text.selectionEnd;
    if (end < 0)
        end = 0;
    else if (end > N)
        end = N;
    Selection.setSelection(sp, start, end);
    // Finally, update the selection mode.
    if ((text.flags & ExtractedText.FLAG_SELECTING) != 0) {
        MetaKeyKeyListener.startSelecting(this, sp);
    } else {
        MetaKeyKeyListener.stopSelecting(this, sp);
    }
}",1,"/**
 * Apply to this text view the given extracted text, as previously
 * returned by {@link #extractText(ExtractedTextRequest, ExtractedText)}.
 */
","/**
 * Apply to this text view the given extracted text, as previously
 * returned by {@link #extractText(ExtractedTextRequest, ExtractedText)}.
 */
",0,,,0,,,0,"1,2","3,4,5",0,3,1,"The code change is that the condition statement ""if (text.partialStartOffset < 0)"" has been changed to ""if (text.partialStartOffset >= 0)"". The code inside the if block has also been updated, which is a control dependency change.","The update of the condition statement and the code inside the if block can potentially lead to different behavior of the API, which means the API may return a different value. Therefore, this is a Compatibility Issue caused by potential different return values or types."
170,<android.net.Uri: Uri normalizeScheme()>,22,23,<android.net.Uri: Uri normalizeScheme()>,<android.net.Uri: Uri normalizeScheme()>,0,"{
    String scheme = getScheme();
    // give up
    if (scheme == null)
        return this;
    String lowerScheme = scheme.toLowerCase(Locale.ROOT);
    // no change
    if (scheme.equals(lowerScheme))
        return this;
    return buildUpon().scheme(lowerScheme).build();
}","{
    String scheme = getScheme();
    // give up
    if (scheme == null)
        return this;
    String lowerScheme = scheme.toLowerCase(Locale.ROOT);
    // no change
    if (scheme.equals(lowerScheme))
        return this;
    return buildUpon().scheme(lowerScheme).build();
}",0,"/**
 * Return an equivalent URI with a lowercase scheme component.
 * This aligns the Uri with Android best practices for
 * intent filtering.
 *
 * <p>For example, ""HTTP://www.android.com"" becomes
 * ""http://www.android.com""
 *
 * <p>All URIs received from outside Android (such as user input,
 * or external sources like Bluetooth, NFC, or the Internet) should
 * be normalized before they are used to create an Intent.
 *
 * <p class=""note"">This method does <em>not</em> validate bad URI's,
 * or 'fix' poorly formatted URI's - so do not use it for input validation.
 * A Uri will always be returned, even if the Uri is badly formatted to
 * begin with and a scheme component cannot be found.
 *
 * @return normalized Uri (never null)
 * @see {@link android.content.Intent#setData}
 * @see {@link #setNormalizedData}
 */
","/**
 * Return an equivalent URI with a lowercase scheme component.
 * This aligns the Uri with Android best practices for
 * intent filtering.
 *
 * <p>For example, ""HTTP://www.android.com"" becomes
 * ""http://www.android.com""
 *
 * <p>All URIs received from outside Android (such as user input,
 * or external sources like Bluetooth, NFC, or the Internet) should
 * be normalized before they are used to create an Intent.
 *
 * <p class=""note"">This method does <em>not</em> validate bad URI's,
 * or 'fix' poorly formatted URI's - so do not use it for input validation.
 * A Uri will always be returned, even if the Uri is badly formatted to
 * begin with and a scheme component cannot be found.
 *
 * @return normalized Uri (never null)
 * @see {@link android.content.Intent#setData}
 * @see {@link android.content.Intent#setDataAndNormalize}
 */
",1,,,0,,,0,0,0,0,0,0,"The implementation of the API has not been changed, so the code change type is 0.","As the API implementation has not been changed, the API will not return a different value or throw a different exception, so there is no Compatibility Issue. The CI type is 0."
171,"<android.content.ContextWrapper: void sendStickyOrderedBroadcastAsUser(Intent,UserHandle,BroadcastReceiver,Handler,int,String,Bundle)>",22,23,"<android.content.ContextWrapper: void sendStickyOrderedBroadcastAsUser(Intent,UserHandle,BroadcastReceiver,Handler,int,String,Bundle)>","<android.content.ContextWrapper: void sendStickyOrderedBroadcastAsUser(Intent,UserHandle,BroadcastReceiver,Handler,int,String,Bundle)>",0,"{
    mBase.sendStickyOrderedBroadcastAsUser(intent, user, resultReceiver, scheduler, initialCode, initialData, initialExtras);
}","{
    mBase.sendStickyOrderedBroadcastAsUser(intent, user, resultReceiver, scheduler, initialCode, initialData, initialExtras);
}",0,,,0,[@Override],"[@Override, @Deprecated]",1,,,0,0,0,0,0,0,No code change between the two versions.,No Compatibility Issue arises as there is no code change between the two versions.
172,<android.hardware.camera2.legacy.SurfaceTextureRenderer: void drawIntoSurfaces(CaptureCollector)>,23,24,<android.hardware.camera2.legacy.SurfaceTextureRenderer: void drawIntoSurfaces(CaptureCollector)>,<android.hardware.camera2.legacy.SurfaceTextureRenderer: void drawIntoSurfaces(CaptureCollector)>,0,"{
    if ((mSurfaces == null || mSurfaces.size() == 0) && (mConversionSurfaces == null || mConversionSurfaces.size() == 0)) {
        return;
    }
    boolean doTiming = targetCollector.hasPendingPreviewCaptures();
    checkGlError(""before updateTexImage"");
    if (doTiming) {
        beginGlTiming();
    }
    mSurfaceTexture.updateTexImage();
    long timestamp = mSurfaceTexture.getTimestamp();
    Pair<RequestHolder, Long> captureHolder = targetCollector.previewCaptured(timestamp);
    // No preview request queued, drop frame.
    if (captureHolder == null) {
        if (DEBUG) {
            Log.d(TAG, ""Dropping preview frame."");
        }
        if (doTiming) {
            endGlTiming();
        }
        return;
    }
    RequestHolder request = captureHolder.first;
    Collection<Surface> targetSurfaces = request.getHolderTargets();
    if (doTiming) {
        addGlTimestamp(timestamp);
    }
    List<Long> targetSurfaceIds = LegacyCameraDevice.getSurfaceIds(targetSurfaces);
    for (EGLSurfaceHolder holder : mSurfaces) {
        if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)) {
            try {
                LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height);
                makeCurrent(holder.eglSurface);
                LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second);
                drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing == CameraCharacteristics.LENS_FACING_FRONT) ? FLIP_TYPE_HORIZONTAL : FLIP_TYPE_NONE);
                swapBuffers(holder.eglSurface);
            } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
                Log.w(TAG, ""Surface abandoned, dropping frame. "", e);
            }
        }
    }
    for (EGLSurfaceHolder holder : mConversionSurfaces) {
        if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)) {
            makeCurrent(holder.eglSurface);
            // glReadPixels reads from the bottom of the buffer, so add an extra vertical flip
            drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing == CameraCharacteristics.LENS_FACING_FRONT) ? FLIP_TYPE_BOTH : FLIP_TYPE_VERTICAL);
            mPBufferPixels.clear();
            GLES20.glReadPixels(/*x*/
            0, /*y*/
            0, holder.width, holder.height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, mPBufferPixels);
            checkGlError(""glReadPixels"");
            try {
                int format = LegacyCameraDevice.detectSurfaceType(holder.surface);
                LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height);
                LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second);
                LegacyCameraDevice.produceFrame(holder.surface, mPBufferPixels.array(), holder.width, holder.height, format);
            } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
                Log.w(TAG, ""Surface abandoned, dropping frame. "", e);
            }
        }
    }
    targetCollector.previewProduced();
    if (doTiming) {
        endGlTiming();
    }
}","{
    if ((mSurfaces == null || mSurfaces.size() == 0) && (mConversionSurfaces == null || mConversionSurfaces.size() == 0)) {
        return;
    }
    boolean doTiming = targetCollector.hasPendingPreviewCaptures();
    checkGlError(""before updateTexImage"");
    if (doTiming) {
        beginGlTiming();
    }
    mSurfaceTexture.updateTexImage();
    long timestamp = mSurfaceTexture.getTimestamp();
    Pair<RequestHolder, Long> captureHolder = targetCollector.previewCaptured(timestamp);
    // No preview request queued, drop frame.
    if (captureHolder == null) {
        if (DEBUG) {
            Log.d(TAG, ""Dropping preview frame."");
        }
        if (doTiming) {
            endGlTiming();
        }
        return;
    }
    RequestHolder request = captureHolder.first;
    Collection<Surface> targetSurfaces = request.getHolderTargets();
    if (doTiming) {
        addGlTimestamp(timestamp);
    }
    List<Long> targetSurfaceIds = new ArrayList();
    try {
        targetSurfaceIds = LegacyCameraDevice.getSurfaceIds(targetSurfaces);
    } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
        Log.w(TAG, ""Surface abandoned, dropping frame. "", e);
        request.setOutputAbandoned();
    }
    for (EGLSurfaceHolder holder : mSurfaces) {
        if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)) {
            try {
                LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height);
                makeCurrent(holder.eglSurface);
                LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second);
                drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing == CameraCharacteristics.LENS_FACING_FRONT) ? FLIP_TYPE_HORIZONTAL : FLIP_TYPE_NONE);
                swapBuffers(holder.eglSurface);
            } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
                Log.w(TAG, ""Surface abandoned, dropping frame. "", e);
                request.setOutputAbandoned();
            }
        }
    }
    for (EGLSurfaceHolder holder : mConversionSurfaces) {
        if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)) {
            makeCurrent(holder.eglSurface);
            // glReadPixels reads from the bottom of the buffer, so add an extra vertical flip
            drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing == CameraCharacteristics.LENS_FACING_FRONT) ? FLIP_TYPE_BOTH : FLIP_TYPE_VERTICAL);
            mPBufferPixels.clear();
            GLES20.glReadPixels(/*x*/
            0, /*y*/
            0, holder.width, holder.height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, mPBufferPixels);
            checkGlError(""glReadPixels"");
            try {
                int format = LegacyCameraDevice.detectSurfaceType(holder.surface);
                LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height);
                LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second);
                LegacyCameraDevice.produceFrame(holder.surface, mPBufferPixels.array(), holder.width, holder.height, format);
            } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
                Log.w(TAG, ""Surface abandoned, dropping frame. "", e);
                request.setOutputAbandoned();
            }
        }
    }
    targetCollector.previewProduced();
    if (doTiming) {
        endGlTiming();
    }
}",1,"/**
 * Draw the current buffer in the {@link SurfaceTexture} returned from
 * {@link #getSurfaceTexture()} into the set of target {@link Surface}s
 * in the next request from the given {@link CaptureCollector}, or drop
 * the frame if none is available.
 *
 * <p>
 * Any {@link Surface}s targeted must be a subset of the {@link Surface}s
 * set in the last {@link #configureSurfaces(java.util.Collection)} call.
 * </p>
 *
 * @param targetCollector the surfaces to draw to.
 */
","/**
 * Draw the current buffer in the {@link SurfaceTexture} returned from
 * {@link #getSurfaceTexture()} into the set of target {@link Surface}s
 * in the next request from the given {@link CaptureCollector}, or drop
 * the frame if none is available.
 *
 * <p>
 * Any {@link Surface}s targeted must be a subset of the {@link Surface}s
 * set in the last {@link #configureSurfaces(java.util.Collection)} call.
 * </p>
 *
 * @param targetCollector the surfaces to draw to.
 */
",0,,,0,,,0,"1,2","2,4,5",2,"3, 5",1,"The code change involves control dependency and dependent API changes. Specifically, a new try-catch block is added around the `LegacyCameraDevice.getSurfaceIds(targetSurfaces)` method, and the dependent API `LegacyCameraDevice.getSurfaceIds(Surface[])` potentially throws a new exception `LegacyExceptionUtils.BufferQueueAbandonedException`. Additionally, the `request.setOutputAbandoned()` method is added to the catch block.","The compatibility issue arises from the potential different exception handling. The new try-catch block added in the late version catches a new exception `LegacyExceptionUtils.BufferQueueAbandonedException`, which is not caught in the early version. This means that in the late version, the API may throw this exception or execute the `request.setOutputAbandoned()` method, while in the early version, the exception will propagate to the caller or crash the program, potentially causing different behaviors."
173,<android.widget.TabWidget: void setRightStripDrawable(Drawable)>,23,24,<android.widget.TabWidget: void setRightStripDrawable(Drawable)>,<android.widget.TabWidget: void setRightStripDrawable(Drawable)>,0,"{
    mRightStrip = drawable;
    requestLayout();
    invalidate();
}","{
    mRightStrip = drawable;
    requestLayout();
    invalidate();
}",0,"/**
 * Sets the drawable to use as the right part of the strip below the
 * tab indicators.
 * @param drawable the right strip drawable
 */
","/**
 * Sets the drawable to use as the right part of the strip below the tab
 * indicators.
 *
 * @param drawable the right strip drawable
 * @see #getRightStripDrawable()
 * @attr ref android.R.styleable#TabWidget_tabStripRight
 */
",1,,,0,,,0,0,0,0,0,0,"There is no code change between the early version and the late version of the API, so the code change type is 0.","As there is no code change, the API will not potentially return a different value or type and will not throw a different exception. Therefore, there is no Compatibility Issue (CI), and the CI type is 0."
174,<android.app.Dialog: void onActionModeStarted(ActionMode)>,23,24,<android.app.Dialog: void onActionModeStarted(ActionMode)>,<android.app.Dialog: void onActionModeStarted(ActionMode)>,0,"{
    mActionMode = mode;
}","{
    mActionMode = mode;
}",0,"/**
 * {@inheritDoc}
 *
 * Note that if you override this method you should always call through
 * to the superclass implementation by calling super.onActionModeStarted(mode).
 */
","/**
 * {@inheritDoc}
 *
 * Note that if you override this method you should always call through
 * to the superclass implementation by calling super.onActionModeStarted(mode).
 */
",0,[@CallSuper],"[@Override, @CallSuper]",1,,,0,0,0,0,0,0,"There is no change in the implementation of the method, but the annotation has been updated with the addition of '@Override'.","As there is no change in the implementation, the behavior of the API remains the same. The addition of the '@Override' annotation does not affect the behavior, so there is no compatibility issue."
175,<android.service.notification.ZenModeConfig.ZenRule: int hashCode()>,24,25,<android.service.notification.ZenModeConfig.ZenRule: int hashCode()>,<android.service.notification.ZenModeConfig.ZenRule: int hashCode()>,0,"{
    return Objects.hash(enabled, snoozing, name, zenMode, conditionId, condition, component, id, creationTime);
}","{
    return Objects.hash(enabled, snoozing, name, zenMode, conditionId, condition, component, id, creationTime, enabler);
}",1,,,0,[@Override],[@Override],0,,,0,"1,2","1,5",1,1,1,The return statement in the late version API has changed by adding a new variable "enabler" which is passed as an argument to the Objects.hash() method.,"As the return statement of the API has changed by passing a new variable ""enabler"" to the Objects.hash() method, this could potentially cause the API to return a different hash value. Therefore, this is a Compatibility Issue caused by potential different return values."
176,<android.view.DragEvent: ClipDescription getClipDescription()>,24,25,<android.view.DragEvent: ClipDescription getClipDescription()>,<android.view.DragEvent: ClipDescription getClipDescription()>,0,"{
    return mClipDescription;
}","{
    return mClipDescription;
}",0,"/**
 * Returns the {@link android.content.ClipDescription} object contained in the
 * {@link android.content.ClipData} object sent to the system as part of the call to
 * {@link android.view.View#startDrag(ClipData,View.DragShadowBuilder,Object,int) startDrag()}.
 * The drag handler or listener for a View can use the metadata in this object to decide if the
 * View can accept the dragged View object's data.
 * <p>
 * This method returns valid data for all event actions.
 * @return The ClipDescription that was part of the ClipData sent to the system by startDrag().
 */
","/**
 * Returns the {@link android.content.ClipDescription} object contained in the
 * {@link android.content.ClipData} object sent to the system as part of the call to
 * {@link android.view.View#startDrag(ClipData,View.DragShadowBuilder,Object,int) startDrag()}.
 * The drag handler or listener for a View can use the metadata in this object to decide if the
 * View can accept the dragged View object's data.
 * <p>
 * This method returns valid data for all event actions except for {@link #ACTION_DRAG_ENDED}.
 * @return The ClipDescription that was part of the ClipData sent to the system by startDrag().
 */
",1,,,0,,,0,0,0,0,0,0,The code for the API 'getClipDescription()' remains the same in both the early version and the late version.,"As the code change is classified as 0, meaning no change, thus there is no Compatibility Issue arises for the API."
177,<android.hardware.camera2.legacy.SurfaceTextureRenderer: void drawIntoSurfaces(CaptureCollector)>,25,26,<android.hardware.camera2.legacy.SurfaceTextureRenderer: void drawIntoSurfaces(CaptureCollector)>,<android.hardware.camera2.legacy.SurfaceTextureRenderer: void drawIntoSurfaces(CaptureCollector)>,0,"{
    if ((mSurfaces == null || mSurfaces.size() == 0) && (mConversionSurfaces == null || mConversionSurfaces.size() == 0)) {
        return;
    }
    boolean doTiming = targetCollector.hasPendingPreviewCaptures();
    checkGlError(""before updateTexImage"");
    if (doTiming) {
        beginGlTiming();
    }
    mSurfaceTexture.updateTexImage();
    long timestamp = mSurfaceTexture.getTimestamp();
    Pair<RequestHolder, Long> captureHolder = targetCollector.previewCaptured(timestamp);
    // No preview request queued, drop frame.
    if (captureHolder == null) {
        if (DEBUG) {
            Log.d(TAG, ""Dropping preview frame."");
        }
        if (doTiming) {
            endGlTiming();
        }
        return;
    }
    RequestHolder request = captureHolder.first;
    Collection<Surface> targetSurfaces = request.getHolderTargets();
    if (doTiming) {
        addGlTimestamp(timestamp);
    }
    List<Long> targetSurfaceIds = new ArrayList();
    try {
        targetSurfaceIds = LegacyCameraDevice.getSurfaceIds(targetSurfaces);
    } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
        Log.w(TAG, ""Surface abandoned, dropping frame. "", e);
        request.setOutputAbandoned();
    }
    for (EGLSurfaceHolder holder : mSurfaces) {
        if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)) {
            try {
                LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height);
                makeCurrent(holder.eglSurface);
                LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second);
                drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing == CameraCharacteristics.LENS_FACING_FRONT) ? FLIP_TYPE_HORIZONTAL : FLIP_TYPE_NONE);
                swapBuffers(holder.eglSurface);
            } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
                Log.w(TAG, ""Surface abandoned, dropping frame. "", e);
                request.setOutputAbandoned();
            }
        }
    }
    for (EGLSurfaceHolder holder : mConversionSurfaces) {
        if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)) {
            makeCurrent(holder.eglSurface);
            // glReadPixels reads from the bottom of the buffer, so add an extra vertical flip
            drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing == CameraCharacteristics.LENS_FACING_FRONT) ? FLIP_TYPE_BOTH : FLIP_TYPE_VERTICAL);
            mPBufferPixels.clear();
            GLES20.glReadPixels(/*x*/
            0, /*y*/
            0, holder.width, holder.height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, mPBufferPixels);
            checkGlError(""glReadPixels"");
            try {
                int format = LegacyCameraDevice.detectSurfaceType(holder.surface);
                LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height);
                LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second);
                LegacyCameraDevice.produceFrame(holder.surface, mPBufferPixels.array(), holder.width, holder.height, format);
            } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
                Log.w(TAG, ""Surface abandoned, dropping frame. "", e);
                request.setOutputAbandoned();
            }
        }
    }
    targetCollector.previewProduced();
    if (doTiming) {
        endGlTiming();
    }
}","{
    if ((mSurfaces == null || mSurfaces.size() == 0) && (mConversionSurfaces == null || mConversionSurfaces.size() == 0)) {
        return;
    }
    boolean doTiming = targetCollector.hasPendingPreviewCaptures();
    checkGlError(""before updateTexImage"");
    if (doTiming) {
        beginGlTiming();
    }
    mSurfaceTexture.updateTexImage();
    long timestamp = mSurfaceTexture.getTimestamp();
    Pair<RequestHolder, Long> captureHolder = targetCollector.previewCaptured(timestamp);
    // No preview request queued, drop frame.
    if (captureHolder == null) {
        if (DEBUG) {
            Log.d(TAG, ""Dropping preview frame."");
        }
        if (doTiming) {
            endGlTiming();
        }
        return;
    }
    RequestHolder request = captureHolder.first;
    Collection<Surface> targetSurfaces = request.getHolderTargets();
    if (doTiming) {
        addGlTimestamp(timestamp);
    }
    List<Long> targetSurfaceIds = new ArrayList();
    try {
        targetSurfaceIds = LegacyCameraDevice.getSurfaceIds(targetSurfaces);
    } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
        Log.w(TAG, ""Surface abandoned, dropping frame. "", e);
        request.setOutputAbandoned();
    }
    for (EGLSurfaceHolder holder : mSurfaces) {
        if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)) {
            try {
                LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height);
                makeCurrent(holder.eglSurface);
                LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second);
                drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing == CameraCharacteristics.LENS_FACING_FRONT) ? FLIP_TYPE_HORIZONTAL : FLIP_TYPE_NONE);
                swapBuffers(holder.eglSurface);
            } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
                Log.w(TAG, ""Surface abandoned, dropping frame. "", e);
                request.setOutputAbandoned();
            }
        }
    }
    for (EGLSurfaceHolder holder : mConversionSurfaces) {
        if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)) {
            makeCurrent(holder.eglSurface);
            // glReadPixels reads from the bottom of the buffer, so add an extra vertical flip
            try {
                drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing == CameraCharacteristics.LENS_FACING_FRONT) ? FLIP_TYPE_BOTH : FLIP_TYPE_VERTICAL);
            } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
                // Should never hit this.
                throw new IllegalStateException(""Surface abandoned, skipping drawFrame..."", e);
            }
            mPBufferPixels.clear();
            GLES20.glReadPixels(/*x*/
            0, /*y*/
            0, holder.width, holder.height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, mPBufferPixels);
            checkGlError(""glReadPixels"");
            try {
                int format = LegacyCameraDevice.detectSurfaceType(holder.surface);
                LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height);
                LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second);
                LegacyCameraDevice.produceFrame(holder.surface, mPBufferPixels.array(), holder.width, holder.height, format);
            } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
                Log.w(TAG, ""Surface abandoned, dropping frame. "", e);
                request.setOutputAbandoned();
            }
        }
    }
    targetCollector.previewProduced();
    if (doTiming) {
        endGlTiming();
    }
}",1,"/**
 * Draw the current buffer in the {@link SurfaceTexture} returned from
 * {@link #getSurfaceTexture()} into the set of target {@link Surface}s
 * in the next request from the given {@link CaptureCollector}, or drop
 * the frame if none is available.
 *
 * <p>
 * Any {@link Surface}s targeted must be a subset of the {@link Surface}s
 * set in the last {@link #configureSurfaces(java.util.Collection)} call.
 * </p>
 *
 * @param targetCollector the surfaces to draw to.
 */
","/**
 * Draw the current buffer in the {@link SurfaceTexture} returned from
 * {@link #getSurfaceTexture()} into the set of target {@link Surface}s
 * in the next request from the given {@link CaptureCollector}, or drop
 * the frame if none is available.
 *
 * <p>
 * Any {@link Surface}s targeted must be a subset of the {@link Surface}s
 * set in the last {@link #configureSurfaces(java.util.Collection)} call.
 * </p>
 *
 * @param targetCollector the surfaces to draw to.
 */
",0,,,0,,,0,"1,2",2,2,"3, 2",2,"In the late version of the implementation, a new exception handling statement is added in the second for loop:",        // Should never hit this.
178,<android.net.Uri: Uri normalizeScheme()>,25,26,<android.net.Uri: Uri normalizeScheme()>,<android.net.Uri: Uri normalizeScheme()>,0,"{
    String scheme = getScheme();
    // give up
    if (scheme == null)
        return this;
    String lowerScheme = scheme.toLowerCase(Locale.ROOT);
    // no change
    if (scheme.equals(lowerScheme))
        return this;
    return buildUpon().scheme(lowerScheme).build();
}","{
    String scheme = getScheme();
    // give up
    if (scheme == null)
        return this;
    String lowerScheme = scheme.toLowerCase(Locale.ROOT);
    // no change
    if (scheme.equals(lowerScheme))
        return this;
    return buildUpon().scheme(lowerScheme).build();
}",0,"/**
 * Return an equivalent URI with a lowercase scheme component.
 * This aligns the Uri with Android best practices for
 * intent filtering.
 *
 * <p>For example, ""HTTP://www.android.com"" becomes
 * ""http://www.android.com""
 *
 * <p>All URIs received from outside Android (such as user input,
 * or external sources like Bluetooth, NFC, or the Internet) should
 * be normalized before they are used to create an Intent.
 *
 * <p class=""note"">This method does <em>not</em> validate bad URI's,
 * or 'fix' poorly formatted URI's - so do not use it for input validation.
 * A Uri will always be returned, even if the Uri is badly formatted to
 * begin with and a scheme component cannot be found.
 *
 * @return normalized Uri (never null)
 * @see {@link android.content.Intent#setData}
 * @see {@link android.content.Intent#setDataAndNormalize}
 */
","/**
 * Return an equivalent URI with a lowercase scheme component.
 * This aligns the Uri with Android best practices for
 * intent filtering.
 *
 * <p>For example, ""HTTP://www.android.com"" becomes
 * ""http://www.android.com""
 *
 * <p>All URIs received from outside Android (such as user input,
 * or external sources like Bluetooth, NFC, or the Internet) should
 * be normalized before they are used to create an Intent.
 *
 * <p class=""note"">This method does <em>not</em> validate bad URI's,
 * or 'fix' poorly formatted URI's - so do not use it for input validation.
 * A Uri will always be returned, even if the Uri is badly formatted to
 * begin with and a scheme component cannot be found.
 *
 * @return normalized Uri (never null)
 * @see android.content.Intent#setData
 * @see android.content.Intent#setDataAndNormalize
 */
",1,,,0,,,0,0,0,0,0,0,"The implementation of the `normalizeScheme()` method has not changed between versions 25 and 26. Therefore, the code change type is 0 (No change).","As there is no change in the implementation of the method between the two versions, there is no potential Compatibility Issue (CI) that could arise. Therefore, the CI type is 0 (No Compatibility Issue)."
179,<android.widget.GridView: void setRemoteViewsAdapter(Intent)>,25,26,<android.widget.GridView: void setRemoteViewsAdapter(Intent)>,<android.widget.GridView: void setRemoteViewsAdapter(Intent)>,0,"{
    super.setRemoteViewsAdapter(intent);
}","{
    super.setRemoteViewsAdapter(intent);
}",0,"/**
 * Sets up this AbsListView to use a remote views adapter which connects to a RemoteViewsService
 * through the specified intent.
 * @param intent the intent used to identify the RemoteViewsService for the adapter to connect to.
 */
","/**
 * Sets up this AbsListView to use a remote views adapter which connects to a RemoteViewsService
 * through the specified intent.
 * @param intent the intent used to identify the RemoteViewsService for the adapter to connect to.
 */
",0,[@android.view.RemotableViewMethod],[@android.view.RemotableViewMethod(asyncImpl = "setRemoteViewsAdapterAsync")],1,,,0,0,0,0,5,0,The annotation has changed from `@android.view.RemotableViewMethod` to `@android.view.RemotableViewMethod(asyncImpl = "setRemoteViewsAdapterAsync")`. It indicates that there is a new async implementation "setRemoteViewsAdapterAsync" introduced in the late version.,"No Compatibility Issue arises since the implementation of the method itself has not changed, and the async implementation does not affect the behavior of the current method invocation."
180,<android.os.MemoryFile.MemoryInputStream: int available()>,26,27,<android.os.MemoryFile.MemoryInputStream: int available()>,<android.os.MemoryFile.MemoryInputStream: int available()>,0,"{
    if (mOffset >= mLength) {
        return 0;
    }
    return mLength - mOffset;
}","{
    if (mOffset >= mSharedMemory.getSize()) {
        return 0;
    }
    return mSharedMemory.getSize() - mOffset;
}",1,,,0,[@Override],[@Override],0,,,0,"1,2","1,3,4",1,3,1,The condition in the 'if' statement and the statement in the 'return' have both changed from `mLength` to `mSharedMemory.getSize()`. This is a control dependency change and a return statement change.,"The change in the condition of the 'if' statement and the variable used in the 'return' statement could affect the value returned by the API. In the early version, the value returned is based on `mLength`, while in the late version, the value returned is based on `mSharedMemory.getSize()`. This difference could lead to a Compatibility Issue (CI) where the API returns a different value in the two versions."
181,"<android.text.InputFilter: CharSequence filter(CharSequence,int,int,Spanned,int,int)>",26,27,"<android.text.InputFilter: CharSequence filter(CharSequence,int,int,Spanned,int,int)>","<android.text.InputFilter: CharSequence filter(CharSequence,int,int,Spanned,int,int)>",0,,,0,"/**
 * This method is called when the buffer is going to replace the
 * range <code>dstart &hellip; dend</code> of <code>dest</code>
 * with the new text from the range <code>start &hellip; end</code>
 * of <code>source</code>.  Return the CharSequence that you would
 * like to have placed there instead, including an empty string
 * if appropriate, or <code>null</code> to accept the original
 * replacement.  Be careful to not to reject 0-length replacements,
 * as this is what happens when you delete text.  Also beware that
 * you should not attempt to make any changes to <code>dest</code>
 * from this method; you may only examine it for context.
 *
 * Note: If <var>source</var> is an instance of {@link Spanned} or
 * {@link Spannable}, the span objects in the <var>source</var> should be
 * copied into the filtered result (i.e. the non-null return value).
 * {@link TextUtils#copySpansFrom} can be used for convenience.
 */
","/**
 * This method is called when the buffer is going to replace the
 * range <code>dstart &hellip; dend</code> of <code>dest</code>
 * with the new text from the range <code>start &hellip; end</code>
 * of <code>source</code>.  Return the CharSequence that you would
 * like to have placed there instead, including an empty string
 * if appropriate, or <code>null</code> to accept the original
 * replacement.  Be careful to not to reject 0-length replacements,
 * as this is what happens when you delete text.  Also beware that
 * you should not attempt to make any changes to <code>dest</code>
 * from this method; you may only examine it for context.
 *
 * Note: If <var>source</var> is an instance of {@link Spanned} or
 * {@link Spannable}, the span objects in the <var>source</var> should be
 * copied into the filtered result (i.e. the non-null return value).
 * {@link TextUtils#copySpansFrom} can be used for convenience if the
 * span boundary indices would be remaining identical relative to the source.
 */
",1,,,0,,,0,0,0,0,0,0,"There is no code provided for both early and late implementations, so we cannot determine any code change.","There is no code provided for both early and late implementations, so we cannot determine any Compatibility Issue."
182,<android.view.textclassifier.TextClassification: String getText()>,26,27,<android.view.textclassifier.TextClassification: String getText()>,<android.view.textclassifier.TextClassification: String getText()>,0,"{
    return mText;
}","{
    return mText;
}",0,"/**
 * Gets the classified text.
 */
","/**
 * Gets the classified text.
 */
",0,[@NonNull],[@Nullable],1,,,0,0,0,0,5,1,"The annotation of the API has changed from @NonNull to @Nullable, so the code change type is 5.","As the annotation of the API has changed from @NonNull to @Nullable, the value that this API returns could be null in the late version, which could lead to different behaviors when this API is invoked. Therefore, the CI type is 1."
183,<android.os.MemoryFile.MemoryInputStream: int available()>,26,27,<android.os.MemoryFile.MemoryInputStream: int available()>,<android.os.MemoryFile.MemoryInputStream: int available()>,0,"{
    if (mOffset >= mLength) {
        return 0;
    }
    return mLength - mOffset;
}","{
    if (mOffset >= mSharedMemory.getSize()) {
        return 0;
    }
    return mSharedMemory.getSize() - mOffset;
}",1,,,0,[@Override],[@Override],0,,,0,"1,2","1,3,4",1,3,1,"The condition statement in the 'if' statement and the return statement have changed. In the late version, the variable 'mLength' is replaced by 'mSharedMemory.getSize()'.","The change of the return statement may cause the API to return a different value. The value of 'mSharedMemory.getSize()' may be different from 'mLength'. Therefore, it leads to a compatibility issue that the API potentially returns different values."
184,"<android.text.InputFilter: CharSequence filter(CharSequence,int,int,Spanned,int,int)>",27,28,"<android.text.InputFilter: CharSequence filter(CharSequence,int,int,Spanned,int,int)>","<android.text.InputFilter: CharSequence filter(CharSequence,int,int,Spanned,int,int)>",0,,,0,"/**
 * This method is called when the buffer is going to replace the
 * range <code>dstart &hellip; dend</code> of <code>dest</code>
 * with the new text from the range <code>start &hellip; end</code>
 * of <code>source</code>.  Return the CharSequence that you would
 * like to have placed there instead, including an empty string
 * if appropriate, or <code>null</code> to accept the original
 * replacement.  Be careful to not to reject 0-length replacements,
 * as this is what happens when you delete text.  Also beware that
 * you should not attempt to make any changes to <code>dest</code>
 * from this method; you may only examine it for context.
 *
 * Note: If <var>source</var> is an instance of {@link Spanned} or
 * {@link Spannable}, the span objects in the <var>source</var> should be
 * copied into the filtered result (i.e. the non-null return value).
 * {@link TextUtils#copySpansFrom} can be used for convenience.
 */
","/**
 * This method is called when the buffer is going to replace the
 * range <code>dstart &hellip; dend</code> of <code>dest</code>
 * with the new text from the range <code>start &hellip; end</code>
 * of <code>source</code>.  Return the CharSequence that you would
 * like to have placed there instead, including an empty string
 * if appropriate, or <code>null</code> to accept the original
 * replacement.  Be careful to not to reject 0-length replacements,
 * as this is what happens when you delete text.  Also beware that
 * you should not attempt to make any changes to <code>dest</code>
 * from this method; you may only examine it for context.
 *
 * Note: If <var>source</var> is an instance of {@link Spanned} or
 * {@link Spannable}, the span objects in the <var>source</var> should be
 * copied into the filtered result (i.e. the non-null return value).
 * {@link TextUtils#copySpansFrom} can be used for convenience if the
 * span boundary indices would be remaining identical relative to the source.
 */
",1,,,0,,,0,0,0,0,0,0,"There is no implementation and annotation provided for the given API in both early and late versions, so it's impossible to detect any change.","Since there is no implementation and annotation provided, it's also impossible to detect any compatibility issues. Therefore, there is no compatibility issue for this API."
185,<android.view.textclassifier.TextClassification: String getText()>,27,28,<android.view.textclassifier.TextClassification: String getText()>,<android.view.textclassifier.TextClassification: String getText()>,0,"{
    return mText;
}","{
    return mText;
}",0,"/**
 * Gets the classified text.
 */
","/**
 * Gets the classified text.
 */
",0,[@NonNull],[@Nullable],1,,,0,0,0,0,1,1,"Although there is no change in the implementation, the annotation for the return value has changed. In the early version, the annotation is @NonNull, while in the late version it is @Nullable.","The change in annotation indicates that the return value of the API can potentially be null in the late version, which may cause Compatibility Issues if the calling code is not prepared to handle null values. Therefore, this is a Compatibility Issue caused by potential different return values or types (type 1)."
186,"<android.view.textclassifier.TextSelection.Builder: Builder setEntityType(String,float)>",27,28,"<android.view.textclassifier.TextSelection.Builder: Builder setEntityType(String,float)>","<android.view.textclassifier.TextSelection.Builder: Builder setEntityType(String,float)>",0,"{
    mEntityConfidence.setEntityType(type, confidenceScore);
    return this;
}","{
    Preconditions.checkNotNull(type);
    mEntityConfidence.put(type, confidenceScore);
    return this;
}",1,"/**
 * Sets an entity type for the classified text and assigns a confidence score.
 *
 * @param confidenceScore a value from 0 (low confidence) to 1 (high confidence).
 * 0 implies the entity does not exist for the classified text.
 * Values greater than 1 are clamped to 1.
 */
","/**
 * Sets an entity type for the classified text and assigns a confidence score.
 *
 * @param confidenceScore a value from 0 (low confidence) to 1 (high confidence).
 * 0 implies the entity does not exist for the classified text.
 * Values greater than 1 are clamped to 1.
 */
",0,,[@NonNull],1,,,0,"1,2","1,4,5",1,"1,5",1,"The code change is a combination of return statement change and dependent API change. The return statement has changed from ""setEntityType"" to ""put"" method of the ""mEntityConfidence"" object. Additionally, the implementation now includes a null-check for the ""type"" parameter using ""Preconditions.checkNotNull(type)"". The ""setEntityType"" method in the early version has been replaced by the ""put"" method in the late version, indicating a dependent API change.","The Compatibility Issue is caused by potential different return values or types. The change in the method used to set the entity type (setEntityType to put) may result in different behavior of the API. Additionally, the null-check added in the late version may throw a NullPointerException if the ""type"" parameter is null, which is not the case in the early version. Therefore, the API may behave differently between the two versions, potentially leading to a compatibility issue."
187,"<android.bluetooth.BluetoothDevice: BluetoothGatt connectGatt(Context,boolean,BluetoothGattCallback)>",27,28,"<android.bluetooth.BluetoothDevice: BluetoothGatt connectGatt(Context,boolean,BluetoothGattCallback)>","<android.bluetooth.BluetoothDevice: BluetoothGatt connectGatt(Context,boolean,BluetoothGattCallback)>",0,"{
    return (connectGatt(context, autoConnect, callback, TRANSPORT_AUTO));
}","{
    return (connectGatt(context, autoConnect, callback, TRANSPORT_AUTO));
}",0,"/**
 * Connect to GATT Server hosted by this device. Caller acts as GATT client.
 * The callback is used to deliver results to Caller, such as connection status as well
 * as any further GATT client operations.
 * The method returns a BluetoothGatt instance. You can use BluetoothGatt to conduct
 * GATT client operations.
 * @param callback GATT callback handler that will receive asynchronous callbacks.
 * @param autoConnect Whether to directly connect to the remote device (false)
 * or to automatically connect as soon as the remote
 * device becomes available (true).
 * @throws IllegalArgumentException if callback is null
 */
","/**
 * Connect to GATT Server hosted by this device. Caller acts as GATT client.
 * The callback is used to deliver results to Caller, such as connection status as well
 * as any further GATT client operations.
 * The method returns a BluetoothGatt instance. You can use BluetoothGatt to conduct
 * GATT client operations.
 *
 * @param callback GATT callback handler that will receive asynchronous callbacks.
 * @param autoConnect Whether to directly connect to the remote device (false) or to
 * automatically connect as soon as the remote device becomes available (true).
 * @throws IllegalArgumentException if callback is null
 */
",1,,,0,,,0,0,0,0,0,0,The implementations and annotations of the given API remain unchanged between the two versions.,"There is no code change that leads to different behaviors, so there is no Compatibility Issue."
188,<android.inputmethodservice.IInputMethodWrapper: void bindInput(InputBinding)>,27,28,<android.inputmethodservice.IInputMethodWrapper: void bindInput(InputBinding)>,<android.inputmethodservice.IInputMethodWrapper: void bindInput(InputBinding)>,0,"{
    // This IInputContext is guaranteed to implement all the methods.
    final int missingMethodFlags = 0;
    InputConnection ic = new InputConnectionWrapper(mTarget, IInputContext.Stub.asInterface(binding.getConnectionToken()), missingMethodFlags);
    InputBinding nu = new InputBinding(ic, binding);
    mCaller.executeOrSendMessage(mCaller.obtainMessageO(DO_SET_INPUT_CONTEXT, nu));
}","{
    if (mIsUnbindIssued != null) {
        Log.e(TAG, ""bindInput must be paired with unbindInput."");
    }
    mIsUnbindIssued = new AtomicBoolean();
    // This IInputContext is guaranteed to implement all the methods.
    final int missingMethodFlags = 0;
    InputConnection ic = new InputConnectionWrapper(mTarget, IInputContext.Stub.asInterface(binding.getConnectionToken()), missingMethodFlags, mIsUnbindIssued);
    InputBinding nu = new InputBinding(ic, binding);
    mCaller.executeOrSendMessage(mCaller.obtainMessageO(DO_SET_INPUT_CONTEXT, nu));
}",1,,,0,[@Override],"[@BinderThread, @Override]",1,,,0,"1,2","3,4,5",0,"4,5",1,"In the late version, an additional if-statement has been added before the initialization of the ""missingMethodFlags"" variable, which checks whether the ""mIsUnbindIssued"" variable is null. If it is not null, an error message will be logged. Also, a new parameter ""mIsUnbindIssued"" is passed to the constructor of ""InputConnectionWrapper"" class. Furthermore, the annotation has been changed from ""[@Override]"" to ""[@BinderThread, @Override]"".","The added if-statement and the new parameter passed to the ""InputConnectionWrapper"" constructor potentially lead to different behavior when the ""bindInput"" method is invoked. Specifically, if ""mIsUnbindIssued"" is not null, an error message will be logged and the method will return without initializing ""InputConnection"" and ""InputBinding"" objects. This is a compatibility issue caused by potential different return values or types."
189,<android.os.MemoryFile.MemoryInputStream: int available()>,28,29,<android.os.MemoryFile.MemoryInputStream: int available()>,<android.os.MemoryFile.MemoryInputStream: int available()>,0,"{
    if (mOffset >= mLength) {
        return 0;
    }
    return mLength - mOffset;
}","{
    if (mOffset >= mSharedMemory.getSize()) {
        return 0;
    }
    return mSharedMemory.getSize() - mOffset;
}",1,,,0,[@Override],[@Override],0,,,0,"1,2","1,3",1,"3, 1",1,"The implementation of the available() method has changed. In the early version, the method returns the difference between mLength and mOffset, while in the late version, it returns the difference between mSharedMemory.getSize() and mOffset. The variable mLength in the early version has been replaced with mSharedMemory.getSize() in the late version, indicating a control dependency change (change type 3). Additionally, the return statement has been changed (change type 1).","The change in the return statement and control dependency can potentially cause the API to return different values. In the early version, the method returns the difference between mLength and mOffset, while in the late version, it returns the difference between mSharedMemory.getSize() and mOffset. If the value of mLength and mSharedMemory.getSize() are different, the method will return different values in different versions, leading to a compatibility issue (CI type 1)."
190,"<android.text.InputFilter: CharSequence filter(CharSequence,int,int,Spanned,int,int)>",28,29,"<android.text.InputFilter: CharSequence filter(CharSequence,int,int,Spanned,int,int)>","<android.text.InputFilter: CharSequence filter(CharSequence,int,int,Spanned,int,int)>",0,,,0,"/**
 * This method is called when the buffer is going to replace the
 * range <code>dstart &hellip; dend</code> of <code>dest</code>
 * with the new text from the range <code>start &hellip; end</code>
 * of <code>source</code>.  Return the CharSequence that you would
 * like to have placed there instead, including an empty string
 * if appropriate, or <code>null</code> to accept the original
 * replacement.  Be careful to not to reject 0-length replacements,
 * as this is what happens when you delete text.  Also beware that
 * you should not attempt to make any changes to <code>dest</code>
 * from this method; you may only examine it for context.
 *
 * Note: If <var>source</var> is an instance of {@link Spanned} or
 * {@link Spannable}, the span objects in the <var>source</var> should be
 * copied into the filtered result (i.e. the non-null return value).
 * {@link TextUtils#copySpansFrom} can be used for convenience.
 */
","/**
 * This method is called when the buffer is going to replace the
 * range <code>dstart &hellip; dend</code> of <code>dest</code>
 * with the new text from the range <code>start &hellip; end</code>
 * of <code>source</code>.  Return the CharSequence that you would
 * like to have placed there instead, including an empty string
 * if appropriate, or <code>null</code> to accept the original
 * replacement.  Be careful to not to reject 0-length replacements,
 * as this is what happens when you delete text.  Also beware that
 * you should not attempt to make any changes to <code>dest</code>
 * from this method; you may only examine it for context.
 *
 * Note: If <var>source</var> is an instance of {@link Spanned} or
 * {@link Spannable}, the span objects in the <var>source</var> should be
 * copied into the filtered result (i.e. the non-null return value).
 * {@link TextUtils#copySpansFrom} can be used for convenience if the
 * span boundary indices would be remaining identical relative to the source.
 */
",1,,,0,,,0,0,0,0,0,0,"Both implementation and annotation of the given API are missing, it's impossible to detect any code change between two versions.","Both implementation and annotation of the given API are missing, it's impossible to detect whether potential Compatibility Issue could arise for the API."
191,<android.view.textclassifier.TextClassification: String getText()>,28,29,<android.view.textclassifier.TextClassification: String getText()>,<android.view.textclassifier.TextClassification: String getText()>,0,"{
    return mText;
}","{
    return mText;
}",0,"/**
 * Gets the classified text.
 */
","/**
 * Gets the classified text.
 */
",0,[@NonNull],[@Nullable],1,,,0,0,0,0,0,0,"The code implementation has not changed, but the annotation has changed from `@NonNull` to `@Nullable`. The change does not affect the behavior of the API, as it only affects the nullability of the returned value.","The annotation change does not cause any compatibility issue, as it only affects the nullability of the returned value. The implementation code of the API has not changed and therefore it will not lead to different behaviors. Therefore, there is no compatibility issue."
192,"<android.view.textclassifier.TextSelection.Builder: Builder setEntityType(String,float)>",28,29,"<android.view.textclassifier.TextSelection.Builder: Builder setEntityType(String,float)>","<android.view.textclassifier.TextSelection.Builder: Builder setEntityType(String,float)>",0,"{
    mEntityConfidence.setEntityType(type, confidenceScore);
    return this;
}","{
    Preconditions.checkNotNull(type);
    mEntityConfidence.put(type, confidenceScore);
    return this;
}",1,"/**
 * Sets an entity type for the classified text and assigns a confidence score.
 *
 * @param confidenceScore a value from 0 (low confidence) to 1 (high confidence).
 * 0 implies the entity does not exist for the classified text.
 * Values greater than 1 are clamped to 1.
 */
","/**
 * Sets an entity type for the classified text and assigns a confidence score.
 *
 * @param confidenceScore a value from 0 (low confidence) to 1 (high confidence).
 * 0 implies the entity does not exist for the classified text.
 * Values greater than 1 are clamped to 1.
 */
",0,,[@NonNull],1,,,0,"1,2","1,4,5",1,"1,5",1,"The API's return statement stays the same in the early and late versions. However, the method used to set the entity type has been changed from setEntityType() to put(), and there is a new parameter check statement added in the late version. The change of method used and the added check statement indicate that the code change type is 1,5.","The change of method used for setting the entity type and the added check statement could potentially cause the API to return different values, so the CI type is 1."
193,"<android.bluetooth.BluetoothDevice: BluetoothGatt connectGatt(Context,boolean,BluetoothGattCallback)>",28,29,"<android.bluetooth.BluetoothDevice: BluetoothGatt connectGatt(Context,boolean,BluetoothGattCallback)>","<android.bluetooth.BluetoothDevice: BluetoothGatt connectGatt(Context,boolean,BluetoothGattCallback)>",0,"{
    return (connectGatt(context, autoConnect, callback, TRANSPORT_AUTO));
}","{
    return (connectGatt(context, autoConnect, callback, TRANSPORT_AUTO));
}",0,"/**
 * Connect to GATT Server hosted by this device. Caller acts as GATT client.
 * The callback is used to deliver results to Caller, such as connection status as well
 * as any further GATT client operations.
 * The method returns a BluetoothGatt instance. You can use BluetoothGatt to conduct
 * GATT client operations.
 * @param callback GATT callback handler that will receive asynchronous callbacks.
 * @param autoConnect Whether to directly connect to the remote device (false)
 * or to automatically connect as soon as the remote
 * device becomes available (true).
 * @throws IllegalArgumentException if callback is null
 */
","/**
 * Connect to GATT Server hosted by this device. Caller acts as GATT client.
 * The callback is used to deliver results to Caller, such as connection status as well
 * as any further GATT client operations.
 * The method returns a BluetoothGatt instance. You can use BluetoothGatt to conduct
 * GATT client operations.
 *
 * @param callback GATT callback handler that will receive asynchronous callbacks.
 * @param autoConnect Whether to directly connect to the remote device (false) or to
 * automatically connect as soon as the remote device becomes available (true).
 * @throws IllegalArgumentException if callback is null
 */
",1,,,0,,,0,0,0,0,0,0,"There's no change in the implementation and annotation of the given API, so the code change is 0.","As there is no change in the implementation, there is no potential for a compatibility issue, so the CI type is 0."
194,<android.inputmethodservice.IInputMethodWrapper: void bindInput(InputBinding)>,28,29,<android.inputmethodservice.IInputMethodWrapper: void bindInput(InputBinding)>,<android.inputmethodservice.IInputMethodWrapper: void bindInput(InputBinding)>,0,"{
    // This IInputContext is guaranteed to implement all the methods.
    final int missingMethodFlags = 0;
    InputConnection ic = new InputConnectionWrapper(mTarget, IInputContext.Stub.asInterface(binding.getConnectionToken()), missingMethodFlags);
    InputBinding nu = new InputBinding(ic, binding);
    mCaller.executeOrSendMessage(mCaller.obtainMessageO(DO_SET_INPUT_CONTEXT, nu));
}","{
    if (mIsUnbindIssued != null) {
        Log.e(TAG, ""bindInput must be paired with unbindInput."");
    }
    mIsUnbindIssued = new AtomicBoolean();
    // This IInputContext is guaranteed to implement all the methods.
    final int missingMethodFlags = 0;
    InputConnection ic = new InputConnectionWrapper(mTarget, IInputContext.Stub.asInterface(binding.getConnectionToken()), missingMethodFlags, mIsUnbindIssued);
    InputBinding nu = new InputBinding(ic, binding);
    mCaller.executeOrSendMessage(mCaller.obtainMessageO(DO_SET_INPUT_CONTEXT, nu));
}",1,,,0,[@Override],"[@BinderThread, @Override]",1,,,0,"1,2","3,4,5",0,5,1,"A new parameter 'mIsUnbindIssued' is added to the constructor of InputConnectionWrapper class. The new parameter is an AtomicBoolean object and its value is determined by a new if-statement. The if-statement checks whether the 'mIsUnbindIssued' variable is null and logs an error message if it is not null. This change can be classified as 'Dependent API changed' (5), because the change is about the parameters of the dependent API (i.e., InputConnectionWrapper constructor).","The added parameter 'mIsUnbindIssued' in InputConnectionWrapper constructor might affect the behavior of the API and cause compatibility issues. The new parameter is used for checking whether the unbindInput method has been called or not. If the 'bindInput' method is called without calling 'unbindInput' first, then an error message will be logged. Therefore, the new code might return a different value or throw a different exception compared to the old code, leading to compatibility issues. The CI type is 'Compatibility Issue caused by potential different return values or types' (1)."
195,<android.widget.CheckedTextView: Mode getCheckMarkTintMode()>,28,29,<android.widget.CheckedTextView: Mode getCheckMarkTintMode()>,<android.widget.CheckedTextView: Mode getCheckMarkTintMode()>,0,"{
    return mCheckMarkTintMode;
}","{
    return mCheckMarkBlendMode != null ? BlendMode.blendModeToPorterDuffMode(mCheckMarkBlendMode) : null;
}",1,"/**
 * Returns the blending mode used to apply the tint to the check mark
 * drawable, if specified.
 *
 * @return the blending mode used to apply the tint to the check mark
 * drawable
 * @attr ref android.R.styleable#CheckedTextView_checkMarkTintMode
 * @see #setCheckMarkTintMode(PorterDuff.Mode)
 */
","/**
 * Returns the blending mode used to apply the tint to the check mark
 * drawable, if specified.
 *
 * @return the blending mode used to apply the tint to the check mark
 * drawable
 * @attr ref android.R.styleable#CheckedTextView_checkMarkTintMode
 * @see #setCheckMarkTintMode(PorterDuff.Mode)
 */
",0,[@Nullable],"[@InspectableProperty, @Nullable]",1,,,0,"1,2","1,4",1,"1,5",1,"The return statement has changed from return mCheckMarkTintMode; to return mCheckMarkBlendMode != null ? BlendMode.blendModeToPorterDuffMode(mCheckMarkBlendMode) : null;. The value of the returned variables are potentially different. The new implementation also involves a new method BlendMode.blendModeToPorterDuffMode(), which is a dependent API change. So the code change type is 1,5.","As the return statement has changed and the new implementation involves a different dependent API method, the API may return different values in the late version. Therefore, it could lead to a Compatibility Issue, and the CI type is 1."
196,<android.accessibilityservice.AccessibilityService.SoftKeyboardController: boolean setShowMode(int)>,28,29,<android.accessibilityservice.AccessibilityService.SoftKeyboardController: boolean setShowMode(int)>,<android.accessibilityservice.AccessibilityService.SoftKeyboardController: boolean setShowMode(int)>,0,"{
    final IAccessibilityServiceConnection connection = AccessibilityInteractionClient.getInstance().getConnection(mService.mConnectionId);
    if (connection != null) {
        try {
            return connection.setSoftKeyboardShowMode(showMode);
        } catch (RemoteException re) {
            Log.w(LOG_TAG, ""Failed to set soft keyboard behavior"", re);
            re.rethrowFromSystemServer();
        }
    }
    return false;
}","{
    final IAccessibilityServiceConnection connection = AccessibilityInteractionClient.getInstance().getConnection(mService.mConnectionId);
    if (connection != null) {
        try {
            return connection.setSoftKeyboardShowMode(showMode);
        } catch (RemoteException re) {
            Log.w(LOG_TAG, ""Failed to set soft keyboard behavior"", re);
            re.rethrowFromSystemServer();
        }
    }
    return false;
}",0,"/**
 * Sets the soft keyboard show mode. The default show mode is
 * {@code SHOW_MODE_AUTO}, where the soft keyboard is shown when a text input field is
 * focused. An AccessibilityService can also request the show mode
 * {@code SHOW_MODE_HIDDEN}, where the soft keyboard is never shown. The
 * The lastto this method will be honored, regardless of any previous calls (including those
 * made by other AccessibilityServices).
 * <p>
 * <strong>Note:</strong> If the service is not yet connected (e.g.
 * {@link AccessibilityService#onServiceConnected()} has not yet been called) or the
 * service has been disconnected, this method will have no effect and return {@code false}.
 *
 * @param showMode the new show mode for the soft keyboard
 * @return {@code true} on success
 */
","/**
 * Sets the soft keyboard show mode.
 * <p>
 * <strong>Note:</strong> If the service is not yet connected (e.g.
 * {@link AccessibilityService#onServiceConnected()} has not yet been called) or the
 * service has been disconnected, this method will have no effect and return {@code false}.
 *
 * @param showMode the new show mode for the soft keyboard
 * @return {@code true} on success
 *
 * @see AccessibilityService#SHOW_MODE_AUTO
 * @see AccessibilityService#SHOW_MODE_HIDDEN
 * @see AccessibilityService#SHOW_MODE_IGNORE_HARD_KEYBOARD
 */
",1,,,0,,,0,0,0,0,0,0,There is no code change between the early version and the late version.,"As there is no code change, the API's behavior will not be different, so there is no compatibility issue."
197,"<android.view.textclassifier.TextSelection.Builder: Builder setEntityType(String,float)>",29,30,"<android.view.textclassifier.TextSelection.Builder: Builder setEntityType(String,float)>","<android.view.textclassifier.TextSelection.Builder: Builder setEntityType(String,float)>",0,"{
    Preconditions.checkNotNull(type);
    mEntityConfidence.put(type, confidenceScore);
    return this;
}","{
    Objects.requireNonNull(type);
    mEntityConfidence.put(type, confidenceScore);
    return this;
}",1,"/**
 * Sets an entity type for the classified text and assigns a confidence score.
 *
 * @param confidenceScore a value from 0 (low confidence) to 1 (high confidence).
 * 0 implies the entity does not exist for the classified text.
 * Values greater than 1 are clamped to 1.
 */
","/**
 * Sets an entity type for the classified text and assigns a confidence score.
 *
 * @param confidenceScore a value from 0 (low confidence) to 1 (high confidence).
 * 0 implies the entity does not exist for the classified text.
 * Values greater than 1 are clamped to 1.
 */
",0,[@NonNull],[@NonNull],0,,,0,"1,2",5,0,4,0,"The implementation of the method has changed from using `Preconditions.checkNotNull(type)` to `Objects.requireNonNull(type)`. Both statements are used for null-checking and will throw a NullPointerException if the input is null. However, this change is classified as ""Other statement changed"" (4), as it does not fall under return statements, exception handling statements, or control dependency changes.","Although the null-checking method has been changed, the behavior of the API remains the same. The method will throw a NullPointerException if the input is null in both versions. Therefore, this change does not cause a Compatibility Issue."
198,"<android.net.ConnectivityManager.NetworkCallback: void onLinkPropertiesChanged(Network,LinkProperties)>",29,30,"<android.net.ConnectivityManager.NetworkCallback: void onLinkPropertiesChanged(Network,LinkProperties)>","<android.net.ConnectivityManager.NetworkCallback: void onLinkPropertiesChanged(Network,LinkProperties)>",0,"{
}","{
}",0,"/**
 * Called when the network the framework connected to for this request
 * changes {@link LinkProperties}.
 *
 * @param network The {@link Network} whose link properties have changed.
 * @param linkProperties The new {@link LinkProperties} for this network.
 */
","/**
 * Called when the network corresponding to this request changes {@link LinkProperties}.
 *
 * <p>Starting with {@link android.os.Build.VERSION_CODES#O} this method is guaranteed
 * to be called immediately after {@link #onAvailable}.
 *
 * <p>Do NOT call {@link #getNetworkCapabilities(Network)} or other synchronous
 * ConnectivityManager methods in this callback as this is prone to race conditions :
 * calling these methods while in a callback may return an outdated or even a null object.
 *
 * @param network The {@link Network} whose link properties have changed.
 * @param linkProperties The new {@link LinkProperties} for this network.
 */
",1,,,0,,,0,0,0,0,0,0,"The implementation of the API is empty, and there is no change between the two versions.","As there is no code change, it will not cause any compatibility issue."
199,<android.hardware.radio.RadioManager.ModuleProperties: String toString()>,29,30,<android.hardware.radio.RadioManager.ModuleProperties: String toString()>,<android.hardware.radio.RadioManager.ModuleProperties: String toString()>,0,"{
    return ""ModuleProperties [mId="" + mId + "", mServiceName="" + mServiceName + "", mClassId="" + mClassId + "", mImplementor="" + mImplementor + "", mProduct="" + mProduct + "", mVersion="" + mVersion + "", mSerial="" + mSerial + "", mNumTuners="" + mNumTuners + "", mNumAudioSources="" + mNumAudioSources + "", mIsInitializationRequired="" + mIsInitializationRequired + "", mIsCaptureSupported="" + mIsCaptureSupported + "", mIsBgScanSupported="" + mIsBgScanSupported + "", mBands="" + Arrays.toString(mBands) + ""]"";
}","{
    return ""ModuleProperties [mId="" + mId + "", mServiceName="" + mServiceName + "", mClassId="" + mClassId + "", mImplementor="" + mImplementor + "", mProduct="" + mProduct + "", mVersion="" + mVersion + "", mSerial="" + mSerial + "", mNumTuners="" + mNumTuners + "", mNumAudioSources="" + mNumAudioSources + "", mIsInitializationRequired="" + mIsInitializationRequired + "", mIsCaptureSupported="" + mIsCaptureSupported + "", mIsBgScanSupported="" + mIsBgScanSupported + "", mBands="" + Arrays.toString(mBands) + ""]"";
}",0,,,0,[@Override],"[@NonNull, @Override]",1,,,0,0,0,0,1,1,"The return statement did not change, but the annotation of the method changed. However, the annotation change does not affect the return value, so the code change type is 1.","As the return value is not affected by the annotation change, there is no compatibility issue caused by potential different return values or types."
200,"<android.app.admin.DeviceAdminReceiver: void onUserSwitched(Context,Intent,UserHandle)>",30,31,"<android.app.admin.DeviceAdminReceiver: void onUserSwitched(Context,Intent,UserHandle)>","<android.app.admin.DeviceAdminReceiver: void onUserSwitched(Context,Intent,UserHandle)>",0,"{
}","{
    if (LOCAL_LOGV) {
        Log.v(TAG, getClass().getName() + "".onUserSwitched() on user "" + context.getUserId());
    }
}",1,"/**
 * Called when a user or profile is switched to.
 *
 * <p>This callback is only applicable to device owners.
 *
 * @param context The running context as per {@link #onReceive}.
 * @param intent The received intent as per {@link #onReceive}.
 * @param switchedUser The {@link UserHandle} of the user that has just been switched to.
 */
","/**
 * Called when a user or profile is switched to.
 *
 * <p>This callback is only applicable to device owners.
 *
 * @param context The running context as per {@link #onReceive}.
 * @param intent The received intent as per {@link #onReceive}.
 * @param switchedUser The {@link UserHandle} of the user that has just been switched to.
 */
",0,,,0,,,0,"1,2","3,4",0,4,0,"The implementation of the method has been changed from an empty block to a logging statement, which is not included in return statements, exception handling statements, and statements about the control dependency. So, the code change type is 4.","The logging statement only output the log message, it does not change the behavior of the method. Therefore, no Compatibility Issue could arise for the API."
201,<android.bluetooth.BluetoothGattServer: List<BluetoothGattService> getServices()>,30,31,<android.bluetooth.BluetoothGattServer: List<BluetoothGattService> getServices()>,<android.bluetooth.BluetoothGattServer: List<BluetoothGattService> getServices()>,0,"{
    return mServices;
}","{
    return mServices;
}",0,"/**
 * Returns a list of GATT services offered by this device.
 *
 * <p>An application must call {@link #addService} to add a serice to the
 * list of services offered by this device.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @return List of services. Returns an empty list if no services have been added yet.
 */
","/**
 * Returns a list of GATT services offered by this device.
 *
 * <p>An application must call {@link #addService} to add a serice to the
 * list of services offered by this device.
 *
 * @return List of services. Returns an empty list if no services have been added yet.
 */
",1,,"[@RequiresLegacyBluetoothPermission, @RequiresNoPermission]",1,,,0,0,0,0,"0, 5",0,"The annotations have been added to the method, so the code change type is 5.","The added annotations do not affect the behavior of the method, so there is no Compatibility Issue."
202,<android.app.Application: void dispatchActivityPostStarted(Activity)>,30,31,<android.app.Application: void dispatchActivityPostStarted(Activity)>,<android.app.Application: void dispatchActivityPostStarted(Activity)>,0,"{
    Object[] callbacks = collectActivityLifecycleCallbacks();
    if (callbacks != null) {
        for (int i = 0; i < callbacks.length; i++) {
            ((ActivityLifecycleCallbacks) callbacks[i]).onActivityPostStarted(activity);
        }
    }
}","{
    Object[] callbacks = collectActivityLifecycleCallbacks();
    if (callbacks != null) {
        for (int i = 0; i < callbacks.length; i++) {
            ((ActivityLifecycleCallbacks) callbacks[i]).onActivityPostStarted(activity);
        }
    }
}",0,,,0,[@UnsupportedAppUsage],"[@UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553)]",1,,,0,0,0,0,0,0,There is no code change between the early version and the late version. Only the annotation has changed.,"The annotation change doesn't affect the behavior of the API, so it won't cause a Compatibility Issue."
203,"<android.hardware.camera2.impl.CameraMetadataNative: void set(Key<T>,T)>",31,32,"<android.hardware.camera2.impl.CameraMetadataNative: void set(Key<T>,T)>","<android.hardware.camera2.impl.CameraMetadataNative: void set(Key<T>,T)>",0,"{
    set(key.getNativeKey(), value);
}","{
    SetCommand s = sSetCommandMap.get(key);
    if (s != null) {
        s.setValue(this, value);
        return;
    }
    setBase(key, value);
}",1,,"/**
 * Set a camera metadata field to a value. The field definitions can be
 * found in {@link CameraCharacteristics}, {@link CaptureResult}, and
 * {@link CaptureRequest}.
 *
 * @param key The metadata field to write.
 * @param value The value to set the field to, which must be of a matching
 * type to the key.
 */
",1,,,0,,,0,"1,2","1,3,4,5",1,"1,3,5",1,"The implementation of the method has been completely changed. In the early version, the method `set(key.getNativeKey(), value)` is called directly. In the late version, the method first gets a `SetCommand` object by calling `sSetCommandMap.get(key)`. If the object is not null, it calls the `setValue()` method of the object and returns. Otherwise, it calls the `setBase()` method. This change can be classified into three categories: 1) Return statement changed, as the return statement has been added in the late version; 3) Control dependency changed, as the control flow has been changed by adding an if statement; 5) Dependent API changed, as the method now relies on the `sSetCommandMap.get(key)`, `setValue()`, and `setBase()` methods.","The change in the implementation can potentially cause the method to return different values or throw different exceptions, leading to a compatibility issue. For example, if the `sSetCommandMap` does not contain the key, the method will call `setBase()` in the late version, which may have different behavior compared to calling `set(key.getNativeKey(), value)` in the early version. Therefore, the CI type is 1 (Compatibility Issue caused by potential different return values or types)."
204,<android.view.accessibility.AccessibilityEvent: void setEventType(int)>,31,32,<android.view.accessibility.AccessibilityEvent: void setEventType(int)>,<android.view.accessibility.AccessibilityEvent: void setEventType(int)>,0,"{
    enforceNotSealed();
    mEventType = eventType;
}","{
    enforceNotSealed();
    mEventType = eventType;
}",0,"/**
 * Sets the event type.
 *
 * @param eventType The event type.
 *
 * @throws IllegalStateException If called from an AccessibilityService.
 */
","/**
 * Sets the event type.
 *
 * <b>Note: An event must represent a single event type.</b>
 * @param eventType The event type.
 *
 * @throws IllegalStateException If called from an AccessibilityService.
 */
",1,,,0,,,0,0,0,0,0,0,The code snippets provided in the Early_Implementation and Late_Implementation are identical.,"There is no change in the API implementation or annotations, so there is no compatibility issue."
205,<android.accessibilityservice.AccessibilityService: Context createDisplayContext(Display)>,31,32,<android.accessibilityservice.AccessibilityService: Context createDisplayContext(Display)>,<android.accessibilityservice.AccessibilityService: Context createDisplayContext(Display)>,0,"{
    final Context context = super.createDisplayContext(display);
    final int displayId = display.getDisplayId();
    setDefaultTokenInternal(context, displayId);
    return context;
}","{
    return new AccessibilityContext(super.createDisplayContext(display), mConnectionId);
}",1,,,0,[@Override],"[@NonNull, @Override]",1,,,0,"1,2","1,4",1,"1,5",1,"The return statement has changed from 'return context' to 'return new AccessibilityContext(super.createDisplayContext(display), mConnectionId)', and the new return statement has introduced a new dependent API 'AccessibilityContext', so the code change type is 1,5.","The return value of the API has changed, so the CI type is 1. The old API returns the result of 'super.createDisplayContext(display)' and sets the default token for the context, while the new API returns a new instance of 'AccessibilityContext' with 'super.createDisplayContext(display)' as one of its constructor parameters. Therefore, the behaviours of the two versions of the API are different, so the CI type is 1."
206,<android.os.UserManager: Bundle getUserRestrictions()>,32,33,<android.os.UserManager: Bundle getUserRestrictions()>,<android.os.UserManager: Bundle getUserRestrictions()>,0,"{
    return getUserRestrictions(Process.myUserHandle());
}","{
    try {
        return mService.getUserRestrictions(getContextUserIfAppropriate());
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns the user-wide restrictions imposed on this user.
 * @return a Bundle containing all the restrictions.
 */
","/**
 * Returns the user-wide restrictions imposed on the context user.
 * @return a Bundle containing all the restrictions.
 */
",1,,"[@UserHandleAware(enabledSinceTargetSdkVersion = Build.VERSION_CODES.TIRAMISU, requiresAnyOfPermissionsIfNotCallerProfileGroup = { android.Manifest.permission.MANAGE_USERS, android.Manifest.permission.INTERACT_ACROSS_USERS })]",1,,,0,"1,2","1,2,5","1,2","1,5","1,2","The implementation of the method `getUserRestrictions()` has changed from calling `getUserRestrictions(Process.myUserHandle())` to calling `mService.getUserRestrictions(getContextUserIfAppropriate())` and introducing a `try-catch` block for handling `RemoteException`. This means that the return statement has changed and the exception handling has also changed. Thus the change type is 1,5.","The change in the return statement and exception handling can potentially cause the API to return a different variable or throw a different exception. For example, the `getUserRestrictions()` method in the late version calls `mService.getUserRestrictions(getContextUserIfAppropriate())`, which may return a different result from `getUserRestrictions(Process.myUserHandle())` in the early version. Moreover, the introduction of the `try-catch` block in the late version means that a new exception (`RemoteException`) can be thrown, which was not present in the early version. Therefore, the CI type is 1,2."
207,<android.service.dreams.DreamService: boolean isScreenBright()>,32,33,<android.service.dreams.DreamService: boolean isScreenBright()>,<android.service.dreams.DreamService: boolean isScreenBright()>,0,"{
    return getWindowFlagValue(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON, mScreenBright);
}","{
    return getWindowFlagValue(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON, mScreenBright);
}",0,"/**
 * Returns whether or not this dream keeps the screen bright while dreaming.
 * Defaults to false, allowing the screen to dim if necessary.
 *
 * @see #setScreenBright(boolean)
 */
","/**
 * Returns whether this dream keeps the screen bright while dreaming.
 * Defaults to false, allowing the screen to dim if necessary.
 *
 * @see #setScreenBright(boolean)
 */
",1,,,0,,,0,0,0,0,0,0,"There is no change in the implementation of the given API, so the code change type is 0.","Since there is no change in the implementation, the API will always return the same value and will not throw any exception differently. Therefore, there is no Compatibility Issue (CI) arises in the given method between two continuous versions."
208,<android.os.Parcel: Parcelable[] readParcelableArray(ClassLoader)>,32,33,<android.os.Parcel: Parcelable[] readParcelableArray(ClassLoader)>,<android.os.Parcel: Parcelable[] readParcelableArray(ClassLoader)>,0,"{
    int N = readInt();
    if (N < 0) {
        return null;
    }
    Parcelable[] p = new Parcelable[N];
    for (int i = 0; i < N; i++) {
        p[i] = readParcelable(loader);
    }
    return p;
}","{
    return readParcelableArrayInternal(loader, /* clazz */
    null);
}",1,"/**
 * Read and return a new Parcelable array from the parcel.
 * The given class loader will be used to load any enclosed
 * Parcelables.
 * @return the Parcelable array, or null if the array is null
 */
","/**
 * Read and return a new Parcelable array from the parcel.
 * The given class loader will be used to load any enclosed
 * Parcelables.
 * @return the Parcelable array, or null if the array is null
 *
 * @deprecated Use the type-safer version {@link #readParcelableArray(ClassLoader, Class)}
 * starting from Android {@link Build.VERSION_CODES#TIRAMISU}. Also consider changing the
 * format to use {@link #createTypedArray(Parcelable.Creator)} if possible (eg. if the
 * items' class is final) since this is also more performant. Note that changing to the
 * latter also requires changing the writes.
 */
",1,[@Nullable],"[@Deprecated, @Nullable]",1,,,0,"1,2","1,2,5","1,2","1,5",1,"The implementation of this method has been changed to call a different internal method, which is readParcelableArrayInternal(), and the parameter type of the method also changed, so the code change type is 1,5.","The change of implementation method will make the API potentially return a different value, so the CI type is 1."
502,"<android.os.image.DynamicSystemClient.DynSystemServiceConnection: void onServiceConnected(ComponentName,IBinder)>",30,31,"<android.os.image.DynamicSystemClient.DynSystemServiceConnection: void onServiceConnected(ComponentName,IBinder)>","<android.os.image.DynamicSystemClient.DynSystemServiceConnection: void onServiceConnected(ComponentName,IBinder)>",0,"{
    Slog.v(TAG, ""DynSystemService connected"");
    mService = new Messenger(service);
    try {
        Message msg = Message.obtain(null, MSG_REGISTER_LISTENER);
        msg.replyTo = mMessenger;
        mService.send(msg);
    } catch (RemoteException e) {
        Slog.e(TAG, ""Unable to get status from installation service"");
        if (mExecutor != null) {
            mExecutor.execute(() -> {
                mListener.onStatusChanged(STATUS_UNKNOWN, CAUSE_ERROR_IPC, 0, e);
            });
        } else {
            mListener.onStatusChanged(STATUS_UNKNOWN, CAUSE_ERROR_IPC, 0, e);
        }
    }
}","{
    Slog.v(TAG, ""onServiceConnected: "" + className);
    mService = new Messenger(service);
    try {
        Message msg = Message.obtain(null, MSG_REGISTER_LISTENER);
        msg.replyTo = mMessenger;
        mService.send(msg);
    } catch (RemoteException e) {
        Slog.e(TAG, ""Unable to get status from installation service"");
        notifyOnStatusChangedListener(STATUS_UNKNOWN, CAUSE_ERROR_IPC, 0, e);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,"2,3,4",0,4,1,"The implementation of the onServiceConnected function has been modified, specifically, the logging statement and the way the listener is notified on error have been changed. In the early version, the logging statement logs the message ""DynSystemService connected"", while in the late version, it logs ""onServiceConnected: "" + className. Moreover, in the early version, the listener is notified on error using the execute method of mExecutor, while in the late version, it is notified using the notifyOnStatusChangedListener method.","The change in the logging statement does not cause a compatibility issue, but the change in the way the listener is notified on error potentially can. In the early version, the listener is notified on the executor thread, while in the late version, it is notified on the main thread. This change can cause different behavior if the listener implementation is not thread-safe or expects to be notified on a specific thread. Therefore, it is a compatibility issue caused by potential different return values or types (1)."
168,<android.hardware.display.DisplayManagerInternal.DisplayPowerRequest: boolean equals(DisplayPowerRequest)>,29,30,<android.hardware.display.DisplayManagerInternal.DisplayPowerRequest: boolean equals(DisplayPowerRequest)>,<android.hardware.display.DisplayManagerInternal.DisplayPowerRequest: boolean equals(DisplayPowerRequest)>,0,"{
    return other != null && policy == other.policy && useProximitySensor == other.useProximitySensor && screenBrightnessOverride == other.screenBrightnessOverride && useAutoBrightness == other.useAutoBrightness && floatEquals(screenAutoBrightnessAdjustmentOverride, other.screenAutoBrightnessAdjustmentOverride) && screenLowPowerBrightnessFactor == other.screenLowPowerBrightnessFactor && blockScreenOn == other.blockScreenOn && lowPowerMode == other.lowPowerMode && boostScreenBrightness == other.boostScreenBrightness && dozeScreenBrightness == other.dozeScreenBrightness && dozeScreenState == other.dozeScreenState;
}","{
    return other != null && policy == other.policy && useProximitySensor == other.useProximitySensor && floatEquals(screenBrightnessOverride, other.screenBrightnessOverride) && useAutoBrightness == other.useAutoBrightness && floatEquals(screenAutoBrightnessAdjustmentOverride, other.screenAutoBrightnessAdjustmentOverride) && screenLowPowerBrightnessFactor == other.screenLowPowerBrightnessFactor && blockScreenOn == other.blockScreenOn && lowPowerMode == other.lowPowerMode && boostScreenBrightness == other.boostScreenBrightness && floatEquals(dozeScreenBrightness, other.dozeScreenBrightness) && dozeScreenState == other.dozeScreenState;
}",1,,,-1,,,-1,-1,-1,-1,-1,"1,4",0,1,1,"The implementation of the equals method has changed. Specifically, in the early version, the method compares the values of the field ""screenBrightnessOverride"" directly, while in the late version, it uses the ""floatEquals"" method to compare the values of the field ""screenBrightnessOverride"". Additionally, in the early version, the method directly compares the values of the field ""dozeScreenBrightness"", while in the late version, it uses the ""floatEquals"" method to compare the values of the field ""dozeScreenBrightness"".","The change in the implementation of the equals method could lead to different behaviours. Specifically, in the early version, if the values of the fields ""screenBrightnessOverride"" and ""dozeScreenBrightness"" are not exactly equal (e.g., due to floating-point precision issues), the method could return false, while in the late version, the method could return true. This is a compatibility issue caused by potential different return values."
223,<android.text.TextUtils: int getLayoutDirectionFromLocale(Locale)>,18,19,<android.text.TextUtils: int getLayoutDirectionFromLocale(Locale)>,<android.text.TextUtils: int getLayoutDirectionFromLocale(Locale)>,0,"{
    if (locale != null && !locale.equals(Locale.ROOT)) {
        final String scriptSubtag = ICU.getScript(ICU.addLikelySubtags(locale.toString()));
        if (scriptSubtag == null)
            return getLayoutDirectionFromFirstChar(locale);
        if (scriptSubtag.equalsIgnoreCase(ARAB_SCRIPT_SUBTAG) || scriptSubtag.equalsIgnoreCase(HEBR_SCRIPT_SUBTAG)) {
            return View.LAYOUT_DIRECTION_RTL;
        }
    }
    return View.LAYOUT_DIRECTION_LTR;
}","{
    if (locale != null && !locale.equals(Locale.ROOT)) {
        final String scriptSubtag = ICU.getScript(ICU.addLikelySubtags(locale.toString()));
        if (scriptSubtag == null)
            return getLayoutDirectionFromFirstChar(locale);
        if (scriptSubtag.equalsIgnoreCase(ARAB_SCRIPT_SUBTAG) || scriptSubtag.equalsIgnoreCase(HEBR_SCRIPT_SUBTAG)) {
            return View.LAYOUT_DIRECTION_RTL;
        }
    }
    // If forcing into RTL layout mode, return RTL as default, else LTR
    return SystemProperties.getBoolean(Settings.Global.DEVELOPMENT_FORCE_RTL, false) ? View.LAYOUT_DIRECTION_RTL : View.LAYOUT_DIRECTION_LTR;
}",1,"/**
 * Return the layout direction for a given Locale
 *
 * @param locale the Locale for which we want the layout direction. Can be null.
 * @return the layout direction. This may be one of:
 * {@link android.view.View#LAYOUT_DIRECTION_LTR} or
 * {@link android.view.View#LAYOUT_DIRECTION_RTL}.
 *
 * Be careful: this code will need to be updated when vertical scripts will be supported
 */
","/**
 * Return the layout direction for a given Locale
 *
 * @param locale the Locale for which we want the layout direction. Can be null.
 * @return the layout direction. This may be one of:
 * {@link android.view.View#LAYOUT_DIRECTION_LTR} or
 * {@link android.view.View#LAYOUT_DIRECTION_RTL}.
 *
 * Be careful: this code will need to be updated when vertical scripts will be supported
 */
",-1,,,-1,-1,-1,-1,-1,"1,3,4",1,"1,3",1,"The code change includes a new return statement and a new if-else control dependency. The return statement in the early version is replaced by a new control dependency that returns a different value in the late version, so the code change type is 1,3.","The new control dependency in the late version can potentially cause the API to return a different value (View.LAYOUT\_DIRECTION\_RTL or View.LAYOUT\_DIRECTION\_LTR) based on the value of the system property ""DEVELOPMENT\_FORCE\_RTL"". Therefore, the CI type is 1."
234,"<android.hardware.camera2.impl.CameraDeviceImpl: void createConstrainedHighSpeedCaptureSession(List<Surface>,StateCallback,Handler)>",25,26,"<android.hardware.camera2.impl.CameraDeviceImpl: void createConstrainedHighSpeedCaptureSession(List<Surface>,StateCallback,Handler)>","<android.hardware.camera2.impl.CameraDeviceImpl: void createConstrainedHighSpeedCaptureSession(List<Surface>,StateCallback,Handler)>",0,"{
    if (outputs == null || outputs.size() == 0 || outputs.size() > 2) {
        throw new IllegalArgumentException(""Output surface list must not be null and the size must be no more than 2"");
    }
    StreamConfigurationMap config = getCharacteristics().get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);
    SurfaceUtils.checkConstrainedHighSpeedSurfaces(outputs, /*fpsRange*/
    null, config);
    List<OutputConfiguration> outConfigurations = new ArrayList<>(outputs.size());
    for (Surface surface : outputs) {
        outConfigurations.add(new OutputConfiguration(surface));
    }
    createCaptureSessionInternal(null, outConfigurations, callback, handler, /*isConstrainedHighSpeed*/
    true);
}","{
    if (outputs == null || outputs.size() == 0 || outputs.size() > 2) {
        throw new IllegalArgumentException(""Output surface list must not be null and the size must be no more than 2"");
    }
    StreamConfigurationMap config = getCharacteristics().get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);
    SurfaceUtils.checkConstrainedHighSpeedSurfaces(outputs, /*fpsRange*/
    null, config);
    List<OutputConfiguration> outConfigurations = new ArrayList<>(outputs.size());
    for (Surface surface : outputs) {
        outConfigurations.add(new OutputConfiguration(surface));
    }
    createCaptureSessionInternal(null, outConfigurations, callback, handler, /*operatingMode*/
    ICameraDeviceUser.CONSTRAINED_HIGH_SPEED_MODE);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,4,1,5,0,"The method 'createCaptureSessionInternal' in the late version has an additional parameter 'operatingMode' with value 'ICameraDeviceUser.CONSTRAINED\_HIGH\_SPEED\_MODE', which is not present in the early version. So the code change type is 5 (Dependent API changed).","The additional parameter in the 'createCaptureSessionInternal' method in the late version does not affect the return value or exception handling of the 'createConstrainedHighSpeedCaptureSession' method. Thus, there is no compatibility issue."
695,<android.content.ContentValues: Long getAsLong(String)>,28,29,<android.content.ContentValues: Long getAsLong(String)>,<android.content.ContentValues: Long getAsLong(String)>,0,"{
    Object value = mValues.get(key);
    try {
        return value != null ? ((Number) value).longValue() : null;
    } catch (ClassCastException e) {
        if (value instanceof CharSequence) {
            try {
                return Long.valueOf(value.toString());
            } catch (NumberFormatException e2) {
                Log.e(TAG, ""Cannot parse Long value for "" + value + "" at key "" + key);
                return null;
            }
        } else {
            Log.e(TAG, ""Cannot cast value for "" + key + "" to a Long: "" + value, e);
            return null;
        }
    }
}","{
    Object value = mMap.get(key);
    try {
        return value != null ? ((Number) value).longValue() : null;
    } catch (ClassCastException e) {
        if (value instanceof CharSequence) {
            try {
                return Long.valueOf(value.toString());
            } catch (NumberFormatException e2) {
                Log.e(TAG, ""Cannot parse Long value for "" + value + "" at key "" + key);
                return null;
            }
        } else {
            Log.e(TAG, ""Cannot cast value for "" + key + "" to a Long: "" + value, e);
            return null;
        }
    }
}",1,"/**
 * Gets a value and converts it to a Long.
 *
 * @param key the value to get
 * @return the Long value, or {@code null} if the value is missing or cannot be converted
 */
","/**
 * Gets a value and converts it to a Long.
 *
 * @param key the value to get
 * @return the Long value, or {@code null} if the value is missing or cannot be converted
 */
",-1,,,-1,-1,-1,-1,-1,4,0,5,1,The variable used in the return statement has changed from 'mValues' to 'mMap' which indicates that the method is now using a different data structure to look up the value for the given key. This is a change in the dependent API.,"As the method now uses a different data structure to look up the value for the given key, it is possible that the method may now return a different value for the same key, leading to a compatibility issue. Specifically, the compatibility issue is caused by potential different return values."
863,<android.widget.RemoteViews.AsyncApplyTask: ViewTree doInBackground(Void)>,30,31,<android.widget.RemoteViews.AsyncApplyTask: ViewTree doInBackground(Void)>,<android.widget.RemoteViews.AsyncApplyTask: ViewTree doInBackground(Void)>,0,"{
    try {
        if (mResult == null) {
            mResult = inflateView(mContext, mRV, mParent);
        }
        mTree = new ViewTree(mResult);
        if (mRV.mActions != null) {
            int count = mRV.mActions.size();
            mActions = new Action[count];
            for (int i = 0; i < count && !isCancelled(); i++) {
                // TODO: check if isCancelled in nested views.
                mActions[i] = mRV.mActions.get(i).initActionAsync(mTree, mParent, mHandler);
            }
        } else {
            mActions = null;
        }
        return mTree;
    } catch (Exception e) {
        mError = e;
        return null;
    }
}","{
    try {
        if (mResult == null) {
            mResult = inflateView(mContext, mRV, mParent, 0, mColorResources);
        }
        mTree = new ViewTree(mResult);
        if (mRV.mActions != null) {
            int count = mRV.mActions.size();
            mActions = new Action[count];
            for (int i = 0; i < count && !isCancelled(); i++) {
                // TODO: check if isCancelled in nested views.
                mActions[i] = mRV.mActions.get(i).initActionAsync(mTree, mParent, mHandler, mColorResources);
            }
        } else {
            mActions = null;
        }
        return mTree;
    } catch (Exception e) {
        mError = e;
        return null;
    }
}",1,,,-1,[@Override],"[@Nullable, @Override]",-1,-1,-1,-1,-1,5,0,5,1,"The code change involves the addition of two parameters in the `inflateView` method and the `initActionAsync` method. This means that the dependent API has changed, so the code change type is 5.","The addition of new parameters in the dependent APIs could lead to different behaviors when the late version API is invoked, thus the CI type is 1."
117,<android.hardware.camera2.impl.CameraDeviceImpl: void createExtensionSession(ExtensionSessionConfiguration)>,32,33,,,,"{
    try {
        if (CameraExtensionCharacteristics.areAdvancedExtensionsSupported()) {
            mCurrentAdvancedExtensionSession = CameraAdvancedExtensionSessionImpl.createCameraAdvancedExtensionSession(this, mContext, extensionConfiguration);
        } else {
            mCurrentExtensionSession = CameraExtensionSessionImpl.createCameraExtensionSession(this, mContext, extensionConfiguration);
        }
    } catch (RemoteException e) {
        throw new CameraAccessException(CameraAccessException.CAMERA_ERROR);
    }
}","{
    try {
        if (CameraExtensionCharacteristics.areAdvancedExtensionsSupported()) {
            mCurrentAdvancedExtensionSession = CameraAdvancedExtensionSessionImpl.createCameraAdvancedExtensionSession(this, mContext, extensionConfiguration, mNextSessionId++);
        } else {
            mCurrentExtensionSession = CameraExtensionSessionImpl.createCameraExtensionSession(this, mContext, extensionConfiguration, mNextSessionId++);
        }
    } catch (RemoteException e) {
        throw new CameraAccessException(CameraAccessException.CAMERA_ERROR);
    }
}",1,,,0,[@Override],[@Override],0,,,,,5,0,5,1,"In the late implementation, a new parameter `mNextSessionId++` is added to the methods `createCameraAdvancedExtensionSession` and `createCameraExtensionSession`. This indicates that the dependent APIs have changed. Therefore, the code change type is 5.","As the new parameter `mNextSessionId++` is added to the methods `createCameraAdvancedExtensionSession` and `createCameraExtensionSession`, it may result in a different behavior of the API, leading to different return values or types. Therefore, the CI type is 1."
9,<android.webkit.WebView: void onDraw(Canvas)>,6,7,<android.webkit.WebView: void onDraw(Canvas)>,<android.webkit.WebView: void onDraw(Canvas)>,0,"{
    // if mNativeClass is 0, the WebView has been destroyed. Do nothing.
    if (mNativeClass == 0) {
        return;
    }
    int saveCount = canvas.save();
    if (mTitleBar != null) {
        canvas.translate(0, (int) mTitleBar.getHeight());
    }
    // Update the buttons in the picture, so when we draw the picture
    // to the screen, they are in the correct state.
    // Tell the native side if user is a) touching the screen,
    // b) pressing the trackball down, or c) pressing the enter key
    // If the cursor is on a button, we need to draw it in the pressed
    // state.
    // If mNativeClass is 0, we should not reach here, so we do not
    // need to check it again.
    nativeRecordButtons(hasFocus() && hasWindowFocus(), mTouchMode == TOUCH_SHORTPRESS_START_MODE || mTrackballDown || mGotCenterDown, false);
    drawCoreAndCursorRing(canvas, mBackgroundColor, mDrawCursorRing);
    canvas.restoreToCount(saveCount);
    // Now draw the shadow.
    if (mTitleBar != null) {
        int y = mScrollY + getVisibleTitleHeight();
        int height = (int) (5f * getContext().getResources().getDisplayMetrics().density);
        mTitleShadow.setBounds(mScrollX, y, mScrollX + getWidth(), y + height);
        mTitleShadow.draw(canvas);
    }
    if (AUTO_REDRAW_HACK && mAutoRedraw) {
        invalidate();
    }
}","{
    // if mNativeClass is 0, the WebView has been destroyed. Do nothing.
    if (mNativeClass == 0) {
        return;
    }
    int saveCount = canvas.save();
    if (mTitleBar != null) {
        canvas.translate(0, (int) mTitleBar.getHeight());
    }
    if (mDragTrackerHandler == null || !mDragTrackerHandler.draw(canvas)) {
        drawContent(canvas);
    }
    canvas.restoreToCount(saveCount);
    // Now draw the shadow.
    if (mTitleBar != null) {
        int y = mScrollY + getVisibleTitleHeight();
        int height = (int) (5f * getContext().getResources().getDisplayMetrics().density);
        mTitleShadow.setBounds(mScrollX, y, mScrollX + getWidth(), y + height);
        mTitleShadow.draw(canvas);
    }
    if (AUTO_REDRAW_HACK && mAutoRedraw) {
        invalidate();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,"3,4",0,"3,4",1,"The control dependency in the late version has changed, specifically the condition in the 'if' statement. In the early version, the code calls `nativeRecordButtons()` and `drawCoreAndCursorRing()` unconditionally, while in the late version, these two methods are replaced by `drawContent()`, which is called only if `mDragTrackerHandler == null || !mDragTrackerHandler.draw(canvas)` is true. Additionally, a new method `mDragTrackerHandler.draw(canvas)` is introduced in the late version.","The change in control dependency can lead to different behaviors between the two versions. In the early version, `nativeRecordButtons()` and `drawCoreAndCursorRing()` will always be called, while in the late version, they might not be called, and `drawContent()` might be called instead. This potential difference in the return value or type can cause a Compatibility Issue of type 1."
583,<android.app.ActivityThread.PackageInfo: ClassLoader getClassLoader()>,7,8,<android.app.ActivityThread.PackageInfo: ClassLoader getClassLoader()>,<android.app.ActivityThread.PackageInfo: ClassLoader getClassLoader()>,0,"{
    synchronized (this) {
        if (mClassLoader != null) {
            return mClassLoader;
        }
        if (mIncludeCode && !mPackageName.equals(""android"")) {
            String zip = mAppDir;
            /*
                     * The following is a bit of a hack to inject
                     * instrumentation into the system: If the app
                     * being started matches one of the instrumentation names,
                     * then we combine both the ""instrumentation"" and
                     * ""instrumented"" app into the path, along with the
                     * concatenation of both apps' shared library lists.
                     */
            String instrumentationAppDir = mActivityThread.mInstrumentationAppDir;
            String instrumentationAppPackage = mActivityThread.mInstrumentationAppPackage;
            String instrumentedAppDir = mActivityThread.mInstrumentedAppDir;
            String[] instrumentationLibs = null;
            if (mAppDir.equals(instrumentationAppDir) || mAppDir.equals(instrumentedAppDir)) {
                zip = instrumentationAppDir + "":"" + instrumentedAppDir;
                if (!instrumentedAppDir.equals(instrumentationAppDir)) {
                    instrumentationLibs = getLibrariesFor(instrumentationAppPackage);
                }
            }
            if ((mSharedLibraries != null) || (instrumentationLibs != null)) {
                zip = combineLibs(mSharedLibraries, instrumentationLibs) + ':' + zip;
            }
            if (localLOGV)
                Log.v(TAG, ""Class path: "" + zip);
            mClassLoader = ApplicationLoaders.getDefault().getClassLoader(zip, mDataDir, mBaseClassLoader);
        } else {
            if (mBaseClassLoader == null) {
                mClassLoader = ClassLoader.getSystemClassLoader();
            } else {
                mClassLoader = mBaseClassLoader;
            }
        }
        return mClassLoader;
    }
}","{
    synchronized (this) {
        if (mClassLoader != null) {
            return mClassLoader;
        }
        if (mIncludeCode && !mPackageName.equals(""android"")) {
            String zip = mAppDir;
            /*
                     * The following is a bit of a hack to inject
                     * instrumentation into the system: If the app
                     * being started matches one of the instrumentation names,
                     * then we combine both the ""instrumentation"" and
                     * ""instrumented"" app into the path, along with the
                     * concatenation of both apps' shared library lists.
                     */
            String instrumentationAppDir = mActivityThread.mInstrumentationAppDir;
            String instrumentationAppPackage = mActivityThread.mInstrumentationAppPackage;
            String instrumentedAppDir = mActivityThread.mInstrumentedAppDir;
            String[] instrumentationLibs = null;
            if (mAppDir.equals(instrumentationAppDir) || mAppDir.equals(instrumentedAppDir)) {
                zip = instrumentationAppDir + "":"" + instrumentedAppDir;
                if (!instrumentedAppDir.equals(instrumentationAppDir)) {
                    instrumentationLibs = getLibrariesFor(instrumentationAppPackage);
                }
            }
            if ((mSharedLibraries != null) || (instrumentationLibs != null)) {
                zip = combineLibs(mSharedLibraries, instrumentationLibs) + ':' + zip;
            }
            if (localLOGV)
                Slog.v(TAG, ""Class path: "" + zip);
            mClassLoader = ApplicationLoaders.getDefault().getClassLoader(zip, mDataDir, mBaseClassLoader);
            initializeJavaContextClassLoader();
        } else {
            if (mBaseClassLoader == null) {
                mClassLoader = ClassLoader.getSystemClassLoader();
            } else {
                mClassLoader = mBaseClassLoader;
            }
        }
        return mClassLoader;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,4,1,5,0,"The code change is that a new method `initializeJavaContextClassLoader()` is called before the return statement. This method does not affect the returned value or the exception handling, but it changes the behavior of the API. Therefore, the code change type is 5 (Other statement changed).","The added method `initializeJavaContextClassLoader()` does not affect the returned value or the exception handling, so it does not lead to a Compatibility Issue. Therefore, the CI type is 0 (No Compatibility Issue)."
1032,<android.animation.AnimatorSet: void setStartDelay(long)>,25,26,<android.animation.AnimatorSet: void setStartDelay(long)>,<android.animation.AnimatorSet: void setStartDelay(long)>,0,"{
    // Clamp start delay to non-negative range.
    if (startDelay < 0) {
        Log.w(TAG, ""Start delay should always be non-negative"");
        startDelay = 0;
    }
    long delta = startDelay - mStartDelay;
    if (delta == 0) {
        return;
    }
    mStartDelay = startDelay;
    if (mStartDelay > 0) {
        mReversible = false;
    }
    if (!mDependencyDirty) {
        // Dependency graph already constructed, update all the nodes' start/end time
        int size = mNodes.size();
        for (int i = 0; i < size; i++) {
            Node node = mNodes.get(i);
            if (node == mRootNode) {
                node.mEndTime = mStartDelay;
            } else {
                node.mStartTime = node.mStartTime == DURATION_INFINITE ? DURATION_INFINITE : node.mStartTime + delta;
                node.mEndTime = node.mEndTime == DURATION_INFINITE ? DURATION_INFINITE : node.mEndTime + delta;
            }
        }
        // Update total duration, if necessary.
        if (mTotalDuration != DURATION_INFINITE) {
            mTotalDuration += delta;
        }
    }
}","{
    // Clamp start delay to non-negative range.
    if (startDelay < 0) {
        Log.w(TAG, ""Start delay should always be non-negative"");
        startDelay = 0;
    }
    long delta = startDelay - mStartDelay;
    if (delta == 0) {
        return;
    }
    mStartDelay = startDelay;
    if (!mDependencyDirty) {
        // Dependency graph already constructed, update all the nodes' start/end time
        int size = mNodes.size();
        for (int i = 0; i < size; i++) {
            Node node = mNodes.get(i);
            if (node == mRootNode) {
                node.mEndTime = mStartDelay;
            } else {
                node.mStartTime = node.mStartTime == DURATION_INFINITE ? DURATION_INFINITE : node.mStartTime + delta;
                node.mEndTime = node.mEndTime == DURATION_INFINITE ? DURATION_INFINITE : node.mEndTime + delta;
            }
        }
        // Update total duration, if necessary.
        if (mTotalDuration != DURATION_INFINITE) {
            mTotalDuration += delta;
        }
    }
}",1,"/**
 * The amount of time, in milliseconds, to delay starting the animation after
 * {@link #start()} is called. Note that the start delay should always be non-negative. Any
 * negative start delay will be clamped to 0 on N and above.
 *
 * @param startDelay The amount of the delay, in milliseconds
 */
","/**
 * The amount of time, in milliseconds, to delay starting the animation after
 * {@link #start()} is called. Note that the start delay should always be non-negative. Any
 * negative start delay will be clamped to 0 on N and above.
 *
 * @param startDelay The amount of the delay, in milliseconds
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,3,0,0,0,There is no difference between the early and late implementation.,"Since there is no change, there is no compatibility issue."
193,<android.pim.vcard.VCardComposer.HandlerForOutputStream: boolean onInit(Context)>,8,9,<android.pim.vcard.VCardComposer.HandlerForOutputStream: boolean onInit(Context)>,<android.pim.vcard.VCardComposer.HandlerForOutputStream: boolean onInit(Context)>,0,"{
    try {
        mWriter = new BufferedWriter(new OutputStreamWriter(mOutputStream, mCharsetString));
    } catch (UnsupportedEncodingException e1) {
        Log.e(LOG_TAG, ""Unsupported charset: "" + mCharsetString);
        mErrorReason = ""Encoding is not supported (usually this does not happen!): "" + mCharsetString;
        return false;
    }
    if (mIsDoCoMo) {
        try {
            // Create one empty entry.
            mWriter.write(createOneEntryInternal(""-1"", null));
        } catch (VCardException e) {
            Log.e(LOG_TAG, ""VCardException has been thrown during on Init(): "" + e.getMessage());
            return false;
        } catch (IOException e) {
            Log.e(LOG_TAG, ""IOException occurred during exportOneContactData: "" + e.getMessage());
            mErrorReason = ""IOException occurred: "" + e.getMessage();
            return false;
        }
    }
    return true;
}","{
    try {
        mWriter = new BufferedWriter(new OutputStreamWriter(mOutputStream, mCharset));
    } catch (UnsupportedEncodingException e1) {
        Log.e(LOG_TAG, ""Unsupported charset: "" + mCharset);
        mErrorReason = ""Encoding is not supported (usually this does not happen!): "" + mCharset;
        return false;
    }
    if (mIsDoCoMo) {
        try {
            // Create one empty entry.
            mWriter.write(createOneEntryInternal(""-1"", null));
        } catch (VCardException e) {
            Log.e(LOG_TAG, ""VCardException has been thrown during on Init(): "" + e.getMessage());
            return false;
        } catch (IOException e) {
            Log.e(LOG_TAG, ""IOException occurred during exportOneContactData: "" + e.getMessage());
            mErrorReason = ""IOException occurred: "" + e.getMessage();
            return false;
        }
    }
    return true;
}",1,,,-1,,,-1,-1,-1,-1,-1,4,0,"1,2",1,"The constructor of BufferedWriter has changed from OutputStreamWriter(mOutputStream, mCharsetString) to OutputStreamWriter(mOutputStream, mCharset). Additionally, the code change caused the variable 'mCharsetString' to be replaced with 'mCharset' in the catch clause, thus, it's both return statement changed (1) and exception handling statement changed (2).","The change in the constructor of BufferedWriter and the replacement of the variable in the catch clause can lead to different behavior in the late version of the API, potentially causing the API to return a different value, so the CI type is 1."
888,"<android.inputmethodservice.InputMethodService: void doStartInput(InputConnection,EditorInfo,boolean)>",29,30,"<android.inputmethodservice.InputMethodService: void doStartInput(InputConnection,EditorInfo,boolean)>","<android.inputmethodservice.InputMethodService: void doStartInput(InputConnection,EditorInfo,boolean)>",0,"{
    if (!restarting) {
        doFinishInput();
    }
    mInputStarted = true;
    mStartedInputConnection = ic;
    mInputEditorInfo = attribute;
    initialize();
    if (DEBUG)
        Log.v(TAG, ""CALL: onStartInput"");
    onStartInput(attribute, restarting);
    if (mDecorViewVisible) {
        if (mShowInputRequested) {
            if (DEBUG)
                Log.v(TAG, ""CALL: onStartInputView"");
            mInputViewStarted = true;
            onStartInputView(mInputEditorInfo, restarting);
            startExtractingText(true);
        } else if (mCandidatesVisibility == View.VISIBLE) {
            if (DEBUG)
                Log.v(TAG, ""CALL: onStartCandidatesView"");
            mCandidatesViewStarted = true;
            onStartCandidatesView(mInputEditorInfo, restarting);
        }
    } else if (mCanPreRender && mInputEditorInfo != null && mStartedInputConnection != null) {
        // pre-render IME window and keep it invisible.
        if (DEBUG)
            Log.v(TAG, ""Pre-Render IME for "" + mInputEditorInfo.fieldName);
        if (mInShowWindow) {
            Log.w(TAG, ""Re-entrance in to showWindow"");
            return;
        }
        mDecorViewWasVisible = mDecorViewVisible;
        mInShowWindow = true;
        startViews(prepareWindow(true));
        // compute visibility
        mIsPreRendered = true;
        onPreRenderedWindowVisibilityChanged(false);
        // When IME is not pre-rendered, this will actually show the IME.
        if (DEBUG)
            Log.v(TAG, ""showWindow: draw decorView!"");
        mWindow.show();
        maybeNotifyPreRendered();
        mDecorViewWasVisible = true;
        mInShowWindow = false;
    } else {
        mIsPreRendered = false;
    }
}","{
    if (!restarting) {
        doFinishInput();
    }
    mInputStarted = true;
    mStartedInputConnection = ic;
    mInputEditorInfo = attribute;
    initialize();
    mInlineSuggestionSessionController.notifyOnStartInput(attribute == null ? null : attribute.packageName, attribute == null ? null : attribute.autofillId);
    if (DEBUG)
        Log.v(TAG, ""CALL: onStartInput"");
    onStartInput(attribute, restarting);
    if (mDecorViewVisible) {
        if (mShowInputRequested) {
            if (DEBUG)
                Log.v(TAG, ""CALL: onStartInputView"");
            mInputViewStarted = true;
            mInlineSuggestionSessionController.notifyOnStartInputView();
            onStartInputView(mInputEditorInfo, restarting);
            startExtractingText(true);
        } else if (mCandidatesVisibility == View.VISIBLE) {
            if (DEBUG)
                Log.v(TAG, ""CALL: onStartCandidatesView"");
            mCandidatesViewStarted = true;
            onStartCandidatesView(mInputEditorInfo, restarting);
        }
    } else if (mCanPreRender && mInputEditorInfo != null && mStartedInputConnection != null) {
        // pre-render IME window and keep it invisible.
        if (DEBUG)
            Log.v(TAG, ""Pre-Render IME for "" + mInputEditorInfo.fieldName);
        if (mInShowWindow) {
            Log.w(TAG, ""Re-entrance in to showWindow"");
            return;
        }
        mDecorViewWasVisible = mDecorViewVisible;
        mInShowWindow = true;
        startViews(prepareWindow(true));
        // compute visibility
        mIsPreRendered = true;
        onPreRenderedWindowVisibilityChanged(false);
        // When IME is not pre-rendered, this will actually show the IME.
        if (DEBUG)
            Log.v(TAG, ""showWindow: draw decorView!"");
        mWindow.show();
        maybeNotifyPreRendered();
        mDecorViewWasVisible = true;
        mInShowWindow = false;
    } else {
        mIsPreRendered = false;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,4,0,5,1,"In the late version of the API, the following lines have been added:",* mInlineSuggestionSessionController.notifyOnStartInputView();
48,<android.animation.Keyframe.FloatKeyframe: FloatKeyframe clone()>,20,21,<android.animation.Keyframe.FloatKeyframe: FloatKeyframe clone()>,<android.animation.Keyframe.FloatKeyframe: FloatKeyframe clone()>,0,"{
    FloatKeyframe kfClone = mHasValue ? new FloatKeyframe(getFraction(), mValue) : new FloatKeyframe(getFraction());
    kfClone.setInterpolator(getInterpolator());
    return kfClone;
}","{
    FloatKeyframe kfClone = mHasValue ? new FloatKeyframe(getFraction(), mValue) : new FloatKeyframe(getFraction());
    kfClone.setInterpolator(getInterpolator());
    kfClone.mValueWasSetOnStart = mValueWasSetOnStart;
    return kfClone;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,4,0,4,1,"A new statement, `kfClone.mValueWasSetOnStart = mValueWasSetOnStart;`, has been introduced, which is not related to return statements, exception handling statements, and control dependency. So the code change type is 4.","The new introduced statement `kfClone.mValueWasSetOnStart = mValueWasSetOnStart;` potentially changes the value of the returned object `kfClone`, which could lead to different behaviours when the late version API is invoked. Therefore, the CI type is 1."
212,<android.webkit.WebView: void requestImageRef(Message)>,15,16,<android.webkit.WebView: void requestImageRef(Message)>,<android.webkit.WebView: void requestImageRef(Message)>,0,"{
    checkThread();
    // client isn't initialized
    if (0 == mNativeClass)
        return;
    int contentX = viewToContentX(mLastTouchX + mScrollX);
    int contentY = viewToContentY(mLastTouchY + mScrollY);
    String ref = nativeImageURI(contentX, contentY);
    Bundle data = msg.getData();
    data.putString(""url"", ref);
    msg.setData(data);
    msg.sendToTarget();
}","{
    checkThread();
    mProvider.requestImageRef(msg);
}",1,"/**
 * Request the url of the image last touched by the user. msg will be sent
 * to its target with a String representing the url as its object.
 *
 * @param msg This message will be dispatched with the result of the request
 * as the data member with ""url"" as key. The result can be null.
 */
","/**
 * Requests the URL of the image last touched by the user. msg will be sent
 * to its target with a String representing the URL as its object.
 *
 * @param msg the message to be dispatched with the result of the request
 * as the data member with ""url"" as key. The result can be null.
 */
",-1,,,-1,-1,-1,-1,-1,"1,3,4",1,5,1,"The earlier version of the API used to directly call nativeImageURI() and send a message to the target, but in the later version, it calls another API, mProvider.requestImageRef(). This means that the dependent API has changed.","The change in the dependent API could lead to different return values, as the later version of the API no longer calls the nativeImageURI() method directly. This could potentially cause a compatibility issue, as the returned value may be different from the earlier version."
171,<android.app.ActivityManager: int getLockTaskModeState()>,23,24,<android.app.ActivityManager: int getLockTaskModeState()>,<android.app.ActivityManager: int getLockTaskModeState()>,0,"{
    try {
        return ActivityManagerNative.getDefault().getLockTaskModeState();
    } catch (RemoteException e) {
        return ActivityManager.LOCK_TASK_MODE_NONE;
    }
}","{
    try {
        return ActivityManagerNative.getDefault().getLockTaskModeState();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Return the current state of task locking. The three possible outcomes
 * are {@link #LOCK_TASK_MODE_NONE}, {@link #LOCK_TASK_MODE_LOCKED}
 * and {@link #LOCK_TASK_MODE_PINNED}.
 *
 * @see Activity#startLockTask()
 */
","/**
 * Return the current state of task locking. The three possible outcomes
 * are {@link #LOCK_TASK_MODE_NONE}, {@link #LOCK_TASK_MODE_LOCKED}
 * and {@link #LOCK_TASK_MODE_PINNED}.
 *
 * @see Activity#startLockTask()
 */
",-1,,,-1,-1,-1,-1,-1,"1,2",2,2,2,"The catch block in the late version throws the exception instead of returning a default value. This is a change in exception handling, hence the code change type is 2.","The change in exception handling can cause a different behavior in the API. In the early version, if an exception occurs, a default value is returned. In the late version, the exception is thrown, which may not be handled by the calling code and can lead to unexpected behavior or crashing of the application. This is a Compatibility Issue caused by potential different exception handling, hence the CI type is 2."
785,"<android.app.admin.DevicePolicyManager: void setCameraDisabled(ComponentName,boolean)>",23,24,"<android.app.admin.DevicePolicyManager: void setCameraDisabled(ComponentName,boolean)>","<android.app.admin.DevicePolicyManager: void setCameraDisabled(ComponentName,boolean)>",0,"{
    if (mService != null) {
        try {
            mService.setCameraDisabled(admin, disabled);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    throwIfParentInstance(""setCameraDisabled"");
    if (mService != null) {
        try {
            mService.setCameraDisabled(admin, disabled);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Called by an application that is administering the device to disable all cameras
 * on the device, for this user. After setting this, no applications running as this user
 * will be able to access any cameras on the device.
 *
 * <p>The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_DISABLE_CAMERA} to be able to call
 * this method; if it has not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param disabled Whether or not the camera should be disabled.
 */
","/**
 * Called by an application that is administering the device to disable all cameras on the
 * device, for this user. After setting this, no applications running as this user will be able
 * to access any cameras on the device.
 * <p>
 * If the caller is device owner, then the restriction will be applied to all users.
 * <p>
 * The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_DISABLE_CAMERA} to be able to call this method; if it has
 * not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param disabled Whether or not the camera should be disabled.
 * @throws SecurityException if {@code admin} is not an active administrator or does not use
 * {@link DeviceAdminInfo#USES_POLICY_DISABLE_CAMERA}.
 */
",-1,,,-1,-1,-1,-1,-1,"2,4",2,"2,5",2,"A new exception handling statement has been introduced (throw e.rethrowFromSystemServer()) and a new method call statement is added (throwIfParentInstance(""setCameraDisabled"")), so the change type is 2,5.","As the introduced exception handling could lead to different exception behaviour when the late version API is invoked, thus the CI type is 2."
202,"<android.content.ContentResolver: void requestSync(Account,String,Bundle)>",18,19,"<android.content.ContentResolver: void requestSync(Account,String,Bundle)>","<android.content.ContentResolver: void requestSync(Account,String,Bundle)>",0,"{
    validateSyncExtrasBundle(extras);
    try {
        getContentService().requestSync(account, authority, extras);
    } catch (RemoteException e) {
    }
}","{
    if (extras == null) {
        throw new IllegalArgumentException(""Must specify extras."");
    }
    SyncRequest request = new SyncRequest.Builder().setSyncAdapter(account, authority).setExtras(extras).syncOnce().build();
    requestSync(request);
}",1,"/**
 * Start an asynchronous sync operation. If you want to monitor the progress
 * of the sync you may register a SyncObserver. Only values of the following
 * types may be used in the extras bundle:
 * <ul>
 * <li>Integer</li>
 * <li>Long</li>
 * <li>Boolean</li>
 * <li>Float</li>
 * <li>Double</li>
 * <li>String</li>
 * </ul>
 *
 * @param account which account should be synced
 * @param authority which authority should be synced
 * @param extras any extras to pass to the SyncAdapter.
 */
","/**
 * Start an asynchronous sync operation. If you want to monitor the progress
 * of the sync you may register a SyncObserver. Only values of the following
 * types may be used in the extras bundle:
 * <ul>
 * <li>Integer</li>
 * <li>Long</li>
 * <li>Boolean</li>
 * <li>Float</li>
 * <li>Double</li>
 * <li>String</li>
 * <li>Account</li>
 * <li>null</li>
 * </ul>
 *
 * @param account which account should be synced
 * @param authority which authority should be synced
 * @param extras any extras to pass to the SyncAdapter.
 */
",-1,,,-1,-1,-1,-1,-1,"2,3,4",2,"1,2,5","1,2",The code change includes:,2. Exception handling statement changed: The catch statement for RemoteException was removed in the later version.
498,"<android.view.Choreographer.FrameDisplayEventReceiver: void onVsync(long,int,int)>",20,21,"<android.view.Choreographer.FrameDisplayEventReceiver: void onVsync(long,int,int)>","<android.view.Choreographer.FrameDisplayEventReceiver: void onVsync(long,int,int)>",0,"{
    // that we need to fix this.
    if (builtInDisplayId != SurfaceControl.BUILT_IN_DISPLAY_ID_MAIN) {
        Log.d(TAG, ""Received vsync from secondary display, but we don't support "" + ""this case yet.  Choreographer needs a way to explicitly request "" + ""vsync for a specific display to ensure it doesn't lose track "" + ""of its scheduled vsync."");
        scheduleVsync();
        return;
    }
    // Post the vsync event to the Handler.
    // The idea is to prevent incoming vsync events from completely starving
    // the message queue.  If there are no messages in the queue with timestamps
    // earlier than the frame time, then the vsync event will be processed immediately.
    // Otherwise, messages that predate the vsync event will be handled first.
    long now = System.nanoTime();
    if (timestampNanos > now) {
        Log.w(TAG, ""Frame time is "" + ((timestampNanos - now) * 0.000001f) + "" ms in the future!  Check that graphics HAL is generating vsync "" + ""timestamps using the correct timebase."");
        timestampNanos = now;
    }
    if (mHavePendingVsync) {
        Log.w(TAG, ""Already have a pending vsync event.  There should only be "" + ""one at a time."");
    } else {
        mHavePendingVsync = true;
    }
    mTimestampNanos = timestampNanos;
    mFrame = frame;
    Message msg = Message.obtain(mHandler, this);
    msg.setAsynchronous(true);
    mHandler.sendMessageAtTime(msg, timestampNanos / NANOS_PER_MS);
}","{
    // that we need to fix this.
    if (builtInDisplayId != SurfaceControl.BUILT_IN_DISPLAY_ID_MAIN) {
        Log.d(TAG, ""Received vsync from secondary display, but we don't support "" + ""this case yet.  Choreographer needs a way to explicitly request "" + ""vsync for a specific display to ensure it doesn't lose track "" + ""of its scheduled vsync."");
        scheduleVsync();
        return;
    }
    // Post the vsync event to the Handler.
    // The idea is to prevent incoming vsync events from completely starving
    // the message queue.  If there are no messages in the queue with timestamps
    // earlier than the frame time, then the vsync event will be processed immediately.
    // Otherwise, messages that predate the vsync event will be handled first.
    long now = System.nanoTime();
    if (timestampNanos > now) {
        Log.w(TAG, ""Frame time is "" + ((timestampNanos - now) * 0.000001f) + "" ms in the future!  Check that graphics HAL is generating vsync "" + ""timestamps using the correct timebase."");
        timestampNanos = now;
    }
    if (mHavePendingVsync) {
        Log.w(TAG, ""Already have a pending vsync event.  There should only be "" + ""one at a time."");
    } else {
        mHavePendingVsync = true;
    }
    mTimestampNanos = timestampNanos;
    mFrame = frame;
    Message msg = Message.obtain(mHandler, this);
    msg.setAsynchronous(true);
    mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,5,0,"4,5",0,"The change between the two versions is that the constant NANOS\_PER\_MS has been replaced with TimeUtils.NANOS\_PER\_MS in the late version. This is considered a dependent API change, since the implementation of the current API relies on another API. Thus, the code change type is 4,5.","However, the change in the constant value from NANOS\_PER\_MS to TimeUtils.NANOS\_PER\_MS does not affect the behavior of the API, as both constants have the same value (1000000). Therefore, there is no compatibility issue caused by this change, so the CI type is 0."
530,<android.view.View: AccessibilityNodeInfo createAccessibilityNodeInfo()>,17,18,<android.view.View: AccessibilityNodeInfo createAccessibilityNodeInfo()>,<android.view.View: AccessibilityNodeInfo createAccessibilityNodeInfo()>,0,"{
    AccessibilityNodeProvider provider = getAccessibilityNodeProvider();
    if (provider != null) {
        return provider.createAccessibilityNodeInfo(View.NO_ID);
    } else {
        AccessibilityNodeInfo info = AccessibilityNodeInfo.obtain(this);
        onInitializeAccessibilityNodeInfo(info);
        return info;
    }
}","{
    if (mAccessibilityDelegate != null) {
        return mAccessibilityDelegate.createAccessibilityNodeInfo(this);
    } else {
        return createAccessibilityNodeInfoInternal();
    }
}",1,"/**
 * Returns an {@link AccessibilityNodeInfo} representing this view from the
 * point of view of an {@link android.accessibilityservice.AccessibilityService}.
 * This method is responsible for obtaining an accessibility node info from a
 * pool of reusable instances and calling
 * {@link #onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo)} on this view to
 * initialize the former.
 * <p>
 * Note: The client is responsible for recycling the obtained instance by calling
 * {@link AccessibilityNodeInfo#recycle()} to minimize object creation.
 * </p>
 *
 * @return A populated {@link AccessibilityNodeInfo}.
 *
 * @see AccessibilityNodeInfo
 */
","/**
 * Returns an {@link AccessibilityNodeInfo} representing this view from the
 * point of view of an {@link android.accessibilityservice.AccessibilityService}.
 * This method is responsible for obtaining an accessibility node info from a
 * pool of reusable instances and calling
 * {@link #onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo)} on this view to
 * initialize the former.
 * <p>
 * Note: The client is responsible for recycling the obtained instance by calling
 * {@link AccessibilityNodeInfo#recycle()} to minimize object creation.
 * </p>
 *
 * @return A populated {@link AccessibilityNodeInfo}.
 *
 * @see AccessibilityNodeInfo
 */
",-1,,,-1,-1,-1,-1,-1,"1,3,4,5",1,5,1,"The implementation of the `createAccessibilityNodeInfo()` method has been changed. The early version uses `AccessibilityNodeProvider` to create an `AccessibilityNodeInfo` object, while the late version uses `mAccessibilityDelegate` to create an `AccessibilityNodeInfo` object. The method `createAccessibilityNodeInfoInternal()` has been introduced in the late version, which is not present in the early version.","The change in implementation of the `createAccessibilityNodeInfo()` method could potentially lead to different return values or types. The early version uses `AccessibilityNodeProvider` to create an `AccessibilityNodeInfo` object, while the late version uses `mAccessibilityDelegate` to create an `AccessibilityNodeInfo` object. Therefore, there is a compatibility issue caused by potential different return values or types."
1403,<android.app.WallpaperManager: Drawable peekDrawable()>,23,24,<android.app.WallpaperManager: Drawable peekDrawable()>,<android.app.WallpaperManager: Drawable peekDrawable()>,0,"{
    Bitmap bm = sGlobals.peekWallpaperBitmap(mContext, false);
    if (bm != null) {
        Drawable dr = new BitmapDrawable(mContext.getResources(), bm);
        dr.setDither(false);
        return dr;
    }
    return null;
}","{
    Bitmap bm = sGlobals.peekWallpaperBitmap(mContext, false, FLAG_SYSTEM);
    if (bm != null) {
        Drawable dr = new BitmapDrawable(mContext.getResources(), bm);
        dr.setDither(false);
        return dr;
    }
    return null;
}",1,"/**
 * Retrieve the current system wallpaper; if there is no wallpaper set,
 * a null pointer is returned. This is returned as an
 * abstract Drawable that you can install in a View to display whatever
 * wallpaper the user has currently set.
 *
 * @return Returns a Drawable object that will draw the wallpaper or a
 * null pointer if these is none.
 */
","/**
 * Retrieve the current system wallpaper; if there is no wallpaper set,
 * a null pointer is returned. This is returned as an
 * abstract Drawable that you can install in a View to display whatever
 * wallpaper the user has currently set.
 *
 * @return Returns a Drawable object that will draw the wallpaper or a
 * null pointer if these is none.
 */
",-1,,,-1,-1,-1,-1,-1,5,0,5,1,The code change is due to the introduction of a new parameter in the call to `sGlobals.peekWallpaperBitmap()` method. This change falls under the category "Dependent API changed".,"The new parameter introduced in the call to `sGlobals.peekWallpaperBitmap()` method may lead to different behavior of the API, as it could result in a different bitmap being returned. This, in turn, could result in a different Drawable being returned by the `peekDrawable()` method, leading to a compatibility issue caused by potential different return values."
65,<android.app.VoiceInteractor: boolean unregisterOnDestroyedCallback(Runnable)>,29,30,<android.app.VoiceInteractor: boolean unregisterOnDestroyedCallback(Runnable)>,<android.app.VoiceInteractor: boolean unregisterOnDestroyedCallback(Runnable)>,0,"{
    Preconditions.checkNotNull(callback);
    if (isDestroyed()) {
        Log.w(TAG, ""Cannot interact with a destroyed voice interactor"");
        return false;
    }
    return mOnDestroyCallbacks.remove(callback) != null;
}","{
    Objects.requireNonNull(callback);
    if (isDestroyed()) {
        Log.w(TAG, ""Cannot interact with a destroyed voice interactor"");
        return false;
    }
    return mOnDestroyCallbacks.remove(callback) != null;
}",1,"/**
 * Unregisters a previously registered onDestroy callback
 *
 * @param callback The callback to remove.
 * @return whether the callback was unregistered.
 */
","/**
 * Unregisters a previously registered onDestroy callback
 *
 * @param callback The callback to remove.
 * @return whether the callback was unregistered.
 */
",-1,,,-1,-1,-1,-1,-1,4,0,4,0,"The only difference between the two versions is the null check for the `callback` parameter. The `Preconditions.checkNotNull(callback)` in the early version is replaced by `Objects.requireNonNull(callback)` in the late version. Both statements check if `callback` is null and throw a `NullPointerException` if it is, but they are implemented differently. This change belongs to the ""Other statement changed"" category.","Although the null check statement has changed, it does not lead to any compatibility issue. The behavior remains the same in both versions, i.e., a `NullPointerException` will be thrown if `callback` is null. The returned boolean value and exception handling are the same in both versions, so there is no compatibility issue."
736,"<android.hardware.display.DisplayManager: VirtualDisplay createVirtualDisplay(String,int,int,int,Surface,int)>",20,21,"<android.hardware.display.DisplayManager: VirtualDisplay createVirtualDisplay(String,int,int,int,Surface,int)>","<android.hardware.display.DisplayManager: VirtualDisplay createVirtualDisplay(String,int,int,int,Surface,int)>",0,"{
    return mGlobal.createVirtualDisplay(mContext, name, width, height, densityDpi, surface, flags);
}","{
    return createVirtualDisplay(name, width, height, densityDpi, surface, flags, null, null);
}",1,"/**
 * Creates a virtual display.
 * <p>
 * The content of a virtual display is rendered to a {@link Surface} provided
 * by the application.
 * </p><p>
 * The virtual display should be {@link VirtualDisplay#release released}
 * when no longer needed.  Because a virtual display renders to a surface
 * provided by the application, it will be released automatically when the
 * process terminates and all remaining windows on it will be forcibly removed.
 * </p><p>
 * The behavior of the virtual display depends on the flags that are provided
 * to this method.  By default, virtual displays are created to be private,
 * non-presentation and unsecure.  Permissions may be required to use certain flags.
 * </p>
 *
 * @param name The name of the virtual display, must be non-empty.
 * @param width The width of the virtual display in pixels, must be greater than 0.
 * @param height The height of the virtual display in pixels, must be greater than 0.
 * @param densityDpi The density of the virtual display in dpi, must be greater than 0.
 * @param surface The surface to which the content of the virtual display should
 * be rendered, must be non-null.
 * @param flags A combination of virtual display flags:
 * {@link #VIRTUAL_DISPLAY_FLAG_PUBLIC}, {@link #VIRTUAL_DISPLAY_FLAG_PRESENTATION}
 * or {@link #VIRTUAL_DISPLAY_FLAG_SECURE}.
 * @return The newly created virtual display, or null if the application could
 * not create the virtual display.
 *
 * @throws SecurityException if the caller does not have permission to create
 * a virtual display with the specified flags.
 */
","/**
 * Creates a virtual display.
 *
 * @see #createVirtualDisplay(String, int, int, int, Surface, int, VirtualDisplay.Callback)
 */
",-1,,,-1,-1,-1,-1,-1,"1,4",1,5,1,"Based on the provided code, the implementation of the `createVirtualDisplay` method has changed between versions 20 and 21. In version 20, the method invokes `mGlobal.createVirtualDisplay` with six arguments, whereas in version 21, it invokes `createVirtualDisplay` with eight arguments, passing `null` for the last two. This is a Dependent API change, as the implementation now depends on a different version of the `createVirtualDisplay` method.","This change could lead to a Compatibility Issue of type 1 (Compatibility Issue caused by potential different return values or types), because the implementation now depends on a different version of the `createVirtualDisplay` method that takes different arguments. This could cause the method to behave differently and return a different value, depending on the implementation of the new version of `createVirtualDisplay`."
138,<android.view.View: boolean hasFocusable()>,20,21,<android.view.View: boolean hasFocusable()>,<android.view.View: boolean hasFocusable()>,0,"{
    return (mViewFlags & VISIBILITY_MASK) == VISIBLE && isFocusable();
}","{
    if (!isFocusableInTouchMode()) {
        for (ViewParent p = mParent; p instanceof ViewGroup; p = p.getParent()) {
            final ViewGroup g = (ViewGroup) p;
            if (g.shouldBlockFocusForTouchscreen()) {
                return false;
            }
        }
    }
    return (mViewFlags & VISIBILITY_MASK) == VISIBLE && isFocusable();
}",1,"/**
 * Returns true if this view is focusable or if it contains a reachable View
 * for which {@link #hasFocusable()} returns true. A ""reachable hasFocusable()""
 * is a View whose parents do not block descendants focus.
 *
 * Only {@link #VISIBLE} views are considered focusable.
 *
 * @return True if the view is focusable or if the view contains a focusable
 * View, false otherwise.
 *
 * @see ViewGroup#FOCUS_BLOCK_DESCENDANTS
 */
","/**
 * Returns true if this view is focusable or if it contains a reachable View
 * for which {@link #hasFocusable()} returns true. A ""reachable hasFocusable()""
 * is a View whose parents do not block descendants focus.
 *
 * Only {@link #VISIBLE} views are considered focusable.
 *
 * @return True if the view is focusable or if the view contains a focusable
 * View, false otherwise.
 *
 * @see ViewGroup#FOCUS_BLOCK_DESCENDANTS
 * @see ViewGroup#getTouchscreenBlocksFocus()
 */
",-1,,,-1,-1,-1,-1,-1,"1,3",1,3,1,"A new 'if' control dependency has been introduced, making the code change type 3.","The added 'if' statement could cause the API to return a different value (false), so the code change potentially leads to Compatibility Issue. Therefore, the CI type is 1."
352,<android.preference.PreferenceActivity: void switchToHeader(Header)>,20,21,<android.preference.PreferenceActivity: void switchToHeader(Header)>,<android.preference.PreferenceActivity: void switchToHeader(Header)>,0,"{
    if (mCurHeader == header) {
        // This is the header we are currently displaying.  Just make sure
        // to pop the stack up to its root state.
        getFragmentManager().popBackStack(BACK_STACK_PREFS, FragmentManager.POP_BACK_STACK_INCLUSIVE);
    } else {
        if (header.fragment == null) {
            throw new IllegalStateException(""can't switch to header that has no fragment"");
        }
        int direction = mHeaders.indexOf(header) - mHeaders.indexOf(mCurHeader);
        switchToHeaderInner(header.fragment, header.fragmentArguments, direction);
        setSelectedHeader(header);
    }
}","{
    if (mCurHeader == header) {
        // This is the header we are currently displaying.  Just make sure
        // to pop the stack up to its root state.
        getFragmentManager().popBackStack(BACK_STACK_PREFS, FragmentManager.POP_BACK_STACK_INCLUSIVE);
    } else {
        if (header.fragment == null) {
            throw new IllegalStateException(""can't switch to header that has no fragment"");
        }
        switchToHeaderInner(header.fragment, header.fragmentArguments);
        setSelectedHeader(header);
    }
}",1,"/**
 * When in two-pane mode, switch to the fragment pane to show the given
 * preference fragment.
 *
 * @param header The new header to display.
 */
","/**
 * When in two-pane mode, switch to the fragment pane to show the given
 * preference fragment.
 *
 * @param header The new header to display.
 */
",-1,,,-1,-1,-1,-1,-1,4,0,3,1,"In the late version, the statement `int direction = mHeaders.indexOf(header) - mHeaders.indexOf(mCurHeader);` is removed, and the method `switchToHeaderInner` is changed from `switchToHeaderInner(header.fragment, header.fragmentArguments, direction);` to `switchToHeaderInner(header.fragment, header.fragmentArguments);`. This change is about the control dependency change, so the code change type is 3.","This change could potentially lead to the API behaving differently. Specifically, the `switchToHeaderInner` method could receive different parameters, which may cause it to return different values or throw different exceptions. Therefore, the CI type is 1."
551,<android.view.View: void setAutofillId(AutofillId)>,28,29,<android.view.View: void setAutofillId(AutofillId)>,<android.view.View: void setAutofillId(AutofillId)>,0,"{
    // TODO(b/37566627): add unit / CTS test for all possible combinations below
    if (android.view.autofill.Helper.sVerbose) {
        Log.v(VIEW_LOG_TAG, ""setAutofill(): from "" + mAutofillId + "" to "" + id);
    }
    if (isAttachedToWindow()) {
        throw new IllegalStateException(""Cannot set autofill id when view is attached"");
    }
    if (id != null && id.isVirtual()) {
        throw new IllegalStateException(""Cannot set autofill id assigned to virtual views"");
    }
    if (id == null && (mPrivateFlags3 & PFLAG3_AUTOFILLID_EXPLICITLY_SET) == 0) {
        // Ignore reset because it was never explicitly set before.
        return;
    }
    mAutofillId = id;
    if (id != null) {
        mAutofillViewId = id.getViewId();
        mPrivateFlags3 |= PFLAG3_AUTOFILLID_EXPLICITLY_SET;
    } else {
        mAutofillViewId = NO_ID;
        mPrivateFlags3 &= ~PFLAG3_AUTOFILLID_EXPLICITLY_SET;
    }
}","{
    // TODO(b/37566627): add unit / CTS test for all possible combinations below
    if (Log.isLoggable(AUTOFILL_LOG_TAG, Log.VERBOSE)) {
        Log.v(AUTOFILL_LOG_TAG, ""setAutofill(): from "" + mAutofillId + "" to "" + id);
    }
    if (isAttachedToWindow()) {
        throw new IllegalStateException(""Cannot set autofill id when view is attached"");
    }
    if (id != null && !id.isNonVirtual()) {
        throw new IllegalStateException(""Cannot set autofill id assigned to virtual views"");
    }
    if (id == null && (mPrivateFlags3 & PFLAG3_AUTOFILLID_EXPLICITLY_SET) == 0) {
        // Ignore reset because it was never explicitly set before.
        return;
    }
    mAutofillId = id;
    if (id != null) {
        mAutofillViewId = id.getViewId();
        mPrivateFlags3 |= PFLAG3_AUTOFILLID_EXPLICITLY_SET;
    } else {
        mAutofillViewId = NO_ID;
        mPrivateFlags3 &= ~PFLAG3_AUTOFILLID_EXPLICITLY_SET;
    }
}",1,"/**
 * Sets the unique, logical identifier of this view in the activity, for autofill purposes.
 *
 * <p>The autofill id is created on demand, and this method should only be called when a view is
 * reused after {@link #dispatchProvideAutofillStructure(ViewStructure, int)} is called, as
 * that method creates a snapshot of the view that is passed along to the autofill service.
 *
 * <p>This method is typically used when view subtrees are recycled to represent different
 * content* &mdash;in this case, the autofill id can be saved before the view content is swapped
 * out, and restored later when it's swapped back in. For example:
 *
 * <pre>
 * EditText reusableView = ...;
 * ViewGroup parentView = ...;
 * AutofillManager afm = ...;
 *
 * // Swap out the view and change its contents
 * AutofillId oldId = reusableView.getAutofillId();
 * CharSequence oldText = reusableView.getText();
 * parentView.removeView(reusableView);
 * AutofillId newId = afm.getNextAutofillId();
 * reusableView.setText(""New I am"");
 * reusableView.setAutofillId(newId);
 * parentView.addView(reusableView);
 *
 * // Later, swap the old content back in
 * parentView.removeView(reusableView);
 * reusableView.setAutofillId(oldId);
 * reusableView.setText(oldText);
 * parentView.addView(reusableView);
 * </pre>
 *
 * @param id an autofill ID that is unique in the {@link android.app.Activity} hosting the view,
 * or {@code null} to reset it. Usually it's an id previously allocated to another view (and
 * obtained through {@link #getAutofillId()}), or a new value obtained through
 * {@link AutofillManager#getNextAutofillId()}.
 *
 * @throws IllegalStateException if the view is already {@link #isAttachedToWindow() attached to
 * a window}.
 *
 * @throws IllegalArgumentException if the id is an autofill id associated with a virtual view.
 */
","/**
 * Sets the unique, logical identifier of this view in the activity, for autofill purposes.
 *
 * <p>The autofill id is created on demand, and this method should only be called when a view is
 * reused after {@link #dispatchProvideAutofillStructure(ViewStructure, int)} is called, as
 * that method creates a snapshot of the view that is passed along to the autofill service.
 *
 * <p>This method is typically used when view subtrees are recycled to represent different
 * content* &mdash;in this case, the autofill id can be saved before the view content is swapped
 * out, and restored later when it's swapped back in. For example:
 *
 * <pre>
 * EditText reusableView = ...;
 * ViewGroup parentView = ...;
 * AutofillManager afm = ...;
 *
 * // Swap out the view and change its contents
 * AutofillId oldId = reusableView.getAutofillId();
 * CharSequence oldText = reusableView.getText();
 * parentView.removeView(reusableView);
 * AutofillId newId = afm.getNextAutofillId();
 * reusableView.setText(""New I am"");
 * reusableView.setAutofillId(newId);
 * parentView.addView(reusableView);
 *
 * // Later, swap the old content back in
 * parentView.removeView(reusableView);
 * reusableView.setAutofillId(oldId);
 * reusableView.setText(oldText);
 * parentView.addView(reusableView);
 * </pre>
 *
 * @param id an autofill ID that is unique in the {@link android.app.Activity} hosting the view,
 * or {@code null} to reset it. Usually it's an id previously allocated to another view (and
 * obtained through {@link #getAutofillId()}), or a new value obtained through
 * {@link AutofillManager#getNextAutofillId()}.
 *
 * @throws IllegalStateException if the view is already {@link #isAttachedToWindow() attached to
 * a window}.
 *
 * @throws IllegalArgumentException if the id is an autofill id associated with a virtual view.
 */
",-1,,,-1,-1,-1,-1,-1,"2,3,4",2,2,2,"The if statement under the condition ""if (id != null && !id.isNonVirtual())"" has changed, from ""id.isVirtual()"" to ""!id.isNonVirtual()"", which means the late version has a different exception handling.","The change makes the API throw a different exception when the condition is met, so it could arise a Compatibility Issue caused by potential different exception handlings."
363,"<android.app.ContextImpl: void sendOrderedBroadcast(Intent,String)>",16,17,"<android.app.ContextImpl: void sendOrderedBroadcast(Intent,String)>","<android.app.ContextImpl: void sendOrderedBroadcast(Intent,String)>",0,"{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.setAllowFds(false);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermission, true, false, Binder.getOrigCallingUser());
    } catch (RemoteException e) {
    }
}","{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.setAllowFds(false);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermission, true, false, getUserId());
    } catch (RemoteException e) {
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,"4,5",1,5,1,"The code change type is 5, as a new method `warnIfCallingFromSystemProcess()` is added and the parameter of the dependent API `ActivityManagerNative.getDefault().broadcastIntent()` has changed.","The new added method `warnIfCallingFromSystemProcess()` and the changed parameter of the dependent API `ActivityManagerNative.getDefault().broadcastIntent()` potentially cause the API to return a different value or throw a different exception, thus the CI type is 1."
729,<android.widget.AdapterView: int getPositionForView(View)>,22,23,<android.widget.AdapterView: int getPositionForView(View)>,<android.widget.AdapterView: int getPositionForView(View)>,0,"{
    View listItem = view;
    try {
        View v;
        while (!(v = (View) listItem.getParent()).equals(this)) {
            listItem = v;
        }
    } catch (ClassCastException e) {
        // We made it up to the window without find this list view
        return INVALID_POSITION;
    }
    // Search the children for the list item
    final int childCount = getChildCount();
    for (int i = 0; i < childCount; i++) {
        if (getChildAt(i).equals(listItem)) {
            return mFirstPosition + i;
        }
    }
    // Child not found!
    return INVALID_POSITION;
}","{
    View listItem = view;
    try {
        View v;
        while ((v = (View) listItem.getParent()) != null && !v.equals(this)) {
            listItem = v;
        }
    } catch (ClassCastException e) {
        // We made it up to the window without find this list view
        return INVALID_POSITION;
    }
    if (listItem != null) {
        // Search the children for the list item
        final int childCount = getChildCount();
        for (int i = 0; i < childCount; i++) {
            if (getChildAt(i).equals(listItem)) {
                return mFirstPosition + i;
            }
        }
    }
    // Child not found!
    return INVALID_POSITION;
}",1,"/**
 * Get the position within the adapter's data set for the view, where view is a an adapter item
 * or a descendant of an adapter item.
 *
 * @param view an adapter item, or a descendant of an adapter item. This must be visible in this
 * AdapterView at the time of the call.
 * @return the position within the adapter's data set of the view, or {@link #INVALID_POSITION}
 * if the view does not correspond to a list item (or it is not currently visible).
 */
","/**
 * Get the position within the adapter's data set for the view, where view is a an adapter item
 * or a descendant of an adapter item.
 *
 * @param view an adapter item, or a descendant of an adapter item. This must be visible in this
 * AdapterView at the time of the call.
 * @return the position within the adapter's data set of the view, or {@link #INVALID_POSITION}
 * if the view does not correspond to a list item (or it is not currently visible).
 */
",-1,,,-1,-1,-1,-1,-1,3,1,3,1,"The condition statement in the 'while' loop has changed from '!(v = (View) listItem.getParent()).equals(this)' to '(v = (View) listItem.getParent()) != null && !v.equals(this)'. Also, a new 'if' statement has been introduced to check whether 'listItem' is null or not before searching the children for the list item.","The change in the 'while' loop condition statement could make the API potentially return different values when the parent view of the list item is not found. Additionally, the introduced 'if' statement could also lead to the API returning a different value, so the CI type is 1."
800,<android.app.DialogFragment: void onActivityCreated(Bundle)>,23,24,<android.app.DialogFragment: void onActivityCreated(Bundle)>,<android.app.DialogFragment: void onActivityCreated(Bundle)>,0,"{
    super.onActivityCreated(savedInstanceState);
    if (!mShowsDialog) {
        return;
    }
    View view = getView();
    if (view != null) {
        if (view.getParent() != null) {
            throw new IllegalStateException(""DialogFragment can not be attached to a container view"");
        }
        mDialog.setContentView(view);
    }
    mDialog.setOwnerActivity(getActivity());
    mDialog.setCancelable(mCancelable);
    if (!mDialog.takeCancelAndDismissListeners(""DialogFragment"", this, this)) {
        throw new IllegalStateException(""You can not set Dialog's OnCancelListener or OnDismissListener"");
    }
    if (savedInstanceState != null) {
        Bundle dialogState = savedInstanceState.getBundle(SAVED_DIALOG_STATE_TAG);
        if (dialogState != null) {
            mDialog.onRestoreInstanceState(dialogState);
        }
    }
}","{
    super.onActivityCreated(savedInstanceState);
    if (!mShowsDialog) {
        return;
    }
    View view = getView();
    if (view != null) {
        if (view.getParent() != null) {
            throw new IllegalStateException(""DialogFragment can not be attached to a container view"");
        }
        mDialog.setContentView(view);
    }
    final Activity activity = getActivity();
    if (activity != null) {
        mDialog.setOwnerActivity(activity);
    }
    mDialog.setCancelable(mCancelable);
    if (!mDialog.takeCancelAndDismissListeners(""DialogFragment"", this, this)) {
        throw new IllegalStateException(""You can not set Dialog's OnCancelListener or OnDismissListener"");
    }
    if (savedInstanceState != null) {
        Bundle dialogState = savedInstanceState.getBundle(SAVED_DIALOG_STATE_TAG);
        if (dialogState != null) {
            mDialog.onRestoreInstanceState(dialogState);
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,"3,4",0,3,1,"The code change is in the control dependency. In the early version, the mDialog.setOwnerActivity(getActivity()) is called directly, while in the late version, it's called only if the getActivity() is not null.","The change in control dependency may cause potential compatibility issue. In the early version, if the getActivity() returns null, a NullPointerException will be thrown when calling mDialog.setOwnerActivity(getActivity()). However, in the late version, the method mDialog.setOwnerActivity(activity) will not be called in this case, which avoids the NullPointerException. So the potential compatibility issue is caused by the different exception handling."
768,<android.hardware.radio.RadioManager.ProgramInfo: boolean equals(Object)>,27,28,<android.hardware.radio.RadioManager.ProgramInfo: boolean equals(Object)>,<android.hardware.radio.RadioManager.ProgramInfo: boolean equals(Object)>,0,"{
    if (this == obj)
        return true;
    if (!(obj instanceof ProgramInfo))
        return false;
    ProgramInfo other = (ProgramInfo) obj;
    if (!mSelector.equals(other.getSelector()))
        return false;
    if (mTuned != other.isTuned())
        return false;
    if (mStereo != other.isStereo())
        return false;
    if (mDigital != other.isDigital())
        return false;
    if (mFlags != other.mFlags)
        return false;
    if (mSignalStrength != other.getSignalStrength())
        return false;
    if (mMetadata == null) {
        if (other.getMetadata() != null)
            return false;
    } else if (!mMetadata.equals(other.getMetadata()))
        return false;
    if (!mVendorInfo.equals(other.mVendorInfo))
        return false;
    return true;
}","{
    if (this == obj)
        return true;
    if (!(obj instanceof ProgramInfo))
        return false;
    ProgramInfo other = (ProgramInfo) obj;
    if (!Objects.equals(mSelector, other.mSelector))
        return false;
    if (!Objects.equals(mLogicallyTunedTo, other.mLogicallyTunedTo))
        return false;
    if (!Objects.equals(mPhysicallyTunedTo, other.mPhysicallyTunedTo))
        return false;
    if (!Objects.equals(mRelatedContent, other.mRelatedContent))
        return false;
    if (mInfoFlags != other.mInfoFlags)
        return false;
    if (mSignalQuality != other.mSignalQuality)
        return false;
    if (!Objects.equals(mMetadata, other.mMetadata))
        return false;
    if (!Objects.equals(mVendorInfo, other.mVendorInfo))
        return false;
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,"1,3,4",1,"1, 3",1,"The early implementation uses `mSelector.equals(other.getSelector())` to check equality, while the late implementation uses `Objects.equals(mSelector, other.mSelector)`. There are also new fields added to the late implementation, such as `mLogicallyTunedTo`, `mPhysicallyTunedTo`, `mRelatedContent`, `mInfoFlags`, and `mSignalQuality`, which leads to additional control dependency changes.","The change of equality check method and the addition of new fields can potentially lead to different return values, causing a compatibility issue. For example, if `mSelector` or `other.mSelector` is `null`, the early implementation will throw a `NullPointerException`, while the late implementation will not. The addition of new fields also means that the late implementation may return `false` even if all fields in the early implementation are equal, causing a compatibility issue."
264,<android.app.ContextImpl: int checkSelfPermission(String)>,30,31,<android.app.ContextImpl: int checkSelfPermission(String)>,<android.app.ContextImpl: int checkSelfPermission(String)>,0,"{
    if (permission == null) {
        throw new IllegalArgumentException(""permission is null"");
    }
    return checkPermission(permission, Process.myPid(), Process.myUid());
}","{
    if (permission == null) {
        throw new IllegalArgumentException(""permission is null"");
    }
    if (mParams.isRenouncedPermission(permission)) {
        Log.v(TAG, ""Treating renounced permission "" + permission + "" as denied"");
        return PERMISSION_DENIED;
    }
    return checkPermission(permission, Process.myPid(), Process.myUid());
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,"1,3,4",1,3,1,"The late implementation has added an if statement, which checks if a permission is renounced. This is a control dependency change.","The added if statement checks if the permission is renounced. If it is, the API will return PERMISSION\_DENIED. This could lead to a different return value for the API, which is a Compatibility Issue. Therefore, the CI type is 1."
1068,"<android.os.Vibrator: void vibrate(long[],int,AudioAttributes)>",25,26,"<android.os.Vibrator: void vibrate(long[],int,AudioAttributes)>","<android.os.Vibrator: void vibrate(long[],int,AudioAttributes)>",0,"{
    vibrate(Process.myUid(), mPackageName, pattern, repeat, attributes);
}","{
    // exceptions for compatibility purposes
    if (repeat < -1 || repeat >= pattern.length) {
        Log.e(TAG, ""vibrate called with repeat index out of bounds"" + "" (pattern.length="" + pattern.length + "", index="" + repeat + "")"");
        throw new ArrayIndexOutOfBoundsException();
    }
    try {
        vibrate(VibrationEffect.createWaveform(pattern, repeat), attributes);
    } catch (IllegalArgumentException iae) {
        Log.e(TAG, ""Failed to create VibrationEffect"", iae);
    }
}",1,"/**
 * Vibrate with a given pattern.
 *
 * <p>
 * Pass in an array of ints that are the durations for which to turn on or off
 * the vibrator in milliseconds.  The first value indicates the number of milliseconds
 * to wait before turning the vibrator on.  The next value indicates the number of milliseconds
 * for which to keep the vibrator on before turning it off.  Subsequent values alternate
 * between durations in milliseconds to turn the vibrator off or to turn the vibrator on.
 * </p><p>
 * To cause the pattern to repeat, pass the index into the pattern array at which
 * to start the repeat, or -1 to disable repeating.
 * </p>
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#VIBRATE}.
 *
 * @param pattern an array of longs of times for which to turn the vibrator on or off.
 * @param repeat the index into pattern at which to repeat, or -1 if
 * you don't want to repeat.
 * @param attributes {@link AudioAttributes} corresponding to the vibration. For example,
 * specify {@link AudioAttributes#USAGE_ALARM} for alarm vibrations or
 * {@link AudioAttributes#USAGE_NOTIFICATION_RINGTONE} for
 * vibrations associated with incoming calls.
 */
","/**
 * Vibrate with a given pattern.
 *
 * <p>
 * Pass in an array of ints that are the durations for which to turn on or off
 * the vibrator in milliseconds.  The first value indicates the number of milliseconds
 * to wait before turning the vibrator on.  The next value indicates the number of milliseconds
 * for which to keep the vibrator on before turning it off.  Subsequent values alternate
 * between durations in milliseconds to turn the vibrator off or to turn the vibrator on.
 * </p><p>
 * To cause the pattern to repeat, pass the index into the pattern array at which
 * to start the repeat, or -1 to disable repeating.
 * </p>
 *
 * @param pattern an array of longs of times for which to turn the vibrator on or off.
 * @param repeat the index into pattern at which to repeat, or -1 if
 * you don't want to repeat.
 * @param attributes {@link AudioAttributes} corresponding to the vibration. For example,
 * specify {@link AudioAttributes#USAGE_ALARM} for alarm vibrations or
 * {@link AudioAttributes#USAGE_NOTIFICATION_RINGTONE} for
 * vibrations associated with incoming calls.
 *
 * @deprecated Use {@link #vibrate(VibrationEffect, AudioAttributes)} instead.
 */
",-1,,"[@Deprecated, @RequiresPermission(android.Manifest.permission.VIBRATE)]",-1,-1,-1,-1,-1,"2,3,4,5",2,"1, 2, 3","1, 2","The implementation of the vibrate() method has changed significantly between the two versions. In the early version, the method simply calls the vibrate() method with different parameters. In the late version, the method first checks if the repeat index is out of bounds, and if so, throws an ArrayIndexOutOfBoundsException. Then, it creates a VibrationEffect object and calls the vibrate() method with this object and the attributes parameter. Additionally, the late version includes a try-catch block to handle IllegalArgumentException. The annotation has also changed, with the late version including the @Deprecated and @RequiresPermission annotations.","The changes in the implementation and exception handling can potentially lead to different behaviors in the two versions. In the early version, the vibrate() method is called with different parameters, while in the late version, a VibrationEffect object is created and used to call the vibrate() method. If the repeat index is out of bounds, the late version will throw an ArrayIndexOutOfBoundsException, while the early version will not. The try-catch block in the late version also handles IllegalArgumentException, which may not be handled in the early version. These changes can potentially lead to compatibility issues, such as different return values or types (due to the changes in the vibrate() method call) or different exception handlings (due to the added exception handling in the late version)."
216,<android.app.UiAutomation: void setRunAsMonkey(boolean)>,30,31,<android.app.UiAutomation: void setRunAsMonkey(boolean)>,<android.app.UiAutomation: void setRunAsMonkey(boolean)>,0,"{
    synchronized (mLock) {
        throwIfNotConnectedLocked();
    }
    try {
        ActivityManager.getService().setUserIsMonkey(enable);
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error while setting run as monkey!"", re);
    }
}","{
    try {
        ActivityManager.getService().setUserIsMonkey(enable);
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error while setting run as monkey!"", re);
    }
}",1,"/**
 * Sets whether this UiAutomation to run in a ""monkey"" mode. Applications can query whether
 * they are executed in a ""monkey"" mode, i.e. run by a test framework, and avoid doing
 * potentially undesirable actions such as calling 911 or posting on public forums etc.
 *
 * @param enable whether to run in a ""monkey"" mode or not. Default is not.
 * @see ActivityManager#isUserAMonkey()
 */
","/**
 * Sets whether this UiAutomation to run in a ""monkey"" mode. Applications can query whether
 * they are executed in a ""monkey"" mode, i.e. run by a test framework, and avoid doing
 * potentially undesirable actions such as calling 911 or posting on public forums etc.
 *
 * @param enable whether to run in a ""monkey"" mode or not. Default is not.
 * @see ActivityManager#isUserAMonkey()
 */
",-1,,,-1,-1,-1,-1,-1,4,0,4,0,"The early version of the method includes a synchronized block that calls throwIfNotConnectedLocked() method, while the late version of the method does not have this synchronized block. This change falls under the ""Other statement changed"" category.","The removal of the synchronized block does not affect the return value or the exception handling of the method. Therefore, there is no Compatibility Issue caused by this change."
776,<android.os.PowerManager: boolean isPowerSaveMode()>,29,30,<android.os.PowerManager: boolean isPowerSaveMode()>,<android.os.PowerManager: boolean isPowerSaveMode()>,0,"{
    try {
        return mService.isPowerSaveMode();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    return mPowerSaveModeCache.query(null);
}",1,"/**
 * Returns true if the device is currently in power save mode.  When in this mode,
 * applications should reduce their functionality in order to conserve battery as
 * much as possible.  You can monitor for changes to this state with
 * {@link #ACTION_POWER_SAVE_MODE_CHANGED}.
 *
 * @return Returns true if currently in low power mode, else false.
 */
","/**
 * Returns true if the device is currently in power save mode.  When in this mode,
 * applications should reduce their functionality in order to conserve battery as
 * much as possible.  You can monitor for changes to this state with
 * {@link #ACTION_POWER_SAVE_MODE_CHANGED}.
 *
 * @return Returns true if currently in low power mode, else false.
 */
",-1,,,-1,-1,-1,-1,-1,"1,2,4","1,2","1,5",1,"The return statement has changed from mService.isPowerSaveMode() to mPowerSaveModeCache.query(null), and the method being called has also changed, so the code change type is 1,5.","The change of return statement will make the API potentially return a different value, so the CI type is 1."
961,<android.webkit.WebSettings: void setUseWebViewBackgroundForOverscrollBackground(boolean)>,15,16,<android.webkit.WebSettings: void setUseWebViewBackgroundForOverscrollBackground(boolean)>,<android.webkit.WebSettings: void setUseWebViewBackgroundForOverscrollBackground(boolean)>,0,"{
    mUseWebViewBackgroundForOverscroll = view;
}","{
    throw new MustOverrideException();
}",1,"/**
 * Set whether the WebView uses its background for over scroll background.
 * If true, it will use the WebView's background. If false, it will use an
 * internal pattern. Default is true.
 * @deprecated This method is now obsolete.
 */
","/**
 * Sets whether the WebView uses its background for over scroll background.
 * If true, it will use the WebView's background. If false, it will use an
 * internal pattern. Default is true.
 *
 * @deprecated This method is now obsolete.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,2,2,"1,2",1,"The implementation of the API has changed from setting a value to throwing an exception (`throw new MustOverrideException()`), so the change type is 1,2.","Since the late version always throws an exception, which is different from the original behavior of the API, it may cause a Compatibility Issue. As the return value is no longer relevant, the CI is caused by potential different exception handling, and the CI type is 1."
535,<android.text.StaticLayout: int getLineDescent(int)>,23,24,<android.text.StaticLayout: int getLineDescent(int)>,<android.text.StaticLayout: int getLineDescent(int)>,0,"{
    int descent = mLines[mColumns * line + DESCENT];
    if (// -1 intended
    mMaximumVisibleLineCount > 0 && line >= mMaximumVisibleLineCount - 1 && line != mLineCount) {
        descent += getBottomPadding();
    }
    return descent;
}","{
    return mLines[mColumns * line + DESCENT];
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,"1,3",1,1,1,"The return statement has changed, the original implementation has been simplified, and the condition statement for calculating the value of 'descent' has been removed.","The removed condition statement in late version could potentially cause the API to return a different value when the maximum visible line count is greater than 0, and the line number is not the last line. Thus, it can be classified as a CI caused by potential different return values."
464,<android.app.ContextImpl: void sendBroadcast(Intent)>,30,31,<android.app.ContextImpl: void sendBroadcast(Intent)>,<android.app.ContextImpl: void sendBroadcast(Intent)>,0,"{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, false, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, null, /*excludedPermissions=*/
        AppOpsManager.OP_NONE, null, false, false, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,5,0,5,1,"The code change is that, in the late version, a new parameter is introduced in the `broadcastIntentWithFeature` method which is called in the `sendBroadcast` method. This new parameter is `excludedPermissions`, and it is set as `AppOpsManager.OP_NONE`.","The new parameter `excludedPermissions` introduced in the `broadcastIntentWithFeature` method may affect the behavior of the `sendBroadcast` method. Specifically, it may change the way the intent is broadcasted, leading to different results. Therefore, this code change potentially causes the API to return a different variable (value or type), and it should be regarded as a Compatibility Issue (CI) with type 1."
292,<android.widget.TimePicker: void setIs24HourView(Boolean)>,18,19,<android.widget.TimePicker: void setIs24HourView(Boolean)>,<android.widget.TimePicker: void setIs24HourView(Boolean)>,0,"{
    if (mIs24HourView == is24HourView) {
        return;
    }
    mIs24HourView = is24HourView;
    // cache the current hour since spinner range changes
    int currentHour = getCurrentHour();
    updateHourControl();
    // set value after spinner range is updated
    setCurrentHour(currentHour);
    updateAmPmControl();
}","{
    if (mIs24HourView == is24HourView) {
        return;
    }
    // cache the current hour since spinner range changes and BEFORE changing mIs24HourView!!
    int currentHour = getCurrentHour();
    // Order is important here.
    mIs24HourView = is24HourView;
    getHourFormatData();
    updateHourControl();
    // set value after spinner range is updated - be aware that because mIs24HourView has
    // changed then getCurrentHour() is not equal to the currentHour we cached before so
    // explicitly ask for *not* propagating any onTimeChanged()
    setCurrentHour(currentHour, false);
    updateMinuteControl();
    updateAmPmControl();
}",1,"/**
 * Set whether in 24 hour or AM/PM mode.
 *
 * @param is24HourView True = 24 hour mode. False = AM/PM.
 */
","/**
 * Set whether in 24 hour or AM/PM mode.
 *
 * @param is24HourView True = 24 hour mode. False = AM/PM.
 */
",-1,,,-1,-1,-1,-1,-1,"4,5",0,"3,4",1,"The implementation of the method setIs24HourView has changed in control dependency and other statements. The statement ""mIs24HourView = is24HourView;"" has been moved after ""int currentHour = getCurrentHour();"" and a new method ""getHourFormatData();"" has been added. Also, ""setCurrentHour(currentHour);"" has been replaced with ""setCurrentHour(currentHour, false);"" and ""updateAmPmControl();"" has been added.","The change in control dependency and other statements can cause potential compatibility issues as the API may behave differently in the late version. Specifically, the added method ""getHourFormatData();"" may affect the return value of the API, and the change in ""setCurrentHour(currentHour);"" to ""setCurrentHour(currentHour, false);"" may also affect the return value of the API. Therefore, the CI type is 1, which is a compatibility issue caused by potential different return values or types."
344,"<android.provider.Settings.NameValueCache: boolean putStringForUser(ContentResolver,String,String,int)>",17,18,"<android.provider.Settings.NameValueCache: boolean putStringForUser(ContentResolver,String,String,int)>","<android.provider.Settings.NameValueCache: boolean putStringForUser(ContentResolver,String,String,int)>",0,"{
    try {
        Bundle arg = new Bundle();
        arg.putString(Settings.NameValueTable.VALUE, value);
        arg.putInt(CALL_METHOD_USER_KEY, userHandle);
        IContentProvider cp = lazyGetProvider(cr);
        cp.call(mCallSetCommand, name, arg);
    } catch (RemoteException e) {
        Log.w(TAG, ""Can't set key "" + name + "" in "" + mUri, e);
        return false;
    }
    return true;
}","{
    try {
        Bundle arg = new Bundle();
        arg.putString(Settings.NameValueTable.VALUE, value);
        arg.putInt(CALL_METHOD_USER_KEY, userHandle);
        IContentProvider cp = lazyGetProvider(cr);
        cp.call(cr.getPackageName(), mCallSetCommand, name, arg);
    } catch (RemoteException e) {
        Log.w(TAG, ""Can't set key "" + name + "" in "" + mUri, e);
        return false;
    }
    return true;
}",1,,,-1,,,-1,-1,-1,-1,-1,"4,5",0,5,1,"The implementation of `putStringForUser` method has changed in the argument passed to `call` method of `IContentProvider` interface. In the early version, it only passes three arguments to `call` method and in the late version, it passes four arguments to `call` method.","The change in the argument passed to `call` method can cause compatibility issue as the late version is passing an extra argument. If the implementation of `call` method in the dependent API is not compatible with the extra argument passed, it can lead to potential different return values or types, resulting in a compatibility issue."
120,<android.hardware.camera2.CameraManager: CameraCharacteristics getCameraCharacteristics(String)>,29,30,<android.hardware.camera2.CameraManager: CameraCharacteristics getCameraCharacteristics(String)>,<android.hardware.camera2.CameraManager: CameraCharacteristics getCameraCharacteristics(String)>,0,"{
    CameraCharacteristics characteristics = null;
    if (CameraManagerGlobal.sCameraServiceDisabled) {
        throw new IllegalArgumentException(""No cameras available on device"");
    }
    synchronized (mLock) {
        /*
             * Get the camera characteristics from the camera service directly if it supports it,
             * otherwise get them from the legacy shim instead.
             */
        ICameraService cameraService = CameraManagerGlobal.get().getCameraService();
        if (cameraService == null) {
            throw new CameraAccessException(CameraAccessException.CAMERA_DISCONNECTED, ""Camera service is currently unavailable"");
        }
        try {
            Size displaySize = getDisplaySize();
            // exception in case cameraId is a hidden physical camera.
            if (!isHiddenPhysicalCamera(cameraId) && !supportsCamera2ApiLocked(cameraId)) {
                // Legacy backwards compatibility path; build static info from the camera
                // parameters
                int id = Integer.parseInt(cameraId);
                String parameters = cameraService.getLegacyParameters(id);
                CameraInfo info = cameraService.getCameraInfo(id);
                characteristics = LegacyMetadataMapper.createCharacteristics(parameters, info, id, displaySize);
            } else {
                // Normal path: Get the camera characteristics directly from the camera service
                CameraMetadataNative info = cameraService.getCameraCharacteristics(cameraId);
                try {
                    info.setCameraId(Integer.parseInt(cameraId));
                } catch (NumberFormatException e) {
                    Log.e(TAG, ""Failed to parse camera Id "" + cameraId + "" to integer"");
                }
                info.setDisplaySize(displaySize);
                characteristics = new CameraCharacteristics(info);
            }
        } catch (ServiceSpecificException e) {
            throwAsPublicException(e);
        } catch (RemoteException e) {
            // Camera service died - act as if the camera was disconnected
            throw new CameraAccessException(CameraAccessException.CAMERA_DISCONNECTED, ""Camera service is currently unavailable"", e);
        }
    }
    return characteristics;
}","{
    CameraCharacteristics characteristics = null;
    if (CameraManagerGlobal.sCameraServiceDisabled) {
        throw new IllegalArgumentException(""No cameras available on device"");
    }
    synchronized (mLock) {
        /*
             * Get the camera characteristics from the camera service directly if it supports it,
             * otherwise get them from the legacy shim instead.
             */
        ICameraService cameraService = CameraManagerGlobal.get().getCameraService();
        if (cameraService == null) {
            throw new CameraAccessException(CameraAccessException.CAMERA_DISCONNECTED, ""Camera service is currently unavailable"");
        }
        try {
            Size displaySize = getDisplaySize();
            // exception in case cameraId is a hidden physical camera.
            if (!isHiddenPhysicalCamera(cameraId) && !supportsCamera2ApiLocked(cameraId)) {
                // Legacy backwards compatibility path; build static info from the camera
                // parameters
                int id = Integer.parseInt(cameraId);
                String parameters = cameraService.getLegacyParameters(id);
                CameraInfo info = cameraService.getCameraInfo(id);
                characteristics = LegacyMetadataMapper.createCharacteristics(parameters, info, id, displaySize);
            } else {
                // Normal path: Get the camera characteristics directly from the camera service
                CameraMetadataNative info = cameraService.getCameraCharacteristics(cameraId);
                try {
                    info.setCameraId(Integer.parseInt(cameraId));
                } catch (NumberFormatException e) {
                    // For external camera, reaching here is expected.
                    Log.v(TAG, ""Failed to parse camera Id "" + cameraId + "" to integer"");
                }
                boolean hasConcurrentStreams = CameraManagerGlobal.get().cameraIdHasConcurrentStreamsLocked(cameraId);
                info.setHasMandatoryConcurrentStreams(hasConcurrentStreams);
                info.setDisplaySize(displaySize);
                characteristics = new CameraCharacteristics(info);
            }
        } catch (ServiceSpecificException e) {
            throwAsPublicException(e);
        } catch (RemoteException e) {
            // Camera service died - act as if the camera was disconnected
            throw new CameraAccessException(CameraAccessException.CAMERA_DISCONNECTED, ""Camera service is currently unavailable"", e);
        }
    }
    return characteristics;
}",1,"/**
 * <p>Query the capabilities of a camera device. These capabilities are
 * immutable for a given camera.</p>
 *
 * <p>From API level 29, this function can also be used to query the capabilities of physical
 * cameras that can only be used as part of logical multi-camera. These cameras cannot be
 * opened directly via {@link #openCamera}</p>
 *
 * @param cameraId The id of the camera device to query. This could be either a standalone
 * camera ID which can be directly opened by {@link #openCamera}, or a physical camera ID that
 * can only used as part of a logical multi-camera.
 * @return The properties of the given camera
 *
 * @throws IllegalArgumentException if the cameraId does not match any
 * known camera device.
 * @throws CameraAccessException if the camera device has been disconnected.
 *
 * @see #getCameraIdList
 * @see android.app.admin.DevicePolicyManager#setCameraDisabled
 */
","/**
 * <p>Query the capabilities of a camera device. These capabilities are
 * immutable for a given camera.</p>
 *
 * <p>From API level 29, this function can also be used to query the capabilities of physical
 * cameras that can only be used as part of logical multi-camera. These cameras cannot be
 * opened directly via {@link #openCamera}</p>
 *
 * <p>Also starting with API level 29, while most basic camera information is still available
 * even without the CAMERA permission, some values are not available to apps that do not hold
 * that permission. The keys not available are listed by
 * {@link CameraCharacteristics#getKeysNeedingPermission}.</p>
 *
 * @param cameraId The id of the camera device to query. This could be either a standalone
 * camera ID which can be directly opened by {@link #openCamera}, or a physical camera ID that
 * can only used as part of a logical multi-camera.
 * @return The properties of the given camera
 *
 * @throws IllegalArgumentException if the cameraId does not match any
 * known camera device.
 * @throws CameraAccessException if the camera device has been disconnected.
 *
 * @see #getCameraIdList
 * @see android.app.admin.DevicePolicyManager#setCameraDisabled
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,4,0,5,1,"A new boolean variable 'hasConcurrentStreams' is introduced, and the statement 'info.setHasMandatoryConcurrentStreams(hasConcurrentStreams)' is also added. This change does not fall into the categories of return statement, exception handling statement, and control dependency. Thus, the code change type is 5.","As the new variable 'hasConcurrentStreams' is used to set the value of 'info', which is then used to construct the 'characteristics' object, the value of 'characteristics' could be different in the late version, leading to a potential Compatibility Issue. The CI type is 1."
851,<android.accounts.AccountManager: AuthenticatorDescription[] getAuthenticatorTypes()>,29,30,<android.accounts.AccountManager: AuthenticatorDescription[] getAuthenticatorTypes()>,<android.accounts.AccountManager: AuthenticatorDescription[] getAuthenticatorTypes()>,0,"{
    try {
        return mService.getAuthenticatorTypes(UserHandle.getCallingUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    return getAuthenticatorTypesAsUser(mContext.getUserId());
}",1,"/**
 * Lists the currently registered authenticators.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>No permission is required to call this method.
 *
 * @return An array of {@link AuthenticatorDescription} for every
 * authenticator known to the AccountManager service.  Empty (never
 * null) if no authenticators are known.
 */
","/**
 * Lists the currently registered authenticators.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>No permission is required to call this method.
 *
 * @return An array of {@link AuthenticatorDescription} for every
 * authenticator known to the AccountManager service.  Empty (never
 * null) if no authenticators are known.
 */
",-1,,[@UserHandleAware],-1,-1,-1,-1,-1,"1,2,4,5","1,2","1,5",1,"The method implementation of the late version has changed from using the 'mService' object to using the 'getAuthenticatorTypesAsUser' method with 'mContext.getUserId()' as parameter. This leads to a different way of getting the AuthenticatorDescription array, and thus the change type is 1,5.","The change in implementation could lead to different return values of AuthenticatorDescription array, as the late version method uses different way to get the array. Therefore, the CI type is 1."
541,<android.widget.TextView: int getImeActionId()>,15,16,<android.widget.TextView: int getImeActionId()>,<android.widget.TextView: int getImeActionId()>,0,"{
    return mInputContentType != null ? mInputContentType.imeActionId : 0;
}","{
    return mEditor != null && mEditor.mInputContentType != null ? mEditor.mInputContentType.imeActionId : 0;
}",1,"/**
 * Get the IME action ID previous set with {@link #setImeActionLabel}.
 *
 * @see #setImeActionLabel
 * @see android.view.inputmethod.EditorInfo
 */
","/**
 * Get the IME action ID previous set with {@link #setImeActionLabel}.
 *
 * @see #setImeActionLabel
 * @see android.view.inputmethod.EditorInfo
 */
",-1,,,-1,-1,-1,-1,-1,"1,3",1,"1,3",1,"The code change type is 1,3 because the return statement has changed and the control dependency has changed. The return statement has changed from returning the value of `mInputContentType.imeActionId` to returning the value of `mEditor.mInputContentType.imeActionId` if `mEditor` is not null. The control dependency has changed by adding a null check for `mEditor` using the logical AND operator (`&&`).","The compatibility issue type is 1 because the return value of the method could potentially be different between the two versions. In the early version, the method returns the value of `mInputContentType.imeActionId` if `mInputContentType` is not null. However, in the late version, the method returns the value of `mEditor.mInputContentType.imeActionId` if `mEditor` is not null and `mEditor.mInputContentType` is not null. This means that if `mEditor` is null, the method will return 0 in the late version, but in the early version, it will still return the value of `mInputContentType.imeActionId`. This difference in behavior could lead to compatibility issues."
137,<android.permission.PermissionManager.SplitPermissionInfo: int getTargetSdk()>,29,30,<android.permission.PermissionManager.SplitPermissionInfo: int getTargetSdk()>,<android.permission.PermissionManager.SplitPermissionInfo: int getTargetSdk()>,0,"{
    return mTargetSdk;
}","{
    return mSplitPermissionInfoParcelable.getTargetSdk();
}",1,"/**
 * Get the target API level when the permission was split.
 */
","/**
 * Get the target API level when the permission was split.
 */
",-1,,,-1,-1,-1,-1,-1,"1,4",1,"1, 5",1,The return statement has changed from returning the value of the `mTargetSdk` field directly to calling the `getTargetSdk()` method of the `mSplitPermissionInfoParcelable` object. This change implies that the implementation of the method has been modified to depend on another API.,The change in the return statement could potentially lead to different behavior because the value returned by `mSplitPermissionInfoParcelable.getTargetSdk()` might not be the same as the value of `mTargetSdk`. This could result in a compatibility issue caused by potential different return values.
323,<android.bluetooth.BluetoothAdapter: String getName()>,16,17,<android.bluetooth.BluetoothAdapter: String getName()>,<android.bluetooth.BluetoothAdapter: String getName()>,0,"{
    try {
        return mService.getName();
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return null;
}","{
    try {
        return mManagerService.getName();
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return null;
}",1,"/**
 * Get the friendly Bluetooth name of the local Bluetooth adapter.
 * <p>This name is visible to remote Bluetooth devices.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
 *
 * @return the Bluetooth name, or null on error
 */
","/**
 * Get the friendly Bluetooth name of the local Bluetooth adapter.
 * <p>This name is visible to remote Bluetooth devices.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
 *
 * @return the Bluetooth name, or null on error
 */
",-1,,,-1,-1,-1,-1,-1,"1,5",1,5,1,"The name of the dependent API has changed from mService to mManagerService, which falls under the category of dependent API changed (5).","As the name of the dependent API has changed, the behavior of the API could potentially be affected. This may result in the API returning a different value, leading to a compatibility issue (1)."
683,<android.app.admin.DevicePolicyManager: boolean getCameraDisabled(ComponentName)>,23,24,<android.app.admin.DevicePolicyManager: boolean getCameraDisabled(ComponentName)>,<android.app.admin.DevicePolicyManager: boolean getCameraDisabled(ComponentName)>,0,"{
    return getCameraDisabled(admin, UserHandle.myUserId());
}","{
    throwIfParentInstance(""getCameraDisabled"");
    return getCameraDisabled(admin, myUserId());
}",1,"/**
 * Determine whether or not the device's cameras have been disabled for this user,
 * either by the current admin, if specified, or all admins.
 * @param admin The name of the admin component to check, or {@code null} to check whether any admins
 * have disabled the camera
 */
","/**
 * Determine whether or not the device's cameras have been disabled for this user,
 * either by the calling admin, if specified, or all admins.
 * @param admin The name of the admin component to check, or {@code null} to check whether any admins
 * have disabled the camera
 */
",-1,,,-1,-1,-1,-1,-1,"2,4,5",2,"1,5",1,"The early implementation of the method directly calls `getCameraDisabled(ComponentName,int)` while the late implementation added a method call `throwIfParentInstance(""getCameraDisabled"")` before that, which checks if the current instance is an instance of the parent class, and if so, it throws an exception. Additionally, the parameter of the `getCameraDisabled` method has changed from `UserHandle.myUserId()` to `myUserId()`.","The added exception handling statement can potentially cause the API to throw a different exception, leading to a Compatibility Issue (CI) of type 1. The change in the parameter of `getCameraDisabled` method can also potentially cause the API to return a different value, leading to CI of type 1."
1288,"<android.app.ContextImpl: void revokeUriPermission(Uri,int)>",23,24,"<android.app.ContextImpl: void revokeUriPermission(Uri,int)>","<android.app.ContextImpl: void revokeUriPermission(Uri,int)>",0,"{
    try {
        ActivityManagerNative.getDefault().revokeUriPermission(mMainThread.getApplicationThread(), ContentProvider.getUriWithoutUserId(uri), modeFlags, resolveUserId(uri));
    } catch (RemoteException e) {
    }
}","{
    try {
        ActivityManagerNative.getDefault().revokeUriPermission(mMainThread.getApplicationThread(), ContentProvider.getUriWithoutUserId(uri), modeFlags, resolveUserId(uri));
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,2,2,2,2,A new exception handling statement (throw e.rethrowFromSystemServer()) has been introduced in the late version.,"The introduced exception handling statement could lead to different exception behaviours when the late version API is invoked, thus it is a Compatibility Issue caused by potential different exception handlings."
348,<android.webkit.LoadListener: boolean handleSslErrorRequest(SslError)>,4,5,<android.webkit.LoadListener: boolean handleSslErrorRequest(SslError)>,<android.webkit.LoadListener: boolean handleSslErrorRequest(SslError)>,0,"{
    if (WebView.LOGV_ENABLED) {
        Log.v(LOGTAG, ""LoadListener.handleSslErrorRequest(): url:"" + url() + "" primary error: "" + error.getPrimaryError() + "" certificate: "" + error.getCertificate());
    }
    sendMessageInternal(obtainMessage(MSG_SSL_ERROR, error));
    // to unblock the network thread.
    if (!mCancelled) {
        mSslErrorRequestHandle = mRequestHandle;
    }
    return !mCancelled;
}","{
    if (DebugFlags.LOAD_LISTENER) {
        Log.v(LOGTAG, ""LoadListener.handleSslErrorRequest(): url:"" + url() + "" primary error: "" + error.getPrimaryError() + "" certificate: "" + error.getCertificate());
    }
    // will prevent waiting for an already available answer.
    if (Network.getInstance(mContext).checkSslPrefTable(this, error)) {
        return true;
    }
    // deadlock. Just bail on the request.
    if (isSynchronous()) {
        mRequestHandle.handleSslErrorResponse(false);
        return true;
    }
    sendMessageInternal(obtainMessage(MSG_SSL_ERROR, error));
    // to unblock the network thread.
    if (!mCancelled) {
        mSslErrorRequestHandle = mRequestHandle;
    }
    return !mCancelled;
}",1,"/**
 * SSL certificate error callback. Handles SSL error(s) on the way up
 * to the user.
 * IMPORTANT: as this is called from network thread, can't call native
 * directly
 */
","/**
 * SSL certificate error callback. Handles SSL error(s) on the way up
 * to the user.
 * IMPORTANT: as this is called from network thread, can't call native
 * directly
 */
",-1,,,-1,-1,-1,-1,-1,"3,4",1,"1, 2, 3, 4",1,The code change includes:,2. Exception handling statement changed: No change in exception handling.
297,"<android.pim.vcard.VCardUtils: String constructNameFromElements(int,String,String,String,String,String)>",7,8,"<android.pim.vcard.VCardUtils: String constructNameFromElements(int,String,String,String,String,String)>","<android.pim.vcard.VCardUtils: String constructNameFromElements(int,String,String,String,String,String)>",0,"{
    StringBuilder builder = new StringBuilder();
    String[] nameList = sortNameElements(nameOrderType, familyName, middleName, givenName);
    boolean first = true;
    if (!TextUtils.isEmpty(prefix)) {
        first = false;
        builder.append(prefix);
    }
    for (String namePart : nameList) {
        if (!TextUtils.isEmpty(namePart)) {
            if (first) {
                first = false;
            } else {
                builder.append(' ');
            }
            builder.append(namePart);
        }
    }
    if (!TextUtils.isEmpty(suffix)) {
        if (!first) {
            builder.append(' ');
        }
        builder.append(suffix);
    }
    return builder.toString();
}","{
    final StringBuilder builder = new StringBuilder();
    final String[] nameList = sortNameElements(vcardType, familyName, middleName, givenName);
    boolean first = true;
    if (!TextUtils.isEmpty(prefix)) {
        first = false;
        builder.append(prefix);
    }
    for (final String namePart : nameList) {
        if (!TextUtils.isEmpty(namePart)) {
            if (first) {
                first = false;
            } else {
                builder.append(' ');
            }
            builder.append(namePart);
        }
    }
    if (!TextUtils.isEmpty(suffix)) {
        if (!first) {
            builder.append(' ');
        }
        builder.append(suffix);
    }
    return builder.toString();
}",1,,,-1,,,-1,-1,-1,-1,-1,"4,5",1,3,1,"The first parameter of the method sortNameElements() has changed from nameOrderType to vcardType, which is a Dependent API change.","As the first parameter of sortNameElements() has changed, it can lead to a different sorting order of nameList, and consequently, builder.toString() may return different values in the late version. Therefore, it is a Compatibility Issue caused by potential different return values."
147,<android.widget.TextView: float getLeftFadingEdgeStrength()>,18,19,<android.widget.TextView: float getLeftFadingEdgeStrength()>,<android.widget.TextView: float getLeftFadingEdgeStrength()>,0,"{
    if (mEllipsize == TextUtils.TruncateAt.MARQUEE && mMarqueeFadeMode != MARQUEE_FADE_SWITCH_SHOW_ELLIPSIS) {
        if (mMarquee != null && !mMarquee.isStopped()) {
            final Marquee marquee = mMarquee;
            if (marquee.shouldDrawLeftFade()) {
                final float scroll = marquee.getScroll();
                return scroll / getHorizontalFadingEdgeLength();
            } else {
                return 0.0f;
            }
        } else if (getLineCount() == 1) {
            final int layoutDirection = getLayoutDirection();
            final int absoluteGravity = Gravity.getAbsoluteGravity(mGravity, layoutDirection);
            switch(absoluteGravity & Gravity.HORIZONTAL_GRAVITY_MASK) {
                case Gravity.LEFT:
                    return 0.0f;
                case Gravity.RIGHT:
                    return (mLayout.getLineRight(0) - (mRight - mLeft) - getCompoundPaddingLeft() - getCompoundPaddingRight() - mLayout.getLineLeft(0)) / getHorizontalFadingEdgeLength();
                case Gravity.CENTER_HORIZONTAL:
                    return 0.0f;
            }
        }
    }
    return super.getLeftFadingEdgeStrength();
}","{
    if (mEllipsize == TextUtils.TruncateAt.MARQUEE && mMarqueeFadeMode != MARQUEE_FADE_SWITCH_SHOW_ELLIPSIS) {
        if (mMarquee != null && !mMarquee.isStopped()) {
            final Marquee marquee = mMarquee;
            if (marquee.shouldDrawLeftFade()) {
                final float scroll = marquee.getScroll();
                return scroll / getHorizontalFadingEdgeLength();
            } else {
                return 0.0f;
            }
        } else if (getLineCount() == 1) {
            final int layoutDirection = getLayoutDirection();
            final int absoluteGravity = Gravity.getAbsoluteGravity(mGravity, layoutDirection);
            switch(absoluteGravity & Gravity.HORIZONTAL_GRAVITY_MASK) {
                case Gravity.LEFT:
                    return 0.0f;
                case Gravity.RIGHT:
                    return (mLayout.getLineRight(0) - (mRight - mLeft) - getCompoundPaddingLeft() - getCompoundPaddingRight() - mLayout.getLineLeft(0)) / getHorizontalFadingEdgeLength();
                case Gravity.CENTER_HORIZONTAL:
                case Gravity.FILL_HORIZONTAL:
                    final int textDirection = mLayout.getParagraphDirection(0);
                    if (textDirection == Layout.DIR_LEFT_TO_RIGHT) {
                        return 0.0f;
                    } else {
                        return (mLayout.getLineRight(0) - (mRight - mLeft) - getCompoundPaddingLeft() - getCompoundPaddingRight() - mLayout.getLineLeft(0)) / getHorizontalFadingEdgeLength();
                    }
            }
        }
    }
    return super.getLeftFadingEdgeStrength();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,"1,3,4",1,3,1,"The code change is in the control dependency section. Specifically, a new case `Gravity.FILL_HORIZONTAL` has been added in the `switch` statement and an additional `if` condition has been introduced to check the text direction.","The new case and the additional `if` condition inside the `switch` statement can potentially cause the method to return a different value, which means a Compatibility Issue could arise. The method may return 0.0f for certain cases in the early version, while in the late version, it may return a different value based on the calculation in the `else` clause of the new `if` condition."
615,"<android.webkit.CallbackProxy: void onTooManyRedirects(Message,Message)>",7,8,"<android.webkit.CallbackProxy: void onTooManyRedirects(Message,Message)>","<android.webkit.CallbackProxy: void onTooManyRedirects(Message,Message)>",0,"{
    // been set.
    if (mWebViewClient == null) {
        cancelMsg.sendToTarget();
        return;
    }
    Message msg = obtainMessage(TOO_MANY_REDIRECTS);
    Bundle bundle = msg.getData();
    bundle.putParcelable(""cancelMsg"", cancelMsg);
    bundle.putParcelable(""continueMsg"", continueMsg);
    sendMessage(msg);
}","{
// deprecated.
}",1,,"// party of the public classes, we cannot remove this method.
",-1,,,-1,-1,-1,-1,-1,4,1,5,1,"The whole implementation of the method has been removed, so it is considered as a dependent API changed.","Since the implementation has been removed, the API will return nothing, which is different from the early version. Therefore, it is a Compatibility Issue caused by potential different return values or types."
209,<android.content.Intent: String toUri(int)>,21,22,<android.content.Intent: String toUri(int)>,<android.content.Intent: String toUri(int)>,0,"{
    StringBuilder uri = new StringBuilder(128);
    String scheme = null;
    if (mData != null) {
        String data = mData.toString();
        if ((flags & URI_INTENT_SCHEME) != 0) {
            final int N = data.length();
            for (int i = 0; i < N; i++) {
                char c = data.charAt(i);
                if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '-') {
                    continue;
                }
                if (c == ':' && i > 0) {
                    // Valid scheme.
                    scheme = data.substring(0, i);
                    uri.append(""intent:"");
                    data = data.substring(i + 1);
                    break;
                }
                // No scheme.
                break;
            }
        }
        uri.append(data);
    } else if ((flags & URI_INTENT_SCHEME) != 0) {
        uri.append(""intent:"");
    }
    uri.append(""#Intent;"");
    toUriInner(uri, scheme, flags);
    if (mSelector != null) {
        uri.append(""SEL;"");
        // Note that for now we are not going to try to handle the
        // data part; not clear how to represent this as a URI, and
        // not much utility in it.
        mSelector.toUriInner(uri, null, flags);
    }
    uri.append(""end"");
    return uri.toString();
}","{
    StringBuilder uri = new StringBuilder(128);
    if ((flags & URI_ANDROID_APP_SCHEME) != 0) {
        if (mPackage == null) {
            throw new IllegalArgumentException(""Intent must include an explicit package name to build an android-app: "" + this);
        }
        uri.append(""android-app://"");
        uri.append(mPackage);
        String scheme = null;
        if (mData != null) {
            scheme = mData.getScheme();
            if (scheme != null) {
                uri.append('/');
                uri.append(scheme);
                String authority = mData.getEncodedAuthority();
                if (authority != null) {
                    uri.append('/');
                    uri.append(authority);
                    String path = mData.getEncodedPath();
                    if (path != null) {
                        uri.append(path);
                    }
                    String queryParams = mData.getEncodedQuery();
                    if (queryParams != null) {
                        uri.append('?');
                        uri.append(queryParams);
                    }
                    String fragment = mData.getEncodedFragment();
                    if (fragment != null) {
                        uri.append('#');
                        uri.append(fragment);
                    }
                }
            }
        }
        toUriFragment(uri, null, scheme == null ? Intent.ACTION_MAIN : Intent.ACTION_VIEW, mPackage, flags);
        return uri.toString();
    }
    String scheme = null;
    if (mData != null) {
        String data = mData.toString();
        if ((flags & URI_INTENT_SCHEME) != 0) {
            final int N = data.length();
            for (int i = 0; i < N; i++) {
                char c = data.charAt(i);
                if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '-') {
                    continue;
                }
                if (c == ':' && i > 0) {
                    // Valid scheme.
                    scheme = data.substring(0, i);
                    uri.append(""intent:"");
                    data = data.substring(i + 1);
                    break;
                }
                // No scheme.
                break;
            }
        }
        uri.append(data);
    } else if ((flags & URI_INTENT_SCHEME) != 0) {
        uri.append(""intent:"");
    }
    toUriFragment(uri, scheme, Intent.ACTION_VIEW, null, flags);
    return uri.toString();
}",1,"/**
 * Convert this Intent into a String holding a URI representation of it.
 * The returned URI string has been properly URI encoded, so it can be
 * used with {@link Uri#parse Uri.parse(String)}.  The URI contains the
 * Intent's data as the base URI, with an additional fragment describing
 * the action, categories, type, flags, package, component, and extras.
 *
 * <p>You can convert the returned string back to an Intent with
 * {@link #getIntent}.
 *
 * @param flags Additional operating flags.  Either 0 or
 * {@link #URI_INTENT_SCHEME}.
 *
 * @return Returns a URI encoding URI string describing the entire contents
 * of the Intent.
 */
","/**
 * Convert this Intent into a String holding a URI representation of it.
 * The returned URI string has been properly URI encoded, so it can be
 * used with {@link Uri#parse Uri.parse(String)}.  The URI contains the
 * Intent's data as the base URI, with an additional fragment describing
 * the action, categories, type, flags, package, component, and extras.
 *
 * <p>You can convert the returned string back to an Intent with
 * {@link #getIntent}.
 *
 * @param flags Additional operating flags.  Either 0,
 * {@link #URI_INTENT_SCHEME}, or {@link #URI_ANDROID_APP_SCHEME}.
 *
 * @return Returns a URI encoding URI string describing the entire contents
 * of the Intent.
 */
",-1,,,-1,-1,-1,-1,-1,"1,3,4",1,"1,5",1,"The late version implementation added a new control dependency, which is an if-statement starting with ""(flags & URI_ANDROID_APP_SCHEME) != 0"". This new control dependency leads to a different execution flow, and thus the API potentially returns a different value.","The new control dependency added in the late version implementation can lead to different return values. For instance, if the flag variable has the URI_ANDROID_APP_SCHEME flag set, the late version API will return a different value from the early version API. Therefore, a compatibility issue arises, and the CI type is 1."
178,"<android.hardware.Sensor: int getMaxLengthValuesArray(Sensor,int)>",18,19,"<android.hardware.Sensor: int getMaxLengthValuesArray(Sensor,int)>","<android.hardware.Sensor: int getMaxLengthValuesArray(Sensor,int)>",0,"{
    // mType starts from offset 1.
    int len = sMaxLengthValuesArray[sensor.mType - 1];
    // Set it to 3 for backward compatibility.
    if (sensor.getType() == Sensor.TYPE_ROTATION_VECTOR && sdkLevel <= Build.VERSION_CODES.JELLY_BEAN_MR1) {
        len = 3;
    }
    return len;
}","{
    int type = sensor.mType;
    // Set it to 3 for backward compatibility.
    if (type == Sensor.TYPE_ROTATION_VECTOR && sdkLevel <= Build.VERSION_CODES.JELLY_BEAN_MR1) {
        return 3;
    }
    int offset = type * 2 + 1;
    if (offset >= sSensorReportingModes.length) {
        // sensor
        return 16;
    }
    return sSensorReportingModes[offset];
}",1,,,-1,,,-1,-1,-1,-1,-1,"1,3,4",1,"1,3,5",1,"The implementation of the API has changed significantly. Instead of using the `sMaxLengthValuesArray` array to get the length, the late version API uses the `sensor.mType` and `sSensorReportingModes` array to calculate the length. Additionally, the condition statement inside the 'if' statement has changed, which potentially leads to a different return value. The dependent API has also changed, which is `sMaxLengthValuesArray` in the early version and `sSensorReportingModes` in the late version.","The change in the calculation of the length and the dependent API could lead to a different return value. Therefore, the CI type is 1."
666,<android.view.ScaleGestureDetector: float getCurrentSpanX()>,16,17,<android.view.ScaleGestureDetector: float getCurrentSpanX()>,<android.view.ScaleGestureDetector: float getCurrentSpanX()>,0,"{
    return mCurrFingerDiffX;
}","{
    return mCurrSpanX;
}",1,"/**
 * Return the current x distance between the two pointers forming the
 * gesture in progress.
 *
 * @return Distance between pointers in pixels.
 */
","/**
 * Return the average X distance between each of the pointers forming the
 * gesture in progress through the focal point.
 *
 * @return Distance between pointers in pixels.
 */
",-1,,,-1,-1,-1,-1,-1,"1,4",1,1,1,"The return statement has changed from mCurrFingerDiffX to mCurrSpanX, so the code change type is 1.","The change of return statement will make the API potentially return a different value, so the CI type is 1."
1077,<android.hardware.camera2.legacy.LegacyCameraDevice: int detectSurfaceType(Surface)>,25,26,<android.hardware.camera2.legacy.LegacyCameraDevice: int detectSurfaceType(Surface)>,<android.hardware.camera2.legacy.LegacyCameraDevice: int detectSurfaceType(Surface)>,0,"{
    checkNotNull(surface);
    return LegacyExceptionUtils.throwOnError(nativeDetectSurfaceType(surface));
}","{
    checkNotNull(surface);
    int surfaceType = nativeDetectSurfaceType(surface);
    // ImageFormat.PRIVATE. b/9487482
    if ((surfaceType >= LegacyMetadataMapper.HAL_PIXEL_FORMAT_RGBA_8888 && surfaceType <= LegacyMetadataMapper.HAL_PIXEL_FORMAT_BGRA_8888)) {
        surfaceType = ImageFormat.PRIVATE;
    }
    return LegacyExceptionUtils.throwOnError(surfaceType);
}",1,"/**
 * Query the surface for its currently configured format
 */
","/**
 * Query the surface for its currently configured format
 */
",-1,,,-1,-1,-1,-1,-1,"1,3,4",1,"1,5",1,"The return statement has changed from return LegacyExceptionUtils.throwOnError(nativeDetectSurfaceType(surface)) to return LegacyExceptionUtils.throwOnError(surfaceType), after an if-statement has been added to modify the value of surfaceType, and the method nativeDetectSurfaceType(surface) has undergone a new dependent API change, so the code change type is 1,5.","The added if-statement and the new dependent API change may cause the API to return a different value, so the CI type is 1."
668,"<android.app.PendingIntent: PendingIntent getService(Context,int,Intent,int)>",16,17,"<android.app.PendingIntent: PendingIntent getService(Context,int,Intent,int)>","<android.app.PendingIntent: PendingIntent getService(Context,int,Intent,int)>",0,"{
    String packageName = context.getPackageName();
    String resolvedType = intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
    try {
        intent.setAllowFds(false);
        IIntentSender target = ActivityManagerNative.getDefault().getIntentSender(ActivityManager.INTENT_SENDER_SERVICE, packageName, null, null, requestCode, new Intent[] { intent }, resolvedType != null ? new String[] { resolvedType } : null, flags, null);
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
    }
    return null;
}","{
    String packageName = context.getPackageName();
    String resolvedType = intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
    try {
        intent.setAllowFds(false);
        IIntentSender target = ActivityManagerNative.getDefault().getIntentSender(ActivityManager.INTENT_SENDER_SERVICE, packageName, null, null, requestCode, new Intent[] { intent }, resolvedType != null ? new String[] { resolvedType } : null, flags, null, UserHandle.myUserId());
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
    }
    return null;
}",1,"/**
 * Retrieve a PendingIntent that will start a service, like calling
 * {@link Context#startService Context.startService()}.  The start
 * arguments given to the service will come from the extras of the Intent.
 *
 * @param context The Context in which this PendingIntent should start
 * the service.
 * @param requestCode Private request code for the sender (currently
 * not used).
 * @param intent An Intent describing the service to be started.
 * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},
 * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},
 * or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been
 * supplied.
 */
","/**
 * Retrieve a PendingIntent that will start a service, like calling
 * {@link Context#startService Context.startService()}.  The start
 * arguments given to the service will come from the extras of the Intent.
 *
 * @param context The Context in which this PendingIntent should start
 * the service.
 * @param requestCode Private request code for the sender (currently
 * not used).
 * @param intent An Intent describing the service to be started.
 * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},
 * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},
 * or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been
 * supplied.
 */
",-1,,,-1,-1,-1,-1,-1,"4,5",1,5,1,"A new parameter (UserHandle.myUserId()) is added in the call to ""ActivityManagerNative.getDefault().getIntentSender()"", so the code change type is 5.","As a new parameter has been added, the behavior of the getIntentSender() function may change, which could impact the return value of the getService() method, and thus the CI type is 1."
67,<android.os.VibrationAttributes: int hashCode()>,30,31,<android.os.VibrationAttributes: int hashCode()>,<android.os.VibrationAttributes: int hashCode()>,0,"{
    return Objects.hash(mUsage, mFlags);
}","{
    return Objects.hash(mUsage, mOriginalAudioUsage, mFlags);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,"1,4,5",1,1,1,The code change between the two versions is that an additional parameter `mOriginalAudioUsage` is added in the calculation of the hash code. This is a return statement change.,"As the hash code calculation involves an additional parameter in the late version, it is highly likely that the hash code generated by the late version will be different from the early version. This will cause compatibility issues as the API potentially returns different values."
192,<android.widget.TextView: int getCompoundPaddingRight()>,22,23,<android.widget.TextView: int getCompoundPaddingRight()>,<android.widget.TextView: int getCompoundPaddingRight()>,0,"{
    final Drawables dr = mDrawables;
    if (dr == null || dr.mDrawableRight == null) {
        return mPaddingRight;
    } else {
        return mPaddingRight + dr.mDrawablePadding + dr.mDrawableSizeRight;
    }
}","{
    final Drawables dr = mDrawables;
    if (dr == null || dr.mShowing[Drawables.RIGHT] == null) {
        return mPaddingRight;
    } else {
        return mPaddingRight + dr.mDrawablePadding + dr.mDrawableSizeRight;
    }
}",1,"/**
 * Returns the right padding of the view, plus space for the right
 * Drawable if any.
 */
","/**
 * Returns the right padding of the view, plus space for the right
 * Drawable if any.
 */
",-1,,,-1,-1,-1,-1,-1,4,0,3,1,"The code change is in the control dependency, specifically the 'if' statement. The condition for the 'if' statement has been changed in the late version.","The change in the 'if' statement condition can cause the API to return different values. In the early version, the API returns mPaddingRight if the right drawable is null. In the late version, the API returns mPaddingRight if the right drawable is not showing. This can potentially cause a compatibility issue as the API can return different values for the same input in different versions."
980,<android.os.PowerManager: boolean isPowerSaveMode()>,23,24,<android.os.PowerManager: boolean isPowerSaveMode()>,<android.os.PowerManager: boolean isPowerSaveMode()>,0,"{
    try {
        return mService.isPowerSaveMode();
    } catch (RemoteException e) {
        return false;
    }
}","{
    try {
        return mService.isPowerSaveMode();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns true if the device is currently in power save mode.  When in this mode,
 * applications should reduce their functionality in order to conserve battery as
 * much as possible.  You can monitor for changes to this state with
 * {@link #ACTION_POWER_SAVE_MODE_CHANGED}.
 *
 * @return Returns true if currently in low power mode, else false.
 */
","/**
 * Returns true if the device is currently in power save mode.  When in this mode,
 * applications should reduce their functionality in order to conserve battery as
 * much as possible.  You can monitor for changes to this state with
 * {@link #ACTION_POWER_SAVE_MODE_CHANGED}.
 *
 * @return Returns true if currently in low power mode, else false.
 */
",-1,,,-1,-1,-1,-1,-1,2,2,"1,2","1,2","The return statement has been removed and a new exception handling statement has been introduced (throw e.rethrowFromSystemServer()), so the code change type is 1,2.","As the removed return statement and introduced exception handling could lead to different bahaviour when the late version API is invoked, thus the CI type is 1,2."
269,"<android.hardware.usb.UsbDeviceConnection: int controlTransfer(int,int,int,int,byte[],int,int)>",17,18,"<android.hardware.usb.UsbDeviceConnection: int controlTransfer(int,int,int,int,byte[],int,int)>","<android.hardware.usb.UsbDeviceConnection: int controlTransfer(int,int,int,int,byte[],int,int)>",0,"{
    return native_control_request(requestType, request, value, index, buffer, length, timeout);
}","{
    return controlTransfer(requestType, request, value, index, buffer, 0, length, timeout);
}",1,"/**
 * Performs a control transaction on endpoint zero for this device.
 * The direction of the transfer is determined by the request type.
 * If requestType & {@link UsbConstants#USB_ENDPOINT_DIR_MASK} is
 * {@link UsbConstants#USB_DIR_OUT}, then the transfer is a write,
 * and if it is {@link UsbConstants#USB_DIR_IN}, then the transfer
 * is a read.
 *
 * @param requestType request type for this transaction
 * @param request request ID for this transaction
 * @param value value field for this transaction
 * @param index index field for this transaction
 * @param buffer buffer for data portion of transaction,
 * or null if no data needs to be sent or received
 * @param length the length of the data to send or receive
 * @param timeout in milliseconds
 * @return length of data transferred (or zero) for success,
 * or negative value for failure
 */
","/**
 * Performs a control transaction on endpoint zero for this device.
 * The direction of the transfer is determined by the request type.
 * If requestType & {@link UsbConstants#USB_ENDPOINT_DIR_MASK} is
 * {@link UsbConstants#USB_DIR_OUT}, then the transfer is a write,
 * and if it is {@link UsbConstants#USB_DIR_IN}, then the transfer
 * is a read.
 * <p>
 * This method transfers data starting from index 0 in the buffer.
 * To specify a different offset, use
 * {@link #controlTransfer(int, int, int, int, byte[], int, int, int)}.
 * </p>
 *
 * @param requestType request type for this transaction
 * @param request request ID for this transaction
 * @param value value field for this transaction
 * @param index index field for this transaction
 * @param buffer buffer for data portion of transaction,
 * or null if no data needs to be sent or received
 * @param length the length of the data to send or receive
 * @param timeout in milliseconds
 * @return length of data transferred (or zero) for success,
 * or negative value for failure
 */
",-1,,,-1,-1,-1,-1,-1,"1,4",1,5,1,The implementation of the method "controlTransfer" has changed from using the native method "native\_control\_request" to using another method "controlTransfer" with a different number of parameters. This change falls under the category of "Dependent API changed" (5).,"The change in the dependent API could potentially lead to different return values or types, as the new method ""controlTransfer"" might behave differently from the previous native method. This is a Compatibility Issue caused by potential different return values or types (1)."
213,"<android.content.ContentResolver: void takePersistableUriPermission(Uri,int)>",27,28,"<android.content.ContentResolver: void takePersistableUriPermission(Uri,int)>","<android.content.ContentResolver: void takePersistableUriPermission(Uri,int)>",0,"{
    Preconditions.checkNotNull(uri, ""uri"");
    try {
        ActivityManager.getService().takePersistableUriPermission(ContentProvider.getUriWithoutUserId(uri), modeFlags, resolveUserId(uri));
    } catch (RemoteException e) {
    }
}","{
    Preconditions.checkNotNull(uri, ""uri"");
    try {
        ActivityManager.getService().takePersistableUriPermission(ContentProvider.getUriWithoutUserId(uri), modeFlags, /* toPackage= */
        null, resolveUserId(uri));
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Take a persistable URI permission grant that has been offered. Once
 * taken, the permission grant will be remembered across device reboots.
 * Only URI permissions granted with
 * {@link Intent#FLAG_GRANT_PERSISTABLE_URI_PERMISSION} can be persisted. If
 * the grant has already been persisted, taking it again will touch
 * {@link UriPermission#getPersistedTime()}.
 *
 * @see #getPersistedUriPermissions()
 */
","/**
 * Take a persistable URI permission grant that has been offered. Once
 * taken, the permission grant will be remembered across device reboots.
 * Only URI permissions granted with
 * {@link Intent#FLAG_GRANT_PERSISTABLE_URI_PERMISSION} can be persisted. If
 * the grant has already been persisted, taking it again will touch
 * {@link UriPermission#getPersistedTime()}.
 *
 * @see #getPersistedUriPermissions()
 */
",-1,,,-1,-1,-1,-1,-1,"2,4,5",2,"2,5",2,The ActivityManager.getService().takePersistableUriPermission() function has a new argument "toPackage= null" and the catch block has changed from an empty catch block to throwing the exception. This falls into the "Dependent API changed" (5) and "Exception handling statement changed" (2) categories.,"The new exception handling in the catch block could lead to a different behavior when the API is invoked, causing a Compatibility Issue, specifically ""Compatibility Issue caused by potential different exception handlings"" (2)."
218,<android.widget.Switch: Mode getThumbTintMode()>,28,29,<android.widget.Switch: Mode getThumbTintMode()>,<android.widget.Switch: Mode getThumbTintMode()>,0,"{
    return mThumbTintMode;
}","{
    BlendMode mode = getThumbTintBlendMode();
    return mode != null ? BlendMode.blendModeToPorterDuffMode(mode) : null;
}",1,"/**
 * @return the blending mode used to apply the tint to the thumb
 * drawable
 * @attr ref android.R.styleable#Switch_thumbTintMode
 * @see #setThumbTintMode(PorterDuff.Mode)
 */
","/**
 * @return the blending mode used to apply the tint to the thumb
 * drawable
 * @attr ref android.R.styleable#Switch_thumbTintMode
 * @see #setThumbTintMode(PorterDuff.Mode)
 */
",-1,[@Nullable],"[@InspectableProperty, @Nullable]",-1,-1,-1,-1,-1,"1,4",1,"1,5",1,"The return statement has changed from returning the value of mThumbTintMode to returning the result of a new method getThumbTintBlendMode(). The return value of getThumbTintBlendMode() is converted and returned, so this is a return statement change. Additionally, the API getThumbTintBlendMode() is a new dependent API in the late version, so this is also a dependent API change.","The change in the return statement could lead to different return values in the two versions. Specifically, the late version API returns the result of a new method getThumbTintBlendMode() after conversion, while the early version returns the value of mThumbTintMode directly. Therefore, the Compatibility Issue is 1 - Compatibility Issue caused by potential different return values or types."
533,"<android.speech.tts.PlaybackSynthesisCallback: int start(int,int,int)>",23,24,"<android.speech.tts.PlaybackSynthesisCallback: int start(int,int,int)>","<android.speech.tts.PlaybackSynthesisCallback: int start(int,int,int)>",0,"{
    if (DBG)
        Log.d(TAG, ""start("" + sampleRateInHz + "","" + audioFormat + "","" + channelCount + "")"");
    int channelConfig = BlockingAudioTrack.getChannelConfig(channelCount);
    synchronized (mStateLock) {
        if (channelConfig == 0) {
            Log.e(TAG, ""Unsupported number of channels :"" + channelCount);
            mStatusCode = TextToSpeech.ERROR_OUTPUT;
            return TextToSpeech.ERROR;
        }
        if (mStatusCode == TextToSpeech.STOPPED) {
            if (DBG)
                Log.d(TAG, ""stop() called before start(), returning."");
            return errorCodeOnStop();
        }
        if (mStatusCode != TextToSpeech.SUCCESS) {
            if (DBG)
                Log.d(TAG, ""Error was raised"");
            return TextToSpeech.ERROR;
        }
        if (mItem != null) {
            Log.e(TAG, ""Start called twice"");
            return TextToSpeech.ERROR;
        }
        SynthesisPlaybackQueueItem item = new SynthesisPlaybackQueueItem(mAudioParams, sampleRateInHz, audioFormat, channelCount, mDispatcher, mCallerIdentity, mLogger);
        mAudioTrackHandler.enqueue(item);
        mItem = item;
    }
    return TextToSpeech.SUCCESS;
}","{
    if (DBG)
        Log.d(TAG, ""start("" + sampleRateInHz + "","" + audioFormat + "","" + channelCount + "")"");
    if (audioFormat != AudioFormat.ENCODING_PCM_8BIT && audioFormat != AudioFormat.ENCODING_PCM_16BIT && audioFormat != AudioFormat.ENCODING_PCM_FLOAT) {
        Log.w(TAG, ""Audio format encoding "" + audioFormat + "" not supported. Please use one "" + ""of AudioFormat.ENCODING_PCM_8BIT, AudioFormat.ENCODING_PCM_16BIT or "" + ""AudioFormat.ENCODING_PCM_FLOAT"");
    }
    mDispatcher.dispatchOnBeginSynthesis(sampleRateInHz, audioFormat, channelCount);
    int channelConfig = BlockingAudioTrack.getChannelConfig(channelCount);
    synchronized (mStateLock) {
        if (channelConfig == 0) {
            Log.e(TAG, ""Unsupported number of channels :"" + channelCount);
            mStatusCode = TextToSpeech.ERROR_OUTPUT;
            return TextToSpeech.ERROR;
        }
        if (mStatusCode == TextToSpeech.STOPPED) {
            if (DBG)
                Log.d(TAG, ""stop() called before start(), returning."");
            return errorCodeOnStop();
        }
        if (mStatusCode != TextToSpeech.SUCCESS) {
            if (DBG)
                Log.d(TAG, ""Error was raised"");
            return TextToSpeech.ERROR;
        }
        if (mItem != null) {
            Log.e(TAG, ""Start called twice"");
            return TextToSpeech.ERROR;
        }
        SynthesisPlaybackQueueItem item = new SynthesisPlaybackQueueItem(mAudioParams, sampleRateInHz, audioFormat, channelCount, mDispatcher, mCallerIdentity, mLogger);
        mAudioTrackHandler.enqueue(item);
        mItem = item;
    }
    return TextToSpeech.SUCCESS;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,"3,4",1,"3,4","1,2","In the late version of the implementation, the code adds a new control dependency to check the `audioFormat` value and logs a warning message if it's not supported. Additionally, a new method call (`mDispatcher.dispatchOnBeginSynthesis`) is introduced. Therefore, the code change is classified as 3 (Control dependency changed) and 4 (Other statement changed).","The added control dependency can cause the API to log a warning message when the `audioFormat` value is not supported. The added method call (`mDispatcher.dispatchOnBeginSynthesis`) could potentially lead to different behaviors when the API is invoked. Therefore, the Compatibility Issue type is 1 (Compatibility Issue caused by potential different return values or types) and 2 (Compatibility Issue caused by potential different exception handlings)."
949,<android.accounts.AccountManager: AuthenticatorDescription[] getAuthenticatorTypes()>,20,21,<android.accounts.AccountManager: AuthenticatorDescription[] getAuthenticatorTypes()>,<android.accounts.AccountManager: AuthenticatorDescription[] getAuthenticatorTypes()>,0,"{
    try {
        return mService.getAuthenticatorTypes();
    } catch (RemoteException e) {
        // will never happen
        throw new RuntimeException(e);
    }
}","{
    try {
        return mService.getAuthenticatorTypes(UserHandle.getCallingUserId());
    } catch (RemoteException e) {
        // will never happen
        throw new RuntimeException(e);
    }
}",1,"/**
 * Lists the currently registered authenticators.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>No permission is required to call this method.
 *
 * @return An array of {@link AuthenticatorDescription} for every
 * authenticator known to the AccountManager service.  Empty (never
 * null) if no authenticators are known.
 */
","/**
 * Lists the currently registered authenticators.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>No permission is required to call this method.
 *
 * @return An array of {@link AuthenticatorDescription} for every
 * authenticator known to the AccountManager service.  Empty (never
 * null) if no authenticators are known.
 */
",-1,,,-1,-1,-1,-1,-1,"1,4,5",-1,5,1,"The method `mService.getAuthenticatorTypes()` has changed to `mService.getAuthenticatorTypes(UserHandle.getCallingUserId())`. This indicates a change in the dependent API, with the introduction of a new parameter in the late version.",The introduction of a new parameter in the dependent API could potentially lead to different return values for the `getAuthenticatorTypes()` method. This is considered a compatibility issue as the API could return different values in the late version.
17,"<android.view.GLES20Canvas: boolean quickReject(Path,EdgeType)>",15,16,"<android.view.GLES20Canvas: boolean quickReject(Path,EdgeType)>","<android.view.GLES20Canvas: boolean quickReject(Path,EdgeType)>",0,"{
    throw new UnsupportedOperationException();
}","{
    path.computeBounds(mPathBounds, true);
    return nQuickReject(mRenderer, mPathBounds.left, mPathBounds.top, mPathBounds.right, mPathBounds.bottom, type.nativeInt);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,"1,2","1,2","1, 5",1,The implementation has changed from throwing an UnsupportedOperationException to calling the `nQuickReject` method. This is a return statement change and a dependent API change.,"The API now performs a computation and returns a boolean value instead of throwing an exception, which could lead to a Compatibility Issue caused by potential different return values or types."
129,"<android.util.Log: int v(String,String)>",7,8,"<android.util.Log: int v(String,String)>","<android.util.Log: int v(String,String)>",0,"{
    return println(VERBOSE, tag, msg);
}","{
    return println_native(LOG_ID_MAIN, VERBOSE, tag, msg);
}",1,"/**
 * Send a {@link #VERBOSE} log message.
 * @param tag Used to identify the source of a log message.  It usually identifies
 * the class or activity where the log call occurs.
 * @param msg The message you would like logged.
 */
","/**
 * Send a {@link #VERBOSE} log message.
 * @param tag Used to identify the source of a log message.  It usually identifies
 * the class or activity where the log call occurs.
 * @param msg The message you would like logged.
 */
",-1,,,-1,-1,-1,-1,-1,"1,4",1,5,1,"The implementation of the method `android.util.Log.v` has changed from calling `println` to `println_native`. This is a change in the dependent API, as it modifies the method used for logging.","The change in the dependent API could lead to a different behavior in the logging mechanism, potentially causing a compatibility issue. Since the return value of the method could be different due to the change in the dependent API, the compatibility issue is classified as type 1."
424,<android.view.autofill.AutofillId: int hashCode()>,28,29,<android.view.autofill.AutofillId: int hashCode()>,<android.view.autofill.AutofillId: int hashCode()>,0,"{
    final int prime = 31;
    int result = 1;
    result = prime * result + mViewId;
    result = prime * result + mVirtualId;
    return result;
}","{
    final int prime = 31;
    int result = 1;
    result = prime * result + mViewId;
    result = prime * result + mVirtualIntId;
    result = prime * result + (int) (mVirtualLongId ^ (mVirtualLongId >>> 32));
    result = prime * result + mSessionId;
    return result;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,"1,4",1,"1, 5",1,"The implementation of the `hashCode()` method has changed between the two versions. Specifically, the variables used in the calculation of the hash code have changed. In the early version, `mVirtualId` is used, while in the late version, `mVirtualIntId`, `mVirtualLongId`, and `mSessionId` are used. This change affects the return value of the method.","This change can lead to a compatibility issue because the hash code calculated by the method may be different between the two versions for the same object. This can cause issues in data structures that rely on hash codes, such as `HashMap` or `HashSet`. For example, an object inserted into a `HashSet` in the early version may not be found in the set after upgrading to the late version. Therefore, the CI type is 1."
741,"<android.bluetooth.BluetoothHidDevice: boolean reportError(BluetoothDevice,byte)>",28,29,"<android.bluetooth.BluetoothHidDevice: boolean reportError(BluetoothDevice,byte)>","<android.bluetooth.BluetoothHidDevice: boolean reportError(BluetoothDevice,byte)>",0,"{
    boolean result = false;
    final IBluetoothHidDevice service = mService;
    if (service != null) {
        try {
            result = service.reportError(device, error);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, ""Proxy not attached to service"");
    }
    return result;
}","{
    boolean result = false;
    final IBluetoothHidDevice service = getService();
    if (service != null) {
        try {
            result = service.reportError(device, error);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, ""Proxy not attached to service"");
    }
    return result;
}",1,"/**
 * Sends error handshake message as reply for invalid SET_REPORT request from {@link
 * Callback#onSetReport(BluetoothDevice, byte, byte, byte[])}.
 *
 * @param error Error to be sent for SET_REPORT via HANDSHAKE.
 * @return true if the command is successfully sent; otherwise false.
 */
","/**
 * Sends error handshake message as reply for invalid SET_REPORT request from {@link
 * Callback#onSetReport(BluetoothDevice, byte, byte, byte[])}.
 *
 * @param error Error to be sent for SET_REPORT via HANDSHAKE.
 * @return true if the command is successfully sent; otherwise false.
 */
",-1,,,-1,-1,-1,-1,-1,4,0,5,0,"The implementation of the method 'getService()' has changed from using the member variable 'mService' to calling a new method 'getService()'. This is a dependent API change, so the code change type is 5.","However, since the returned value of 'getService()' is only used to check whether it is null or not, and the behavior of the method does not change based on the returned value, this code change does not lead to any compatibility issues. Therefore, the CI type is 0."
350,"<android.database.sqlite.SQLiteDatabase: SQLiteDatabase openDatabase(String,CursorFactory,int,DatabaseErrorHandler)>",27,28,"<android.database.sqlite.SQLiteDatabase: SQLiteDatabase openDatabase(String,CursorFactory,int,DatabaseErrorHandler)>","<android.database.sqlite.SQLiteDatabase: SQLiteDatabase openDatabase(String,CursorFactory,int,DatabaseErrorHandler)>",0,"{
    SQLiteDatabase db = new SQLiteDatabase(path, flags, factory, errorHandler, -1, -1, -1);
    db.open();
    return db;
}","{
    SQLiteDatabase db = new SQLiteDatabase(path, flags, factory, errorHandler, -1, -1, -1, null, null);
    db.open();
    return db;
}",1,"/**
 * Open the database according to the flags {@link #OPEN_READWRITE}
 * {@link #OPEN_READONLY} {@link #CREATE_IF_NECESSARY} and/or {@link #NO_LOCALIZED_COLLATORS}.
 *
 * <p>Sets the locale of the database to the  the system's current locale.
 * Call {@link #setLocale} if you would like something else.</p>
 *
 * <p>Accepts input param: a concrete instance of {@link DatabaseErrorHandler} to be
 * used to handle corruption when sqlite reports database corruption.</p>
 *
 * @param path to database file to open and/or create
 * @param factory an optional factory class that is called to instantiate a
 * cursor when query is called, or null for default
 * @param flags to control database access mode
 * @param errorHandler the {@link DatabaseErrorHandler} obj to be used to handle corruption
 * when sqlite reports database corruption
 * @return the newly opened database
 * @throws SQLiteException if the database cannot be opened
 */
","/**
 * Open the database according to the flags {@link #OPEN_READWRITE}
 * {@link #OPEN_READONLY} {@link #CREATE_IF_NECESSARY} and/or {@link #NO_LOCALIZED_COLLATORS}.
 *
 * <p>Sets the locale of the database to the  the system's current locale.
 * Call {@link #setLocale} if you would like something else.</p>
 *
 * <p>Accepts input param: a concrete instance of {@link DatabaseErrorHandler} to be
 * used to handle corruption when sqlite reports database corruption.</p>
 *
 * @param path to database file to open and/or create
 * @param factory an optional factory class that is called to instantiate a
 * cursor when query is called, or null for default
 * @param flags to control database access mode
 * @param errorHandler the {@link DatabaseErrorHandler} obj to be used to handle corruption
 * when sqlite reports database corruption
 * @return the newly opened database
 * @throws SQLiteException if the database cannot be opened
 */
",-1,,,-1,-1,-1,-1,-1,5,0,5,1,"The constructor of SQLiteDatabase has changed, with two additional null parameters added in the late version. Therefore, the change type is 5 (Dependent API changed).","The added parameters in the constructor may lead to the creation of a SQLiteDatabase object with different properties, which could potentially result in different return values or types when the API is called. Therefore, this change could cause a Compatibility Issue of type 1."
571,<android.animation.PropertyValuesHolder.IntPropertyValuesHolder: IntPropertyValuesHolder clone()>,20,21,<android.animation.PropertyValuesHolder.IntPropertyValuesHolder: IntPropertyValuesHolder clone()>,<android.animation.PropertyValuesHolder.IntPropertyValuesHolder: IntPropertyValuesHolder clone()>,0,"{
    IntPropertyValuesHolder newPVH = (IntPropertyValuesHolder) super.clone();
    newPVH.mIntKeyframeSet = (IntKeyframeSet) newPVH.mKeyframeSet;
    return newPVH;
}","{
    IntPropertyValuesHolder newPVH = (IntPropertyValuesHolder) super.clone();
    newPVH.mIntKeyframes = (Keyframes.IntKeyframes) newPVH.mKeyframes;
    return newPVH;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,4,0,5,1,"The implementation of the API has changed from assigning `mIntKeyframeSet` with a value of `(IntKeyframeSet) newPVH.mKeyframeSet` to assigning `mIntKeyframes` with a value of `(Keyframes.IntKeyframes) newPVH.mKeyframes`. This means that the variable being assigned and the type of value being assigned have both changed, which falls under the ""Dependent API changed"" category.","The change in the dependent API could potentially result in different behavior when the `clone()` method is called. Specifically, the returned `IntPropertyValuesHolder` object's `mIntKeyframes` field may now contain different values or types, which could lead to compatibility issues. Therefore, this change falls under the ""Compatibility Issue caused by potential different return values or types"" category."
206,<android.app.SharedPreferencesImpl.EditorImpl: Editor remove(String)>,25,26,<android.app.SharedPreferencesImpl.EditorImpl: Editor remove(String)>,<android.app.SharedPreferencesImpl.EditorImpl: Editor remove(String)>,0,"{
    synchronized (this) {
        mModified.put(key, this);
        return this;
    }
}","{
    synchronized (mLock) {
        mModified.put(key, this);
        return this;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,4,0,4,0,The 'synchronized' block in the late version uses a different object ('mLock') than the early version ('this'). This change falls under 'Other statement changed' category.,"Although the synchronization object has changed, it does not cause a compatibility issue as the return value and exception handling remain the same. The lock object change only affects the thread synchronization mechanism."
1096,<android.speech.SpeechRecognizer: void destroy()>,20,21,<android.speech.SpeechRecognizer: void destroy()>,<android.speech.SpeechRecognizer: void destroy()>,0,"{
    if (mConnection != null) {
        mContext.unbindService(mConnection);
    }
    mPendingTasks.clear();
    mService = null;
    mConnection = null;
    mListener.mInternalListener = null;
}","{
    if (mService != null) {
        try {
            mService.cancel(mListener);
        } catch (final RemoteException e) {
        // Not important
        }
    }
    if (mConnection != null) {
        mContext.unbindService(mConnection);
    }
    mPendingTasks.clear();
    mService = null;
    mConnection = null;
    mListener.mInternalListener = null;
}",1,"/**
 * Destroys the {@code SpeechRecognizer} object.
 */
","/**
 * Destroys the {@code SpeechRecognizer} object.
 */
",-1,,,-1,-1,-1,-1,-1,"2,3,4",2,"1,3",1,"The return statement has not changed, but a new conditional statement and exception handling statement have been introduced. Therefore, the code change type is 1,3.","The new conditional statement and exception handling statement could lead to different behaviours when the late version API is invoked. Specifically, if the condition `mService != null` is true, the `mService.cancel(mListener)` would be executed and potentially leads to a different return value. Therefore, the CI type is 1."
90,<android.widget.RemoteViewsAdapter.FixedSizeRemoteViewsCache: RemoteViewsIndexMetaData getMetaDataAt(int)>,23,24,<android.widget.RemoteViewsAdapter.FixedSizeRemoteViewsCache: RemoteViewsIndexMetaData getMetaDataAt(int)>,<android.widget.RemoteViewsAdapter.FixedSizeRemoteViewsCache: RemoteViewsIndexMetaData getMetaDataAt(int)>,0,"{
    if (mIndexMetaData.containsKey(position)) {
        return mIndexMetaData.get(position);
    }
    return null;
}","{
    return mIndexMetaData.get(position);
}",1,,,-1,,,-1,-1,-1,-1,-1,"1,3",1,1,1,"The implementation of the method has changed, specifically the removal of the if statement that checks if mIndexMetaData contains the key ""position"". The method now directly calls the get method on mIndexMetaData and returns the result, without any null check.","The change in implementation can cause a compatibility issue as the method in the earlier version returned null if the key ""position"" was not present in mIndexMetaData, whereas the method in the later version will throw a NullPointerException in this case. This can lead to different behaviors and cause a compatibility issue."
497,"<android.view.GLES20Canvas: void drawHardwareLayer(HardwareLayer,float,float,Paint)>",16,17,"<android.view.GLES20Canvas: void drawHardwareLayer(HardwareLayer,float,float,Paint)>","<android.view.GLES20Canvas: void drawHardwareLayer(HardwareLayer,float,float,Paint)>",0,"{
    final GLES20Layer glLayer = (GLES20Layer) layer;
    int modifier = paint != null ? setupColorFilter(paint) : MODIFIER_NONE;
    try {
        final int nativePaint = paint == null ? 0 : paint.mNativePaint;
        nDrawLayer(mRenderer, glLayer.getLayer(), x, y, nativePaint);
    } finally {
        if (modifier != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifier);
    }
}","{
    final GLES20Layer glLayer = (GLES20Layer) layer;
    final int nativePaint = paint == null ? 0 : paint.mNativePaint;
    nDrawLayer(mRenderer, glLayer.getLayer(), x, y, nativePaint);
}",1,,,-1,,,-1,-1,-1,-1,-1,"2,3,4",0,"1,3",1,"The implementation of `drawHardwareLayer()` method has changed between version 16 and 17. In particular, the variable `modifier` and its related code have been removed in the late version. This change is related to both return statement (since the `setupColorFilter()` method is removed) and control dependency (since the `finally` block is removed).","The removal of `setupColorFilter()` method in the late version may cause the method to return a different value, which may lead to compatibility issues. Specifically, the `setupColorFilter()` method sets up color filter for the paint object, so its removal may affect the drawing result. As a result, the API may return a different value in the late version, which may cause compatibility issues."
288,"<android.speech.tts.PlaybackSynthesisCallback: int audioAvailable(byte[],int,int)>",15,16,"<android.speech.tts.PlaybackSynthesisCallback: int audioAvailable(byte[],int,int)>","<android.speech.tts.PlaybackSynthesisCallback: int audioAvailable(byte[],int,int)>",0,"{
    if (DBG) {
        Log.d(TAG, ""audioAvailable(byte["" + buffer.length + ""],"" + offset + "","" + length + "")"");
    }
    if (length > getMaxBufferSize() || length <= 0) {
        throw new IllegalArgumentException(""buffer is too large or of zero length ("" + +length + "" bytes)"");
    }
    SynthesisMessageParams token = null;
    synchronized (mStateLock) {
        if (mToken == null || mStopped) {
            return TextToSpeech.ERROR;
        }
        token = mToken;
    }
    // Sigh, another copy.
    final byte[] bufferCopy = new byte[length];
    System.arraycopy(buffer, offset, bufferCopy, 0, length);
    // Might block on mToken.this, if there are too many buffers waiting to
    // be consumed.
    token.addBuffer(bufferCopy);
    mAudioTrackHandler.enqueueSynthesisDataAvailable(token);
    mLogger.onEngineDataReceived();
    return TextToSpeech.SUCCESS;
}","{
    if (DBG) {
        Log.d(TAG, ""audioAvailable(byte["" + buffer.length + ""],"" + offset + "","" + length + "")"");
    }
    if (length > getMaxBufferSize() || length <= 0) {
        throw new IllegalArgumentException(""buffer is too large or of zero length ("" + +length + "" bytes)"");
    }
    SynthesisPlaybackQueueItem item = null;
    synchronized (mStateLock) {
        if (mItem == null || mStopped) {
            return TextToSpeech.ERROR;
        }
        item = mItem;
    }
    // Sigh, another copy.
    final byte[] bufferCopy = new byte[length];
    System.arraycopy(buffer, offset, bufferCopy, 0, length);
    // be consumed.
    try {
        item.put(bufferCopy);
    } catch (InterruptedException ie) {
        return TextToSpeech.ERROR;
    }
    mLogger.onEngineDataReceived();
    return TextToSpeech.SUCCESS;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,"1,2,4","1,2","1,3",1,"There are multiple changes between the two versions. The first change is that the variable ""token"" has been replaced by ""item"", which is a different variable. The second change is that the method ""addBuffer"" has been replaced by ""put"", which means the dependent API has changed. The third change is that a new exception handling statement has been introduced (""catch (InterruptedException ie)"").","Due to the change of variable and dependent API, the API might return different values in the late version. Additionally, the new exception handling statement might cause the API to throw a different exception. Therefore, both the changes could lead to compatibility issues. The CI type is 1, which means compatibility issue caused by potential different return values or types."
650,"<android.view.View: boolean awakenScrollBars(int,boolean)>",22,23,"<android.view.View: boolean awakenScrollBars(int,boolean)>","<android.view.View: boolean awakenScrollBars(int,boolean)>",0,"{
    final ScrollabilityCache scrollCache = mScrollCache;
    if (scrollCache == null || !scrollCache.fadeScrollBars) {
        return false;
    }
    if (scrollCache.scrollBar == null) {
        scrollCache.scrollBar = new ScrollBarDrawable();
    }
    if (isHorizontalScrollBarEnabled() || isVerticalScrollBarEnabled()) {
        if (invalidate) {
            // Invalidate to show the scrollbars
            postInvalidateOnAnimation();
        }
        if (scrollCache.state == ScrollabilityCache.OFF) {
            // FIXME: this is copied from WindowManagerService.
            // We should get this value from the system when it
            // is possible to do so.
            final int KEY_REPEAT_FIRST_DELAY = 750;
            startDelay = Math.max(KEY_REPEAT_FIRST_DELAY, startDelay);
        }
        // Tell mScrollCache when we should start fading. This may
        // extend the fade start time if one was already scheduled
        long fadeStartTime = AnimationUtils.currentAnimationTimeMillis() + startDelay;
        scrollCache.fadeStartTime = fadeStartTime;
        scrollCache.state = ScrollabilityCache.ON;
        // Schedule our fader to run, unscheduling any old ones first
        if (mAttachInfo != null) {
            mAttachInfo.mHandler.removeCallbacks(scrollCache);
            mAttachInfo.mHandler.postAtTime(scrollCache, fadeStartTime);
        }
        return true;
    }
    return false;
}","{
    final ScrollabilityCache scrollCache = mScrollCache;
    if (scrollCache == null || !scrollCache.fadeScrollBars) {
        return false;
    }
    if (scrollCache.scrollBar == null) {
        scrollCache.scrollBar = new ScrollBarDrawable();
        scrollCache.scrollBar.setCallback(this);
        scrollCache.scrollBar.setState(getDrawableState());
    }
    if (isHorizontalScrollBarEnabled() || isVerticalScrollBarEnabled()) {
        if (invalidate) {
            // Invalidate to show the scrollbars
            postInvalidateOnAnimation();
        }
        if (scrollCache.state == ScrollabilityCache.OFF) {
            // FIXME: this is copied from WindowManagerService.
            // We should get this value from the system when it
            // is possible to do so.
            final int KEY_REPEAT_FIRST_DELAY = 750;
            startDelay = Math.max(KEY_REPEAT_FIRST_DELAY, startDelay);
        }
        // Tell mScrollCache when we should start fading. This may
        // extend the fade start time if one was already scheduled
        long fadeStartTime = AnimationUtils.currentAnimationTimeMillis() + startDelay;
        scrollCache.fadeStartTime = fadeStartTime;
        scrollCache.state = ScrollabilityCache.ON;
        // Schedule our fader to run, unscheduling any old ones first
        if (mAttachInfo != null) {
            mAttachInfo.mHandler.removeCallbacks(scrollCache);
            mAttachInfo.mHandler.postAtTime(scrollCache, fadeStartTime);
        }
        return true;
    }
    return false;
}",1,"/**
 * <p>
 * Trigger the scrollbars to draw. When invoked this method starts an
 * animation to fade the scrollbars out after a fixed delay. If a subclass
 * provides animated scrolling, the start delay should equal the duration of
 * the scrolling animation.
 * </p>
 *
 * <p>
 * The animation starts only if at least one of the scrollbars is enabled,
 * as specified by {@link #isHorizontalScrollBarEnabled()} and
 * {@link #isVerticalScrollBarEnabled()}. When the animation is started,
 * this method returns true, and false otherwise. If the animation is
 * started, this method calls {@link #invalidate()} if the invalidate parameter
 * is set to true; in that case the caller
 * should not call {@link #invalidate()}.
 * </p>
 *
 * <p>
 * This method should be invoked everytime a subclass directly updates the
 * scroll parameters.
 * </p>
 *
 * @param startDelay the delay, in milliseconds, after which the animation
 * should start; when the delay is 0, the animation starts
 * immediately
 *
 * @param invalidate Wheter this method should call invalidate
 *
 * @return true if the animation is played, false otherwise
 *
 * @see #scrollBy(int, int)
 * @see #scrollTo(int, int)
 * @see #isHorizontalScrollBarEnabled()
 * @see #isVerticalScrollBarEnabled()
 * @see #setHorizontalScrollBarEnabled(boolean)
 * @see #setVerticalScrollBarEnabled(boolean)
 */
","/**
 * <p>
 * Trigger the scrollbars to draw. When invoked this method starts an
 * animation to fade the scrollbars out after a fixed delay. If a subclass
 * provides animated scrolling, the start delay should equal the duration of
 * the scrolling animation.
 * </p>
 *
 * <p>
 * The animation starts only if at least one of the scrollbars is enabled,
 * as specified by {@link #isHorizontalScrollBarEnabled()} and
 * {@link #isVerticalScrollBarEnabled()}. When the animation is started,
 * this method returns true, and false otherwise. If the animation is
 * started, this method calls {@link #invalidate()} if the invalidate parameter
 * is set to true; in that case the caller
 * should not call {@link #invalidate()}.
 * </p>
 *
 * <p>
 * This method should be invoked every time a subclass directly updates the
 * scroll parameters.
 * </p>
 *
 * @param startDelay the delay, in milliseconds, after which the animation
 * should start; when the delay is 0, the animation starts
 * immediately
 *
 * @param invalidate Whether this method should call invalidate
 *
 * @return true if the animation is played, false otherwise
 *
 * @see #scrollBy(int, int)
 * @see #scrollTo(int, int)
 * @see #isHorizontalScrollBarEnabled()
 * @see #isVerticalScrollBarEnabled()
 * @see #setHorizontalScrollBarEnabled(boolean)
 * @see #setVerticalScrollBarEnabled(boolean)
 */
",-1,,,-1,-1,-1,-1,-1,4,0,4,1,"In the late version of the implementation, two new lines of code were added after the initialization of the `scrollBar` object:",scrollCache.scrollBar.setState(getDrawableState());
475,<android.preference.Preference: int compareTo(Preference)>,18,19,<android.preference.Preference: int compareTo(Preference)>,<android.preference.Preference: int compareTo(Preference)>,0,"{
    if (mOrder != DEFAULT_ORDER || (mOrder == DEFAULT_ORDER && another.mOrder != DEFAULT_ORDER)) {
        // Do order comparison
        return mOrder - another.mOrder;
    } else if (mTitle == null) {
        return 1;
    } else if (another.mTitle == null) {
        return -1;
    } else {
        // Do name comparison
        return CharSequences.compareToIgnoreCase(mTitle, another.mTitle);
    }
}","{
    if (mOrder != DEFAULT_ORDER || (mOrder == DEFAULT_ORDER && another.mOrder != DEFAULT_ORDER)) {
        // Do order comparison
        return mOrder - another.mOrder;
    } else if (mTitle == another.mTitle) {
        // If titles are null or share same object comparison
        return 0;
    } else if (mTitle == null) {
        return 1;
    } else if (another.mTitle == null) {
        return -1;
    } else {
        // Do name comparison
        return CharSequences.compareToIgnoreCase(mTitle, another.mTitle);
    }
}",1,"/**
 * Compares Preference objects based on order (if set), otherwise alphabetically on the titles.
 *
 * @param another The Preference to compare to this one.
 * @return 0 if the same; less than 0 if this Preference sorts ahead of <var>another</var>;
 * greater than 0 if this Preference sorts after <var>another</var>.
 */
","/**
 * Compares Preference objects based on order (if set), otherwise alphabetically on the titles.
 *
 * @param another The Preference to compare to this one.
 * @return 0 if the same; less than 0 if this Preference sorts ahead of <var>another</var>;
 * greater than 0 if this Preference sorts after <var>another</var>.
 */
",-1,,,-1,-1,-1,-1,-1,"1,3",1,"1, 3",1,The code change is a combination of control dependency change and return statement change. The control dependency change is that a new if-else statement has been added to check if the titles are the same object. The return statement change is that a new return statement has been added to return 0 when the titles are the same object.,"CI type is 1, as the new return statement can potentially cause the API to return a different value (0) when the titles are the same object, leading to different behaviors in the late version."
47,<android.text.PrecomputedText.Params.Builder: Params build()>,32,33,,,,"{
    return new Params(mPaint, mTextDir, mBreakStrategy, mHyphenationFrequency);
}","{
    return new Params(mPaint, mLineBreakConfig, mTextDir, mBreakStrategy, mHyphenationFrequency);
}",1,"/**
 * Build the {@link Params}.
 *
 * @return the layout parameter
 */
","/**
 * Build the {@link Params}.
 *
 * @return the layout parameter
 */
",0,[@NonNull],[@NonNull],0,,,,,"1,5",1,"1,5",1,"In the late version implementation, an additional parameter ""mLineBreakConfig"" is added in the constructor of ""Params"" class, which indicates that the return statement has changed. Therefore, the code change type is 1,5.","The additional parameter ""mLineBreakConfig"" may cause the constructor of ""Params"" class to generate different values, which leads to the different return values of ""build()"" method in the two versions. Therefore, the CI type is 1."
1019,<android.webkit.WebSettings: String getDatabasePath()>,15,16,<android.webkit.WebSettings: String getDatabasePath()>,<android.webkit.WebSettings: String getDatabasePath()>,0,"{
    return mDatabasePath;
}","{
    throw new MustOverrideException();
}",1,"/**
 * Return the path to where database storage API databases are saved for
 * the current WebView.
 * @return the String path to the database storage API databases.
 */
","/**
 * Gets the path to where database storage API databases are saved for
 * the current WebView.
 *
 * @return the String path to the database storage API databases
 */
",-1,,,-1,-1,-1,-1,-1,"1,2","1,2",1,1,The return statement has changed from returning a value to throwing an exception.,"The behavior of the API has changed, as it no longer returns a value and instead throws an exception. This could lead to different behaviors in client code that calls this API, potentially causing a compatibility issue."
210,<android.hardware.camera2.legacy.LegacyCameraDevice: void finalize()>,23,24,<android.hardware.camera2.legacy.LegacyCameraDevice: void finalize()>,<android.hardware.camera2.legacy.LegacyCameraDevice: void finalize()>,0,"{
    try {
        close();
    } catch (CameraRuntimeException e) {
        Log.e(TAG, ""Got error while trying to finalize, ignoring: "" + e.getMessage());
    } finally {
        super.finalize();
    }
}","{
    try {
        close();
    } catch (ServiceSpecificException e) {
        Log.e(TAG, ""Got error while trying to finalize, ignoring: "" + e.getMessage());
    } finally {
        super.finalize();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,"2,4",2,2,2,"The exception handling statement has changed, the exception type caught in the catch clause has changed from CameraRuntimeException to ServiceSpecificException.","As the exception handling statement has changed, the exception thrown by the late version API could be different from the early version API, so the CI type is 2."
849,<android.widget.NumberPicker: void onDraw(Canvas)>,15,16,<android.widget.NumberPicker: void onDraw(Canvas)>,<android.widget.NumberPicker: void onDraw(Canvas)>,0,"{
    if (mSelectorWheelState == SELECTOR_WHEEL_STATE_NONE) {
        return;
    }
    float x = (mRight - mLeft) / 2;
    float y = mCurrentScrollOffset;
    final int restoreCount = canvas.save();
    if (mSelectorWheelState == SELECTOR_WHEEL_STATE_SMALL) {
        Rect clipBounds = canvas.getClipBounds();
        clipBounds.inset(0, mSelectorElementHeight);
        canvas.clipRect(clipBounds);
    }
    // draw the selector wheel
    int[] selectorIndices = mSelectorIndices;
    for (int i = 0; i < selectorIndices.length; i++) {
        int selectorIndex = selectorIndices[i];
        String scrollSelectorValue = mSelectorIndexToStringCache.get(selectorIndex);
        // value intermixed with the new one.
        if (i != SELECTOR_MIDDLE_ITEM_INDEX || mInputText.getVisibility() != VISIBLE) {
            canvas.drawText(scrollSelectorValue, x, y, mSelectorWheelPaint);
        }
        y += mSelectorElementHeight;
    }
    // draw the selection dividers (only if scrolling and drawable specified)
    if (mSelectionDivider != null) {
        // draw the top divider
        int topOfTopDivider = (getHeight() - mSelectorElementHeight - mSelectionDividerHeight) / 2;
        int bottomOfTopDivider = topOfTopDivider + mSelectionDividerHeight;
        mSelectionDivider.setBounds(0, topOfTopDivider, mRight, bottomOfTopDivider);
        mSelectionDivider.draw(canvas);
        // draw the bottom divider
        int topOfBottomDivider = topOfTopDivider + mSelectorElementHeight;
        int bottomOfBottomDivider = bottomOfTopDivider + mSelectorElementHeight;
        mSelectionDivider.setBounds(0, topOfBottomDivider, mRight, bottomOfBottomDivider);
        mSelectionDivider.draw(canvas);
    }
    canvas.restoreToCount(restoreCount);
}","{
    if (!mHasSelectorWheel) {
        super.onDraw(canvas);
        return;
    }
    float x = (mRight - mLeft) / 2;
    float y = mCurrentScrollOffset;
    // draw the virtual buttons pressed state if needed
    if (mVirtualButtonPressedDrawable != null && mScrollState == OnScrollListener.SCROLL_STATE_IDLE) {
        if (mDecrementVirtualButtonPressed) {
            mVirtualButtonPressedDrawable.setState(PRESSED_STATE_SET);
            mVirtualButtonPressedDrawable.setBounds(0, 0, mRight, mTopSelectionDividerTop);
            mVirtualButtonPressedDrawable.draw(canvas);
        }
        if (mIncrementVirtualButtonPressed) {
            mVirtualButtonPressedDrawable.setState(PRESSED_STATE_SET);
            mVirtualButtonPressedDrawable.setBounds(0, mBottomSelectionDividerBottom, mRight, mBottom);
            mVirtualButtonPressedDrawable.draw(canvas);
        }
    }
    // draw the selector wheel
    int[] selectorIndices = mSelectorIndices;
    for (int i = 0; i < selectorIndices.length; i++) {
        int selectorIndex = selectorIndices[i];
        String scrollSelectorValue = mSelectorIndexToStringCache.get(selectorIndex);
        // with the new one.
        if (i != SELECTOR_MIDDLE_ITEM_INDEX || mInputText.getVisibility() != VISIBLE) {
            canvas.drawText(scrollSelectorValue, x, y, mSelectorWheelPaint);
        }
        y += mSelectorElementHeight;
    }
    // draw the selection dividers
    if (mSelectionDivider != null) {
        // draw the top divider
        int topOfTopDivider = mTopSelectionDividerTop;
        int bottomOfTopDivider = topOfTopDivider + mSelectionDividerHeight;
        mSelectionDivider.setBounds(0, topOfTopDivider, mRight, bottomOfTopDivider);
        mSelectionDivider.draw(canvas);
        // draw the bottom divider
        int bottomOfBottomDivider = mBottomSelectionDividerBottom;
        int topOfBottomDivider = bottomOfBottomDivider - mSelectionDividerHeight;
        mSelectionDivider.setBounds(0, topOfBottomDivider, mRight, bottomOfBottomDivider);
        mSelectionDivider.draw(canvas);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,"3,4",0,"3,4",1,"The change type is 3,4. The control dependency has changed: the early version first checks if the selector wheel state is none and returns, while the late version checks if there is a selector wheel and calls super.onDraw(canvas) if not. Also, there is a new block of code in the late version that draws virtual buttons' pressed state. The other statements about drawing the selector wheel and selection dividers also have some changes (change type 4).","The Compatibility Issue type is 1. The changes in control dependency and other statements can potentially cause the API to return a different value or type. For example, in the early version, if the selector wheel state is none, the onDraw method just returns and does nothing, while in the late version, the super.onDraw(canvas) method is called if there is no selector wheel, which can lead to different behaviours. Additionally, the new block of code that draws virtual buttons' pressed state can also cause different values to be drawn on the canvas."
1109,<android.hardware.camera2.legacy.CameraDeviceUserShim: int createStream(OutputConfiguration)>,23,24,<android.hardware.camera2.legacy.CameraDeviceUserShim: int createStream(OutputConfiguration)>,<android.hardware.camera2.legacy.CameraDeviceUserShim: int createStream(OutputConfiguration)>,0,"{
    if (DEBUG) {
        Log.d(TAG, ""createStream called."");
    }
    if (mLegacyDevice.isClosed()) {
        Log.e(TAG, ""Cannot create stream, device has been closed."");
        return CameraBinderDecorator.ENODEV;
    }
    synchronized (mConfigureLock) {
        if (!mConfiguring) {
            Log.e(TAG, ""Cannot create stream, beginConfigure hasn't been called yet."");
            return CameraBinderDecorator.INVALID_OPERATION;
        }
        if (outputConfiguration.getRotation() != OutputConfiguration.ROTATION_0) {
            Log.e(TAG, ""Cannot create stream, stream rotation is not supported."");
            return CameraBinderDecorator.INVALID_OPERATION;
        }
        int id = ++mSurfaceIdCounter;
        mSurfaces.put(id, outputConfiguration.getSurface());
        return id;
    }
}","{
    if (DEBUG) {
        Log.d(TAG, ""createStream called."");
    }
    if (mLegacyDevice.isClosed()) {
        String err = ""Cannot create stream, device has been closed."";
        Log.e(TAG, err);
        throw new ServiceSpecificException(ICameraService.ERROR_DISCONNECTED, err);
    }
    synchronized (mConfigureLock) {
        if (!mConfiguring) {
            String err = ""Cannot create stream, beginConfigure hasn't been called yet."";
            Log.e(TAG, err);
            throw new ServiceSpecificException(ICameraService.ERROR_INVALID_OPERATION, err);
        }
        if (outputConfiguration.getRotation() != OutputConfiguration.ROTATION_0) {
            String err = ""Cannot create stream, stream rotation is not supported."";
            Log.e(TAG, err);
            throw new ServiceSpecificException(ICameraService.ERROR_ILLEGAL_ARGUMENT, err);
        }
        int id = ++mSurfaceIdCounter;
        mSurfaces.put(id, outputConfiguration.getSurface());
        return id;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,"1,2,4","1,2","1,2","1,2","In the early version, the function returns an error code when there is a problem, while in the late version, it throws an exception. The return statement has been removed and new exception handling statements have been introduced. So the change type is 1,2.","The change of return statement and exception handling statements could lead to different behaviours when the API is invoked. Specifically, the exception handling statements in the late version may cause potential exceptions, while the early version doesn't throw any exception. Therefore, the CI type is 1,2."
1148,<android.view.TextureView: HardwareLayer getHardwareLayer()>,20,21,<android.view.TextureView: HardwareLayer getHardwareLayer()>,<android.view.TextureView: HardwareLayer getHardwareLayer()>,0,"{
    // NOTE: Maintain these two lines very carefully (see View.java)
    mPrivateFlags |= PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID;
    mPrivateFlags &= ~PFLAG_DIRTY_MASK;
    if (mLayer == null) {
        if (mAttachInfo == null || mAttachInfo.mHardwareRenderer == null) {
            return null;
        }
        mLayer = mAttachInfo.mHardwareRenderer.createHardwareLayer(mOpaque);
        if (!mUpdateSurface) {
            // Create a new SurfaceTexture for the layer.
            mSurface = mAttachInfo.mHardwareRenderer.createSurfaceTexture(mLayer);
        }
        mSurface.setDefaultBufferSize(getWidth(), getHeight());
        nCreateNativeWindow(mSurface);
        mUpdateListener = new SurfaceTexture.OnFrameAvailableListener() {

            @Override
            public void onFrameAvailable(SurfaceTexture surfaceTexture) {
                // Per SurfaceTexture's documentation, the callback may be invoked
                // from an arbitrary thread
                updateLayer();
                if (Looper.myLooper() == Looper.getMainLooper()) {
                    invalidate();
                } else {
                    postInvalidate();
                }
            }
        };
        mSurface.setOnFrameAvailableListener(mUpdateListener);
        if (mListener != null && !mUpdateSurface) {
            mListener.onSurfaceTextureAvailable(mSurface, getWidth(), getHeight());
        }
        mLayer.setLayerPaint(mLayerPaint);
    }
    if (mUpdateSurface) {
        // Someone has requested that we use a specific SurfaceTexture, so
        // tell mLayer about it and set the SurfaceTexture to use the
        // current view size.
        mUpdateSurface = false;
        // Since we are updating the layer, force an update to ensure its
        // parameters are correct (width, height, transform, etc.)
        updateLayer();
        mMatrixChanged = true;
        mAttachInfo.mHardwareRenderer.setSurfaceTexture(mLayer, mSurface);
        mSurface.setDefaultBufferSize(getWidth(), getHeight());
    }
    applyUpdate();
    applyTransformMatrix();
    return mLayer;
}","{
    // NOTE: Maintain these two lines very carefully (see View.java)
    mPrivateFlags |= PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID;
    mPrivateFlags &= ~PFLAG_DIRTY_MASK;
    if (mLayer == null) {
        if (mAttachInfo == null || mAttachInfo.mHardwareRenderer == null) {
            return null;
        }
        mLayer = mAttachInfo.mHardwareRenderer.createTextureLayer();
        if (!mUpdateSurface) {
            // Create a new SurfaceTexture for the layer.
            mSurface = new SurfaceTexture(false);
            mLayer.setSurfaceTexture(mSurface);
        }
        mSurface.setDefaultBufferSize(getWidth(), getHeight());
        nCreateNativeWindow(mSurface);
        mSurface.setOnFrameAvailableListener(mUpdateListener, mAttachInfo.mHandler);
        if (mListener != null && !mUpdateSurface) {
            mListener.onSurfaceTextureAvailable(mSurface, getWidth(), getHeight());
        }
        mLayer.setLayerPaint(mLayerPaint);
    }
    if (mUpdateSurface) {
        // Someone has requested that we use a specific SurfaceTexture, so
        // tell mLayer about it and set the SurfaceTexture to use the
        // current view size.
        mUpdateSurface = false;
        // Since we are updating the layer, force an update to ensure its
        // parameters are correct (width, height, transform, etc.)
        updateLayer();
        mMatrixChanged = true;
        mLayer.setSurfaceTexture(mSurface);
        mSurface.setDefaultBufferSize(getWidth(), getHeight());
    }
    applyUpdate();
    applyTransformMatrix();
    return mLayer;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,"3,4",0,"1,5",1,"In the early version, the method `mAttachInfo.mHardwareRenderer.createHardwareLayer(mOpaque)` is used to create the hardware layer, while in the late version, the method `mAttachInfo.mHardwareRenderer.createTextureLayer()` is used. The two methods have different names and return different types of objects (HardwareLayer vs TextureLayer). In addition, the way the SurfaceTexture is created and set to the layer is different between the two versions. These changes can potentially lead to different behaviors of the API. Therefore, the code change type is 1,5.","Since the implementation of the API has changed in the way the HardwareLayer is created and the way the SurfaceTexture is set to the layer, the API may return a different value or type (HardwareLayer vs TextureLayer), which can potentially lead to compatibility issues. Therefore, the CI type is 1."
867,"<android.view.GLES20Canvas: boolean clipRegion(Region,Op)>",15,16,"<android.view.GLES20Canvas: boolean clipRegion(Region,Op)>","<android.view.GLES20Canvas: boolean clipRegion(Region,Op)>",0,"{
    throw new UnsupportedOperationException();
}","{
    // TODO: Implement
    region.getBounds(mClipBounds);
    return nClipRect(mRenderer, mClipBounds.left, mClipBounds.top, mClipBounds.right, mClipBounds.bottom, op.nativeInt);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,"1,2,4","1,2","1, 4",1,"The implementation of the clipRegion(Region,Op) method has been changed from throwing an UnsupportedOperationException to implementing the method using the getBounds() method and nClipRect() method.","The code change potentially leads to different behavior, as the early version throws an exception, while the late version does not. Therefore, it may cause a compatibility issue where the API returns different values or types. The compatibility issue type is 1, as the method returns a boolean value that may be different from the previous implementation."
550,<android.os.RemoteCallbackList: int beginBroadcast()>,18,19,<android.os.RemoteCallbackList: int beginBroadcast()>,<android.os.RemoteCallbackList: int beginBroadcast()>,0,"{
    synchronized (mCallbacks) {
        if (mBroadcastCount > 0) {
            throw new IllegalStateException(""beginBroadcast() called while already in a broadcast"");
        }
        final int N = mBroadcastCount = mCallbacks.size();
        if (N <= 0) {
            return 0;
        }
        Object[] active = mActiveBroadcast;
        if (active == null || active.length < N) {
            mActiveBroadcast = active = new Object[N];
        }
        int i = 0;
        for (Callback cb : mCallbacks.values()) {
            active[i++] = cb;
        }
        return i;
    }
}","{
    synchronized (mCallbacks) {
        if (mBroadcastCount > 0) {
            throw new IllegalStateException(""beginBroadcast() called while already in a broadcast"");
        }
        final int N = mBroadcastCount = mCallbacks.size();
        if (N <= 0) {
            return 0;
        }
        Object[] active = mActiveBroadcast;
        if (active == null || active.length < N) {
            mActiveBroadcast = active = new Object[N];
        }
        for (int i = 0; i < N; i++) {
            active[i] = mCallbacks.valueAt(i);
        }
        return N;
    }
}",1,"/**
 * Prepare to start making calls to the currently registered callbacks.
 * This creates a copy of the callback list, which you can retrieve items
 * from using {@link #getBroadcastItem}.  Note that only one broadcast can
 * be active at a time, so you must be sure to always call this from the
 * same thread (usually by scheduling with {@link Handler}) or
 * do your own synchronization.  You must call {@link #finishBroadcast}
 * when done.
 *
 * <p>A typical loop delivering a broadcast looks like this:
 *
 * <pre>
 * int i = callbacks.beginBroadcast();
 * while (i &gt; 0) {
 * i--;
 * try {
 * callbacks.getBroadcastItem(i).somethingHappened();
 * } catch (RemoteException e) {
 * // The RemoteCallbackList will take care of removing
 * // the dead object for us.
 * }
 * }
 * callbacks.finishBroadcast();</pre>
 *
 * @return Returns the number of callbacks in the broadcast, to be used
 * with {@link #getBroadcastItem} to determine the range of indices you
 * can supply.
 *
 * @see #getBroadcastItem
 * @see #finishBroadcast
 */
","/**
 * Prepare to start making calls to the currently registered callbacks.
 * This creates a copy of the callback list, which you can retrieve items
 * from using {@link #getBroadcastItem}.  Note that only one broadcast can
 * be active at a time, so you must be sure to always call this from the
 * same thread (usually by scheduling with {@link Handler}) or
 * do your own synchronization.  You must call {@link #finishBroadcast}
 * when done.
 *
 * <p>A typical loop delivering a broadcast looks like this:
 *
 * <pre>
 * int i = callbacks.beginBroadcast();
 * while (i &gt; 0) {
 * i--;
 * try {
 * callbacks.getBroadcastItem(i).somethingHappened();
 * } catch (RemoteException e) {
 * // The RemoteCallbackList will take care of removing
 * // the dead object for us.
 * }
 * }
 * callbacks.finishBroadcast();</pre>
 *
 * @return Returns the number of callbacks in the broadcast, to be used
 * with {@link #getBroadcastItem} to determine the range of indices you
 * can supply.
 *
 * @see #getBroadcastItem
 * @see #finishBroadcast
 */
",-1,,,-1,-1,-1,-1,-1,"1,4",1,"3, 4",1,"The code change is in the last few lines of the implementation. In the early version, the code uses a for loop to iterate through the values of `mCallbacks` and set them to the `active` array. In the late version, the code uses the `valueAt` method of `mCallbacks` to set the values of the `active` array. Additionally, the return value in the early version is the index `i`, while in the late version, the return value is `N`, which is the size of `mCallbacks`.","The change in the return value from `i` to `N` could potentially lead to compatibility issues, as the behavior of the API has changed. Specifically, the value returned by the API could be different between the early and late versions, which could affect the functionality of the code that calls this API. Therefore, this change is classified as a compatibility issue caused by potential different return values or types (1)."
316,"<android.app.AppOpsManager: int unsafeCheckOpRawNoThrow(String,int,String)>",29,30,"<android.app.AppOpsManager: int unsafeCheckOpRawNoThrow(String,int,String)>","<android.app.AppOpsManager: int unsafeCheckOpRawNoThrow(String,int,String)>",0,"{
    try {
        return mService.checkOperationRaw(strOpToOp(op), uid, packageName);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    return unsafeCheckOpRawNoThrow(strOpToOp(op), uid, packageName);
}",1,"/**
 * Like {@link #unsafeCheckOpNoThrow(String, int, String)} but returns the <em>raw</em>
 * mode associated with the op. Does not throw a security exception, does not translate
 * {@link #MODE_FOREGROUND}.
 */
","/**
 * Like {@link #unsafeCheckOpNoThrow(String, int, String)} but returns the <em>raw</em>
 * mode associated with the op. Does not throw a security exception, does not translate
 * {@link #MODE_FOREGROUND}.
 */
",-1,,,-1,-1,-1,-1,-1,4,-1,5,1,"In the early version, the method uses the `mService.checkOperationRaw()` method to perform the check and catches a `RemoteException` which is then rethrown using `e.rethrowFromSystemServer()`. However, in the late version, the implementation is replaced with a call to `unsafeCheckOpRawNoThrow()`, which likely handles the exception internally and does not rethrow it. This is an example of dependent API change as the implementation relies on a different method in the late version.","The change in the implementation can potentially cause a compatibility issue as the late version no longer throws the `RemoteException` that was thrown in the early version. This means that any code that depends on the exception being thrown may no longer function as intended. Therefore, this is a compatibility issue caused by potential different exception handling."
334,<android.accounts.AccountManager: String getPassword(Account)>,22,23,<android.accounts.AccountManager: String getPassword(Account)>,<android.accounts.AccountManager: String getPassword(Account)>,0,"{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    try {
        return mService.getPassword(account);
    } catch (RemoteException e) {
        // will never happen
        throw new RuntimeException(e);
    }
}","{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    try {
        return mService.getPassword(account);
    } catch (RemoteException e) {
        // won't ever happen
        throw new RuntimeException(e);
    }
}",1,"/**
 * Gets the saved password associated with the account.
 * This is intended for authenticators and related code; applications
 * should get an auth token instead.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#AUTHENTICATE_ACCOUNTS}
 * and to have the same UID as the account's authenticator.
 *
 * @param account The account to query for a password
 * @return The account's password, null if none or if the account doesn't exist
 */
","/**
 * Gets the saved password associated with the account.
 * This is intended for authenticators and related code; applications
 * should get an auth token instead.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>This method requires the caller to have a signature match with the
 * authenticator that owns the specified account.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * AUTHENTICATE_ACCOUNTS permission is needed for those platforms. See docs for
 * this function in API level 22.
 *
 * @param account The account to query for a password. Must not be {@code null}.
 * @return The account's password, null if none or if the account doesn't exist
 */
",-1,,,-1,-1,-1,-1,-1,0,0,0,0,There is no significant code change between the early and late versions.,There is no potential Compatibility Issue as the code remains the same in both versions.
725,<android.app.ActivityManager: void killBackgroundProcesses(String)>,25,26,<android.app.ActivityManager: void killBackgroundProcesses(String)>,<android.app.ActivityManager: void killBackgroundProcesses(String)>,0,"{
    try {
        ActivityManagerNative.getDefault().killBackgroundProcesses(packageName, UserHandle.myUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        getService().killBackgroundProcesses(packageName, UserHandle.myUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Have the system immediately kill all background processes associated
 * with the given package.  This is the same as the kernel killing those
 * processes to reclaim memory; the system will take care of restarting
 * these processes in the future as needed.
 *
 * <p>You must hold the permission
 * {@link android.Manifest.permission#KILL_BACKGROUND_PROCESSES} to be able to
 * call this method.
 *
 * @param packageName The name of the package whose processes are to
 * be killed.
 */
","/**
 * Have the system immediately kill all background processes associated
 * with the given package.  This is the same as the kernel killing those
 * processes to reclaim memory; the system will take care of restarting
 * these processes in the future as needed.
 *
 * @param packageName The name of the package whose processes are to
 * be killed.
 */
",-1,,[@RequiresPermission(Manifest.permission.KILL_BACKGROUND_PROCESSES)],-1,-1,-1,-1,-1,4,0,5,0,"The method call within the try block has changed from ""ActivityManagerNative.getDefault().killBackgroundProcesses(packageName, UserHandle.myUserId())"" to ""getService().killBackgroundProcesses(packageName, UserHandle.myUserId())"". This change is a Dependent API change.","Although the method call has changed, the behavior of the method is still the same as it is still calling the killBackgroundProcesses method with the same parameters. Therefore, there is no compatibility issue caused by this change."
60,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getChild(int)>,32,33,,,,"{
    enforceSealed();
    if (mChildNodeIds == null) {
        return null;
    }
    if (!canPerformRequestOverConnection(mConnectionId, mWindowId, mSourceNodeId)) {
        return null;
    }
    final long childId = mChildNodeIds.get(index);
    final AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    if (mLeashedChild != null && childId == LEASHED_NODE_ID) {
        return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mLeashedChild, ROOT_NODE_ID, false, FLAG_PREFETCH_DESCENDANTS, null);
    }
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mWindowId, childId, false, FLAG_PREFETCH_DESCENDANTS, null);
}","{
    return getChild(index, FLAG_PREFETCH_DESCENDANTS_HYBRID);
}",1,"/**
 * Get the child at given index.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @param index The child index.
 * @return The child node.
 *
 * @throws IllegalStateException If called outside of an AccessibilityService.
 */
","/**
 * Get the child at given index.
 *
 * @param index The child index.
 * @return The child node.
 *
 * @throws IllegalStateException If called outside of an AccessibilityService.
 */
",1,,,0,,,,,"1,3,4",1,5,1,"The whole implementation has changed, using a new API call (getChild with an additional flag) instead of the previous implementation. The new API is a dependent API, so the code change type is 5.","As the new API (getChild with an additional flag) is used, it could potentially return different values, leading to a different behavior in the late version. Thus, the CI type is 1."
302,"<android.app.ContextImpl: void sendStickyBroadcastAsUser(Intent,UserHandle)>",29,30,"<android.app.ContextImpl: void sendStickyBroadcastAsUser(Intent,UserHandle)>","<android.app.ContextImpl: void sendStickyBroadcastAsUser(Intent,UserHandle)>",0,"{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, true, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, true, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,"[@Override, @Deprecated]","[@Override, @Deprecated]",-1,-1,-1,-1,-1,4,0,5,1,"The `ActivityManager.getService().broadcastIntent` method call in the early implementation has been changed to `ActivityManager.getService().broadcastIntentWithFeature` in the late implementation. This is a Dependent API change, hence the change type is 5.","The change in the dependent API method call from `broadcastIntent` to `broadcastIntentWithFeature` could potentially lead to different behaviors, especially if the additional `getAttributionTag()` parameter in `broadcastIntentWithFeature` affects the broadcast behavior. Thus, this change may cause a Compatibility Issue (CI) of type 1 (Compatibility Issue caused by potential different return values or types)."
20,<android.widget.FrameLayout: LayoutParams generateDefaultLayoutParams()>,7,8,<android.widget.FrameLayout: LayoutParams generateDefaultLayoutParams()>,<android.widget.FrameLayout: LayoutParams generateDefaultLayoutParams()>,0,"{
    return new LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.FILL_PARENT);
}","{
    return new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
}",1,"/**
 * Returns a set of layout parameters with a width of
 * {@link android.view.ViewGroup.LayoutParams#FILL_PARENT},
 * and a height of {@link android.view.ViewGroup.LayoutParams#FILL_PARENT}.
 */
","/**
 * Returns a set of layout parameters with a width of
 * {@link android.view.ViewGroup.LayoutParams#MATCH_PARENT},
 * and a height of {@link android.view.ViewGroup.LayoutParams#MATCH_PARENT}.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,"1,4",1,1,1,"The return statement has changed, with the values `LayoutParams.FILL_PARENT` being replaced with `LayoutParams.MATCH_PARENT` for both width and height in the late version.","This change in the return statement can lead to a different behavior, as `MATCH_PARENT` and `FILL_PARENT` have different meanings. `MATCH_PARENT` means that the view wants to be as big as its parent (minus padding), while `FILL_PARENT` is a deprecated constant replaced by `MATCH_PARENT`. Thus, the compatibility issue arises due to the potential for different return values."
319,"<android.app.Notification.Builder: Builder setSound(Uri,int)>",25,26,"<android.app.Notification.Builder: Builder setSound(Uri,int)>","<android.app.Notification.Builder: Builder setSound(Uri,int)>",0,"{
    mN.sound = sound;
    mN.audioStreamType = streamType;
    return this;
}","{
    PlayerBase.deprecateStreamTypeForPlayback(streamType, ""Notification"", ""setSound()"");
    mN.sound = sound;
    mN.audioStreamType = streamType;
    return this;
}",1,"/**
 * Set the sound to play, along with a specific stream on which to play it.
 *
 * See {@link android.media.AudioManager} for the <code>STREAM_</code> constants.
 *
 * <p>
 * A notification that is noisy is more likely to be presented as a heads-up notification.
 * </p>
 * @deprecated use {@link #setSound(Uri, AudioAttributes)} instead.
 * @see Notification#sound
 */
","/**
 * Set the sound to play, along with a specific stream on which to play it.
 *
 * See {@link android.media.AudioManager} for the <code>STREAM_</code> constants.
 *
 * @deprecated use {@link NotificationChannel#setSound(Uri, AudioAttributes)}.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,4,0,"4,5",0,"In the late version, a new method call `PlayerBase.deprecateStreamTypeForPlayback(streamType, ""Notification"", ""setSound()"")` has been added before setting the sound and audio stream type. This method call is not related to the return statement, exception handling, or control dependency, so it is classified as ""Other statement changed"" (code change type 4). Additionally, the `setSound` method now depends on the `PlayerBase.deprecateStreamTypeForPlayback` method, so it is also classified as ""Dependent API changed"" (code change type 5).","Although there is a new method call in the late version, it does not affect the return value or exception handling of the `setSound` method. The `PlayerBase.deprecateStreamTypeForPlayback` method is used to log a deprecation warning, but it does not change the behavior of the `setSound` method. Therefore, there is no compatibility issue in this case."
64,<android.app.Activity: void recreate()>,23,24,<android.app.Activity: void recreate()>,<android.app.Activity: void recreate()>,0,"{
    if (mParent != null) {
        throw new IllegalStateException(""Can only be called on top-level activity"");
    }
    if (Looper.myLooper() != mMainThread.getLooper()) {
        throw new IllegalStateException(""Must be called from main thread"");
    }
    mMainThread.requestRelaunchActivity(mToken, null, null, 0, false, null, null, false);
}","{
    if (mParent != null) {
        throw new IllegalStateException(""Can only be called on top-level activity"");
    }
    if (Looper.myLooper() != mMainThread.getLooper()) {
        throw new IllegalStateException(""Must be called from main thread"");
    }
    mMainThread.requestRelaunchActivity(mToken, null, null, 0, false, null, null, false, false);
}",1,"/**
 * Cause this Activity to be recreated with a new instance.  This results
 * in essentially the same flow as when the Activity is created due to
 * a configuration change -- the current instance will go through its
 * lifecycle to {@link #onDestroy} and a new instance then created after it.
 */
","/**
 * Cause this Activity to be recreated with a new instance.  This results
 * in essentially the same flow as when the Activity is created due to
 * a configuration change -- the current instance will go through its
 * lifecycle to {@link #onDestroy} and a new instance then created after it.
 */
",-1,,,-1,-1,-1,-1,-1,5,0,5,0,"The method requestRelaunchActivity in the late version has an additional boolean parameter ""keepTaskId"", which indicates whether to keep the task id of the activity or not. This is a change of the dependent API.","Since the additional parameter in the dependent API has a default value of false, it does not affect the behavior of the recreate() method, so there is no compatibility issue caused by this change."
807,<android.app.Activity: void setActionBar(Toolbar)>,22,23,<android.app.Activity: void setActionBar(Toolbar)>,<android.app.Activity: void setActionBar(Toolbar)>,0,"{
    if (getActionBar() instanceof WindowDecorActionBar) {
        throw new IllegalStateException(""This Activity already has an action bar supplied "" + ""by the window decor. Do not request Window.FEATURE_ACTION_BAR and set "" + ""android:windowActionBar to false in your theme to use a Toolbar instead."");
    }
    ToolbarActionBar tbab = new ToolbarActionBar(toolbar, getTitle(), this);
    mActionBar = tbab;
    mWindow.setCallback(tbab.getWrappedWindowCallback());
    mActionBar.invalidateOptionsMenu();
}","{
    if (getActionBar() instanceof WindowDecorActionBar) {
        throw new IllegalStateException(""This Activity already has an action bar supplied "" + ""by the window decor. Do not request Window.FEATURE_ACTION_BAR and set "" + ""android:windowActionBar to false in your theme to use a Toolbar instead."");
    }
    // Clear out the MenuInflater to make sure that it is valid for the new Action Bar
    mMenuInflater = null;
    ToolbarActionBar tbab = new ToolbarActionBar(toolbar, getTitle(), this);
    mActionBar = tbab;
    mWindow.setCallback(tbab.getWrappedWindowCallback());
    mActionBar.invalidateOptionsMenu();
}",1,"/**
 * Set a {@link android.widget.Toolbar Toolbar} to act as the {@link ActionBar} for this
 * Activity window.
 *
 * <p>When set to a non-null value the {@link #getActionBar()} method will return
 * an {@link ActionBar} object that can be used to control the given toolbar as if it were
 * a traditional window decor action bar. The toolbar's menu will be populated with the
 * Activity's options menu and the navigation button will be wired through the standard
 * {@link android.R.id#home home} menu select action.</p>
 *
 * <p>In order to use a Toolbar within the Activity's window content the application
 * must not request the window feature {@link Window#FEATURE_ACTION_BAR FEATURE_ACTION_BAR}.</p>
 *
 * @param toolbar Toolbar to set as the Activity's action bar
 */
","/**
 * Set a {@link android.widget.Toolbar Toolbar} to act as the {@link ActionBar} for this
 * Activity window.
 *
 * <p>When set to a non-null value the {@link #getActionBar()} method will return
 * an {@link ActionBar} object that can be used to control the given toolbar as if it were
 * a traditional window decor action bar. The toolbar's menu will be populated with the
 * Activity's options menu and the navigation button will be wired through the standard
 * {@link android.R.id#home home} menu select action.</p>
 *
 * <p>In order to use a Toolbar within the Activity's window content the application
 * must not request the window feature {@link Window#FEATURE_ACTION_BAR FEATURE_ACTION_BAR}.</p>
 *
 * @param toolbar Toolbar to set as the Activity's action bar
 */
",-1,,,-1,-1,-1,-1,-1,4,0,4,0,"A statement ""mMenuInflater = null;"" has been added in the late version of the implementation, which is not related to the return statement, exception handling statement, or control dependency. So the code change type is 4, Other statement changed.","The change in the code does not impact the return value or exception handling of the API. Therefore, it does not cause any Compatibility Issue."
1086,<android.print.PrintManager.PrintDocumentAdapterDelegate.MyWriteResultCallback: void onWriteCancelled()>,20,21,<android.print.PrintManager.PrintDocumentAdapterDelegate.MyWriteResultCallback: void onWriteCancelled()>,<android.print.PrintManager.PrintDocumentAdapterDelegate.MyWriteResultCallback: void onWriteCancelled()>,0,"{
    synchronized (mLock) {
        if (mDestroyed) {
            Log.e(LOG_TAG, ""PrintDocumentAdapter is destroyed. Did you "" + ""finish the printing activity before print completion?"");
            return;
        }
        clearLocked();
    }
}","{
    final IWriteResultCallback callback;
    synchronized (mLock) {
        callback = mCallback;
    }
    // If the callback is null we are destroyed.
    if (callback == null) {
        Log.e(LOG_TAG, ""PrintDocumentAdapter is destroyed. Did you "" + ""finish the printing activity before print completion "" + ""or did you invoke a callback after finish?"");
        return;
    }
    try {
        callback.onWriteCanceled(mSequence);
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error calling onWriteCanceled"", re);
    } finally {
        destroy();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,"1,2,3,4","1,2","1,2,3,5","1,2",The change from early version to late version includes:,2. Exception handling statement changed: The late version has added a try-catch block for handling RemoteException.
267,<android.util.SparseIntArray: int indexOfKey(int)>,18,19,<android.util.SparseIntArray: int indexOfKey(int)>,<android.util.SparseIntArray: int indexOfKey(int)>,0,"{
    return binarySearch(mKeys, 0, mSize, key);
}","{
    return ContainerHelpers.binarySearch(mKeys, mSize, key);
}",1,"/**
 * Returns the index for which {@link #keyAt} would return the
 * specified key, or a negative number if the specified
 * key is not mapped.
 */
","/**
 * Returns the index for which {@link #keyAt} would return the
 * specified key, or a negative number if the specified
 * key is not mapped.
 */
",-1,,,-1,-1,-1,-1,-1,"1,5",1,5,1,The implementation of the binary search algorithm has changed from using the local method `binarySearch()` to the static method `ContainerHelpers.binarySearch()`. This is a change in the dependent API.,"The change in the implementation of the binary search algorithm could lead to different behavior in the API, specifically in the return value. Therefore, this is a compatibility issue caused by potential different return values."
339,"<android.view.GLES20Canvas: void drawText(String,int,int,float,float,Paint)>",20,21,"<android.view.GLES20Canvas: void drawText(String,int,int,float,float,Paint)>","<android.view.GLES20Canvas: void drawText(String,int,int,float,float,Paint)>",0,"{
    if ((start | end | (end - start) | (text.length() - end)) < 0) {
        throw new IndexOutOfBoundsException();
    }
    int modifiers = setupModifiers(paint);
    try {
        nDrawText(mRenderer, text, start, end, x, y, paint.mBidiFlags, paint.mNativePaint);
    } finally {
        if (modifiers != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifiers);
    }
}","{
    if ((start | end | (end - start) | (text.length() - end)) < 0) {
        throw new IndexOutOfBoundsException();
    }
    nDrawText(mRenderer, text, start, end, x, y, paint.mBidiFlags, paint.mNativePaint, paint.mNativeTypeface);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,"2,4",2,5,1,"The API implementation in the late version has a new dependent API nDrawText() with an additional parameter paint.mNativeTypeface, so the code change type is 5.","The additional parameter paint.mNativeTypeface in nDrawText() method could potentially cause the API to return a different value or type, so the CI type is 1."
685,<android.content.pm.ShortcutInfo.Builder: Builder setActivity(ComponentName)>,29,30,<android.content.pm.ShortcutInfo.Builder: Builder setActivity(ComponentName)>,<android.content.pm.ShortcutInfo.Builder: Builder setActivity(ComponentName)>,0,"{
    mActivity = Preconditions.checkNotNull(activity, ""activity cannot be null"");
    return this;
}","{
    mActivity = Objects.requireNonNull(activity, ""activity cannot be null"");
    return this;
}",1,"/**
 * Sets the target activity.  A shortcut will be shown along with this activity's icon
 * on the launcher.
 *
 * When selecting a target activity, keep the following in mind:
 * <ul>
 * <li>All dynamic shortcuts must have a target activity.  When a shortcut with no target
 * activity is published using
 * {@link ShortcutManager#addDynamicShortcuts(List)} or
 * {@link ShortcutManager#setDynamicShortcuts(List)},
 * the first main activity defined in the app's <code>AndroidManifest.xml</code>
 * file is used.
 *
 * <li>Only ""main"" activities&mdash;ones that define the {@link Intent#ACTION_MAIN}
 * and {@link Intent#CATEGORY_LAUNCHER} intent filters&mdash;can be target
 * activities.
 *
 * <li>By default, the first main activity defined in the app's manifest is
 * the target activity.
 *
 * <li>A target activity must belong to the publisher app.
 * </ul>
 *
 * @see ShortcutInfo#getActivity()
 */
","/**
 * Sets the target activity.  A shortcut will be shown along with this activity's icon
 * on the launcher.
 *
 * When selecting a target activity, keep the following in mind:
 * <ul>
 * <li>All dynamic shortcuts must have a target activity.  When a shortcut with no target
 * activity is published using
 * {@link ShortcutManager#addDynamicShortcuts(List)} or
 * {@link ShortcutManager#setDynamicShortcuts(List)},
 * the first main activity defined in the app's <code>AndroidManifest.xml</code>
 * file is used.
 *
 * <li>Only ""main"" activities&mdash;ones that define the {@link Intent#ACTION_MAIN}
 * and {@link Intent#CATEGORY_LAUNCHER} intent filters&mdash;can be target
 * activities.
 *
 * <li>By default, the first main activity defined in the app's manifest is
 * the target activity.
 *
 * <li>A target activity must belong to the publisher app.
 * </ul>
 *
 * @see ShortcutInfo#getActivity()
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,4,0,4,0,"The implementation of the null check for the argument ""activity"" has been changed from ""Preconditions.checkNotNull"" to ""Objects.requireNonNull"". This is an ""other statement changed"" since it does not fall under return statement, exception handling, or control dependency changes.","The change in the null check implementation does not affect the behavior of the API. It still checks if the activity is null and throws a NullPointerException if it is, so there is no compatibility issue."
2,"<android.util.LongSparseArray: void setValueAt(int,E)>",28,29,"<android.util.LongSparseArray: void setValueAt(int,E)>","<android.util.LongSparseArray: void setValueAt(int,E)>",0,"{
    if (mGarbage) {
        gc();
    }
    mValues[index] = value;
}","{
    if (index >= mSize && UtilConfig.sThrowExceptionForUpperArrayOutOfBounds) {
        // Check if exception should be thrown outside of the critical path.
        throw new ArrayIndexOutOfBoundsException(index);
    }
    if (mGarbage) {
        gc();
    }
    mValues[index] = value;
}",1,"/**
 * Given an index in the range <code>0...size()-1</code>, sets a new
 * value for the <code>index</code>th key-value mapping that this
 * LongSparseArray stores.
 */
","/**
 * Given an index in the range <code>0...size()-1</code>, sets a new
 * value for the <code>index</code>th key-value mapping that this
 * LongSparseArray stores.
 *
 * <p>For indices outside of the range <code>0...size()-1</code>, the behavior is undefined for
 * apps targeting {@link android.os.Build.VERSION_CODES#P} and earlier, and an
 * {@link ArrayIndexOutOfBoundsException} is thrown for apps targeting
 * {@link android.os.Build.VERSION_CODES#Q} and later.</p>
 */
",-1,,,-1,-1,-1,-1,-1,"2,3,4",2,"3,2",2,"The late implementation includes a new conditional statement that throws an ArrayIndexOutOfBoundsException if index is greater than or equal to mSize and UtilConfig.sThrowExceptionForUpperArrayOutOfBounds is true. Therefore, the code change type is 3 (control dependency changed) and 2 (exception handling statement changed).","The new conditional statement in the late implementation can potentially throw an ArrayIndexOutOfBoundsException which did not exist in the early implementation. This could cause a compatibility issue as the behavior of the API could change when the exception is thrown. Therefore, the CI type is 2 (Compatibility Issue caused by potential different exception handlings)."
1053,"<android.content.res.AssetManager: XmlBlock openXmlBlockAsset(int,String)>",20,21,"<android.content.res.AssetManager: XmlBlock openXmlBlockAsset(int,String)>","<android.content.res.AssetManager: XmlBlock openXmlBlockAsset(int,String)>",0,"{
    synchronized (this) {
        if (!mOpen) {
            throw new RuntimeException(""Assetmanager has been closed"");
        }
        int xmlBlock = openXmlAssetNative(cookie, fileName);
        if (xmlBlock != 0) {
            XmlBlock res = new XmlBlock(this, xmlBlock);
            incRefsLocked(res.hashCode());
            return res;
        }
    }
    throw new FileNotFoundException(""Asset XML file: "" + fileName);
}","{
    synchronized (this) {
        if (!mOpen) {
            throw new RuntimeException(""Assetmanager has been closed"");
        }
        long xmlBlock = openXmlAssetNative(cookie, fileName);
        if (xmlBlock != 0) {
            XmlBlock res = new XmlBlock(this, xmlBlock);
            incRefsLocked(res.hashCode());
            return res;
        }
    }
    throw new FileNotFoundException(""Asset XML file: "" + fileName);
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,4,0,1,1,The return type of the method openXmlAssetNative has changed from int to long. This leads to the variable "xmlBlock" being assigned a different type.,"The method ""openXmlAssetNative"" returns a value that is used to construct a new ""XmlBlock"" object. The change in the return type could potentially lead to a different value being used to construct the XmlBlock object. Therefore, the API could return a different object in the late version, causing a compatibility issue."
