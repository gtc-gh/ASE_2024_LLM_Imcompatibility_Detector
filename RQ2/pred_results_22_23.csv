Number,Signature,Early_Version,Late_Version,Early_Signature,Late_Signature,Diff_Signature,Early_Implementation,Late_Implementation,Diff_Implementation,Early_Comment,Late_Comment,Diff_Comment,Early_Annotation,Late_Annotation,Diff_Annotation,Early_Callback,Late_Callback,Diff_Callback,GT_CI_ControlFlow,GT_CI_Type,pred_change,pred_CI,change_description,CI_description
1,"<android.app.admin.DevicePolicyManager: void setMaximumTimeToLock(ComponentName,long)>",22,23,"<android.app.admin.DevicePolicyManager: void setMaximumTimeToLock(ComponentName,long)>","<android.app.admin.DevicePolicyManager: void setMaximumTimeToLock(ComponentName,long)>",0,"{
    if (mService != null) {
        try {
            mService.setMaximumTimeToLock(admin, timeMs, UserHandle.myUserId());
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    if (mService != null) {
        try {
            mService.setMaximumTimeToLock(admin, timeMs);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}",1,"/**
 * Called by an application that is administering the device to set the
 * maximum time for user activity until the device will lock.  This limits
 * the length that the user can set.  It takes effect immediately.
 *
 * <p>The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_FORCE_LOCK} to be able to call
 * this method; if it has not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param timeMs The new desired maximum time to lock in milliseconds.
 * A value of 0 means there is no restriction.
 */
","/**
 * Called by an application that is administering the device to set the
 * maximum time for user activity until the device will lock.  This limits
 * the length that the user can set.  It takes effect immediately.
 *
 * <p>The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_FORCE_LOCK} to be able to call
 * this method; if it has not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param timeMs The new desired maximum time to lock in milliseconds.
 * A value of 0 means there is no restriction.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The change is in the dependent API where the number of parameters of mService.setMaximumTimeToLock method has changed from 3 parameters to 2 parameters. Therefore, the code change type is 5.","There's no compatibility issue with this change because the exception and return behavior for the calling code is not altered by this parameter change in the dependent API call within the method. Hence, there's no potential difference in value returned nor exception handling introduced. The method still does not provide a return value nor does it throw a checked exception; it simply logs the error if one occurs. The clients of this API would not need to change their code unless they were using a mocked version of DevicePolicyManager that expected the three-parameter version of setMaximumTimeToLock."
2,<android.widget.SimpleMonthView: boolean dispatchHoverEvent(MotionEvent)>,22,23,<android.widget.SimpleMonthView: boolean dispatchHoverEvent(MotionEvent)>,<android.widget.SimpleMonthView: boolean dispatchHoverEvent(MotionEvent)>,0,"{
    // First right-of-refusal goes the touch exploration helper.
    if (mTouchHelper.dispatchHoverEvent(event)) {
        return true;
    }
    return super.dispatchHoverEvent(event);
}","{
    // First right-of-refusal goes the touch exploration helper.
    return mTouchHelper.dispatchHoverEvent(event) || super.dispatchHoverEvent(event);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The change is the refactoring of two return statements into one using the logical OR operator. This does not change the functionality as the logical OR operation in Java will return true if the first operand is true, otherwise it will evaluate the second operand (short-circuit evaluation), which is the previous behavior.","There is no Compatibility Issue since the method still returns true if `mTouchHelper.dispatchHoverEvent(event)` is true, and otherwise calls and returns the result of `super.dispatchHoverEvent(event)`. The behavior remains functionally identical."
4,<android.hardware.camera2.params.StreamConfigurationMap: Size[] getOutputSizes(Class<T>)>,22,23,<android.hardware.camera2.params.StreamConfigurationMap: Size[] getOutputSizes(Class<T>)>,<android.hardware.camera2.params.StreamConfigurationMap: Size[] getOutputSizes(Class<T>)>,0,"{
    // Image reader is ""supported"", but never for implementation-defined formats; return empty
    if (android.media.ImageReader.class.isAssignableFrom(klass)) {
        return new Size[0];
    }
    if (isOutputSupportedFor(klass) == false) {
        return null;
    }
    return getInternalFormatSizes(HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED, /*output*/
    true);
}","{
    if (isOutputSupportedFor(klass) == false) {
        return null;
    }
    return getInternalFormatSizes(HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED, HAL_DATASPACE_UNKNOWN, /*output*/
    true, /*highRes*/
    false);
}",1,"/**
 * Get a list of sizes compatible with {@code klass} to use as an output.
 *
 * <p>Since some of the supported classes may support additional formats beyond
 * an opaque/implementation-defined (under-the-hood) format; this function only returns
 * sizes for the implementation-defined format.</p>
 *
 * <p>Some classes such as {@link android.media.ImageReader} may only support user-defined
 * formats; in particular {@link #isOutputSupportedFor(Class)} will return {@code true} for
 * that class and this method will return an empty array (but not {@code null}).</p>
 *
 * <p>If a well-defined format such as {@code NV21} is required, use
 * {@link #getOutputSizes(int)} instead.</p>
 *
 * <p>The {@code klass} should be a supported output, that querying
 * {@code #isOutputSupportedFor(Class)} should return {@code true}.</p>
 *
 * @param klass
 * a non-{@code null} {@link Class} object reference
 * @return
 * an array of supported sizes for implementation-defined formats,
 * or {@code null} iff the {@code klass} is not a supported output
 *
 * @throws NullPointerException if {@code klass} was {@code null}
 *
 * @see #isOutputSupportedFor(Class)
 */
","/**
 * Get a list of sizes compatible with {@code klass} to use as an output.
 *
 * <p>Some of the supported classes may support additional formats beyond
 * {@link ImageFormat#PRIVATE}; this function only returns
 * sizes for {@link ImageFormat#PRIVATE}. For example, {@link android.media.ImageReader}
 * supports {@link ImageFormat#YUV_420_888} and {@link ImageFormat#PRIVATE}, this method will
 * only return the sizes for {@link ImageFormat#PRIVATE} for {@link android.media.ImageReader}
 * class.</p>
 *
 * <p>If a well-defined format such as {@code NV21} is required, use
 * {@link #getOutputSizes(int)} instead.</p>
 *
 * <p>The {@code klass} should be a supported output, that querying
 * {@code #isOutputSupportedFor(Class)} should return {@code true}.</p>
 *
 * @param klass
 * a non-{@code null} {@link Class} object reference
 * @return
 * an array of supported sizes for {@link ImageFormat#PRIVATE} format,
 * or {@code null} iff the {@code klass} is not a supported output.
 *
 * @throws NullPointerException if {@code klass} was {@code null}
 *
 * @see #isOutputSupportedFor(Class)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,5",1,"The condition check for `android.media.ImageReader.class.isAssignableFrom(klass)` and its associated return statement `return new Size[0]` have been removed. Besides that, the call to the method `getInternalFormatSizes` has an additional parameter in the late version. Therefore, the code change includes return statement changed (1), control dependency changed due to the removed if statement (3), and dependent API changed because of the added parameter to an existing method (5).","The removal of the previously conditional return statement (`return new Size[0]`) can lead to a different return value when `android.media.ImageReader.class.isAssignableFrom(klass)` is true. Previously, it would return an empty array, but now it will proceed to the next logic. The addition of the new parameter in the `getInternalFormatSizes` method call means the function being called might behave differently or return different values, which might impact the array returned. Therefore, there is a potential for return values to be different, meaning the type is 1."
7,"<android.hardware.SensorManager: boolean getRotationMatrix(float[],float[],float[],float[])>",22,23,"<android.hardware.SensorManager: boolean getRotationMatrix(float[],float[],float[],float[])>","<android.hardware.SensorManager: boolean getRotationMatrix(float[],float[],float[],float[])>",0,"{
    // TODO: move this to native code for efficiency
    float Ax = gravity[0];
    float Ay = gravity[1];
    float Az = gravity[2];
    final float Ex = geomagnetic[0];
    final float Ey = geomagnetic[1];
    final float Ez = geomagnetic[2];
    float Hx = Ey * Az - Ez * Ay;
    float Hy = Ez * Ax - Ex * Az;
    float Hz = Ex * Ay - Ey * Ax;
    final float normH = (float) Math.sqrt(Hx * Hx + Hy * Hy + Hz * Hz);
    if (normH < 0.1f) {
        // magnetic north pole. Typical values are  > 100.
        return false;
    }
    final float invH = 1.0f / normH;
    Hx *= invH;
    Hy *= invH;
    Hz *= invH;
    final float invA = 1.0f / (float) Math.sqrt(Ax * Ax + Ay * Ay + Az * Az);
    Ax *= invA;
    Ay *= invA;
    Az *= invA;
    final float Mx = Ay * Hz - Az * Hy;
    final float My = Az * Hx - Ax * Hz;
    final float Mz = Ax * Hy - Ay * Hx;
    if (R != null) {
        if (R.length == 9) {
            R[0] = Hx;
            R[1] = Hy;
            R[2] = Hz;
            R[3] = Mx;
            R[4] = My;
            R[5] = Mz;
            R[6] = Ax;
            R[7] = Ay;
            R[8] = Az;
        } else if (R.length == 16) {
            R[0] = Hx;
            R[1] = Hy;
            R[2] = Hz;
            R[3] = 0;
            R[4] = Mx;
            R[5] = My;
            R[6] = Mz;
            R[7] = 0;
            R[8] = Ax;
            R[9] = Ay;
            R[10] = Az;
            R[11] = 0;
            R[12] = 0;
            R[13] = 0;
            R[14] = 0;
            R[15] = 1;
        }
    }
    if (I != null) {
        // compute the inclination matrix by projecting the geomagnetic
        // vector onto the Z (gravity) and X (horizontal component
        // of geomagnetic vector) axes.
        final float invE = 1.0f / (float) Math.sqrt(Ex * Ex + Ey * Ey + Ez * Ez);
        final float c = (Ex * Mx + Ey * My + Ez * Mz) * invE;
        final float s = (Ex * Ax + Ey * Ay + Ez * Az) * invE;
        if (I.length == 9) {
            I[0] = 1;
            I[1] = 0;
            I[2] = 0;
            I[3] = 0;
            I[4] = c;
            I[5] = s;
            I[6] = 0;
            I[7] = -s;
            I[8] = c;
        } else if (I.length == 16) {
            I[0] = 1;
            I[1] = 0;
            I[2] = 0;
            I[4] = 0;
            I[5] = c;
            I[6] = s;
            I[8] = 0;
            I[9] = -s;
            I[10] = c;
            I[3] = I[7] = I[11] = I[12] = I[13] = I[14] = 0;
            I[15] = 1;
        }
    }
    return true;
}","{
    // TODO: move this to native code for efficiency
    float Ax = gravity[0];
    float Ay = gravity[1];
    float Az = gravity[2];
    final float normsqA = (Ax * Ax + Ay * Ay + Az * Az);
    final float g = 9.81f;
    final float freeFallGravitySquared = 0.01f * g * g;
    if (normsqA < freeFallGravitySquared) {
        // gravity less than 10% of normal value
        return false;
    }
    final float Ex = geomagnetic[0];
    final float Ey = geomagnetic[1];
    final float Ez = geomagnetic[2];
    float Hx = Ey * Az - Ez * Ay;
    float Hy = Ez * Ax - Ex * Az;
    float Hz = Ex * Ay - Ey * Ax;
    final float normH = (float) Math.sqrt(Hx * Hx + Hy * Hy + Hz * Hz);
    if (normH < 0.1f) {
        // magnetic north pole. Typical values are  > 100.
        return false;
    }
    final float invH = 1.0f / normH;
    Hx *= invH;
    Hy *= invH;
    Hz *= invH;
    final float invA = 1.0f / (float) Math.sqrt(Ax * Ax + Ay * Ay + Az * Az);
    Ax *= invA;
    Ay *= invA;
    Az *= invA;
    final float Mx = Ay * Hz - Az * Hy;
    final float My = Az * Hx - Ax * Hz;
    final float Mz = Ax * Hy - Ay * Hx;
    if (R != null) {
        if (R.length == 9) {
            R[0] = Hx;
            R[1] = Hy;
            R[2] = Hz;
            R[3] = Mx;
            R[4] = My;
            R[5] = Mz;
            R[6] = Ax;
            R[7] = Ay;
            R[8] = Az;
        } else if (R.length == 16) {
            R[0] = Hx;
            R[1] = Hy;
            R[2] = Hz;
            R[3] = 0;
            R[4] = Mx;
            R[5] = My;
            R[6] = Mz;
            R[7] = 0;
            R[8] = Ax;
            R[9] = Ay;
            R[10] = Az;
            R[11] = 0;
            R[12] = 0;
            R[13] = 0;
            R[14] = 0;
            R[15] = 1;
        }
    }
    if (I != null) {
        // compute the inclination matrix by projecting the geomagnetic
        // vector onto the Z (gravity) and X (horizontal component
        // of geomagnetic vector) axes.
        final float invE = 1.0f / (float) Math.sqrt(Ex * Ex + Ey * Ey + Ez * Ez);
        final float c = (Ex * Mx + Ey * My + Ez * Mz) * invE;
        final float s = (Ex * Ax + Ey * Ay + Ez * Az) * invE;
        if (I.length == 9) {
            I[0] = 1;
            I[1] = 0;
            I[2] = 0;
            I[3] = 0;
            I[4] = c;
            I[5] = s;
            I[6] = 0;
            I[7] = -s;
            I[8] = c;
        } else if (I.length == 16) {
            I[0] = 1;
            I[1] = 0;
            I[2] = 0;
            I[4] = 0;
            I[5] = c;
            I[6] = s;
            I[8] = 0;
            I[9] = -s;
            I[10] = c;
            I[3] = I[7] = I[11] = I[12] = I[13] = I[14] = 0;
            I[15] = 1;
        }
    }
    return true;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
9,"<android.app.FragmentManagerImpl: void moveToState(int,int,int,boolean)>",22,23,"<android.app.FragmentManagerImpl: void moveToState(int,int,int,boolean)>","<android.app.FragmentManagerImpl: void moveToState(int,int,int,boolean)>",0,"{
    if (mActivity == null && newState != Fragment.INITIALIZING) {
        throw new IllegalStateException(""No activity"");
    }
    if (!always && mCurState == newState) {
        return;
    }
    mCurState = newState;
    if (mActive != null) {
        boolean loadersRunning = false;
        for (int i = 0; i < mActive.size(); i++) {
            Fragment f = mActive.get(i);
            if (f != null) {
                moveToState(f, newState, transit, transitStyle, false);
                if (f.mLoaderManager != null) {
                    loadersRunning |= f.mLoaderManager.hasRunningLoaders();
                }
            }
        }
        if (!loadersRunning) {
            startPendingDeferredFragments();
        }
        if (mNeedMenuInvalidate && mActivity != null && mCurState == Fragment.RESUMED) {
            mActivity.invalidateOptionsMenu();
            mNeedMenuInvalidate = false;
        }
    }
}","{
    if (mHost == null && newState != Fragment.INITIALIZING) {
        throw new IllegalStateException(""No activity"");
    }
    if (!always && mCurState == newState) {
        return;
    }
    mCurState = newState;
    if (mActive != null) {
        boolean loadersRunning = false;
        for (int i = 0; i < mActive.size(); i++) {
            Fragment f = mActive.get(i);
            if (f != null) {
                moveToState(f, newState, transit, transitStyle, false);
                if (f.mLoaderManager != null) {
                    loadersRunning |= f.mLoaderManager.hasRunningLoaders();
                }
            }
        }
        if (!loadersRunning) {
            startPendingDeferredFragments();
        }
        if (mNeedMenuInvalidate && mHost != null && mCurState == Fragment.RESUMED) {
            mHost.onInvalidateOptionsMenu();
            mNeedMenuInvalidate = false;
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",0,There are three changes in the code:,2. The method call `mActivity.invalidateOptionsMenu();` is replaced by `mHost.onInvalidateOptionsMenu();`.
11,<android.animation.AnimatorSet.Node: Node clone()>,22,23,<android.animation.AnimatorSet.Node: Node clone()>,<android.animation.AnimatorSet.Node: Node clone()>,0,"{
    try {
        Node node = (Node) super.clone();
        node.animation = (Animator) animation.clone();
        return node;
    } catch (CloneNotSupportedException e) {
        throw new AssertionError();
    }
}","{
    try {
        Node node = (Node) super.clone();
        node.animation = animation.clone();
        node.done = false;
        return node;
    } catch (CloneNotSupportedException e) {
        throw new AssertionError();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"There's a new assignment statement (node.done = false;) in the late implementation version, and although the type casting for animation.clone() is removed, the behavior is not altered by this because the method clone() still is expected to return the correct type. So, there's a change in terms of Other statement changed (4) and Return statement changed (1).","The new assignment (node.done = false) will affect the state of the cloned `Node` object, potentially leading to a change in the behavior of the `Node` class instance when the `clone` method is used. This constitutes a CI due to the potential different return values caused by the additional initialization of the 'done' field (1)."
15,"<android.accounts.AccountManager: AccountManagerFuture<Boolean> hasFeatures(Account,String[],AccountManagerCallback<Boolean>,Handler)>",22,23,"<android.accounts.AccountManager: AccountManagerFuture<Boolean> hasFeatures(Account,String[],AccountManagerCallback<Boolean>,Handler)>","<android.accounts.AccountManager: AccountManagerFuture<Boolean> hasFeatures(Account,String[],AccountManagerCallback<Boolean>,Handler)>",0,"{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    if (features == null)
        throw new IllegalArgumentException(""features is null"");
    return new Future2Task<Boolean>(handler, callback) {

        public void doWork() throws RemoteException {
            mService.hasFeatures(mResponse, account, features);
        }

        public Boolean bundleToResult(Bundle bundle) throws AuthenticatorException {
            if (!bundle.containsKey(KEY_BOOLEAN_RESULT)) {
                throw new AuthenticatorException(""no result in response"");
            }
            return bundle.getBoolean(KEY_BOOLEAN_RESULT);
        }
    }.start();
}","{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    if (features == null)
        throw new IllegalArgumentException(""features is null"");
    return new Future2Task<Boolean>(handler, callback) {

        public void doWork() throws RemoteException {
            mService.hasFeatures(mResponse, account, features, mContext.getOpPackageName());
        }

        public Boolean bundleToResult(Bundle bundle) throws AuthenticatorException {
            if (!bundle.containsKey(KEY_BOOLEAN_RESULT)) {
                throw new AuthenticatorException(""no result in response"");
            }
            return bundle.getBoolean(KEY_BOOLEAN_RESULT);
        }
    }.start();
}",1,"/**
 * Finds out whether a particular account has all the specified features.
 * Account features are authenticator-specific string tokens identifying
 * boolean account properties.  For example, features are used to tell
 * whether Google accounts have a particular service (such as Google
 * Calendar or Google Talk) enabled.  The feature names and their meanings
 * are published somewhere associated with the authenticator in question.
 *
 * <p>This method may be called from any thread, but the returned
 * {@link AccountManagerFuture} must not be used on the main thread.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#GET_ACCOUNTS}.
 *
 * @param account The {@link Account} to test
 * @param features An array of the account features to check
 * @param callback Callback to invoke when the request completes,
 * null for no callback
 * @param handler {@link Handler} identifying the callback thread,
 * null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Boolean,
 * true if the account exists and has all of the specified features.
 */
","/**
 * Finds out whether a particular account has all the specified features.
 * Account features are authenticator-specific string tokens identifying
 * boolean account properties.  For example, features are used to tell
 * whether Google accounts have a particular service (such as Google
 * Calendar or Google Talk) enabled.  The feature names and their meanings
 * are published somewhere associated with the authenticator in question.
 *
 * <p>This method may be called from any thread, but the returned
 * {@link AccountManagerFuture} must not be used on the main thread.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#GET_ACCOUNTS} or be a signature
 * match with the AbstractAccountAuthenticator that manages the account.
 *
 * @param account The {@link Account} to test
 * @param features An array of the account features to check
 * @param callback Callback to invoke when the request completes,
 * null for no callback
 * @param handler {@link Handler} identifying the callback thread,
 * null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Boolean,
 * true if the account exists and has all of the specified features.
 */
",-1,,[@RequiresPermission(GET_ACCOUNTS)],-1,-1,-1,-1,-1,-1,"4,5",0,"The method mService.hasFeatures now includes an additional parameter, mContext.getOpPackageName(), so the code change type is 4,5 due to the change in the method signature of the dependent API.","While the dependent API mService.hasFeatures has an additional parameter in the late version, it does not lead to a Compatibility Issue since it does not change the behavior of how the result is obtained or how exceptions are handled within the current API method. There is no change in the control flow or the expected return value or exception handling. The new parameter is used to provide additional context for the API call but does not affect the return type or the outcome, assuming that mContext.getOpPackageName() returns a valid package name as part of the normal operation. Therefore, there's no CI detected."
16,"<android.text.TextDirectionHeuristics.AnyStrong: int checkRtl(CharSequence,int,int)>",22,23,"<android.text.TextDirectionHeuristics.AnyStrong: int checkRtl(CharSequence,int,int)>","<android.text.TextDirectionHeuristics.AnyStrong: int checkRtl(CharSequence,int,int)>",0,"{
    boolean haveUnlookedFor = false;
    for (int i = start, e = start + count; i < e; ++i) {
        switch(isRtlText(Character.getDirectionality(cs.charAt(i)))) {
            case STATE_TRUE:
                if (mLookForRtl) {
                    return STATE_TRUE;
                }
                haveUnlookedFor = true;
                break;
            case STATE_FALSE:
                if (!mLookForRtl) {
                    return STATE_FALSE;
                }
                haveUnlookedFor = true;
                break;
            default:
                break;
        }
    }
    if (haveUnlookedFor) {
        return mLookForRtl ? STATE_FALSE : STATE_TRUE;
    }
    return STATE_UNKNOWN;
}","{
    boolean haveUnlookedFor = false;
    int openIsolateCount = 0;
    for (int cp, i = start, end = start + count; i < end; i += Character.charCount(cp)) {
        cp = Character.codePointAt(cs, i);
        if (0x2066 <= cp && cp <= 0x2068) {
            // Opening isolates
            openIsolateCount += 1;
        } else if (cp == 0x2069) {
            // POP DIRECTIONAL ISOLATE (PDI)
            if (openIsolateCount > 0)
                openIsolateCount -= 1;
        } else if (openIsolateCount == 0) {
            // Only consider the characters outside isolate pairs
            switch(isRtlCodePoint(cp)) {
                case STATE_TRUE:
                    if (mLookForRtl) {
                        return STATE_TRUE;
                    }
                    haveUnlookedFor = true;
                    break;
                case STATE_FALSE:
                    if (!mLookForRtl) {
                        return STATE_FALSE;
                    }
                    haveUnlookedFor = true;
                    break;
                default:
                    break;
            }
        }
    }
    if (haveUnlookedFor) {
        return mLookForRtl ? STATE_FALSE : STATE_TRUE;
    }
    return STATE_UNKNOWN;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"The for-loop's iteration mechanism has changed (it now uses Character's codePointAt and charCount methods), and additional control statements have been introduced (if-else structure to handle special unicode isolate characters). Hence, there are control dependency changes (3) and other statement changes (4) due to new variable declarations and the alterations in the loop.","The additional checks and changes in loop iteration logic may lead to a different pathway of execution which affects the value being returned. Specifically, the decision to return STATE_TRUE or STATE_FALSE could be influenced by the processing of unicode isolate pairs which wasn't considered in the early version. Hence, there's a potential Compatibility Issue of type 1, as the method could return a different value."
17,<android.hardware.camera2.CameraManager.CameraManagerGlobal: void binderDied()>,22,23,<android.hardware.camera2.CameraManager.CameraManagerGlobal: void binderDied()>,<android.hardware.camera2.CameraManager.CameraManagerGlobal: void binderDied()>,0,"{
    synchronized (mLock) {
        // Only do this once per service death
        if (mCameraService == null)
            return;
        mCameraService = null;
        // to listeners that previously in-use cameras are now available.
        for (int i = 0; i < mDeviceStatus.size(); i++) {
            String cameraId = mDeviceStatus.keyAt(i);
            onStatusChangedLocked(STATUS_PRESENT, cameraId);
        }
    }
}","{
    synchronized (mLock) {
        // Only do this once per service death
        if (mCameraService == null)
            return;
        mCameraService = null;
        // and torch statuses will be updated.
        for (int i = 0; i < mDeviceStatus.size(); i++) {
            String cameraId = mDeviceStatus.keyAt(i);
            onStatusChangedLocked(STATUS_NOT_PRESENT, cameraId);
        }
        for (int i = 0; i < mTorchStatus.size(); i++) {
            String cameraId = mTorchStatus.keyAt(i);
            onTorchStatusChangedLocked(TORCH_STATUS_NOT_AVAILABLE, cameraId);
        }
        scheduleCameraServiceReconnectionLocked();
    }
}",1,"/**
 * Listener for camera service death.
 *
 * <p>The camera service isn't supposed to die under any normal circumstances, but can be
 * turned off during debug, or crash due to bugs.  So detect that and null out the interface
 * object, so that the next calls to the manager can try to reconnect.</p>
 */
","/**
 * Listener for camera service death.
 *
 * <p>The camera service isn't supposed to die under any normal circumstances, but can be
 * turned off during debug, or crash due to bugs.  So detect that and null out the interface
 * object, so that the next calls to the manager can try to reconnect.</p>
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The control dependency has changed because an additional loop has been introduced to iterate over mTorchStatus, which was not present in the early version. Also, there is a new method call to scheduleCameraServiceReconnectionLocked(). It is a change in the body of the method outside the scope of control dependencies, so the code change type includes both 3 and 4.","Even though there are changes in the implementation details, such as updating torch status and scheduling camera service reconnection, these changes do not directly affect the return value or exception handling of the method. Because this method's return type is void and it does not have any exception statements, no compatibility issue should arise from this particular change, resulting in CI type 0."
19,<android.view.ScaleGestureDetector: boolean onTouchEvent(MotionEvent)>,22,23,<android.view.ScaleGestureDetector: boolean onTouchEvent(MotionEvent)>,<android.view.ScaleGestureDetector: boolean onTouchEvent(MotionEvent)>,0,"{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(event, 0);
    }
    mCurrTime = event.getEventTime();
    final int action = event.getActionMasked();
    // Forward the event to check for double tap gesture
    if (mQuickScaleEnabled) {
        mGestureDetector.onTouchEvent(event);
    }
    final boolean streamComplete = action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_CANCEL;
    if (action == MotionEvent.ACTION_DOWN || streamComplete) {
        // This means the app probably didn't give us all the events. Shame on it.
        if (mInProgress) {
            mListener.onScaleEnd(this);
            mInProgress = false;
            mInitialSpan = 0;
            mDoubleTapMode = DOUBLE_TAP_MODE_NONE;
        } else if (mDoubleTapMode == DOUBLE_TAP_MODE_IN_PROGRESS && streamComplete) {
            mInProgress = false;
            mInitialSpan = 0;
            mDoubleTapMode = DOUBLE_TAP_MODE_NONE;
        }
        if (streamComplete) {
            clearTouchHistory();
            return true;
        }
    }
    final boolean configChanged = action == MotionEvent.ACTION_DOWN || action == MotionEvent.ACTION_POINTER_UP || action == MotionEvent.ACTION_POINTER_DOWN;
    final boolean pointerUp = action == MotionEvent.ACTION_POINTER_UP;
    final int skipIndex = pointerUp ? event.getActionIndex() : -1;
    // Determine focal point
    float sumX = 0, sumY = 0;
    final int count = event.getPointerCount();
    final int div = pointerUp ? count - 1 : count;
    final float focusX;
    final float focusY;
    if (mDoubleTapMode == DOUBLE_TAP_MODE_IN_PROGRESS) {
        // In double tap mode, the focal pt is always where the double tap
        // gesture started
        focusX = mDoubleTapEvent.getX();
        focusY = mDoubleTapEvent.getY();
        if (event.getY() < focusY) {
            mEventBeforeOrAboveStartingGestureEvent = true;
        } else {
            mEventBeforeOrAboveStartingGestureEvent = false;
        }
    } else {
        for (int i = 0; i < count; i++) {
            if (skipIndex == i)
                continue;
            sumX += event.getX(i);
            sumY += event.getY(i);
        }
        focusX = sumX / div;
        focusY = sumY / div;
    }
    addTouchHistory(event);
    // Determine average deviation from focal point
    float devSumX = 0, devSumY = 0;
    for (int i = 0; i < count; i++) {
        if (skipIndex == i)
            continue;
        // Convert the resulting diameter into a radius.
        final float touchSize = mTouchHistoryLastAccepted / 2;
        devSumX += Math.abs(event.getX(i) - focusX) + touchSize;
        devSumY += Math.abs(event.getY(i) - focusY) + touchSize;
    }
    final float devX = devSumX / div;
    final float devY = devSumY / div;
    // Span is the average distance between touch points through the focal point;
    // i.e. the diameter of the circle with a radius of the average deviation from
    // the focal point.
    final float spanX = devX * 2;
    final float spanY = devY * 2;
    final float span;
    if (inDoubleTapMode()) {
        span = spanY;
    } else {
        span = FloatMath.sqrt(spanX * spanX + spanY * spanY);
    }
    // Dispatch begin/end events as needed.
    // If the configuration changes, notify the app to reset its current state by beginning
    // a fresh scale event stream.
    final boolean wasInProgress = mInProgress;
    mFocusX = focusX;
    mFocusY = focusY;
    if (!inDoubleTapMode() && mInProgress && (span < mMinSpan || configChanged)) {
        mListener.onScaleEnd(this);
        mInProgress = false;
        mInitialSpan = span;
        mDoubleTapMode = DOUBLE_TAP_MODE_NONE;
    }
    if (configChanged) {
        mPrevSpanX = mCurrSpanX = spanX;
        mPrevSpanY = mCurrSpanY = spanY;
        mInitialSpan = mPrevSpan = mCurrSpan = span;
    }
    final int minSpan = inDoubleTapMode() ? mSpanSlop : mMinSpan;
    if (!mInProgress && span >= minSpan && (wasInProgress || Math.abs(span - mInitialSpan) > mSpanSlop)) {
        mPrevSpanX = mCurrSpanX = spanX;
        mPrevSpanY = mCurrSpanY = spanY;
        mPrevSpan = mCurrSpan = span;
        mPrevTime = mCurrTime;
        mInProgress = mListener.onScaleBegin(this);
    }
    // Handle motion; focal point and span/scale factor are changing.
    if (action == MotionEvent.ACTION_MOVE) {
        mCurrSpanX = spanX;
        mCurrSpanY = spanY;
        mCurrSpan = span;
        boolean updatePrev = true;
        if (mInProgress) {
            updatePrev = mListener.onScale(this);
        }
        if (updatePrev) {
            mPrevSpanX = mCurrSpanX;
            mPrevSpanY = mCurrSpanY;
            mPrevSpan = mCurrSpan;
            mPrevTime = mCurrTime;
        }
    }
    return true;
}","{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(event, 0);
    }
    mCurrTime = event.getEventTime();
    final int action = event.getActionMasked();
    // Forward the event to check for double tap gesture
    if (mQuickScaleEnabled) {
        mGestureDetector.onTouchEvent(event);
    }
    final int count = event.getPointerCount();
    final boolean isStylusButtonDown = (event.getButtonState() & MotionEvent.BUTTON_STYLUS_PRIMARY) != 0;
    final boolean anchoredScaleCancelled = mAnchoredScaleMode == ANCHORED_SCALE_MODE_STYLUS && !isStylusButtonDown;
    final boolean streamComplete = action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_CANCEL || anchoredScaleCancelled;
    if (action == MotionEvent.ACTION_DOWN || streamComplete) {
        // This means the app probably didn't give us all the events. Shame on it.
        if (mInProgress) {
            mListener.onScaleEnd(this);
            mInProgress = false;
            mInitialSpan = 0;
            mAnchoredScaleMode = ANCHORED_SCALE_MODE_NONE;
        } else if (inAnchoredScaleMode() && streamComplete) {
            mInProgress = false;
            mInitialSpan = 0;
            mAnchoredScaleMode = ANCHORED_SCALE_MODE_NONE;
        }
        if (streamComplete) {
            clearTouchHistory();
            return true;
        }
    }
    if (!mInProgress && mStylusScaleEnabled && !inAnchoredScaleMode() && !streamComplete && isStylusButtonDown) {
        // Start of a button scale gesture
        mAnchoredScaleStartX = event.getX();
        mAnchoredScaleStartY = event.getY();
        mAnchoredScaleMode = ANCHORED_SCALE_MODE_STYLUS;
        mInitialSpan = 0;
    }
    final boolean configChanged = action == MotionEvent.ACTION_DOWN || action == MotionEvent.ACTION_POINTER_UP || action == MotionEvent.ACTION_POINTER_DOWN || anchoredScaleCancelled;
    final boolean pointerUp = action == MotionEvent.ACTION_POINTER_UP;
    final int skipIndex = pointerUp ? event.getActionIndex() : -1;
    // Determine focal point
    float sumX = 0, sumY = 0;
    final int div = pointerUp ? count - 1 : count;
    final float focusX;
    final float focusY;
    if (inAnchoredScaleMode()) {
        // In anchored scale mode, the focal pt is always where the double tap
        // or button down gesture started
        focusX = mAnchoredScaleStartX;
        focusY = mAnchoredScaleStartY;
        if (event.getY() < focusY) {
            mEventBeforeOrAboveStartingGestureEvent = true;
        } else {
            mEventBeforeOrAboveStartingGestureEvent = false;
        }
    } else {
        for (int i = 0; i < count; i++) {
            if (skipIndex == i)
                continue;
            sumX += event.getX(i);
            sumY += event.getY(i);
        }
        focusX = sumX / div;
        focusY = sumY / div;
    }
    addTouchHistory(event);
    // Determine average deviation from focal point
    float devSumX = 0, devSumY = 0;
    for (int i = 0; i < count; i++) {
        if (skipIndex == i)
            continue;
        // Convert the resulting diameter into a radius.
        final float touchSize = mTouchHistoryLastAccepted / 2;
        devSumX += Math.abs(event.getX(i) - focusX) + touchSize;
        devSumY += Math.abs(event.getY(i) - focusY) + touchSize;
    }
    final float devX = devSumX / div;
    final float devY = devSumY / div;
    // Span is the average distance between touch points through the focal point;
    // i.e. the diameter of the circle with a radius of the average deviation from
    // the focal point.
    final float spanX = devX * 2;
    final float spanY = devY * 2;
    final float span;
    if (inAnchoredScaleMode()) {
        span = spanY;
    } else {
        span = (float) Math.hypot(spanX, spanY);
    }
    // Dispatch begin/end events as needed.
    // If the configuration changes, notify the app to reset its current state by beginning
    // a fresh scale event stream.
    final boolean wasInProgress = mInProgress;
    mFocusX = focusX;
    mFocusY = focusY;
    if (!inAnchoredScaleMode() && mInProgress && (span < mMinSpan || configChanged)) {
        mListener.onScaleEnd(this);
        mInProgress = false;
        mInitialSpan = span;
    }
    if (configChanged) {
        mPrevSpanX = mCurrSpanX = spanX;
        mPrevSpanY = mCurrSpanY = spanY;
        mInitialSpan = mPrevSpan = mCurrSpan = span;
    }
    final int minSpan = inAnchoredScaleMode() ? mSpanSlop : mMinSpan;
    if (!mInProgress && span >= minSpan && (wasInProgress || Math.abs(span - mInitialSpan) > mSpanSlop)) {
        mPrevSpanX = mCurrSpanX = spanX;
        mPrevSpanY = mCurrSpanY = spanY;
        mPrevSpan = mCurrSpan = span;
        mPrevTime = mCurrTime;
        mInProgress = mListener.onScaleBegin(this);
    }
    // Handle motion; focal point and span/scale factor are changing.
    if (action == MotionEvent.ACTION_MOVE) {
        mCurrSpanX = spanX;
        mCurrSpanY = spanY;
        mCurrSpan = span;
        boolean updatePrev = true;
        if (mInProgress) {
            updatePrev = mListener.onScale(this);
        }
        if (updatePrev) {
            mPrevSpanX = mCurrSpanX;
            mPrevSpanY = mCurrSpanY;
            mPrevSpan = mCurrSpan;
            mPrevTime = mCurrTime;
        }
    }
    return true;
}",1,"/**
 * Accepts MotionEvents and dispatches events to a {@link OnScaleGestureListener}
 * when appropriate.
 *
 * <p>Applications should pass a complete and consistent event stream to this method.
 * A complete and consistent event stream involves all MotionEvents from the initial
 * ACTION_DOWN to the final ACTION_UP or ACTION_CANCEL.</p>
 *
 * @param event The event to process
 * @return true if the event was processed and the detector wants to receive the
 * rest of the MotionEvents in this event stream.
 */
","/**
 * Accepts MotionEvents and dispatches events to a {@link OnScaleGestureListener}
 * when appropriate.
 *
 * <p>Applications should pass a complete and consistent event stream to this method.
 * A complete and consistent event stream involves all MotionEvents from the initial
 * ACTION_DOWN to the final ACTION_UP or ACTION_CANCEL.</p>
 *
 * @param event The event to process
 * @return true if the event was processed and the detector wants to receive the
 * rest of the MotionEvents in this event stream.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
20,"<android.app.Notification.Builder: Builder setSmallIcon(int,int)>",22,23,"<android.app.Notification.Builder: Builder setSmallIcon(int,int)>","<android.app.Notification.Builder: Builder setSmallIcon(int,int)>",0,"{
    mSmallIcon = icon;
    mSmallIconLevel = level;
    return this;
}","{
    mSmallIconLevel = level;
    return setSmallIcon(icon);
}",1,"/**
 * A variant of {@link #setSmallIcon(int) setSmallIcon(int)} that takes an additional
 * level parameter for when the icon is a {@link android.graphics.drawable.LevelListDrawable
 * LevelListDrawable}.
 *
 * @param icon A resource ID in the application's package of the drawable to use.
 * @param level The level to use for the icon.
 *
 * @see Notification#icon
 * @see Notification#iconLevel
 */
","/**
 * A variant of {@link #setSmallIcon(int) setSmallIcon(int)} that takes an additional
 * level parameter for when the icon is a {@link android.graphics.drawable.LevelListDrawable
 * LevelListDrawable}.
 *
 * @param icon A resource ID in the application's package of the drawable to use.
 * @param level The level to use for the icon.
 *
 * @see Notification#icon
 * @see Notification#iconLevel
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The early version directly assigns values to mSmallIcon and mSmallIconLevel, while the late version assigns a value to mSmallIconLevel and delegates the assignment of mSmallIcon to the setSmallIcon method. The direct modification has been replaced by an indirect modification through a dependent method call, so the change type is 4,5.","Although the implementation has been refactored, it doesn't introduce a compatibility issue, assuming that the setSmallIcon method being called in the late version performs the equivalent action as the direct assignment in the early version. Thus, the changes made would not result in different return values or throw exceptions differently assuming the setSmallIcon method behaves consistently, so the CI type is 0."
21,<android.app.admin.DevicePolicyManager: boolean isAdminActive(ComponentName)>,22,23,<android.app.admin.DevicePolicyManager: boolean isAdminActive(ComponentName)>,<android.app.admin.DevicePolicyManager: boolean isAdminActive(ComponentName)>,0,"{
    return isAdminActiveAsUser(who, UserHandle.myUserId());
}","{
    return isAdminActiveAsUser(admin, UserHandle.myUserId());
}",1,"/**
 * Return true if the given administrator component is currently
 * active (enabled) in the system.
 */
","/**
 * Return true if the given administrator component is currently
 * active (enabled) in the system.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The parameter for the method call to isAdminActiveAsUser() has changed from 'who' to 'admin', but it seems to be a simple variable rename with no functional change to the method's behavior.",No Compatibility Issue is detected since it appears to be a renaming of the variable which is passed to another method without changing its behavior or the method's contract.
23,"<android.content.ContentProviderClient: Uri insert(Uri,ContentValues)>",22,23,"<android.content.ContentProviderClient: Uri insert(Uri,ContentValues)>","<android.content.ContentProviderClient: Uri insert(Uri,ContentValues)>",0,"{
    beforeRemote();
    try {
        return mContentProvider.insert(mPackageName, url, initialValues);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}","{
    Preconditions.checkNotNull(url, ""url"");
    beforeRemote();
    try {
        return mContentProvider.insert(mPackageName, url, initialValues);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}",1,"/**
 * See {@link ContentProvider#insert ContentProvider.insert}
 */
","/**
 * See {@link ContentProvider#insert ContentProvider.insert}
 */
",-1,,[@Nullable],-1,-1,-1,-1,-1,-1,4,0,"The early and late versions include an added call to Preconditions.checkNotNull(url, ""url""); this is an additional statement that does not affect the control flow or exception handling or modifies the return statement of the API. Therefore, the code change type is 4.","The additional call to Preconditions.checkNotNull() will cause an early throw of a NullPointerException if the 'url' parameter is null. However, since this check strengthens the precondition of the method, it does not constitute a compatibility issue because it is preventing subsequent operations with a null 'url' that would likely result in an error or exception anyway. Therefore, the Compatibility Issue is 0, as it does not lead to different return values or change the exception handling that would affect API consumers who are using the API correctly (i.e., not passing a null 'url')."
27,<android.widget.FastScroller: void updateLayout()>,22,23,<android.widget.FastScroller: void updateLayout()>,<android.widget.FastScroller: void updateLayout()>,0,"{
    // resolving padding.
    if (mUpdatingLayout) {
        return;
    }
    mUpdatingLayout = true;
    updateContainerRect();
    layoutThumb();
    layoutTrack();
    final Rect bounds = mTempBounds;
    measurePreview(mPrimaryText, bounds);
    applyLayout(mPrimaryText, bounds);
    measurePreview(mSecondaryText, bounds);
    applyLayout(mSecondaryText, bounds);
    if (mPreviewImage != null) {
        // Apply preview image padding.
        bounds.left -= mPreviewImage.getPaddingLeft();
        bounds.top -= mPreviewImage.getPaddingTop();
        bounds.right += mPreviewImage.getPaddingRight();
        bounds.bottom += mPreviewImage.getPaddingBottom();
        applyLayout(mPreviewImage, bounds);
    }
    mUpdatingLayout = false;
}","{
    // resolving padding.
    if (mUpdatingLayout) {
        return;
    }
    mUpdatingLayout = true;
    updateContainerRect();
    layoutThumb();
    layoutTrack();
    updateOffsetAndRange();
    final Rect bounds = mTempBounds;
    measurePreview(mPrimaryText, bounds);
    applyLayout(mPrimaryText, bounds);
    measurePreview(mSecondaryText, bounds);
    applyLayout(mSecondaryText, bounds);
    if (mPreviewImage != null) {
        // Apply preview image padding.
        bounds.left -= mPreviewImage.getPaddingLeft();
        bounds.top -= mPreviewImage.getPaddingTop();
        bounds.right += mPreviewImage.getPaddingRight();
        bounds.bottom += mPreviewImage.getPaddingBottom();
        applyLayout(mPreviewImage, bounds);
    }
    mUpdatingLayout = false;
}",1,"/**
 * Measures and layouts the scrollbar and decorations.
 */
","/**
 * Measures and layouts the scrollbar and decorations.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"A new method call has been introduced (updateOffsetAndRange()), however, it does not change the API's return type or value, nor does it introduce any different exception handling, so the change type is 4.","As the added method call does not affect the return type or value and no different exception handling is introduced, it does not cause a Compatibility Issue, so the CI type is 0."
28,<android.hardware.camera2.impl.CameraCaptureSessionImpl: StateCallbackKK getDeviceStateCallback()>,22,23,<android.hardware.camera2.impl.CameraCaptureSessionImpl: StateCallbackKK getDeviceStateCallback()>,<android.hardware.camera2.impl.CameraCaptureSessionImpl: StateCallbackKK getDeviceStateCallback()>,0,"{
    final CameraCaptureSession session = this;
    return new CameraDeviceImpl.StateCallbackKK() {

        private boolean mBusy = false;

        private boolean mActive = false;

        @Override
        public void onOpened(CameraDevice camera) {
            throw new AssertionError(""Camera must already be open before creating a session"");
        }

        @Override
        public void onDisconnected(CameraDevice camera) {
            if (VERBOSE)
                Log.v(TAG, mIdString + ""onDisconnected"");
            close();
        }

        @Override
        public void onError(CameraDevice camera, int error) {
            // Should not be reached, handled by device code
            Log.wtf(TAG, mIdString + ""Got device error "" + error);
        }

        @Override
        public void onActive(CameraDevice camera) {
            mIdleDrainer.taskStarted();
            mActive = true;
            if (VERBOSE)
                Log.v(TAG, mIdString + ""onActive"");
            mStateCallback.onActive(session);
        }

        @Override
        public void onIdle(CameraDevice camera) {
            boolean isAborting;
            if (VERBOSE)
                Log.v(TAG, mIdString + ""onIdle"");
            synchronized (session) {
                isAborting = mAborting;
            }
            /*
                 * Check which states we transitioned through:
                 *
                 * (ACTIVE -> IDLE)
                 * (BUSY -> IDLE)
                 *
                 * Note that this is also legal:
                 * (ACTIVE -> BUSY -> IDLE)
                 *
                 * and mark those tasks as finished
                 */
            if (mBusy && isAborting) {
                mAbortDrainer.taskFinished();
                synchronized (session) {
                    mAborting = false;
                }
            }
            if (mActive) {
                mIdleDrainer.taskFinished();
            }
            mBusy = false;
            mActive = false;
            mStateCallback.onReady(session);
        }

        @Override
        public void onBusy(CameraDevice camera) {
            mBusy = true;
            // Don't signal the application since there's no clean mapping here
            if (VERBOSE)
                Log.v(TAG, mIdString + ""onBusy"");
        }

        @Override
        public void onUnconfigured(CameraDevice camera) {
            if (VERBOSE)
                Log.v(TAG, mIdString + ""onUnconfigured"");
            synchronized (session) {
                // guard with mSkipUnconfigure
                if (mClosed && mConfigureSuccess && !mSkipUnconfigure) {
                    mUnconfigureDrainer.taskFinished();
                }
            }
        }
    };
}","{
    final CameraCaptureSession session = this;
    return new CameraDeviceImpl.StateCallbackKK() {

        private boolean mBusy = false;

        private boolean mActive = false;

        @Override
        public void onOpened(CameraDevice camera) {
            throw new AssertionError(""Camera must already be open before creating a session"");
        }

        @Override
        public void onDisconnected(CameraDevice camera) {
            if (DEBUG)
                Log.v(TAG, mIdString + ""onDisconnected"");
            close();
        }

        @Override
        public void onError(CameraDevice camera, int error) {
            // Should not be reached, handled by device code
            Log.wtf(TAG, mIdString + ""Got device error "" + error);
        }

        @Override
        public void onActive(CameraDevice camera) {
            mIdleDrainer.taskStarted();
            mActive = true;
            if (DEBUG)
                Log.v(TAG, mIdString + ""onActive"");
            mStateCallback.onActive(session);
        }

        @Override
        public void onIdle(CameraDevice camera) {
            boolean isAborting;
            if (DEBUG)
                Log.v(TAG, mIdString + ""onIdle"");
            synchronized (session) {
                isAborting = mAborting;
            }
            /*
                 * Check which states we transitioned through:
                 *
                 * (ACTIVE -> IDLE)
                 * (BUSY -> IDLE)
                 *
                 * Note that this is also legal:
                 * (ACTIVE -> BUSY -> IDLE)
                 *
                 * and mark those tasks as finished
                 */
            if (mBusy && isAborting) {
                mAbortDrainer.taskFinished();
                synchronized (session) {
                    mAborting = false;
                }
            }
            if (mActive) {
                mIdleDrainer.taskFinished();
            }
            mBusy = false;
            mActive = false;
            mStateCallback.onReady(session);
        }

        @Override
        public void onBusy(CameraDevice camera) {
            mBusy = true;
            // Don't signal the application since there's no clean mapping here
            if (DEBUG)
                Log.v(TAG, mIdString + ""onBusy"");
        }

        @Override
        public void onUnconfigured(CameraDevice camera) {
            if (DEBUG)
                Log.v(TAG, mIdString + ""onUnconfigured"");
        }

        @Override
        public void onSurfacePrepared(Surface surface) {
            if (DEBUG)
                Log.v(TAG, mIdString + ""onPrepared"");
            mStateCallback.onSurfacePrepared(session, surface);
        }
    };
}",1,"/**
 * Create an internal state callback, to be invoked on the mDeviceHandler
 *
 * <p>It has a few behaviors:
 * <ul>
 * <li>Convert device state changes into session state changes.
 * <li>Keep track of async tasks that the session began (idle, abort).
 * </ul>
 * </p>
 */
","/**
 * Create an internal state callback, to be invoked on the mDeviceHandler
 *
 * <p>It has a few behaviors:
 * <ul>
 * <li>Convert device state changes into session state changes.
 * <li>Keep track of async tasks that the session began (idle, abort).
 * </ul>
 * </p>
 */
",-1,,[@Override],-1,-1,-1,-1,-1,-1,,,,
29,"<android.appwidget.AppWidgetHost.Callbacks: void updateAppWidget(int,RemoteViews)>",22,23,"<android.appwidget.AppWidgetHost.Callbacks: void updateAppWidget(int,RemoteViews)>","<android.appwidget.AppWidgetHost.Callbacks: void updateAppWidget(int,RemoteViews)>",0,"{
    if (isLocalBinder() && views != null) {
        views = views.clone();
    }
    Message msg = mHandler.obtainMessage(HANDLE_UPDATE, appWidgetId, 0, views);
    msg.sendToTarget();
}","{
    if (isLocalBinder() && views != null) {
        views = views.clone();
    }
    Handler handler = mWeakHandler.get();
    if (handler == null) {
        return;
    }
    Message msg = handler.obtainMessage(HANDLE_UPDATE, appWidgetId, 0, views);
    msg.sendToTarget();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",0,"The change includes the introduction of a local variable 'handler' which is fetched through 'mWeakHandler.get()', a new control statement 'if (handler == null)', and a new return statement. The use of 'handler' instead of 'mHandler' constitutes a control dependency change and an other statement change. The introduction of a check for a null value of 'handler' and an early return implies a control dependency change and a return statement changed, so the change type is 1,3,4.","Despite the control dependency change, there is no Compatibility Issue caused by potential different return values or types. The callback is still posted to handler's message queue with the same data if the handler is not null. If the handler is null, the method exits early, which is a new behavior, but it does not impact the callers since they do not expect any return value or use the return value for further processing. Hence, the method's contract is not altered in a way that would lead to a compatibility issue, and therefore, the CI type is 0."
30,"<android.content.IntentFilter: int matchData(String,String,Uri)>",22,23,"<android.content.IntentFilter: int matchData(String,String,Uri)>","<android.content.IntentFilter: int matchData(String,String,Uri)>",0,"{
    final ArrayList<String> types = mDataTypes;
    final ArrayList<String> schemes = mDataSchemes;
    int match = MATCH_CATEGORY_EMPTY;
    if (types == null && schemes == null) {
        return ((type == null && data == null) ? (MATCH_CATEGORY_EMPTY + MATCH_ADJUSTMENT_NORMAL) : NO_MATCH_DATA);
    }
    if (schemes != null) {
        if (schemes.contains(scheme != null ? scheme : """")) {
            match = MATCH_CATEGORY_SCHEME;
        } else {
            return NO_MATCH_DATA;
        }
        final ArrayList<PatternMatcher> schemeSpecificParts = mDataSchemeSpecificParts;
        if (schemeSpecificParts != null) {
            match = hasDataSchemeSpecificPart(data.getSchemeSpecificPart()) ? MATCH_CATEGORY_SCHEME_SPECIFIC_PART : NO_MATCH_DATA;
        }
        if (match != MATCH_CATEGORY_SCHEME_SPECIFIC_PART) {
            // If there isn't any matching ssp, we need to match an authority.
            final ArrayList<AuthorityEntry> authorities = mDataAuthorities;
            if (authorities != null) {
                int authMatch = matchDataAuthority(data);
                if (authMatch >= 0) {
                    final ArrayList<PatternMatcher> paths = mDataPaths;
                    if (paths == null) {
                        match = authMatch;
                    } else if (hasDataPath(data.getPath())) {
                        match = MATCH_CATEGORY_PATH;
                    } else {
                        return NO_MATCH_DATA;
                    }
                } else {
                    return NO_MATCH_DATA;
                }
            }
        }
        // If neither an ssp nor an authority matched, we're done.
        if (match == NO_MATCH_DATA) {
            return NO_MATCH_DATA;
        }
    } else {
        // to force everyone to say they handle content: or file: URIs.
        if (scheme != null && !"""".equals(scheme) && !""content"".equals(scheme) && !""file"".equals(scheme)) {
            return NO_MATCH_DATA;
        }
    }
    if (types != null) {
        if (findMimeType(type)) {
            match = MATCH_CATEGORY_TYPE;
        } else {
            return NO_MATCH_TYPE;
        }
    } else {
        // an Intent that does not have a MIME type.
        if (type != null) {
            return NO_MATCH_TYPE;
        }
    }
    return match + MATCH_ADJUSTMENT_NORMAL;
}","{
    final ArrayList<String> types = mDataTypes;
    final ArrayList<String> schemes = mDataSchemes;
    int match = MATCH_CATEGORY_EMPTY;
    if (types == null && schemes == null) {
        return ((type == null && data == null) ? (MATCH_CATEGORY_EMPTY + MATCH_ADJUSTMENT_NORMAL) : NO_MATCH_DATA);
    }
    if (schemes != null) {
        if (schemes.contains(scheme != null ? scheme : """")) {
            match = MATCH_CATEGORY_SCHEME;
        } else {
            return NO_MATCH_DATA;
        }
        final ArrayList<PatternMatcher> schemeSpecificParts = mDataSchemeSpecificParts;
        if (schemeSpecificParts != null && data != null) {
            match = hasDataSchemeSpecificPart(data.getSchemeSpecificPart()) ? MATCH_CATEGORY_SCHEME_SPECIFIC_PART : NO_MATCH_DATA;
        }
        if (match != MATCH_CATEGORY_SCHEME_SPECIFIC_PART) {
            // If there isn't any matching ssp, we need to match an authority.
            final ArrayList<AuthorityEntry> authorities = mDataAuthorities;
            if (authorities != null) {
                int authMatch = matchDataAuthority(data);
                if (authMatch >= 0) {
                    final ArrayList<PatternMatcher> paths = mDataPaths;
                    if (paths == null) {
                        match = authMatch;
                    } else if (hasDataPath(data.getPath())) {
                        match = MATCH_CATEGORY_PATH;
                    } else {
                        return NO_MATCH_DATA;
                    }
                } else {
                    return NO_MATCH_DATA;
                }
            }
        }
        // If neither an ssp nor an authority matched, we're done.
        if (match == NO_MATCH_DATA) {
            return NO_MATCH_DATA;
        }
    } else {
        // to force everyone to say they handle content: or file: URIs.
        if (scheme != null && !"""".equals(scheme) && !""content"".equals(scheme) && !""file"".equals(scheme)) {
            return NO_MATCH_DATA;
        }
    }
    if (types != null) {
        if (findMimeType(type)) {
            match = MATCH_CATEGORY_TYPE;
        } else {
            return NO_MATCH_TYPE;
        }
    } else {
        // an Intent that does not have a MIME type.
        if (type != null) {
            return NO_MATCH_TYPE;
        }
    }
    return match + MATCH_ADJUSTMENT_NORMAL;
}",1,"/**
 * Match this filter against an Intent's data (type, scheme and path). If
 * the filter does not specify any types and does not specify any
 * schemes/paths, the match will only succeed if the intent does not
 * also specify a type or data.  If the filter does not specify any schemes,
 * it will implicitly match intents with no scheme, or the schemes ""content:""
 * or ""file:"" (basically performing a MIME-type only match).  If the filter
 * does not specify any MIME types, the Intent also must not specify a MIME
 * type.
 *
 * <p>Be aware that to match against an authority, you must also specify a base
 * scheme the authority is in.  To match against a data path, both a scheme
 * and authority must be specified.  If the filter does not specify any
 * types or schemes that it matches against, it is considered to be empty
 * (any authority or data path given is ignored, as if it were empty as
 * well).
 *
 * <p><em>Note: MIME type, Uri scheme, and host name matching in the
 * Android framework is case-sensitive, unlike the formal RFC definitions.
 * As a result, you should always write these elements with lower case letters,
 * and normalize any MIME types or Uris you receive from
 * outside of Android to ensure these elements are lower case before
 * supplying them here.</em></p>
 *
 * @param type The desired data type to look for, as returned by
 * Intent.resolveType().
 * @param scheme The desired data scheme to look for, as returned by
 * Intent.getScheme().
 * @param data The full data string to match against, as supplied in
 * Intent.data.
 *
 * @return Returns either a valid match constant (a combination of
 * {@link #MATCH_CATEGORY_MASK} and {@link #MATCH_ADJUSTMENT_MASK}),
 * or one of the error codes {@link #NO_MATCH_TYPE} if the type didn't match
 * or {@link #NO_MATCH_DATA} if the scheme/path didn't match.
 *
 * @see #match
 */
","/**
 * Match this filter against an Intent's data (type, scheme and path). If
 * the filter does not specify any types and does not specify any
 * schemes/paths, the match will only succeed if the intent does not
 * also specify a type or data.  If the filter does not specify any schemes,
 * it will implicitly match intents with no scheme, or the schemes ""content:""
 * or ""file:"" (basically performing a MIME-type only match).  If the filter
 * does not specify any MIME types, the Intent also must not specify a MIME
 * type.
 *
 * <p>Be aware that to match against an authority, you must also specify a base
 * scheme the authority is in.  To match against a data path, both a scheme
 * and authority must be specified.  If the filter does not specify any
 * types or schemes that it matches against, it is considered to be empty
 * (any authority or data path given is ignored, as if it were empty as
 * well).
 *
 * <p><em>Note: MIME type, Uri scheme, and host name matching in the
 * Android framework is case-sensitive, unlike the formal RFC definitions.
 * As a result, you should always write these elements with lower case letters,
 * and normalize any MIME types or Uris you receive from
 * outside of Android to ensure these elements are lower case before
 * supplying them here.</em></p>
 *
 * @param type The desired data type to look for, as returned by
 * Intent.resolveType().
 * @param scheme The desired data scheme to look for, as returned by
 * Intent.getScheme().
 * @param data The full data string to match against, as supplied in
 * Intent.data.
 *
 * @return Returns either a valid match constant (a combination of
 * {@link #MATCH_CATEGORY_MASK} and {@link #MATCH_ADJUSTMENT_MASK}),
 * or one of the error codes {@link #NO_MATCH_TYPE} if the type didn't match
 * or {@link #NO_MATCH_DATA} if the scheme/path didn't match.
 *
 * @see #match
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The code change occurred in the control flow within the if statement where `schemeSpecificParts != null`. An extra condition `data != null` has been added to the if statement. This changes the control dependency, so the code change type is 3.","Despite the control dependency change, this addition of a null check for `data` before calling `data.getSchemeSpecificPart()` is a defensive programming practice to avoid potential NullPointerException. The behavior of the API remains the same when the provided inputs are not null, thus no Compatibility Issue is expected in this context. If `data` is null, the previous implementation could have thrown a NullPointerException, whereas the new implementation will avoid this by not proceeding into the body of the if condition where `data.getSchemeSpecificPart()` is called. Hence, this change does not lead to a Compatibility Issue and is consistent with safe API usage enforcement. The behavior when `data` is non-null remains unchanged."
31,<android.widget.TimePickerSpinnerDelegate: String[] getAmPmStrings(Context)>,22,23,<android.widget.TimePickerSpinnerDelegate: String[] getAmPmStrings(Context)>,<android.widget.TimePickerSpinnerDelegate: String[] getAmPmStrings(Context)>,0,"{
    String[] result = new String[2];
    LocaleData d = LocaleData.get(context.getResources().getConfiguration().locale);
    result[0] = d.amPm[0].length() > 2 ? d.narrowAm : d.amPm[0];
    result[1] = d.amPm[1].length() > 2 ? d.narrowPm : d.amPm[1];
    return result;
}","{
    String[] result = new String[2];
    LocaleData d = LocaleData.get(context.getResources().getConfiguration().locale);
    result[0] = d.amPm[0].length() > 4 ? d.narrowAm : d.amPm[0];
    result[1] = d.amPm[1].length() > 4 ? d.narrowPm : d.amPm[1];
    return result;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,0,The condition in the ternary operation has been changed for both array elements. The length check has been changed from 2 to 4 (`length() > 2` to `length() > 4`).,"The API's behavior has been modified due to the change in the condition for deciding between `narrowAm`/`narrowPm` and `amPm[0]`/`amPm[1]`. However, since this is a change in a condition within the same logical structure of the function, and it does not necessarily lead to a different output for the same input (because it depends on the actual `LocaleData` content), this change should not inherently cause incompatibility. It may still return the same values for LocaleData that meets the old and new conditions similarly. Therefore, this change does not necessarily result in compatibility issues due to different return values, so pred_CI is marked as 0."
32,"<android.app.backup.BackupAgent.BackupServiceBinder: void doRestoreFinished(int,IBackupManager)>",22,23,"<android.app.backup.BackupAgent.BackupServiceBinder: void doRestoreFinished(int,IBackupManager)>","<android.app.backup.BackupAgent.BackupServiceBinder: void doRestoreFinished(int,IBackupManager)>",0,"{
    long ident = Binder.clearCallingIdentity();
    try {
        BackupAgent.this.onRestoreFinished();
    } finally {
        // Ensure that any side-effect SharedPreferences writes have landed
        waitForSharedPrefs();
        Binder.restoreCallingIdentity(ident);
        try {
            callbackBinder.opComplete(token);
        } catch (RemoteException e) {
        // we'll time out anyway, so we're safe
        }
    }
}","{
    long ident = Binder.clearCallingIdentity();
    try {
        BackupAgent.this.onRestoreFinished();
    } catch (Exception e) {
        Log.d(TAG, ""onRestoreFinished ("" + BackupAgent.this.getClass().getName() + "") threw"", e);
        throw e;
    } finally {
        // Ensure that any side-effect SharedPreferences writes have landed
        waitForSharedPrefs();
        Binder.restoreCallingIdentity(ident);
        try {
            callbackBinder.opComplete(token, 0);
        } catch (RemoteException e) {
        // we'll time out anyway, so we're safe
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,3,5","1,2","The new version adds a catch block for a broader `Exception` type around the `BackupAgent.this.onRestoreFinished();` method call, and also changes the parameters of `callbackBinder.opComplete` method from `token` to `(token, 0)`. These changes result in change types 2, 3, and 5.",The new try-catch block for the broader `Exception` type introduces the potential for different exception handling (CI type 2). The change in the parameters of the `callbackBinder.opComplete` method call introduces a potential change in behaviour of the method (CI type 1).
33,<android.app.admin.DevicePolicyManager: boolean getCrossProfileCallerIdDisabled(ComponentName)>,22,23,<android.app.admin.DevicePolicyManager: boolean getCrossProfileCallerIdDisabled(ComponentName)>,<android.app.admin.DevicePolicyManager: boolean getCrossProfileCallerIdDisabled(ComponentName)>,0,"{
    if (mService != null) {
        try {
            return mService.getCrossProfileCallerIdDisabled(who);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
    return false;
}","{
    if (mService != null) {
        try {
            return mService.getCrossProfileCallerIdDisabled(admin);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
    return false;
}",1,"/**
 * Called by a profile owner of a managed profile to determine whether or not caller-Id
 * information has been disabled.
 *
 * <p>The calling device admin must be a profile owner. If it is not, a
 * security exception will be thrown.
 *
 * @param who Which {@link DeviceAdminReceiver} this request is associated with.
 */
","/**
 * Called by a profile owner of a managed profile to determine whether or not caller-Id
 * information has been disabled.
 *
 * <p>The calling device admin must be a profile owner. If it is not, a
 * security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The argument name passed to the method getCrossProfileCallerIdDisabled has changed from 'who' to 'admin'. It's likely a simple renaming of the variable without changing the type or the runtime behavior. No other code changes have occurred, so the change type is 5.","There is no Compatibility Issue since the change is only related to the renaming of a parameter within the method, which has no impact on the method's behavior. The method signatures remain the same and so do the return values and exceptions thrown."
35,<android.widget.TextView: int getCompoundPaddingTop()>,22,23,<android.widget.TextView: int getCompoundPaddingTop()>,<android.widget.TextView: int getCompoundPaddingTop()>,0,"{
    final Drawables dr = mDrawables;
    if (dr == null || dr.mDrawableTop == null) {
        return mPaddingTop;
    } else {
        return mPaddingTop + dr.mDrawablePadding + dr.mDrawableSizeTop;
    }
}","{
    final Drawables dr = mDrawables;
    if (dr == null || dr.mShowing[Drawables.TOP] == null) {
        return mPaddingTop;
    } else {
        return mPaddingTop + dr.mDrawablePadding + dr.mDrawableSizeTop;
    }
}",1,"/**
 * Returns the top padding of the view, plus space for the top
 * Drawable if any.
 */
","/**
 * Returns the top padding of the view, plus space for the top
 * Drawable if any.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The condition in the if statement has changed from 'dr.mDrawableTop == null' to 'dr.mShowing[Drawables.TOP] == null', which indicates that the internal representation of how top drawables are referenced has changed but doesn't necessarily indicate that the behavior of the method has changed, as the method's contract still simply states whether there is a top compound drawable or not. Therefore, the change is a dependent API changed (5) since dr.mDrawableTop seems to have been replaced by dr.mShowing[Drawables.TOP].",No Compatibility Issue should arise from this change (0) assuming 'dr.mDrawableTop' was refactored to 'dr.mShowing[Drawables.TOP]' and there is no change in how the presence of a top drawable is determined or in the calculated padding. The external behavior of the method - which padding is returned under which conditions - should remain the same.
36,"<android.transition.CircularPropagation: long getStartDelay(ViewGroup,Transition,TransitionValues,TransitionValues)>",22,23,"<android.transition.CircularPropagation: long getStartDelay(ViewGroup,Transition,TransitionValues,TransitionValues)>","<android.transition.CircularPropagation: long getStartDelay(ViewGroup,Transition,TransitionValues,TransitionValues)>",0,"{
    if (startValues == null && endValues == null) {
        return 0;
    }
    int directionMultiplier = 1;
    TransitionValues positionValues;
    if (endValues == null || getViewVisibility(startValues) == View.VISIBLE) {
        positionValues = startValues;
        directionMultiplier = -1;
    } else {
        positionValues = endValues;
    }
    int viewCenterX = getViewX(positionValues);
    int viewCenterY = getViewY(positionValues);
    Rect epicenter = transition.getEpicenter();
    int epicenterX;
    int epicenterY;
    if (epicenter != null) {
        epicenterX = epicenter.centerX();
        epicenterY = epicenter.centerY();
    } else {
        int[] loc = new int[2];
        sceneRoot.getLocationOnScreen(loc);
        epicenterX = Math.round(loc[0] + (sceneRoot.getWidth() / 2) + sceneRoot.getTranslationX());
        epicenterY = Math.round(loc[1] + (sceneRoot.getHeight() / 2) + sceneRoot.getTranslationY());
    }
    float distance = distance(viewCenterX, viewCenterY, epicenterX, epicenterY);
    float maxDistance = distance(0, 0, sceneRoot.getWidth(), sceneRoot.getHeight());
    float distanceFraction = distance / maxDistance;
    long duration = transition.getDuration();
    if (duration < 0) {
        duration = 300;
    }
    return Math.round(duration * directionMultiplier / mPropagationSpeed * distanceFraction);
}","{
    if (startValues == null && endValues == null) {
        return 0;
    }
    int directionMultiplier = 1;
    TransitionValues positionValues;
    if (endValues == null || getViewVisibility(startValues) == View.VISIBLE) {
        positionValues = startValues;
        directionMultiplier = -1;
    } else {
        positionValues = endValues;
    }
    int viewCenterX = getViewX(positionValues);
    int viewCenterY = getViewY(positionValues);
    Rect epicenter = transition.getEpicenter();
    int epicenterX;
    int epicenterY;
    if (epicenter != null) {
        epicenterX = epicenter.centerX();
        epicenterY = epicenter.centerY();
    } else {
        int[] loc = new int[2];
        sceneRoot.getLocationOnScreen(loc);
        epicenterX = Math.round(loc[0] + (sceneRoot.getWidth() / 2) + sceneRoot.getTranslationX());
        epicenterY = Math.round(loc[1] + (sceneRoot.getHeight() / 2) + sceneRoot.getTranslationY());
    }
    double distance = distance(viewCenterX, viewCenterY, epicenterX, epicenterY);
    double maxDistance = distance(0, 0, sceneRoot.getWidth(), sceneRoot.getHeight());
    double distanceFraction = distance / maxDistance;
    long duration = transition.getDuration();
    if (duration < 0) {
        duration = 300;
    }
    return Math.round(duration * directionMultiplier / mPropagationSpeed * distanceFraction);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The change occurred in the variable type for `distance` and `maxDistance` from `float` to `double`, which is an internal computation detail; considering Java's implicit casting rules, the change of type from `float` to `double` is not expected to result in different behavior from an external perspective unless there is a very specific scenario involving precision that could affect the outcome of the method. However, this scenario is not very common. There are no other changes in the code logic, return statements, or exception handling.","In this case, it is not likely to cause a Compatibility Issue that the API returns a different value or throws a different exception, as the final returned value is still being calculated in the same way and rounded to `long` before being returned. The change from `float` to `double` increases precision but does not fundamentally alter the output of the method, given that precision loss can occur when casting from `double` to `long`."
37,<android.widget.FrameLayout: int getPaddingLeftWithForeground()>,22,23,<android.widget.FrameLayout: int getPaddingLeftWithForeground()>,<android.widget.FrameLayout: int getPaddingLeftWithForeground()>,0,"{
    return mForegroundInPadding ? Math.max(mPaddingLeft, mForegroundPaddingLeft) : mPaddingLeft + mForegroundPaddingLeft;
}","{
    return isForegroundInsidePadding() ? Math.max(mPaddingLeft, mForegroundPaddingLeft) : mPaddingLeft + mForegroundPaddingLeft;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,The method mForegroundInPadding has been replaced with a dependent API isForegroundInsidePadding call. This is considered a code change type 4 (Other statement changed) and 5 (Dependent API changed).,"There is no Compatibility Issue here as the behavior is preserved. The change is the usage of a different but equivalent method to determine padding, which should not affect the resulting value returned by the API. The condition and the operation remains the same, just the method of evaluating the condition has changed. Therefore, the CI situation is 0 (No Compatibility Issue)."
40,<android.widget.PopupWindow: void dismiss()>,22,23,<android.widget.PopupWindow: void dismiss()>,<android.widget.PopupWindow: void dismiss()>,0,"{
    if (isShowing() && mPopupView != null) {
        mIsShowing = false;
        unregisterForScrollChanged();
        try {
            mWindowManager.removeViewImmediate(mPopupView);
        } finally {
            if (mPopupView != mContentView && mPopupView instanceof ViewGroup) {
                ((ViewGroup) mPopupView).removeView(mContentView);
            }
            mPopupView = null;
            if (mOnDismissListener != null) {
                mOnDismissListener.onDismiss();
            }
        }
    }
}","{
    if (!isShowing() || mIsTransitioningToDismiss) {
        return;
    }
    final PopupDecorView decorView = mDecorView;
    final View contentView = mContentView;
    final ViewGroup contentHolder;
    final ViewParent contentParent = contentView.getParent();
    if (contentParent instanceof ViewGroup) {
        contentHolder = ((ViewGroup) contentParent);
    } else {
        contentHolder = null;
    }
    // Ensure any ongoing or pending transitions are canceled.
    decorView.cancelTransitions();
    mIsShowing = false;
    mIsTransitioningToDismiss = true;
    final Transition exitTransition = mExitTransition;
    if (exitTransition != null && decorView.isLaidOut()) {
        // The decor view is non-interactive during exit transitions.
        final LayoutParams p = (LayoutParams) decorView.getLayoutParams();
        p.flags |= LayoutParams.FLAG_NOT_TOUCHABLE;
        p.flags |= LayoutParams.FLAG_NOT_FOCUSABLE;
        mWindowManager.updateViewLayout(decorView, p);
        final Rect epicenter = getRelativeAnchorBounds();
        exitTransition.setEpicenterCallback(new EpicenterCallback() {

            @Override
            public Rect onGetEpicenter(Transition transition) {
                return epicenter;
            }
        });
        decorView.startExitTransition(exitTransition, new TransitionListenerAdapter() {

            @Override
            public void onTransitionEnd(Transition transition) {
                dismissImmediate(decorView, contentHolder, contentView);
            }
        });
    } else {
        dismissImmediate(decorView, contentHolder, contentView);
    }
    // Clears the anchor view.
    unregisterForScrollChanged();
    if (mOnDismissListener != null) {
        mOnDismissListener.onDismiss();
    }
}",1,"/**
 * <p>Dispose of the popup window. This method can be invoked only after
 * {@link #showAsDropDown(android.view.View)} has been executed. Failing that, calling
 * this method will have no effect.</p>
 *
 * @see #showAsDropDown(android.view.View)
 */
","/**
 * Disposes of the popup window. This method can be invoked only after
 * {@link #showAsDropDown(android.view.View)} has been executed. Failing
 * that, calling this method will have no effect.
 *
 * @see #showAsDropDown(android.view.View)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,3,4","1,2","The existing condition in the 'if' statement has been changed, new conditions are added, new return statement introduced, new variable assignments, a new call to `cancelTransitions()` method, use of `LayoutParams`, a new instantiation of `EpicenterCallback`, and a call to `startExitTransition` method with a new `TransitionListenerAdapter`. Exception handling has also been changed since early version has a try-finally block, while the late version does not have such block around `mWindowManager.removeViewImmediate`. The structure of control flow has also experienced a significant change, including new if conditions and a different way of dismissing the PopupWindow which is dependent on the existence and state of `exitTransition`. Therefore, the code change includes a return statement change, exception handling statement change, control dependency change, and other statement changes.","The introduction of new conditions (`!isShowing()` or `mIsTransitioningToDismiss`) which could return early, the removal of the try-finally block, and the new conditional logic for dismissing the PopupWindow with or without the exit transition could lead to both a different return behavior and different exception handling. Specifically, if any of the new conditions is true, an early return is now introduced, and the omission of the try-finally block could lead to resource leakage if an exception occurs in the meantime, which previously would be caught and handled in the finally block. The control dependency changes affect the execution path of the method, potentially altering the method's outcome and behavior under various conditions."
41,"<android.app.FragmentManagerImpl: void popBackStack(int,int)>",22,23,"<android.app.FragmentManagerImpl: void popBackStack(int,int)>","<android.app.FragmentManagerImpl: void popBackStack(int,int)>",0,"{
    if (id < 0) {
        throw new IllegalArgumentException(""Bad id: "" + id);
    }
    enqueueAction(new Runnable() {

        @Override
        public void run() {
            popBackStackState(mActivity.mHandler, null, id, flags);
        }
    }, false);
}","{
    if (id < 0) {
        throw new IllegalArgumentException(""Bad id: "" + id);
    }
    enqueueAction(new Runnable() {

        @Override
        public void run() {
            popBackStackState(mHost.getHandler(), null, id, flags);
        }
    }, false);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The method popBackStackState is being called with a different parameter: mActivity.mHandler has been changed to mHost.getHandler(). This is a change in the dependent API being called within the enqueueAction method, hence the code change type is 5.","There is no Compatibility Issue, as the change doesn't alter the behavior of the popBackStack method itself in terms of what it returns or the exceptions it throws. The functionality of getting the handler has been refactored or changed internally, which by itself doesn't constitute a compatibility issue, assuming mHost.getHandler() is intended to provide the same functionality as mActivity.mHandler. Thus, the CI type is 0."
42,<android.app.ContextImpl: void sendStickyBroadcast(Intent)>,22,23,<android.app.ContextImpl: void sendStickyBroadcast(Intent)>,<android.app.ContextImpl: void sendStickyBroadcast(Intent)>,0,"{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess();
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, false, true, getUserId());
    } catch (RemoteException e) {
    }
}","{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess();
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, true, getUserId());
    } catch (RemoteException e) {
        throw new RuntimeException(""Failure from system"", e);
    }
}",1,,,-1,[@Override],"[@Override, @Deprecated]",-1,-1,-1,-1,-1,-1,"2,4",2,"An additional catch block action is added which throws a RuntimeException. Also, in the broadcastIntent call, 'false' is replaced with 'null' for one of the parameters. This represents a change in other statements, so the change type is 2,4.","Because the late version adds a new throw statement in the catch block, it leads to a different exception handling behavior compared to the early version, which did not throw an exception in this case. Therefore, the CI type is 2."
43,<android.hardware.camera2.params.StreamConfigurationMap: int hashCode()>,22,23,<android.hardware.camera2.params.StreamConfigurationMap: int hashCode()>,<android.hardware.camera2.params.StreamConfigurationMap: int hashCode()>,0,"{
    // XX: do we care about order?
    return HashCodeHelpers.hashCode(mConfigurations, mMinFrameDurations, mStallDurations, mHighSpeedVideoConfigurations);
}","{
    // XX: do we care about order?
    return HashCodeHelpers.hashCodeGeneric(mConfigurations, mMinFrameDurations, mStallDurations, mDepthConfigurations, mHighSpeedVideoConfigurations);
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed because an additional parameter, mDepthConfigurations, is added to the hashCodeGeneric() method call. This changes the way the hash code is calculated, which can result in a different return value. Additionally, since the method used for calculating the hash code has changed from hashCode() to hashCodeGeneric(), it is considered a dependent API change.","The addition of the mDepthConfigurations parameter and the change to a different hashCode calculation method means the hash value returned could potentially be different even for the same object state in the two API versions. This is a compatibility issue of type 1, caused by potentially different return values."
44,<android.content.ContentProviderClient: ContentProviderResult[] applyBatch(ArrayList<ContentProviderOperation>)>,22,23,<android.content.ContentProviderClient: ContentProviderResult[] applyBatch(ArrayList<ContentProviderOperation>)>,<android.content.ContentProviderClient: ContentProviderResult[] applyBatch(ArrayList<ContentProviderOperation>)>,0,"{
    beforeRemote();
    try {
        return mContentProvider.applyBatch(mPackageName, operations);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}","{
    Preconditions.checkNotNull(operations, ""operations"");
    beforeRemote();
    try {
        return mContentProvider.applyBatch(mPackageName, operations);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}",1,"/**
 * See {@link ContentProvider#applyBatch ContentProvider.applyBatch}
 */
","/**
 * See {@link ContentProvider#applyBatch ContentProvider.applyBatch}
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,4,0,"The code change is the addition of a line of code that checks if the 'operations' parameter is null using Preconditions.checkNotNull(), before executing the rest of the method. This is categorized as 4 since it's an ""Other statement changed"".","This addition does not cause a Compatibility Issue as checking for null only enforces that the input should not be null, which should have been the case even without this explicit check (as passing a null 'operations' would likely result in an exception anyway). Thus, this change just provides a clearer error message and earlier failure when 'operations' is null and does not affect the behavior of the API in cases where 'operations' is not null. Therefore, there is No Compatibility Issue, i.e., 0."
45,<android.accounts.AccountManager: boolean removeAccountExplicitly(Account)>,22,23,<android.accounts.AccountManager: boolean removeAccountExplicitly(Account)>,<android.accounts.AccountManager: boolean removeAccountExplicitly(Account)>,0,"{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    try {
        return mService.removeAccountExplicitly(account);
    } catch (RemoteException e) {
        // won't ever happen
        throw new RuntimeException(e);
    }
}","{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    try {
        return mService.removeAccountExplicitly(account);
    } catch (RemoteException e) {
        // May happen if the caller doesn't match the signature of the authenticator.
        throw new RuntimeException(e);
    }
}",1,"/**
 * Removes an account directly. Normally used by authenticators, not
 * directly by applications. Does not delete the account from the server.
 * The authenticator may have its own policies preventing account deletion,
 * in which case the account will not be deleted.
 * <p>
 * It is safe to call this method from the main thread.
 * <p>
 * This method requires the caller to hold the permission
 * {@link android.Manifest.permission#AUTHENTICATE_ACCOUNTS} and to have the
 * same UID or signature as the account's authenticator.
 *
 * @param account The {@link Account} to delete.
 * @return True if the account was successfully deleted, false if the
 * account did not exist, the account is null, or another error
 * occurs.
 */
","/**
 * Removes an account directly. Normally used by authenticators, not
 * directly by applications. Does not delete the account from the server.
 * The authenticator may have its own policies preventing account deletion,
 * in which case the account will not be deleted.
 * <p>
 * It is safe to call this method from the main thread.
 * <p>This method requires the caller to have a signature match with the
 * authenticator that manages the specified account.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * AUTHENTICATE_ACCOUNTS permission and same UID as account's authenticator
 * is needed for those platforms. See docs for this function in API level 22.
 *
 * @param account The {@link Account} to delete.
 * @return True if the account was successfully deleted, false if the
 * account did not exist, the account is null, or another error
 * occurs.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The implementation code is unchanged, with the exception of a comment that is updated. The update does not affect the API's behavior, so the code change type is 4.","The change is only in the comment and there are no changes to the code that could affect its behavior; hence, there is no compatibility issue, and the CI type is 0."
46,<android.app.FragmentManagerImpl: boolean execPendingActions()>,22,23,<android.app.FragmentManagerImpl: boolean execPendingActions()>,<android.app.FragmentManagerImpl: boolean execPendingActions()>,0,"{
    if (mExecutingActions) {
        throw new IllegalStateException(""Recursive entry to executePendingTransactions"");
    }
    if (Looper.myLooper() != mActivity.mHandler.getLooper()) {
        throw new IllegalStateException(""Must be called from main thread of process"");
    }
    boolean didSomething = false;
    while (true) {
        int numActions;
        synchronized (this) {
            if (mPendingActions == null || mPendingActions.size() == 0) {
                break;
            }
            numActions = mPendingActions.size();
            if (mTmpActions == null || mTmpActions.length < numActions) {
                mTmpActions = new Runnable[numActions];
            }
            mPendingActions.toArray(mTmpActions);
            mPendingActions.clear();
            mActivity.mHandler.removeCallbacks(mExecCommit);
        }
        mExecutingActions = true;
        for (int i = 0; i < numActions; i++) {
            mTmpActions[i].run();
            mTmpActions[i] = null;
        }
        mExecutingActions = false;
        didSomething = true;
    }
    if (mHavePendingDeferredStart) {
        boolean loadersRunning = false;
        for (int i = 0; i < mActive.size(); i++) {
            Fragment f = mActive.get(i);
            if (f != null && f.mLoaderManager != null) {
                loadersRunning |= f.mLoaderManager.hasRunningLoaders();
            }
        }
        if (!loadersRunning) {
            mHavePendingDeferredStart = false;
            startPendingDeferredFragments();
        }
    }
    return didSomething;
}","{
    if (mExecutingActions) {
        throw new IllegalStateException(""Recursive entry to executePendingTransactions"");
    }
    if (Looper.myLooper() != mHost.getHandler().getLooper()) {
        throw new IllegalStateException(""Must be called from main thread of process"");
    }
    boolean didSomething = false;
    while (true) {
        int numActions;
        synchronized (this) {
            if (mPendingActions == null || mPendingActions.size() == 0) {
                break;
            }
            numActions = mPendingActions.size();
            if (mTmpActions == null || mTmpActions.length < numActions) {
                mTmpActions = new Runnable[numActions];
            }
            mPendingActions.toArray(mTmpActions);
            mPendingActions.clear();
            mHost.getHandler().removeCallbacks(mExecCommit);
        }
        mExecutingActions = true;
        for (int i = 0; i < numActions; i++) {
            mTmpActions[i].run();
            mTmpActions[i] = null;
        }
        mExecutingActions = false;
        didSomething = true;
    }
    if (mHavePendingDeferredStart) {
        boolean loadersRunning = false;
        for (int i = 0; i < mActive.size(); i++) {
            Fragment f = mActive.get(i);
            if (f != null && f.mLoaderManager != null) {
                loadersRunning |= f.mLoaderManager.hasRunningLoaders();
            }
        }
        if (!loadersRunning) {
            mHavePendingDeferredStart = false;
            startPendingDeferredFragments();
        }
    }
    return didSomething;
}",1,"/**
 * Only call from main thread!
 */
","/**
 * Only call from main thread!
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The change is in the part of the code where it gets the Handler from a differently named variable (from `mActivity.mHandler` to `mHost.getHandler()`), this implies that there was a change in the dependent API (`getHandler()` called on different objects). Since there is no structural code change other than the variable from which the Handler is being fetched, the change type is 5.","There is no Compatibility Issue since the modification to the code does not affect the behavior or output of the `execPendingActions` method. It's simply a change in the internal implementation detail (i.e., where the Handler object is obtained from), not something that would alter the logic or results of the method. So the CI type is 0."
47,<android.webkit.WebView: PrintDocumentAdapter createPrintDocumentAdapter()>,22,23,<android.webkit.WebView: PrintDocumentAdapter createPrintDocumentAdapter()>,<android.webkit.WebView: PrintDocumentAdapter createPrintDocumentAdapter()>,0,"{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, ""createPrintDocumentAdapter"");
    return mProvider.createPrintDocumentAdapter(""default"");
}","{
    checkThread();
    return mProvider.createPrintDocumentAdapter(""default"");
}",1,"/**
 * @deprecated Use {@link #createPrintDocumentAdapter(String)} which requires user
 * to provide a print document name.
 */
","/**
 * @deprecated Use {@link #createPrintDocumentAdapter(String)} which requires user
 * to provide a print document name.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,4,0,"The change is only the removal of the conditional logging statement. This does not affect the behavior of the method from the perspective of functionality or output, so the code change type is 4.","Since the code change does not affect the functionality of the method (only the logging is removed, which is not part of the method's behavior), there is no compatibility issue, and the CI type is 0."
50,"<android.content.ContentProviderClient: int update(Uri,ContentValues,String,String[])>",22,23,"<android.content.ContentProviderClient: int update(Uri,ContentValues,String,String[])>","<android.content.ContentProviderClient: int update(Uri,ContentValues,String,String[])>",0,"{
    beforeRemote();
    try {
        return mContentProvider.update(mPackageName, url, values, selection, selectionArgs);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}","{
    Preconditions.checkNotNull(url, ""url"");
    beforeRemote();
    try {
        return mContentProvider.update(mPackageName, url, values, selection, selectionArgs);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}",1,"/**
 * See {@link ContentProvider#update ContentProvider.update}
 */
","/**
 * See {@link ContentProvider#update ContentProvider.update}
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The new version has added Preconditions.checkNotNull(url, ""url""); at the start of the method. This is a new statement being introduced which is an additional precondition check and it does not change return values, exception handling, or control flow; therefore, the code change type is 4.","Since the added precondition check will only cause the method to fail earlier with a NullPointerException if 'url' is null, and this exception would occur regardless later in the code when trying to use 'url', this does not constitute a new compatibility issue; the behavior in terms of exceptions thrown would be the same in the context of normal execution where non-null 'url' is expected. Hence, there is no CI."
51,"<android.view.ViewGroup: void offsetRectBetweenParentAndChild(View,Rect,boolean,boolean)>",22,23,"<android.view.ViewGroup: void offsetRectBetweenParentAndChild(View,Rect,boolean,boolean)>","<android.view.ViewGroup: void offsetRectBetweenParentAndChild(View,Rect,boolean,boolean)>",0,"{
    // already in the same coord system :)
    if (descendant == this) {
        return;
    }
    ViewParent theParent = descendant.mParent;
    // search and offset up to the parent
    while ((theParent != null) && (theParent instanceof View) && (theParent != this)) {
        if (offsetFromChildToParent) {
            rect.offset(descendant.mLeft - descendant.mScrollX, descendant.mTop - descendant.mScrollY);
            if (clipToBounds) {
                View p = (View) theParent;
                rect.intersect(0, 0, p.mRight - p.mLeft, p.mBottom - p.mTop);
            }
        } else {
            if (clipToBounds) {
                View p = (View) theParent;
                rect.intersect(0, 0, p.mRight - p.mLeft, p.mBottom - p.mTop);
            }
            rect.offset(descendant.mScrollX - descendant.mLeft, descendant.mScrollY - descendant.mTop);
        }
        descendant = (View) theParent;
        theParent = descendant.mParent;
    }
    // to get into our coordinate space
    if (theParent == this) {
        if (offsetFromChildToParent) {
            rect.offset(descendant.mLeft - descendant.mScrollX, descendant.mTop - descendant.mScrollY);
        } else {
            rect.offset(descendant.mScrollX - descendant.mLeft, descendant.mScrollY - descendant.mTop);
        }
    } else {
        throw new IllegalArgumentException(""parameter must be a descendant of this view"");
    }
}","{
    // already in the same coord system :)
    if (descendant == this) {
        return;
    }
    ViewParent theParent = descendant.mParent;
    // search and offset up to the parent
    while ((theParent != null) && (theParent instanceof View) && (theParent != this)) {
        if (offsetFromChildToParent) {
            rect.offset(descendant.mLeft - descendant.mScrollX, descendant.mTop - descendant.mScrollY);
            if (clipToBounds) {
                View p = (View) theParent;
                boolean intersected = rect.intersect(0, 0, p.mRight - p.mLeft, p.mBottom - p.mTop);
                if (!intersected) {
                    rect.setEmpty();
                }
            }
        } else {
            if (clipToBounds) {
                View p = (View) theParent;
                boolean intersected = rect.intersect(0, 0, p.mRight - p.mLeft, p.mBottom - p.mTop);
                if (!intersected) {
                    rect.setEmpty();
                }
            }
            rect.offset(descendant.mScrollX - descendant.mLeft, descendant.mScrollY - descendant.mTop);
        }
        descendant = (View) theParent;
        theParent = descendant.mParent;
    }
    // to get into our coordinate space
    if (theParent == this) {
        if (offsetFromChildToParent) {
            rect.offset(descendant.mLeft - descendant.mScrollX, descendant.mTop - descendant.mScrollY);
        } else {
            rect.offset(descendant.mScrollX - descendant.mLeft, descendant.mScrollY - descendant.mTop);
        }
    } else {
        throw new IllegalArgumentException(""parameter must be a descendant of this view"");
    }
}",1,"/**
 * Helper method that offsets a rect either from parent to descendant or
 * descendant to parent.
 */
","/**
 * Helper method that offsets a rect either from parent to descendant or
 * descendant to parent.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The change is the addition of a result check after the `rect.intersect(...)` method call and setting the rectangle to empty if there is no intersection. These modifications represent a control dependency change because the additional code is now dependent on the result of `rect.intersect(...)`, and it also represents an ""Other statement changed"" because the behavior of the method is extended by new non-control statements (e.g., `rect.setEmpty()`). So, the change types are 3 and 4.","The change potentially leads to a different behavior where the `Rect` could be set to empty while this was not possible in the earlier version. Thus, the change could result in a different return value (the state of `Rect` object), and the CI type is 1."
52,<android.app.Activity: void recreate()>,22,23,<android.app.Activity: void recreate()>,<android.app.Activity: void recreate()>,0,"{
    if (mParent != null) {
        throw new IllegalStateException(""Can only be called on top-level activity"");
    }
    if (Looper.myLooper() != mMainThread.getLooper()) {
        throw new IllegalStateException(""Must be called from main thread"");
    }
    mMainThread.requestRelaunchActivity(mToken, null, null, 0, false, null, false);
}","{
    if (mParent != null) {
        throw new IllegalStateException(""Can only be called on top-level activity"");
    }
    if (Looper.myLooper() != mMainThread.getLooper()) {
        throw new IllegalStateException(""Must be called from main thread"");
    }
    mMainThread.requestRelaunchActivity(mToken, null, null, 0, false, null, null, false);
}",1,"/**
 * Cause this Activity to be recreated with a new instance.  This results
 * in essentially the same flow as when the Activity is created due to
 * a configuration change -- the current instance will go through its
 * lifecycle to {@link #onDestroy} and a new instance then created after it.
 */
","/**
 * Cause this Activity to be recreated with a new instance.  This results
 * in essentially the same flow as when the Activity is created due to
 * a configuration change -- the current instance will go through its
 * lifecycle to {@link #onDestroy} and a new instance then created after it.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method 'requestRelaunchActivity' has an added parameter in the late version. This is a change in the arguments passed to a method, which is classified as 4.","The change in the number of parameters to 'requestRelaunchActivity' does not alter the behavior that could result in a different return value or a different exception being thrown from 'recreate()', because 'recreate()' itself does not return a value. Thus, there's no compatibility issue and the CI type is 0."
53,<android.widget.AbsListView: boolean onTouchEvent(MotionEvent)>,22,23,<android.widget.AbsListView: boolean onTouchEvent(MotionEvent)>,<android.widget.AbsListView: boolean onTouchEvent(MotionEvent)>,0,"{
    if (!isEnabled()) {
        // events, it just doesn't respond to them.
        return isClickable() || isLongClickable();
    }
    if (mPositionScroller != null) {
        mPositionScroller.stop();
    }
    if (mIsDetaching || !isAttachedToWindow()) {
        // in a bogus state.
        return false;
    }
    startNestedScroll(SCROLL_AXIS_VERTICAL);
    if (mFastScroll != null) {
        boolean intercepted = mFastScroll.onTouchEvent(ev);
        if (intercepted) {
            return true;
        }
    }
    initVelocityTrackerIfNotExists();
    final MotionEvent vtev = MotionEvent.obtain(ev);
    final int actionMasked = ev.getActionMasked();
    if (actionMasked == MotionEvent.ACTION_DOWN) {
        mNestedYOffset = 0;
    }
    vtev.offsetLocation(0, mNestedYOffset);
    switch(actionMasked) {
        case MotionEvent.ACTION_DOWN:
            {
                onTouchDown(ev);
                break;
            }
        case MotionEvent.ACTION_MOVE:
            {
                onTouchMove(ev, vtev);
                break;
            }
        case MotionEvent.ACTION_UP:
            {
                onTouchUp(ev);
                break;
            }
        case MotionEvent.ACTION_CANCEL:
            {
                onTouchCancel();
                break;
            }
        case MotionEvent.ACTION_POINTER_UP:
            {
                onSecondaryPointerUp(ev);
                final int x = mMotionX;
                final int y = mMotionY;
                final int motionPosition = pointToPosition(x, y);
                if (motionPosition >= 0) {
                    // Remember where the motion event started
                    final View child = getChildAt(motionPosition - mFirstPosition);
                    mMotionViewOriginalTop = child.getTop();
                    mMotionPosition = motionPosition;
                }
                mLastY = y;
                break;
            }
        case MotionEvent.ACTION_POINTER_DOWN:
            {
                // New pointers take over dragging duties
                final int index = ev.getActionIndex();
                final int id = ev.getPointerId(index);
                final int x = (int) ev.getX(index);
                final int y = (int) ev.getY(index);
                mMotionCorrection = 0;
                mActivePointerId = id;
                mMotionX = x;
                mMotionY = y;
                final int motionPosition = pointToPosition(x, y);
                if (motionPosition >= 0) {
                    // Remember where the motion event started
                    final View child = getChildAt(motionPosition - mFirstPosition);
                    mMotionViewOriginalTop = child.getTop();
                    mMotionPosition = motionPosition;
                }
                mLastY = y;
                break;
            }
    }
    if (mVelocityTracker != null) {
        mVelocityTracker.addMovement(vtev);
    }
    vtev.recycle();
    return true;
}","{
    if (!isEnabled()) {
        // events, it just doesn't respond to them.
        return isClickable() || isLongClickable();
    }
    if (mPositionScroller != null) {
        mPositionScroller.stop();
    }
    if (mIsDetaching || !isAttachedToWindow()) {
        // in a bogus state.
        return false;
    }
    startNestedScroll(SCROLL_AXIS_VERTICAL);
    if (mFastScroll != null && mFastScroll.onTouchEvent(ev)) {
        return true;
    }
    initVelocityTrackerIfNotExists();
    final MotionEvent vtev = MotionEvent.obtain(ev);
    final int actionMasked = ev.getActionMasked();
    if (actionMasked == MotionEvent.ACTION_DOWN) {
        mNestedYOffset = 0;
    }
    vtev.offsetLocation(0, mNestedYOffset);
    switch(actionMasked) {
        case MotionEvent.ACTION_DOWN:
            {
                onTouchDown(ev);
                break;
            }
        case MotionEvent.ACTION_MOVE:
            {
                onTouchMove(ev, vtev);
                break;
            }
        case MotionEvent.ACTION_UP:
            {
                onTouchUp(ev);
                break;
            }
        case MotionEvent.ACTION_CANCEL:
            {
                onTouchCancel();
                break;
            }
        case MotionEvent.ACTION_POINTER_UP:
            {
                onSecondaryPointerUp(ev);
                final int x = mMotionX;
                final int y = mMotionY;
                final int motionPosition = pointToPosition(x, y);
                if (motionPosition >= 0) {
                    // Remember where the motion event started
                    final View child = getChildAt(motionPosition - mFirstPosition);
                    mMotionViewOriginalTop = child.getTop();
                    mMotionPosition = motionPosition;
                }
                mLastY = y;
                break;
            }
        case MotionEvent.ACTION_POINTER_DOWN:
            {
                // New pointers take over dragging duties
                final int index = ev.getActionIndex();
                final int id = ev.getPointerId(index);
                final int x = (int) ev.getX(index);
                final int y = (int) ev.getY(index);
                mMotionCorrection = 0;
                mActivePointerId = id;
                mMotionX = x;
                mMotionY = y;
                final int motionPosition = pointToPosition(x, y);
                if (motionPosition >= 0) {
                    // Remember where the motion event started
                    final View child = getChildAt(motionPosition - mFirstPosition);
                    mMotionViewOriginalTop = child.getTop();
                    mMotionPosition = motionPosition;
                }
                mLastY = y;
                break;
            }
    }
    if (mVelocityTracker != null) {
        mVelocityTracker.addMovement(vtev);
    }
    vtev.recycle();
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
54,"<android.hardware.camera2.legacy.ParameterUtils: int getClosestAvailableZoomCrop(Parameters,Rect,Size,Rect,Rect,Rect)>",22,23,"<android.hardware.camera2.legacy.ParameterUtils: int getClosestAvailableZoomCrop(Parameters,Rect,Size,Rect,Rect,Rect)>","<android.hardware.camera2.legacy.ParameterUtils: int getClosestAvailableZoomCrop(Parameters,Rect,Size,Rect,Rect,Rect)>",0,"{
    checkNotNull(params, ""params must not be null"");
    checkNotNull(activeArray, ""activeArray must not be null"");
    checkNotNull(streamSize, ""streamSize must not be null"");
    checkNotNull(reportedCropRegion, ""reportedCropRegion must not be null"");
    checkNotNull(previewCropRegion, ""previewCropRegion must not be null"");
    Rect actualCrop = new Rect(cropRegion);
    /*
         * Shrink requested crop region to fit inside of the active array size
         */
    if (!actualCrop.intersect(activeArray)) {
        Log.w(TAG, ""getClosestAvailableZoomCrop - Crop region out of range; "" + ""setting to active array size"");
        actualCrop.set(activeArray);
    }
    Rect previewCrop = getPreviewCropRectangleUnzoomed(activeArray, streamSize);
    // Make the user-requested crop region the same aspect ratio as the preview stream size
    Rect cropRegionAsPreview = shrinkToSameAspectRatioCentered(previewCrop, actualCrop);
    if (VERBOSE) {
        Log.v(TAG, ""getClosestAvailableZoomCrop - actualCrop = "" + actualCrop);
        Log.v(TAG, ""getClosestAvailableZoomCrop - previewCrop = "" + previewCrop);
        Log.v(TAG, ""getClosestAvailableZoomCrop - cropRegionAsPreview = "" + cropRegionAsPreview);
    }
    /*
         * Iterate all available zoom rectangles and find the closest zoom index
         */
    Rect bestReportedCropRegion = null;
    Rect bestPreviewCropRegion = null;
    int bestZoomIndex = -1;
    List<Rect> availableReportedCropRegions = getAvailableZoomCropRectangles(params, activeArray);
    List<Rect> availablePreviewCropRegions = getAvailablePreviewZoomCropRectangles(params, activeArray, streamSize);
    if (VERBOSE) {
        Log.v(TAG, ""getClosestAvailableZoomCrop - availableReportedCropRegions = "" + ListUtils.listToString(availableReportedCropRegions));
        Log.v(TAG, ""getClosestAvailableZoomCrop - availablePreviewCropRegions = "" + ListUtils.listToString(availablePreviewCropRegions));
    }
    if (availableReportedCropRegions.size() != availablePreviewCropRegions.size()) {
        throw new AssertionError(""available reported/preview crop region size mismatch"");
    }
    for (int i = 0; i < availableReportedCropRegions.size(); ++i) {
        Rect currentPreviewCropRegion = availablePreviewCropRegions.get(i);
        Rect currentReportedCropRegion = availableReportedCropRegions.get(i);
        boolean isBest;
        if (bestZoomIndex == -1) {
            isBest = true;
        } else if (currentPreviewCropRegion.width() >= cropRegionAsPreview.width() && currentPreviewCropRegion.height() >= cropRegionAsPreview.height()) {
            isBest = true;
        } else {
            isBest = false;
        }
        // since its the largest crop that still fits the requested crop
        if (isBest) {
            bestPreviewCropRegion = currentPreviewCropRegion;
            bestReportedCropRegion = currentReportedCropRegion;
            bestZoomIndex = i;
        } else {
            break;
        }
    }
    if (bestZoomIndex == -1) {
        // Even in the worst case, we should always at least return 0 here
        throw new AssertionError(""Should've found at least one valid zoom index"");
    }
    // Write the rectangles in-place
    reportedCropRegion.set(bestReportedCropRegion);
    previewCropRegion.set(bestPreviewCropRegion);
    return bestZoomIndex;
}","{
    checkNotNull(params, ""params must not be null"");
    checkNotNull(activeArray, ""activeArray must not be null"");
    checkNotNull(streamSize, ""streamSize must not be null"");
    checkNotNull(reportedCropRegion, ""reportedCropRegion must not be null"");
    checkNotNull(previewCropRegion, ""previewCropRegion must not be null"");
    Rect actualCrop = new Rect(cropRegion);
    /*
         * Shrink requested crop region to fit inside of the active array size
         */
    if (!actualCrop.intersect(activeArray)) {
        Log.w(TAG, ""getClosestAvailableZoomCrop - Crop region out of range; "" + ""setting to active array size"");
        actualCrop.set(activeArray);
    }
    Rect previewCrop = getPreviewCropRectangleUnzoomed(activeArray, streamSize);
    // Make the user-requested crop region the same aspect ratio as the preview stream size
    Rect cropRegionAsPreview = shrinkToSameAspectRatioCentered(previewCrop, actualCrop);
    if (DEBUG) {
        Log.v(TAG, ""getClosestAvailableZoomCrop - actualCrop = "" + actualCrop);
        Log.v(TAG, ""getClosestAvailableZoomCrop - previewCrop = "" + previewCrop);
        Log.v(TAG, ""getClosestAvailableZoomCrop - cropRegionAsPreview = "" + cropRegionAsPreview);
    }
    /*
         * Iterate all available zoom rectangles and find the closest zoom index
         */
    Rect bestReportedCropRegion = null;
    Rect bestPreviewCropRegion = null;
    int bestZoomIndex = -1;
    List<Rect> availableReportedCropRegions = getAvailableZoomCropRectangles(params, activeArray);
    List<Rect> availablePreviewCropRegions = getAvailablePreviewZoomCropRectangles(params, activeArray, streamSize);
    if (DEBUG) {
        Log.v(TAG, ""getClosestAvailableZoomCrop - availableReportedCropRegions = "" + ListUtils.listToString(availableReportedCropRegions));
        Log.v(TAG, ""getClosestAvailableZoomCrop - availablePreviewCropRegions = "" + ListUtils.listToString(availablePreviewCropRegions));
    }
    if (availableReportedCropRegions.size() != availablePreviewCropRegions.size()) {
        throw new AssertionError(""available reported/preview crop region size mismatch"");
    }
    for (int i = 0; i < availableReportedCropRegions.size(); ++i) {
        Rect currentPreviewCropRegion = availablePreviewCropRegions.get(i);
        Rect currentReportedCropRegion = availableReportedCropRegions.get(i);
        boolean isBest;
        if (bestZoomIndex == -1) {
            isBest = true;
        } else if (currentPreviewCropRegion.width() >= cropRegionAsPreview.width() && currentPreviewCropRegion.height() >= cropRegionAsPreview.height()) {
            isBest = true;
        } else {
            isBest = false;
        }
        // since its the largest crop that still fits the requested crop
        if (isBest) {
            bestPreviewCropRegion = currentPreviewCropRegion;
            bestReportedCropRegion = currentReportedCropRegion;
            bestZoomIndex = i;
        } else {
            break;
        }
    }
    if (bestZoomIndex == -1) {
        // Even in the worst case, we should always at least return 0 here
        throw new AssertionError(""Should've found at least one valid zoom index"");
    }
    // Write the rectangles in-place
    reportedCropRegion.set(bestReportedCropRegion);
    previewCropRegion.set(bestPreviewCropRegion);
    return bestZoomIndex;
}",1,"/**
 * Calculate the closest zoom index for the user-requested crop region by rounding
 * up to the closest (largest or equal) possible zoom crop.
 *
 * <p>If the requested crop region exceeds the size of the active array, it is
 * shrunk to fit inside of the active array first.</p>
 *
 * <p>Since all api1 camera devices only support a discrete set of zooms, we have
 * to translate the per-pixel-granularity requested crop region into a per-zoom-index
 * granularity.</p>
 *
 * <p>Furthermore, since the zoom index and zoom levels also depends on the field-of-view
 * of the preview, the current preview {@code streamSize} is also used.</p>
 *
 * <p>The calculated crop regions are then written to in-place to {@code reportedCropRegion}
 * and {@code previewCropRegion}, in coordinates relative to the active array.</p>
 *
 * @param params non-{@code null} camera api1 parameters
 * @param activeArray active array dimensions, in sensor space
 * @param streamSize stream size dimensions, in pixels
 * @param cropRegion user-specified crop region, in active array coordinates
 * @param reportedCropRegion (out parameter) what the result for {@code cropRegion} looks like
 * @param previewCropRegion (out parameter) what the visual preview crop is
 * @return
 * the zoom index inclusively between 0 and {@code Parameters#getMaxZoom},
 * where 0 means the camera is not zoomed
 *
 * @throws NullPointerException if any of the args were {@code null}
 */
","/**
 * Calculate the closest zoom index for the user-requested crop region by rounding
 * up to the closest (largest or equal) possible zoom crop.
 *
 * <p>If the requested crop region exceeds the size of the active array, it is
 * shrunk to fit inside of the active array first.</p>
 *
 * <p>Since all api1 camera devices only support a discrete set of zooms, we have
 * to translate the per-pixel-granularity requested crop region into a per-zoom-index
 * granularity.</p>
 *
 * <p>Furthermore, since the zoom index and zoom levels also depends on the field-of-view
 * of the preview, the current preview {@code streamSize} is also used.</p>
 *
 * <p>The calculated crop regions are then written to in-place to {@code reportedCropRegion}
 * and {@code previewCropRegion}, in coordinates relative to the active array.</p>
 *
 * @param params non-{@code null} camera api1 parameters
 * @param activeArray active array dimensions, in sensor space
 * @param streamSize stream size dimensions, in pixels
 * @param cropRegion user-specified crop region, in active array coordinates
 * @param reportedCropRegion (out parameter) what the result for {@code cropRegion} looks like
 * @param previewCropRegion (out parameter) what the visual preview crop is
 * @return
 * the zoom index inclusively between 0 and {@code Parameters#getMaxZoom},
 * where 0 means the camera is not zoomed
 *
 * @throws NullPointerException if any of the args were {@code null}
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
55,<android.widget.AppSecurityPermissions.PermissionItemView: void onClick(View)>,22,23,<android.widget.AppSecurityPermissions.PermissionItemView: void onClick(View)>,<android.widget.AppSecurityPermissions.PermissionItemView: void onClick(View)>,0,"{
    if (mGroup != null && mPerm != null) {
        if (mDialog != null) {
            mDialog.dismiss();
        }
        PackageManager pm = getContext().getPackageManager();
        AlertDialog.Builder builder = new AlertDialog.Builder(getContext());
        builder.setTitle(mGroup.mLabel);
        if (mPerm.descriptionRes != 0) {
            builder.setMessage(mPerm.loadDescription(pm));
        } else {
            CharSequence appName;
            try {
                ApplicationInfo app = pm.getApplicationInfo(mPerm.packageName, 0);
                appName = app.loadLabel(pm);
            } catch (NameNotFoundException e) {
                appName = mPerm.packageName;
            }
            StringBuilder sbuilder = new StringBuilder(128);
            sbuilder.append(getContext().getString(R.string.perms_description_app, appName));
            sbuilder.append(""\n\n"");
            sbuilder.append(mPerm.name);
            builder.setMessage(sbuilder.toString());
        }
        builder.setCancelable(true);
        builder.setIcon(mGroup.loadGroupIcon(pm));
        addRevokeUIIfNecessary(builder);
        mDialog = builder.show();
        mDialog.setCanceledOnTouchOutside(true);
    }
}","{
    if (mGroup != null && mPerm != null) {
        if (mDialog != null) {
            mDialog.dismiss();
        }
        PackageManager pm = getContext().getPackageManager();
        AlertDialog.Builder builder = new AlertDialog.Builder(getContext());
        builder.setTitle(mGroup.mLabel);
        if (mPerm.descriptionRes != 0) {
            builder.setMessage(mPerm.loadDescription(pm));
        } else {
            CharSequence appName;
            try {
                ApplicationInfo app = pm.getApplicationInfo(mPerm.packageName, 0);
                appName = app.loadLabel(pm);
            } catch (NameNotFoundException e) {
                appName = mPerm.packageName;
            }
            StringBuilder sbuilder = new StringBuilder(128);
            sbuilder.append(getContext().getString(R.string.perms_description_app, appName));
            sbuilder.append(""\n\n"");
            sbuilder.append(mPerm.name);
            builder.setMessage(sbuilder.toString());
        }
        builder.setCancelable(true);
        builder.setIcon(mGroup.loadGroupIcon(getContext(), pm));
        addRevokeUIIfNecessary(builder);
        mDialog = builder.show();
        mDialog.setCanceledOnTouchOutside(true);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The method call parameter for `mGroup.loadGroupIcon` has changed from passing a single `pm` object to passing `getContext()` along with `pm`. This is an example of Other statement changed, and it also reflects a change in the dependent API since the `loadGroupIcon` method signature may have changed between versions. Thus, the code change types are 4,5.","However, this change does not cause a Compatibility Issue because the change in method call parameters does not affect the behavior of the onClick method in terms of the return type or value, or exception handling. Therefore, there is no Compatibility Issue."
56,<android.webkit.WebView: boolean overlayVerticalScrollbar()>,22,23,<android.webkit.WebView: boolean overlayVerticalScrollbar()>,<android.webkit.WebView: boolean overlayVerticalScrollbar()>,0,"{
    checkThread();
    return mProvider.overlayVerticalScrollbar();
}","{
    // The old implementation defaulted to false, so return false for consistency
    return false;
}",1,"/**
 * Gets whether vertical scrollbar has overlay style.
 *
 * @return true if vertical scrollbar has overlay style
 */
","/**
 * Gets whether vertical scrollbar has overlay style.
 *
 * @deprecated This method is now obsolete.
 * @return false
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from mProvider.overlayVerticalScrollbar() to a hard-coded false, and it does not depend on the mProvider object or any other method call. This represents a direct change in the return value. Additionally, a dependent API (mProvider.overlayVerticalScrollbar()) is removed from the method body, so the code change type is 1,5.","The return value has been changed unconditionally to false. Hence, the late version will always return false regardless of the previous implementation's logic, leading to a potential difference in behavior. Such a change directly results in a Compatibility Issue because the method consistently returns a different value. The CI type is 1."
57,"<android.widget.OverScroller.SplineOverScroller: boolean springback(int,int,int)>",22,23,"<android.widget.OverScroller.SplineOverScroller: boolean springback(int,int,int)>","<android.widget.OverScroller.SplineOverScroller: boolean springback(int,int,int)>",0,"{
    mFinished = true;
    mStart = mFinal = start;
    mVelocity = 0;
    mStartTime = AnimationUtils.currentAnimationTimeMillis();
    mDuration = 0;
    if (start < min) {
        startSpringback(start, min, 0);
    } else if (start > max) {
        startSpringback(start, max, 0);
    }
    return !mFinished;
}","{
    mFinished = true;
    mCurrentPosition = mStart = mFinal = start;
    mVelocity = 0;
    mStartTime = AnimationUtils.currentAnimationTimeMillis();
    mDuration = 0;
    if (start < min) {
        startSpringback(start, min, 0);
    } else if (start > max) {
        startSpringback(start, max, 0);
    }
    return !mFinished;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"A new field assignment (mCurrentPosition = mStart) has been introduced in the late version of the implementation, and this additionally assigned field does not seem to affect the return value or exception handling, so the code change type is 4.","There is no Compatibility Issue since the return statement and the method contract remain the same, and the change does not affect the value returned by the method nor does it affect the exception handling; therefore, the API would behave identically in terms of its external interactions."
59,<android.app.AlarmManager: void setTimeZone(String)>,22,23,<android.app.AlarmManager: void setTimeZone(String)>,<android.app.AlarmManager: void setTimeZone(String)>,0,"{
    try {
        mService.setTimeZone(timeZone);
    } catch (RemoteException ex) {
    }
}","{
    if (TextUtils.isEmpty(timeZone)) {
        return;
    }
    // Reject this timezone if it isn't an Olson zone we recognize.
    if (mTargetSdkVersion >= Build.VERSION_CODES.M) {
        boolean hasTimeZone = false;
        try {
            hasTimeZone = ZoneInfoDB.getInstance().hasTimeZone(timeZone);
        } catch (IOException ignored) {
        }
        if (!hasTimeZone) {
            throw new IllegalArgumentException(""Timezone: "" + timeZone + "" is not an Olson ID"");
        }
    }
    try {
        mService.setTimeZone(timeZone);
    } catch (RemoteException ex) {
    }
}",1,"/**
 * Set the system default time zone.
 * Requires the permission android.permission.SET_TIME_ZONE.
 *
 * @param timeZone in the format understood by {@link java.util.TimeZone}
 */
","/**
 * Sets the system's persistent default time zone. This is the time zone for all apps, even
 * after a reboot. Use {@link java.util.TimeZone#setDefault} if you just want to change the
 * time zone within your app, and even then prefer to pass an explicit
 * {@link java.util.TimeZone} to APIs that require it rather than changing the time zone for
 * all threads.
 *
 * <p> On android M and above, it is an error to pass in a non-Olson timezone to this
 * function. Note that this is a bad idea on all Android releases because POSIX and
 * the {@code TimeZone} class have opposite interpretations of {@code '+'} and {@code '-'}
 * in the same non-Olson ID.
 *
 * @param timeZone one of the Olson ids from the list returned by
 * {@link java.util.TimeZone#getAvailableIDs}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,3","1,2","The late version introduces a new check for the empty string and a new control dependency with checks for the SDK version and validates the time zone against known Olson IDs. This change can result in a different return statement when the time zone string is empty or not valid. An exception is also introduced with the `IllegalArgumentException`, and the structure of the try-catch block is altered. Thus, the code change type is 1,2,3.",There are new execution paths introduced that can lead to different behaviors:
60,<android.animation.AnimatorSet: AnimatorSet clone()>,22,23,<android.animation.AnimatorSet: AnimatorSet clone()>,<android.animation.AnimatorSet: AnimatorSet clone()>,0,"{
    final AnimatorSet anim = (AnimatorSet) super.clone();
    /*
         * The basic clone() operation copies all items. This doesn't work very well for
         * AnimatorSet, because it will copy references that need to be recreated and state
         * that may not apply. What we need to do now is put the clone in an uninitialized
         * state, with fresh, empty data structures. Then we will build up the nodes list
         * manually, as we clone each Node (and its animation). The clone will then be sorted,
         * and will populate any appropriate lists, when it is started.
         */
    final int nodeCount = mNodes.size();
    anim.mNeedsSort = true;
    anim.mTerminated = false;
    anim.mStarted = false;
    anim.mPlayingSet = new ArrayList<Animator>();
    anim.mNodeMap = new HashMap<Animator, Node>();
    anim.mNodes = new ArrayList<Node>(nodeCount);
    anim.mSortedNodes = new ArrayList<Node>(nodeCount);
    anim.mReversible = mReversible;
    anim.mSetListener = null;
    for (int n = 0; n < nodeCount; n++) {
        final Node node = mNodes.get(n);
        Node nodeClone = node.clone();
        node.mTmpClone = nodeClone;
        anim.mNodes.add(nodeClone);
        anim.mNodeMap.put(nodeClone.animation, nodeClone);
        // Clear out the dependencies in the clone; we'll set these up manually later
        nodeClone.dependencies = null;
        nodeClone.tmpDependencies = null;
        nodeClone.nodeDependents = null;
        nodeClone.nodeDependencies = null;
        // clear out any listeners that were set up by the AnimatorSet; these will
        // be set up when the clone's nodes are sorted
        final ArrayList<AnimatorListener> cloneListeners = nodeClone.animation.getListeners();
        if (cloneListeners != null) {
            for (int i = cloneListeners.size() - 1; i >= 0; i--) {
                final AnimatorListener listener = cloneListeners.get(i);
                if (listener instanceof AnimatorSetListener) {
                    cloneListeners.remove(i);
                }
            }
        }
    }
    // dependencies, mapping the old dependencies to the new nodes
    for (int n = 0; n < nodeCount; n++) {
        final Node node = mNodes.get(n);
        final Node clone = node.mTmpClone;
        if (node.dependencies != null) {
            clone.dependencies = new ArrayList<Dependency>(node.dependencies.size());
            final int depSize = node.dependencies.size();
            for (int i = 0; i < depSize; i++) {
                final Dependency dependency = node.dependencies.get(i);
                Dependency cloneDependency = new Dependency(dependency.node.mTmpClone, dependency.rule);
                clone.dependencies.add(cloneDependency);
            }
        }
        if (node.nodeDependents != null) {
            clone.nodeDependents = new ArrayList<Node>(node.nodeDependents.size());
            for (Node dep : node.nodeDependents) {
                clone.nodeDependents.add(dep.mTmpClone);
            }
        }
        if (node.nodeDependencies != null) {
            clone.nodeDependencies = new ArrayList<Node>(node.nodeDependencies.size());
            for (Node dep : node.nodeDependencies) {
                clone.nodeDependencies.add(dep.mTmpClone);
            }
        }
    }
    for (int n = 0; n < nodeCount; n++) {
        mNodes.get(n).mTmpClone = null;
    }
    return anim;
}","{
    final AnimatorSet anim = (AnimatorSet) super.clone();
    /*
         * The basic clone() operation copies all items. This doesn't work very well for
         * AnimatorSet, because it will copy references that need to be recreated and state
         * that may not apply. What we need to do now is put the clone in an uninitialized
         * state, with fresh, empty data structures. Then we will build up the nodes list
         * manually, as we clone each Node (and its animation). The clone will then be sorted,
         * and will populate any appropriate lists, when it is started.
         */
    final int nodeCount = mNodes.size();
    anim.mNeedsSort = true;
    anim.mTerminated = false;
    anim.mStarted = false;
    anim.mPlayingSet = new ArrayList<Animator>();
    anim.mNodeMap = new ArrayMap<Animator, Node>();
    anim.mNodes = new ArrayList<Node>(nodeCount);
    anim.mSortedNodes = new ArrayList<Node>(nodeCount);
    anim.mReversible = mReversible;
    anim.mSetListener = null;
    for (int n = 0; n < nodeCount; n++) {
        final Node node = mNodes.get(n);
        Node nodeClone = node.clone();
        node.mTmpClone = nodeClone;
        anim.mNodes.add(nodeClone);
        anim.mNodeMap.put(nodeClone.animation, nodeClone);
        // Clear out the dependencies in the clone; we'll set these up manually later
        nodeClone.dependencies = null;
        nodeClone.tmpDependencies = null;
        nodeClone.nodeDependents = null;
        nodeClone.nodeDependencies = null;
        // clear out any listeners that were set up by the AnimatorSet; these will
        // be set up when the clone's nodes are sorted
        final ArrayList<AnimatorListener> cloneListeners = nodeClone.animation.getListeners();
        if (cloneListeners != null) {
            for (int i = cloneListeners.size() - 1; i >= 0; i--) {
                final AnimatorListener listener = cloneListeners.get(i);
                if (listener instanceof AnimatorSetListener) {
                    cloneListeners.remove(i);
                }
            }
        }
    }
    // dependencies, mapping the old dependencies to the new nodes
    for (int n = 0; n < nodeCount; n++) {
        final Node node = mNodes.get(n);
        final Node clone = node.mTmpClone;
        if (node.dependencies != null) {
            clone.dependencies = new ArrayList<Dependency>(node.dependencies.size());
            final int depSize = node.dependencies.size();
            for (int i = 0; i < depSize; i++) {
                final Dependency dependency = node.dependencies.get(i);
                Dependency cloneDependency = new Dependency(dependency.node.mTmpClone, dependency.rule);
                clone.dependencies.add(cloneDependency);
            }
        }
        if (node.nodeDependents != null) {
            clone.nodeDependents = new ArrayList<Node>(node.nodeDependents.size());
            for (Node dep : node.nodeDependents) {
                clone.nodeDependents.add(dep.mTmpClone);
            }
        }
        if (node.nodeDependencies != null) {
            clone.nodeDependencies = new ArrayList<Node>(node.nodeDependencies.size());
            for (Node dep : node.nodeDependencies) {
                clone.nodeDependencies.add(dep.mTmpClone);
            }
        }
    }
    for (int n = 0; n < nodeCount; n++) {
        mNodes.get(n).mTmpClone = null;
    }
    return anim;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
61,<android.view.View: ActionMode startActionMode(Callback)>,22,23,<android.view.View: ActionMode startActionMode(Callback)>,<android.view.View: ActionMode startActionMode(Callback)>,0,"{
    ViewParent parent = getParent();
    if (parent == null)
        return null;
    return parent.startActionModeForChild(this, callback);
}","{
    return startActionMode(callback, ActionMode.TYPE_PRIMARY);
}",1,"/**
 * Start an action mode.
 *
 * @param callback Callback that will control the lifecycle of the action mode
 * @return The new action mode if it is started, null otherwise
 *
 * @see ActionMode
 */
","/**
 * Start an action mode with the default type {@link ActionMode#TYPE_PRIMARY}.
 *
 * @param callback Callback that will control the lifecycle of the action mode
 * @return The new action mode if it is started, null otherwise
 *
 * @see ActionMode
 * @see #startActionMode(android.view.ActionMode.Callback, int)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation of method has completely changed: the early version calls 'parent.startActionModeForChild', and the late version directly calls 'startActionMode(callback, ActionMode.TYPE_PRIMARY)'. It indicates not only a change in the return statement but also a dependent API has been changed. Hence, the code change types are 1 and 5.","The change completely alters the behavior of the method, as it now calls a different version of 'startActionMode' with a different signature. This could lead to different return values as the action mode started might not be equivalent to the one expected in the original API usage. Thus, the CI type is 1."
62,"<android.app.PendingIntent: void send(Context,int,Intent,OnFinished,Handler,String)>",22,23,"<android.app.PendingIntent: void send(Context,int,Intent,OnFinished,Handler,String)>","<android.app.PendingIntent: void send(Context,int,Intent,OnFinished,Handler,String)>",0,"{
    try {
        String resolvedType = intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
        int res = mTarget.send(code, intent, resolvedType, onFinished != null ? new FinishedDispatcher(this, onFinished, handler) : null, requiredPermission);
        if (res < 0) {
            throw new CanceledException();
        }
    } catch (RemoteException e) {
        throw new CanceledException(e);
    }
}","{
    send(context, code, intent, onFinished, handler, requiredPermission, null);
}",1,"/**
 * Perform the operation associated with this PendingIntent, allowing the
 * caller to specify information about the Intent to use and be notified
 * when the send has completed.
 *
 * <p>For the intent parameter, a PendingIntent
 * often has restrictions on which fields can be supplied here, based on
 * how the PendingIntent was retrieved in {@link #getActivity},
 * {@link #getBroadcast}, or {@link #getService}.
 *
 * @param context The Context of the caller.  This may be null if
 * <var>intent</var> is also null.
 * @param code Result code to supply back to the PendingIntent's target.
 * @param intent Additional Intent data.  See {@link Intent#fillIn
 * Intent.fillIn()} for information on how this is applied to the
 * original Intent.  Use null to not modify the original Intent.
 * @param onFinished The object to call back on when the send has
 * completed, or null for no callback.
 * @param handler Handler identifying the thread on which the callback
 * should happen.  If null, the callback will happen from the thread
 * pool of the process.
 * @param requiredPermission Name of permission that a recipient of the PendingIntent
 * is required to hold.  This is only valid for broadcast intents, and
 * corresponds to the permission argument in
 * {@link Context#sendBroadcast(Intent, String) Context.sendOrderedBroadcast(Intent, String)}.
 * If null, no permission is required.
 *
 * @see #send()
 * @see #send(int)
 * @see #send(Context, int, Intent)
 * @see #send(int, android.app.PendingIntent.OnFinished, Handler)
 * @see #send(Context, int, Intent, OnFinished, Handler)
 *
 * @throws CanceledException Throws CanceledException if the PendingIntent
 * is no longer allowing more intents to be sent through it.
 */
","/**
 * Perform the operation associated with this PendingIntent, allowing the
 * caller to specify information about the Intent to use and be notified
 * when the send has completed.
 *
 * <p>For the intent parameter, a PendingIntent
 * often has restrictions on which fields can be supplied here, based on
 * how the PendingIntent was retrieved in {@link #getActivity},
 * {@link #getBroadcast}, or {@link #getService}.
 *
 * @param context The Context of the caller.  This may be null if
 * <var>intent</var> is also null.
 * @param code Result code to supply back to the PendingIntent's target.
 * @param intent Additional Intent data.  See {@link Intent#fillIn
 * Intent.fillIn()} for information on how this is applied to the
 * original Intent.  Use null to not modify the original Intent.
 * If flag {@link #FLAG_IMMUTABLE} was set when this pending intent was
 * created, this argument will be ignored.
 * @param onFinished The object to call back on when the send has
 * completed, or null for no callback.
 * @param handler Handler identifying the thread on which the callback
 * should happen.  If null, the callback will happen from the thread
 * pool of the process.
 * @param requiredPermission Name of permission that a recipient of the PendingIntent
 * is required to hold.  This is only valid for broadcast intents, and
 * corresponds to the permission argument in
 * {@link Context#sendBroadcast(Intent, String) Context.sendOrderedBroadcast(Intent, String)}.
 * If null, no permission is required.
 *
 * @see #send()
 * @see #send(int)
 * @see #send(Context, int, Intent)
 * @see #send(int, android.app.PendingIntent.OnFinished, Handler)
 * @see #send(Context, int, Intent, OnFinished, Handler)
 *
 * @throws CanceledException Throws CanceledException if the PendingIntent
 * is no longer allowing more intents to be sent through it.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The late version of the method is calling another overloaded method of the same class, send(), with an additional parameter. The entire body of the method was replaced by this single call. Hence, the change type is 5.","Since the implementation of send() in the late version delegates to another method that presumably contains the same operational code as seen in the early version, with an additional parameter that is set to null, there should be no compatibility issue stemming from this change as long as the additional method behaves the same when passed a null for the new parameter. However, without seeing the implementation of the called method, I cannot definitively determine effects, but based on the provided information, it seems like there is no Compatibility Issue."
63,"<android.transition.Explode: Animator onDisappear(ViewGroup,View,TransitionValues,TransitionValues)>",22,23,"<android.transition.Explode: Animator onDisappear(ViewGroup,View,TransitionValues,TransitionValues)>","<android.transition.Explode: Animator onDisappear(ViewGroup,View,TransitionValues,TransitionValues)>",0,"{
    if (startValues == null) {
        return null;
    }
    Rect bounds = (Rect) startValues.values.get(PROPNAME_SCREEN_BOUNDS);
    int viewPosX = bounds.left;
    int viewPosY = bounds.top;
    float startX = view.getTranslationX();
    float startY = view.getTranslationY();
    float endX = startX;
    float endY = startY;
    int[] interruptedPosition = (int[]) startValues.view.getTag(R.id.transitionPosition);
    if (interruptedPosition != null) {
        // We want to have the end position relative to the interrupted position, not
        // the position it was supposed to start at.
        endX += interruptedPosition[0] - bounds.left;
        endY += interruptedPosition[1] - bounds.top;
        bounds.offsetTo(interruptedPosition[0], interruptedPosition[1]);
    }
    calculateOut(sceneRoot, bounds, mTempLoc);
    endX += mTempLoc[0];
    endY += mTempLoc[1];
    return TranslationAnimationCreator.createAnimation(view, startValues, viewPosX, viewPosY, startX, startY, endX, endY, sAccelerate);
}","{
    if (startValues == null) {
        return null;
    }
    Rect bounds = (Rect) startValues.values.get(PROPNAME_SCREEN_BOUNDS);
    int viewPosX = bounds.left;
    int viewPosY = bounds.top;
    float startX = view.getTranslationX();
    float startY = view.getTranslationY();
    float endX = startX;
    float endY = startY;
    int[] interruptedPosition = (int[]) startValues.view.getTag(R.id.transitionPosition);
    if (interruptedPosition != null) {
        // We want to have the end position relative to the interrupted position, not
        // the position it was supposed to start at.
        endX += interruptedPosition[0] - bounds.left;
        endY += interruptedPosition[1] - bounds.top;
        bounds.offsetTo(interruptedPosition[0], interruptedPosition[1]);
    }
    calculateOut(sceneRoot, bounds, mTempLoc);
    endX += mTempLoc[0];
    endY += mTempLoc[1];
    return TranslationAnimationCreator.createAnimation(view, startValues, viewPosX, viewPosY, startX, startY, endX, endY, sAccelerate, this);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The method `createAnimation` of `TranslationAnimationCreator` has been called with an additional parameter `this` in the late version, which indicates a change in the dependent API, and thus the change types are 1 (since a different method may be invoked which returns different value) and 5.","The compatibility issue is caused by a potential different return value due to the change in the call to `createAnimation`, adding an extra parameter could result in a different behavior, so the CI type is 1."
64,<android.os.ParcelFileDescriptor: int detachFd()>,22,23,<android.os.ParcelFileDescriptor: int detachFd()>,<android.os.ParcelFileDescriptor: int detachFd()>,0,"{
    if (mWrapped != null) {
        return mWrapped.detachFd();
    } else {
        if (mClosed) {
            throw new IllegalStateException(""Already closed"");
        }
        final int fd = getFd();
        Parcel.clearFileDescriptor(mFd);
        writeCommStatusAndClose(Status.DETACHED, null);
        return fd;
    }
}","{
    if (mWrapped != null) {
        return mWrapped.detachFd();
    } else {
        if (mClosed) {
            throw new IllegalStateException(""Already closed"");
        }
        final int fd = getFd();
        Parcel.clearFileDescriptor(mFd);
        writeCommStatusAndClose(Status.DETACHED, null);
        mClosed = true;
        mGuard.close();
        releaseResources();
        return fd;
    }
}",1,"/**
 * Return the native fd int for this ParcelFileDescriptor and detach it from
 * the object here. You are now responsible for closing the fd in native
 * code.
 * <p>
 * You should not detach when the original creator of the descriptor is
 * expecting a reliable signal through {@link #close()} or
 * {@link #closeWithError(String)}.
 *
 * @see #canDetectErrors()
 */
","/**
 * Return the native fd int for this ParcelFileDescriptor and detach it from
 * the object here. You are now responsible for closing the fd in native
 * code.
 * <p>
 * You should not detach when the original creator of the descriptor is
 * expecting a reliable signal through {@link #close()} or
 * {@link #closeWithError(String)}.
 *
 * @see #canDetectErrors()
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"New statements 'mClosed = true;', 'mGuard.close();', and 'releaseResources();' have been added, which are not return or exception handling statements, nor do they change control flow. Therefore, the code change type is 4.","The additions of 'mClosed = true;', 'mGuard.close();', and 'releaseResources();' do not directly affect the returned value or the exception thrown, they rather seem to be cleanup and state update operations after the file descriptor has already been detached. The behavior of the detachFd() method, in terms of what it returns or the exceptions it throws under the given conditions, remains consistent between the two versions. Thus, there is no Compatibility Issue."
69,<android.widget.TextView: boolean onTextContextMenuItem(int)>,22,23,<android.widget.TextView: boolean onTextContextMenuItem(int)>,<android.widget.TextView: boolean onTextContextMenuItem(int)>,0,"{
    int min = 0;
    int max = mText.length();
    if (isFocused()) {
        final int selStart = getSelectionStart();
        final int selEnd = getSelectionEnd();
        min = Math.max(0, Math.min(selStart, selEnd));
        max = Math.max(0, Math.max(selStart, selEnd));
    }
    switch(id) {
        case ID_SELECT_ALL:
            // This does not enter text selection mode. Text is highlighted, so that it can be
            // bulk edited, like selectAllOnFocus does. Returns true even if text is empty.
            selectAllText();
            return true;
        case ID_PASTE:
            paste(min, max);
            return true;
        case ID_CUT:
            setPrimaryClip(ClipData.newPlainText(null, getTransformedText(min, max)));
            deleteText_internal(min, max);
            stopSelectionActionMode();
            return true;
        case ID_COPY:
            setPrimaryClip(ClipData.newPlainText(null, getTransformedText(min, max)));
            stopSelectionActionMode();
            return true;
    }
    return false;
}","{
    int min = 0;
    int max = mText.length();
    if (isFocused()) {
        final int selStart = getSelectionStart();
        final int selEnd = getSelectionEnd();
        min = Math.max(0, Math.min(selStart, selEnd));
        max = Math.max(0, Math.max(selStart, selEnd));
    }
    switch(id) {
        case ID_SELECT_ALL:
            // This starts an action mode if triggered from another action mode. Text is
            // highlighted, so that it can be bulk edited, like selectAllOnFocus does. Returns
            // true even if text is empty.
            boolean shouldRestartActionMode = mEditor != null && mEditor.mTextActionMode != null;
            stopTextActionMode();
            selectAllText();
            if (shouldRestartActionMode) {
                mEditor.startSelectionActionMode();
            }
            return true;
        case ID_UNDO:
            if (mEditor != null) {
                mEditor.undo();
            }
            // Returns true even if nothing was undone.
            return true;
        case ID_REDO:
            if (mEditor != null) {
                mEditor.redo();
            }
            // Returns true even if nothing was undone.
            return true;
        case ID_PASTE:
            paste(min, max, true);
            return true;
        case ID_PASTE_AS_PLAIN_TEXT:
            paste(min, max, false);
            return true;
        case ID_CUT:
            setPrimaryClip(ClipData.newPlainText(null, getTransformedText(min, max)));
            deleteText_internal(min, max);
            stopTextActionMode();
            return true;
        case ID_COPY:
            setPrimaryClip(ClipData.newPlainText(null, getTransformedText(min, max)));
            stopTextActionMode();
            return true;
        case ID_REPLACE:
            if (mEditor != null) {
                mEditor.replace();
            }
            return true;
        case ID_SHARE:
            shareSelectedText();
            return true;
    }
    return false;
}",1,"/**
 * Called when a context menu option for the text view is selected.  Currently
 * this will be one of {@link android.R.id#selectAll}, {@link android.R.id#cut},
 * {@link android.R.id#copy} or {@link android.R.id#paste}.
 *
 * @return true if the context menu item action was performed.
 */
","/**
 * Called when a context menu option for the text view is selected.  Currently
 * this will be one of {@link android.R.id#selectAll}, {@link android.R.id#cut},
 * {@link android.R.id#copy}, {@link android.R.id#paste} or {@link android.R.id#shareText}.
 *
 * @return true if the context menu item action was performed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The changes to the method include the addition of new cases in the switch statement, a change in how the `ID_SELECT_ALL` case is handled, including additional logic to potentially start the selection action mode, and added cases `ID_UNDO`, `ID_REDO`, `ID_PASTE_AS_PLAIN_TEXT`, `ID_REPLACE`, and `ID_SHARE`. The method now also has the potential to call different methods like `mEditor.undo()`, `mEditor.redo()`, `paste(int, int, boolean)`, `mEditor.replace()`, and `shareSelectedText()`, which were not present in the early version. Furthermore, the paste method call changed from `paste(min, max)` to `paste(min, max, true)` indicating a change in the parameters, which are all classified under Return statement changed (1), Control dependency changed (3), and Other statement changed (4).","The added cases in the switch statement and the modifications in the existing cases (like `ID_SELECT_ALL` and `ID_PASTE`) could result in different return values and behaviors when the method is invoked, which presents a potential Compatibility Issue (1) due to different return values. The introduction of new operations and branches based on the ID passed to the method would mean clients relying on the previous behavior might experience unexpected behaviors if they do not account for these new cases."
72,<android.speech.tts.TextToSpeech: Voice getDefaultVoice()>,22,23,<android.speech.tts.TextToSpeech: Voice getDefaultVoice()>,<android.speech.tts.TextToSpeech: Voice getDefaultVoice()>,0,"{
    return runAction(new Action<Voice>() {

        @Override
        public Voice run(ITextToSpeechService service) throws RemoteException {
            String[] defaultLanguage = service.getClientDefaultLanguage();
            if (defaultLanguage == null || defaultLanguage.length == 0) {
                Log.e(TAG, ""service.getClientDefaultLanguage() returned empty array"");
                return null;
            }
            String language = defaultLanguage[0];
            String country = (defaultLanguage.length > 1) ? defaultLanguage[1] : """";
            String variant = (defaultLanguage.length > 2) ? defaultLanguage[2] : """";
            // Sanitize the locale using isLanguageAvailable.
            int result = service.isLanguageAvailable(language, country, variant);
            if (result >= LANG_AVAILABLE) {
                if (result < LANG_COUNTRY_VAR_AVAILABLE) {
                    variant = """";
                    if (result < LANG_COUNTRY_AVAILABLE) {
                        country = """";
                    }
                }
            } else {
                // The default language is not supported.
                return null;
            }
            // Get the default voice name
            String voiceName = service.getDefaultVoiceNameFor(language, country, variant);
            if (TextUtils.isEmpty(voiceName)) {
                return null;
            }
            // Find it
            List<Voice> voices = service.getVoices();
            if (voices == null) {
                return null;
            }
            for (Voice voice : voices) {
                if (voice.getName().equals(voiceName)) {
                    return voice;
                }
            }
            return null;
        }
    }, null, ""getDefaultVoice"");
}","{
    return runAction(new Action<Voice>() {

        @Override
        public Voice run(ITextToSpeechService service) throws RemoteException {
            String[] defaultLanguage = service.getClientDefaultLanguage();
            if (defaultLanguage == null || defaultLanguage.length == 0) {
                Log.e(TAG, ""service.getClientDefaultLanguage() returned empty array"");
                return null;
            }
            String language = defaultLanguage[0];
            String country = (defaultLanguage.length > 1) ? defaultLanguage[1] : """";
            String variant = (defaultLanguage.length > 2) ? defaultLanguage[2] : """";
            // Sanitize the locale using isLanguageAvailable.
            int result = service.isLanguageAvailable(language, country, variant);
            if (result < LANG_AVAILABLE) {
                // The default language is not supported.
                return null;
            }
            // Get the default voice name
            String voiceName = service.getDefaultVoiceNameFor(language, country, variant);
            if (TextUtils.isEmpty(voiceName)) {
                return null;
            }
            // Find it
            List<Voice> voices = service.getVoices();
            if (voices == null) {
                return null;
            }
            for (Voice voice : voices) {
                if (voice.getName().equals(voiceName)) {
                    return voice;
                }
            }
            return null;
        }
    }, null, ""getDefaultVoice"");
}",1,"/**
 * Returns a Voice instance that's the default voice for the default Text-to-speech language.
 * @return The default voice instance for the default language, or {@code null} if not set or
 * on error.
 */
","/**
 * Returns a Voice instance that's the default voice for the default Text-to-speech language.
 * @return The default voice instance for the default language, or {@code null} if not set or
 * on error.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"The control dependency inside the 'if' statement that checks the result variable has been simplified, which alters the conditions under which the country and variant strings are set to an empty string. Only the parts in the 'if (result >= LANG_AVAILABLE)' block have been changed, which affects the returned Voice value, hence the code change type is 3.","The change in control dependency could lead to a change in the 'country' and 'variant' variables when 'result' is between LANG_AVAILABLE and LANG_COUNTRY_AVAILABLE. This could potentially affect the choice of the default voice returned by the method (since it might match a different voice). Therefore, the CI type is 1."
73,<android.view.Display: float[] getSupportedRefreshRates()>,22,23,<android.view.Display: float[] getSupportedRefreshRates()>,<android.view.Display: float[] getSupportedRefreshRates()>,0,"{
    synchronized (this) {
        updateDisplayInfoLocked();
        final float[] refreshRates = mDisplayInfo.supportedRefreshRates;
        return Arrays.copyOf(refreshRates, refreshRates.length);
    }
}","{
    synchronized (this) {
        updateDisplayInfoLocked();
        return mDisplayInfo.getDefaultRefreshRates();
    }
}",1,"/**
 * Get the supported refresh rates of this display in frames per second.
 */
","/**
 * Get the supported refresh rates of this display in frames per second.
 * <p>
 * This method only returns refresh rates for the display's default modes. For more options, use
 * {@link #getSupportedModes()}.
 *
 * @deprecated use {@link #getSupportedModes()} instead
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"4,5",1,"The implementation has been changed from directly accessing and copying an array of supported refresh rates to using a method call to `getDefaultRefreshRates()`. This involves a method call change (dependent API change), so the code change type is 4,5.","The change from directly copying an array to using a method call to obtain the supported refresh rates could potentially lead to a different return value if `getDefaultRefreshRates` behaves differently from the previous implementation, hence the CI type is 1."
75,<android.os.Parcel: T readParcelable(ClassLoader)>,22,23,<android.os.Parcel: T readParcelable(ClassLoader)>,<android.os.Parcel: T readParcelable(ClassLoader)>,0,"{
    Parcelable.Creator<T> creator = readParcelableCreator(loader);
    if (creator == null) {
        return null;
    }
    if (creator instanceof Parcelable.ClassLoaderCreator<?>) {
        return ((Parcelable.ClassLoaderCreator<T>) creator).createFromParcel(this, loader);
    }
    return creator.createFromParcel(this);
}","{
    Parcelable.Creator<?> creator = readParcelableCreator(loader);
    if (creator == null) {
        return null;
    }
    if (creator instanceof Parcelable.ClassLoaderCreator<?>) {
        Parcelable.ClassLoaderCreator<?> classLoaderCreator = (Parcelable.ClassLoaderCreator<?>) creator;
        return (T) classLoaderCreator.createFromParcel(this, loader);
    }
    return (T) creator.createFromParcel(this);
}",1,"/**
 * Read and return a new Parcelable from the parcel.  The given class loader
 * will be used to load any enclosed Parcelables.  If it is null, the default
 * class loader will be used.
 * @param loader A ClassLoader from which to instantiate the Parcelable
 * object, or null for the default class loader.
 * @return Returns the newly created Parcelable, or null if a null
 * object has been written.
 * @throws BadParcelableException Throws BadParcelableException if there
 * was an error trying to instantiate the Parcelable.
 */
","/**
 * Read and return a new Parcelable from the parcel.  The given class loader
 * will be used to load any enclosed Parcelables.  If it is null, the default
 * class loader will be used.
 * @param loader A ClassLoader from which to instantiate the Parcelable
 * object, or null for the default class loader.
 * @return Returns the newly created Parcelable, or null if a null
 * object has been written.
 * @throws BadParcelableException Throws BadParcelableException if there
 * was an error trying to instantiate the Parcelable.
 */
",-1,,"[@SuppressWarnings(""unchecked"")]",-1,-1,-1,-1,-1,-1,4,0,"The change is in casting details. In the early version, the cast is done within a single statement. In the late version, the creator object is assigned to a variable with explicit casting to 'Parcelable.ClassLoaderCreator<?>', and then 'createFromParcel' is called on this variable with a cast to 'T'. The 'SuppressWarnings(""unchecked"")' annotation makes clear that the unchecked cast is intentional, and no functional change is made to the behavior of the method. Thus, the change is of type 4.","Since the logic and the flow of the code have not changed, and this casting is a necessary part of using generics in Java, there is no behavior change. Hence, there's no Compatibility Issue here. The change only addresses the compiler warning about the unchecked cast."
76,<android.util.Range: int hashCode()>,22,23,<android.util.Range: int hashCode()>,<android.util.Range: int hashCode()>,0,"{
    return HashCodeHelpers.hashCode(mLower, mUpper);
}","{
    return HashCodeHelpers.hashCodeGeneric(mLower, mUpper);
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The implementation changed from calling `HashCodeHelpers.hashCode(mLower, mUpper)` to calling a different method `HashCodeHelpers.hashCodeGeneric(mLower, mUpper)`. This is classified as type 5 because the dependent API `HashCodeHelpers.hashCode` is changed to `HashCodeHelpers.hashCodeGeneric`.","There is no Compatibility issue here as long as the contract of `hashCodeGeneric` is guaranteed to be consistent with that of the original `hashCode` method for the given objects `mLower` and `mUpper`. The change in method is internal and should not affect the behavior or output of `hashCode()` as per the `hashCode` contract, which mandates consistency. Thus, as per the provided information, there's no evidence that the method change would lead to a different output, so there's no Compatibility Issue in this case."
77,<android.hardware.camera2.params.StreamConfigurationMap: boolean isOutputSupportedFor(Surface)>,22,23,<android.hardware.camera2.params.StreamConfigurationMap: boolean isOutputSupportedFor(Surface)>,<android.hardware.camera2.params.StreamConfigurationMap: boolean isOutputSupportedFor(Surface)>,0,"{
    checkNotNull(surface, ""surface must not be null"");
    Size surfaceSize;
    int surfaceFormat = -1;
    try {
        surfaceSize = LegacyCameraDevice.getSurfaceSize(surface);
        surfaceFormat = LegacyCameraDevice.detectSurfaceType(surface);
    } catch (BufferQueueAbandonedException e) {
        throw new IllegalArgumentException(""Abandoned surface"", e);
    }
    // See if consumer is flexible.
    boolean isFlexible = LegacyCameraDevice.isFlexibleConsumer(surface);
    // Override RGB formats to IMPLEMENTATION_DEFINED, b/9487482
    if ((surfaceFormat >= LegacyMetadataMapper.HAL_PIXEL_FORMAT_RGBA_8888 && surfaceFormat <= LegacyMetadataMapper.HAL_PIXEL_FORMAT_BGRA_8888)) {
        surfaceFormat = LegacyMetadataMapper.HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED;
    }
    for (StreamConfiguration config : mConfigurations) {
        if (config.getFormat() == surfaceFormat && config.isOutput()) {
            // and a size no bigger than MAX_DIMEN_FOR_ROUNDING
            if (config.getSize().equals(surfaceSize)) {
                return true;
            } else if (isFlexible && (config.getSize().getWidth() <= LegacyCameraDevice.MAX_DIMEN_FOR_ROUNDING)) {
                return true;
            }
        }
    }
    return false;
}","{
    checkNotNull(surface, ""surface must not be null"");
    Size surfaceSize = SurfaceUtils.getSurfaceSize(surface);
    int surfaceFormat = SurfaceUtils.getSurfaceFormat(surface);
    int surfaceDataspace = SurfaceUtils.getSurfaceDataspace(surface);
    // See if consumer is flexible.
    boolean isFlexible = SurfaceUtils.isFlexibleConsumer(surface);
    // Override RGB formats to IMPLEMENTATION_DEFINED, b/9487482
    if ((surfaceFormat >= LegacyMetadataMapper.HAL_PIXEL_FORMAT_RGBA_8888 && surfaceFormat <= LegacyMetadataMapper.HAL_PIXEL_FORMAT_BGRA_8888)) {
        surfaceFormat = HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED;
    }
    StreamConfiguration[] configs = surfaceDataspace != HAL_DATASPACE_DEPTH ? mConfigurations : mDepthConfigurations;
    for (StreamConfiguration config : configs) {
        if (config.getFormat() == surfaceFormat && config.isOutput()) {
            // and a size no bigger than MAX_DIMEN_FOR_ROUNDING
            if (config.getSize().equals(surfaceSize)) {
                return true;
            } else if (isFlexible && (config.getSize().getWidth() <= LegacyCameraDevice.MAX_DIMEN_FOR_ROUNDING)) {
                return true;
            }
        }
    }
    return false;
}",1,"/**
 * Determine whether or not the {@code surface} in its current state is suitable to be included
 * in a {@link CameraDevice#createCaptureSession capture session} as an output.
 *
 * <p>Not all surfaces are usable with the {@link CameraDevice}, and not all configurations
 * of that {@code surface} are compatible. Some classes that provide the {@code surface} are
 * compatible with the {@link CameraDevice} in general
 * (see {@link #isOutputSupportedFor(Class)}, but it is the caller's responsibility to put the
 * {@code surface} into a state that will be compatible with the {@link CameraDevice}.</p>
 *
 * <p>Reasons for a {@code surface} being specifically incompatible might be:
 * <ul>
 * <li>Using a format that's not listed by {@link #getOutputFormats}
 * <li>Using a format/size combination that's not listed by {@link #getOutputSizes}
 * <li>The {@code surface} itself is not in a state where it can service a new producer.</p>
 * </li>
 * </ul>
 *
 * <p>Surfaces from flexible sources will return true even if the exact size of the Surface does
 * not match a camera-supported size, as long as the format (or class) is supported and the
 * camera device supports a size that is equal to or less than 1080p in that format. If such as
 * Surface is used to create a capture session, it will have its size rounded to the nearest
 * supported size, below or equal to 1080p. Flexible sources include SurfaceView, SurfaceTexture,
 * and ImageReader.</p>
 *
 * <p>This is not an exhaustive list; see the particular class's documentation for further
 * possible reasons of incompatibility.</p>
 *
 * @param surface a non-{@code null} {@link Surface} object reference
 * @return {@code true} if this is supported, {@code false} otherwise
 *
 * @throws NullPointerException if {@code surface} was {@code null}
 * @throws IllegalArgumentException if the Surface endpoint is no longer valid
 *
 * @see CameraDevice#createCaptureSession
 * @see #isOutputSupportedFor(Class)
 */
","/**
 * Determine whether or not the {@code surface} in its current state is suitable to be included
 * in a {@link CameraDevice#createCaptureSession capture session} as an output.
 *
 * <p>Not all surfaces are usable with the {@link CameraDevice}, and not all configurations
 * of that {@code surface} are compatible. Some classes that provide the {@code surface} are
 * compatible with the {@link CameraDevice} in general
 * (see {@link #isOutputSupportedFor(Class)}, but it is the caller's responsibility to put the
 * {@code surface} into a state that will be compatible with the {@link CameraDevice}.</p>
 *
 * <p>Reasons for a {@code surface} being specifically incompatible might be:
 * <ul>
 * <li>Using a format that's not listed by {@link #getOutputFormats}
 * <li>Using a format/size combination that's not listed by {@link #getOutputSizes}
 * <li>The {@code surface} itself is not in a state where it can service a new producer.</p>
 * </li>
 * </ul>
 *
 * <p>Surfaces from flexible sources will return true even if the exact size of the Surface does
 * not match a camera-supported size, as long as the format (or class) is supported and the
 * camera device supports a size that is equal to or less than 1080p in that format. If such as
 * Surface is used to create a capture session, it will have its size rounded to the nearest
 * supported size, below or equal to 1080p. Flexible sources include SurfaceView, SurfaceTexture,
 * and ImageReader.</p>
 *
 * <p>This is not an exhaustive list; see the particular class's documentation for further
 * possible reasons of incompatibility.</p>
 *
 * @param surface a non-{@code null} {@link Surface} object reference
 * @return {@code true} if this is supported, {@code false} otherwise
 *
 * @throws NullPointerException if {@code surface} was {@code null}
 * @throws IllegalArgumentException if the Surface endpoint is no longer valid
 *
 * @see CameraDevice#createCaptureSession
 * @see #isOutputSupportedFor(Class)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",1,The code has several changes:,- Replacement of constants `LegacyMetadataMapper.HAL_PIXEL_FORMAT_RGBA_8888` to `LegacyMetadataMapper.HAL_PIXEL_FORMAT_BGRA_8888` with likely similar constants without the `LegacyMetadataMapper` prefix.
78,<android.provider.ContactsContract.RawContacts.EntityIteratorImpl: Entity getEntityAndIncrementCursor(Cursor)>,22,23,<android.provider.ContactsContract.RawContacts.EntityIteratorImpl: Entity getEntityAndIncrementCursor(Cursor)>,<android.provider.ContactsContract.RawContacts.EntityIteratorImpl: Entity getEntityAndIncrementCursor(Cursor)>,0,"{
    final int columnRawContactId = cursor.getColumnIndexOrThrow(RawContacts._ID);
    final long rawContactId = cursor.getLong(columnRawContactId);
    // we expect the cursor is already at the row we need to read from
    ContentValues cv = new ContentValues();
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, ACCOUNT_NAME);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, ACCOUNT_TYPE);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, DATA_SET);
    DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, _ID);
    DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, DIRTY);
    DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, VERSION);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SOURCE_ID);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC1);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC2);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC3);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC4);
    DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, DELETED);
    DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, CONTACT_ID);
    DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, STARRED);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, NAME_VERIFIED);
    android.content.Entity contact = new android.content.Entity(cv);
    // read data rows until the contact id changes
    do {
        if (rawContactId != cursor.getLong(columnRawContactId)) {
            break;
        }
        // add the data to to the contact
        cv = new ContentValues();
        cv.put(Data._ID, cursor.getLong(cursor.getColumnIndexOrThrow(Entity.DATA_ID)));
        DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, Data.RES_PACKAGE);
        DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, Data.MIMETYPE);
        DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, Data.IS_PRIMARY);
        DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, Data.IS_SUPER_PRIMARY);
        DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, Data.DATA_VERSION);
        DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CommonDataKinds.GroupMembership.GROUP_SOURCE_ID);
        DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, Data.DATA_VERSION);
        for (String key : DATA_KEYS) {
            final int columnIndex = cursor.getColumnIndexOrThrow(key);
            switch(cursor.getType(columnIndex)) {
                case Cursor.FIELD_TYPE_NULL:
                    // don't put anything
                    break;
                case Cursor.FIELD_TYPE_INTEGER:
                case Cursor.FIELD_TYPE_FLOAT:
                case Cursor.FIELD_TYPE_STRING:
                    cv.put(key, cursor.getString(columnIndex));
                    break;
                case Cursor.FIELD_TYPE_BLOB:
                    cv.put(key, cursor.getBlob(columnIndex));
                    break;
                default:
                    throw new IllegalStateException(""Invalid or unhandled data type"");
            }
        }
        contact.addSubValue(ContactsContract.Data.CONTENT_URI, cv);
    } while (cursor.moveToNext());
    return contact;
}","{
    final int columnRawContactId = cursor.getColumnIndexOrThrow(RawContacts._ID);
    final long rawContactId = cursor.getLong(columnRawContactId);
    // we expect the cursor is already at the row we need to read from
    ContentValues cv = new ContentValues();
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, ACCOUNT_NAME);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, ACCOUNT_TYPE);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, DATA_SET);
    DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, _ID);
    DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, DIRTY);
    DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, VERSION);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SOURCE_ID);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC1);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC2);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC3);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC4);
    DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, DELETED);
    DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, CONTACT_ID);
    DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, STARRED);
    android.content.Entity contact = new android.content.Entity(cv);
    // read data rows until the contact id changes
    do {
        if (rawContactId != cursor.getLong(columnRawContactId)) {
            break;
        }
        // add the data to to the contact
        cv = new ContentValues();
        cv.put(Data._ID, cursor.getLong(cursor.getColumnIndexOrThrow(Entity.DATA_ID)));
        DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, Data.RES_PACKAGE);
        DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, Data.MIMETYPE);
        DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, Data.IS_PRIMARY);
        DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, Data.IS_SUPER_PRIMARY);
        DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, Data.DATA_VERSION);
        DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CommonDataKinds.GroupMembership.GROUP_SOURCE_ID);
        DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, Data.DATA_VERSION);
        for (String key : DATA_KEYS) {
            final int columnIndex = cursor.getColumnIndexOrThrow(key);
            switch(cursor.getType(columnIndex)) {
                case Cursor.FIELD_TYPE_NULL:
                    // don't put anything
                    break;
                case Cursor.FIELD_TYPE_INTEGER:
                case Cursor.FIELD_TYPE_FLOAT:
                case Cursor.FIELD_TYPE_STRING:
                    cv.put(key, cursor.getString(columnIndex));
                    break;
                case Cursor.FIELD_TYPE_BLOB:
                    cv.put(key, cursor.getBlob(columnIndex));
                    break;
                default:
                    throw new IllegalStateException(""Invalid or unhandled data type"");
            }
        }
        contact.addSubValue(ContactsContract.Data.CONTENT_URI, cv);
    } while (cursor.moveToNext());
    return contact;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
79,<android.print.PrinterCapabilitiesInfo.Builder: PrinterCapabilitiesInfo build()>,22,23,<android.print.PrinterCapabilitiesInfo.Builder: PrinterCapabilitiesInfo build()>,<android.print.PrinterCapabilitiesInfo.Builder: PrinterCapabilitiesInfo build()>,0,"{
    if (mPrototype.mMediaSizes == null || mPrototype.mMediaSizes.isEmpty()) {
        throw new IllegalStateException(""No media size specified."");
    }
    if (mPrototype.mDefaults[PROPERTY_MEDIA_SIZE] == DEFAULT_UNDEFINED) {
        throw new IllegalStateException(""No default media size specified."");
    }
    if (mPrototype.mResolutions == null || mPrototype.mResolutions.isEmpty()) {
        throw new IllegalStateException(""No resolution specified."");
    }
    if (mPrototype.mDefaults[PROPERTY_RESOLUTION] == DEFAULT_UNDEFINED) {
        throw new IllegalStateException(""No default resolution specified."");
    }
    if (mPrototype.mColorModes == 0) {
        throw new IllegalStateException(""No color mode specified."");
    }
    if (mPrototype.mDefaults[PROPERTY_COLOR_MODE] == DEFAULT_UNDEFINED) {
        throw new IllegalStateException(""No default color mode specified."");
    }
    if (mPrototype.mMinMargins == null) {
        throw new IllegalArgumentException(""margins cannot be null"");
    }
    return mPrototype;
}","{
    if (mPrototype.mMediaSizes == null || mPrototype.mMediaSizes.isEmpty()) {
        throw new IllegalStateException(""No media size specified."");
    }
    if (mPrototype.mDefaults[PROPERTY_MEDIA_SIZE] == DEFAULT_UNDEFINED) {
        throw new IllegalStateException(""No default media size specified."");
    }
    if (mPrototype.mResolutions == null || mPrototype.mResolutions.isEmpty()) {
        throw new IllegalStateException(""No resolution specified."");
    }
    if (mPrototype.mDefaults[PROPERTY_RESOLUTION] == DEFAULT_UNDEFINED) {
        throw new IllegalStateException(""No default resolution specified."");
    }
    if (mPrototype.mColorModes == 0) {
        throw new IllegalStateException(""No color mode specified."");
    }
    if (mPrototype.mDefaults[PROPERTY_COLOR_MODE] == DEFAULT_UNDEFINED) {
        throw new IllegalStateException(""No default color mode specified."");
    }
    if (mPrototype.mDuplexModes == 0) {
        setDuplexModes(PrintAttributes.DUPLEX_MODE_NONE, PrintAttributes.DUPLEX_MODE_NONE);
    }
    if (mPrototype.mMinMargins == null) {
        throw new IllegalArgumentException(""margins cannot be null"");
    }
    return mPrototype;
}",1,"/**
 * Crates a new {@link PrinterCapabilitiesInfo} enforcing that all
 * required properties have been specified. See individual methods
 * in this class for reference about required attributes.
 *
 * @return A new {@link PrinterCapabilitiesInfo}.
 *
 * @throws IllegalStateException If a required attribute was not specified.
 */
","/**
 * Crates a new {@link PrinterCapabilitiesInfo} enforcing that all
 * required properties have been specified. See individual methods
 * in this class for reference about required attributes.
 * <p>
 * <strong>Note:</strong> If you do not add supported duplex modes,
 * {@link android.print.PrintAttributes#DUPLEX_MODE_NONE} will set
 * as the only supported mode and also as the default duplex mode.
 * </p>
 *
 * @return A new {@link PrinterCapabilitiesInfo}.
 *
 * @throws IllegalStateException If a required attribute was not specified.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The late version introduces a check for duplex modes that sets default values if `mPrototype.mDuplexModes` is zero. This is a new operation related to setting certain properties of the `mPrototype`, which is not related to return or exception handling operations or control dependencies. Therefore, the code change type is 4.","No Compatibility Issue could arise due to this change as it does not affect the return value; it merely sets a property on the `mPrototype` object if a condition is met. There is no change in the potential return values or exception handling, so the CI type is 0."
80,"<android.accounts.AccountManager: AccountManagerFuture<Account[]> getAccountsByTypeAndFeatures(String,String[],AccountManagerCallback<Account[]>,Handler)>",22,23,"<android.accounts.AccountManager: AccountManagerFuture<Account[]> getAccountsByTypeAndFeatures(String,String[],AccountManagerCallback<Account[]>,Handler)>","<android.accounts.AccountManager: AccountManagerFuture<Account[]> getAccountsByTypeAndFeatures(String,String[],AccountManagerCallback<Account[]>,Handler)>",0,"{
    if (type == null)
        throw new IllegalArgumentException(""type is null"");
    return new Future2Task<Account[]>(handler, callback) {

        public void doWork() throws RemoteException {
            mService.getAccountsByFeatures(mResponse, type, features);
        }

        public Account[] bundleToResult(Bundle bundle) throws AuthenticatorException {
            if (!bundle.containsKey(KEY_ACCOUNTS)) {
                throw new AuthenticatorException(""no result in response"");
            }
            final Parcelable[] parcelables = bundle.getParcelableArray(KEY_ACCOUNTS);
            Account[] descs = new Account[parcelables.length];
            for (int i = 0; i < parcelables.length; i++) {
                descs[i] = (Account) parcelables[i];
            }
            return descs;
        }
    }.start();
}","{
    if (type == null)
        throw new IllegalArgumentException(""type is null"");
    return new Future2Task<Account[]>(handler, callback) {

        public void doWork() throws RemoteException {
            mService.getAccountsByFeatures(mResponse, type, features, mContext.getOpPackageName());
        }

        public Account[] bundleToResult(Bundle bundle) throws AuthenticatorException {
            if (!bundle.containsKey(KEY_ACCOUNTS)) {
                throw new AuthenticatorException(""no result in response"");
            }
            final Parcelable[] parcelables = bundle.getParcelableArray(KEY_ACCOUNTS);
            Account[] descs = new Account[parcelables.length];
            for (int i = 0; i < parcelables.length; i++) {
                descs[i] = (Account) parcelables[i];
            }
            return descs;
        }
    }.start();
}",1,"/**
 * Lists all accounts of a type which have certain features.  The account
 * type identifies the authenticator (see {@link #getAccountsByType}).
 * Account features are authenticator-specific string tokens identifying
 * boolean account properties (see {@link #hasFeatures}).
 *
 * <p>Unlike {@link #getAccountsByType}, this method calls the authenticator,
 * which may contact the server or do other work to check account features,
 * so the method returns an {@link AccountManagerFuture}.
 *
 * <p>This method may be called from any thread, but the returned
 * {@link AccountManagerFuture} must not be used on the main thread.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#GET_ACCOUNTS}.
 *
 * @param type The type of accounts to return, must not be null
 * @param features An array of the account features to require,
 * may be null or empty
 * @param callback Callback to invoke when the request completes,
 * null for no callback
 * @param handler {@link Handler} identifying the callback thread,
 * null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to an array of
 * {@link Account}, one per account of the specified type which
 * matches the requested features.
 */
","/**
 * Lists all accounts of a type which have certain features.  The account
 * type identifies the authenticator (see {@link #getAccountsByType}).
 * Account features are authenticator-specific string tokens identifying
 * boolean account properties (see {@link #hasFeatures}).
 *
 * <p>Unlike {@link #getAccountsByType}, this method calls the authenticator,
 * which may contact the server or do other work to check account features,
 * so the method returns an {@link AccountManagerFuture}.
 *
 * <p>This method may be called from any thread, but the returned
 * {@link AccountManagerFuture} must not be used on the main thread.
 *
 * <p>Clients of this method that have not been granted the
 * {@link android.Manifest.permission#GET_ACCOUNTS} permission,
 * will only see those accounts managed by AbstractAccountAuthenticators whose
 * signature matches the client.
 *
 * @param type The type of accounts to return, must not be null
 * @param features An array of the account features to require,
 * may be null or empty
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * GET_ACCOUNTS permission is needed for those platforms, irrespective of uid
 * or signature match. See docs for this function in API level 22.
 *
 * @param callback Callback to invoke when the request completes,
 * null for no callback
 * @param handler {@link Handler} identifying the callback thread,
 * null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to an array of
 * {@link Account}, one per account of the specified type which
 * matches the requested features.
 */
",-1,,[@RequiresPermission(GET_ACCOUNTS)],-1,-1,-1,-1,-1,-1,5,0,"The method invocation within the doWork() method has changed from mService.getAccountsByFeatures(mResponse, type, features) to mService.getAccountsByFeatures(mResponse, type, features, mContext.getOpPackageName()), adding an extra argument, which indicates a dependent API has changed. Therefore, the code change type is 5.","Although there is a change in the dependent API, no changes are made to the return value or exception handling in the method implementation that would affect the calling code, and hence there is no compatibility issue regarding the return value or exceptions thrown. Therefore, the CI type is 0."
81,<android.view.View: boolean verifyDrawable(Drawable)>,22,23,<android.view.View: boolean verifyDrawable(Drawable)>,<android.view.View: boolean verifyDrawable(Drawable)>,0,"{
    return who == mBackground;
}","{
    return who == mBackground || (mScrollCache != null && mScrollCache.scrollBar == who) || (mForegroundInfo != null && mForegroundInfo.mDrawable == who);
}",1,"/**
 * If your view subclass is displaying its own Drawable objects, it should
 * override this function and return true for any Drawable it is
 * displaying.  This allows animations for those drawables to be
 * scheduled.
 *
 * <p>Be sure to call through to the super class when overriding this
 * function.
 *
 * @param who The Drawable to verify.  Return true if it is one you are
 * displaying, else return the result of calling through to the
 * super class.
 *
 * @return boolean If true than the Drawable is being displayed in the
 * view; else false and it is not allowed to animate.
 *
 * @see #unscheduleDrawable(android.graphics.drawable.Drawable)
 * @see #drawableStateChanged()
 */
","/**
 * If your view subclass is displaying its own Drawable objects, it should
 * override this function and return true for any Drawable it is
 * displaying.  This allows animations for those drawables to be
 * scheduled.
 *
 * <p>Be sure to call through to the super class when overriding this
 * function.
 *
 * @param who The Drawable to verify.  Return true if it is one you are
 * displaying, else return the result of calling through to the
 * super class.
 *
 * @return boolean If true than the Drawable is being displayed in the
 * view; else false and it is not allowed to animate.
 *
 * @see #unscheduleDrawable(android.graphics.drawable.Drawable)
 * @see #drawableStateChanged()
 */
",-1,,[@CallSuper],-1,-1,-1,-1,-1,-1,1,1,"In the late implementation, there is an addition to the return statement with more conditions to check (via logical OR operations) if 'who' is equal not only to 'mBackground' but also to 'mScrollCache.scrollBar' or 'mForegroundInfo.mDrawable'. Hence, the code change type is 1.","The API's behavior can differ because of the introduction of additional conditions in the return statement, which means that the late version may return a different value compared to the early version when 'who' is the same as 'mScrollCache.scrollBar' or 'mForegroundInfo.mDrawable'. This change constitutes a CI type 1."
83,"<android.content.ContentResolver: int update(Uri,ContentValues,String,String[])>",22,23,"<android.content.ContentResolver: int update(Uri,ContentValues,String,String[])>","<android.content.ContentResolver: int update(Uri,ContentValues,String,String[])>",0,"{
    IContentProvider provider = acquireProvider(uri);
    if (provider == null) {
        throw new IllegalArgumentException(""Unknown URI "" + uri);
    }
    try {
        long startTime = SystemClock.uptimeMillis();
        int rowsUpdated = provider.update(mPackageName, uri, values, where, selectionArgs);
        long durationMillis = SystemClock.uptimeMillis() - startTime;
        maybeLogUpdateToEventLog(durationMillis, uri, ""update"", where);
        return rowsUpdated;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return -1;
    } finally {
        releaseProvider(provider);
    }
}","{
    Preconditions.checkNotNull(uri, ""uri"");
    IContentProvider provider = acquireProvider(uri);
    if (provider == null) {
        throw new IllegalArgumentException(""Unknown URI "" + uri);
    }
    try {
        long startTime = SystemClock.uptimeMillis();
        int rowsUpdated = provider.update(mPackageName, uri, values, where, selectionArgs);
        long durationMillis = SystemClock.uptimeMillis() - startTime;
        maybeLogUpdateToEventLog(durationMillis, uri, ""update"", where);
        return rowsUpdated;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return -1;
    } finally {
        releaseProvider(provider);
    }
}",1,"/**
 * Update row(s) in a content URI.
 *
 * If the content provider supports transactions the update will be atomic.
 *
 * @param uri The URI to modify.
 * @param values The new field values. The key is the column name for the field.
 * A null value will remove an existing field value.
 * @param where A filter to apply to rows before updating, formatted as an SQL WHERE clause
 * (excluding the WHERE itself).
 * @return the number of rows updated.
 * @throws NullPointerException if uri or values are null
 */
","/**
 * Update row(s) in a content URI.
 *
 * If the content provider supports transactions the update will be atomic.
 *
 * @param uri The URI to modify.
 * @param values The new field values. The key is the column name for the field.
 * A null value will remove an existing field value.
 * @param where A filter to apply to rows before updating, formatted as an SQL WHERE clause
 * (excluding the WHERE itself).
 * @return the number of rows updated.
 * @throws NullPointerException if uri or values are null
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"An additional method call Preconditions.checkNotNull(uri, ""uri"") has been introduced before acquiring the provider. This is a change in the method implementation, but since it is a precondition check designed to ensure that the 'uri' parameter is not null, it does not represent a change in behaviour under the assumption that 'uri' would not be null at this invocation point. Thus, the code change type is 4.","There is no Compatibility Issue here because the precondition check is enforcing a contract that should already be followed by the callers of the method. If 'uri' is not null, both the early and late versions of the code produce the same behaviour. If 'uri' is null, the early version would potentially result in a NullPointerException later on when the 'uri' is dereferenced, whereas the late version would throw an IllegalArgumentException explicitly due to the Preconditions.checkNotNull. However, in both cases, an exception would be thrown, thus the overall contract of the method remains the same. Therefore, there is no change in the return value or exception thrown due to this precondition check that would not have been thrown anyway."
85,"<android.os.storage.IMountServiceListener.Stub: boolean onTransact(int,Parcel,Parcel,int)>",22,23,"<android.os.storage.IMountServiceListener.Stub: boolean onTransact(int,Parcel,Parcel,int)>","<android.os.storage.IMountServiceListener.Stub: boolean onTransact(int,Parcel,Parcel,int)>",0,"{
    switch(code) {
        case INTERFACE_TRANSACTION:
            {
                reply.writeString(DESCRIPTOR);
                return true;
            }
        case TRANSACTION_onUsbMassStorageConnectionChanged:
            {
                data.enforceInterface(DESCRIPTOR);
                boolean connected;
                connected = (0 != data.readInt());
                this.onUsbMassStorageConnectionChanged(connected);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_onStorageStateChanged:
            {
                data.enforceInterface(DESCRIPTOR);
                String path;
                path = data.readString();
                String oldState;
                oldState = data.readString();
                String newState;
                newState = data.readString();
                this.onStorageStateChanged(path, oldState, newState);
                reply.writeNoException();
                return true;
            }
    }
    return super.onTransact(code, data, reply, flags);
}","{
    switch(code) {
        case INTERFACE_TRANSACTION:
            {
                reply.writeString(DESCRIPTOR);
                return true;
            }
        case TRANSACTION_onUsbMassStorageConnectionChanged:
            {
                data.enforceInterface(DESCRIPTOR);
                boolean connected;
                connected = (0 != data.readInt());
                this.onUsbMassStorageConnectionChanged(connected);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_onStorageStateChanged:
            {
                data.enforceInterface(DESCRIPTOR);
                final String path = data.readString();
                final String oldState = data.readString();
                final String newState = data.readString();
                this.onStorageStateChanged(path, oldState, newState);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_onVolumeStateChanged:
            {
                data.enforceInterface(DESCRIPTOR);
                final VolumeInfo vol = (VolumeInfo) data.readParcelable(null);
                final int oldState = data.readInt();
                final int newState = data.readInt();
                onVolumeStateChanged(vol, oldState, newState);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_onVolumeRecordChanged:
            {
                data.enforceInterface(DESCRIPTOR);
                final VolumeRecord rec = (VolumeRecord) data.readParcelable(null);
                onVolumeRecordChanged(rec);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_onVolumeForgotten:
            {
                data.enforceInterface(DESCRIPTOR);
                final String fsUuid = data.readString();
                onVolumeForgotten(fsUuid);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_onDiskScanned:
            {
                data.enforceInterface(DESCRIPTOR);
                final DiskInfo disk = (DiskInfo) data.readParcelable(null);
                final int volumeCount = data.readInt();
                onDiskScanned(disk, volumeCount);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_onDiskDestroyed:
            {
                data.enforceInterface(DESCRIPTOR);
                final DiskInfo disk = (DiskInfo) data.readParcelable(null);
                onDiskDestroyed(disk);
                reply.writeNoException();
                return true;
            }
    }
    return super.onTransact(code, data, reply, flags);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4,5",0,"The late implementation adds new cases to the switch statement (TRANSACTION_onVolumeStateChanged, TRANSACTION_onVolumeRecordChanged, TRANSACTION_onVolumeForgotten, TRANSACTION_onDiskScanned, TRANSACTION_onDiskDestroyed) and it also changes local variable declaration by adding 'final' keyword to the `path`, `oldState`, and `newState` variables in `TRANSACTION_onStorageStateChanged`. However, these changes are within the switch statement and do not affect the behavior of cases that exists in both versions, and new cases do not break compatibility since they handle previously unhandled operation codes. Therefore, the change types are 3 and 4. The declaration change is considered Other statement change and not a change in control dependency. The new operation codes introduce handling of new functionality, which under the assumption that this class is only extended by classes within the system that will be using the updated code, will not introduce incompatibilities for existing clients.","There is no Compatibility Issue detected, as all changes are either internal variable declarations or adding new cases to handle new functionality which do not alter the behavior of existing functionality in the early version. Clients using this API will still experience consistent behavior for operation codes that were handled in both versions. Hence, there's no change in the existing API contract or behavior."
86,"<android.inputmethodservice.InputMethodService.InputMethodImpl: void showSoftInput(int,ResultReceiver)>",22,23,"<android.inputmethodservice.InputMethodService.InputMethodImpl: void showSoftInput(int,ResultReceiver)>","<android.inputmethodservice.InputMethodService.InputMethodImpl: void showSoftInput(int,ResultReceiver)>",0,"{
    if (DEBUG)
        Log.v(TAG, ""showSoftInput()"");
    boolean wasVis = isInputViewShown();
    mShowInputFlags = 0;
    if (onShowInputRequested(flags, false)) {
        try {
            showWindow(true);
        } catch (BadTokenException e) {
            if (DEBUG)
                Log.v(TAG, ""BadTokenException: IME is done."");
            mWindowVisible = false;
            mWindowAdded = false;
        }
    }
    // If user uses hard keyboard, IME button should always be shown.
    boolean showing = isInputViewShown();
    mImm.setImeWindowStatus(mToken, IME_ACTIVE | (showing ? IME_VISIBLE : 0), mBackDisposition);
    if (resultReceiver != null) {
        resultReceiver.send(wasVis != isInputViewShown() ? InputMethodManager.RESULT_SHOWN : (wasVis ? InputMethodManager.RESULT_UNCHANGED_SHOWN : InputMethodManager.RESULT_UNCHANGED_HIDDEN), null);
    }
}","{
    if (DEBUG)
        Log.v(TAG, ""showSoftInput()"");
    boolean wasVis = isInputViewShown();
    mShowInputFlags = 0;
    if (onShowInputRequested(flags, false)) {
        try {
            showWindow(true);
        } catch (BadTokenException e) {
            if (DEBUG)
                Log.v(TAG, ""BadTokenException: IME is done."");
            mWindowVisible = false;
            mWindowAdded = false;
        }
    }
    clearInsetOfPreviousIme();
    // If user uses hard keyboard, IME button should always be shown.
    boolean showing = isInputViewShown();
    mImm.setImeWindowStatus(mToken, IME_ACTIVE | (showing ? IME_VISIBLE : 0), mBackDisposition);
    if (resultReceiver != null) {
        resultReceiver.send(wasVis != isInputViewShown() ? InputMethodManager.RESULT_SHOWN : (wasVis ? InputMethodManager.RESULT_UNCHANGED_SHOWN : InputMethodManager.RESULT_UNCHANGED_HIDDEN), null);
    }
}",1,"/**
 * Handle a request by the system to show the soft input area.
 */
","/**
 * Handle a request by the system to show the soft input area.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method `clearInsetOfPreviousIme()` has been introduced in the late version; there are no changes to return or exception handling statements nor to the control dependencies, so the change type is 4.","The introduction of `clearInsetOfPreviousIme()` method call does not directly impact the return value or exception handling of the `showSoftInput` method. Therefore, there is no compatibility issue caused by different return values or types, nor by different exception handlings. Hence, the CI type is 0."
90,"<android.widget.ListView: int measureHeightOfChildren(int,int,int,int,int)>",22,23,"<android.widget.ListView: int measureHeightOfChildren(int,int,int,int,int)>","<android.widget.ListView: int measureHeightOfChildren(int,int,int,int,int)>",0,"{
    final ListAdapter adapter = mAdapter;
    if (adapter == null) {
        return mListPadding.top + mListPadding.bottom;
    }
    // Include the padding of the list
    int returnedHeight = mListPadding.top + mListPadding.bottom;
    final int dividerHeight = ((mDividerHeight > 0) && mDivider != null) ? mDividerHeight : 0;
    // The previous height value that was less than maxHeight and contained
    // no partial children
    int prevHeightWithoutPartialChild = 0;
    int i;
    View child;
    // mItemCount - 1 since endPosition parameter is inclusive
    endPosition = (endPosition == NO_POSITION) ? adapter.getCount() - 1 : endPosition;
    final AbsListView.RecycleBin recycleBin = mRecycler;
    final boolean recyle = recycleOnMeasure();
    final boolean[] isScrap = mIsScrap;
    for (i = startPosition; i <= endPosition; ++i) {
        child = obtainView(i, isScrap);
        measureScrapChild(child, i, widthMeasureSpec);
        if (i > 0) {
            // Count the divider for all but one child
            returnedHeight += dividerHeight;
        }
        // Recycle the view before we possibly return from the method
        if (recyle && recycleBin.shouldRecycleViewType(((LayoutParams) child.getLayoutParams()).viewType)) {
            recycleBin.addScrapView(child, -1);
        }
        returnedHeight += child.getMeasuredHeight();
        if (returnedHeight >= maxHeight) {
            // then the i'th position did not fit completely.
            return // Disallowing is enabled (> -1)
            (disallowPartialChildPosition >= 0) && // We've past the min pos
            (i > disallowPartialChildPosition) && // We have a prev height
            (prevHeightWithoutPartialChild > 0) && // i'th child did not fit completely
            (returnedHeight != maxHeight) ? prevHeightWithoutPartialChild : maxHeight;
        }
        if ((disallowPartialChildPosition >= 0) && (i >= disallowPartialChildPosition)) {
            prevHeightWithoutPartialChild = returnedHeight;
        }
    }
    // completely fit, so return the returnedHeight
    return returnedHeight;
}","{
    final ListAdapter adapter = mAdapter;
    if (adapter == null) {
        return mListPadding.top + mListPadding.bottom;
    }
    // Include the padding of the list
    int returnedHeight = mListPadding.top + mListPadding.bottom;
    final int dividerHeight = ((mDividerHeight > 0) && mDivider != null) ? mDividerHeight : 0;
    // The previous height value that was less than maxHeight and contained
    // no partial children
    int prevHeightWithoutPartialChild = 0;
    int i;
    View child;
    // mItemCount - 1 since endPosition parameter is inclusive
    endPosition = (endPosition == NO_POSITION) ? adapter.getCount() - 1 : endPosition;
    final AbsListView.RecycleBin recycleBin = mRecycler;
    final boolean recyle = recycleOnMeasure();
    final boolean[] isScrap = mIsScrap;
    for (i = startPosition; i <= endPosition; ++i) {
        child = obtainView(i, isScrap);
        measureScrapChild(child, i, widthMeasureSpec, maxHeight);
        if (i > 0) {
            // Count the divider for all but one child
            returnedHeight += dividerHeight;
        }
        // Recycle the view before we possibly return from the method
        if (recyle && recycleBin.shouldRecycleViewType(((LayoutParams) child.getLayoutParams()).viewType)) {
            recycleBin.addScrapView(child, -1);
        }
        returnedHeight += child.getMeasuredHeight();
        if (returnedHeight >= maxHeight) {
            // then the i'th position did not fit completely.
            return // Disallowing is enabled (> -1)
            (disallowPartialChildPosition >= 0) && // We've past the min pos
            (i > disallowPartialChildPosition) && // We have a prev height
            (prevHeightWithoutPartialChild > 0) && // i'th child did not fit completely
            (returnedHeight != maxHeight) ? prevHeightWithoutPartialChild : maxHeight;
        }
        if ((disallowPartialChildPosition >= 0) && (i >= disallowPartialChildPosition)) {
            prevHeightWithoutPartialChild = returnedHeight;
        }
    }
    // completely fit, so return the returnedHeight
    return returnedHeight;
}",1,"/**
 * Measures the height of the given range of children (inclusive) and
 * returns the height with this ListView's padding and divider heights
 * included. If maxHeight is provided, the measuring will stop when the
 * current height reaches maxHeight.
 *
 * @param widthMeasureSpec The width measure spec to be given to a child's
 * {@link View#measure(int, int)}.
 * @param startPosition The position of the first child to be shown.
 * @param endPosition The (inclusive) position of the last child to be
 * shown. Specify {@link #NO_POSITION} if the last child should be
 * the last available child from the adapter.
 * @param maxHeight The maximum height that will be returned (if all the
 * children don't fit in this value, this value will be
 * returned).
 * @param disallowPartialChildPosition In general, whether the returned
 * height should only contain entire children. This is more
 * powerful--it is the first inclusive position at which partial
 * children will not be allowed. Example: it looks nice to have
 * at least 3 completely visible children, and in portrait this
 * will most likely fit; but in landscape there could be times
 * when even 2 children can not be completely shown, so a value
 * of 2 (remember, inclusive) would be good (assuming
 * startPosition is 0).
 * @return The height of this ListView with the given children.
 */
","/**
 * Measures the height of the given range of children (inclusive) and
 * returns the height with this ListView's padding and divider heights
 * included. If maxHeight is provided, the measuring will stop when the
 * current height reaches maxHeight.
 *
 * @param widthMeasureSpec The width measure spec to be given to a child's
 * {@link View#measure(int, int)}.
 * @param startPosition The position of the first child to be shown.
 * @param endPosition The (inclusive) position of the last child to be
 * shown. Specify {@link #NO_POSITION} if the last child should be
 * the last available child from the adapter.
 * @param maxHeight The maximum height that will be returned (if all the
 * children don't fit in this value, this value will be
 * returned).
 * @param disallowPartialChildPosition In general, whether the returned
 * height should only contain entire children. This is more
 * powerful--it is the first inclusive position at which partial
 * children will not be allowed. Example: it looks nice to have
 * at least 3 completely visible children, and in portrait this
 * will most likely fit; but in landscape there could be times
 * when even 2 children can not be completely shown, so a value
 * of 2 (remember, inclusive) would be good (assuming
 * startPosition is 0).
 * @return The height of this ListView with the given children.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change in the code is the parameters of the `measureScrapChild` method call, where `maxHeight` has been added as a new parameter in the late version. There are no changes to the control flow, return statements, or exception handling, which corresponds to the change type 4.",There is no Compatibility Issue because the addition of a parameter to the `measureScrapChild` method doesn't inherently change the return value or the exception handling of the `measureHeightOfChildren` method. The method's behavior will remain consistent as long as the implementation of `measureScrapChild` properly handles the new parameter without altering its contract.
91,<android.print.PrintAttributes: int hashCode()>,22,23,<android.print.PrintAttributes: int hashCode()>,<android.print.PrintAttributes: int hashCode()>,0,"{
    final int prime = 31;
    int result = 1;
    result = prime * result + mColorMode;
    result = prime * result + ((mMinMargins == null) ? 0 : mMinMargins.hashCode());
    result = prime * result + ((mMediaSize == null) ? 0 : mMediaSize.hashCode());
    result = prime * result + ((mResolution == null) ? 0 : mResolution.hashCode());
    return result;
}","{
    final int prime = 31;
    int result = 1;
    result = prime * result + mColorMode;
    result = prime * result + mDuplexMode;
    result = prime * result + ((mMinMargins == null) ? 0 : mMinMargins.hashCode());
    result = prime * result + ((mMediaSize == null) ? 0 : mMediaSize.hashCode());
    result = prime * result + ((mResolution == null) ? 0 : mResolution.hashCode());
    return result;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,"There is an addition of 'mDuplexMode' in the hashCode calculation; this means there is a change in the statements other than return, exception handling, or control dependency which falls under other statement changed.","The change in the method's implementation affects the output of the hashCode, which implies that a different value might be produced when the same object is passed to this method in different API versions. This difference can potentially cause issues wherever the hash code might be used, such as in collections (like HashMap or HashSet). Thus, the CI type is 1."
92,"<android.hardware.camera2.legacy.ParameterUtils: MeteringData convertMeteringRectangleToLegacy(Rect,MeteringRectangle,ZoomData)>",22,23,"<android.hardware.camera2.legacy.ParameterUtils: MeteringData convertMeteringRectangleToLegacy(Rect,MeteringRectangle,ZoomData)>","<android.hardware.camera2.legacy.ParameterUtils: MeteringData convertMeteringRectangleToLegacy(Rect,MeteringRectangle,ZoomData)>",0,"{
    Rect previewCrop = zoomData.previewCrop;
    float scaleW = (NORMALIZED_RECTANGLE_MAX - NORMALIZED_RECTANGLE_MIN) * 1.0f / previewCrop.width();
    float scaleH = (NORMALIZED_RECTANGLE_MAX - NORMALIZED_RECTANGLE_MIN) * 1.0f / previewCrop.height();
    Matrix transform = new Matrix();
    // Move the preview crop so that top,left is at (0,0), otherwise after scaling
    // the corner bounds will be outside of [-1000, 1000]
    transform.setTranslate(-previewCrop.left, -previewCrop.top);
    // Scale into [0, 2000] range about the center of the preview
    transform.postScale(scaleW, scaleH);
    // Move so that top left of a typical rect is at [-1000, -1000]
    transform.postTranslate(/*dx*/
    NORMALIZED_RECTANGLE_MIN, /*dy*/
    NORMALIZED_RECTANGLE_MIN);
    /*
         * Calculate the preview metering region (effective), and the camera1 api
         * normalized metering region.
         */
    Rect normalizedRegionUnbounded = ParamsUtils.mapRect(transform, meteringRect.getRect());
    /*
         * Try to intersect normalized area with [-1000, 1000] rectangle; otherwise
         * it's completely out of range
         */
    Rect normalizedIntersected = new Rect(normalizedRegionUnbounded);
    Camera.Area meteringArea;
    if (!normalizedIntersected.intersect(NORMALIZED_RECTANGLE_DEFAULT)) {
        Log.w(TAG, ""convertMeteringRectangleToLegacy - metering rectangle too small, "" + ""no metering will be done"");
        normalizedIntersected.set(RECTANGLE_EMPTY);
        meteringArea = new Camera.Area(RECTANGLE_EMPTY, MeteringRectangle.METERING_WEIGHT_DONT_CARE);
    } else {
        meteringArea = new Camera.Area(normalizedIntersected, meteringRect.getMeteringWeight());
    }
    /*
         * Calculate effective preview metering region
         */
    Rect previewMetering = meteringRect.getRect();
    if (!previewMetering.intersect(previewCrop)) {
        previewMetering.set(RECTANGLE_EMPTY);
    }
    /*
         * Calculate effective reported metering region
         * - Transform the calculated metering area back into active array space
         * - Clip it to be a subset of the reported crop region
         */
    Rect reportedMetering;
    {
        Camera.Area normalizedAreaUnbounded = new Camera.Area(normalizedRegionUnbounded, meteringRect.getMeteringWeight());
        WeightedRectangle reportedMeteringRect = convertCameraAreaToActiveArrayRectangle(activeArray, zoomData, normalizedAreaUnbounded, /*usePreviewCrop*/
        false);
        reportedMetering = reportedMeteringRect.rect;
    }
    if (VERBOSE) {
        Log.v(TAG, String.format(""convertMeteringRectangleToLegacy - activeArray = %s, meteringRect = %s, "" + ""previewCrop = %s, meteringArea = %s, previewMetering = %s, "" + ""reportedMetering = %s, normalizedRegionUnbounded = %s"", activeArray, meteringRect, previewCrop, stringFromArea(meteringArea), previewMetering, reportedMetering, normalizedRegionUnbounded));
    }
    return new MeteringData(meteringArea, previewMetering, reportedMetering);
}","{
    Rect previewCrop = zoomData.previewCrop;
    float scaleW = (NORMALIZED_RECTANGLE_MAX - NORMALIZED_RECTANGLE_MIN) * 1.0f / previewCrop.width();
    float scaleH = (NORMALIZED_RECTANGLE_MAX - NORMALIZED_RECTANGLE_MIN) * 1.0f / previewCrop.height();
    Matrix transform = new Matrix();
    // Move the preview crop so that top,left is at (0,0), otherwise after scaling
    // the corner bounds will be outside of [-1000, 1000]
    transform.setTranslate(-previewCrop.left, -previewCrop.top);
    // Scale into [0, 2000] range about the center of the preview
    transform.postScale(scaleW, scaleH);
    // Move so that top left of a typical rect is at [-1000, -1000]
    transform.postTranslate(/*dx*/
    NORMALIZED_RECTANGLE_MIN, /*dy*/
    NORMALIZED_RECTANGLE_MIN);
    /*
         * Calculate the preview metering region (effective), and the camera1 api
         * normalized metering region.
         */
    Rect normalizedRegionUnbounded = ParamsUtils.mapRect(transform, meteringRect.getRect());
    /*
         * Try to intersect normalized area with [-1000, 1000] rectangle; otherwise
         * it's completely out of range
         */
    Rect normalizedIntersected = new Rect(normalizedRegionUnbounded);
    Camera.Area meteringArea;
    if (!normalizedIntersected.intersect(NORMALIZED_RECTANGLE_DEFAULT)) {
        Log.w(TAG, ""convertMeteringRectangleToLegacy - metering rectangle too small, "" + ""no metering will be done"");
        normalizedIntersected.set(RECTANGLE_EMPTY);
        meteringArea = new Camera.Area(RECTANGLE_EMPTY, MeteringRectangle.METERING_WEIGHT_DONT_CARE);
    } else {
        meteringArea = new Camera.Area(normalizedIntersected, meteringRect.getMeteringWeight());
    }
    /*
         * Calculate effective preview metering region
         */
    Rect previewMetering = meteringRect.getRect();
    if (!previewMetering.intersect(previewCrop)) {
        previewMetering.set(RECTANGLE_EMPTY);
    }
    /*
         * Calculate effective reported metering region
         * - Transform the calculated metering area back into active array space
         * - Clip it to be a subset of the reported crop region
         */
    Rect reportedMetering;
    {
        Camera.Area normalizedAreaUnbounded = new Camera.Area(normalizedRegionUnbounded, meteringRect.getMeteringWeight());
        WeightedRectangle reportedMeteringRect = convertCameraAreaToActiveArrayRectangle(activeArray, zoomData, normalizedAreaUnbounded, /*usePreviewCrop*/
        false);
        reportedMetering = reportedMeteringRect.rect;
    }
    if (DEBUG) {
        Log.v(TAG, String.format(""convertMeteringRectangleToLegacy - activeArray = %s, meteringRect = %s, "" + ""previewCrop = %s, meteringArea = %s, previewMetering = %s, "" + ""reportedMetering = %s, normalizedRegionUnbounded = %s"", activeArray, meteringRect, previewCrop, stringFromArea(meteringArea), previewMetering, reportedMetering, normalizedRegionUnbounded));
    }
    return new MeteringData(meteringArea, previewMetering, reportedMetering);
}",1,"/**
 * Calculate the actual/effective/reported normalized rectangle data from a metering
 * rectangle.
 *
 * <p>If any of the rectangles are out-of-range of their intended bounding box,
 * the {@link #RECTANGLE_EMPTY empty rectangle} is substituted instead
 * (with a weight of {@code 0}).</p>
 *
 * <p>The metering rectangle is bound by the crop region (effective/reported respectively).
 * The metering {@link Camera.Area area} is bound by {@code [-1000, 1000]}.</p>
 *
 * <p>No parameters are mutated; returns the new metering data.</p>
 *
 * @param activeArraySize active array size of the sensor (e.g. max jpeg size)
 * @param meteringRect the user-specified metering rectangle
 * @param zoomData the calculated zoom data corresponding to this request
 *
 * @return the metering area, the reported/effective metering rectangles
 */
","/**
 * Calculate the actual/effective/reported normalized rectangle data from a metering
 * rectangle.
 *
 * <p>If any of the rectangles are out-of-range of their intended bounding box,
 * the {@link #RECTANGLE_EMPTY empty rectangle} is substituted instead
 * (with a weight of {@code 0}).</p>
 *
 * <p>The metering rectangle is bound by the crop region (effective/reported respectively).
 * The metering {@link Camera.Area area} is bound by {@code [-1000, 1000]}.</p>
 *
 * <p>No parameters are mutated; returns the new metering data.</p>
 *
 * @param activeArraySize active array size of the sensor (e.g. max jpeg size)
 * @param meteringRect the user-specified metering rectangle
 * @param zoomData the calculated zoom data corresponding to this request
 *
 * @return the metering area, the reported/effective metering rectangles
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
93,"<android.content.UriMatcher: void addURI(String,String,int)>",22,23,"<android.content.UriMatcher: void addURI(String,String,int)>","<android.content.UriMatcher: void addURI(String,String,int)>",0,"{
    if (code < 0) {
        throw new IllegalArgumentException(""code "" + code + "" is invalid: it must be positive"");
    }
    String[] tokens = null;
    if (path != null) {
        String newPath = path;
        // Strip leading slash if present.
        if (path.length() > 0 && path.charAt(0) == '/') {
            newPath = path.substring(1);
        }
        tokens = PATH_SPLIT_PATTERN.split(newPath);
    }
    int numTokens = tokens != null ? tokens.length : 0;
    UriMatcher node = this;
    for (int i = -1; i < numTokens; i++) {
        String token = i < 0 ? authority : tokens[i];
        ArrayList<UriMatcher> children = node.mChildren;
        int numChildren = children.size();
        UriMatcher child;
        int j;
        for (j = 0; j < numChildren; j++) {
            child = children.get(j);
            if (token.equals(child.mText)) {
                node = child;
                break;
            }
        }
        if (j == numChildren) {
            // Child not found, create it
            child = new UriMatcher();
            if (token.equals(""#"")) {
                child.mWhich = NUMBER;
            } else if (token.equals(""*"")) {
                child.mWhich = TEXT;
            } else {
                child.mWhich = EXACT;
            }
            child.mText = token;
            node.mChildren.add(child);
            node = child;
        }
    }
    node.mCode = code;
}","{
    if (code < 0) {
        throw new IllegalArgumentException(""code "" + code + "" is invalid: it must be positive"");
    }
    String[] tokens = null;
    if (path != null) {
        String newPath = path;
        // Strip leading slash if present.
        if (path.length() > 0 && path.charAt(0) == '/') {
            newPath = path.substring(1);
        }
        tokens = newPath.split(""/"");
    }
    int numTokens = tokens != null ? tokens.length : 0;
    UriMatcher node = this;
    for (int i = -1; i < numTokens; i++) {
        String token = i < 0 ? authority : tokens[i];
        ArrayList<UriMatcher> children = node.mChildren;
        int numChildren = children.size();
        UriMatcher child;
        int j;
        for (j = 0; j < numChildren; j++) {
            child = children.get(j);
            if (token.equals(child.mText)) {
                node = child;
                break;
            }
        }
        if (j == numChildren) {
            // Child not found, create it
            child = new UriMatcher();
            if (token.equals(""#"")) {
                child.mWhich = NUMBER;
            } else if (token.equals(""*"")) {
                child.mWhich = TEXT;
            } else {
                child.mWhich = EXACT;
            }
            child.mText = token;
            node.mChildren.add(child);
            node = child;
        }
    }
    node.mCode = code;
}",1,"/**
 * Add a URI to match, and the code to return when this URI is
 * matched. URI nodes may be exact match string, the token ""*""
 * that matches any text, or the token ""#"" that matches only
 * numbers.
 * <p>
 * Starting from API level {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2},
 * this method will accept a leading slash in the path.
 *
 * @param authority the authority to match
 * @param path the path to match. * may be used as a wild card for
 * any text, and # may be used as a wild card for numbers.
 * @param code the code that is returned when a URI is matched
 * against the given components. Must be positive.
 */
","/**
 * Add a URI to match, and the code to return when this URI is
 * matched. URI nodes may be exact match string, the token ""*""
 * that matches any text, or the token ""#"" that matches only
 * numbers.
 * <p>
 * Starting from API level {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2},
 * this method will accept a leading slash in the path.
 *
 * @param authority the authority to match
 * @param path the path to match. * may be used as a wild card for
 * any text, and # may be used as a wild card for numbers.
 * @param code the code that is returned when a URI is matched
 * against the given components. Must be positive.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method used to split the path string, `tokens = PATH_SPLIT_PATTERN.split(newPath)`, is replaced with `tokens = newPath.split(""/"")` in the later version, which indicates a change in the implementation of how the path is split into tokens. This would be classified as 'Other statement changed' since it's neither a return statement, exception handling, control dependency, nor a dependent API.","There is no Compatibility Issue here because even though the implementation changed, the behavior of splitting a string by slashes should remain consistent when using a regular expression or the `split` method directly on a string. Both methods will behave the same given the input conditions, therefore it should not cause a CI."
94,"<android.accounts.AccountManager: boolean addAccountExplicitly(Account,String,Bundle)>",22,23,"<android.accounts.AccountManager: boolean addAccountExplicitly(Account,String,Bundle)>","<android.accounts.AccountManager: boolean addAccountExplicitly(Account,String,Bundle)>",0,"{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    try {
        return mService.addAccountExplicitly(account, password, userdata);
    } catch (RemoteException e) {
        // won't ever happen
        throw new RuntimeException(e);
    }
}","{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    try {
        return mService.addAccountExplicitly(account, password, userdata);
    } catch (RemoteException e) {
        // Can happen if there was a SecurityException was thrown.
        throw new RuntimeException(e);
    }
}",1,"/**
 * Adds an account directly to the AccountManager.  Normally used by sign-up
 * wizards associated with authenticators, not directly by applications.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#AUTHENTICATE_ACCOUNTS}
 * and to have the same UID as the added account's authenticator.
 *
 * @param account The {@link Account} to add
 * @param password The password to associate with the account, null for none
 * @param userdata String values to use for the account's userdata, null for none
 * @return True if the account was successfully added, false if the account
 * already exists, the account is null, or another error occurs.
 */
","/**
 * Adds an account directly to the AccountManager. Normally used by sign-up
 * wizards associated with authenticators, not directly by applications.
 * <p>Calling this method does not update the last authenticated timestamp,
 * referred by {@link #KEY_LAST_AUTHENTICATED_TIME}. To update it, call
 * {@link #notifyAccountAuthenticated(Account)} after getting success.
 * However, if this method is called when it is triggered by addAccount() or
 * addAccountAsUser() or similar functions, then there is no need to update
 * timestamp manually as it is updated automatically by framework on
 * successful completion of the mentioned functions.
 * <p>It is safe to call this method from the main thread.
 * <p>This method requires the caller to have a signature match with the
 * authenticator that owns the specified account.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * AUTHENTICATE_ACCOUNTS permission is needed for those platforms. See docs
 * for this function in API level 22.
 *
 * @param account The {@link Account} to add
 * @param password The password to associate with the account, null for none
 * @param userdata String values to use for the account's userdata, null for
 * none
 * @return True if the account was successfully added, false if the account
 * already exists, the account is null, or another error occurs.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"There is no change in method signature, return type, exception handling, and control flow. The only change is in the comment, which is not considered a code change for the purpose of this analysis.",No Compatibility Issue could arise as there are no changes in the actual implementation code or behavior.
95,"<android.hardware.SystemSensorManager.SensorEventQueue: void dispatchSensorEvent(int,float[],int,long)>",22,23,"<android.hardware.SystemSensorManager.SensorEventQueue: void dispatchSensorEvent(int,float[],int,long)>","<android.hardware.SystemSensorManager.SensorEventQueue: void dispatchSensorEvent(int,float[],int,long)>",0,"{
    final Sensor sensor = sHandleToSensor.get(handle);
    SensorEvent t = null;
    synchronized (mSensorsEvents) {
        t = mSensorsEvents.get(handle);
    }
    if (t == null) {
        // the queue waiting to be delivered. Ignore.
        return;
    }
    // Copy from the values array.
    System.arraycopy(values, 0, t.values, 0, t.values.length);
    t.timestamp = timestamp;
    t.accuracy = inAccuracy;
    t.sensor = sensor;
    // call onAccuracyChanged() only if the value changes
    final int accuracy = mSensorAccuracies.get(handle);
    if ((t.accuracy >= 0) && (accuracy != t.accuracy)) {
        mSensorAccuracies.put(handle, t.accuracy);
        mListener.onAccuracyChanged(t.sensor, t.accuracy);
    }
    mListener.onSensorChanged(t);
}","{
    final Sensor sensor = mManager.mHandleToSensor.get(handle);
    SensorEvent t = null;
    synchronized (mSensorsEvents) {
        t = mSensorsEvents.get(handle);
    }
    if (t == null) {
        // the queue waiting to be delivered. Ignore.
        return;
    }
    // Copy from the values array.
    System.arraycopy(values, 0, t.values, 0, t.values.length);
    t.timestamp = timestamp;
    t.accuracy = inAccuracy;
    t.sensor = sensor;
    // call onAccuracyChanged() only if the value changes
    final int accuracy = mSensorAccuracies.get(handle);
    if ((t.accuracy >= 0) && (accuracy != t.accuracy)) {
        mSensorAccuracies.put(handle, t.accuracy);
        mListener.onAccuracyChanged(t.sensor, t.accuracy);
    }
    mListener.onSensorChanged(t);
}",1,"// Called from native code.
","// Called from native code.
",-1,"[@SuppressWarnings(""unused""), @Override]","[@SuppressWarnings(""unused""), @Override]",-1,-1,-1,-1,-1,-1,5,0,"The way to get `sensor` has been changed from `sHandleToSensor.get(handle)` to `mManager.mHandleToSensor.get(handle)`. It indicates a change in how a Sensor object is acquired, which is classified as a change in a dependent API, so the code change type is 5.","However, this change does not lead to a different return value or type, nor different exception handling. Assuming `mManager.mHandleToSensor` and `sHandleToSensor` refer to the same underlying data, the actual value returned in both cases would still be the same `Sensor` object for the given `handle`. Therefore, there is no Compatibility Issue, and the CI type is 0."
96,<android.print.PrintAttributes.Builder: Builder setColorMode(int)>,22,23,<android.print.PrintAttributes.Builder: Builder setColorMode(int)>,<android.print.PrintAttributes.Builder: Builder setColorMode(int)>,0,"{
    if (Integer.bitCount(colorMode) > 1) {
        throw new IllegalArgumentException(""can specify at most one colorMode bit."");
    }
    mAttributes.setColorMode(colorMode);
    return this;
}","{
    mAttributes.setColorMode(colorMode);
    return this;
}",1,"/**
 * Sets the color mode.
 *
 * @param colorMode A valid color mode or zero.
 * @return This builder.
 *
 * @see PrintAttributes#COLOR_MODE_MONOCHROME
 * @see PrintAttributes#COLOR_MODE_COLOR
 */
","/**
 * Sets the color mode.
 *
 * @param colorMode A valid color mode or zero.
 * @return This builder.
 *
 * @see PrintAttributes#COLOR_MODE_MONOCHROME
 * @see PrintAttributes#COLOR_MODE_COLOR
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"The early implementation includes an 'if' statement that throws an IllegalArgumentException when more than one colorMode bit is specified, which has been removed in the late implementation. Therefore, the code changes are of type 2 (exception handling statement changed) and 4 (other statement changed).",The removal of the 'if' statement that throws an exception means that the late version of the API will not throw an IllegalArgumentException under circumstances where the early version would. This is a Compatibility Issue of type 2 because the API may behave differently by potentially throwing a different set of exceptions (or not throwing an exception where it once would have).
99,"<android.print.PrinterCapabilitiesInfo.Builder: Builder setColorModes(int,int)>",22,23,"<android.print.PrinterCapabilitiesInfo.Builder: Builder setColorModes(int,int)>","<android.print.PrinterCapabilitiesInfo.Builder: Builder setColorModes(int,int)>",0,"{
    int currentModes = colorModes;
    while (currentModes > 0) {
        final int currentMode = (1 << Integer.numberOfTrailingZeros(currentModes));
        currentModes &= ~currentMode;
        PrintAttributes.enforceValidColorMode(currentMode);
    }
    if ((colorModes & defaultColorMode) == 0) {
        throw new IllegalArgumentException(""Default color mode not in color modes."");
    }
    PrintAttributes.enforceValidColorMode(colorModes);
    mPrototype.mColorModes = colorModes;
    mPrototype.mDefaults[PROPERTY_COLOR_MODE] = defaultColorMode;
    return this;
}","{
    int currentModes = colorModes;
    while (currentModes > 0) {
        final int currentMode = (1 << Integer.numberOfTrailingZeros(currentModes));
        currentModes &= ~currentMode;
        PrintAttributes.enforceValidColorMode(currentMode);
    }
    PrintAttributes.enforceValidColorMode(defaultColorMode);
    mPrototype.mColorModes = colorModes;
    mPrototype.mDefaults[PROPERTY_COLOR_MODE] = defaultColorMode;
    return this;
}",1,"/**
 * Sets the color modes.
 * <p>
 * <strong>Required:</strong> Yes
 * </p>
 *
 * @param colorModes The color mode bit mask.
 * @param defaultColorMode The default color mode.
 * @return This builder.
 * <p>
 * <strong>Note:</strong> On platform version 19 (Kitkat) specifying
 * only PrintAttributes#COLOR_MODE_MONOCHROME leads to a print spooler
 * crash. Hence, you should declare either both color modes or
 * PrintAttributes#COLOR_MODE_COLOR.
 * </p>
 *
 * @throws IllegalArgumentException If color modes contains an invalid
 * mode bit or if the default color mode is invalid.
 *
 * @see PrintAttributes#COLOR_MODE_COLOR
 * @see PrintAttributes#COLOR_MODE_MONOCHROME
 */
","/**
 * Sets the color modes.
 * <p>
 * <strong>Required:</strong> Yes
 * </p>
 *
 * @param colorModes The color mode bit mask.
 * @param defaultColorMode The default color mode.
 * @return This builder.
 * <p>
 * <strong>Note:</strong> On platform version 19 (Kitkat) specifying
 * only PrintAttributes#COLOR_MODE_MONOCHROME leads to a print spooler
 * crash. Hence, you should declare either both color modes or
 * PrintAttributes#COLOR_MODE_COLOR.
 * </p>
 *
 * @throws IllegalArgumentException If color modes contains an invalid
 * mode bit or if the default color mode is invalid.
 *
 * @see PrintAttributes#COLOR_MODE_COLOR
 * @see PrintAttributes#COLOR_MODE_MONOCHROME
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"The condition check `(colorModes & defaultColorMode) == 0` before throwing an IllegalArgumentException has been removed, which is related to exception handling (change type 2). Additionally, there is no direct change in the return statement or control flow, but there is a change in the flow of execution due to the removal of this exception check. This change can affect other statements since the enforcement of the default color mode's validity occurs unconditionally in the late version (change type 4).","Due to the removal of the exception check, the late version of the method could potentially lead to a situation where an IllegalArgumentException would have been thrown in the early version but is no longer thrown in the late version; this difference in behavior can result in a Compatibility Issue related to different exception handlings (CI type 2)."
100,<android.text.style.URLSpan: int getSpanTypeId()>,22,23,<android.text.style.URLSpan: int getSpanTypeId()>,<android.text.style.URLSpan: int getSpanTypeId()>,0,"{
    return TextUtils.URL_SPAN;
}","{
    return getSpanTypeIdInternal();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement is calling a different method; previously, it was returning a constant (TextUtils.URL_SPAN), and now it calls getSpanTypeIdInternal(), which represents a dependent API change. Therefore, both the return statement and dependent API have changed which are types 1 and 5.","By changing the method from returning a direct constant to calling another method to obtain the return value, this can potentially lead to returning a different value if the internal implementation of getSpanTypeIdInternal() differs from the constant TextUtils.URL_SPAN. Thus, a Compatibility Issue arises due to potential different return values or types, which is type 1."
101,<android.app.VoiceInteractor.Request: void cancel()>,22,23,<android.app.VoiceInteractor.Request: void cancel()>,<android.app.VoiceInteractor.Request: void cancel()>,0,"{
    try {
        mRequestInterface.cancel();
    } catch (RemoteException e) {
        Log.w(TAG, ""Voice interactor has died"", e);
    }
}","{
    if (mRequestInterface == null) {
        throw new IllegalStateException(""Request "" + this + "" is no longer active"");
    }
    try {
        mRequestInterface.cancel();
    } catch (RemoteException e) {
        Log.w(TAG, ""Voice interactor has died"", e);
    }
}",1,,"/**
 * Cancel this active request.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"A new control flow (an 'if' statement) check is added before the 'try' block to throw an IllegalStateException if mRequestInterface is null. Additionally, there is an 'Other statement changed' because the new exception throwing logic is added outside existing control structures, so the code change types are 3,4.","The introduction of the new 'if' statement doesn't lead to a Compatibility Issue related to potential different return values or types because the method has a 'void' return type. The exception thrown is also not a change in how exceptions were previously handled since RemoteException was caught and logged before, and continues to be. The IllegalStateException introduced is a pre-condition check for method invocation that ensures integrity before the actual operation is proceeded with. Therefore, the new change does not create a scenario where the API's behaviour is modified in a way that consumers of the API would have to handle differently; thus, no CI should occur from this change."
102,"<android.app.admin.DevicePolicyManager: void uninstallCaCert(ComponentName,byte[])>",22,23,"<android.app.admin.DevicePolicyManager: void uninstallCaCert(ComponentName,byte[])>","<android.app.admin.DevicePolicyManager: void uninstallCaCert(ComponentName,byte[])>",0,"{
    if (mService != null) {
        try {
            final String alias = getCaCertAlias(certBuffer);
            mService.uninstallCaCert(admin, alias);
        } catch (CertificateException e) {
            Log.w(TAG, ""Unable to parse certificate"", e);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    if (mService != null) {
        try {
            final String alias = getCaCertAlias(certBuffer);
            mService.uninstallCaCerts(admin, new String[] { alias });
        } catch (CertificateException e) {
            Log.w(TAG, ""Unable to parse certificate"", e);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}",1,"/**
 * Uninstalls the given certificate from trusted user CAs, if present.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param certBuffer encoded form of the certificate to remove.
 */
","/**
 * Uninstalls the given certificate from trusted user CAs, if present.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or
 * {@code null} if calling from a delegated certificate installer.
 * @param certBuffer encoded form of the certificate to remove.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method within the try block changed from mService.uninstallCaCert(admin, alias) to mService.uninstallCaCerts(admin, new String[] { alias }). Since the method name and the parameter type/number passed in have changed, it is both a change in the return statement and a dependent API change, so the code change type is 1,5.","This change in the dependent API can lead to a difference in the behavior of the API, which could potentially return a different outcome due to the change in the method being called, thus the CI type is 1."
103,"<android.app.admin.DevicePolicyManager: void setPasswordMinimumLowerCase(ComponentName,int)>",22,23,"<android.app.admin.DevicePolicyManager: void setPasswordMinimumLowerCase(ComponentName,int)>","<android.app.admin.DevicePolicyManager: void setPasswordMinimumLowerCase(ComponentName,int)>",0,"{
    if (mService != null) {
        try {
            mService.setPasswordMinimumLowerCase(admin, length, UserHandle.myUserId());
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    if (mService != null) {
        try {
            mService.setPasswordMinimumLowerCase(admin, length);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}",1,"/**
 * Called by an application that is administering the device to set the
 * minimum number of lower case letters required in the password. After
 * setting this, the user will not be able to enter a new password that is
 * not at least as restrictive as what has been set. Note that the current
 * password will remain until the user has set a new one, so the change does
 * not take place immediately. To prompt the user for a new password, use
 * {@link #ACTION_SET_NEW_PASSWORD} after setting this value. This
 * constraint is only imposed if the administrator has also requested
 * {@link #PASSWORD_QUALITY_COMPLEX} with {@link #setPasswordQuality}. The
 * default value is 0.
 * <p>
 * The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call
 * this method; if it has not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated
 * with.
 * @param length The new desired minimum number of lower case letters
 * required in the password. A value of 0 means there is no
 * restriction.
 */
","/**
 * Called by an application that is administering the device to set the
 * minimum number of lower case letters required in the password. After
 * setting this, the user will not be able to enter a new password that is
 * not at least as restrictive as what has been set. Note that the current
 * password will remain until the user has set a new one, so the change does
 * not take place immediately. To prompt the user for a new password, use
 * {@link #ACTION_SET_NEW_PASSWORD} after setting this value. This
 * constraint is only imposed if the administrator has also requested
 * {@link #PASSWORD_QUALITY_COMPLEX} with {@link #setPasswordQuality}. The
 * default value is 0.
 * <p>
 * The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call
 * this method; if it has not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated
 * with.
 * @param length The new desired minimum number of lower case letters
 * required in the password. A value of 0 means there is no
 * restriction.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method call to setPasswordMinimumLowerCase within mService has a change in the number of parameters, it no longer accepts the third argument UserHandle.myUserId(), so the change types are 4 (Other statement changed) and 5 (Dependent API changed).","Despite the change in the method call within setPasswordMinimumLowerCase, the API itself still does not produce any observable behavioral change from the perspective of its signature and its exceptions. It does not return a different value (since it's void) and does not throw new exceptions nor changes exceptions thrown. So there is no compatibility issue, hence CI type is 0."
106,<android.app.Activity: void performStart()>,22,23,<android.app.Activity: void performStart()>,<android.app.Activity: void performStart()>,0,"{
    mActivityTransitionState.setEnterActivityOptions(this, getActivityOptions());
    mFragments.noteStateNotSaved();
    mCalled = false;
    mFragments.execPendingActions();
    mInstrumentation.callActivityOnStart(this);
    if (!mCalled) {
        throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onStart()"");
    }
    mFragments.dispatchStart();
    if (mAllLoaderManagers != null) {
        final int N = mAllLoaderManagers.size();
        LoaderManagerImpl[] loaders = new LoaderManagerImpl[N];
        for (int i = N - 1; i >= 0; i--) {
            loaders[i] = mAllLoaderManagers.valueAt(i);
        }
        for (int i = 0; i < N; i++) {
            LoaderManagerImpl lm = loaders[i];
            lm.finishRetain();
            lm.doReportStart();
        }
    }
    mActivityTransitionState.enterReady(this);
}","{
    mActivityTransitionState.setEnterActivityOptions(this, getActivityOptions());
    mFragments.noteStateNotSaved();
    mCalled = false;
    mFragments.execPendingActions();
    mInstrumentation.callActivityOnStart(this);
    if (!mCalled) {
        throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onStart()"");
    }
    mFragments.dispatchStart();
    mFragments.reportLoaderStart();
    mActivityTransitionState.enterReady(this);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The loop that interacts with all loaders to call `finishRetain()` and `doReportStart()` has been replaced by a single method call to `mFragments.reportLoaderStart()`. This is an internal restructuring that changes how loaders start reporting, which is abstracted by method call change, so the code change type is 4,5.","Assuming `mFragments.reportLoaderStart()` is an internal change that correctly encapsulates the old logic (since there's no change in exception thrown and no new return statement is introduced), no new Compatibility Issue is introduced by this change."
109,"<android.view.inputmethod.InputMethodManager: Map<InputMethodInfo, List<InputMethodSubtype>> getShortcutInputMethodsAndSubtypes()>",22,23,"<android.view.inputmethod.InputMethodManager: Map<InputMethodInfo, List<InputMethodSubtype>> getShortcutInputMethodsAndSubtypes()>","<android.view.inputmethod.InputMethodManager: Map<InputMethodInfo, List<InputMethodSubtype>> getShortcutInputMethodsAndSubtypes()>",0,"{
    synchronized (mH) {
        HashMap<InputMethodInfo, List<InputMethodSubtype>> ret = new HashMap<InputMethodInfo, List<InputMethodSubtype>>();
        try {
            // TODO: We should change the return type from List<Object> to List<Parcelable>
            List<Object> info = mService.getShortcutInputMethodsAndSubtypes();
            // ""info"" has imi1, subtype1, subtype2, imi2, subtype2, imi3, subtype3..in the list
            ArrayList<InputMethodSubtype> subtypes = null;
            final int N = info.size();
            if (info != null && N > 0) {
                for (int i = 0; i < N; ++i) {
                    Object o = info.get(i);
                    if (o instanceof InputMethodInfo) {
                        if (ret.containsKey(o)) {
                            Log.e(TAG, ""IMI list already contains the same InputMethod."");
                            break;
                        }
                        subtypes = new ArrayList<InputMethodSubtype>();
                        ret.put((InputMethodInfo) o, subtypes);
                    } else if (subtypes != null && o instanceof InputMethodSubtype) {
                        subtypes.add((InputMethodSubtype) o);
                    }
                }
            }
        } catch (RemoteException e) {
            Log.w(TAG, ""IME died: "" + mCurId, e);
        }
        return ret;
    }
}","{
    synchronized (mH) {
        HashMap<InputMethodInfo, List<InputMethodSubtype>> ret = new HashMap<InputMethodInfo, List<InputMethodSubtype>>();
        try {
            // TODO: We should change the return type from List<Object> to List<Parcelable>
            List<Object> info = mService.getShortcutInputMethodsAndSubtypes();
            // ""info"" has imi1, subtype1, subtype2, imi2, subtype2, imi3, subtype3..in the list
            ArrayList<InputMethodSubtype> subtypes = null;
            if (info != null && !info.isEmpty()) {
                final int N = info.size();
                for (int i = 0; i < N; ++i) {
                    Object o = info.get(i);
                    if (o instanceof InputMethodInfo) {
                        if (ret.containsKey(o)) {
                            Log.e(TAG, ""IMI list already contains the same InputMethod."");
                            break;
                        }
                        subtypes = new ArrayList<InputMethodSubtype>();
                        ret.put((InputMethodInfo) o, subtypes);
                    } else if (subtypes != null && o instanceof InputMethodSubtype) {
                        subtypes.add((InputMethodSubtype) o);
                    }
                }
            }
        } catch (RemoteException e) {
            Log.w(TAG, ""IME died: "" + mCurId, e);
        }
        return ret;
    }
}",1,"/**
 * Returns a map of all shortcut input method info and their subtypes.
 */
","/**
 * Returns a map of all shortcut input method info and their subtypes.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The change is within a control dependency. The check for the size of the list `info` was changed from `N > 0` to `!info.isEmpty()`. This is a refactoring that does not alter the behavior of the code because both conditions are functionally equivalent, checking that the list is not empty. Thus, the only change is type 3.","There is no Compatibility Issue because the logic of how the API operates has not changed; the list is checked for emptiness in both versions before continuing with the same subsequent operations. Therefore, it's classified as 0 (No Compatibility Issue)."
110,<android.hardware.display.DisplayManagerInternal.DisplayPowerRequest: String toString()>,22,23,<android.hardware.display.DisplayManagerInternal.DisplayPowerRequest: String toString()>,<android.hardware.display.DisplayManagerInternal.DisplayPowerRequest: String toString()>,0,"{
    return ""policy="" + policyToString(policy) + "", useProximitySensor="" + useProximitySensor + "", screenBrightness="" + screenBrightness + "", screenAutoBrightnessAdjustment="" + screenAutoBrightnessAdjustment + "", useAutoBrightness="" + useAutoBrightness + "", blockScreenOn="" + blockScreenOn + "", lowPowerMode="" + lowPowerMode + "", boostScreenBrightness="" + boostScreenBrightness + "", dozeScreenBrightness="" + dozeScreenBrightness + "", dozeScreenState="" + Display.stateToString(dozeScreenState);
}","{
    return ""policy="" + policyToString(policy) + "", useProximitySensor="" + useProximitySensor + "", screenBrightness="" + screenBrightness + "", screenAutoBrightnessAdjustment="" + screenAutoBrightnessAdjustment + "", brightnessSetByUser="" + brightnessSetByUser + "", useAutoBrightness="" + useAutoBrightness + "", blockScreenOn="" + blockScreenOn + "", lowPowerMode="" + lowPowerMode + "", boostScreenBrightness="" + boostScreenBrightness + "", dozeScreenBrightness="" + dozeScreenBrightness + "", dozeScreenState="" + Display.stateToString(dozeScreenState);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The change in the implementation is the addition of a new field to the returned String: "", brightnessSetByUser="" + brightnessSetByUser. This is not a change in the control flow or the method signature, and it does not introduce any different exception handling. It qualifies as 'Other statement changed'.","The modification made only adds additional information to the String being returned by the toString() method. Since toString is meant for providing a string representation of the object, and none of the object’s operational behavior or state changes, this additional information does not introduce a Compatibility Issue. Thus, there is no Compatibility Issue caused by this change."
111,"<android.content.ContentProviderClient: AssetFileDescriptor openTypedAssetFileDescriptor(Uri,String,Bundle,CancellationSignal)>",22,23,"<android.content.ContentProviderClient: AssetFileDescriptor openTypedAssetFileDescriptor(Uri,String,Bundle,CancellationSignal)>","<android.content.ContentProviderClient: AssetFileDescriptor openTypedAssetFileDescriptor(Uri,String,Bundle,CancellationSignal)>",0,"{
    beforeRemote();
    try {
        ICancellationSignal remoteSignal = null;
        if (signal != null) {
            signal.throwIfCanceled();
            remoteSignal = mContentProvider.createCancellationSignal();
            signal.setRemote(remoteSignal);
        }
        return mContentProvider.openTypedAssetFile(mPackageName, uri, mimeType, opts, remoteSignal);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}","{
    Preconditions.checkNotNull(uri, ""uri"");
    Preconditions.checkNotNull(mimeType, ""mimeType"");
    beforeRemote();
    try {
        ICancellationSignal remoteSignal = null;
        if (signal != null) {
            signal.throwIfCanceled();
            remoteSignal = mContentProvider.createCancellationSignal();
            signal.setRemote(remoteSignal);
        }
        return mContentProvider.openTypedAssetFile(mPackageName, uri, mimeType, opts, remoteSignal);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}",1,"/**
 * See {@link ContentProvider#openTypedAssetFile ContentProvider.openTypedAssetFile}
 */
","/**
 * See {@link ContentProvider#openTypedAssetFile ContentProvider.openTypedAssetFile}
 */
",-1,,[@Nullable],-1,-1,-1,-1,-1,-1,4,0,"The change in the code is the addition of two Preconditions.checkNotNull() method calls. These statements don't change any return statements or exception handling statements related to 'openTypedAssetFileDescriptor' behavior directly, hence the code change type is 4.","The added preconditions check for null arguments and will throw a NullPointerException if 'uri' or 'mimeType' is null prior to their use. Since these are precondition checks, they protect the method from proceeding with invalid input and are not considered a change that would affect the method behavior as it relates to the handling of its normal operation, instead, they enforce contractual preconditions. Therefore, there is no Compatibility Issue related to the return values or exception handling of the method as a result of these changes."
115,"<android.content.res.TypedArray: int getLayoutDimension(int,String)>",22,23,"<android.content.res.TypedArray: int getLayoutDimension(int,String)>","<android.content.res.TypedArray: int getLayoutDimension(int,String)>",0,"{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA];
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimensionPixelSize(data[index + AssetManager.STYLE_DATA], mMetrics);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        throw new RuntimeException(""Failed to resolve attribute at index "" + index);
    }
    throw new RuntimeException(getPositionDescription() + "": You must supply a "" + name + "" attribute."");
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA];
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimensionPixelSize(data[index + AssetManager.STYLE_DATA], mMetrics);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, value);
        throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + index + "": "" + value);
    }
    throw new UnsupportedOperationException(getPositionDescription() + "": You must supply a "" + name + "" attribute."");
}",1,"/**
 * Special version of {@link #getDimensionPixelSize} for retrieving
 * {@link android.view.ViewGroup}'s layout_width and layout_height
 * attributes.  This is only here for performance reasons; applications
 * should use {@link #getDimensionPixelSize}.
 *
 * @param index Index of the attribute to retrieve.
 * @param name Textual name of attribute for error reporting.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric and truncated to integer pixels.
 */
","/**
 * Special version of {@link #getDimensionPixelSize} for retrieving
 * {@link android.view.ViewGroup}'s layout_width and layout_height
 * attributes.  This is only here for performance reasons; applications
 * should use {@link #getDimensionPixelSize}.
 * <p>
 * This method will throw an exception if the attribute is defined but is
 * not a dimension or integer (enum).
 *
 * @param index Index of the attribute to retrieve.
 * @param name Textual name of attribute for error reporting.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric and truncated to integer pixels.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not a dimension or integer (enum).
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"The change includes modifications to the exception type thrown (`RuntimeException` changed to `UnsupportedOperationException`) and the content inside an exception (`""Failed to resolve attribute at index "" + index` changed to `""Failed to resolve attribute at index "" + index + "": "" + value`). Also, a new method call `getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, value)` is introduced before throwing an `UnsupportedOperationException`, so the change types are 2 for exception handling statement changed and 4 for other statement changed.","Due to the change in the exception thrown when the attribute type is `TypedValue.TYPE_ATTRIBUTE`, there may be a different exception handling behavior in the late version compared to the early version, resulting in a possible change in the behavior of the API when such a condition is encountered. This change could lead to a Compatibility Issue caused by different exception handlings, thus the CI type is 2."
118,<android.hardware.usb.UsbDevice: String toString()>,22,23,<android.hardware.usb.UsbDevice: String toString()>,<android.hardware.usb.UsbDevice: String toString()>,0,"{
    StringBuilder builder = new StringBuilder(""UsbDevice[mName="" + mName + "",mVendorId="" + mVendorId + "",mProductId="" + mProductId + "",mClass="" + mClass + "",mSubclass="" + mSubclass + "",mProtocol="" + mProtocol + "",mManufacturerName="" + mManufacturerName + "",mProductName="" + mProductName + "",mSerialNumber="" + mSerialNumber + "",mConfigurations=["");
    for (int i = 0; i < mConfigurations.length; i++) {
        builder.append(""\n"");
        builder.append(mConfigurations[i].toString());
    }
    builder.append(""]"");
    return builder.toString();
}","{
    StringBuilder builder = new StringBuilder(""UsbDevice[mName="" + mName + "",mVendorId="" + mVendorId + "",mProductId="" + mProductId + "",mClass="" + mClass + "",mSubclass="" + mSubclass + "",mProtocol="" + mProtocol + "",mManufacturerName="" + mManufacturerName + "",mProductName="" + mProductName + "",mVersion="" + mVersion + "",mSerialNumber="" + mSerialNumber + "",mConfigurations=["");
    for (int i = 0; i < mConfigurations.length; i++) {
        builder.append(""\n"");
        builder.append(mConfigurations[i].toString());
    }
    builder.append(""]"");
    return builder.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The only change between the early and late versions is in the string that's being built: the late version uses ""mVersion"" instead of not adding it to the string at all. This change falls under the category 'Other statement changed' which is type 4.","Despite the alteration of the toString() method implementation, there is no Compatibility Issue. The modification only affects the string representation of the UsbDevice object but does not affect the functional behavior, the values returned, or exception handling - it just adds extra information to the string. Hence, the method's return type, value types, and exception throwing behavior remain unchanged. Consequently, there will be no compatibility issues regarding differing return values or exception throwing behavior, making this type 0."
119,"<android.app.admin.DevicePolicyManager: void setMaximumFailedPasswordsForWipe(ComponentName,int)>",22,23,"<android.app.admin.DevicePolicyManager: void setMaximumFailedPasswordsForWipe(ComponentName,int)>","<android.app.admin.DevicePolicyManager: void setMaximumFailedPasswordsForWipe(ComponentName,int)>",0,"{
    if (mService != null) {
        try {
            mService.setMaximumFailedPasswordsForWipe(admin, num, UserHandle.myUserId());
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    if (mService != null) {
        try {
            mService.setMaximumFailedPasswordsForWipe(admin, num);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}",1,"/**
 * Setting this to a value greater than zero enables a built-in policy
 * that will perform a device wipe after too many incorrect
 * device-unlock passwords have been entered.  This built-in policy combines
 * watching for failed passwords and wiping the device, and requires
 * that you request both {@link DeviceAdminInfo#USES_POLICY_WATCH_LOGIN} and
 * {@link DeviceAdminInfo#USES_POLICY_WIPE_DATA}}.
 *
 * <p>To implement any other policy (e.g. wiping data for a particular
 * application only, erasing or revoking credentials, or reporting the
 * failure to a server), you should implement
 * {@link DeviceAdminReceiver#onPasswordFailed(Context, android.content.Intent)}
 * instead.  Do not use this API, because if the maximum count is reached,
 * the device will be wiped immediately, and your callback will not be invoked.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param num The number of failed password attempts at which point the
 * device will wipe its data.
 */
","/**
 * Setting this to a value greater than zero enables a built-in policy
 * that will perform a device wipe after too many incorrect
 * device-unlock passwords have been entered.  This built-in policy combines
 * watching for failed passwords and wiping the device, and requires
 * that you request both {@link DeviceAdminInfo#USES_POLICY_WATCH_LOGIN} and
 * {@link DeviceAdminInfo#USES_POLICY_WIPE_DATA}}.
 *
 * <p>To implement any other policy (e.g. wiping data for a particular
 * application only, erasing or revoking credentials, or reporting the
 * failure to a server), you should implement
 * {@link DeviceAdminReceiver#onPasswordFailed(Context, android.content.Intent)}
 * instead.  Do not use this API, because if the maximum count is reached,
 * the device will be wiped immediately, and your callback will not be invoked.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param num The number of failed password attempts at which point the
 * device will wipe its data.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The parameter list in the dependent API method call mService.setMaximumFailedPasswordsForWipe(admin, num, UserHandle.myUserId()) has changed to mService.setMaximumFailedPasswordsForWipe(admin, num). This means that the code change type is 5.","Since there are no changes to the behavior of this method itself (i.e., no changes to return statements or exception handling statements), apart from the parameter list change in the dependent API call, there is no potential Compatibility Issue according to the given definitions, so the CI type is 0."
121,"<android.app.admin.DevicePolicyManager: void setKeyguardDisabledFeatures(ComponentName,int)>",22,23,"<android.app.admin.DevicePolicyManager: void setKeyguardDisabledFeatures(ComponentName,int)>","<android.app.admin.DevicePolicyManager: void setKeyguardDisabledFeatures(ComponentName,int)>",0,"{
    if (mService != null) {
        try {
            mService.setKeyguardDisabledFeatures(admin, which, UserHandle.myUserId());
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    if (mService != null) {
        try {
            mService.setKeyguardDisabledFeatures(admin, which);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}",1,"/**
 * Called by an application that is administering the device to disable keyguard customizations,
 * such as widgets. After setting this, keyguard features will be disabled according to the
 * provided feature list.
 *
 * <p>The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_DISABLE_KEYGUARD_FEATURES} to be able to call
 * this method; if it has not, a security exception will be thrown.
 *
 * <p>Calling this from a managed profile will throw a security exception.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param which {@link #KEYGUARD_DISABLE_FEATURES_NONE} (default),
 * {@link #KEYGUARD_DISABLE_WIDGETS_ALL}, {@link #KEYGUARD_DISABLE_SECURE_CAMERA},
 * {@link #KEYGUARD_DISABLE_SECURE_NOTIFICATIONS}, {@link #KEYGUARD_DISABLE_TRUST_AGENTS},
 * {@link #KEYGUARD_DISABLE_UNREDACTED_NOTIFICATIONS}, {@link #KEYGUARD_DISABLE_FEATURES_ALL}
 */
","/**
 * Called by an application that is administering the device to disable keyguard customizations,
 * such as widgets. After setting this, keyguard features will be disabled according to the
 * provided feature list.
 *
 * <p>The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_DISABLE_KEYGUARD_FEATURES} to be able to call
 * this method; if it has not, a security exception will be thrown.
 *
 * <p>Calling this from a managed profile before version
 * {@link android.os.Build.VERSION_CODES#M} will throw a security exception.
 *
 * <p>From version {@link android.os.Build.VERSION_CODES#M} a profile owner can set:
 * <ul>
 * <li>{@link #KEYGUARD_DISABLE_TRUST_AGENTS}, {@link #KEYGUARD_DISABLE_FINGERPRINT}
 * these will affect the profile's parent user.
 * <li>{@link #KEYGUARD_DISABLE_UNREDACTED_NOTIFICATIONS} this will affect notifications
 * generated by applications in the managed profile.
 * </ul>
 * <p>Requests to disable other features on a managed profile will be ignored. The admin
 * can check which features have been disabled by calling
 * {@link #getKeyguardDisabledFeatures(ComponentName)}
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param which {@link #KEYGUARD_DISABLE_FEATURES_NONE} (default),
 * {@link #KEYGUARD_DISABLE_WIDGETS_ALL}, {@link #KEYGUARD_DISABLE_SECURE_CAMERA},
 * {@link #KEYGUARD_DISABLE_SECURE_NOTIFICATIONS}, {@link #KEYGUARD_DISABLE_TRUST_AGENTS},
 * {@link #KEYGUARD_DISABLE_UNREDACTED_NOTIFICATIONS}, {@link #KEYGUARD_DISABLE_FINGERPRINT},
 * {@link #KEYGUARD_DISABLE_FEATURES_ALL}
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method signature of the dependent API mService.setKeyguardDisabledFeatures() was changed by removing the last parameter, so the code change type is 5.","The change in the dependent API does not introduce a new behavior in the API; it simply calls the updated method with one less parameter. Given there's no change in the return type or exception handling in the surrounding code, there should be no Compatibility Issue, therefore the CI type is 0."
124,"<android.widget.YearPickerView.YearAdapter: View getView(int,View,ViewGroup)>",22,23,"<android.widget.YearPickerView.YearAdapter: View getView(int,View,ViewGroup)>","<android.widget.YearPickerView.YearAdapter: View getView(int,View,ViewGroup)>",0,"{
    TextViewWithCircularIndicator v = (TextViewWithCircularIndicator) super.getView(position, convertView, parent);
    v.setTextAppearance(getContext(), mItemTextAppearanceResId);
    v.requestLayout();
    int year = getItem(position);
    boolean selected = mController.getSelectedDay().get(Calendar.YEAR) == year;
    v.setDrawIndicator(selected);
    if (selected) {
        v.setCircleColor(mYearSelectedCircleColor);
    }
    return v;
}","{
    final TextView v;
    final boolean hasNewView = convertView == null;
    if (hasNewView) {
        v = (TextView) mInflater.inflate(ITEM_LAYOUT, parent, false);
    } else {
        v = (TextView) convertView;
    }
    final int year = getYearForPosition(position);
    final boolean activated = mActivatedYear == year;
    if (hasNewView || v.isActivated() != activated) {
        final int textAppearanceResId;
        if (activated && ITEM_TEXT_ACTIVATED_APPEARANCE != 0) {
            textAppearanceResId = ITEM_TEXT_ACTIVATED_APPEARANCE;
        } else {
            textAppearanceResId = ITEM_TEXT_APPEARANCE;
        }
        v.setTextAppearance(textAppearanceResId);
        v.setActivated(activated);
    }
    v.setText(Integer.toString(year));
    return v;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,"The late version has introduced new control flow with the 'hasNewView' flag and changed how the view instance is retrieved and styled. There is a change in the return statement with different method calls that affect the returned view's attributes, and other statements are also changed to reflect the activated state and text appearance conditionally. Accordingly, the code change types include 1 (Return statement changed), 3 (Control dependency changed), and 4 (Other statement changed).","The returned 'View' object could have different properties based on the new implementation, such as its activation state and text appearance, which would be a Compatibility Issue as the behaviours (appearance and selection indication) of the views returned by this method could be different between versions, and as a result, this is a type 1 Compatibility Issue."
125,<android.widget.TextView: boolean bringPointIntoView(int)>,22,23,<android.widget.TextView: boolean bringPointIntoView(int)>,<android.widget.TextView: boolean bringPointIntoView(int)>,0,"{
    if (isLayoutRequested()) {
        mDeferScroll = offset;
        return false;
    }
    boolean changed = false;
    Layout layout = isShowingHint() ? mHintLayout : mLayout;
    if (layout == null)
        return changed;
    int line = layout.getLineForOffset(offset);
    int grav;
    switch(layout.getParagraphAlignment(line)) {
        case ALIGN_LEFT:
            grav = 1;
            break;
        case ALIGN_RIGHT:
            grav = -1;
            break;
        case ALIGN_NORMAL:
            grav = layout.getParagraphDirection(line);
            break;
        case ALIGN_OPPOSITE:
            grav = -layout.getParagraphDirection(line);
            break;
        case ALIGN_CENTER:
        default:
            grav = 0;
            break;
    }
    // We only want to clamp the cursor to fit within the layout width
    // in left-to-right modes, because in a right to left alignment,
    // we want to scroll to keep the line-right on the screen, as other
    // lines are likely to have text flush with the right margin, which
    // we want to keep visible.
    // A better long-term solution would probably be to measure both
    // the full line and a blank-trimmed version, and, for example, use
    // the latter measurement for centering and right alignment, but for
    // the time being we only implement the cursor clamping in left to
    // right where it is most likely to be annoying.
    final boolean clamped = grav > 0;
    // FIXME: Is it okay to truncate this, or should we round?
    final int x = (int) layout.getPrimaryHorizontal(offset, clamped);
    final int top = layout.getLineTop(line);
    final int bottom = layout.getLineTop(line + 1);
    int left = (int) FloatMath.floor(layout.getLineLeft(line));
    int right = (int) FloatMath.ceil(layout.getLineRight(line));
    int ht = layout.getHeight();
    int hspace = mRight - mLeft - getCompoundPaddingLeft() - getCompoundPaddingRight();
    int vspace = mBottom - mTop - getExtendedPaddingTop() - getExtendedPaddingBottom();
    if (!mHorizontallyScrolling && right - left > hspace && right > x) {
        // If cursor has been clamped, make sure we don't scroll.
        right = Math.max(x, left + hspace);
    }
    int hslack = (bottom - top) / 2;
    int vslack = hslack;
    if (vslack > vspace / 4)
        vslack = vspace / 4;
    if (hslack > hspace / 4)
        hslack = hspace / 4;
    int hs = mScrollX;
    int vs = mScrollY;
    if (top - vs < vslack)
        vs = top - vslack;
    if (bottom - vs > vspace - vslack)
        vs = bottom - (vspace - vslack);
    if (ht - vs < vspace)
        vs = ht - vspace;
    if (0 - vs > 0)
        vs = 0;
    if (grav != 0) {
        if (x - hs < hslack) {
            hs = x - hslack;
        }
        if (x - hs > hspace - hslack) {
            hs = x - (hspace - hslack);
        }
    }
    if (grav < 0) {
        if (left - hs > 0)
            hs = left;
        if (right - hs < hspace)
            hs = right - hspace;
    } else if (grav > 0) {
        if (right - hs < hspace)
            hs = right - hspace;
        if (left - hs > 0)
            hs = left;
    } else /* grav == 0 */
    {
        if (right - left <= hspace) {
            /*
                 * If the entire text fits, center it exactly.
                 */
            hs = left - (hspace - (right - left)) / 2;
        } else if (x > right - hslack) {
            /*
                 * If we are near the right edge, keep the right edge
                 * at the edge of the view.
                 */
            hs = right - hspace;
        } else if (x < left + hslack) {
            /*
                 * If we are near the left edge, keep the left edge
                 * at the edge of the view.
                 */
            hs = left;
        } else if (left > hs) {
            /*
                 * Is there whitespace visible at the left?  Fix it if so.
                 */
            hs = left;
        } else if (right < hs + hspace) {
            /*
                 * Is there whitespace visible at the right?  Fix it if so.
                 */
            hs = right - hspace;
        } else {
            /*
                 * Otherwise, float as needed.
                 */
            if (x - hs < hslack) {
                hs = x - hslack;
            }
            if (x - hs > hspace - hslack) {
                hs = x - (hspace - hslack);
            }
        }
    }
    if (hs != mScrollX || vs != mScrollY) {
        if (mScroller == null) {
            scrollTo(hs, vs);
        } else {
            long duration = AnimationUtils.currentAnimationTimeMillis() - mLastScroll;
            int dx = hs - mScrollX;
            int dy = vs - mScrollY;
            if (duration > ANIMATED_SCROLL_GAP) {
                mScroller.startScroll(mScrollX, mScrollY, dx, dy);
                awakenScrollBars(mScroller.getDuration());
                invalidate();
            } else {
                if (!mScroller.isFinished()) {
                    mScroller.abortAnimation();
                }
                scrollBy(dx, dy);
            }
            mLastScroll = AnimationUtils.currentAnimationTimeMillis();
        }
        changed = true;
    }
    if (isFocused()) {
        // will be ignored.
        if (mTempRect == null)
            mTempRect = new Rect();
        mTempRect.set(x - 2, top, x + 2, bottom);
        getInterestingRect(mTempRect, line);
        mTempRect.offset(mScrollX, mScrollY);
        if (requestRectangleOnScreen(mTempRect)) {
            changed = true;
        }
    }
    return changed;
}","{
    if (isLayoutRequested()) {
        mDeferScroll = offset;
        return false;
    }
    boolean changed = false;
    Layout layout = isShowingHint() ? mHintLayout : mLayout;
    if (layout == null)
        return changed;
    int line = layout.getLineForOffset(offset);
    int grav;
    switch(layout.getParagraphAlignment(line)) {
        case ALIGN_LEFT:
            grav = 1;
            break;
        case ALIGN_RIGHT:
            grav = -1;
            break;
        case ALIGN_NORMAL:
            grav = layout.getParagraphDirection(line);
            break;
        case ALIGN_OPPOSITE:
            grav = -layout.getParagraphDirection(line);
            break;
        case ALIGN_CENTER:
        default:
            grav = 0;
            break;
    }
    // We only want to clamp the cursor to fit within the layout width
    // in left-to-right modes, because in a right to left alignment,
    // we want to scroll to keep the line-right on the screen, as other
    // lines are likely to have text flush with the right margin, which
    // we want to keep visible.
    // A better long-term solution would probably be to measure both
    // the full line and a blank-trimmed version, and, for example, use
    // the latter measurement for centering and right alignment, but for
    // the time being we only implement the cursor clamping in left to
    // right where it is most likely to be annoying.
    final boolean clamped = grav > 0;
    // FIXME: Is it okay to truncate this, or should we round?
    final int x = (int) layout.getPrimaryHorizontal(offset, clamped);
    final int top = layout.getLineTop(line);
    final int bottom = layout.getLineTop(line + 1);
    int left = (int) Math.floor(layout.getLineLeft(line));
    int right = (int) Math.ceil(layout.getLineRight(line));
    int ht = layout.getHeight();
    int hspace = mRight - mLeft - getCompoundPaddingLeft() - getCompoundPaddingRight();
    int vspace = mBottom - mTop - getExtendedPaddingTop() - getExtendedPaddingBottom();
    if (!mHorizontallyScrolling && right - left > hspace && right > x) {
        // If cursor has been clamped, make sure we don't scroll.
        right = Math.max(x, left + hspace);
    }
    int hslack = (bottom - top) / 2;
    int vslack = hslack;
    if (vslack > vspace / 4)
        vslack = vspace / 4;
    if (hslack > hspace / 4)
        hslack = hspace / 4;
    int hs = mScrollX;
    int vs = mScrollY;
    if (top - vs < vslack)
        vs = top - vslack;
    if (bottom - vs > vspace - vslack)
        vs = bottom - (vspace - vslack);
    if (ht - vs < vspace)
        vs = ht - vspace;
    if (0 - vs > 0)
        vs = 0;
    if (grav != 0) {
        if (x - hs < hslack) {
            hs = x - hslack;
        }
        if (x - hs > hspace - hslack) {
            hs = x - (hspace - hslack);
        }
    }
    if (grav < 0) {
        if (left - hs > 0)
            hs = left;
        if (right - hs < hspace)
            hs = right - hspace;
    } else if (grav > 0) {
        if (right - hs < hspace)
            hs = right - hspace;
        if (left - hs > 0)
            hs = left;
    } else /* grav == 0 */
    {
        if (right - left <= hspace) {
            /*
                 * If the entire text fits, center it exactly.
                 */
            hs = left - (hspace - (right - left)) / 2;
        } else if (x > right - hslack) {
            /*
                 * If we are near the right edge, keep the right edge
                 * at the edge of the view.
                 */
            hs = right - hspace;
        } else if (x < left + hslack) {
            /*
                 * If we are near the left edge, keep the left edge
                 * at the edge of the view.
                 */
            hs = left;
        } else if (left > hs) {
            /*
                 * Is there whitespace visible at the left?  Fix it if so.
                 */
            hs = left;
        } else if (right < hs + hspace) {
            /*
                 * Is there whitespace visible at the right?  Fix it if so.
                 */
            hs = right - hspace;
        } else {
            /*
                 * Otherwise, float as needed.
                 */
            if (x - hs < hslack) {
                hs = x - hslack;
            }
            if (x - hs > hspace - hslack) {
                hs = x - (hspace - hslack);
            }
        }
    }
    if (hs != mScrollX || vs != mScrollY) {
        if (mScroller == null) {
            scrollTo(hs, vs);
        } else {
            long duration = AnimationUtils.currentAnimationTimeMillis() - mLastScroll;
            int dx = hs - mScrollX;
            int dy = vs - mScrollY;
            if (duration > ANIMATED_SCROLL_GAP) {
                mScroller.startScroll(mScrollX, mScrollY, dx, dy);
                awakenScrollBars(mScroller.getDuration());
                invalidate();
            } else {
                if (!mScroller.isFinished()) {
                    mScroller.abortAnimation();
                }
                scrollBy(dx, dy);
            }
            mLastScroll = AnimationUtils.currentAnimationTimeMillis();
        }
        changed = true;
    }
    if (isFocused()) {
        // will be ignored.
        if (mTempRect == null)
            mTempRect = new Rect();
        mTempRect.set(x - 2, top, x + 2, bottom);
        getInterestingRect(mTempRect, line);
        mTempRect.offset(mScrollX, mScrollY);
        if (requestRectangleOnScreen(mTempRect)) {
            changed = true;
        }
    }
    return changed;
}",1,"/**
 * Move the point, specified by the offset, into the view if it is needed.
 * This has to be called after layout. Returns true if anything changed.
 */
","/**
 * Move the point, specified by the offset, into the view if it is needed.
 * This has to be called after layout. Returns true if anything changed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
126,"<android.widget.AbsListView.RecycleBin: void addScrapView(View,int)>",22,23,"<android.widget.AbsListView.RecycleBin: void addScrapView(View,int)>","<android.widget.AbsListView.RecycleBin: void addScrapView(View,int)>",0,"{
    final AbsListView.LayoutParams lp = (AbsListView.LayoutParams) scrap.getLayoutParams();
    if (lp == null) {
        return;
    }
    lp.scrappedFromPosition = position;
    // Remove but don't scrap header or footer views, or views that
    // should otherwise not be recycled.
    final int viewType = lp.viewType;
    if (!shouldRecycleViewType(viewType)) {
        return;
    }
    scrap.dispatchStartTemporaryDetach();
    // The the accessibility state of the view may change while temporary
    // detached and we do not allow detached views to fire accessibility
    // events. So we are announcing that the subtree changed giving a chance
    // to clients holding on to a view in this subtree to refresh it.
    notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_SUBTREE);
    // Don't scrap views that have transient state.
    final boolean scrapHasTransientState = scrap.hasTransientState();
    if (scrapHasTransientState) {
        if (mAdapter != null && mAdapterHasStableIds) {
            // the same data.
            if (mTransientStateViewsById == null) {
                mTransientStateViewsById = new LongSparseArray<View>();
            }
            mTransientStateViewsById.put(lp.itemId, scrap);
        } else if (!mDataChanged) {
            // their old positions.
            if (mTransientStateViews == null) {
                mTransientStateViews = new SparseArray<View>();
            }
            mTransientStateViews.put(position, scrap);
        } else {
            // Otherwise, we'll have to remove the view and start over.
            if (mSkippedScrap == null) {
                mSkippedScrap = new ArrayList<View>();
            }
            mSkippedScrap.add(scrap);
        }
    } else {
        if (mViewTypeCount == 1) {
            mCurrentScrap.add(scrap);
        } else {
            mScrapViews[viewType].add(scrap);
        }
        if (mRecyclerListener != null) {
            mRecyclerListener.onMovedToScrapHeap(scrap);
        }
    }
}","{
    final AbsListView.LayoutParams lp = (AbsListView.LayoutParams) scrap.getLayoutParams();
    if (lp == null) {
        // Ignore it completely.
        return;
    }
    lp.scrappedFromPosition = position;
    // Remove but don't scrap header or footer views, or views that
    // should otherwise not be recycled.
    final int viewType = lp.viewType;
    if (!shouldRecycleViewType(viewType)) {
        // heap and we'll fully detach the view later.
        if (viewType != ITEM_VIEW_TYPE_HEADER_OR_FOOTER) {
            getSkippedScrap().add(scrap);
        }
        return;
    }
    scrap.dispatchStartTemporaryDetach();
    // The the accessibility state of the view may change while temporary
    // detached and we do not allow detached views to fire accessibility
    // events. So we are announcing that the subtree changed giving a chance
    // to clients holding on to a view in this subtree to refresh it.
    notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_SUBTREE);
    // Don't scrap views that have transient state.
    final boolean scrapHasTransientState = scrap.hasTransientState();
    if (scrapHasTransientState) {
        if (mAdapter != null && mAdapterHasStableIds) {
            // the same data.
            if (mTransientStateViewsById == null) {
                mTransientStateViewsById = new LongSparseArray<>();
            }
            mTransientStateViewsById.put(lp.itemId, scrap);
        } else if (!mDataChanged) {
            // their old positions.
            if (mTransientStateViews == null) {
                mTransientStateViews = new SparseArray<>();
            }
            mTransientStateViews.put(position, scrap);
        } else {
            // Otherwise, we'll have to remove the view and start over.
            getSkippedScrap().add(scrap);
        }
    } else {
        if (mViewTypeCount == 1) {
            mCurrentScrap.add(scrap);
        } else {
            mScrapViews[viewType].add(scrap);
        }
        if (mRecyclerListener != null) {
            mRecyclerListener.onMovedToScrapHeap(scrap);
        }
    }
}",1,"/**
 * Puts a view into the list of scrap views.
 * <p>
 * If the list data hasn't changed or the adapter has stable IDs, views
 * with transient state will be preserved for later retrieval.
 *
 * @param scrap The view to add
 * @param position The view's position within its parent
 */
","/**
 * Puts a view into the list of scrap views.
 * <p>
 * If the list data hasn't changed or the adapter has stable IDs, views
 * with transient state will be preserved for later retrieval.
 *
 * @param scrap The view to add
 * @param position The view's position within its parent
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The condition check `viewType != ITEM_VIEW_TYPE_HEADER_OR_FOOTER` and the corresponding block that adds the view to `getSkippedScrap()` have been added; also, the instantiation of `mTransientStateViewsById` and `mTransientStateViews` have been changed from `new LongSparseArray<View>();` and `new SparseArray<View>();` to `new LongSparseArray<>();` and `new SparseArray<>();`. Therefore, the change types are 3 (control dependency change due to new condition) and 4 (other statement change).","The compatibility issue arises due to the added condition `viewType != ITEM_VIEW_TYPE_HEADER_OR_FOOTER`, which introduces a new pathway and can change the method behavior by not adding certain views to the skipped scrap, which was not the case in the early version. Thus, the method can potentially return/act differently, meaning the CI type is 1."
127,<android.webkit.WebResourceResponse: void setData(InputStream)>,22,23,<android.webkit.WebResourceResponse: void setData(InputStream)>,<android.webkit.WebResourceResponse: void setData(InputStream)>,0,"{
    mInputStream = data;
}","{
    checkImmutable();
    // If data is (or is a subclass of) StringBufferInputStream
    if (data != null && StringBufferInputStream.class.isAssignableFrom(data.getClass())) {
        throw new IllegalArgumentException(""StringBufferInputStream is deprecated and must "" + ""not be passed to a WebResourceResponse"");
    }
    mInputStream = data;
}",1,"/**
 * Sets the input stream that provides the resource response's data. Callers
 * must implement {@link InputStream#read(byte[]) InputStream.read(byte[])}.
 *
 * @param data the input stream that provides the resource response's data
 */
","/**
 * Sets the input stream that provides the resource response's data. Callers
 * must implement {@link InputStream#read(byte[]) InputStream.read(byte[])}.
 *
 * @param data the input stream that provides the resource response's data. Must not be a
 * StringBufferInputStream.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"In the late version, a new call to `checkImmutable()` is added, and a new condition is introduced that checks the type of the `data` parameter and potentially throws an `IllegalArgumentException`. These changes are classified under exception handling statement (2) and other statements (4).","The `IllegalArgumentException` thrown when a deprecated `StringBufferInputStream` is passed to `setData()` introduces a new behavior that was not present in the earlier version; hence the change potentially leads to a different exception being thrown. Therefore, the CI type is 2."
128,"<android.app.backup.BackupAgent: void fullBackupFile(File,FullBackupDataOutput)>",22,23,"<android.app.backup.BackupAgent: void fullBackupFile(File,FullBackupDataOutput)>","<android.app.backup.BackupAgent: void fullBackupFile(File,FullBackupDataOutput)>",0,"{
    // Look up where all of our various well-defined dir trees live on this device
    String mainDir;
    String filesDir;
    String nbFilesDir;
    String dbDir;
    String spDir;
    String cacheDir;
    String libDir;
    String efDir = null;
    String filePath;
    ApplicationInfo appInfo = getApplicationInfo();
    try {
        mainDir = new File(appInfo.dataDir).getCanonicalPath();
        filesDir = getFilesDir().getCanonicalPath();
        nbFilesDir = getNoBackupFilesDir().getCanonicalPath();
        dbDir = getDatabasePath(""foo"").getParentFile().getCanonicalPath();
        spDir = getSharedPrefsFile(""foo"").getParentFile().getCanonicalPath();
        cacheDir = getCacheDir().getCanonicalPath();
        libDir = (appInfo.nativeLibraryDir == null) ? null : new File(appInfo.nativeLibraryDir).getCanonicalPath();
        // may or may not have external files access to attempt backup/restore there
        if (Process.myUid() != Process.SYSTEM_UID) {
            File efLocation = getExternalFilesDir(null);
            if (efLocation != null) {
                efDir = efLocation.getCanonicalPath();
            }
        }
        // Now figure out which well-defined tree the file is placed in, working from
        // most to least specific.  We also specifically exclude the lib and cache dirs.
        filePath = file.getCanonicalPath();
    } catch (IOException e) {
        Log.w(TAG, ""Unable to obtain canonical paths"");
        return;
    }
    if (filePath.startsWith(cacheDir) || filePath.startsWith(libDir) || filePath.startsWith(nbFilesDir)) {
        Log.w(TAG, ""lib, cache, and no_backup files are not backed up"");
        return;
    }
    final String domain;
    String rootpath = null;
    if (filePath.startsWith(dbDir)) {
        domain = FullBackup.DATABASE_TREE_TOKEN;
        rootpath = dbDir;
    } else if (filePath.startsWith(spDir)) {
        domain = FullBackup.SHAREDPREFS_TREE_TOKEN;
        rootpath = spDir;
    } else if (filePath.startsWith(filesDir)) {
        domain = FullBackup.DATA_TREE_TOKEN;
        rootpath = filesDir;
    } else if (filePath.startsWith(mainDir)) {
        domain = FullBackup.ROOT_TREE_TOKEN;
        rootpath = mainDir;
    } else if ((efDir != null) && filePath.startsWith(efDir)) {
        domain = FullBackup.MANAGED_EXTERNAL_TREE_TOKEN;
        rootpath = efDir;
    } else {
        Log.w(TAG, ""File "" + filePath + "" is in an unsupported location; skipping"");
        return;
    }
    // And now that we know where it lives, semantically, back it up appropriately
    Log.i(TAG, ""backupFile() of "" + filePath + "" => domain="" + domain + "" rootpath="" + rootpath);
    FullBackup.backupToTar(getPackageName(), domain, null, rootpath, filePath, output.getData());
}","{
    // Look up where all of our various well-defined dir trees live on this device
    String mainDir;
    String filesDir;
    String nbFilesDir;
    String dbDir;
    String spDir;
    String cacheDir;
    String codeCacheDir;
    String libDir;
    String efDir = null;
    String filePath;
    ApplicationInfo appInfo = getApplicationInfo();
    try {
        mainDir = new File(appInfo.dataDir).getCanonicalPath();
        filesDir = getFilesDir().getCanonicalPath();
        nbFilesDir = getNoBackupFilesDir().getCanonicalPath();
        dbDir = getDatabasePath(""foo"").getParentFile().getCanonicalPath();
        spDir = getSharedPrefsFile(""foo"").getParentFile().getCanonicalPath();
        cacheDir = getCacheDir().getCanonicalPath();
        codeCacheDir = getCodeCacheDir().getCanonicalPath();
        libDir = (appInfo.nativeLibraryDir == null) ? null : new File(appInfo.nativeLibraryDir).getCanonicalPath();
        // may or may not have external files access to attempt backup/restore there
        if (Process.myUid() != Process.SYSTEM_UID) {
            File efLocation = getExternalFilesDir(null);
            if (efLocation != null) {
                efDir = efLocation.getCanonicalPath();
            }
        }
        // Now figure out which well-defined tree the file is placed in, working from
        // most to least specific.  We also specifically exclude the lib, cache,
        // and code_cache dirs.
        filePath = file.getCanonicalPath();
    } catch (IOException e) {
        Log.w(TAG, ""Unable to obtain canonical paths"");
        return;
    }
    if (filePath.startsWith(cacheDir) || filePath.startsWith(codeCacheDir) || filePath.startsWith(libDir) || filePath.startsWith(nbFilesDir)) {
        Log.w(TAG, ""lib, cache, code_cache, and no_backup files are not backed up"");
        return;
    }
    final String domain;
    String rootpath = null;
    if (filePath.startsWith(dbDir)) {
        domain = FullBackup.DATABASE_TREE_TOKEN;
        rootpath = dbDir;
    } else if (filePath.startsWith(spDir)) {
        domain = FullBackup.SHAREDPREFS_TREE_TOKEN;
        rootpath = spDir;
    } else if (filePath.startsWith(filesDir)) {
        domain = FullBackup.DATA_TREE_TOKEN;
        rootpath = filesDir;
    } else if (filePath.startsWith(mainDir)) {
        domain = FullBackup.ROOT_TREE_TOKEN;
        rootpath = mainDir;
    } else if ((efDir != null) && filePath.startsWith(efDir)) {
        domain = FullBackup.MANAGED_EXTERNAL_TREE_TOKEN;
        rootpath = efDir;
    } else {
        Log.w(TAG, ""File "" + filePath + "" is in an unsupported location; skipping"");
        return;
    }
    // without transmitting any file data.
    if (DEBUG)
        Log.i(TAG, ""backupFile() of "" + filePath + "" => domain="" + domain + "" rootpath="" + rootpath);
    FullBackup.backupToTar(getPackageName(), domain, null, rootpath, filePath, output);
}",1,"/**
 * Write an entire file as part of a full-backup operation.  The file's contents
 * will be delivered to the backup destination along with the metadata necessary
 * to place it with the proper location and permissions on the device where the
 * data is restored.
 *
 * <p class=""note"">It is safe to explicitly back up files underneath your application's
 * {@link #getNoBackupFilesDir()} directory, and they will be restored to that
 * location correctly.
 *
 * @param file The file to be backed up.  The file must exist and be readable by
 * the caller.
 * @param output The destination to which the backed-up file data will be sent.
 */
","/**
 * Write an entire file as part of a full-backup operation.  The file's contents
 * will be delivered to the backup destination along with the metadata necessary
 * to place it with the proper location and permissions on the device where the
 * data is restored.
 *
 * <p class=""note"">It is safe to explicitly back up files underneath your application's
 * {@link #getNoBackupFilesDir()} directory, and they will be restored to that
 * location correctly.
 *
 * @param file The file to be backed up.  The file must exist and be readable by
 * the caller.
 * @param output The destination to which the backed-up file data will be sent.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
129,"<android.app.Activity: boolean startActivityIfNeeded(Intent,int,Bundle)>",22,23,"<android.app.Activity: boolean startActivityIfNeeded(Intent,int,Bundle)>","<android.app.Activity: boolean startActivityIfNeeded(Intent,int,Bundle)>",0,"{
    if (mParent == null) {
        int result = ActivityManager.START_RETURN_INTENT_TO_CALLER;
        try {
            intent.migrateExtraStreamToClipData();
            intent.prepareToLeaveProcess();
            result = ActivityManagerNative.getDefault().startActivity(mMainThread.getApplicationThread(), getBasePackageName(), intent, intent.resolveTypeIfNeeded(getContentResolver()), mToken, mEmbeddedID, requestCode, ActivityManager.START_FLAG_ONLY_IF_NEEDED, null, options);
        } catch (RemoteException e) {
        // Empty
        }
        Instrumentation.checkStartActivityResult(result, intent);
        if (requestCode >= 0) {
            // If this start is requesting a result, we can avoid making
            // the activity visible until the result is received.  Setting
            // this code during onCreate(Bundle savedInstanceState) or onResume() will keep the
            // activity hidden during this time, to avoid flickering.
            // This can only be done when a result is requested because
            // that guarantees we will get information back when the
            // activity is finished, no matter what happens to it.
            mStartedActivity = true;
        }
        return result != ActivityManager.START_RETURN_INTENT_TO_CALLER;
    }
    throw new UnsupportedOperationException(""startActivityIfNeeded can only be called from a top-level activity"");
}","{
    if (mParent == null) {
        int result = ActivityManager.START_RETURN_INTENT_TO_CALLER;
        try {
            Uri referrer = onProvideReferrer();
            if (referrer != null) {
                intent.putExtra(Intent.EXTRA_REFERRER, referrer);
            }
            intent.migrateExtraStreamToClipData();
            intent.prepareToLeaveProcess();
            result = ActivityManagerNative.getDefault().startActivity(mMainThread.getApplicationThread(), getBasePackageName(), intent, intent.resolveTypeIfNeeded(getContentResolver()), mToken, mEmbeddedID, requestCode, ActivityManager.START_FLAG_ONLY_IF_NEEDED, null, options);
        } catch (RemoteException e) {
        // Empty
        }
        Instrumentation.checkStartActivityResult(result, intent);
        if (requestCode >= 0) {
            // If this start is requesting a result, we can avoid making
            // the activity visible until the result is received.  Setting
            // this code during onCreate(Bundle savedInstanceState) or onResume() will keep the
            // activity hidden during this time, to avoid flickering.
            // This can only be done when a result is requested because
            // that guarantees we will get information back when the
            // activity is finished, no matter what happens to it.
            mStartedActivity = true;
        }
        return result != ActivityManager.START_RETURN_INTENT_TO_CALLER;
    }
    throw new UnsupportedOperationException(""startActivityIfNeeded can only be called from a top-level activity"");
}",1,"/**
 * A special variation to launch an activity only if a new activity
 * instance is needed to handle the given Intent.  In other words, this is
 * just like {@link #startActivityForResult(Intent, int)} except: if you are
 * using the {@link Intent#FLAG_ACTIVITY_SINGLE_TOP} flag, or
 * singleTask or singleTop
 * {@link android.R.styleable#AndroidManifestActivity_launchMode launchMode},
 * and the activity
 * that handles <var>intent</var> is the same as your currently running
 * activity, then a new instance is not needed.  In this case, instead of
 * the normal behavior of calling {@link #onNewIntent} this function will
 * return and you can handle the Intent yourself.
 *
 * <p>This function can only be called from a top-level activity; if it is
 * called from a child activity, a runtime exception will be thrown.
 *
 * @param intent The intent to start.
 * @param requestCode If >= 0, this code will be returned in
 * onActivityResult() when the activity exits, as described in
 * {@link #startActivityForResult}.
 * @param options Additional options for how the Activity should be started.
 * See {@link android.content.Context#startActivity(Intent, Bundle)
 * Context.startActivity(Intent, Bundle)} for more details.
 *
 * @return If a new activity was launched then true is returned; otherwise
 * false is returned and you must handle the Intent yourself.
 *
 * @see #startActivity
 * @see #startActivityForResult
 */
","/**
 * A special variation to launch an activity only if a new activity
 * instance is needed to handle the given Intent.  In other words, this is
 * just like {@link #startActivityForResult(Intent, int)} except: if you are
 * using the {@link Intent#FLAG_ACTIVITY_SINGLE_TOP} flag, or
 * singleTask or singleTop
 * {@link android.R.styleable#AndroidManifestActivity_launchMode launchMode},
 * and the activity
 * that handles <var>intent</var> is the same as your currently running
 * activity, then a new instance is not needed.  In this case, instead of
 * the normal behavior of calling {@link #onNewIntent} this function will
 * return and you can handle the Intent yourself.
 *
 * <p>This function can only be called from a top-level activity; if it is
 * called from a child activity, a runtime exception will be thrown.
 *
 * @param intent The intent to start.
 * @param requestCode If >= 0, this code will be returned in
 * onActivityResult() when the activity exits, as described in
 * {@link #startActivityForResult}.
 * @param options Additional options for how the Activity should be started.
 * See {@link android.content.Context#startActivity(Intent, Bundle)
 * Context.startActivity(Intent, Bundle)} for more details.
 *
 * @return If a new activity was launched then true is returned; otherwise
 * false is returned and you must handle the Intent yourself.
 *
 * @see #startActivity
 * @see #startActivityForResult
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code change consists only of adding a block that sets a referrer in the given intent. No return or exception handling statements are changed, and no dependency on another API is modified, so the change type is 4.","The change should not cause any compatibility issues as it does not affect the return type or the exceptions thrown by the method. It simply adds additional information to the intent. If the extra data added to the intent has no impact on the method's contract regarding return value or exceptions, there's no compatibility issue, thus the CI type is 0."
130,<android.hardware.camera2.params.StreamConfigurationMap: boolean isOutputSupportedFor(int)>,22,23,<android.hardware.camera2.params.StreamConfigurationMap: boolean isOutputSupportedFor(int)>,<android.hardware.camera2.params.StreamConfigurationMap: boolean isOutputSupportedFor(int)>,0,"{
    checkArgumentFormat(format);
    format = imageFormatToInternal(format);
    return getFormatsMap(/*output*/
    true).containsKey(format);
}","{
    checkArgumentFormat(format);
    int internalFormat = imageFormatToInternal(format);
    int dataspace = imageFormatToDataspace(format);
    if (dataspace == HAL_DATASPACE_DEPTH) {
        return mDepthOutputFormats.indexOfKey(internalFormat) >= 0;
    } else {
        return getFormatsMap(/*output*/
        true).indexOfKey(internalFormat) >= 0;
    }
}",1,"/**
 * Determine whether or not output surfaces with a particular user-defined format can be passed
 * {@link CameraDevice#createCaptureSession createCaptureSession}.
 *
 * <p>This method determines that the output {@code format} is supported by the camera device;
 * each output {@code surface} target may or may not itself support that {@code format}.
 * Refer to the class which provides the surface for additional documentation.</p>
 *
 * <p>Formats for which this returns {@code true} are guaranteed to exist in the result
 * returned by {@link #getOutputSizes}.</p>
 *
 * @param format an image format from either {@link ImageFormat} or {@link PixelFormat}
 * @return
 * {@code true} iff using a {@code surface} with this {@code format} will be
 * supported with {@link CameraDevice#createCaptureSession}
 *
 * @throws IllegalArgumentException
 * if the image format was not a defined named constant
 * from either {@link ImageFormat} or {@link PixelFormat}
 *
 * @see ImageFormat
 * @see PixelFormat
 * @see CameraDevice#createCaptureSession
 */
","/**
 * Determine whether or not output surfaces with a particular user-defined format can be passed
 * {@link CameraDevice#createCaptureSession createCaptureSession}.
 *
 * <p>This method determines that the output {@code format} is supported by the camera device;
 * each output {@code surface} target may or may not itself support that {@code format}.
 * Refer to the class which provides the surface for additional documentation.</p>
 *
 * <p>Formats for which this returns {@code true} are guaranteed to exist in the result
 * returned by {@link #getOutputSizes}.</p>
 *
 * @param format an image format from either {@link ImageFormat} or {@link PixelFormat}
 * @return
 * {@code true} iff using a {@code surface} with this {@code format} will be
 * supported with {@link CameraDevice#createCaptureSession}
 *
 * @throws IllegalArgumentException
 * if the image format was not a defined named constant
 * from either {@link ImageFormat} or {@link PixelFormat}
 *
 * @see ImageFormat
 * @see PixelFormat
 * @see CameraDevice#createCaptureSession
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",1,"The late version introduces new local variables and new control dependency with additional conditional logic, as well as a change in how the return value is determined given the newly introduced variable 'dataspace' from the function 'imageFormatToDataspace(format)'. A check on 'dataspace' has been added to make a decision on which map to search for 'internalFormat', changing the source of the returned boolean value. The type of the variable 'format' has also been modified to be 'internalFormat' after the method 'imageFormatToInternal(format)'. So, this constitutes changes in control dependency, other statements, and dependent API change, hence the classifications 3, 4, 5.","The modification introduces a new branch that checks a newly introduced variable 'dataspace', which could potentially lead to a different output than the early version for the same 'format' input value if that format's dataspace is recognized as 'HAL_DATASPACE_DEPTH'. This means there could be a difference in behavior if 'HAL_DATASPACE_DEPTH' is involved, which could lead to a change in the returned value, hence a CI type of 1."
131,<android.widget.CalendarViewMaterialDelegate: int getWeekDayTextAppearance()>,22,23,<android.widget.CalendarViewMaterialDelegate: int getWeekDayTextAppearance()>,<android.widget.CalendarViewMaterialDelegate: int getWeekDayTextAppearance()>,0,"{
    return 0;
}","{
    return mDayPickerView.getDayOfWeekTextAppearance();
}",1,,,-1,[@Override],"[@StyleRes, @Override]",-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation of the method has changed from a constant return value to returning the result of a different method, and there's a change in the use of a dependent API (mDayPickerView.getDayOfWeekTextAppearance()), thus the change type is 1,5.","Since the return value of the method is now dependent on the result of another method call rather than a constant, the method could return a different value than before. This introduces a Compatibility Issue of type 1 (potential different return values)."
132,<android.print.PrinterCapabilitiesInfo: PrintAttributes getDefaults()>,22,23,<android.print.PrinterCapabilitiesInfo: PrintAttributes getDefaults()>,<android.print.PrinterCapabilitiesInfo: PrintAttributes getDefaults()>,0,"{
    PrintAttributes.Builder builder = new PrintAttributes.Builder();
    builder.setMinMargins(mMinMargins);
    final int mediaSizeIndex = mDefaults[PROPERTY_MEDIA_SIZE];
    if (mediaSizeIndex >= 0) {
        builder.setMediaSize(mMediaSizes.get(mediaSizeIndex));
    }
    final int resolutionIndex = mDefaults[PROPERTY_RESOLUTION];
    if (resolutionIndex >= 0) {
        builder.setResolution(mResolutions.get(resolutionIndex));
    }
    final int colorMode = mDefaults[PROPERTY_COLOR_MODE];
    if (colorMode > 0) {
        builder.setColorMode(colorMode);
    }
    return builder.build();
}","{
    PrintAttributes.Builder builder = new PrintAttributes.Builder();
    builder.setMinMargins(mMinMargins);
    final int mediaSizeIndex = mDefaults[PROPERTY_MEDIA_SIZE];
    if (mediaSizeIndex >= 0) {
        builder.setMediaSize(mMediaSizes.get(mediaSizeIndex));
    }
    final int resolutionIndex = mDefaults[PROPERTY_RESOLUTION];
    if (resolutionIndex >= 0) {
        builder.setResolution(mResolutions.get(resolutionIndex));
    }
    final int colorMode = mDefaults[PROPERTY_COLOR_MODE];
    if (colorMode > 0) {
        builder.setColorMode(colorMode);
    }
    final int duplexMode = mDefaults[PROPERTY_DUPLEX_MODE];
    if (duplexMode > 0) {
        builder.setDuplexMode(duplexMode);
    }
    return builder.build();
}",1,"/**
 * Gets the default print attributes.
 *
 * @return The default attributes.
 */
","/**
 * Gets the default print attributes.
 *
 * @return The default attributes.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"New statements have been added to set the duplex mode in the builder, thus the change type is 4 (Other statement changed).","The changes in the code only add additional information to the `PrintAttributes` being built. There is no change in the return type, nor is there a change in the behavior of existing code paths which would cause a previously working invocation of the method to fail or behave differently. Therefore, there is no Compatibility Issue; the pred_CI is 0."
134,<android.gesture.GestureUtils: float computeTotalLength(float[])>,22,23,<android.gesture.GestureUtils: float computeTotalLength(float[])>,<android.gesture.GestureUtils: float computeTotalLength(float[])>,0,"{
    float sum = 0;
    int count = points.length - 4;
    for (int i = 0; i < count; i += 2) {
        float dx = points[i + 2] - points[i];
        float dy = points[i + 3] - points[i + 1];
        sum += Math.sqrt(dx * dx + dy * dy);
    }
    return sum;
}","{
    float sum = 0;
    int count = points.length - 4;
    for (int i = 0; i < count; i += 2) {
        float dx = points[i + 2] - points[i];
        float dy = points[i + 3] - points[i + 1];
        sum += Math.hypot(dx, dy);
    }
    return sum;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change is the mathematical function used to calculate the distance from Math.sqrt(dx * dx + dy * dy) to Math.hypot(dx, dy), which is an implementation detail that doesn't affect the method contract or expected behavior, hence the change type is 4.","The implementation detail changed (Math.sqrt to Math.hypot) does not result in any incompatibilities since both functions are intended to calculate the Euclidean distance which would return the same result given the same parameters. Thus, there is no compatibility issue, and the CI type is 0."
136,"<android.app.ContextImpl: void sendStickyOrderedBroadcast(Intent,BroadcastReceiver,Handler,int,String,Bundle)>",22,23,"<android.app.ContextImpl: void sendStickyOrderedBroadcast(Intent,BroadcastReceiver,Handler,int,String,Bundle)>","<android.app.ContextImpl: void sendStickyOrderedBroadcast(Intent,BroadcastReceiver,Handler,int,String,Bundle)>",0,"{
    warnIfCallingFromSystemProcess();
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess();
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, rd, initialCode, initialData, initialExtras, null, AppOpsManager.OP_NONE, true, true, getUserId());
    } catch (RemoteException e) {
    }
}","{
    warnIfCallingFromSystemProcess();
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess();
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, rd, initialCode, initialData, initialExtras, null, AppOpsManager.OP_NONE, null, true, true, getUserId());
    } catch (RemoteException e) {
        throw new RuntimeException(""Failure from system"", e);
    }
}",1,,,-1,[@Override],"[@Override, @Deprecated]",-1,-1,-1,-1,-1,-1,"2,4",2,"The exception handling statement has changed by adding a throw new RuntimeException(""Failure from system"", e); and the method call to ActivityManagerNative.getDefault().broadcastIntent() contains a change in arguments with null replacing true. This is an 'Other statement changed' since it involves a change in the method's argument list, and also 'Exception handling statement changed' due to the addition of the new throw statement.","The addition of throw new RuntimeException(""Failure from system"", e); where previously there was an empty catch block introduces a new exception-throwing behavior, which is a Compatibility Issue caused by potential different exception handlings (CI type 2). The change in the broadcastIntent call's arguments may or may not introduce compatibility issues depending on the implementation of the method, but there is no indication of a different value or type being returned, so CI type 1 does not apply."
138,"<android.provider.ContactsContract.Contacts: Uri getLookupUri(long,String)>",22,23,"<android.provider.ContactsContract.Contacts: Uri getLookupUri(long,String)>","<android.provider.ContactsContract.Contacts: Uri getLookupUri(long,String)>",0,"{
    return ContentUris.withAppendedId(Uri.withAppendedPath(Contacts.CONTENT_LOOKUP_URI, lookupKey), contactId);
}","{
    if (TextUtils.isEmpty(lookupKey)) {
        return null;
    }
    return ContentUris.withAppendedId(Uri.withAppendedPath(Contacts.CONTENT_LOOKUP_URI, lookupKey), contactId);
}",1,"/**
 * Build a {@link #CONTENT_LOOKUP_URI} lookup {@link Uri} using the
 * given {@link ContactsContract.Contacts#_ID} and {@link #LOOKUP_KEY}.
 */
","/**
 * Build a {@link #CONTENT_LOOKUP_URI} lookup {@link Uri} using the
 * given {@link ContactsContract.Contacts#_ID} and {@link #LOOKUP_KEY}.
 * <p>
 * Returns null if unable to construct a valid lookup URI from the
 * provided parameters.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"A new control dependency 'if (TextUtils.isEmpty(lookupKey))' has been added which can return 'null' along with a 'return null' statement, so there is a change in the control dependency and return statement, which is classified as 1,3.","The introduction of a new condition that checks if 'lookupKey' is empty can lead to a different return value ('null' instead of a Uri), so there is a potential Compatibility Issue due to different return values, which is classified as 1."
144,"<android.accounts.AccountManager: void setUserData(Account,String,String)>",22,23,"<android.accounts.AccountManager: void setUserData(Account,String,String)>","<android.accounts.AccountManager: void setUserData(Account,String,String)>",0,"{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    if (key == null)
        throw new IllegalArgumentException(""key is null"");
    try {
        mService.setUserData(account, key, value);
    } catch (RemoteException e) {
        // won't ever happen
        throw new RuntimeException(e);
    }
}","{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    if (key == null)
        throw new IllegalArgumentException(""key is null"");
    try {
        mService.setUserData(account, key, value);
    } catch (RemoteException e) {
        // Will happen if there is not signature match.
        throw new RuntimeException(e);
    }
}",1,"/**
 * Sets one userdata key for an account.  Intended by use for the
 * authenticator to stash state for itself, not directly by applications.
 * The meaning of the keys and values is up to the authenticator.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#AUTHENTICATE_ACCOUNTS}
 * and to have the same UID as the account's authenticator.
 *
 * @param account The account to set the userdata for
 * @param key The userdata key to set.  Must not be null
 * @param value The value to set, null to clear this userdata key
 */
","/**
 * Sets one userdata key for an account.  Intended by use for the
 * authenticator to stash state for itself, not directly by applications.
 * The meaning of the keys and values is up to the authenticator.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>This method requires the caller to have a signature match with the
 * authenticator that manages the specified account.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * AUTHENTICATE_ACCOUNTS permission and same UID as account's authenticator
 * is needed for those platforms. See docs for this function in API level 22.
 *
 * @param account Account whose user data is to be set. Must not be {@code null}.
 * @param key String user data key to set.  Must not be null
 * @param value String value to set, {@code null} to clear this user data key
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change between the two versions is the comment within the catch block, which does not affect the program's logic or behavior, so the code change type is 4.","Since there is no alteration in the actual executable code but just in the comments, there is no Compatibility Issue, thus CI type is 0."
145,<android.app.Activity: FragmentManager getFragmentManager()>,22,23,<android.app.Activity: FragmentManager getFragmentManager()>,<android.app.Activity: FragmentManager getFragmentManager()>,0,"{
    return mFragments;
}","{
    return mFragments.getFragmentManager();
}",1,"/**
 * Return the FragmentManager for interacting with fragments associated
 * with this activity.
 */
","/**
 * Return the FragmentManager for interacting with fragments associated
 * with this activity.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,The implementation of the getFragmentManager() method has changed from returning `mFragments` directly to calling and returning `mFragments.getFragmentManager()`. This indicates that there is a dependent API change.,"Since the implementation now relies on the `getFragmentManager()` method from `mFragments`, if that method has different behavior or returns a different instance of `FragmentManager`, it could lead to a different return value in the late version, which would be a compatibility issue. Therefore, the CI type is 1."
147,<android.content.ContentResolver: String getType(Uri)>,22,23,<android.content.ContentResolver: String getType(Uri)>,<android.content.ContentResolver: String getType(Uri)>,0,"{
    // XXX would like to have an acquireExistingUnstableProvider for this.
    IContentProvider provider = acquireExistingProvider(url);
    if (provider != null) {
        try {
            return provider.getType(url);
        } catch (RemoteException e) {
            return null;
        } catch (java.lang.Exception e) {
            Log.w(TAG, ""Failed to get type for: "" + url + "" ("" + e.getMessage() + "")"");
            return null;
        } finally {
            releaseProvider(provider);
        }
    }
    if (!SCHEME_CONTENT.equals(url.getScheme())) {
        return null;
    }
    try {
        String type = ActivityManagerNative.getDefault().getProviderMimeType(ContentProvider.getUriWithoutUserId(url), resolveUserId(url));
        return type;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } catch (java.lang.Exception e) {
        Log.w(TAG, ""Failed to get type for: "" + url + "" ("" + e.getMessage() + "")"");
        return null;
    }
}","{
    Preconditions.checkNotNull(url, ""url"");
    // XXX would like to have an acquireExistingUnstableProvider for this.
    IContentProvider provider = acquireExistingProvider(url);
    if (provider != null) {
        try {
            return provider.getType(url);
        } catch (RemoteException e) {
            return null;
        } catch (java.lang.Exception e) {
            Log.w(TAG, ""Failed to get type for: "" + url + "" ("" + e.getMessage() + "")"");
            return null;
        } finally {
            releaseProvider(provider);
        }
    }
    if (!SCHEME_CONTENT.equals(url.getScheme())) {
        return null;
    }
    try {
        String type = ActivityManagerNative.getDefault().getProviderMimeType(ContentProvider.getUriWithoutUserId(url), resolveUserId(url));
        return type;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } catch (java.lang.Exception e) {
        Log.w(TAG, ""Failed to get type for: "" + url + "" ("" + e.getMessage() + "")"");
        return null;
    }
}",1,"/**
 * Return the MIME type of the given content URL.
 *
 * @param url A Uri identifying content (either a list or specific type),
 * using the content:// scheme.
 * @return A MIME type for the content, or null if the URL is invalid or the type is unknown
 */
","/**
 * Return the MIME type of the given content URL.
 *
 * @param url A Uri identifying content (either a list or specific type),
 * using the content:// scheme.
 * @return A MIME type for the content, or null if the URL is invalid or the type is unknown
 */
",-1,,[@Nullable],-1,-1,-1,-1,-1,-1,4,0,"An input validation check for the 'url' parameter has been added with Preconditions.checkNotNull(url, ""url""). This change does not affect the return value or the exceptions thrown by the method since it will throw a runtime exception (NullPointerException) if the supplied 'url' is null before any other logic is executed. Therefore, it's classified as 4.","There's no Compatibility Issue here because if the 'url' was null in the early version, it would lead to a NullPointerException when 'url.getScheme()' is called. The added precondition check just makes this behavior explicit and fails fast. This early failure does not represent a change in the API's behavior regarding the values it returns or the exceptions it throws, as null input would lead to an exception in both versions."
149,<android.webkit.WebView: WebBackForwardList saveState(Bundle)>,22,23,<android.webkit.WebView: WebBackForwardList saveState(Bundle)>,<android.webkit.WebView: WebBackForwardList saveState(Bundle)>,0,"{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, ""saveState"");
    return mProvider.saveState(outState);
}","{
    checkThread();
    return mProvider.saveState(outState);
}",1,"/**
 * Saves the state of this WebView used in
 * {@link android.app.Activity#onSaveInstanceState}. Please note that this
 * method no longer stores the display data for this WebView. The previous
 * behavior could potentially leak files if {@link #restoreState} was never
 * called.
 *
 * @param outState the Bundle to store this WebView's state
 * @return the same copy of the back/forward list used to save the state. If
 * saveState fails, the returned list will be null.
 */
","/**
 * Saves the state of this WebView used in
 * {@link android.app.Activity#onSaveInstanceState}. Please note that this
 * method no longer stores the display data for this WebView. The previous
 * behavior could potentially leak files if {@link #restoreState} was never
 * called.
 *
 * @param outState the Bundle to store this WebView's state
 * @return the same copy of the back/forward list used to save the state. If
 * saveState fails, the returned list will be null.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change between the versions is the removal of the logging statement (if (TRACE) Log.d(LOGTAG, ""saveState"");), which does not affect the API's behavior, so the code change type is 4.","The removal of a logging statement will not lead to any compatibility issues since it does not affect the API's output or behavior; therefore, there is no compatibility issue, and the CI type is 0."
151,<android.view.View: int[] onCreateDrawableState(int)>,22,23,<android.view.View: int[] onCreateDrawableState(int)>,<android.view.View: int[] onCreateDrawableState(int)>,0,"{
    if ((mViewFlags & DUPLICATE_PARENT_STATE) == DUPLICATE_PARENT_STATE && mParent instanceof View) {
        return ((View) mParent).onCreateDrawableState(extraSpace);
    }
    int[] drawableState;
    int privateFlags = mPrivateFlags;
    int viewStateIndex = 0;
    if ((privateFlags & PFLAG_PRESSED) != 0)
        viewStateIndex |= VIEW_STATE_PRESSED;
    if ((mViewFlags & ENABLED_MASK) == ENABLED)
        viewStateIndex |= VIEW_STATE_ENABLED;
    if (isFocused())
        viewStateIndex |= VIEW_STATE_FOCUSED;
    if ((privateFlags & PFLAG_SELECTED) != 0)
        viewStateIndex |= VIEW_STATE_SELECTED;
    if (hasWindowFocus())
        viewStateIndex |= VIEW_STATE_WINDOW_FOCUSED;
    if ((privateFlags & PFLAG_ACTIVATED) != 0)
        viewStateIndex |= VIEW_STATE_ACTIVATED;
    if (mAttachInfo != null && mAttachInfo.mHardwareAccelerationRequested && HardwareRenderer.isAvailable()) {
        // This is set if HW acceleration is requested, even if the current
        // process doesn't allow it.  This is just to allow app preview
        // windows to better match their app.
        viewStateIndex |= VIEW_STATE_ACCELERATED;
    }
    if ((privateFlags & PFLAG_HOVERED) != 0)
        viewStateIndex |= VIEW_STATE_HOVERED;
    final int privateFlags2 = mPrivateFlags2;
    if ((privateFlags2 & PFLAG2_DRAG_CAN_ACCEPT) != 0)
        viewStateIndex |= VIEW_STATE_DRAG_CAN_ACCEPT;
    if ((privateFlags2 & PFLAG2_DRAG_HOVERED) != 0)
        viewStateIndex |= VIEW_STATE_DRAG_HOVERED;
    drawableState = VIEW_STATE_SETS[viewStateIndex];
    // noinspection ConstantIfStatement
    if (false) {
        Log.i(""View"", ""drawableStateIndex="" + viewStateIndex);
        Log.i(""View"", toString() + "" pressed="" + ((privateFlags & PFLAG_PRESSED) != 0) + "" en="" + ((mViewFlags & ENABLED_MASK) == ENABLED) + "" fo="" + hasFocus() + "" sl="" + ((privateFlags & PFLAG_SELECTED) != 0) + "" wf="" + hasWindowFocus() + "": "" + Arrays.toString(drawableState));
    }
    if (extraSpace == 0) {
        return drawableState;
    }
    final int[] fullState;
    if (drawableState != null) {
        fullState = new int[drawableState.length + extraSpace];
        System.arraycopy(drawableState, 0, fullState, 0, drawableState.length);
    } else {
        fullState = new int[extraSpace];
    }
    return fullState;
}","{
    if ((mViewFlags & DUPLICATE_PARENT_STATE) == DUPLICATE_PARENT_STATE && mParent instanceof View) {
        return ((View) mParent).onCreateDrawableState(extraSpace);
    }
    int[] drawableState;
    int privateFlags = mPrivateFlags;
    int viewStateIndex = 0;
    if ((privateFlags & PFLAG_PRESSED) != 0)
        viewStateIndex |= StateSet.VIEW_STATE_PRESSED;
    if ((mViewFlags & ENABLED_MASK) == ENABLED)
        viewStateIndex |= StateSet.VIEW_STATE_ENABLED;
    if (isFocused())
        viewStateIndex |= StateSet.VIEW_STATE_FOCUSED;
    if ((privateFlags & PFLAG_SELECTED) != 0)
        viewStateIndex |= StateSet.VIEW_STATE_SELECTED;
    if (hasWindowFocus())
        viewStateIndex |= StateSet.VIEW_STATE_WINDOW_FOCUSED;
    if ((privateFlags & PFLAG_ACTIVATED) != 0)
        viewStateIndex |= StateSet.VIEW_STATE_ACTIVATED;
    if (mAttachInfo != null && mAttachInfo.mHardwareAccelerationRequested && HardwareRenderer.isAvailable()) {
        // This is set if HW acceleration is requested, even if the current
        // process doesn't allow it.  This is just to allow app preview
        // windows to better match their app.
        viewStateIndex |= StateSet.VIEW_STATE_ACCELERATED;
    }
    if ((privateFlags & PFLAG_HOVERED) != 0)
        viewStateIndex |= StateSet.VIEW_STATE_HOVERED;
    final int privateFlags2 = mPrivateFlags2;
    if ((privateFlags2 & PFLAG2_DRAG_CAN_ACCEPT) != 0) {
        viewStateIndex |= StateSet.VIEW_STATE_DRAG_CAN_ACCEPT;
    }
    if ((privateFlags2 & PFLAG2_DRAG_HOVERED) != 0) {
        viewStateIndex |= StateSet.VIEW_STATE_DRAG_HOVERED;
    }
    drawableState = StateSet.get(viewStateIndex);
    // noinspection ConstantIfStatement
    if (false) {
        Log.i(""View"", ""drawableStateIndex="" + viewStateIndex);
        Log.i(""View"", toString() + "" pressed="" + ((privateFlags & PFLAG_PRESSED) != 0) + "" en="" + ((mViewFlags & ENABLED_MASK) == ENABLED) + "" fo="" + hasFocus() + "" sl="" + ((privateFlags & PFLAG_SELECTED) != 0) + "" wf="" + hasWindowFocus() + "": "" + Arrays.toString(drawableState));
    }
    if (extraSpace == 0) {
        return drawableState;
    }
    final int[] fullState;
    if (drawableState != null) {
        fullState = new int[drawableState.length + extraSpace];
        System.arraycopy(drawableState, 0, fullState, 0, drawableState.length);
    } else {
        fullState = new int[extraSpace];
    }
    return fullState;
}",1,"/**
 * Generate the new {@link android.graphics.drawable.Drawable} state for
 * this view. This is called by the view
 * system when the cached Drawable state is determined to be invalid.  To
 * retrieve the current state, you should use {@link #getDrawableState}.
 *
 * @param extraSpace if non-zero, this is the number of extra entries you
 * would like in the returned array in which you can place your own
 * states.
 *
 * @return Returns an array holding the current {@link Drawable} state of
 * the view.
 *
 * @see #mergeDrawableStates(int[], int[])
 */
","/**
 * Generate the new {@link android.graphics.drawable.Drawable} state for
 * this view. This is called by the view
 * system when the cached Drawable state is determined to be invalid.  To
 * retrieve the current state, you should use {@link #getDrawableState}.
 *
 * @param extraSpace if non-zero, this is the number of extra entries you
 * would like in the returned array in which you can place your own
 * states.
 *
 * @return Returns an array holding the current {@link Drawable} state of
 * the view.
 *
 * @see #mergeDrawableStates(int[], int[])
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
155,<android.net.http.HttpResponseCache: HttpResponseCache getInstalled()>,22,23,<android.net.http.HttpResponseCache: HttpResponseCache getInstalled()>,<android.net.http.HttpResponseCache: HttpResponseCache getInstalled()>,0,"{
    ResponseCache installed = ResponseCache.getDefault();
    if (installed instanceof com.android.okhttp.HttpResponseCache) {
        return new HttpResponseCache((com.android.okhttp.HttpResponseCache) installed);
    }
    return null;
}","{
    ResponseCache installed = ResponseCache.getDefault();
    if (installed instanceof HttpResponseCache) {
        return (HttpResponseCache) installed;
    }
    return null;
}",1,"/**
 * Returns the currently-installed {@code HttpResponseCache}, or null if
 * there is no cache installed or it is not a {@code HttpResponseCache}.
 */
","/**
 * Returns the currently-installed {@code HttpResponseCache}, or null if
 * there is no cache installed or it is not a {@code HttpResponseCache}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The casting in the return statement has changed from wrapping the `com.android.okhttp.HttpResponseCache` in a new `HttpResponseCache` object to a direct cast of `installed` to `HttpResponseCache`, and the type checking in the 'if' statement has also changed to check directly against `HttpResponseCache` instead of `com.android.okhttp.HttpResponseCache`, so the code change type is 1,5.","The change in casting could potentially lead to the API returning a different type of object, and the altered type check could determine a different outcome from the `if` condition, which means the CI type is 1."
157,<android.app.LoaderManagerImpl.LoaderInfo: void destroy()>,22,23,<android.app.LoaderManagerImpl.LoaderInfo: void destroy()>,<android.app.LoaderManagerImpl.LoaderInfo: void destroy()>,0,"{
    if (DEBUG)
        Log.v(TAG, ""  Destroying: "" + this);
    mDestroyed = true;
    boolean needReset = mDeliveredData;
    mDeliveredData = false;
    if (mCallbacks != null && mLoader != null && mHaveData && needReset) {
        if (DEBUG)
            Log.v(TAG, ""  Reseting: "" + this);
        String lastBecause = null;
        if (mActivity != null) {
            lastBecause = mActivity.mFragments.mNoTransactionsBecause;
            mActivity.mFragments.mNoTransactionsBecause = ""onLoaderReset"";
        }
        try {
            mCallbacks.onLoaderReset(mLoader);
        } finally {
            if (mActivity != null) {
                mActivity.mFragments.mNoTransactionsBecause = lastBecause;
            }
        }
    }
    mCallbacks = null;
    mData = null;
    mHaveData = false;
    if (mLoader != null) {
        if (mListenerRegistered) {
            mListenerRegistered = false;
            mLoader.unregisterListener(this);
            mLoader.unregisterOnLoadCanceledListener(this);
        }
        mLoader.reset();
    }
    if (mPendingLoader != null) {
        mPendingLoader.destroy();
    }
}","{
    if (DEBUG)
        Log.v(TAG, ""  Destroying: "" + this);
    mDestroyed = true;
    boolean needReset = mDeliveredData;
    mDeliveredData = false;
    if (mCallbacks != null && mLoader != null && mHaveData && needReset) {
        if (DEBUG)
            Log.v(TAG, ""  Reseting: "" + this);
        String lastBecause = null;
        if (mHost != null) {
            lastBecause = mHost.mFragmentManager.mNoTransactionsBecause;
            mHost.mFragmentManager.mNoTransactionsBecause = ""onLoaderReset"";
        }
        try {
            mCallbacks.onLoaderReset(mLoader);
        } finally {
            if (mHost != null) {
                mHost.mFragmentManager.mNoTransactionsBecause = lastBecause;
            }
        }
    }
    mCallbacks = null;
    mData = null;
    mHaveData = false;
    if (mLoader != null) {
        if (mListenerRegistered) {
            mListenerRegistered = false;
            mLoader.unregisterListener(this);
            mLoader.unregisterOnLoadCanceledListener(this);
        }
        mLoader.reset();
    }
    if (mPendingLoader != null) {
        mPendingLoader.destroy();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The variable `mActivity` is replaced with `mHost`, and accordingly, `mActivity.mFragments` is replaced with `mHost.mFragmentManager`. However, this is not affecting the flow of control, exception handling, or return statements. Therefore, the change type is 4, which is an ""Other statement changed"".","There should not be a Compatibility Issue caused by the replacement of the variable `mActivity` with `mHost` as it looks like a simple renaming of a variable and its associated field, which presumably represents the same concept in the context of the Android framework. There is no indication of changes in object behavior, new or removed functionalities, or different interactions that could lead to a change in the return value or the exceptions thrown by the method. Thus, it is reasonable to assume that there is no Compatibility Issue."
159,"<android.appwidget.AppWidgetHost.Callbacks: void providerChanged(int,AppWidgetProviderInfo)>",22,23,"<android.appwidget.AppWidgetHost.Callbacks: void providerChanged(int,AppWidgetProviderInfo)>","<android.appwidget.AppWidgetHost.Callbacks: void providerChanged(int,AppWidgetProviderInfo)>",0,"{
    if (isLocalBinder() && info != null) {
        info = info.clone();
    }
    Message msg = mHandler.obtainMessage(HANDLE_PROVIDER_CHANGED, appWidgetId, 0, info);
    msg.sendToTarget();
}","{
    if (isLocalBinder() && info != null) {
        info = info.clone();
    }
    Handler handler = mWeakHandler.get();
    if (handler == null) {
        return;
    }
    Message msg = handler.obtainMessage(HANDLE_PROVIDER_CHANGED, appWidgetId, 0, info);
    msg.sendToTarget();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The addition of a new variable `handler` and a null check introduces changes in the control flow and other statements (initializing a variable and using it to send message), so the code change types are 3 and 4.","The change in the method introduces an additional null check, which does not affect the behavior of the method in terms of returning different values or throwing different exceptions, as the method is void. Thus, despite this change, we do not expect a change in behavior that would lead to a compatibility issue, so the CI type is 0."
160,<android.view.View: Parcelable onSaveInstanceState()>,22,23,<android.view.View: Parcelable onSaveInstanceState()>,<android.view.View: Parcelable onSaveInstanceState()>,0,"{
    mPrivateFlags |= PFLAG_SAVE_STATE_CALLED;
    return BaseSavedState.EMPTY_STATE;
}","{
    mPrivateFlags |= PFLAG_SAVE_STATE_CALLED;
    if (mStartActivityRequestWho != null) {
        BaseSavedState state = new BaseSavedState(AbsSavedState.EMPTY_STATE);
        state.mStartActivityRequestWhoSaved = mStartActivityRequestWho;
        return state;
    }
    return BaseSavedState.EMPTY_STATE;
}",1,"/**
 * Hook allowing a view to generate a representation of its internal state
 * that can later be used to create a new instance with that same state.
 * This state should only contain information that is not persistent or can
 * not be reconstructed later. For example, you will never store your
 * current position on screen because that will be computed again when a
 * new instance of the view is placed in its view hierarchy.
 * <p>
 * Some examples of things you may store here: the current cursor position
 * in a text view (but usually not the text itself since that is stored in a
 * content provider or other persistent storage), the currently selected
 * item in a list view.
 *
 * @return Returns a Parcelable object containing the view's current dynamic
 * state, or null if there is nothing interesting to save. The
 * default implementation returns null.
 * @see #onRestoreInstanceState(android.os.Parcelable)
 * @see #saveHierarchyState(android.util.SparseArray)
 * @see #dispatchSaveInstanceState(android.util.SparseArray)
 * @see #setSaveEnabled(boolean)
 */
","/**
 * Hook allowing a view to generate a representation of its internal state
 * that can later be used to create a new instance with that same state.
 * This state should only contain information that is not persistent or can
 * not be reconstructed later. For example, you will never store your
 * current position on screen because that will be computed again when a
 * new instance of the view is placed in its view hierarchy.
 * <p>
 * Some examples of things you may store here: the current cursor position
 * in a text view (but usually not the text itself since that is stored in a
 * content provider or other persistent storage), the currently selected
 * item in a list view.
 *
 * @return Returns a Parcelable object containing the view's current dynamic
 * state, or null if there is nothing interesting to save. The
 * default implementation returns null.
 * @see #onRestoreInstanceState(android.os.Parcelable)
 * @see #saveHierarchyState(android.util.SparseArray)
 * @see #dispatchSaveInstanceState(android.util.SparseArray)
 * @see #setSaveEnabled(boolean)
 */
",-1,,[@CallSuper],-1,-1,-1,-1,-1,-1,"1,3",1,"A new control dependency 'if' with the associated block of code has been added, and this involves a new return statement as well. So, the code change is of types 1,3.","The introduction of the new conditional may result in returning a different type of `Parcelable` object (BaseSavedState with additional information set versus the constant BaseSavedState.EMPTY_STATE), so this can potentially lead to different behavior after the change, qualifying as CI type 1."
161,<android.os.StrictMode.VmPolicy.Builder: Builder detectAll()>,22,23,<android.os.StrictMode.VmPolicy.Builder: Builder detectAll()>,<android.os.StrictMode.VmPolicy.Builder: Builder detectAll()>,0,"{
    return enable(DETECT_VM_ACTIVITY_LEAKS | DETECT_VM_CURSOR_LEAKS | DETECT_VM_CLOSABLE_LEAKS | DETECT_VM_REGISTRATION_LEAKS | DETECT_VM_FILE_URI_EXPOSURE);
}","{
    int flags = DETECT_VM_ACTIVITY_LEAKS | DETECT_VM_CURSOR_LEAKS | DETECT_VM_CLOSABLE_LEAKS | DETECT_VM_REGISTRATION_LEAKS | DETECT_VM_FILE_URI_EXPOSURE;
    // for apps to mark sockets that should be ignored
    if (SystemProperties.getBoolean(CLEARTEXT_PROPERTY, false)) {
        flags |= DETECT_VM_CLEARTEXT_NETWORK;
    }
    return enable(flags);
}",1,"/**
 * Detect everything that's potentially suspect.
 *
 * <p>In the Honeycomb release this includes leaks of
 * SQLite cursors, Activities, and other closable objects
 * but will likely expand in future releases.
 */
","/**
 * Detect everything that's potentially suspect.
 *
 * <p>In the Honeycomb release this includes leaks of
 * SQLite cursors, Activities, and other closable objects
 * but will likely expand in future releases.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The late version of the method has introduced a new block of code to conditionally enable an additional detection flag (DETECT_VM_CLEARTEXT_NETWORK) based on a system property. This results in a change of the control dependency because of the newly added 'if' condition, and consequently, modifies the flags to pass to the enable method. This is why the changes are classified as types 1 and 3.","Because the enabling of DETECT_VM_CLEARTEXT_NETWORK is conditional, dependent on the result of SystemProperties.getBoolean(CLEARTEXT_PROPERTY, false), there is a potential for the late version of the API to return a different set of flags than the early version. This potential difference in behavior means that the CI type is 1."
162,<android.view.accessibility.AccessibilityNodeInfo: String toString()>,22,23,<android.view.accessibility.AccessibilityNodeInfo: String toString()>,<android.view.accessibility.AccessibilityNodeInfo: String toString()>,0,"{
    StringBuilder builder = new StringBuilder();
    builder.append(super.toString());
    if (DEBUG) {
        builder.append(""; sourceNodeId: "" + mSourceNodeId);
        builder.append(""; accessibilityViewId: "" + getAccessibilityViewId(mSourceNodeId));
        builder.append(""; virtualDescendantId: "" + getVirtualDescendantId(mSourceNodeId));
        builder.append(""; mParentNodeId: "" + mParentNodeId);
        builder.append(""; traversalBefore: "").append(mTraversalBefore);
        builder.append(""; traversalAfter: "").append(mTraversalAfter);
        int granularities = mMovementGranularities;
        builder.append(""; MovementGranularities: ["");
        while (granularities != 0) {
            final int granularity = 1 << Integer.numberOfTrailingZeros(granularities);
            granularities &= ~granularity;
            builder.append(getMovementGranularitySymbolicName(granularity));
            if (granularities != 0) {
                builder.append("", "");
            }
        }
        builder.append(""]"");
        builder.append(""; childAccessibilityIds: ["");
        final LongArray childIds = mChildNodeIds;
        if (childIds != null) {
            for (int i = 0, count = childIds.size(); i < count; i++) {
                builder.append(childIds.get(i));
                if (i < count - 1) {
                    builder.append("", "");
                }
            }
        }
        builder.append(""]"");
    }
    builder.append(""; boundsInParent: "" + mBoundsInParent);
    builder.append(""; boundsInScreen: "" + mBoundsInScreen);
    builder.append(""; packageName: "").append(mPackageName);
    builder.append(""; className: "").append(mClassName);
    builder.append(""; text: "").append(mText);
    builder.append(""; error: "").append(mError);
    builder.append(""; maxTextLength: "").append(mMaxTextLength);
    builder.append(""; contentDescription: "").append(mContentDescription);
    builder.append(""; viewIdResName: "").append(mViewIdResourceName);
    builder.append(""; checkable: "").append(isCheckable());
    builder.append(""; checked: "").append(isChecked());
    builder.append(""; focusable: "").append(isFocusable());
    builder.append(""; focused: "").append(isFocused());
    builder.append(""; selected: "").append(isSelected());
    builder.append(""; clickable: "").append(isClickable());
    builder.append(""; longClickable: "").append(isLongClickable());
    builder.append(""; enabled: "").append(isEnabled());
    builder.append(""; password: "").append(isPassword());
    builder.append(""; scrollable: "").append(isScrollable());
    builder.append(""; actions: "").append(mActions);
    return builder.toString();
}","{
    StringBuilder builder = new StringBuilder();
    builder.append(super.toString());
    if (DEBUG) {
        builder.append(""; sourceNodeId: "" + mSourceNodeId);
        builder.append(""; accessibilityViewId: "" + getAccessibilityViewId(mSourceNodeId));
        builder.append(""; virtualDescendantId: "" + getVirtualDescendantId(mSourceNodeId));
        builder.append(""; mParentNodeId: "" + mParentNodeId);
        builder.append(""; traversalBefore: "").append(mTraversalBefore);
        builder.append(""; traversalAfter: "").append(mTraversalAfter);
        int granularities = mMovementGranularities;
        builder.append(""; MovementGranularities: ["");
        while (granularities != 0) {
            final int granularity = 1 << Integer.numberOfTrailingZeros(granularities);
            granularities &= ~granularity;
            builder.append(getMovementGranularitySymbolicName(granularity));
            if (granularities != 0) {
                builder.append("", "");
            }
        }
        builder.append(""]"");
        builder.append(""; childAccessibilityIds: ["");
        final LongArray childIds = mChildNodeIds;
        if (childIds != null) {
            for (int i = 0, count = childIds.size(); i < count; i++) {
                builder.append(childIds.get(i));
                if (i < count - 1) {
                    builder.append("", "");
                }
            }
        }
        builder.append(""]"");
    }
    builder.append(""; boundsInParent: "" + mBoundsInParent);
    builder.append(""; boundsInScreen: "" + mBoundsInScreen);
    builder.append(""; packageName: "").append(mPackageName);
    builder.append(""; className: "").append(mClassName);
    builder.append(""; text: "").append(mText);
    builder.append(""; error: "").append(mError);
    builder.append(""; maxTextLength: "").append(mMaxTextLength);
    builder.append(""; contentDescription: "").append(mContentDescription);
    builder.append(""; viewIdResName: "").append(mViewIdResourceName);
    builder.append(""; checkable: "").append(isCheckable());
    builder.append(""; checked: "").append(isChecked());
    builder.append(""; focusable: "").append(isFocusable());
    builder.append(""; focused: "").append(isFocused());
    builder.append(""; selected: "").append(isSelected());
    builder.append(""; clickable: "").append(isClickable());
    builder.append(""; longClickable: "").append(isLongClickable());
    builder.append(""; contextClickable: "").append(isContextClickable());
    builder.append(""; enabled: "").append(isEnabled());
    builder.append(""; password: "").append(isPassword());
    builder.append(""; scrollable: "").append(isScrollable());
    builder.append(""; actions: "").append(mActions);
    return builder.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
163,"<android.transition.Explode: Animator onAppear(ViewGroup,View,TransitionValues,TransitionValues)>",22,23,"<android.transition.Explode: Animator onAppear(ViewGroup,View,TransitionValues,TransitionValues)>","<android.transition.Explode: Animator onAppear(ViewGroup,View,TransitionValues,TransitionValues)>",0,"{
    if (endValues == null) {
        return null;
    }
    Rect bounds = (Rect) endValues.values.get(PROPNAME_SCREEN_BOUNDS);
    float endX = view.getTranslationX();
    float endY = view.getTranslationY();
    calculateOut(sceneRoot, bounds, mTempLoc);
    float startX = endX + mTempLoc[0];
    float startY = endY + mTempLoc[1];
    return TranslationAnimationCreator.createAnimation(view, endValues, bounds.left, bounds.top, startX, startY, endX, endY, sDecelerate);
}","{
    if (endValues == null) {
        return null;
    }
    Rect bounds = (Rect) endValues.values.get(PROPNAME_SCREEN_BOUNDS);
    float endX = view.getTranslationX();
    float endY = view.getTranslationY();
    calculateOut(sceneRoot, bounds, mTempLoc);
    float startX = endX + mTempLoc[0];
    float startY = endY + mTempLoc[1];
    return TranslationAnimationCreator.createAnimation(view, endValues, bounds.left, bounds.top, startX, startY, endX, endY, sDecelerate, this);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"There is an additional parameter 'this' added to the method call of TranslationAnimationCreator.createAnimation in the late version, so the code change type is 4.","The addition of 'this' as a parameter to the createAnimation method does not by itself indicate a change in the behavior of how exceptions are thrown or how values are returned. Since the method signature and return type stays the same and the extra parameter does not affect the existing behavior in a way that would cause an incompatibility issue (assuming the method is correctly handling the extra parameter), there is no compatibility issue caused by this change. Therefore, the CI type is 0."
164,"<android.app.ContextImpl: void sendBroadcastAsUser(Intent,UserHandle,String)>",22,23,"<android.app.ContextImpl: void sendBroadcastAsUser(Intent,UserHandle,String)>","<android.app.ContextImpl: void sendBroadcastAsUser(Intent,UserHandle,String)>",0,"{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess();
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermission, AppOpsManager.OP_NONE, false, false, user.getIdentifier());
    } catch (RemoteException e) {
    }
}","{
    sendBroadcastAsUser(intent, user, receiverPermission, AppOpsManager.OP_NONE);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The Late_Implementation is changed to a call to another method with parameters passed through, so the code change type is 5.","There doesn't seem to be a Compatibility Issue because the implementation of the method in the late version delegates the work to another method without changing the behavior of how the broadcast is sent. It simply reuses another method with the same signature to reduce code duplication, assuming the functionality of the newly used method sendBroadcastAsUser(intent, user, receiverPermission, AppOpsManager.OP_NONE) is the same. Therefore, based on the information provided, there's no indication that behavior has changed from the caller's perspective."
165,"<android.widget.EdgeEffect: void onPull(float,float)>",22,23,"<android.widget.EdgeEffect: void onPull(float,float)>","<android.widget.EdgeEffect: void onPull(float,float)>",0,"{
    final long now = AnimationUtils.currentAnimationTimeMillis();
    mTargetDisplacement = displacement;
    if (mState == STATE_PULL_DECAY && now - mStartTime < mDuration) {
        return;
    }
    if (mState != STATE_PULL) {
        mGlowScaleY = Math.max(PULL_GLOW_BEGIN, mGlowScaleY);
    }
    mState = STATE_PULL;
    mStartTime = now;
    mDuration = PULL_TIME;
    mPullDistance += deltaDistance;
    final float absdd = Math.abs(deltaDistance);
    mGlowAlpha = mGlowAlphaStart = Math.min(MAX_ALPHA, mGlowAlpha + (absdd * PULL_DISTANCE_ALPHA_GLOW_FACTOR));
    if (mPullDistance == 0) {
        mGlowScaleY = mGlowScaleYStart = 0;
    } else {
        final float scale = Math.max(0, 1 - 1 / FloatMath.sqrt(Math.abs(mPullDistance) * mBounds.height()) - 0.3f) / 0.7f;
        mGlowScaleY = mGlowScaleYStart = scale;
    }
    mGlowAlphaFinish = mGlowAlpha;
    mGlowScaleYFinish = mGlowScaleY;
}","{
    final long now = AnimationUtils.currentAnimationTimeMillis();
    mTargetDisplacement = displacement;
    if (mState == STATE_PULL_DECAY && now - mStartTime < mDuration) {
        return;
    }
    if (mState != STATE_PULL) {
        mGlowScaleY = Math.max(PULL_GLOW_BEGIN, mGlowScaleY);
    }
    mState = STATE_PULL;
    mStartTime = now;
    mDuration = PULL_TIME;
    mPullDistance += deltaDistance;
    final float absdd = Math.abs(deltaDistance);
    mGlowAlpha = mGlowAlphaStart = Math.min(MAX_ALPHA, mGlowAlpha + (absdd * PULL_DISTANCE_ALPHA_GLOW_FACTOR));
    if (mPullDistance == 0) {
        mGlowScaleY = mGlowScaleYStart = 0;
    } else {
        final float scale = (float) (Math.max(0, 1 - 1 / Math.sqrt(Math.abs(mPullDistance) * mBounds.height()) - 0.3d) / 0.7d);
        mGlowScaleY = mGlowScaleYStart = scale;
    }
    mGlowAlphaFinish = mGlowAlpha;
    mGlowScaleYFinish = mGlowScaleY;
}",1,"/**
 * A view should call this when content is pulled away from an edge by the user.
 * This will update the state of the current visual effect and its associated animation.
 * The host view should always {@link android.view.View#invalidate()} after this
 * and draw the results accordingly.
 *
 * @param deltaDistance Change in distance since the last call. Values may be 0 (no change) to
 * 1.f (full length of the view) or negative values to express change
 * back toward the edge reached to initiate the effect.
 * @param displacement The displacement from the starting side of the effect of the point
 * initiating the pull. In the case of touch this is the finger position.
 * Values may be from 0-1.
 */
","/**
 * A view should call this when content is pulled away from an edge by the user.
 * This will update the state of the current visual effect and its associated animation.
 * The host view should always {@link android.view.View#invalidate()} after this
 * and draw the results accordingly.
 *
 * @param deltaDistance Change in distance since the last call. Values may be 0 (no change) to
 * 1.f (full length of the view) or negative values to express change
 * back toward the edge reached to initiate the effect.
 * @param displacement The displacement from the starting side of the effect of the point
 * initiating the pull. In the case of touch this is the finger position.
 * Values may be from 0-1.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change in the implementation is the replacement of `FloatMath.sqrt` with `Math.sqrt` and casting the result to `float`. This does not lead to the API potentially returning a different value or throwing a different exception because the mathematical result would be the same, it just switches from a now-deprecated API (`FloatMath`) to using `Math` directly. Since the change is only in the arithmetic calculation, the code change type is 4.","There is no Compatibility Issue, as the change does not affect the API output; the value of `scale` will remain the same because both `Math.sqrt` and `FloatMath.sqrt` would compute the same result for given input. The update has just adapted to a newer method for square root calculation thus, the result remains mathematically equivalent to the previous implementation. There is no change to return values, control structures, or exception handling, so the CI type is 0."
166,"<android.bluetooth.BluetoothAdapter: boolean getProfileProxy(Context,ServiceListener,int)>",22,23,"<android.bluetooth.BluetoothAdapter: boolean getProfileProxy(Context,ServiceListener,int)>","<android.bluetooth.BluetoothAdapter: boolean getProfileProxy(Context,ServiceListener,int)>",0,"{
    if (context == null || listener == null)
        return false;
    if (profile == BluetoothProfile.HEADSET) {
        BluetoothHeadset headset = new BluetoothHeadset(context, listener);
        return true;
    } else if (profile == BluetoothProfile.A2DP) {
        BluetoothA2dp a2dp = new BluetoothA2dp(context, listener);
        return true;
    } else if (profile == BluetoothProfile.A2DP_SINK) {
        BluetoothA2dpSink a2dpSink = new BluetoothA2dpSink(context, listener);
        return true;
    } else if (profile == BluetoothProfile.AVRCP_CONTROLLER) {
        BluetoothAvrcpController avrcp = new BluetoothAvrcpController(context, listener);
        return true;
    } else if (profile == BluetoothProfile.INPUT_DEVICE) {
        BluetoothInputDevice iDev = new BluetoothInputDevice(context, listener);
        return true;
    } else if (profile == BluetoothProfile.PAN) {
        BluetoothPan pan = new BluetoothPan(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEALTH) {
        BluetoothHealth health = new BluetoothHealth(context, listener);
        return true;
    } else if (profile == BluetoothProfile.MAP) {
        BluetoothMap map = new BluetoothMap(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEADSET_CLIENT) {
        BluetoothHeadsetClient headsetClient = new BluetoothHeadsetClient(context, listener);
        return true;
    } else {
        return false;
    }
}","{
    if (context == null || listener == null)
        return false;
    if (profile == BluetoothProfile.HEADSET) {
        BluetoothHeadset headset = new BluetoothHeadset(context, listener);
        return true;
    } else if (profile == BluetoothProfile.A2DP) {
        BluetoothA2dp a2dp = new BluetoothA2dp(context, listener);
        return true;
    } else if (profile == BluetoothProfile.A2DP_SINK) {
        BluetoothA2dpSink a2dpSink = new BluetoothA2dpSink(context, listener);
        return true;
    } else if (profile == BluetoothProfile.AVRCP_CONTROLLER) {
        BluetoothAvrcpController avrcp = new BluetoothAvrcpController(context, listener);
        return true;
    } else if (profile == BluetoothProfile.INPUT_DEVICE) {
        BluetoothInputDevice iDev = new BluetoothInputDevice(context, listener);
        return true;
    } else if (profile == BluetoothProfile.PAN) {
        BluetoothPan pan = new BluetoothPan(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEALTH) {
        BluetoothHealth health = new BluetoothHealth(context, listener);
        return true;
    } else if (profile == BluetoothProfile.MAP) {
        BluetoothMap map = new BluetoothMap(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEADSET_CLIENT) {
        BluetoothHeadsetClient headsetClient = new BluetoothHeadsetClient(context, listener);
        return true;
    } else if (profile == BluetoothProfile.SAP) {
        BluetoothSap sap = new BluetoothSap(context, listener);
        return true;
    } else {
        return false;
    }
}",1,"/**
 * Get the profile proxy object associated with the profile.
 *
 * <p>Profile can be one of {@link BluetoothProfile#HEALTH}, {@link BluetoothProfile#HEADSET},
 * {@link BluetoothProfile#A2DP}, {@link BluetoothProfile#GATT}, or
 * {@link BluetoothProfile#GATT_SERVER}. Clients must implement
 * {@link BluetoothProfile.ServiceListener} to get notified of
 * the connection status and to get the proxy object.
 *
 * @param context Context of the application
 * @param listener The service Listener for connection callbacks.
 * @param profile The Bluetooth profile; either {@link BluetoothProfile#HEALTH},
 * {@link BluetoothProfile#HEADSET} or {@link BluetoothProfile#A2DP}.
 * @return true on success, false on error
 */
","/**
 * Get the profile proxy object associated with the profile.
 *
 * <p>Profile can be one of {@link BluetoothProfile#HEALTH}, {@link BluetoothProfile#HEADSET},
 * {@link BluetoothProfile#A2DP}, {@link BluetoothProfile#GATT}, or
 * {@link BluetoothProfile#GATT_SERVER}. Clients must implement
 * {@link BluetoothProfile.ServiceListener} to get notified of
 * the connection status and to get the proxy object.
 *
 * @param context Context of the application
 * @param listener The service Listener for connection callbacks.
 * @param profile The Bluetooth profile; either {@link BluetoothProfile#HEALTH},
 * {@link BluetoothProfile#HEADSET}, {@link BluetoothProfile#A2DP}.
 * {@link BluetoothProfile#GATT} or {@link BluetoothProfile#GATT_SERVER}.
 * @return true on success, false on error
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"A new else if branch has been introduced to check an additional profile type (BluetoothProfile.SAP) and return true if it matches, so the changes include control dependency (condition check for a new profile) as well as a new return statement. Therefore, the code change type is 1,3.","The addition of a new profile type for which the method returns true introduces a potential Compatibility Issue where, in the newer version, the method would return 'true' for a case where it previously would have returned 'false'. Thus, the API potentially returns different values, and the CI type is 1."
168,"<android.content.ContentResolver: String[] getStreamTypes(Uri,String)>",22,23,"<android.content.ContentResolver: String[] getStreamTypes(Uri,String)>","<android.content.ContentResolver: String[] getStreamTypes(Uri,String)>",0,"{
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        return null;
    }
    try {
        return provider.getStreamTypes(url, mimeTypeFilter);
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        releaseProvider(provider);
    }
}","{
    Preconditions.checkNotNull(url, ""url"");
    Preconditions.checkNotNull(mimeTypeFilter, ""mimeTypeFilter"");
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        return null;
    }
    try {
        return provider.getStreamTypes(url, mimeTypeFilter);
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        releaseProvider(provider);
    }
}",1,"/**
 * Query for the possible MIME types for the representations the given
 * content URL can be returned when opened as as stream with
 * {@link #openTypedAssetFileDescriptor}.  Note that the types here are
 * not necessarily a superset of the type returned by {@link #getType} --
 * many content providers cannot return a raw stream for the structured
 * data that they contain.
 *
 * @param url A Uri identifying content (either a list or specific type),
 * using the content:// scheme.
 * @param mimeTypeFilter The desired MIME type.  This may be a pattern,
 * such as *&#47;*, to query for all available MIME types that match the
 * pattern.
 * @return Returns an array of MIME type strings for all available
 * data streams that match the given mimeTypeFilter.  If there are none,
 * null is returned.
 */
","/**
 * Query for the possible MIME types for the representations the given
 * content URL can be returned when opened as as stream with
 * {@link #openTypedAssetFileDescriptor}.  Note that the types here are
 * not necessarily a superset of the type returned by {@link #getType} --
 * many content providers cannot return a raw stream for the structured
 * data that they contain.
 *
 * @param url A Uri identifying content (either a list or specific type),
 * using the content:// scheme.
 * @param mimeTypeFilter The desired MIME type.  This may be a pattern,
 * such as *&#47;*, to query for all available MIME types that match the
 * pattern.
 * @return Returns an array of MIME type strings for all available
 * data streams that match the given mimeTypeFilter.  If there are none,
 * null is returned.
 */
",-1,,[@Nullable],-1,-1,-1,-1,-1,-1,4,0,"The new code introduces calls to Preconditions.checkNotNull for the `url` and `mimeTypeFilter` parameters before they are used, so the change type is 4.","Although the Preconditions.checkNotNull calls could throw a NullPointerException if the arguments are null, the previous version would have also resulted in a NullPointerException eventually when a null `url` or `mimeTypeFilter` was accessed by `acquireProvider(url)` or `provider.getStreamTypes(url, mimeTypeFilter)`. Thus, the added preconditions do not introduce a CI, because they enforce a contract that was already implicitly present. Therefore, there is no Compatibility Issue."
173,"<android.content.ContentProviderClient: AssetFileDescriptor openAssetFile(Uri,String,CancellationSignal)>",22,23,"<android.content.ContentProviderClient: AssetFileDescriptor openAssetFile(Uri,String,CancellationSignal)>","<android.content.ContentProviderClient: AssetFileDescriptor openAssetFile(Uri,String,CancellationSignal)>",0,"{
    beforeRemote();
    try {
        ICancellationSignal remoteSignal = null;
        if (signal != null) {
            signal.throwIfCanceled();
            remoteSignal = mContentProvider.createCancellationSignal();
            signal.setRemote(remoteSignal);
        }
        return mContentProvider.openAssetFile(mPackageName, url, mode, remoteSignal);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}","{
    Preconditions.checkNotNull(url, ""url"");
    Preconditions.checkNotNull(mode, ""mode"");
    beforeRemote();
    try {
        ICancellationSignal remoteSignal = null;
        if (signal != null) {
            signal.throwIfCanceled();
            remoteSignal = mContentProvider.createCancellationSignal();
            signal.setRemote(remoteSignal);
        }
        return mContentProvider.openAssetFile(mPackageName, url, mode, remoteSignal);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}",1,"/**
 * See {@link ContentProvider#openAssetFile ContentProvider.openAssetFile}.
 * Note that this <em>does not</em>
 * take care of non-content: URIs such as file:.  It is strongly recommended
 * you use the {@link ContentResolver#openAssetFileDescriptor
 * ContentResolver.openAssetFileDescriptor} API instead.
 */
","/**
 * See {@link ContentProvider#openAssetFile ContentProvider.openAssetFile}.
 * Note that this <em>does not</em>
 * take care of non-content: URIs such as file:.  It is strongly recommended
 * you use the {@link ContentResolver#openAssetFileDescriptor
 * ContentResolver.openAssetFileDescriptor} API instead.
 */
",-1,,[@Nullable],-1,-1,-1,-1,-1,-1,4,0,"The late implementation introduces two Preconditions.checkNotNull statements, which constitute an 'Other statement changed' change (code change type 4).","The Preconditions.checkNotNull statements are used to validate the inputs 'url' and 'mode', ensuring they are not null. If they are null, a NullPointerException will be thrown. Since 'NullPointerException' is an 'unchecked exception', it would be part of the method signature already possible from the Early_Version (though not explicitly thrown), and thus does not constitute a change in exception handling. In this case, the precondition checks make the late version fail faster if the conditions are not met but do not represent a compatibility issue because it does not introduce a new checked exception or change a return type or value (CI type 0)."
175,<android.view.MotionEvent: String toString()>,22,23,<android.view.MotionEvent: String toString()>,<android.view.MotionEvent: String toString()>,0,"{
    StringBuilder msg = new StringBuilder();
    msg.append(""MotionEvent { action="").append(actionToString(getAction()));
    final int pointerCount = getPointerCount();
    for (int i = 0; i < pointerCount; i++) {
        msg.append("", id["").append(i).append(""]="").append(getPointerId(i));
        msg.append("", x["").append(i).append(""]="").append(getX(i));
        msg.append("", y["").append(i).append(""]="").append(getY(i));
        msg.append("", toolType["").append(i).append(""]="").append(toolTypeToString(getToolType(i)));
    }
    msg.append("", buttonState="").append(MotionEvent.buttonStateToString(getButtonState()));
    msg.append("", metaState="").append(KeyEvent.metaStateToString(getMetaState()));
    msg.append("", flags=0x"").append(Integer.toHexString(getFlags()));
    msg.append("", edgeFlags=0x"").append(Integer.toHexString(getEdgeFlags()));
    msg.append("", pointerCount="").append(pointerCount);
    msg.append("", historySize="").append(getHistorySize());
    msg.append("", eventTime="").append(getEventTime());
    msg.append("", downTime="").append(getDownTime());
    msg.append("", deviceId="").append(getDeviceId());
    msg.append("", source=0x"").append(Integer.toHexString(getSource()));
    msg.append("" }"");
    return msg.toString();
}","{
    StringBuilder msg = new StringBuilder();
    msg.append(""MotionEvent { action="").append(actionToString(getAction()));
    msg.append("", actionButton="").append(buttonStateToString(getActionButton()));
    final int pointerCount = getPointerCount();
    for (int i = 0; i < pointerCount; i++) {
        msg.append("", id["").append(i).append(""]="").append(getPointerId(i));
        msg.append("", x["").append(i).append(""]="").append(getX(i));
        msg.append("", y["").append(i).append(""]="").append(getY(i));
        msg.append("", toolType["").append(i).append(""]="").append(toolTypeToString(getToolType(i)));
    }
    msg.append("", buttonState="").append(MotionEvent.buttonStateToString(getButtonState()));
    msg.append("", metaState="").append(KeyEvent.metaStateToString(getMetaState()));
    msg.append("", flags=0x"").append(Integer.toHexString(getFlags()));
    msg.append("", edgeFlags=0x"").append(Integer.toHexString(getEdgeFlags()));
    msg.append("", pointerCount="").append(pointerCount);
    msg.append("", historySize="").append(getHistorySize());
    msg.append("", eventTime="").append(getEventTime());
    msg.append("", downTime="").append(getDownTime());
    msg.append("", deviceId="").append(getDeviceId());
    msg.append("", source=0x"").append(Integer.toHexString(getSource()));
    msg.append("" }"");
    return msg.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"Additional data (actionButton) has been appended to the StringBuilder object 'msg' within the method. This is a change in one of the statements that construct this String, so the change type is 4.","The change only adds additional information to the string representation of the MotionEvent. It does not affect the behavior of other methods or the execution flow of the program; hence, there is no Compatibility Issue. The method's return type and potential exception handling remain unchanged."
178,<android.net.Network: void bindSocket(Socket)>,22,23,<android.net.Network: void bindSocket(Socket)>,<android.net.Network: void bindSocket(Socket)>,0,"{
    // Apparently, the kernel doesn't update a connected TCP socket's routing upon mark changes.
    if (socket.isConnected()) {
        throw new SocketException(""Socket is connected"");
    }
    // Query a property of the underlying socket to ensure that the socket's file descriptor
    // exists, is available to bind to a network and is not closed.
    socket.getReuseAddress();
    bindSocketFd(socket.getFileDescriptor$());
}","{
    // Query a property of the underlying socket to ensure that the socket's file descriptor
    // exists, is available to bind to a network and is not closed.
    socket.getReuseAddress();
    bindSocket(socket.getFileDescriptor$());
}",1,"/**
 * Binds the specified {@link Socket} to this {@code Network}. All data traffic on the socket
 * will be sent on this {@code Network}, irrespective of any process-wide network binding set by
 * {@link ConnectivityManager#setProcessDefaultNetwork}. The socket must not be connected.
 */
","/**
 * Binds the specified {@link Socket} to this {@code Network}. All data traffic on the socket
 * will be sent on this {@code Network}, irrespective of any process-wide network binding set by
 * {@link ConnectivityManager#bindProcessToNetwork}. The socket must not be connected.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","The exception handling statement `throw new SocketException(""Socket is connected"")` in the early version has been removed. This constitutes a change of type 2. Additionally, there is a change in the method used from `bindSocketFd(socket.getFileDescriptor$());` to `bindSocket(socket.getFileDescriptor$());` without knowing the implementation details of these methods, this could also be a change of type 1 if the behaviors of the methods differ.","The compatibility issue can be both 1 and 2 because the removal of the exception handling statement means that the early version could throw an exception in a scenario where the late version will not, which is a CI of type 2. Furthermore, if the behavior of `bindSocketFd` and `bindSocket` differs, it could potentially lead to different outcomes when binding the socket, indicating a CI of type 1."
179,"<android.inputmethodservice.InputMethodService: boolean onKeyDown(int,KeyEvent)>",22,23,"<android.inputmethodservice.InputMethodService: boolean onKeyDown(int,KeyEvent)>","<android.inputmethodservice.InputMethodService: boolean onKeyDown(int,KeyEvent)>",0,"{
    if (event.getKeyCode() == KeyEvent.KEYCODE_BACK) {
        if (handleBack(false)) {
            event.startTracking();
            return true;
        }
        return false;
    }
    return doMovementKey(keyCode, event, MOVEMENT_DOWN);
}","{
    if (event.getKeyCode() == KeyEvent.KEYCODE_BACK) {
        final ExtractEditText eet = getExtractEditTextIfVisible();
        if (eet != null && eet.handleBackInTextActionModeIfNeeded(event)) {
            return true;
        }
        if (handleBack(false)) {
            event.startTracking();
            return true;
        }
        return false;
    }
    return doMovementKey(keyCode, event, MOVEMENT_DOWN);
}",1,"/**
 * Override this to intercept key down events before they are processed by the
 * application.  If you return true, the application will not
 * process the event itself.  If you return false, the normal application processing
 * will occur as if the IME had not seen the event at all.
 *
 * <p>The default implementation intercepts {@link KeyEvent#KEYCODE_BACK
 * KeyEvent.KEYCODE_BACK} if the IME is currently shown, to
 * possibly hide it when the key goes up (if not canceled or long pressed).  In
 * addition, in fullscreen mode only, it will consume DPAD movement
 * events to move the cursor in the extracted text view, not allowing
 * them to perform navigation in the underlying application.
 */
","/**
 * Override this to intercept key down events before they are processed by the
 * application.  If you return true, the application will not
 * process the event itself.  If you return false, the normal application processing
 * will occur as if the IME had not seen the event at all.
 *
 * <p>The default implementation intercepts {@link KeyEvent#KEYCODE_BACK
 * KeyEvent.KEYCODE_BACK} if the IME is currently shown, to
 * possibly hide it when the key goes up (if not canceled or long pressed).  In
 * addition, in fullscreen mode only, it will consume DPAD movement
 * events to move the cursor in the extracted text view, not allowing
 * them to perform navigation in the underlying application.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The late version introduces a new variable (eet) and a new conditional block with return statements. This is an addition to the existing control flow, which constitutes a control dependency change type 3 and another statement within that control block changed, categorized as other statement changed type 4.","The new conditional block with return statements means that the method can return true in a scenario where it previously would not, due to the new check on `eet.handleBackInTextActionModeIfNeeded(event)`. This is a possible Compatibility Issue due to potential different return values, so the CI type is 1."
181,<android.net.DhcpStateMachine.WaitBeforeRenewalState: boolean processMessage(Message)>,22,23,<android.net.DhcpStateMachine.WaitBeforeRenewalState: boolean processMessage(Message)>,<android.net.DhcpStateMachine.WaitBeforeRenewalState: boolean processMessage(Message)>,0,"{
    boolean retValue = HANDLED;
    if (DBG)
        Log.d(TAG, getName() + message.toString() + ""\n"");
    switch(message.what) {
        case CMD_STOP_DHCP:
            mAlarmManager.cancel(mDhcpRenewalIntent);
            if (!NetworkUtils.stopDhcp(mInterfaceName)) {
                Log.e(TAG, ""Failed to stop Dhcp on "" + mInterfaceName);
            }
            transitionTo(mStoppedState);
            break;
        case CMD_PRE_DHCP_ACTION_COMPLETE:
            if (runDhcp(DhcpAction.RENEW)) {
                transitionTo(mRunningState);
            } else {
                transitionTo(mStoppedState);
            }
            break;
        case CMD_START_DHCP:
            // ignore
            break;
        default:
            retValue = NOT_HANDLED;
            break;
    }
    return retValue;
}","{
    boolean retValue = HANDLED;
    if (DBG)
        Log.d(TAG, getName() + message.toString() + ""\n"");
    switch(message.what) {
        case CMD_STOP_DHCP:
            mAlarmManager.cancel(mDhcpRenewalIntent);
            transitionTo(mStoppedState);
            break;
        case CMD_PRE_DHCP_ACTION_COMPLETE:
            if (runDhcpRenew()) {
                transitionTo(mRunningState);
            } else {
                transitionTo(mStoppedState);
            }
            break;
        case CMD_START_DHCP:
            // ignore
            break;
        default:
            retValue = NOT_HANDLED;
            break;
    }
    return retValue;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4,5",0,"The removal of the `NetworkUtils.stopDhcp(mInterfaceName)` statement and the change from `runDhcp(DhcpAction.RENEW)` to `runDhcpRenew()` are instances of other statements changed, control dependency changed, as well as dependent API changed (i.e. change type 3,4,5).","Although there are code changes, the logic and overall behaviour of the API do not change. `runDhcp(DhcpAction.RENEW)` seems to have been renamed to `runDhcpRenew()`, which should not affect the API's return value or the exceptions it might throw. The removal of `Log.e(TAG, ""Failed to stop Dhcp on "" + mInterfaceName);` only affects logging and not the operational logic. Thus, there is no compatibility issue (i.e. CI type 0)."
183,"<android.text.SpannableStringInternal: T[] getSpans(int,int,Class<T>)>",22,23,"<android.text.SpannableStringInternal: T[] getSpans(int,int,Class<T>)>","<android.text.SpannableStringInternal: T[] getSpans(int,int,Class<T>)>",0,"{
    int count = 0;
    int spanCount = mSpanCount;
    Object[] spans = mSpans;
    int[] data = mSpanData;
    Object[] ret = null;
    Object ret1 = null;
    for (int i = 0; i < spanCount; i++) {
        if (kind != null && !kind.isInstance(spans[i])) {
            continue;
        }
        int spanStart = data[i * COLUMNS + START];
        int spanEnd = data[i * COLUMNS + END];
        if (spanStart > queryEnd) {
            continue;
        }
        if (spanEnd < queryStart) {
            continue;
        }
        if (spanStart != spanEnd && queryStart != queryEnd) {
            if (spanStart == queryEnd) {
                continue;
            }
            if (spanEnd == queryStart) {
                continue;
            }
        }
        if (count == 0) {
            ret1 = spans[i];
            count++;
        } else {
            if (count == 1) {
                ret = (Object[]) Array.newInstance(kind, spanCount - i + 1);
                ret[0] = ret1;
            }
            int prio = data[i * COLUMNS + FLAGS] & Spanned.SPAN_PRIORITY;
            if (prio != 0) {
                int j;
                for (j = 0; j < count; j++) {
                    int p = getSpanFlags(ret[j]) & Spanned.SPAN_PRIORITY;
                    if (prio > p) {
                        break;
                    }
                }
                System.arraycopy(ret, j, ret, j + 1, count - j);
                ret[j] = spans[i];
                count++;
            } else {
                ret[count++] = spans[i];
            }
        }
    }
    if (count == 0) {
        return (T[]) ArrayUtils.emptyArray(kind);
    }
    if (count == 1) {
        ret = (Object[]) Array.newInstance(kind, 1);
        ret[0] = ret1;
        return (T[]) ret;
    }
    if (count == ret.length) {
        return (T[]) ret;
    }
    Object[] nret = (Object[]) Array.newInstance(kind, count);
    System.arraycopy(ret, 0, nret, 0, count);
    return (T[]) nret;
}","{
    int count = 0;
    int spanCount = mSpanCount;
    Object[] spans = mSpans;
    int[] data = mSpanData;
    Object[] ret = null;
    Object ret1 = null;
    for (int i = 0; i < spanCount; i++) {
        int spanStart = data[i * COLUMNS + START];
        int spanEnd = data[i * COLUMNS + END];
        if (spanStart > queryEnd) {
            continue;
        }
        if (spanEnd < queryStart) {
            continue;
        }
        if (spanStart != spanEnd && queryStart != queryEnd) {
            if (spanStart == queryEnd) {
                continue;
            }
            if (spanEnd == queryStart) {
                continue;
            }
        }
        // verify span class as late as possible, since it is expensive
        if (kind != null && !kind.isInstance(spans[i])) {
            continue;
        }
        if (count == 0) {
            ret1 = spans[i];
            count++;
        } else {
            if (count == 1) {
                ret = (Object[]) Array.newInstance(kind, spanCount - i + 1);
                ret[0] = ret1;
            }
            int prio = data[i * COLUMNS + FLAGS] & Spanned.SPAN_PRIORITY;
            if (prio != 0) {
                int j;
                for (j = 0; j < count; j++) {
                    int p = getSpanFlags(ret[j]) & Spanned.SPAN_PRIORITY;
                    if (prio > p) {
                        break;
                    }
                }
                System.arraycopy(ret, j, ret, j + 1, count - j);
                ret[j] = spans[i];
                count++;
            } else {
                ret[count++] = spans[i];
            }
        }
    }
    if (count == 0) {
        return (T[]) ArrayUtils.emptyArray(kind);
    }
    if (count == 1) {
        ret = (Object[]) Array.newInstance(kind, 1);
        ret[0] = ret1;
        return (T[]) ret;
    }
    if (count == ret.length) {
        return (T[]) ret;
    }
    Object[] nret = (Object[]) Array.newInstance(kind, count);
    System.arraycopy(ret, 0, nret, 0, count);
    return (T[]) nret;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
185,"<android.view.View: boolean draw(Canvas,ViewGroup,long)>",22,23,"<android.view.View: boolean draw(Canvas,ViewGroup,long)>","<android.view.View: boolean draw(Canvas,ViewGroup,long)>",0,"{
    boolean usingRenderNodeProperties = mAttachInfo != null && mAttachInfo.mHardwareAccelerated;
    boolean more = false;
    final boolean childHasIdentityMatrix = hasIdentityMatrix();
    final int flags = parent.mGroupFlags;
    if ((flags & ViewGroup.FLAG_CLEAR_TRANSFORMATION) == ViewGroup.FLAG_CLEAR_TRANSFORMATION) {
        parent.getChildTransformation().clear();
        parent.mGroupFlags &= ~ViewGroup.FLAG_CLEAR_TRANSFORMATION;
    }
    Transformation transformToApply = null;
    boolean concatMatrix = false;
    boolean scalingRequired = false;
    boolean caching;
    int layerType = getLayerType();
    final boolean hardwareAccelerated = canvas.isHardwareAccelerated();
    if ((flags & ViewGroup.FLAG_CHILDREN_DRAWN_WITH_CACHE) != 0 || (flags & ViewGroup.FLAG_ALWAYS_DRAWN_WITH_CACHE) != 0) {
        caching = true;
        // Auto-scaled apps are not hw-accelerated, no need to set scaling flag on DisplayList
        if (mAttachInfo != null)
            scalingRequired = mAttachInfo.mScalingRequired;
    } else {
        caching = (layerType != LAYER_TYPE_NONE) || hardwareAccelerated;
    }
    final Animation a = getAnimation();
    if (a != null) {
        more = drawAnimation(parent, drawingTime, a, scalingRequired);
        concatMatrix = a.willChangeTransformationMatrix();
        if (concatMatrix) {
            mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_TRANSFORM;
        }
        transformToApply = parent.getChildTransformation();
    } else {
        if ((mPrivateFlags3 & PFLAG3_VIEW_IS_ANIMATING_TRANSFORM) != 0) {
            // No longer animating: clear out old animation matrix
            mRenderNode.setAnimationMatrix(null);
            mPrivateFlags3 &= ~PFLAG3_VIEW_IS_ANIMATING_TRANSFORM;
        }
        if (!usingRenderNodeProperties && (flags & ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != 0) {
            final Transformation t = parent.getChildTransformation();
            final boolean hasTransform = parent.getChildStaticTransformation(this, t);
            if (hasTransform) {
                final int transformType = t.getTransformationType();
                transformToApply = transformType != Transformation.TYPE_IDENTITY ? t : null;
                concatMatrix = (transformType & Transformation.TYPE_MATRIX) != 0;
            }
        }
    }
    concatMatrix |= !childHasIdentityMatrix;
    // Sets the flag as early as possible to allow draw() implementations
    // to call invalidate() successfully when doing animations
    mPrivateFlags |= PFLAG_DRAWN;
    if (!concatMatrix && (flags & (ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS | ViewGroup.FLAG_CLIP_CHILDREN)) == ViewGroup.FLAG_CLIP_CHILDREN && canvas.quickReject(mLeft, mTop, mRight, mBottom, Canvas.EdgeType.BW) && (mPrivateFlags & PFLAG_DRAW_ANIMATION) == 0) {
        mPrivateFlags2 |= PFLAG2_VIEW_QUICK_REJECTED;
        return more;
    }
    mPrivateFlags2 &= ~PFLAG2_VIEW_QUICK_REJECTED;
    if (hardwareAccelerated) {
        // Clear INVALIDATED flag to allow invalidation to occur during rendering, but
        // retain the flag's value temporarily in the mRecreateDisplayList flag
        mRecreateDisplayList = (mPrivateFlags & PFLAG_INVALIDATED) == PFLAG_INVALIDATED;
        mPrivateFlags &= ~PFLAG_INVALIDATED;
    }
    RenderNode renderNode = null;
    Bitmap cache = null;
    boolean hasDisplayList = false;
    if (caching) {
        if (!hardwareAccelerated) {
            if (layerType != LAYER_TYPE_NONE) {
                layerType = LAYER_TYPE_SOFTWARE;
                buildDrawingCache(true);
            }
            cache = getDrawingCache(true);
        } else {
            switch(layerType) {
                case LAYER_TYPE_SOFTWARE:
                    if (usingRenderNodeProperties) {
                        hasDisplayList = canHaveDisplayList();
                    } else {
                        buildDrawingCache(true);
                        cache = getDrawingCache(true);
                    }
                    break;
                case LAYER_TYPE_HARDWARE:
                    if (usingRenderNodeProperties) {
                        hasDisplayList = canHaveDisplayList();
                    }
                    break;
                case LAYER_TYPE_NONE:
                    // Delay getting the display list until animation-driven alpha values are
                    // set up and possibly passed on to the view
                    hasDisplayList = canHaveDisplayList();
                    break;
            }
        }
    }
    usingRenderNodeProperties &= hasDisplayList;
    if (usingRenderNodeProperties) {
        renderNode = getDisplayList();
        if (!renderNode.isValid()) {
            // Uncommon, but possible. If a view is removed from the hierarchy during the call
            // to getDisplayList(), the display list will be marked invalid and we should not
            // try to use it again.
            renderNode = null;
            hasDisplayList = false;
            usingRenderNodeProperties = false;
        }
    }
    int sx = 0;
    int sy = 0;
    if (!hasDisplayList) {
        computeScroll();
        sx = mScrollX;
        sy = mScrollY;
    }
    final boolean hasNoCache = cache == null || hasDisplayList;
    final boolean offsetForScroll = cache == null && !hasDisplayList && layerType != LAYER_TYPE_HARDWARE;
    int restoreTo = -1;
    if (!usingRenderNodeProperties || transformToApply != null) {
        restoreTo = canvas.save();
    }
    if (offsetForScroll) {
        canvas.translate(mLeft - sx, mTop - sy);
    } else {
        if (!usingRenderNodeProperties) {
            canvas.translate(mLeft, mTop);
        }
        if (scalingRequired) {
            if (usingRenderNodeProperties) {
                // TODO: Might not need this if we put everything inside the DL
                restoreTo = canvas.save();
            }
            // mAttachInfo cannot be null, otherwise scalingRequired == false
            final float scale = 1.0f / mAttachInfo.mApplicationScale;
            canvas.scale(scale, scale);
        }
    }
    float alpha = usingRenderNodeProperties ? 1 : (getAlpha() * getTransitionAlpha());
    if (transformToApply != null || alpha < 1 || !hasIdentityMatrix() || (mPrivateFlags3 & PFLAG3_VIEW_IS_ANIMATING_ALPHA) == PFLAG3_VIEW_IS_ANIMATING_ALPHA) {
        if (transformToApply != null || !childHasIdentityMatrix) {
            int transX = 0;
            int transY = 0;
            if (offsetForScroll) {
                transX = -sx;
                transY = -sy;
            }
            if (transformToApply != null) {
                if (concatMatrix) {
                    if (usingRenderNodeProperties) {
                        renderNode.setAnimationMatrix(transformToApply.getMatrix());
                    } else {
                        // Undo the scroll translation, apply the transformation matrix,
                        // then redo the scroll translate to get the correct result.
                        canvas.translate(-transX, -transY);
                        canvas.concat(transformToApply.getMatrix());
                        canvas.translate(transX, transY);
                    }
                    parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
                }
                float transformAlpha = transformToApply.getAlpha();
                if (transformAlpha < 1) {
                    alpha *= transformAlpha;
                    parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
                }
            }
            if (!childHasIdentityMatrix && !usingRenderNodeProperties) {
                canvas.translate(-transX, -transY);
                canvas.concat(getMatrix());
                canvas.translate(transX, transY);
            }
        }
        // Deal with alpha if it is or used to be <1
        if (alpha < 1 || (mPrivateFlags3 & PFLAG3_VIEW_IS_ANIMATING_ALPHA) == PFLAG3_VIEW_IS_ANIMATING_ALPHA) {
            if (alpha < 1) {
                mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_ALPHA;
            } else {
                mPrivateFlags3 &= ~PFLAG3_VIEW_IS_ANIMATING_ALPHA;
            }
            parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
            if (hasNoCache) {
                final int multipliedAlpha = (int) (255 * alpha);
                if (!onSetAlpha(multipliedAlpha)) {
                    int layerFlags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG;
                    if ((flags & ViewGroup.FLAG_CLIP_CHILDREN) != 0 || layerType != LAYER_TYPE_NONE) {
                        layerFlags |= Canvas.CLIP_TO_LAYER_SAVE_FLAG;
                    }
                    if (usingRenderNodeProperties) {
                        renderNode.setAlpha(alpha * getAlpha() * getTransitionAlpha());
                    } else if (layerType == LAYER_TYPE_NONE) {
                        final int scrollX = hasDisplayList ? 0 : sx;
                        final int scrollY = hasDisplayList ? 0 : sy;
                        canvas.saveLayerAlpha(scrollX, scrollY, scrollX + (mRight - mLeft), scrollY + (mBottom - mTop), multipliedAlpha, layerFlags);
                    }
                } else {
                    // Alpha is handled by the child directly, clobber the layer's alpha
                    mPrivateFlags |= PFLAG_ALPHA_SET;
                }
            }
        }
    } else if ((mPrivateFlags & PFLAG_ALPHA_SET) == PFLAG_ALPHA_SET) {
        onSetAlpha(255);
        mPrivateFlags &= ~PFLAG_ALPHA_SET;
    }
    if (!usingRenderNodeProperties) {
        // apply clips directly, since RenderNode won't do it for this draw
        if ((flags & ViewGroup.FLAG_CLIP_CHILDREN) == ViewGroup.FLAG_CLIP_CHILDREN && cache == null) {
            if (offsetForScroll) {
                canvas.clipRect(sx, sy, sx + (mRight - mLeft), sy + (mBottom - mTop));
            } else {
                if (!scalingRequired || cache == null) {
                    canvas.clipRect(0, 0, mRight - mLeft, mBottom - mTop);
                } else {
                    canvas.clipRect(0, 0, cache.getWidth(), cache.getHeight());
                }
            }
        }
        if (mClipBounds != null) {
            // clip bounds ignore scroll
            canvas.clipRect(mClipBounds);
        }
    }
    if (!usingRenderNodeProperties && hasDisplayList) {
        renderNode = getDisplayList();
        if (!renderNode.isValid()) {
            // Uncommon, but possible. If a view is removed from the hierarchy during the call
            // to getDisplayList(), the display list will be marked invalid and we should not
            // try to use it again.
            renderNode = null;
            hasDisplayList = false;
        }
    }
    if (hasNoCache) {
        boolean layerRendered = false;
        if (layerType == LAYER_TYPE_HARDWARE && !usingRenderNodeProperties) {
            final HardwareLayer layer = getHardwareLayer();
            if (layer != null && layer.isValid()) {
                int restoreAlpha = mLayerPaint.getAlpha();
                mLayerPaint.setAlpha((int) (alpha * 255));
                ((HardwareCanvas) canvas).drawHardwareLayer(layer, 0, 0, mLayerPaint);
                mLayerPaint.setAlpha(restoreAlpha);
                layerRendered = true;
            } else {
                final int scrollX = hasDisplayList ? 0 : sx;
                final int scrollY = hasDisplayList ? 0 : sy;
                canvas.saveLayer(scrollX, scrollY, scrollX + mRight - mLeft, scrollY + mBottom - mTop, mLayerPaint, Canvas.HAS_ALPHA_LAYER_SAVE_FLAG | Canvas.CLIP_TO_LAYER_SAVE_FLAG);
            }
        }
        if (!layerRendered) {
            if (!hasDisplayList) {
                // Fast path for layouts with no backgrounds
                if ((mPrivateFlags & PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) {
                    mPrivateFlags &= ~PFLAG_DIRTY_MASK;
                    dispatchDraw(canvas);
                } else {
                    draw(canvas);
                }
            } else {
                mPrivateFlags &= ~PFLAG_DIRTY_MASK;
                ((HardwareCanvas) canvas).drawRenderNode(renderNode, null, flags);
            }
        }
    } else if (cache != null) {
        mPrivateFlags &= ~PFLAG_DIRTY_MASK;
        Paint cachePaint;
        int restoreAlpha = 0;
        if (layerType == LAYER_TYPE_NONE) {
            cachePaint = parent.mCachePaint;
            if (cachePaint == null) {
                cachePaint = new Paint();
                cachePaint.setDither(false);
                parent.mCachePaint = cachePaint;
            }
        } else {
            cachePaint = mLayerPaint;
            restoreAlpha = mLayerPaint.getAlpha();
        }
        cachePaint.setAlpha((int) (alpha * 255));
        canvas.drawBitmap(cache, 0.0f, 0.0f, cachePaint);
        cachePaint.setAlpha(restoreAlpha);
    }
    if (restoreTo >= 0) {
        canvas.restoreToCount(restoreTo);
    }
    if (a != null && !more) {
        if (!hardwareAccelerated && !a.getFillAfter()) {
            onSetAlpha(255);
        }
        parent.finishAnimatingView(this, a);
    }
    if (more && hardwareAccelerated) {
        if (a.hasAlpha() && (mPrivateFlags & PFLAG_ALPHA_SET) == PFLAG_ALPHA_SET) {
            // alpha animations should cause the child to recreate its display list
            invalidate(true);
        }
    }
    mRecreateDisplayList = false;
    return more;
}","{
    final boolean hardwareAcceleratedCanvas = canvas.isHardwareAccelerated();
    /* If an attached view draws to a HW canvas, it may use its RenderNode + DisplayList.
         *
         * If a view is dettached, its DisplayList shouldn't exist. If the canvas isn't
         * HW accelerated, it can't handle drawing RenderNodes.
         */
    boolean drawingWithRenderNode = mAttachInfo != null && mAttachInfo.mHardwareAccelerated && hardwareAcceleratedCanvas;
    boolean more = false;
    final boolean childHasIdentityMatrix = hasIdentityMatrix();
    final int parentFlags = parent.mGroupFlags;
    if ((parentFlags & ViewGroup.FLAG_CLEAR_TRANSFORMATION) != 0) {
        parent.getChildTransformation().clear();
        parent.mGroupFlags &= ~ViewGroup.FLAG_CLEAR_TRANSFORMATION;
    }
    Transformation transformToApply = null;
    boolean concatMatrix = false;
    final boolean scalingRequired = mAttachInfo != null && mAttachInfo.mScalingRequired;
    final Animation a = getAnimation();
    if (a != null) {
        more = applyLegacyAnimation(parent, drawingTime, a, scalingRequired);
        concatMatrix = a.willChangeTransformationMatrix();
        if (concatMatrix) {
            mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_TRANSFORM;
        }
        transformToApply = parent.getChildTransformation();
    } else {
        if ((mPrivateFlags3 & PFLAG3_VIEW_IS_ANIMATING_TRANSFORM) != 0) {
            // No longer animating: clear out old animation matrix
            mRenderNode.setAnimationMatrix(null);
            mPrivateFlags3 &= ~PFLAG3_VIEW_IS_ANIMATING_TRANSFORM;
        }
        if (!drawingWithRenderNode && (parentFlags & ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != 0) {
            final Transformation t = parent.getChildTransformation();
            final boolean hasTransform = parent.getChildStaticTransformation(this, t);
            if (hasTransform) {
                final int transformType = t.getTransformationType();
                transformToApply = transformType != Transformation.TYPE_IDENTITY ? t : null;
                concatMatrix = (transformType & Transformation.TYPE_MATRIX) != 0;
            }
        }
    }
    concatMatrix |= !childHasIdentityMatrix;
    // Sets the flag as early as possible to allow draw() implementations
    // to call invalidate() successfully when doing animations
    mPrivateFlags |= PFLAG_DRAWN;
    if (!concatMatrix && (parentFlags & (ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS | ViewGroup.FLAG_CLIP_CHILDREN)) == ViewGroup.FLAG_CLIP_CHILDREN && canvas.quickReject(mLeft, mTop, mRight, mBottom, Canvas.EdgeType.BW) && (mPrivateFlags & PFLAG_DRAW_ANIMATION) == 0) {
        mPrivateFlags2 |= PFLAG2_VIEW_QUICK_REJECTED;
        return more;
    }
    mPrivateFlags2 &= ~PFLAG2_VIEW_QUICK_REJECTED;
    if (hardwareAcceleratedCanvas) {
        // Clear INVALIDATED flag to allow invalidation to occur during rendering, but
        // retain the flag's value temporarily in the mRecreateDisplayList flag
        mRecreateDisplayList = (mPrivateFlags & PFLAG_INVALIDATED) != 0;
        mPrivateFlags &= ~PFLAG_INVALIDATED;
    }
    RenderNode renderNode = null;
    Bitmap cache = null;
    // TODO: signify cache state with just 'cache' local
    int layerType = getLayerType();
    if (layerType == LAYER_TYPE_SOFTWARE || (!drawingWithRenderNode && layerType != LAYER_TYPE_NONE)) {
        // If not drawing with RenderNode, treat HW layers as SW
        layerType = LAYER_TYPE_SOFTWARE;
        buildDrawingCache(true);
        cache = getDrawingCache(true);
    }
    if (drawingWithRenderNode) {
        // Delay getting the display list until animation-driven alpha values are
        // set up and possibly passed on to the view
        renderNode = updateDisplayListIfDirty();
        if (!renderNode.isValid()) {
            // Uncommon, but possible. If a view is removed from the hierarchy during the call
            // to getDisplayList(), the display list will be marked invalid and we should not
            // try to use it again.
            renderNode = null;
            drawingWithRenderNode = false;
        }
    }
    int sx = 0;
    int sy = 0;
    if (!drawingWithRenderNode) {
        computeScroll();
        sx = mScrollX;
        sy = mScrollY;
    }
    final boolean drawingWithDrawingCache = cache != null && !drawingWithRenderNode;
    final boolean offsetForScroll = cache == null && !drawingWithRenderNode;
    int restoreTo = -1;
    if (!drawingWithRenderNode || transformToApply != null) {
        restoreTo = canvas.save();
    }
    if (offsetForScroll) {
        canvas.translate(mLeft - sx, mTop - sy);
    } else {
        if (!drawingWithRenderNode) {
            canvas.translate(mLeft, mTop);
        }
        if (scalingRequired) {
            if (drawingWithRenderNode) {
                // TODO: Might not need this if we put everything inside the DL
                restoreTo = canvas.save();
            }
            // mAttachInfo cannot be null, otherwise scalingRequired == false
            final float scale = 1.0f / mAttachInfo.mApplicationScale;
            canvas.scale(scale, scale);
        }
    }
    float alpha = drawingWithRenderNode ? 1 : (getAlpha() * getTransitionAlpha());
    if (transformToApply != null || alpha < 1 || !hasIdentityMatrix() || (mPrivateFlags3 & PFLAG3_VIEW_IS_ANIMATING_ALPHA) != 0) {
        if (transformToApply != null || !childHasIdentityMatrix) {
            int transX = 0;
            int transY = 0;
            if (offsetForScroll) {
                transX = -sx;
                transY = -sy;
            }
            if (transformToApply != null) {
                if (concatMatrix) {
                    if (drawingWithRenderNode) {
                        renderNode.setAnimationMatrix(transformToApply.getMatrix());
                    } else {
                        // Undo the scroll translation, apply the transformation matrix,
                        // then redo the scroll translate to get the correct result.
                        canvas.translate(-transX, -transY);
                        canvas.concat(transformToApply.getMatrix());
                        canvas.translate(transX, transY);
                    }
                    parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
                }
                float transformAlpha = transformToApply.getAlpha();
                if (transformAlpha < 1) {
                    alpha *= transformAlpha;
                    parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
                }
            }
            if (!childHasIdentityMatrix && !drawingWithRenderNode) {
                canvas.translate(-transX, -transY);
                canvas.concat(getMatrix());
                canvas.translate(transX, transY);
            }
        }
        // Deal with alpha if it is or used to be <1
        if (alpha < 1 || (mPrivateFlags3 & PFLAG3_VIEW_IS_ANIMATING_ALPHA) != 0) {
            if (alpha < 1) {
                mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_ALPHA;
            } else {
                mPrivateFlags3 &= ~PFLAG3_VIEW_IS_ANIMATING_ALPHA;
            }
            parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
            if (!drawingWithDrawingCache) {
                final int multipliedAlpha = (int) (255 * alpha);
                if (!onSetAlpha(multipliedAlpha)) {
                    if (drawingWithRenderNode) {
                        renderNode.setAlpha(alpha * getAlpha() * getTransitionAlpha());
                    } else if (layerType == LAYER_TYPE_NONE) {
                        canvas.saveLayerAlpha(sx, sy, sx + getWidth(), sy + getHeight(), multipliedAlpha);
                    }
                } else {
                    // Alpha is handled by the child directly, clobber the layer's alpha
                    mPrivateFlags |= PFLAG_ALPHA_SET;
                }
            }
        }
    } else if ((mPrivateFlags & PFLAG_ALPHA_SET) == PFLAG_ALPHA_SET) {
        onSetAlpha(255);
        mPrivateFlags &= ~PFLAG_ALPHA_SET;
    }
    if (!drawingWithRenderNode) {
        // apply clips directly, since RenderNode won't do it for this draw
        if ((parentFlags & ViewGroup.FLAG_CLIP_CHILDREN) != 0 && cache == null) {
            if (offsetForScroll) {
                canvas.clipRect(sx, sy, sx + getWidth(), sy + getHeight());
            } else {
                if (!scalingRequired || cache == null) {
                    canvas.clipRect(0, 0, getWidth(), getHeight());
                } else {
                    canvas.clipRect(0, 0, cache.getWidth(), cache.getHeight());
                }
            }
        }
        if (mClipBounds != null) {
            // clip bounds ignore scroll
            canvas.clipRect(mClipBounds);
        }
    }
    if (!drawingWithDrawingCache) {
        if (drawingWithRenderNode) {
            mPrivateFlags &= ~PFLAG_DIRTY_MASK;
            ((DisplayListCanvas) canvas).drawRenderNode(renderNode);
        } else {
            // Fast path for layouts with no backgrounds
            if ((mPrivateFlags & PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) {
                mPrivateFlags &= ~PFLAG_DIRTY_MASK;
                dispatchDraw(canvas);
            } else {
                draw(canvas);
            }
        }
    } else if (cache != null) {
        mPrivateFlags &= ~PFLAG_DIRTY_MASK;
        if (layerType == LAYER_TYPE_NONE) {
            // no layer paint, use temporary paint to draw bitmap
            Paint cachePaint = parent.mCachePaint;
            if (cachePaint == null) {
                cachePaint = new Paint();
                cachePaint.setDither(false);
                parent.mCachePaint = cachePaint;
            }
            cachePaint.setAlpha((int) (alpha * 255));
            canvas.drawBitmap(cache, 0.0f, 0.0f, cachePaint);
        } else {
            // use layer paint to draw the bitmap, merging the two alphas, but also restore
            int layerPaintAlpha = mLayerPaint.getAlpha();
            mLayerPaint.setAlpha((int) (alpha * layerPaintAlpha));
            canvas.drawBitmap(cache, 0.0f, 0.0f, mLayerPaint);
            mLayerPaint.setAlpha(layerPaintAlpha);
        }
    }
    if (restoreTo >= 0) {
        canvas.restoreToCount(restoreTo);
    }
    if (a != null && !more) {
        if (!hardwareAcceleratedCanvas && !a.getFillAfter()) {
            onSetAlpha(255);
        }
        parent.finishAnimatingView(this, a);
    }
    if (more && hardwareAcceleratedCanvas) {
        if (a.hasAlpha() && (mPrivateFlags & PFLAG_ALPHA_SET) == PFLAG_ALPHA_SET) {
            // alpha animations should cause the child to recreate its display list
            invalidate(true);
        }
    }
    mRecreateDisplayList = false;
    return more;
}",1,"/**
 * This method is called by ViewGroup.drawChild() to have each child view draw itself.
 * This draw() method is an implementation detail and is not intended to be overridden or
 * to be called from anywhere else other than ViewGroup.drawChild().
 */
","/**
 * This method is called by ViewGroup.drawChild() to have each child view draw itself.
 *
 * This is where the View specializes rendering behavior based on layer type,
 * and hardware acceleration.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
186,<android.widget.TextView: Parcelable onSaveInstanceState()>,22,23,<android.widget.TextView: Parcelable onSaveInstanceState()>,<android.widget.TextView: Parcelable onSaveInstanceState()>,0,"{
    Parcelable superState = super.onSaveInstanceState();
    // Save state if we are forced to
    boolean save = mFreezesText;
    int start = 0;
    int end = 0;
    if (mText != null) {
        start = getSelectionStart();
        end = getSelectionEnd();
        if (start >= 0 || end >= 0) {
            // Or save state if there is a selection
            save = true;
        }
    }
    if (save) {
        SavedState ss = new SavedState(superState);
        // XXX Should also save the current scroll position!
        ss.selStart = start;
        ss.selEnd = end;
        if (mText instanceof Spanned) {
            Spannable sp = new SpannableStringBuilder(mText);
            if (mEditor != null) {
                removeMisspelledSpans(sp);
                sp.removeSpan(mEditor.mSuggestionRangeSpan);
            }
            ss.text = sp;
        } else {
            ss.text = mText.toString();
        }
        if (isFocused() && start >= 0 && end >= 0) {
            ss.frozenWithFocus = true;
        }
        ss.error = getError();
        return ss;
    }
    return superState;
}","{
    Parcelable superState = super.onSaveInstanceState();
    // Save state if we are forced to
    boolean save = mFreezesText;
    int start = 0;
    int end = 0;
    if (mText != null) {
        start = getSelectionStart();
        end = getSelectionEnd();
        if (start >= 0 || end >= 0) {
            // Or save state if there is a selection
            save = true;
        }
    }
    if (save) {
        SavedState ss = new SavedState(superState);
        // XXX Should also save the current scroll position!
        ss.selStart = start;
        ss.selEnd = end;
        if (mText instanceof Spanned) {
            Spannable sp = new SpannableStringBuilder(mText);
            if (mEditor != null) {
                removeMisspelledSpans(sp);
                sp.removeSpan(mEditor.mSuggestionRangeSpan);
            }
            ss.text = sp;
        } else {
            ss.text = mText.toString();
        }
        if (isFocused() && start >= 0 && end >= 0) {
            ss.frozenWithFocus = true;
        }
        ss.error = getError();
        if (mEditor != null) {
            ss.editorState = mEditor.saveInstanceState();
        }
        return ss;
    }
    return superState;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"An if condition and a statement that assigns 'ss.editorState' have been added to the late version of the implementation. It is not under any existing control statements, so the change type is 4. However, since this statement could lead to a change in the returned 'SavedState' object by including additional state information from 'mEditor', the return statement is effectively changed too. Hence the change type is both 1 and 4.","Because 'ss.editorState' is a new field that is set in the late version which may introduce additional state into the 'SavedState' object returned by the method, the return value is altered compared to the early version. Therefore, a compatibility issue could arise due to potential differences in the returned Parcelable object, and the CI type is 1."
187,"<android.os.Parcel: void writeParcelable(Parcelable,int)>",22,23,"<android.os.Parcel: void writeParcelable(Parcelable,int)>","<android.os.Parcel: void writeParcelable(Parcelable,int)>",0,"{
    if (p == null) {
        writeString(null);
        return;
    }
    String name = p.getClass().getName();
    writeString(name);
    p.writeToParcel(this, parcelableFlags);
}","{
    if (p == null) {
        writeString(null);
        return;
    }
    writeParcelableCreator(p);
    p.writeToParcel(this, parcelableFlags);
}",1,"/**
 * Flatten the name of the class of the Parcelable and its contents
 * into the parcel.
 *
 * @param p The Parcelable object to be written.
 * @param parcelableFlags Contextual flags as per
 * {@link Parcelable#writeToParcel(Parcel, int) Parcelable.writeToParcel()}.
 */
","/**
 * Flatten the name of the class of the Parcelable and its contents
 * into the parcel.
 *
 * @param p The Parcelable object to be written.
 * @param parcelableFlags Contextual flags as per
 * {@link Parcelable#writeToParcel(Parcel, int) Parcelable.writeToParcel()}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The early implementation explicitly writes the class name of the Parcelable and then writes the Parcelable content, while the late implementation calls writeParcelableCreator which presumably writes necessary information about the Parcelable, including the class name, before writing its content. This is an other statement change, and since writeParcelableCreator is a method that presumably retrieves the class name internally and is not part of the earlier implementation, this is also a dependent API change. Thus, the code change type is 4,5.","There is no compatibility issue as the behavior and contract of the method seem preserved: it still writes necessary information before the Parcelable content is written to the Parcel, even though the internal method of writing this information has changed. The return type and the exception handling have not changed, so there is no compatibility issue, which is type 0."
189,"<android.os.storage.IMountService.Stub: boolean onTransact(int,Parcel,Parcel,int)>",22,23,"<android.os.storage.IMountService.Stub: boolean onTransact(int,Parcel,Parcel,int)>","<android.os.storage.IMountService.Stub: boolean onTransact(int,Parcel,Parcel,int)>",0,"{
    switch(code) {
        case INTERFACE_TRANSACTION:
            {
                reply.writeString(DESCRIPTOR);
                return true;
            }
        case TRANSACTION_registerListener:
            {
                data.enforceInterface(DESCRIPTOR);
                IMountServiceListener listener;
                listener = IMountServiceListener.Stub.asInterface(data.readStrongBinder());
                registerListener(listener);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_unregisterListener:
            {
                data.enforceInterface(DESCRIPTOR);
                IMountServiceListener listener;
                listener = IMountServiceListener.Stub.asInterface(data.readStrongBinder());
                unregisterListener(listener);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_isUsbMassStorageConnected:
            {
                data.enforceInterface(DESCRIPTOR);
                boolean result = isUsbMassStorageConnected();
                reply.writeNoException();
                reply.writeInt((result ? 1 : 0));
                return true;
            }
        case TRANSACTION_setUsbMassStorageEnabled:
            {
                data.enforceInterface(DESCRIPTOR);
                boolean enable;
                enable = 0 != data.readInt();
                setUsbMassStorageEnabled(enable);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_isUsbMassStorageEnabled:
            {
                data.enforceInterface(DESCRIPTOR);
                boolean result = isUsbMassStorageEnabled();
                reply.writeNoException();
                reply.writeInt((result ? 1 : 0));
                return true;
            }
        case TRANSACTION_mountVolume:
            {
                data.enforceInterface(DESCRIPTOR);
                String mountPoint;
                mountPoint = data.readString();
                int resultCode = mountVolume(mountPoint);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_unmountVolume:
            {
                data.enforceInterface(DESCRIPTOR);
                String mountPoint;
                mountPoint = data.readString();
                boolean force = 0 != data.readInt();
                boolean removeEncrypt = 0 != data.readInt();
                unmountVolume(mountPoint, force, removeEncrypt);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_formatVolume:
            {
                data.enforceInterface(DESCRIPTOR);
                String mountPoint;
                mountPoint = data.readString();
                int result = formatVolume(mountPoint);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_getStorageUsers:
            {
                data.enforceInterface(DESCRIPTOR);
                String path;
                path = data.readString();
                int[] pids = getStorageUsers(path);
                reply.writeNoException();
                reply.writeIntArray(pids);
                return true;
            }
        case TRANSACTION_getVolumeState:
            {
                data.enforceInterface(DESCRIPTOR);
                String mountPoint;
                mountPoint = data.readString();
                String state = getVolumeState(mountPoint);
                reply.writeNoException();
                reply.writeString(state);
                return true;
            }
        case TRANSACTION_createSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                int sizeMb;
                sizeMb = data.readInt();
                String fstype;
                fstype = data.readString();
                String key;
                key = data.readString();
                int ownerUid;
                ownerUid = data.readInt();
                boolean external;
                external = 0 != data.readInt();
                int resultCode = createSecureContainer(id, sizeMb, fstype, key, ownerUid, external);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_finalizeSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                int resultCode = finalizeSecureContainer(id);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_destroySecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                boolean force;
                force = 0 != data.readInt();
                int resultCode = destroySecureContainer(id, force);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_mountSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                String key;
                key = data.readString();
                int ownerUid;
                ownerUid = data.readInt();
                boolean readOnly;
                readOnly = data.readInt() != 0;
                int resultCode = mountSecureContainer(id, key, ownerUid, readOnly);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_unmountSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                boolean force;
                force = 0 != data.readInt();
                int resultCode = unmountSecureContainer(id, force);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_isSecureContainerMounted:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                boolean status = isSecureContainerMounted(id);
                reply.writeNoException();
                reply.writeInt((status ? 1 : 0));
                return true;
            }
        case TRANSACTION_renameSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String oldId;
                oldId = data.readString();
                String newId;
                newId = data.readString();
                int resultCode = renameSecureContainer(oldId, newId);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_getSecureContainerPath:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                String path = getSecureContainerPath(id);
                reply.writeNoException();
                reply.writeString(path);
                return true;
            }
        case TRANSACTION_getSecureContainerList:
            {
                data.enforceInterface(DESCRIPTOR);
                String[] ids = getSecureContainerList();
                reply.writeNoException();
                reply.writeStringArray(ids);
                return true;
            }
        case TRANSACTION_shutdown:
            {
                data.enforceInterface(DESCRIPTOR);
                IMountShutdownObserver observer;
                observer = IMountShutdownObserver.Stub.asInterface(data.readStrongBinder());
                shutdown(observer);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_finishMediaUpdate:
            {
                data.enforceInterface(DESCRIPTOR);
                finishMediaUpdate();
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_mountObb:
            {
                data.enforceInterface(DESCRIPTOR);
                final String rawPath = data.readString();
                final String canonicalPath = data.readString();
                final String key = data.readString();
                IObbActionListener observer;
                observer = IObbActionListener.Stub.asInterface(data.readStrongBinder());
                int nonce;
                nonce = data.readInt();
                mountObb(rawPath, canonicalPath, key, observer, nonce);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_unmountObb:
            {
                data.enforceInterface(DESCRIPTOR);
                String filename;
                filename = data.readString();
                boolean force;
                force = 0 != data.readInt();
                IObbActionListener observer;
                observer = IObbActionListener.Stub.asInterface(data.readStrongBinder());
                int nonce;
                nonce = data.readInt();
                unmountObb(filename, force, observer, nonce);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_isObbMounted:
            {
                data.enforceInterface(DESCRIPTOR);
                String filename;
                filename = data.readString();
                boolean status = isObbMounted(filename);
                reply.writeNoException();
                reply.writeInt((status ? 1 : 0));
                return true;
            }
        case TRANSACTION_getMountedObbPath:
            {
                data.enforceInterface(DESCRIPTOR);
                String filename;
                filename = data.readString();
                String mountedPath = getMountedObbPath(filename);
                reply.writeNoException();
                reply.writeString(mountedPath);
                return true;
            }
        case TRANSACTION_isExternalStorageEmulated:
            {
                data.enforceInterface(DESCRIPTOR);
                boolean emulated = isExternalStorageEmulated();
                reply.writeNoException();
                reply.writeInt(emulated ? 1 : 0);
                return true;
            }
        case TRANSACTION_decryptStorage:
            {
                data.enforceInterface(DESCRIPTOR);
                String password = data.readString();
                int result = decryptStorage(password);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_encryptStorage:
            {
                data.enforceInterface(DESCRIPTOR);
                int type = data.readInt();
                String password = data.readString();
                int result = encryptStorage(type, password);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_changeEncryptionPassword:
            {
                data.enforceInterface(DESCRIPTOR);
                int type = data.readInt();
                String password = data.readString();
                int result = changeEncryptionPassword(type, password);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_getVolumeList:
            {
                data.enforceInterface(DESCRIPTOR);
                StorageVolume[] result = getVolumeList();
                reply.writeNoException();
                reply.writeTypedArray(result, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
                return true;
            }
        case TRANSACTION_getSecureContainerFilesystemPath:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                String path = getSecureContainerFilesystemPath(id);
                reply.writeNoException();
                reply.writeString(path);
                return true;
            }
        case TRANSACTION_getEncryptionState:
            {
                data.enforceInterface(DESCRIPTOR);
                int result = getEncryptionState();
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_fixPermissionsSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                int gid;
                gid = data.readInt();
                String filename;
                filename = data.readString();
                int resultCode = fixPermissionsSecureContainer(id, gid, filename);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_mkdirs:
            {
                data.enforceInterface(DESCRIPTOR);
                String callingPkg = data.readString();
                String path = data.readString();
                int result = mkdirs(callingPkg, path);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_getPasswordType:
            {
                data.enforceInterface(DESCRIPTOR);
                int result = getPasswordType();
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_getPassword:
            {
                data.enforceInterface(DESCRIPTOR);
                String result = getPassword();
                reply.writeNoException();
                reply.writeString(result);
                return true;
            }
        case TRANSACTION_clearPassword:
            {
                data.enforceInterface(DESCRIPTOR);
                clearPassword();
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_setField:
            {
                data.enforceInterface(DESCRIPTOR);
                String field = data.readString();
                String contents = data.readString();
                setField(field, contents);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_getField:
            {
                data.enforceInterface(DESCRIPTOR);
                String field = data.readString();
                String contents = getField(field);
                reply.writeNoException();
                reply.writeString(contents);
                return true;
            }
        case TRANSACTION_resizeSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                int sizeMb;
                sizeMb = data.readInt();
                String key;
                key = data.readString();
                int resultCode = resizeSecureContainer(id, sizeMb, key);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_lastMaintenance:
            {
                data.enforceInterface(DESCRIPTOR);
                long lastMaintenance = lastMaintenance();
                reply.writeNoException();
                reply.writeLong(lastMaintenance);
                return true;
            }
        case TRANSACTION_runMaintenance:
            {
                data.enforceInterface(DESCRIPTOR);
                runMaintenance();
                reply.writeNoException();
                return true;
            }
    }
    return super.onTransact(code, data, reply, flags);
}","{
    switch(code) {
        case INTERFACE_TRANSACTION:
            {
                reply.writeString(DESCRIPTOR);
                return true;
            }
        case TRANSACTION_registerListener:
            {
                data.enforceInterface(DESCRIPTOR);
                IMountServiceListener listener;
                listener = IMountServiceListener.Stub.asInterface(data.readStrongBinder());
                registerListener(listener);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_unregisterListener:
            {
                data.enforceInterface(DESCRIPTOR);
                IMountServiceListener listener;
                listener = IMountServiceListener.Stub.asInterface(data.readStrongBinder());
                unregisterListener(listener);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_isUsbMassStorageConnected:
            {
                data.enforceInterface(DESCRIPTOR);
                boolean result = isUsbMassStorageConnected();
                reply.writeNoException();
                reply.writeInt((result ? 1 : 0));
                return true;
            }
        case TRANSACTION_setUsbMassStorageEnabled:
            {
                data.enforceInterface(DESCRIPTOR);
                boolean enable;
                enable = 0 != data.readInt();
                setUsbMassStorageEnabled(enable);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_isUsbMassStorageEnabled:
            {
                data.enforceInterface(DESCRIPTOR);
                boolean result = isUsbMassStorageEnabled();
                reply.writeNoException();
                reply.writeInt((result ? 1 : 0));
                return true;
            }
        case TRANSACTION_mountVolume:
            {
                data.enforceInterface(DESCRIPTOR);
                String mountPoint;
                mountPoint = data.readString();
                int resultCode = mountVolume(mountPoint);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_unmountVolume:
            {
                data.enforceInterface(DESCRIPTOR);
                String mountPoint;
                mountPoint = data.readString();
                boolean force = 0 != data.readInt();
                boolean removeEncrypt = 0 != data.readInt();
                unmountVolume(mountPoint, force, removeEncrypt);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_formatVolume:
            {
                data.enforceInterface(DESCRIPTOR);
                String mountPoint;
                mountPoint = data.readString();
                int result = formatVolume(mountPoint);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_getStorageUsers:
            {
                data.enforceInterface(DESCRIPTOR);
                String path;
                path = data.readString();
                int[] pids = getStorageUsers(path);
                reply.writeNoException();
                reply.writeIntArray(pids);
                return true;
            }
        case TRANSACTION_getVolumeState:
            {
                data.enforceInterface(DESCRIPTOR);
                String mountPoint;
                mountPoint = data.readString();
                String state = getVolumeState(mountPoint);
                reply.writeNoException();
                reply.writeString(state);
                return true;
            }
        case TRANSACTION_createSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                int sizeMb;
                sizeMb = data.readInt();
                String fstype;
                fstype = data.readString();
                String key;
                key = data.readString();
                int ownerUid;
                ownerUid = data.readInt();
                boolean external;
                external = 0 != data.readInt();
                int resultCode = createSecureContainer(id, sizeMb, fstype, key, ownerUid, external);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_finalizeSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                int resultCode = finalizeSecureContainer(id);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_destroySecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                boolean force;
                force = 0 != data.readInt();
                int resultCode = destroySecureContainer(id, force);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_mountSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                String key;
                key = data.readString();
                int ownerUid;
                ownerUid = data.readInt();
                boolean readOnly;
                readOnly = data.readInt() != 0;
                int resultCode = mountSecureContainer(id, key, ownerUid, readOnly);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_unmountSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                boolean force;
                force = 0 != data.readInt();
                int resultCode = unmountSecureContainer(id, force);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_isSecureContainerMounted:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                boolean status = isSecureContainerMounted(id);
                reply.writeNoException();
                reply.writeInt((status ? 1 : 0));
                return true;
            }
        case TRANSACTION_renameSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String oldId;
                oldId = data.readString();
                String newId;
                newId = data.readString();
                int resultCode = renameSecureContainer(oldId, newId);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_getSecureContainerPath:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                String path = getSecureContainerPath(id);
                reply.writeNoException();
                reply.writeString(path);
                return true;
            }
        case TRANSACTION_getSecureContainerList:
            {
                data.enforceInterface(DESCRIPTOR);
                String[] ids = getSecureContainerList();
                reply.writeNoException();
                reply.writeStringArray(ids);
                return true;
            }
        case TRANSACTION_shutdown:
            {
                data.enforceInterface(DESCRIPTOR);
                IMountShutdownObserver observer;
                observer = IMountShutdownObserver.Stub.asInterface(data.readStrongBinder());
                shutdown(observer);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_finishMediaUpdate:
            {
                data.enforceInterface(DESCRIPTOR);
                finishMediaUpdate();
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_mountObb:
            {
                data.enforceInterface(DESCRIPTOR);
                final String rawPath = data.readString();
                final String canonicalPath = data.readString();
                final String key = data.readString();
                IObbActionListener observer;
                observer = IObbActionListener.Stub.asInterface(data.readStrongBinder());
                int nonce;
                nonce = data.readInt();
                mountObb(rawPath, canonicalPath, key, observer, nonce);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_unmountObb:
            {
                data.enforceInterface(DESCRIPTOR);
                String filename;
                filename = data.readString();
                boolean force;
                force = 0 != data.readInt();
                IObbActionListener observer;
                observer = IObbActionListener.Stub.asInterface(data.readStrongBinder());
                int nonce;
                nonce = data.readInt();
                unmountObb(filename, force, observer, nonce);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_isObbMounted:
            {
                data.enforceInterface(DESCRIPTOR);
                String filename;
                filename = data.readString();
                boolean status = isObbMounted(filename);
                reply.writeNoException();
                reply.writeInt((status ? 1 : 0));
                return true;
            }
        case TRANSACTION_getMountedObbPath:
            {
                data.enforceInterface(DESCRIPTOR);
                String filename;
                filename = data.readString();
                String mountedPath = getMountedObbPath(filename);
                reply.writeNoException();
                reply.writeString(mountedPath);
                return true;
            }
        case TRANSACTION_isExternalStorageEmulated:
            {
                data.enforceInterface(DESCRIPTOR);
                boolean emulated = isExternalStorageEmulated();
                reply.writeNoException();
                reply.writeInt(emulated ? 1 : 0);
                return true;
            }
        case TRANSACTION_decryptStorage:
            {
                data.enforceInterface(DESCRIPTOR);
                String password = data.readString();
                int result = decryptStorage(password);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_encryptStorage:
            {
                data.enforceInterface(DESCRIPTOR);
                int type = data.readInt();
                String password = data.readString();
                int result = encryptStorage(type, password);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_changeEncryptionPassword:
            {
                data.enforceInterface(DESCRIPTOR);
                int type = data.readInt();
                String password = data.readString();
                int result = changeEncryptionPassword(type, password);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_getVolumeList:
            {
                data.enforceInterface(DESCRIPTOR);
                int uid = data.readInt();
                String packageName = data.readString();
                int _flags = data.readInt();
                StorageVolume[] result = getVolumeList(uid, packageName, _flags);
                reply.writeNoException();
                reply.writeTypedArray(result, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
                return true;
            }
        case TRANSACTION_getSecureContainerFilesystemPath:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                String path = getSecureContainerFilesystemPath(id);
                reply.writeNoException();
                reply.writeString(path);
                return true;
            }
        case TRANSACTION_getEncryptionState:
            {
                data.enforceInterface(DESCRIPTOR);
                int result = getEncryptionState();
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_fixPermissionsSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                int gid;
                gid = data.readInt();
                String filename;
                filename = data.readString();
                int resultCode = fixPermissionsSecureContainer(id, gid, filename);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_mkdirs:
            {
                data.enforceInterface(DESCRIPTOR);
                String callingPkg = data.readString();
                String path = data.readString();
                int result = mkdirs(callingPkg, path);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_getPasswordType:
            {
                data.enforceInterface(DESCRIPTOR);
                int result = getPasswordType();
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_getPassword:
            {
                data.enforceInterface(DESCRIPTOR);
                String result = getPassword();
                reply.writeNoException();
                reply.writeString(result);
                return true;
            }
        case TRANSACTION_clearPassword:
            {
                data.enforceInterface(DESCRIPTOR);
                clearPassword();
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_setField:
            {
                data.enforceInterface(DESCRIPTOR);
                String field = data.readString();
                String contents = data.readString();
                setField(field, contents);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_getField:
            {
                data.enforceInterface(DESCRIPTOR);
                String field = data.readString();
                String contents = getField(field);
                reply.writeNoException();
                reply.writeString(contents);
                return true;
            }
        case TRANSACTION_resizeSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                int sizeMb;
                sizeMb = data.readInt();
                String key;
                key = data.readString();
                int resultCode = resizeSecureContainer(id, sizeMb, key);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_lastMaintenance:
            {
                data.enforceInterface(DESCRIPTOR);
                long lastMaintenance = lastMaintenance();
                reply.writeNoException();
                reply.writeLong(lastMaintenance);
                return true;
            }
        case TRANSACTION_runMaintenance:
            {
                data.enforceInterface(DESCRIPTOR);
                runMaintenance();
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_waitForAsecScan:
            {
                data.enforceInterface(DESCRIPTOR);
                waitForAsecScan();
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_getDisks:
            {
                data.enforceInterface(DESCRIPTOR);
                DiskInfo[] disks = getDisks();
                reply.writeNoException();
                reply.writeTypedArray(disks, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
                return true;
            }
        case TRANSACTION_getVolumes:
            {
                data.enforceInterface(DESCRIPTOR);
                int _flags = data.readInt();
                VolumeInfo[] volumes = getVolumes(_flags);
                reply.writeNoException();
                reply.writeTypedArray(volumes, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
                return true;
            }
        case TRANSACTION_getVolumeRecords:
            {
                data.enforceInterface(DESCRIPTOR);
                int _flags = data.readInt();
                VolumeRecord[] volumes = getVolumeRecords(_flags);
                reply.writeNoException();
                reply.writeTypedArray(volumes, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
                return true;
            }
        case TRANSACTION_mount:
            {
                data.enforceInterface(DESCRIPTOR);
                String volId = data.readString();
                mount(volId);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_unmount:
            {
                data.enforceInterface(DESCRIPTOR);
                String volId = data.readString();
                unmount(volId);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_format:
            {
                data.enforceInterface(DESCRIPTOR);
                String volId = data.readString();
                format(volId);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_benchmark:
            {
                data.enforceInterface(DESCRIPTOR);
                String volId = data.readString();
                long res = benchmark(volId);
                reply.writeNoException();
                reply.writeLong(res);
                return true;
            }
        case TRANSACTION_partitionPublic:
            {
                data.enforceInterface(DESCRIPTOR);
                String diskId = data.readString();
                partitionPublic(diskId);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_partitionPrivate:
            {
                data.enforceInterface(DESCRIPTOR);
                String diskId = data.readString();
                partitionPrivate(diskId);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_partitionMixed:
            {
                data.enforceInterface(DESCRIPTOR);
                String diskId = data.readString();
                int ratio = data.readInt();
                partitionMixed(diskId, ratio);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_setVolumeNickname:
            {
                data.enforceInterface(DESCRIPTOR);
                String volId = data.readString();
                String nickname = data.readString();
                setVolumeNickname(volId, nickname);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_setVolumeUserFlags:
            {
                data.enforceInterface(DESCRIPTOR);
                String volId = data.readString();
                int _flags = data.readInt();
                int _mask = data.readInt();
                setVolumeUserFlags(volId, _flags, _mask);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_forgetVolume:
            {
                data.enforceInterface(DESCRIPTOR);
                String fsUuid = data.readString();
                forgetVolume(fsUuid);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_forgetAllVolumes:
            {
                data.enforceInterface(DESCRIPTOR);
                forgetAllVolumes();
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_setDebugFlags:
            {
                data.enforceInterface(DESCRIPTOR);
                int _flags = data.readInt();
                int _mask = data.readInt();
                setDebugFlags(_flags, _mask);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_getPrimaryStorageUuid:
            {
                data.enforceInterface(DESCRIPTOR);
                String volumeUuid = getPrimaryStorageUuid();
                reply.writeNoException();
                reply.writeString(volumeUuid);
                return true;
            }
        case TRANSACTION_setPrimaryStorageUuid:
            {
                data.enforceInterface(DESCRIPTOR);
                String volumeUuid = data.readString();
                IPackageMoveObserver listener = IPackageMoveObserver.Stub.asInterface(data.readStrongBinder());
                setPrimaryStorageUuid(volumeUuid, listener);
                reply.writeNoException();
                return true;
            }
    }
    return super.onTransact(code, data, reply, flags);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
190,"<android.content.pm.LauncherApps: void registerCallback(Callback,Handler)>",22,23,"<android.content.pm.LauncherApps: void registerCallback(Callback,Handler)>","<android.content.pm.LauncherApps: void registerCallback(Callback,Handler)>",0,"{
    synchronized (this) {
        if (callback != null && !mCallbacks.contains(callback)) {
            boolean addedFirstCallback = mCallbacks.size() == 0;
            addCallbackLocked(callback, handler);
            if (addedFirstCallback) {
                try {
                    mService.addOnAppsChangedListener(mAppsChangedListener);
                } catch (RemoteException re) {
                }
            }
        }
    }
}","{
    synchronized (this) {
        if (callback != null && findCallbackLocked(callback) < 0) {
            boolean addedFirstCallback = mCallbacks.size() == 0;
            addCallbackLocked(callback, handler);
            if (addedFirstCallback) {
                try {
                    mService.addOnAppsChangedListener(mAppsChangedListener);
                } catch (RemoteException re) {
                }
            }
        }
    }
}",1,"/**
 * Registers a callback for changes to packages in current and managed profiles.
 *
 * @param callback The callback to register.
 * @param handler that should be used to post callbacks on, may be null.
 */
","/**
 * Registers a callback for changes to packages in current and managed profiles.
 *
 * @param callback The callback to register.
 * @param handler that should be used to post callbacks on, may be null.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,5",0,"The change from '!mCallbacks.contains(callback)' to 'findCallbackLocked(callback) < 0' represents a change in the control dependency (3) and dependent API changed (5) because the way of checking the existence of the callback in the list has been altered, indicating a change in the underlying API used for this check.","There is no Compatibility Issue because the change in method of checking callback existence does not affect the behavior visible to the caller: a callback is either registered or not, and the mechanism by which that determination is made does not change the outcome."
192,<android.widget.TextView: int getCompoundPaddingRight()>,22,23,<android.widget.TextView: int getCompoundPaddingRight()>,<android.widget.TextView: int getCompoundPaddingRight()>,0,"{
    final Drawables dr = mDrawables;
    if (dr == null || dr.mDrawableRight == null) {
        return mPaddingRight;
    } else {
        return mPaddingRight + dr.mDrawablePadding + dr.mDrawableSizeRight;
    }
}","{
    final Drawables dr = mDrawables;
    if (dr == null || dr.mShowing[Drawables.RIGHT] == null) {
        return mPaddingRight;
    } else {
        return mPaddingRight + dr.mDrawablePadding + dr.mDrawableSizeRight;
    }
}",1,"/**
 * Returns the right padding of the view, plus space for the right
 * Drawable if any.
 */
","/**
 * Returns the right padding of the view, plus space for the right
 * Drawable if any.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation has changed only in the access of the drawable right check from dr.mDrawableRight to dr.mShowing[Drawables.RIGHT], which represents a check on a different field or array element within the Drawables inner class, so the code change type is 4. Furthermore, since this change is due to accessing a different field/member of Drawables, this is also classified as a dependent API change, hence type 5.","There is no Compatibility Issue detected, because although the implementation checks a different field for nullity, the logic of returning either mPaddingRight or the calculated padding remains the same. The change does not affect the method's return type, the values returned, or the exception handling, therefore, no CI arises, so the CI type is 0."
195,<android.view.accessibility.AccessibilityEvent: String eventTypeToString(int)>,22,23,<android.view.accessibility.AccessibilityEvent: String eventTypeToString(int)>,<android.view.accessibility.AccessibilityEvent: String eventTypeToString(int)>,0,"{
    if (eventType == TYPES_ALL_MASK) {
        return ""TYPES_ALL_MASK"";
    }
    StringBuilder builder = new StringBuilder();
    int eventTypeCount = 0;
    while (eventType != 0) {
        final int eventTypeFlag = 1 << Integer.numberOfTrailingZeros(eventType);
        eventType &= ~eventTypeFlag;
        switch(eventTypeFlag) {
            case TYPE_VIEW_CLICKED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_CLICKED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_LONG_CLICKED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_LONG_CLICKED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_SELECTED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_SELECTED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_FOCUSED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_FOCUSED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_TEXT_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_TEXT_CHANGED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_WINDOW_STATE_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_WINDOW_STATE_CHANGED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_HOVER_ENTER:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_HOVER_ENTER"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_HOVER_EXIT:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_HOVER_EXIT"");
                    eventTypeCount++;
                }
                break;
            case TYPE_NOTIFICATION_STATE_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_NOTIFICATION_STATE_CHANGED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_TOUCH_EXPLORATION_GESTURE_START:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_TOUCH_EXPLORATION_GESTURE_START"");
                    eventTypeCount++;
                }
                break;
            case TYPE_TOUCH_EXPLORATION_GESTURE_END:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_TOUCH_EXPLORATION_GESTURE_END"");
                    eventTypeCount++;
                }
                break;
            case TYPE_WINDOW_CONTENT_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_WINDOW_CONTENT_CHANGED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_TEXT_SELECTION_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_TEXT_SELECTION_CHANGED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_SCROLLED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_SCROLLED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_ANNOUNCEMENT:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_ANNOUNCEMENT"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_ACCESSIBILITY_FOCUSED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_ACCESSIBILITY_FOCUSED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_TEXT_TRAVERSED_AT_MOVEMENT_GRANULARITY:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_TEXT_TRAVERSED_AT_MOVEMENT_GRANULARITY"");
                    eventTypeCount++;
                }
                break;
            case TYPE_GESTURE_DETECTION_START:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_GESTURE_DETECTION_START"");
                    eventTypeCount++;
                }
                break;
            case TYPE_GESTURE_DETECTION_END:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_GESTURE_DETECTION_END"");
                    eventTypeCount++;
                }
                break;
            case TYPE_TOUCH_INTERACTION_START:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_TOUCH_INTERACTION_START"");
                    eventTypeCount++;
                }
                break;
            case TYPE_TOUCH_INTERACTION_END:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_TOUCH_INTERACTION_END"");
                    eventTypeCount++;
                }
                break;
            case TYPE_WINDOWS_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_WINDOWS_CHANGED"");
                    eventTypeCount++;
                }
                break;
        }
    }
    if (eventTypeCount > 1) {
        builder.insert(0, '[');
        builder.append(']');
    }
    return builder.toString();
}","{
    if (eventType == TYPES_ALL_MASK) {
        return ""TYPES_ALL_MASK"";
    }
    StringBuilder builder = new StringBuilder();
    int eventTypeCount = 0;
    while (eventType != 0) {
        final int eventTypeFlag = 1 << Integer.numberOfTrailingZeros(eventType);
        eventType &= ~eventTypeFlag;
        switch(eventTypeFlag) {
            case TYPE_VIEW_CLICKED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_CLICKED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_LONG_CLICKED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_LONG_CLICKED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_SELECTED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_SELECTED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_FOCUSED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_FOCUSED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_TEXT_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_TEXT_CHANGED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_WINDOW_STATE_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_WINDOW_STATE_CHANGED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_HOVER_ENTER:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_HOVER_ENTER"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_HOVER_EXIT:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_HOVER_EXIT"");
                    eventTypeCount++;
                }
                break;
            case TYPE_NOTIFICATION_STATE_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_NOTIFICATION_STATE_CHANGED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_TOUCH_EXPLORATION_GESTURE_START:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_TOUCH_EXPLORATION_GESTURE_START"");
                    eventTypeCount++;
                }
                break;
            case TYPE_TOUCH_EXPLORATION_GESTURE_END:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_TOUCH_EXPLORATION_GESTURE_END"");
                    eventTypeCount++;
                }
                break;
            case TYPE_WINDOW_CONTENT_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_WINDOW_CONTENT_CHANGED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_TEXT_SELECTION_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_TEXT_SELECTION_CHANGED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_SCROLLED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_SCROLLED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_ANNOUNCEMENT:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_ANNOUNCEMENT"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_ACCESSIBILITY_FOCUSED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_ACCESSIBILITY_FOCUSED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_TEXT_TRAVERSED_AT_MOVEMENT_GRANULARITY:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_TEXT_TRAVERSED_AT_MOVEMENT_GRANULARITY"");
                    eventTypeCount++;
                }
                break;
            case TYPE_GESTURE_DETECTION_START:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_GESTURE_DETECTION_START"");
                    eventTypeCount++;
                }
                break;
            case TYPE_GESTURE_DETECTION_END:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_GESTURE_DETECTION_END"");
                    eventTypeCount++;
                }
                break;
            case TYPE_TOUCH_INTERACTION_START:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_TOUCH_INTERACTION_START"");
                    eventTypeCount++;
                }
                break;
            case TYPE_TOUCH_INTERACTION_END:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_TOUCH_INTERACTION_END"");
                    eventTypeCount++;
                }
                break;
            case TYPE_WINDOWS_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_WINDOWS_CHANGED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_CONTEXT_CLICKED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_CONTEXT_CLICKED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_ASSIST_READING_CONTEXT:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_ASSIST_READING_CONTEXT"");
                    eventTypeCount++;
                }
                break;
        }
    }
    if (eventTypeCount > 1) {
        builder.insert(0, '[');
        builder.append(']');
    }
    return builder.toString();
}",1,"/**
 * Returns the string representation of an event type. For example,
 * {@link #TYPE_VIEW_CLICKED} is represented by the string TYPE_VIEW_CLICKED.
 *
 * @param eventType The event type
 * @return The string representation.
 */
","/**
 * Returns the string representation of an event type. For example,
 * {@link #TYPE_VIEW_CLICKED} is represented by the string TYPE_VIEW_CLICKED.
 *
 * @param eventType The event type
 * @return The string representation.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
197,<android.util.AtomicFile: FileOutputStream startWrite()>,22,23,<android.util.AtomicFile: FileOutputStream startWrite()>,<android.util.AtomicFile: FileOutputStream startWrite()>,0,"{
    // Rename the current file so it may be used as a backup during the next read
    if (mBaseName.exists()) {
        if (!mBackupName.exists()) {
            if (!mBaseName.renameTo(mBackupName)) {
                Log.w(""AtomicFile"", ""Couldn't rename file "" + mBaseName + "" to backup file "" + mBackupName);
            }
        } else {
            mBaseName.delete();
        }
    }
    FileOutputStream str = null;
    try {
        str = new FileOutputStream(mBaseName);
    } catch (FileNotFoundException e) {
        File parent = mBaseName.getParentFile();
        if (!parent.mkdir()) {
            throw new IOException(""Couldn't create directory "" + mBaseName);
        }
        FileUtils.setPermissions(parent.getPath(), FileUtils.S_IRWXU | FileUtils.S_IRWXG | FileUtils.S_IXOTH, -1, -1);
        try {
            str = new FileOutputStream(mBaseName);
        } catch (FileNotFoundException e2) {
            throw new IOException(""Couldn't create "" + mBaseName);
        }
    }
    return str;
}","{
    // Rename the current file so it may be used as a backup during the next read
    if (mBaseName.exists()) {
        if (!mBackupName.exists()) {
            if (!mBaseName.renameTo(mBackupName)) {
                Log.w(""AtomicFile"", ""Couldn't rename file "" + mBaseName + "" to backup file "" + mBackupName);
            }
        } else {
            mBaseName.delete();
        }
    }
    FileOutputStream str = null;
    try {
        str = new FileOutputStream(mBaseName);
    } catch (FileNotFoundException e) {
        File parent = mBaseName.getParentFile();
        if (!parent.mkdirs()) {
            throw new IOException(""Couldn't create directory "" + mBaseName);
        }
        FileUtils.setPermissions(parent.getPath(), FileUtils.S_IRWXU | FileUtils.S_IRWXG | FileUtils.S_IXOTH, -1, -1);
        try {
            str = new FileOutputStream(mBaseName);
        } catch (FileNotFoundException e2) {
            throw new IOException(""Couldn't create "" + mBaseName);
        }
    }
    return str;
}",1,"/**
 * Start a new write operation on the file.  This returns a FileOutputStream
 * to which you can write the new file data.  The existing file is replaced
 * with the new data.  You <em>must not</em> directly close the given
 * FileOutputStream; instead call either {@link #finishWrite(FileOutputStream)}
 * or {@link #failWrite(FileOutputStream)}.
 *
 * <p>Note that if another thread is currently performing
 * a write, this will simply replace whatever that thread is writing
 * with the new file being written by this thread, and when the other
 * thread finishes the write the new write operation will no longer be
 * safe (or will be lost).  You must do your own threading protection for
 * access to AtomicFile.
 */
","/**
 * Start a new write operation on the file.  This returns a FileOutputStream
 * to which you can write the new file data.  The existing file is replaced
 * with the new data.  You <em>must not</em> directly close the given
 * FileOutputStream; instead call either {@link #finishWrite(FileOutputStream)}
 * or {@link #failWrite(FileOutputStream)}.
 *
 * <p>Note that if another thread is currently performing
 * a write, this will simply replace whatever that thread is writing
 * with the new file being written by this thread, and when the other
 * thread finishes the write the new write operation will no longer be
 * safe (or will be lost).  You must do your own threading protection for
 * access to AtomicFile.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change in the code is the modification of the method call from `parent.mkdir()` to `parent.mkdirs()`, which are used to create the directory denoted by this abstract pathname, so the code change type is 4.","There is no compatibility issue introduced by this change because the change from `mkdir()` to `mkdirs()` does not affect the behavior of the method in terms of returning a different value or throwing a different exception. The `mkdirs()` method creates the directory named by the abstract pathname, including any necessary but nonexistent parent directories, whereas `mkdir()` creates only the directory denoted by the abstract pathname. The calling of `mkdirs()` is functionally more inclusive but does not change the fundamental behavior of creating the necessary directory for the file output stream. Consequently, the API will not produce any different return value or throwable exception from the perspective of the client code."
198,"<android.accounts.AbstractAccountAuthenticator.Transport: void confirmCredentials(IAccountAuthenticatorResponse,Account,Bundle)>",22,23,"<android.accounts.AbstractAccountAuthenticator.Transport: void confirmCredentials(IAccountAuthenticatorResponse,Account,Bundle)>","<android.accounts.AbstractAccountAuthenticator.Transport: void confirmCredentials(IAccountAuthenticatorResponse,Account,Bundle)>",0,"{
    if (Log.isLoggable(TAG, Log.VERBOSE)) {
        Log.v(TAG, ""confirmCredentials: "" + account);
    }
    checkBinderPermission();
    try {
        final Bundle result = AbstractAccountAuthenticator.this.confirmCredentials(new AccountAuthenticatorResponse(response), account, options);
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            // force it to be unparcelled
            result.keySet();
            Log.v(TAG, ""confirmCredentials: result "" + AccountManager.sanitizeResult(result));
        }
        if (result != null) {
            response.onResult(result);
        }
    } catch (Exception e) {
        handleException(response, ""confirmCredentials"", account.toString(), e);
    }
}","{
    if (Log.isLoggable(TAG, Log.VERBOSE)) {
        Log.v(TAG, ""confirmCredentials: "" + account);
    }
    checkBinderPermission();
    try {
        final Bundle result = AbstractAccountAuthenticator.this.confirmCredentials(new AccountAuthenticatorResponse(response), account, options);
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            if (result != null) {
                // force it to be unparcelled
                result.keySet();
            }
            Log.v(TAG, ""confirmCredentials: result "" + AccountManager.sanitizeResult(result));
        }
        if (result != null) {
            response.onResult(result);
        }
    } catch (Exception e) {
        handleException(response, ""confirmCredentials"", account.toString(), e);
    }
}",1,,,-1,,[@Override],-1,-1,-1,-1,-1,-1,4,0,"The code change is the refactoring of the log statement to include the non-null check for result inside the verbose logging condition. This change does not affect the flow of execution nor the output, hence the code change type is 4.","Since the behavior of the API has not been altered in terms of output or exception handling, there is no Compatibility Issue; thus the CI type is 0."
199,"<android.accounts.AccountManager: AccountManagerFuture<Boolean> removeAccount(Account,AccountManagerCallback<Boolean>,Handler)>",22,23,"<android.accounts.AccountManager: AccountManagerFuture<Boolean> removeAccount(Account,AccountManagerCallback<Boolean>,Handler)>","<android.accounts.AccountManager: AccountManagerFuture<Boolean> removeAccount(Account,AccountManagerCallback<Boolean>,Handler)>",0,"{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    return new Future2Task<Boolean>(handler, callback) {

        public void doWork() throws RemoteException {
            mService.removeAccount(mResponse, account, false);
        }

        public Boolean bundleToResult(Bundle bundle) throws AuthenticatorException {
            if (!bundle.containsKey(KEY_BOOLEAN_RESULT)) {
                throw new AuthenticatorException(""no result in response"");
            }
            return bundle.getBoolean(KEY_BOOLEAN_RESULT);
        }
    }.start();
}","{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    return new Future2Task<Boolean>(handler, callback) {

        @Override
        public void doWork() throws RemoteException {
            mService.removeAccount(mResponse, account, false);
        }

        @Override
        public Boolean bundleToResult(Bundle bundle) throws AuthenticatorException {
            if (!bundle.containsKey(KEY_BOOLEAN_RESULT)) {
                throw new AuthenticatorException(""no result in response"");
            }
            return bundle.getBoolean(KEY_BOOLEAN_RESULT);
        }
    }.start();
}",1,"/**
 * Removes an account from the AccountManager.  Does nothing if the account
 * does not exist.  Does not delete the account from the server.
 * The authenticator may have its own policies preventing account
 * deletion, in which case the account will not be deleted.
 *
 * <p>This method may be called from any thread, but the returned
 * {@link AccountManagerFuture} must not be used on the main thread.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#MANAGE_ACCOUNTS}.
 *
 * @param account The {@link Account} to remove
 * @param callback Callback to invoke when the request completes,
 * null for no callback
 * @param handler {@link Handler} identifying the callback thread,
 * null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Boolean,
 * true if the account has been successfully removed
 * @deprecated use
 * {@link #removeAccount(Account, Activity, AccountManagerCallback, Handler)}
 * instead
 */
","/**
 * Removes an account from the AccountManager.  Does nothing if the account
 * does not exist.  Does not delete the account from the server.
 * The authenticator may have its own policies preventing account
 * deletion, in which case the account will not be deleted.
 *
 * <p>This method requires the caller to have a signature match with the
 * authenticator that manages the specified account.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * MANAGE_ACCOUNTS permission is needed for those platforms. See docs for
 * this function in API level 22.
 *
 * @param account The {@link Account} to remove
 * @param callback Callback to invoke when the request completes,
 * null for no callback
 * @param handler {@link Handler} identifying the callback thread,
 * null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Boolean,
 * true if the account has been successfully removed
 * @deprecated use
 * {@link #removeAccount(Account, Activity, AccountManagerCallback, Handler)}
 * instead
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,0,0,The only changes between the early version and the late version of the code are the annotations `@Override` added to the methods within the anonymous `Future2Task<Boolean>` class. Adding `@Override` does not alter the functionality or the behavior of the code; it is simply an indication to the compiler that the method is intended to override a method in a superclass.,"Adding `@Override` annotations does not lead to any compatibility issues as it does not change the execution behavior of the methods or the return values. The methods' contract remains the same, so there will be no Compatibility Issue."
200,<android.gesture.GestureUtils: float computeStraightness(float[])>,22,23,<android.gesture.GestureUtils: float computeStraightness(float[])>,<android.gesture.GestureUtils: float computeStraightness(float[])>,0,"{
    float totalLen = computeTotalLength(points);
    float dx = points[2] - points[0];
    float dy = points[3] - points[1];
    return (float) Math.sqrt(dx * dx + dy * dy) / totalLen;
}","{
    float totalLen = computeTotalLength(points);
    float dx = points[2] - points[0];
    float dy = points[3] - points[1];
    return (float) Math.hypot(dx, dy) / totalLen;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method Math.sqrt(dx * dx + dy * dy) is replaced by Math.hypot(dx, dy), which alters the return statement, implicating a change in the dependent API as Math.hypot is being used instead of Math.sqrt for the calculation, hence the change types are 1,5.","Since a different Math method is being used to calculate the return value, this change can lead to a potentially different value being returned even if the inputs are the same. Thus, the CI type is 1."
202,"<android.view.Choreographer: void doFrame(long,int)>",22,23,"<android.view.Choreographer: void doFrame(long,int)>","<android.view.Choreographer: void doFrame(long,int)>",0,"{
    final long startNanos;
    synchronized (mLock) {
        if (!mFrameScheduled) {
            // no work to do
            return;
        }
        startNanos = System.nanoTime();
        final long jitterNanos = startNanos - frameTimeNanos;
        if (jitterNanos >= mFrameIntervalNanos) {
            final long skippedFrames = jitterNanos / mFrameIntervalNanos;
            if (skippedFrames >= SKIPPED_FRAME_WARNING_LIMIT) {
                Log.i(TAG, ""Skipped "" + skippedFrames + "" frames!  "" + ""The application may be doing too much work on its main thread."");
            }
            final long lastFrameOffset = jitterNanos % mFrameIntervalNanos;
            if (DEBUG) {
                Log.d(TAG, ""Missed vsync by "" + (jitterNanos * 0.000001f) + "" ms "" + ""which is more than the frame interval of "" + (mFrameIntervalNanos * 0.000001f) + "" ms!  "" + ""Skipping "" + skippedFrames + "" frames and setting frame "" + ""time to "" + (lastFrameOffset * 0.000001f) + "" ms in the past."");
            }
            frameTimeNanos = startNanos - lastFrameOffset;
        }
        if (frameTimeNanos < mLastFrameTimeNanos) {
            if (DEBUG) {
                Log.d(TAG, ""Frame time appears to be going backwards.  May be due to a "" + ""previously skipped frame.  Waiting for next vsync."");
            }
            scheduleVsyncLocked();
            return;
        }
        mFrameScheduled = false;
        mLastFrameTimeNanos = frameTimeNanos;
    }
    doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos);
    doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);
    doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);
    if (DEBUG) {
        final long endNanos = System.nanoTime();
        Log.d(TAG, ""Frame "" + frame + "": Finished, took "" + (endNanos - startNanos) * 0.000001f + "" ms, latency "" + (startNanos - frameTimeNanos) * 0.000001f + "" ms."");
    }
}","{
    final long startNanos;
    synchronized (mLock) {
        if (!mFrameScheduled) {
            // no work to do
            return;
        }
        if (DEBUG_JANK && mDebugPrintNextFrameTimeDelta) {
            mDebugPrintNextFrameTimeDelta = false;
            Log.d(TAG, ""Frame time delta: "" + ((frameTimeNanos - mLastFrameTimeNanos) * 0.000001f) + "" ms"");
        }
        long intendedFrameTimeNanos = frameTimeNanos;
        startNanos = System.nanoTime();
        final long jitterNanos = startNanos - frameTimeNanos;
        if (jitterNanos >= mFrameIntervalNanos) {
            final long skippedFrames = jitterNanos / mFrameIntervalNanos;
            if (skippedFrames >= SKIPPED_FRAME_WARNING_LIMIT) {
                Log.i(TAG, ""Skipped "" + skippedFrames + "" frames!  "" + ""The application may be doing too much work on its main thread."");
            }
            final long lastFrameOffset = jitterNanos % mFrameIntervalNanos;
            if (DEBUG_JANK) {
                Log.d(TAG, ""Missed vsync by "" + (jitterNanos * 0.000001f) + "" ms "" + ""which is more than the frame interval of "" + (mFrameIntervalNanos * 0.000001f) + "" ms!  "" + ""Skipping "" + skippedFrames + "" frames and setting frame "" + ""time to "" + (lastFrameOffset * 0.000001f) + "" ms in the past."");
            }
            frameTimeNanos = startNanos - lastFrameOffset;
        }
        if (frameTimeNanos < mLastFrameTimeNanos) {
            if (DEBUG_JANK) {
                Log.d(TAG, ""Frame time appears to be going backwards.  May be due to a "" + ""previously skipped frame.  Waiting for next vsync."");
            }
            scheduleVsyncLocked();
            return;
        }
        mFrameInfo.setVsync(intendedFrameTimeNanos, frameTimeNanos);
        mFrameScheduled = false;
        mLastFrameTimeNanos = frameTimeNanos;
    }
    try {
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, ""Choreographer#doFrame"");
        mFrameInfo.markInputHandlingStart();
        doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos);
        mFrameInfo.markAnimationsStart();
        doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);
        mFrameInfo.markPerformTraversalsStart();
        doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);
        doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos);
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_VIEW);
    }
    if (DEBUG_FRAMES) {
        final long endNanos = System.nanoTime();
        Log.d(TAG, ""Frame "" + frame + "": Finished, took "" + (endNanos - startNanos) * 0.000001f + "" ms, latency "" + (startNanos - frameTimeNanos) * 0.000001f + "" ms."");
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
204,"<android.text.TextDirectionHeuristics.FirstStrong: int checkRtl(CharSequence,int,int)>",22,23,"<android.text.TextDirectionHeuristics.FirstStrong: int checkRtl(CharSequence,int,int)>","<android.text.TextDirectionHeuristics.FirstStrong: int checkRtl(CharSequence,int,int)>",0,"{
    int result = STATE_UNKNOWN;
    for (int i = start, e = start + count; i < e && result == STATE_UNKNOWN; ++i) {
        result = isRtlTextOrFormat(Character.getDirectionality(cs.charAt(i)));
    }
    return result;
}","{
    int result = STATE_UNKNOWN;
    int openIsolateCount = 0;
    for (int cp, i = start, end = start + count; i < end && result == STATE_UNKNOWN; i += Character.charCount(cp)) {
        cp = Character.codePointAt(cs, i);
        if (0x2066 <= cp && cp <= 0x2068) {
            // Opening isolates
            openIsolateCount += 1;
        } else if (cp == 0x2069) {
            // POP DIRECTIONAL ISOLATE (PDI)
            if (openIsolateCount > 0)
                openIsolateCount -= 1;
        } else if (openIsolateCount == 0) {
            // Only consider the characters outside isolate pairs
            result = isRtlCodePoint(cp);
        }
    }
    return result;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"There has been an addition of new variables and logic that changes how the loop operates and how code points are counted and considered. Specifically, an 'openIsolateCount' variable is introduced, and there are now conditions checking Unicode range 0x2066 to 0x2069 dictating new logic for incrementing and decrementing this variable. Additionally, a new method 'isRtlCodePoint' is used instead of calling 'isRtlTextOrFormat' and with different parameter passing. Thus, these changes involve control dependency and logic within the loop — so the code change types are 3 for control dependency change and 4 for the other statement changes.","The method's behavior is modified with additional Unicode range checks and a different logic condition based on 'openIsolateCount'. Consequently, it can return different results for input that contains characters within the newly checked Unicode ranges due to the new logic implemented. Hence, there may be compatibility issues related to potentially returning a different value, and the CI type is 1."
205,<android.content.RestrictionsManager: List<RestrictionEntry> getManifestRestrictions(String)>,22,23,<android.content.RestrictionsManager: List<RestrictionEntry> getManifestRestrictions(String)>,<android.content.RestrictionsManager: List<RestrictionEntry> getManifestRestrictions(String)>,0,"{
    ApplicationInfo appInfo = null;
    try {
        appInfo = mContext.getPackageManager().getApplicationInfo(packageName, PackageManager.GET_META_DATA);
    } catch (NameNotFoundException pnfe) {
        throw new IllegalArgumentException(""No such package "" + packageName);
    }
    if (appInfo == null || !appInfo.metaData.containsKey(META_DATA_APP_RESTRICTIONS)) {
        return null;
    }
    XmlResourceParser xml = appInfo.loadXmlMetaData(mContext.getPackageManager(), META_DATA_APP_RESTRICTIONS);
    List<RestrictionEntry> restrictions = loadManifestRestrictions(packageName, xml);
    return restrictions;
}","{
    ApplicationInfo appInfo = null;
    try {
        appInfo = mContext.getPackageManager().getApplicationInfo(packageName, PackageManager.GET_META_DATA);
    } catch (NameNotFoundException pnfe) {
        throw new IllegalArgumentException(""No such package "" + packageName);
    }
    if (appInfo == null || !appInfo.metaData.containsKey(META_DATA_APP_RESTRICTIONS)) {
        return null;
    }
    XmlResourceParser xml = appInfo.loadXmlMetaData(mContext.getPackageManager(), META_DATA_APP_RESTRICTIONS);
    return loadManifestRestrictions(packageName, xml);
}",1,"/**
 * Parse and return the list of restrictions defined in the manifest for the specified
 * package, if any.
 *
 * @param packageName The application for which to fetch the restrictions list.
 * @return The list of RestrictionEntry objects created from the XML file specified
 * in the manifest, or null if none was specified.
 */
","/**
 * Parse and return the list of restrictions defined in the manifest for the specified
 * package, if any.
 *
 * @param packageName The application for which to fetch the restrictions list.
 * @return The list of RestrictionEntry objects created from the XML file specified
 * in the manifest, or null if none was specified.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"There is a change in how the restrictions List is returned. In the early implementation, the restrictions are stored in a temporary variable before returning, whereas in the late implementation, the method 'loadManifestRestrictions' is called directly in the return statement. This is an example of an 'Other statement changed' but doesn't affect the behavior of the method regarding return types or values as well as exceptions thrown.","There is no Compatibility Issue because the return value (List<RestrictionEntry>) is still the same type, and the method still returns null under the same condition. No new exceptions are thrown, and the existing exception handling remains unchanged."
209,<android.hardware.camera2.marshal.impl.MarshalQueryableParcelable.MarshalerParcelable: T unmarshal(ByteBuffer)>,22,23,<android.hardware.camera2.marshal.impl.MarshalQueryableParcelable.MarshalerParcelable: T unmarshal(ByteBuffer)>,<android.hardware.camera2.marshal.impl.MarshalQueryableParcelable.MarshalerParcelable: T unmarshal(ByteBuffer)>,0,"{
    if (VERBOSE) {
        Log.v(TAG, ""unmarshal, buffer remaining "" + buffer.remaining());
    }
    /*
             * Quadratically slow when marshaling an array of parcelables.
             *
             * Read out the entire byte buffer as an array, then copy it into the parcel.
             *
             * Once we unparcel the entire object, advance the byte buffer by only how many
             * bytes the parcel actually used up.
             *
             * Future: If we ever do need to use parcelable arrays, we can do this a little smarter
             * by reading out a chunk like 4,8,16,24 each time, but not sure how to detect
             * parcels being too short in this case.
             *
             * Future: Alternatively use Parcel#obtain(long) directly into the native
             * pointer of a ByteBuffer, which would not copy if the ByteBuffer was direct.
             */
    buffer.mark();
    Parcel parcel = Parcel.obtain();
    try {
        int maxLength = buffer.remaining();
        byte[] remaining = new byte[maxLength];
        buffer.get(remaining);
        parcel.unmarshall(remaining, /*offset*/
        0, maxLength);
        parcel.setDataPosition(/*pos*/
        0);
        T value = mCreator.createFromParcel(parcel);
        int actualLength = parcel.dataPosition();
        if (actualLength == 0) {
            throw new AssertionError(""No data marshaled for "" + value);
        }
        // set the position past the bytes the parcelable actually used
        buffer.reset();
        buffer.position(buffer.position() + actualLength);
        if (VERBOSE) {
            Log.v(TAG, ""unmarshal, parcel length was "" + actualLength);
            Log.v(TAG, ""unmarshal, value is "" + value);
        }
        return mClass.cast(value);
    } finally {
        parcel.recycle();
    }
}","{
    if (DEBUG) {
        Log.v(TAG, ""unmarshal, buffer remaining "" + buffer.remaining());
    }
    /*
             * Quadratically slow when marshaling an array of parcelables.
             *
             * Read out the entire byte buffer as an array, then copy it into the parcel.
             *
             * Once we unparcel the entire object, advance the byte buffer by only how many
             * bytes the parcel actually used up.
             *
             * Future: If we ever do need to use parcelable arrays, we can do this a little smarter
             * by reading out a chunk like 4,8,16,24 each time, but not sure how to detect
             * parcels being too short in this case.
             *
             * Future: Alternatively use Parcel#obtain(long) directly into the native
             * pointer of a ByteBuffer, which would not copy if the ByteBuffer was direct.
             */
    buffer.mark();
    Parcel parcel = Parcel.obtain();
    try {
        int maxLength = buffer.remaining();
        byte[] remaining = new byte[maxLength];
        buffer.get(remaining);
        parcel.unmarshall(remaining, /*offset*/
        0, maxLength);
        parcel.setDataPosition(/*pos*/
        0);
        T value = mCreator.createFromParcel(parcel);
        int actualLength = parcel.dataPosition();
        if (actualLength == 0) {
            throw new AssertionError(""No data marshaled for "" + value);
        }
        // set the position past the bytes the parcelable actually used
        buffer.reset();
        buffer.position(buffer.position() + actualLength);
        if (DEBUG) {
            Log.v(TAG, ""unmarshal, parcel length was "" + actualLength);
            Log.v(TAG, ""unmarshal, value is "" + value);
        }
        return mClass.cast(value);
    } finally {
        parcel.recycle();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The code has changed only in the logging flag from VERBOSE to DEBUG. This change will not affect the behavior of the method, so the code change type is 4.","There is no Compatibility Issue, as the change in the logging level does not lead to a different return value or exception handling. The behavior of the unmarshal method itself remains unchanged."
210,<android.hardware.SystemSensorManager.SensorEventQueue: void dispatchFlushCompleteEvent(int)>,22,23,<android.hardware.SystemSensorManager.SensorEventQueue: void dispatchFlushCompleteEvent(int)>,<android.hardware.SystemSensorManager.SensorEventQueue: void dispatchFlushCompleteEvent(int)>,0,"{
    if (mListener instanceof SensorEventListener2) {
        final Sensor sensor = sHandleToSensor.get(handle);
        ((SensorEventListener2) mListener).onFlushCompleted(sensor);
    }
    return;
}","{
    if (mListener instanceof SensorEventListener2) {
        final Sensor sensor = mManager.mHandleToSensor.get(handle);
        ((SensorEventListener2) mListener).onFlushCompleted(sensor);
    }
    return;
}",1,,,-1,"[@SuppressWarnings(""unused"")]","[@SuppressWarnings(""unused"")]",-1,-1,-1,-1,-1,-1,5,0,"The only change between the early and late versions is in how the `sensor` variable is accessed: from a static `sHandleToSensor.get(handle)` to an instance method `mManager.mHandleToSensor.get(handle)`. This indicates a change in a dependent API, so the code change type is 5.","As the change pertains only to the way the sensor instance is retrieved (from a different source) and assuming that `mManager.mHandleToSensor` delivers the same result as `sHandleToSensor.get(handle)`, there is no indication that the behavior of the method itself has changed. The method's signature, parameter, and the other logic remain unchanged, suggesting no potential for a Compatibility Issue. Therefore, the CI type is 0."
212,<android.bluetooth.BluetoothDevice: BluetoothSocket createInsecureRfcommSocketToServiceRecord(UUID)>,22,23,<android.bluetooth.BluetoothDevice: BluetoothSocket createInsecureRfcommSocketToServiceRecord(UUID)>,<android.bluetooth.BluetoothDevice: BluetoothSocket createInsecureRfcommSocketToServiceRecord(UUID)>,0,"{
    return new BluetoothSocket(BluetoothSocket.TYPE_RFCOMM, -1, false, false, this, -1, new ParcelUuid(uuid));
}","{
    if (isBluetoothEnabled() == false) {
        Log.e(TAG, ""Bluetooth is not enabled"");
        throw new IOException();
    }
    return new BluetoothSocket(BluetoothSocket.TYPE_RFCOMM, -1, false, false, this, -1, new ParcelUuid(uuid));
}",1,"/**
 * Create an RFCOMM {@link BluetoothSocket} socket ready to start an insecure
 * outgoing connection to this remote device using SDP lookup of uuid.
 * <p> The communication channel will not have an authenticated link key
 * i.e it will be subject to man-in-the-middle attacks. For Bluetooth 2.1
 * devices, the link key will be encrypted, as encryption is mandatory.
 * For legacy devices (pre Bluetooth 2.1 devices) the link key will
 * be not be encrypted. Use {@link #createRfcommSocketToServiceRecord} if an
 * encrypted and authenticated communication channel is desired.
 * <p>This is designed to be used with {@link
 * BluetoothAdapter#listenUsingInsecureRfcommWithServiceRecord} for peer-peer
 * Bluetooth applications.
 * <p>Use {@link BluetoothSocket#connect} to initiate the outgoing
 * connection. This will also perform an SDP lookup of the given uuid to
 * determine which channel to connect to.
 * <p>The remote device will be authenticated and communication on this
 * socket will be encrypted.
 * <p>Hint: If you are connecting to a Bluetooth serial board then try
 * using the well-known SPP UUID 00001101-0000-1000-8000-00805F9B34FB.
 * However if you are connecting to an Android peer then please generate
 * your own unique UUID.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
 *
 * @param uuid service record uuid to lookup RFCOMM channel
 * @return a RFCOMM BluetoothServerSocket ready for an outgoing connection
 * @throws IOException on error, for example Bluetooth not available, or
 * insufficient permissions
 */
","/**
 * Create an RFCOMM {@link BluetoothSocket} socket ready to start an insecure
 * outgoing connection to this remote device using SDP lookup of uuid.
 * <p> The communication channel will not have an authenticated link key
 * i.e it will be subject to man-in-the-middle attacks. For Bluetooth 2.1
 * devices, the link key will be encrypted, as encryption is mandatory.
 * For legacy devices (pre Bluetooth 2.1 devices) the link key will
 * be not be encrypted. Use {@link #createRfcommSocketToServiceRecord} if an
 * encrypted and authenticated communication channel is desired.
 * <p>This is designed to be used with {@link
 * BluetoothAdapter#listenUsingInsecureRfcommWithServiceRecord} for peer-peer
 * Bluetooth applications.
 * <p>Use {@link BluetoothSocket#connect} to initiate the outgoing
 * connection. This will also perform an SDP lookup of the given uuid to
 * determine which channel to connect to.
 * <p>The remote device will be authenticated and communication on this
 * socket will be encrypted.
 * <p>Hint: If you are connecting to a Bluetooth serial board then try
 * using the well-known SPP UUID 00001101-0000-1000-8000-00805F9B34FB.
 * However if you are connecting to an Android peer then please generate
 * your own unique UUID.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
 *
 * @param uuid service record uuid to lookup RFCOMM channel
 * @return a RFCOMM BluetoothServerSocket ready for an outgoing connection
 * @throws IOException on error, for example Bluetooth not available, or
 * insufficient permissions
 */
",-1,,[@RequiresPermission(Manifest.permission.BLUETOOTH)],-1,-1,-1,-1,-1,-1,"2,3",2,"The late version introduces a new control dependency checking whether Bluetooth is enabled, an error log, and also throws a new IOException if Bluetooth is not enabled. It's a combination of exception handling statement changed and control dependency changed, so the code change types are 2,3.","Since a new check is introduced that throws a new IOException if the Bluetooth is not enabled, which was not present in the early version, it can lead to a different exception being thrown. Therefore, the CI type is 2."
213,<android.printservice.PrintService: IBinder onBind(Intent)>,22,23,<android.printservice.PrintService: IBinder onBind(Intent)>,<android.printservice.PrintService: IBinder onBind(Intent)>,0,"{
    return new IPrintService.Stub() {

        @Override
        public void createPrinterDiscoverySession() {
            mHandler.sendEmptyMessage(ServiceHandler.MSG_CREATE_PRINTER_DISCOVERY_SESSION);
        }

        @Override
        public void destroyPrinterDiscoverySession() {
            mHandler.sendEmptyMessage(ServiceHandler.MSG_DESTROY_PRINTER_DISCOVERY_SESSION);
        }

        public void startPrinterDiscovery(List<PrinterId> priorityList) {
            mHandler.obtainMessage(ServiceHandler.MSG_START_PRINTER_DISCOVERY, priorityList).sendToTarget();
        }

        @Override
        public void stopPrinterDiscovery() {
            mHandler.sendEmptyMessage(ServiceHandler.MSG_STOP_PRINTER_DISCOVERY);
        }

        @Override
        public void validatePrinters(List<PrinterId> printerIds) {
            mHandler.obtainMessage(ServiceHandler.MSG_VALIDATE_PRINTERS, printerIds).sendToTarget();
        }

        @Override
        public void startPrinterStateTracking(PrinterId printerId) {
            mHandler.obtainMessage(ServiceHandler.MSG_START_PRINTER_STATE_TRACKING, printerId).sendToTarget();
        }

        @Override
        public void stopPrinterStateTracking(PrinterId printerId) {
            mHandler.obtainMessage(ServiceHandler.MSG_STOP_PRINTER_STATE_TRACKING, printerId).sendToTarget();
        }

        @Override
        public void setClient(IPrintServiceClient client) {
            mHandler.obtainMessage(ServiceHandler.MSG_SET_CLEINT, client).sendToTarget();
        }

        @Override
        public void requestCancelPrintJob(PrintJobInfo printJobInfo) {
            mHandler.obtainMessage(ServiceHandler.MSG_ON_REQUEST_CANCEL_PRINTJOB, printJobInfo).sendToTarget();
        }

        @Override
        public void onPrintJobQueued(PrintJobInfo printJobInfo) {
            mHandler.obtainMessage(ServiceHandler.MSG_ON_PRINTJOB_QUEUED, printJobInfo).sendToTarget();
        }
    };
}","{
    return new IPrintService.Stub() {

        @Override
        public void createPrinterDiscoverySession() {
            mHandler.sendEmptyMessage(ServiceHandler.MSG_CREATE_PRINTER_DISCOVERY_SESSION);
        }

        @Override
        public void destroyPrinterDiscoverySession() {
            mHandler.sendEmptyMessage(ServiceHandler.MSG_DESTROY_PRINTER_DISCOVERY_SESSION);
        }

        public void startPrinterDiscovery(List<PrinterId> priorityList) {
            mHandler.obtainMessage(ServiceHandler.MSG_START_PRINTER_DISCOVERY, priorityList).sendToTarget();
        }

        @Override
        public void stopPrinterDiscovery() {
            mHandler.sendEmptyMessage(ServiceHandler.MSG_STOP_PRINTER_DISCOVERY);
        }

        @Override
        public void validatePrinters(List<PrinterId> printerIds) {
            mHandler.obtainMessage(ServiceHandler.MSG_VALIDATE_PRINTERS, printerIds).sendToTarget();
        }

        @Override
        public void startPrinterStateTracking(PrinterId printerId) {
            mHandler.obtainMessage(ServiceHandler.MSG_START_PRINTER_STATE_TRACKING, printerId).sendToTarget();
        }

        @Override
        public void stopPrinterStateTracking(PrinterId printerId) {
            mHandler.obtainMessage(ServiceHandler.MSG_STOP_PRINTER_STATE_TRACKING, printerId).sendToTarget();
        }

        @Override
        public void setClient(IPrintServiceClient client) {
            mHandler.obtainMessage(ServiceHandler.MSG_SET_CLIENT, client).sendToTarget();
        }

        @Override
        public void requestCancelPrintJob(PrintJobInfo printJobInfo) {
            mHandler.obtainMessage(ServiceHandler.MSG_ON_REQUEST_CANCEL_PRINTJOB, printJobInfo).sendToTarget();
        }

        @Override
        public void onPrintJobQueued(PrintJobInfo printJobInfo) {
            mHandler.obtainMessage(ServiceHandler.MSG_ON_PRINTJOB_QUEUED, printJobInfo).sendToTarget();
        }
    };
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,0,0,There is no code change in the actual implementation of the methods between the two versions.,"Since there is no code change, there is no Compatibility Issue."
214,<android.app.ContextImpl: Theme getTheme()>,22,23,<android.app.ContextImpl: Theme getTheme()>,<android.app.ContextImpl: Theme getTheme()>,0,"{
    if (mTheme == null) {
        mThemeResource = Resources.selectDefaultTheme(mThemeResource, getOuterContext().getApplicationInfo().targetSdkVersion);
        mTheme = mResources.newTheme();
        mTheme.applyStyle(mThemeResource, true);
    }
    return mTheme;
}","{
    if (mTheme != null) {
        return mTheme;
    }
    mThemeResource = Resources.selectDefaultTheme(mThemeResource, getOuterContext().getApplicationInfo().targetSdkVersion);
    initializeTheme();
    return mTheme;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"The control flow has been changed by inverting the ""if"" check for 'mTheme', and another method 'initializeTheme()' is now called in place of 'mTheme.applyStyle(mThemeResource, true);'. This indicates both control dependency and potentially other changes as the implementation of 'initializeTheme()' is not shown. So the code change type is 1,3.","The restructuring of the condition checking and the different method call can lead to different behavior if 'initializeTheme()' does something different from 'mTheme.applyStyle(mThemeResource, true);'. Given the change in the control structure and differing method calls, there is a potential for returning a different Theme object. Hence, the CI type is 1."
217,"<android.view.inputmethod.InputMethodSubtype: CharSequence getDisplayName(Context,String,ApplicationInfo)>",22,23,"<android.view.inputmethod.InputMethodSubtype: CharSequence getDisplayName(Context,String,ApplicationInfo)>","<android.view.inputmethod.InputMethodSubtype: CharSequence getDisplayName(Context,String,ApplicationInfo)>",0,"{
    final Locale locale = constructLocaleFromString(mSubtypeLocale);
    final String localeStr = locale != null ? locale.getDisplayName() : mSubtypeLocale;
    if (mSubtypeNameResId == 0) {
        return localeStr;
    }
    final CharSequence subtypeName = context.getPackageManager().getText(packageName, mSubtypeNameResId, appInfo);
    if (!TextUtils.isEmpty(subtypeName)) {
        final String replacementString = containsExtraValueKey(EXTRA_KEY_UNTRANSLATABLE_STRING_IN_SUBTYPE_NAME) ? getExtraValueOf(EXTRA_KEY_UNTRANSLATABLE_STRING_IN_SUBTYPE_NAME) : localeStr;
        try {
            return String.format(subtypeName.toString(), replacementString != null ? replacementString : """");
        } catch (IllegalFormatException e) {
            Slog.w(TAG, ""Found illegal format in subtype name("" + subtypeName + ""): "" + e);
            return """";
        }
    } else {
        return localeStr;
    }
}","{
    final Locale locale = getLocaleObject();
    final String localeStr = locale != null ? locale.getDisplayName() : mSubtypeLocale;
    if (mSubtypeNameResId == 0) {
        return localeStr;
    }
    final CharSequence subtypeName = context.getPackageManager().getText(packageName, mSubtypeNameResId, appInfo);
    if (!TextUtils.isEmpty(subtypeName)) {
        final String replacementString = containsExtraValueKey(EXTRA_KEY_UNTRANSLATABLE_STRING_IN_SUBTYPE_NAME) ? getExtraValueOf(EXTRA_KEY_UNTRANSLATABLE_STRING_IN_SUBTYPE_NAME) : localeStr;
        try {
            return String.format(subtypeName.toString(), replacementString != null ? replacementString : """");
        } catch (IllegalFormatException e) {
            Slog.w(TAG, ""Found illegal format in subtype name("" + subtypeName + ""): "" + e);
            return """";
        }
    } else {
        return localeStr;
    }
}",1,"/**
 * @param context Context will be used for getting Locale and PackageManager.
 * @param packageName The package name of the IME
 * @param appInfo The application info of the IME
 * @return a display name for this subtype. The string resource of the label (mSubtypeNameResId)
 * may have exactly one %s in it. If there is, the %s part will be replaced with the locale's
 * display name by the formatter. If there is not, this method returns the string specified by
 * mSubtypeNameResId. If mSubtypeNameResId is not specified (== 0), it's up to the framework to
 * generate an appropriate display name.
 */
","/**
 * @param context Context will be used for getting Locale and PackageManager.
 * @param packageName The package name of the IME
 * @param appInfo The application info of the IME
 * @return a display name for this subtype. The string resource of the label (mSubtypeNameResId)
 * may have exactly one %s in it. If there is, the %s part will be replaced with the locale's
 * display name by the formatter. If there is not, this method returns the string specified by
 * mSubtypeNameResId. If mSubtypeNameResId is not specified (== 0), it's up to the framework to
 * generate an appropriate display name.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"There is no actual change in the implementation of the method. The only change is renaming a method from 'constructLocaleFromString' to 'getLocaleObject' but the functionality seems to be intact with no modification in behavior, so the code change type is 0.","Since there is no change in the behavior of the method, no new exceptions are thrown, and the return value does not change, there is no Compatibility Issue. Hence, the CI type is 0."
219,<android.print.PrintAttributes: String toString()>,22,23,<android.print.PrintAttributes: String toString()>,<android.print.PrintAttributes: String toString()>,0,"{
    StringBuilder builder = new StringBuilder();
    builder.append(""PrintAttributes{"");
    builder.append(""mediaSize: "").append(mMediaSize);
    if (mMediaSize != null) {
        builder.append("", orientation: "").append(mMediaSize.isPortrait() ? ""portrait"" : ""landscape"");
    } else {
        builder.append("", orientation: "").append(""null"");
    }
    builder.append("", resolution: "").append(mResolution);
    builder.append("", minMargins: "").append(mMinMargins);
    builder.append("", colorMode: "").append(colorModeToString(mColorMode));
    builder.append(""}"");
    return builder.toString();
}","{
    StringBuilder builder = new StringBuilder();
    builder.append(""PrintAttributes{"");
    builder.append(""mediaSize: "").append(mMediaSize);
    if (mMediaSize != null) {
        builder.append("", orientation: "").append(mMediaSize.isPortrait() ? ""portrait"" : ""landscape"");
    } else {
        builder.append("", orientation: "").append(""null"");
    }
    builder.append("", resolution: "").append(mResolution);
    builder.append("", minMargins: "").append(mMinMargins);
    builder.append("", colorMode: "").append(colorModeToString(mColorMode));
    builder.append("", duplexMode: "").append(duplexModeToString(mDuplexMode));
    builder.append(""}"");
    return builder.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"A new information ""duplexMode: "" followed by the result of duplexModeToString(mDuplexMode) is appended to the StringBuilder instance 'builder', without altering any existing control flows, return values, or exception handlings. Thus, the code change type is 4.","The addition of duplex mode information to the string representation does not lead to a change in return type nor does it introduce a new exception handling path. Hence, there is no Compatibility Issue; the toString() method's purpose is to provide a string representation and does not affect the object's behavior."
221,"<android.widget.Toolbar.ExpandedActionViewMenuPresenter: boolean expandItemActionView(MenuBuilder,MenuItemImpl)>",22,23,"<android.widget.Toolbar.ExpandedActionViewMenuPresenter: boolean expandItemActionView(MenuBuilder,MenuItemImpl)>","<android.widget.Toolbar.ExpandedActionViewMenuPresenter: boolean expandItemActionView(MenuBuilder,MenuItemImpl)>",0,"{
    ensureCollapseButtonView();
    if (mCollapseButtonView.getParent() != Toolbar.this) {
        addView(mCollapseButtonView);
    }
    mExpandedActionView = item.getActionView();
    mCurrentExpandedItem = item;
    if (mExpandedActionView.getParent() != Toolbar.this) {
        final LayoutParams lp = generateDefaultLayoutParams();
        lp.gravity = Gravity.START | (mButtonGravity & Gravity.VERTICAL_GRAVITY_MASK);
        lp.mViewType = LayoutParams.EXPANDED;
        mExpandedActionView.setLayoutParams(lp);
        addView(mExpandedActionView);
    }
    setChildVisibilityForExpandedActionView(true);
    requestLayout();
    item.setActionViewExpanded(true);
    if (mExpandedActionView instanceof CollapsibleActionView) {
        ((CollapsibleActionView) mExpandedActionView).onActionViewExpanded();
    }
    return true;
}","{
    ensureCollapseButtonView();
    if (mCollapseButtonView.getParent() != Toolbar.this) {
        addView(mCollapseButtonView);
    }
    mExpandedActionView = item.getActionView();
    mCurrentExpandedItem = item;
    if (mExpandedActionView.getParent() != Toolbar.this) {
        final LayoutParams lp = generateDefaultLayoutParams();
        lp.gravity = Gravity.START | (mButtonGravity & Gravity.VERTICAL_GRAVITY_MASK);
        lp.mViewType = LayoutParams.EXPANDED;
        mExpandedActionView.setLayoutParams(lp);
        addView(mExpandedActionView);
    }
    removeChildrenForExpandedActionView();
    requestLayout();
    item.setActionViewExpanded(true);
    if (mExpandedActionView instanceof CollapsibleActionView) {
        ((CollapsibleActionView) mExpandedActionView).onActionViewExpanded();
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"There is a change in the method body where the method `setChildVisibilityForExpandedActionView(true);` has been replaced by `removeChildrenForExpandedActionView();`. This indicates both a control dependency change and an other statement change, resulting in code change types 3 and 4.","Even though there is a change in the statements executed, since both versions of the method end by returning `true`, and the altered statements do not affect this outcome, there is no difference in the returned value or thrown exceptions between the two versions. Therefore, there is no Compatibility Issue, which corresponds to CI type 0."
222,"<android.app.admin.DevicePolicyManager: void setTrustAgentConfiguration(ComponentName,ComponentName,PersistableBundle)>",22,23,"<android.app.admin.DevicePolicyManager: void setTrustAgentConfiguration(ComponentName,ComponentName,PersistableBundle)>","<android.app.admin.DevicePolicyManager: void setTrustAgentConfiguration(ComponentName,ComponentName,PersistableBundle)>",0,"{
    if (mService != null) {
        try {
            mService.setTrustAgentConfiguration(admin, target, configuration, UserHandle.myUserId());
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    if (mService != null) {
        try {
            mService.setTrustAgentConfiguration(admin, target, configuration);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}",1,"/**
 * Sets a list of configuration features to enable for a TrustAgent component. This is meant
 * to be used in conjunction with {@link #KEYGUARD_DISABLE_TRUST_AGENTS}, which disables all
 * trust agents but those enabled by this function call. If flag
 * {@link #KEYGUARD_DISABLE_TRUST_AGENTS} is not set, then this call has no effect.
 *
 * <p>The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_DISABLE_KEYGUARD_FEATURES} to be able to call
 * this method; if not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param target Component name of the agent to be enabled.
 * @param configuration TrustAgent-specific feature bundle. If null for any admin, agent
 * will be strictly disabled according to the state of the
 * {@link #KEYGUARD_DISABLE_TRUST_AGENTS} flag.
 * <p>If {@link #KEYGUARD_DISABLE_TRUST_AGENTS} is set and options is not null for all admins,
 * then it's up to the TrustAgent itself to aggregate the values from all device admins.
 * <p>Consult documentation for the specific TrustAgent to determine legal options parameters.
 */
","/**
 * Sets a list of configuration features to enable for a TrustAgent component. This is meant
 * to be used in conjunction with {@link #KEYGUARD_DISABLE_TRUST_AGENTS}, which disables all
 * trust agents but those enabled by this function call. If flag
 * {@link #KEYGUARD_DISABLE_TRUST_AGENTS} is not set, then this call has no effect.
 *
 * <p>The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_DISABLE_KEYGUARD_FEATURES} to be able to call
 * this method; if not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param target Component name of the agent to be enabled.
 * @param configuration TrustAgent-specific feature bundle. If null for any admin, agent
 * will be strictly disabled according to the state of the
 * {@link #KEYGUARD_DISABLE_TRUST_AGENTS} flag.
 * <p>If {@link #KEYGUARD_DISABLE_TRUST_AGENTS} is set and options is not null for all admins,
 * then it's up to the TrustAgent itself to aggregate the values from all device admins.
 * <p>Consult documentation for the specific TrustAgent to determine legal options parameters.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,"The method 'mService.setTrustAgentConfiguration' is a dependent API and its invocation has changed by removing the last parameter in the late version. Therefore, the code change type is 5.","The change in the dependent API invocation may lead to a change in behavior since a parameter is no longer being passed, which could affect the outcome of the call, thus the CI type is 1."
224,<android.widget.ImageView: Drawable getDrawable()>,22,23,<android.widget.ImageView: Drawable getDrawable()>,<android.widget.ImageView: Drawable getDrawable()>,0,"{
    return mDrawable;
}","{
    if (mDrawable == mRecycleableBitmapDrawable) {
        // Consider our cached version dirty since app code now has a reference to it
        mRecycleableBitmapDrawable = null;
    }
    return mDrawable;
}",1,"/**
 * Return the view's drawable, or null if no drawable has been
 * assigned.
 */
","/**
 * Return the view's drawable, or null if no drawable has been
 * assigned.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The late implementation includes an additional control statement (if condition) and an assignment (mRecycleableBitmapDrawable = null), indicating a change in the control dependency (type 3) as well as another statement change (type 4). However, the return statement itself remains unchanged.","Despite the new 'if' condition and the nulling of mRecycleableBitmapDrawable, the actual return value of getDrawable() remains the same, as mDrawable is returned in both early and late implementations. Therefore, there is no compatibility issue regarding the return value or type (mDrawable is not modified before the return statement), nor is there a change in exception handling."
225,"<android.app.admin.DevicePolicyManager: void setAutoTimeRequired(ComponentName,boolean)>",22,23,"<android.app.admin.DevicePolicyManager: void setAutoTimeRequired(ComponentName,boolean)>","<android.app.admin.DevicePolicyManager: void setAutoTimeRequired(ComponentName,boolean)>",0,"{
    if (mService != null) {
        try {
            mService.setAutoTimeRequired(admin, UserHandle.myUserId(), required);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    if (mService != null) {
        try {
            mService.setAutoTimeRequired(admin, required);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}",1,"/**
 * Called by a device owner to set whether auto time is required. If auto time is
 * required the user cannot set the date and time, but has to use network date and time.
 *
 * <p>Note: if auto time is required the user can still manually set the time zone.
 *
 * <p>The calling device admin must be a device owner. If it is not, a security exception will
 * be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param required Whether auto time is set required or not.
 */
","/**
 * Called by a device owner to set whether auto time is required. If auto time is
 * required the user cannot set the date and time, but has to use network date and time.
 *
 * <p>Note: if auto time is required the user can still manually set the time zone.
 *
 * <p>The calling device admin must be a device owner. If it is not, a security exception will
 * be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param required Whether auto time is set required or not.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method signature of `mService.setAutoTimeRequired` has changed in the late version with one less parameter being passed through, specifically `UserHandle.myUserId()`. This indicates that the implementation no longer specifies the user ID as part of the method call. This signifies a dependent API change, so the code change type is 5.","This code change doesn't result in a compatibility issue because the method `setAutoTimeRequired` does not return any values, nor does it throw checked exceptions that are caught by the caller. The method still catches the `RemoteException` and logs it without changing the exception handling or the return type. Hence, the behavior exposed to the caller does not vary between versions. Therefore, the CI type is 0."
227,"<android.app.backup.BackupAgent.BackupServiceBinder: void doRestore(ParcelFileDescriptor,int,ParcelFileDescriptor,int,IBackupManager)>",22,23,"<android.app.backup.BackupAgent.BackupServiceBinder: void doRestore(ParcelFileDescriptor,int,ParcelFileDescriptor,int,IBackupManager)>","<android.app.backup.BackupAgent.BackupServiceBinder: void doRestore(ParcelFileDescriptor,int,ParcelFileDescriptor,int,IBackupManager)>",0,"{
    // Ensure that we're running with the app's normal permission level
    long ident = Binder.clearCallingIdentity();
    if (DEBUG)
        Log.v(TAG, ""doRestore() invoked"");
    BackupDataInput input = new BackupDataInput(data.getFileDescriptor());
    try {
        BackupAgent.this.onRestore(input, appVersionCode, newState);
    } catch (IOException ex) {
        Log.d(TAG, ""onRestore ("" + BackupAgent.this.getClass().getName() + "") threw"", ex);
        throw new RuntimeException(ex);
    } catch (RuntimeException ex) {
        Log.d(TAG, ""onRestore ("" + BackupAgent.this.getClass().getName() + "") threw"", ex);
        throw ex;
    } finally {
        // Ensure that any side-effect SharedPreferences writes have landed
        waitForSharedPrefs();
        Binder.restoreCallingIdentity(ident);
        try {
            callbackBinder.opComplete(token);
        } catch (RemoteException e) {
        // we'll time out anyway, so we're safe
        }
    }
}","{
    // Ensure that we're running with the app's normal permission level
    long ident = Binder.clearCallingIdentity();
    if (DEBUG)
        Log.v(TAG, ""doRestore() invoked"");
    BackupDataInput input = new BackupDataInput(data.getFileDescriptor());
    try {
        BackupAgent.this.onRestore(input, appVersionCode, newState);
    } catch (IOException ex) {
        Log.d(TAG, ""onRestore ("" + BackupAgent.this.getClass().getName() + "") threw"", ex);
        throw new RuntimeException(ex);
    } catch (RuntimeException ex) {
        Log.d(TAG, ""onRestore ("" + BackupAgent.this.getClass().getName() + "") threw"", ex);
        throw ex;
    } finally {
        // Ensure that any side-effect SharedPreferences writes have landed
        waitForSharedPrefs();
        Binder.restoreCallingIdentity(ident);
        try {
            callbackBinder.opComplete(token, 0);
        } catch (RemoteException e) {
        // we'll time out anyway, so we're safe
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The only difference is the addition of the parameter '0' to the method call callbackBinder.opComplete(token, 0) in the finally block, which does not alter the control flow of the method or its exception handling and is not expected to affect the behavior observed by callers of doRestore. Therefore, the code change type is 4.",There's no Compatibility Issue because the change in the argument passed to callbackBinder.opComplete does not affect the behavior of this API method with respect to its return value or exception handling from the perspective of the caller.
230,"<android.transition.Transition: TransitionValues getMatchedTransitionValues(View,boolean)>",22,23,"<android.transition.Transition: TransitionValues getMatchedTransitionValues(View,boolean)>","<android.transition.Transition: TransitionValues getMatchedTransitionValues(View,boolean)>",0,"{
    if (mParent != null) {
        return mParent.getMatchedTransitionValues(view, viewInStart);
    }
    ArrayList<TransitionValues> lookIn = viewInStart ? mStartValuesList : mEndValuesList;
    if (lookIn == null) {
        return null;
    }
    int count = lookIn.size();
    int index = -1;
    for (int i = 0; i < count; i++) {
        TransitionValues values = lookIn.get(i);
        if (values == null) {
            return null;
        }
        if (values.view == view) {
            index = i;
            break;
        }
    }
    TransitionValues values = null;
    if (index >= 0) {
        ArrayList<TransitionValues> matchIn = viewInStart ? mEndValuesList : mStartValuesList;
        values = matchIn.get(index);
    }
    return values;
}","{
    if (mParent != null) {
        return mParent.getMatchedTransitionValues(view, viewInStart);
    }
    ArrayList<TransitionValues> lookIn = viewInStart ? mStartValuesList : mEndValuesList;
    if (lookIn == null) {
        return null;
    }
    int count = lookIn.size();
    int index = -1;
    for (int i = 0; i < count; i++) {
        TransitionValues values = lookIn.get(i);
        if (values == null) {
            // Null values are always added to the end of the list, so we know to stop now.
            return null;
        }
        if (values.view == view) {
            index = i;
            break;
        }
    }
    TransitionValues values = null;
    if (index >= 0) {
        ArrayList<TransitionValues> matchIn = viewInStart ? mEndValuesList : mStartValuesList;
        values = matchIn.get(index);
    }
    return values;
}",1,"/**
 * Find the matched start or end value for a given View. This is only valid
 * after playTransition starts. For example, it will be valid in
 * {@link #createAnimator(android.view.ViewGroup, TransitionValues, TransitionValues)}, but not
 * in {@link #captureStartValues(TransitionValues)}.
 *
 * @param view The view to find the match for.
 * @param viewInStart Is View from the start values or end values.
 * @return The matching TransitionValues for view in either start or end values, depending
 * on viewInStart or null if there is no match for the given view.
 */
","/**
 * Find the matched start or end value for a given View. This is only valid
 * after playTransition starts. For example, it will be valid in
 * {@link #createAnimator(android.view.ViewGroup, TransitionValues, TransitionValues)}, but not
 * in {@link #captureStartValues(TransitionValues)}.
 *
 * @param view The view to find the match for.
 * @param viewInStart Is View from the start values or end values.
 * @return The matching TransitionValues for view in either start or end values, depending
 * on viewInStart or null if there is no match for the given view.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change introduced is the addition of a comment inside the 'if' block that checks for a null value in the ArrayList. This change is a simple comment which does not affect the code execution, so the code change type is 4.","Since the change made is only a comment and does not affect the actual execution of the code, there is no difference in the API's behavior; therefore, there would be no Compatibility Issue, which corresponds to CI type 0."
235,"<android.app.admin.DevicePolicyManager: void setPasswordMinimumSymbols(ComponentName,int)>",22,23,"<android.app.admin.DevicePolicyManager: void setPasswordMinimumSymbols(ComponentName,int)>","<android.app.admin.DevicePolicyManager: void setPasswordMinimumSymbols(ComponentName,int)>",0,"{
    if (mService != null) {
        try {
            mService.setPasswordMinimumSymbols(admin, length, UserHandle.myUserId());
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    if (mService != null) {
        try {
            mService.setPasswordMinimumSymbols(admin, length);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}",1,"/**
 * Called by an application that is administering the device to set the
 * minimum number of symbols required in the password. After setting this,
 * the user will not be able to enter a new password that is not at least as
 * restrictive as what has been set. Note that the current password will
 * remain until the user has set a new one, so the change does not take
 * place immediately. To prompt the user for a new password, use
 * {@link #ACTION_SET_NEW_PASSWORD} after setting this value. This
 * constraint is only imposed if the administrator has also requested
 * {@link #PASSWORD_QUALITY_COMPLEX} with {@link #setPasswordQuality}. The
 * default value is 1.
 * <p>
 * The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call
 * this method; if it has not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated
 * with.
 * @param length The new desired minimum number of symbols required in the
 * password. A value of 0 means there is no restriction.
 */
","/**
 * Called by an application that is administering the device to set the
 * minimum number of symbols required in the password. After setting this,
 * the user will not be able to enter a new password that is not at least as
 * restrictive as what has been set. Note that the current password will
 * remain until the user has set a new one, so the change does not take
 * place immediately. To prompt the user for a new password, use
 * {@link #ACTION_SET_NEW_PASSWORD} after setting this value. This
 * constraint is only imposed if the administrator has also requested
 * {@link #PASSWORD_QUALITY_COMPLEX} with {@link #setPasswordQuality}. The
 * default value is 1.
 * <p>
 * The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call
 * this method; if it has not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated
 * with.
 * @param length The new desired minimum number of symbols required in the
 * password. A value of 0 means there is no restriction.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent method called within the implementation, mService.setPasswordMinimumSymbols(admin, length, UserHandle.myUserId()), had its signature changed to mService.setPasswordMinimumSymbols(admin, length) by removing a parameter. This indicates that a dependent API has changed (change type 5).","There is no compatibility issue because the API's functionality regarding its signature and exception handling remains the same from the perspective of the calling code. The internal change doesn't directly affect the callers as the method signature for setPasswordMinimumSymbols(ComponentName,int) remains unchanged and no exception handling or return statements have been modified. Even though the dependent API's signature has been altered, that is visible only within the internal implementation and not to the API consumers. Therefore, the type is 0."
236,<android.net.ConnectivityManager: Network getProcessDefaultNetwork()>,22,23,<android.net.ConnectivityManager: Network getProcessDefaultNetwork()>,<android.net.ConnectivityManager: Network getProcessDefaultNetwork()>,0,"{
    int netId = NetworkUtils.getNetworkBoundToProcess();
    if (netId == NETID_UNSET)
        return null;
    return new Network(netId);
}","{
    int netId = NetworkUtils.getBoundNetworkForProcess();
    if (netId == NETID_UNSET)
        return null;
    return new Network(netId);
}",1,"/**
 * Returns the {@link Network} currently bound to this process via
 * {@link #setProcessDefaultNetwork}, or {@code null} if no {@link Network} is explicitly bound.
 *
 * @return {@code Network} to which this process is bound, or {@code null}.
 */
","/**
 * Returns the {@link Network} currently bound to this process via
 * {@link #bindProcessToNetwork}, or {@code null} if no {@link Network} is explicitly bound.
 *
 * @return {@code Network} to which this process is bound, or {@code null}.
 * @deprecated Using this function can lead to other functions throwing
 * {@link IllegalStateException}.  Use {@link #getBoundNetworkForProcess} instead.
 * {@code getBoundNetworkForProcess} is a direct replacement.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent API used in the early implementation (NetworkUtils.getNetworkBoundToProcess()) has been changed to a different API (NetworkUtils.getBoundNetworkForProcess()) in the late implementation, so the code change type is 5.","There is no Compatibility Issue in this case as the change does not alter the behavior of the existing API in a way that would lead to different return values or exception handling. The renamed method is expected to fulfill the same contract as the original method, assuming that the implementation of getBoundNetworkForProcess() is meant to replace getNetworkBoundToProcess() without changing the return value or exception behavior."
237,<android.speech.tts.TextToSpeech: int setLanguage(Locale)>,22,23,<android.speech.tts.TextToSpeech: int setLanguage(Locale)>,<android.speech.tts.TextToSpeech: int setLanguage(Locale)>,0,"{
    return runAction(new Action<Integer>() {

        @Override
        public Integer run(ITextToSpeechService service) throws RemoteException {
            if (loc == null) {
                return LANG_NOT_SUPPORTED;
            }
            String language = null, country = null;
            try {
                language = loc.getISO3Language();
            } catch (MissingResourceException e) {
                Log.w(TAG, ""Couldn't retrieve ISO 639-2/T language code for locale: "" + loc, e);
                return LANG_NOT_SUPPORTED;
            }
            try {
                country = loc.getISO3Country();
            } catch (MissingResourceException e) {
                Log.w(TAG, ""Couldn't retrieve ISO 3166 country code for locale: "" + loc, e);
                return LANG_NOT_SUPPORTED;
            }
            String variant = loc.getVariant();
            // As of API level 21, setLanguage is implemented using setVoice.
            // (which, in the default implementation, will call loadLanguage on the service
            // interface).
            // Sanitize locale using isLanguageAvailable.
            int result = service.isLanguageAvailable(language, country, variant);
            if (result >= LANG_AVAILABLE) {
                if (result < LANG_COUNTRY_VAR_AVAILABLE) {
                    variant = """";
                    if (result < LANG_COUNTRY_AVAILABLE) {
                        country = """";
                    }
                }
                // Get the default voice for the locale.
                String voiceName = service.getDefaultVoiceNameFor(language, country, variant);
                if (TextUtils.isEmpty(voiceName)) {
                    Log.w(TAG, ""Couldn't find the default voice for "" + language + ""/"" + country + ""/"" + variant);
                    return LANG_NOT_SUPPORTED;
                }
                // Load it.
                if (service.loadVoice(getCallerIdentity(), voiceName) == TextToSpeech.ERROR) {
                    return LANG_NOT_SUPPORTED;
                }
                mParams.putString(Engine.KEY_PARAM_VOICE_NAME, voiceName);
                mParams.putString(Engine.KEY_PARAM_LANGUAGE, language);
                mParams.putString(Engine.KEY_PARAM_COUNTRY, country);
                mParams.putString(Engine.KEY_PARAM_VARIANT, variant);
            }
            return result;
        }
    }, LANG_NOT_SUPPORTED, ""setLanguage"");
}","{
    return runAction(new Action<Integer>() {

        @Override
        public Integer run(ITextToSpeechService service) throws RemoteException {
            if (loc == null) {
                return LANG_NOT_SUPPORTED;
            }
            String language = null, country = null;
            try {
                language = loc.getISO3Language();
            } catch (MissingResourceException e) {
                Log.w(TAG, ""Couldn't retrieve ISO 639-2/T language code for locale: "" + loc, e);
                return LANG_NOT_SUPPORTED;
            }
            try {
                country = loc.getISO3Country();
            } catch (MissingResourceException e) {
                Log.w(TAG, ""Couldn't retrieve ISO 3166 country code for locale: "" + loc, e);
                return LANG_NOT_SUPPORTED;
            }
            String variant = loc.getVariant();
            // As of API level 21, setLanguage is implemented using setVoice.
            // (which, in the default implementation, will call loadLanguage on the service
            // interface).
            // Sanitize locale using isLanguageAvailable.
            int result = service.isLanguageAvailable(language, country, variant);
            if (result >= LANG_AVAILABLE) {
                // Get the default voice for the locale.
                String voiceName = service.getDefaultVoiceNameFor(language, country, variant);
                if (TextUtils.isEmpty(voiceName)) {
                    Log.w(TAG, ""Couldn't find the default voice for "" + language + ""-"" + country + ""-"" + variant);
                    return LANG_NOT_SUPPORTED;
                }
                // Load it.
                if (service.loadVoice(getCallerIdentity(), voiceName) == TextToSpeech.ERROR) {
                    Log.w(TAG, ""The service claimed "" + language + ""-"" + country + ""-"" + variant + "" was available with voice name "" + voiceName + "" but loadVoice returned ERROR"");
                    return LANG_NOT_SUPPORTED;
                }
                // Set the language/country/variant of the voice, so #getLanguage will return
                // the currently set voice locale when called.
                Voice voice = getVoice(service, voiceName);
                if (voice == null) {
                    Log.w(TAG, ""getDefaultVoiceNameFor returned "" + voiceName + "" for locale "" + language + ""-"" + country + ""-"" + variant + "" but getVoice returns null"");
                    return LANG_NOT_SUPPORTED;
                }
                String voiceLanguage = """";
                try {
                    voiceLanguage = voice.getLocale().getISO3Language();
                } catch (MissingResourceException e) {
                    Log.w(TAG, ""Couldn't retrieve ISO 639-2/T language code for locale: "" + voice.getLocale(), e);
                }
                String voiceCountry = """";
                try {
                    voiceCountry = voice.getLocale().getISO3Country();
                } catch (MissingResourceException e) {
                    Log.w(TAG, ""Couldn't retrieve ISO 3166 country code for locale: "" + voice.getLocale(), e);
                }
                mParams.putString(Engine.KEY_PARAM_VOICE_NAME, voiceName);
                mParams.putString(Engine.KEY_PARAM_LANGUAGE, voiceLanguage);
                mParams.putString(Engine.KEY_PARAM_COUNTRY, voiceCountry);
                mParams.putString(Engine.KEY_PARAM_VARIANT, voice.getLocale().getVariant());
            }
            return result;
        }
    }, LANG_NOT_SUPPORTED, ""setLanguage"");
}",1,"/**
 * Sets the text-to-speech language.
 * The TTS engine will try to use the closest match to the specified
 * language as represented by the Locale, but there is no guarantee that the exact same Locale
 * will be used. Use {@link #isLanguageAvailable(Locale)} to check the level of support
 * before choosing the language to use for the next utterances.
 *
 * This method sets the current voice to the default one for the given Locale;
 * {@link #getVoice()} can be used to retrieve it.
 *
 * @param loc The locale describing the language to be used.
 *
 * @return Code indicating the support status for the locale. See {@link #LANG_AVAILABLE},
 * {@link #LANG_COUNTRY_AVAILABLE}, {@link #LANG_COUNTRY_VAR_AVAILABLE},
 * {@link #LANG_MISSING_DATA} and {@link #LANG_NOT_SUPPORTED}.
 */
","/**
 * Sets the text-to-speech language.
 * The TTS engine will try to use the closest match to the specified
 * language as represented by the Locale, but there is no guarantee that the exact same Locale
 * will be used. Use {@link #isLanguageAvailable(Locale)} to check the level of support
 * before choosing the language to use for the next utterances.
 *
 * This method sets the current voice to the default one for the given Locale;
 * {@link #getVoice()} can be used to retrieve it.
 *
 * @param loc The locale describing the language to be used.
 *
 * @return Code indicating the support status for the locale. See {@link #LANG_AVAILABLE},
 * {@link #LANG_COUNTRY_AVAILABLE}, {@link #LANG_COUNTRY_VAR_AVAILABLE},
 * {@link #LANG_MISSING_DATA} and {@link #LANG_NOT_SUPPORTED}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
238,"<android.hardware.camera2.params.StreamConfigurationMap: long getOutputStallDuration(Class<T>,Size)>",22,23,"<android.hardware.camera2.params.StreamConfigurationMap: long getOutputStallDuration(Class<T>,Size)>","<android.hardware.camera2.params.StreamConfigurationMap: long getOutputStallDuration(Class<T>,Size)>",0,"{
    if (!isOutputSupportedFor(klass)) {
        throw new IllegalArgumentException(""klass was not supported"");
    }
    return getInternalFormatDuration(HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED, size, DURATION_STALL);
}","{
    if (!isOutputSupportedFor(klass)) {
        throw new IllegalArgumentException(""klass was not supported"");
    }
    return getInternalFormatDuration(HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED, HAL_DATASPACE_UNKNOWN, size, DURATION_STALL);
}",1,"/**
 * Get the stall duration for the class/size combination (in nanoseconds).
 *
 * <p>This assumes a the {@code klass} is set up to use an implementation-defined format.
 * For user-defined formats, use {@link #getOutputMinFrameDuration(int, Size)}.</p>
 *
 * <p>{@code klass} should be one of the ones with a non-empty array returned by
 * {@link #getOutputSizes(Class)}.</p>
 *
 * <p>{@code size} should be one of the ones returned by
 * {@link #getOutputSizes(Class)}.</p>
 *
 * <p>See {@link #getOutputStallDuration(int, Size)} for a definition of a
 * <em>stall duration</em>.</p>
 *
 * @param klass
 * a class which is supported by {@link #isOutputSupportedFor(Class)} and has a
 * non-empty array returned by {@link #getOutputSizes(Class)}
 * @param size an output-compatible size
 * @return a minimum frame duration {@code >=} 0 in nanoseconds
 *
 * @throws IllegalArgumentException if {@code klass} or {@code size} was not supported
 * @throws NullPointerException if {@code size} or {@code klass} was {@code null}
 *
 * @see CaptureRequest#SENSOR_FRAME_DURATION
 * @see ImageFormat
 * @see PixelFormat
 */
","/**
 * Get the stall duration for the class/size combination (in nanoseconds).
 *
 * <p>This assumes a the {@code klass} is set up to use {@link ImageFormat#PRIVATE}.
 * For user-defined formats, use {@link #getOutputMinFrameDuration(int, Size)}.</p>
 *
 * <p>{@code klass} should be one of the ones with a non-empty array returned by
 * {@link #getOutputSizes(Class)}.</p>
 *
 * <p>{@code size} should be one of the ones returned by
 * {@link #getOutputSizes(Class)}.</p>
 *
 * <p>See {@link #getOutputStallDuration(int, Size)} for a definition of a
 * <em>stall duration</em>.</p>
 *
 * @param klass
 * a class which is supported by {@link #isOutputSupportedFor(Class)} and has a
 * non-empty array returned by {@link #getOutputSizes(Class)}
 * @param size an output-compatible size
 * @return a minimum frame duration {@code >=} 0 in nanoseconds
 *
 * @throws IllegalArgumentException if {@code klass} or {@code size} was not supported
 * @throws NullPointerException if {@code size} or {@code klass} was {@code null}
 *
 * @see CaptureRequest#SENSOR_FRAME_DURATION
 * @see ImageFormat
 * @see PixelFormat
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method getInternalFormatDuration has a new parameter HAL_DATASPACE_UNKNOWN in its argument list, indicating that it's a case of Dependent API changed, so the code change type is 5.","There is no change in the control flow or the exceptions thrown, and while an additional parameter is being passed to a method call within the function, this does not directly indicate that the behavior externally visible to the callers of getOutputStallDuration would be altered. Therefore, there is no Compatibility Issue based on the information provided, as there is no evidence of a change in expected return values or exceptions being thrown. Thus, the CI type is 0."
240,<android.app.Notification.Builder: Notification build()>,22,23,<android.app.Notification.Builder: Notification build()>,<android.app.Notification.Builder: Notification build()>,0,"{
    mOriginatingUserId = mContext.getUserId();
    mHasThreeLines = hasThreeLines();
    Notification n = buildUnstyled();
    if (mStyle != null) {
        n = mStyle.buildStyled(n);
    }
    if (mExtras != null) {
        n.extras.putAll(mExtras);
    }
    if (mRebuildBundle.size() > 0) {
        n.extras.putAll(mRebuildBundle);
        mRebuildBundle.clear();
    }
    populateExtras(n.extras);
    if (mStyle != null) {
        mStyle.addExtras(n.extras);
    }
    mHasThreeLines = false;
    return n;
}","{
    if (mSmallIcon != null) {
        mSmallIcon.convertToAshmem();
    }
    if (mLargeIcon != null) {
        mLargeIcon.convertToAshmem();
    }
    mOriginatingUserId = mContext.getUserId();
    mHasThreeLines = hasThreeLines();
    Notification n = buildUnstyled();
    if (mStyle != null) {
        mStyle.purgeResources();
        n = mStyle.buildStyled(n);
    }
    if (mExtras != null) {
        n.extras.putAll(mExtras);
    }
    if (mRebuildBundle.size() > 0) {
        n.extras.putAll(mRebuildBundle);
        mRebuildBundle.clear();
    }
    populateExtras(n.extras);
    if (mStyle != null) {
        mStyle.addExtras(n.extras);
    }
    mHasThreeLines = false;
    return n;
}",1,"/**
 * Combine all of the options that have been set and return a new {@link Notification}
 * object.
 */
","/**
 * Combine all of the options that have been set and return a new {@link Notification}
 * object.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"There are additional calls to convertToAshmem() on mSmallIcon and mLargeIcon, and a call to purgeResources() on mStyle in the late version of the code. These are 'other statements' (code change type 4). Additionally, there is a control dependency change (code change type 3) due to the new conditionals checking if mSmallIcon and mLargeIcon are non-null.","Although new method calls (convertToAshmem() and purgeResources()) have been added, these do not affect the returned Notification object's properties directly. The build() method's contract seems to be preserved since these calls are managing memory usage optimization internally, not altering the structure or values of the Notification to be returned. Therefore, no compatibility issue is expected to arise from these changes."
241,<android.app.Notification.BigPictureStyle: BigPictureStyle bigLargeIcon(Bitmap)>,22,23,<android.app.Notification.BigPictureStyle: BigPictureStyle bigLargeIcon(Bitmap)>,<android.app.Notification.BigPictureStyle: BigPictureStyle bigLargeIcon(Bitmap)>,0,"{
    mBigLargeIconSet = true;
    mBigLargeIcon = b;
    return this;
}","{
    return bigLargeIcon(b != null ? Icon.createWithBitmap(b) : null);
}",1,"/**
 * Override the large icon when the big notification is shown.
 */
","/**
 * Override the large icon when the big notification is shown.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The implementation in the late version is redirecting to another method call instead of directly setting the fields as in the early version. However, this does not imply a change in the visible behavior or the return type of the method. Therefore, the change type is Other statement changed (4).","There is No Compatibility Issue because the change in implementation does not alter the returned object nor the result that would be visible to the caller. The call is still returning the same object 'this', which means the interface of the method in terms of return value remains the same."
242,<android.content.ContentResolver: Uri uncanonicalize(Uri)>,22,23,<android.content.ContentResolver: Uri uncanonicalize(Uri)>,<android.content.ContentResolver: Uri uncanonicalize(Uri)>,0,"{
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        return null;
    }
    try {
        return provider.uncanonicalize(mPackageName, url);
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        releaseProvider(provider);
    }
}","{
    Preconditions.checkNotNull(url, ""url"");
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        return null;
    }
    try {
        return provider.uncanonicalize(mPackageName, url);
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        releaseProvider(provider);
    }
}",1,"/**
 * Given a canonical Uri previously generated by {@link #canonicalize}, convert
 * it to its local non-canonical form.  This can be useful in some cases where
 * you know that you will only be using the Uri in the current environment and
 * want to avoid any possible overhead when using it with the content
 * provider or want to verify that the referenced data exists at all in the
 * new environment.
 *
 * @param url The canonical {@link Uri} that is to be convered back to its
 * non-canonical form.
 *
 * @return Returns the non-canonical representation of <var>url</var>.  This will
 * return null if data identified by the canonical Uri can not be found in
 * the current environment; callers must always check for null and deal with
 * that by appropriately falling back to an alternative.
 *
 * @see #canonicalize
 */
","/**
 * Given a canonical Uri previously generated by {@link #canonicalize}, convert
 * it to its local non-canonical form.  This can be useful in some cases where
 * you know that you will only be using the Uri in the current environment and
 * want to avoid any possible overhead when using it with the content
 * provider or want to verify that the referenced data exists at all in the
 * new environment.
 *
 * @param url The canonical {@link Uri} that is to be convered back to its
 * non-canonical form.
 *
 * @return Returns the non-canonical representation of <var>url</var>.  This will
 * return null if data identified by the canonical Uri can not be found in
 * the current environment; callers must always check for null and deal with
 * that by appropriately falling back to an alternative.
 *
 * @see #canonicalize
 */
",-1,,[@Nullable],-1,-1,-1,-1,-1,-1,4,0,"Only an additional statement, Preconditions.checkNotNull(url, ""url""), has been added at the beginning of the method to check if the passed argument 'url' is not null. This counts as an Other statement changed (4).","The added preconditions check does not lead to a Compatibility Issue since it is validating input that the previous implementation implicitly required to be non-null (as a null 'url' would lead to a NullPointerException when 'acquireProvider(url)' is called). Such a check ensures that the method behaves as expected when given null input, and will fail-fast with a clear exception message rather than a null pointer exception later in the execution. So, there is no Compatibility Issue (0)."
245,"<android.app.ApplicationThreadProxy: void scheduleCreateService(IBinder,ServiceInfo,CompatibilityInfo,int)>",22,23,"<android.app.ApplicationThreadProxy: void scheduleCreateService(IBinder,ServiceInfo,CompatibilityInfo,int)>","<android.app.ApplicationThreadProxy: void scheduleCreateService(IBinder,ServiceInfo,CompatibilityInfo,int)>",0,"{
    Parcel data = Parcel.obtain();
    data.writeInterfaceToken(IApplicationThread.descriptor);
    data.writeStrongBinder(token);
    info.writeToParcel(data, 0);
    compatInfo.writeToParcel(data, 0);
    data.writeInt(processState);
    mRemote.transact(SCHEDULE_CREATE_SERVICE_TRANSACTION, data, null, IBinder.FLAG_ONEWAY);
    data.recycle();
}","{
    Parcel data = Parcel.obtain();
    data.writeInterfaceToken(IApplicationThread.descriptor);
    data.writeStrongBinder(token);
    info.writeToParcel(data, 0);
    compatInfo.writeToParcel(data, 0);
    data.writeInt(processState);
    try {
        mRemote.transact(SCHEDULE_CREATE_SERVICE_TRANSACTION, data, null, IBinder.FLAG_ONEWAY);
    } catch (TransactionTooLargeException e) {
        Log.e(""CREATE_SERVICE"", ""Binder failure starting service; service="" + info);
        throw e;
    }
    data.recycle();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"The late version of the method has wrapped the transact call in a try-catch block to catch and handle `TransactionTooLargeException`. This constitutes a change in exception handling statements (code change type 2) and also a new logging statement inside the catch block, which is an other statement change (code change type 4).","The introduction of a new catch block for `TransactionTooLargeException` will alter the behavior of the method in circumstances where this exception is thrown, which now results in an error being logged and the exception being rethrown (CI type 2). Previously, if such an exception occurred, it would not be logged, and the exception would not be explicitly caught and rethrown by this method."
246,"<android.text.format.Formatter: String formatFileSize(Context,long)>",22,23,"<android.text.format.Formatter: String formatFileSize(Context,long)>","<android.text.format.Formatter: String formatFileSize(Context,long)>",0,"{
    return formatFileSize(context, number, false);
}","{
    if (context == null) {
        return """";
    }
    final BytesResult res = formatBytes(context.getResources(), sizeBytes, 0);
    return bidiWrap(context, context.getString(com.android.internal.R.string.fileSizeSuffix, res.value, res.units));
}",1,"/**
 * Formats a content size to be in the form of bytes, kilobytes, megabytes, etc
 *
 * @param context Context to use to load the localized units
 * @param number size value to be formatted
 * @return formatted string with the number
 */
","/**
 * Formats a content size to be in the form of bytes, kilobytes, megabytes, etc.
 *
 * If the context has a right-to-left locale, the returned string is wrapped in bidi formatting
 * characters to make sure it's displayed correctly if inserted inside a right-to-left string.
 * (This is useful in cases where the unit strings, like ""MB"", are left-to-right, but the
 * locale is right-to-left.)
 *
 * @param context Context to use to load the localized units
 * @param sizeBytes size value to be formatted, in bytes
 * @return formatted string with the number
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The early version implementation calls another method with a different signature, formatFileSize(Context, long, boolean), while the late version implementation has a completely new set of statements, introducing control flow, local variable declaration, and a computation that did not exist before (formatBytes and bidiWrap calls). This includes new checks for a null context, the introduction of the BytesResult res variable, and String formatting with resources from the context. These changes span across return statement change (1), control dependency change (3), the other statement change (4), and dependent API change (5), as the implementation in the late version relies on different methods (formatBytes and bidiWrap).","The late version introduces a new return value for the case where context is null, which was not present in the early version. Additionally, the way the file size is formatted has completely changed, which will potentially lead to different return values even when the context is not null. The removal of the previous method call and the change in logic for calculating the file size indicate a compatibility issue due to potential different return values or types, thus CI type is 1."
248,"<android.app.admin.DevicePolicyManager: boolean resetPassword(String,int)>",22,23,"<android.app.admin.DevicePolicyManager: boolean resetPassword(String,int)>","<android.app.admin.DevicePolicyManager: boolean resetPassword(String,int)>",0,"{
    if (mService != null) {
        try {
            return mService.resetPassword(password, flags, UserHandle.myUserId());
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
    return false;
}","{
    if (mService != null) {
        try {
            return mService.resetPassword(password, flags);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
    return false;
}",1,"/**
 * Force a new device unlock password (the password needed to access the
 * entire device, not for individual accounts) on the user.  This takes
 * effect immediately.
 * The given password must be sufficient for the
 * current password quality and length constraints as returned by
 * {@link #getPasswordQuality(ComponentName)} and
 * {@link #getPasswordMinimumLength(ComponentName)}; if it does not meet
 * these constraints, then it will be rejected and false returned.  Note
 * that the password may be a stronger quality (containing alphanumeric
 * characters when the requested quality is only numeric), in which case
 * the currently active quality will be increased to match.
 *
 * <p>Calling with a null or empty password will clear any existing PIN,
 * pattern or password if the current password constraints allow it.
 *
 * <p>The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_RESET_PASSWORD} to be able to call
 * this method; if it has not, a security exception will be thrown.
 *
 * <p>Calling this from a managed profile will throw a security exception.
 *
 * @param password The new password for the user. Null or empty clears the password.
 * @param flags May be 0 or {@link #RESET_PASSWORD_REQUIRE_ENTRY}.
 * @return Returns true if the password was applied, or false if it is
 * not acceptable for the current constraints.
 */
","/**
 * Force a new device unlock password (the password needed to access the
 * entire device, not for individual accounts) on the user.  This takes
 * effect immediately.
 * The given password must be sufficient for the
 * current password quality and length constraints as returned by
 * {@link #getPasswordQuality(ComponentName)} and
 * {@link #getPasswordMinimumLength(ComponentName)}; if it does not meet
 * these constraints, then it will be rejected and false returned.  Note
 * that the password may be a stronger quality (containing alphanumeric
 * characters when the requested quality is only numeric), in which case
 * the currently active quality will be increased to match.
 *
 * <p>Calling with a null or empty password will clear any existing PIN,
 * pattern or password if the current password constraints allow it.
 *
 * <p>The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_RESET_PASSWORD} to be able to call
 * this method; if it has not, a security exception will be thrown.
 *
 * <p>Calling this from a managed profile will throw a security exception.
 *
 * @param password The new password for the user. Null or empty clears the password.
 * @param flags May be 0 or combination of {@link #RESET_PASSWORD_REQUIRE_ENTRY} and
 * {@link #RESET_PASSWORD_DO_NOT_ASK_CREDENTIALS_ON_BOOT}.
 * @return Returns true if the password was applied, or false if it is
 * not acceptable for the current constraints.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,"The `resetPassword` method in the `mService` object changed the number of parameters; the `UserHandle.myUserId()` parameter has been removed in the later version. Hence, the code change type is 5.","The method `resetPassword` is invoked with different arguments between the two versions, and since the behaviour of `resetPassword` could differ based on the arguments passed to it, this modification might result in the method returning a different value. Hence, the CI type is 1."
249,<android.widget.DayPickerView: int getMostVisiblePosition()>,22,23,<android.widget.DayPickerView: int getMostVisiblePosition()>,<android.widget.DayPickerView: int getMostVisiblePosition()>,0,"{
    final int firstPosition = getFirstVisiblePosition();
    final int height = getHeight();
    int maxDisplayedHeight = 0;
    int mostVisibleIndex = 0;
    int i = 0;
    int bottom = 0;
    while (bottom < height) {
        View child = getChildAt(i);
        if (child == null) {
            break;
        }
        bottom = child.getBottom();
        int displayedHeight = Math.min(bottom, height) - Math.max(0, child.getTop());
        if (displayedHeight > maxDisplayedHeight) {
            mostVisibleIndex = i;
            maxDisplayedHeight = displayedHeight;
        }
        i++;
    }
    return firstPosition + mostVisibleIndex;
}","{
    return mViewPager.getCurrentItem();
}",1,"/**
 * Gets the position of the view that is most prominently displayed within the list view.
 */
","/**
 * Gets the position of the view that is most prominently displayed within the list view.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The implementation of the method completely changed from a calculation using several statements to determine the most visible position to a single call to mViewPager.getCurrentItem(). Thus, the code change type is 1,4 due to the removal and addition of return statements and because this change does not fall under exception handling, control dependency, or dependent API change categories.","Since the return value will be different due to the new implementation that now relies on mViewPager.getCurrentItem(), the API will behave differently. Therefore, the CI type is 1."
251,<android.content.RestrictionEntry: String toString()>,22,23,<android.content.RestrictionEntry: String toString()>,<android.content.RestrictionEntry: String toString()>,0,"{
    return ""RestrictionsEntry {type="" + mType + "", key="" + mKey + "", value="" + mCurrentValue + ""}"";
}","{
    return ""RestrictionEntry{"" + ""mType="" + mType + "", mKey='"" + mKey + '\'' + "", mTitle='"" + mTitle + '\'' + "", mDescription='"" + mDescription + '\'' + "", mChoiceEntries="" + Arrays.toString(mChoiceEntries) + "", mChoiceValues="" + Arrays.toString(mChoiceValues) + "", mCurrentValue='"" + mCurrentValue + '\'' + "", mCurrentValues="" + Arrays.toString(mCurrentValues) + "", mRestrictions="" + Arrays.toString(mRestrictions) + '}';
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The return statement has been completely changed to include different properties of the RestrictionEntry, hence the change type is 1. Additionally, the change includes concatenating string literals and variables, and the use of the Arrays.toString() method for array-type properties is introduced, which is an 'Other statement changed' as it changes the technique for converting array values into strings, so the change type is 4.","The string representation of RestrictionEntry is altered, thus calling `toString()` on instances of this class will return a different value than before, which constitutes a Compatibility Issue of type 1."
253,<android.app.WallpaperManager: void setStream(InputStream)>,22,23,<android.app.WallpaperManager: void setStream(InputStream)>,<android.app.WallpaperManager: void setStream(InputStream)>,0,"{
    if (sGlobals.mService == null) {
        Log.w(TAG, ""WallpaperService not running"");
        return;
    }
    try {
        ParcelFileDescriptor fd = sGlobals.mService.setWallpaper(null);
        if (fd == null) {
            return;
        }
        FileOutputStream fos = null;
        try {
            fos = new ParcelFileDescriptor.AutoCloseOutputStream(fd);
            setWallpaper(data, fos);
        } finally {
            if (fos != null) {
                fos.close();
            }
        }
    } catch (RemoteException e) {
    // Ignore
    }
}","{
    if (sGlobals.mService == null) {
        Log.w(TAG, ""WallpaperService not running"");
        return;
    }
    try {
        ParcelFileDescriptor fd = sGlobals.mService.setWallpaper(null, mContext.getOpPackageName());
        if (fd == null) {
            return;
        }
        FileOutputStream fos = null;
        try {
            fos = new ParcelFileDescriptor.AutoCloseOutputStream(fd);
            setWallpaper(data, fos);
        } finally {
            if (fos != null) {
                fos.close();
            }
        }
    } catch (RemoteException e) {
    // Ignore
    }
}",1,"/**
 * Change the current system wallpaper to a specific byte stream.  The
 * give InputStream is copied into persistent storage and will now be
 * used as the wallpaper.  Currently it must be either a JPEG or PNG
 * image.  On success, the intent {@link Intent#ACTION_WALLPAPER_CHANGED}
 * is broadcast.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#SET_WALLPAPER}.
 *
 * @param data A stream containing the raw data to install as a wallpaper.
 *
 * @throws IOException If an error occurs reverting to the built-in
 * wallpaper.
 */
","/**
 * Change the current system wallpaper to a specific byte stream.  The
 * give InputStream is copied into persistent storage and will now be
 * used as the wallpaper.  Currently it must be either a JPEG or PNG
 * image.  On success, the intent {@link Intent#ACTION_WALLPAPER_CHANGED}
 * is broadcast.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#SET_WALLPAPER}.
 *
 * @param data A stream containing the raw data to install as a wallpaper.
 *
 * @throws IOException If an error occurs reverting to the built-in
 * wallpaper.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,The implementation of method `setWallpaper` has been updated with an additional parameter `mContext.getOpPackageName()` in the late version. The dependent API `sGlobals.mService.setWallpaper()` has changed its parameters which makes the code change type 5.,"There is no Compatibility Issue as the change should not affect the behavior experienced by the clients of the `setStream` method, so the CI type is 0."
254,<android.widget.Spinner: void setPopupBackgroundDrawable(Drawable)>,22,23,<android.widget.Spinner: void setPopupBackgroundDrawable(Drawable)>,<android.widget.Spinner: void setPopupBackgroundDrawable(Drawable)>,0,"{
    if (!(mPopup instanceof DropdownPopup)) {
        Log.e(TAG, ""setPopupBackgroundDrawable: incompatible spinner mode; ignoring..."");
        return;
    }
    ((DropdownPopup) mPopup).setBackgroundDrawable(background);
}","{
    if (!(mPopup instanceof DropdownPopup)) {
        Log.e(TAG, ""setPopupBackgroundDrawable: incompatible spinner mode; ignoring..."");
        return;
    }
    mPopup.setBackgroundDrawable(background);
}",1,"/**
 * Set the background drawable for the spinner's popup window of choices.
 * Only valid in {@link #MODE_DROPDOWN}; this method is a no-op in other modes.
 *
 * @param background Background drawable
 *
 * @attr ref android.R.styleable#Spinner_popupBackground
 */
","/**
 * Set the background drawable for the spinner's popup window of choices.
 * Only valid in {@link #MODE_DROPDOWN}; this method is a no-op in other modes.
 *
 * @param background Background drawable
 *
 * @attr ref android.R.styleable#Spinner_popupBackground
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The invocation of setBackgroundDrawable has changed from the casted type ((DropdownPopup) mPopup) to directly using mPopup, which indicates a change in the actual object mPopup's type or its class's method declarations. This is a change in an ""Other statement"".","There is no Compatibility Issue since the change doesn’t affect the return values or the exceptions thrown by the method. The internal implementation detail about which object's setBackgroundDrawable method is called is abstracted from the API user, presuming that mPopup still refers to a valid object that supports setBackgroundDrawable operation."
255,"<android.app.backup.BackupAgent.BackupServiceBinder: void doBackup(ParcelFileDescriptor,ParcelFileDescriptor,ParcelFileDescriptor,int,IBackupManager)>",22,23,"<android.app.backup.BackupAgent.BackupServiceBinder: void doBackup(ParcelFileDescriptor,ParcelFileDescriptor,ParcelFileDescriptor,int,IBackupManager)>","<android.app.backup.BackupAgent.BackupServiceBinder: void doBackup(ParcelFileDescriptor,ParcelFileDescriptor,ParcelFileDescriptor,int,IBackupManager)>",0,"{
    // Ensure that we're running with the app's normal permission level
    long ident = Binder.clearCallingIdentity();
    if (DEBUG)
        Log.v(TAG, ""doBackup() invoked"");
    BackupDataOutput output = new BackupDataOutput(data.getFileDescriptor());
    try {
        BackupAgent.this.onBackup(oldState, output, newState);
    } catch (IOException ex) {
        Log.d(TAG, ""onBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", ex);
        throw new RuntimeException(ex);
    } catch (RuntimeException ex) {
        Log.d(TAG, ""onBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", ex);
        throw ex;
    } finally {
        // Ensure that any SharedPreferences writes have landed after the backup,
        // in case the app code has side effects (since apps cannot provide this
        // guarantee themselves).
        waitForSharedPrefs();
        Binder.restoreCallingIdentity(ident);
        try {
            callbackBinder.opComplete(token);
        } catch (RemoteException e) {
        // we'll time out anyway, so we're safe
        }
    }
}","{
    // Ensure that we're running with the app's normal permission level
    long ident = Binder.clearCallingIdentity();
    if (DEBUG)
        Log.v(TAG, ""doBackup() invoked"");
    BackupDataOutput output = new BackupDataOutput(data.getFileDescriptor());
    try {
        BackupAgent.this.onBackup(oldState, output, newState);
    } catch (IOException ex) {
        Log.d(TAG, ""onBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", ex);
        throw new RuntimeException(ex);
    } catch (RuntimeException ex) {
        Log.d(TAG, ""onBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", ex);
        throw ex;
    } finally {
        // Ensure that any SharedPreferences writes have landed after the backup,
        // in case the app code has side effects (since apps cannot provide this
        // guarantee themselves).
        waitForSharedPrefs();
        Binder.restoreCallingIdentity(ident);
        try {
            callbackBinder.opComplete(token, 0);
        } catch (RemoteException e) {
        // we'll time out anyway, so we're safe
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The change consists of the addition of a parameter '0' to the method call 'callbackBinder.opComplete(token, 0)' within the 'finally' block. This pertains to a modification in a call to a dependent API, which is a change type 5.","Given the context of this API, the additional '0' parameter is a value being sent to the 'opComplete' method. There is no evidence provided to indicate that the behavior of 'opComplete' has changed between the versions, such as a change in its signature or its internal logic that would lead to a compatibility issue. The added literal '0' to the 'opComplete' call does not by itself imply a changed behavior with respect to what is returned or thrown by 'doBackup' itself, and therefore it does not introduce a compatibility issue in the context of 'doBackup'. Thus, the CI type is 0."
256,<android.widget.TextView: Drawable[] getCompoundDrawables()>,22,23,<android.widget.TextView: Drawable[] getCompoundDrawables()>,<android.widget.TextView: Drawable[] getCompoundDrawables()>,0,"{
    final Drawables dr = mDrawables;
    if (dr != null) {
        return new Drawable[] { dr.mDrawableLeft, dr.mDrawableTop, dr.mDrawableRight, dr.mDrawableBottom };
    } else {
        return new Drawable[] { null, null, null, null };
    }
}","{
    final Drawables dr = mDrawables;
    if (dr != null) {
        return dr.mShowing.clone();
    } else {
        return new Drawable[] { null, null, null, null };
    }
}",1,"/**
 * Returns drawables for the left, top, right, and bottom borders.
 *
 * @attr ref android.R.styleable#TextView_drawableLeft
 * @attr ref android.R.styleable#TextView_drawableTop
 * @attr ref android.R.styleable#TextView_drawableRight
 * @attr ref android.R.styleable#TextView_drawableBottom
 */
","/**
 * Returns drawables for the left, top, right, and bottom borders.
 *
 * @attr ref android.R.styleable#TextView_drawableLeft
 * @attr ref android.R.styleable#TextView_drawableTop
 * @attr ref android.R.styleable#TextView_drawableRight
 * @attr ref android.R.styleable#TextView_drawableBottom
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"4,5",0,"The way how the array is populated has changed from manually creating a new array with `dr.mDrawableLeft, dr.mDrawableTop, dr.mDrawableRight, dr.mDrawableBottom` to using `dr.mShowing.clone()`, and there seems to be no change in what the array contains, so the change type is 4. If `dr.mShowing` is changed (e.g., how it's constructed or what fields it includes), then it's also type 5. Without further information about `Drawables` class implementation changes, it is assumed that `mShowing` contains the same drawables as were manually assigned before the change.","There is no compatibility issue regarding the return value or exception handling; the return value's data type remains the same (`Drawable[]`), and the data itself is presumed to be equivalent to the earlier version, just created in a different way. Therefore, the CI type is 0."
257,<android.net.NetworkRequest.Builder: NetworkRequest build()>,22,23,<android.net.NetworkRequest.Builder: NetworkRequest build()>,<android.net.NetworkRequest.Builder: NetworkRequest build()>,0,"{
    return new NetworkRequest(mNetworkCapabilities, ConnectivityManager.TYPE_NONE, ConnectivityManager.REQUEST_ID_UNSET);
}","{
    // Make a copy of mNetworkCapabilities so we don't inadvertently remove NOT_RESTRICTED
    // when later an unrestricted capability could be added to mNetworkCapabilities, in
    // which case NOT_RESTRICTED should be returned to mNetworkCapabilities, which
    // maybeMarkCapabilitiesRestricted() doesn't add back.
    final NetworkCapabilities nc = new NetworkCapabilities(mNetworkCapabilities);
    nc.maybeMarkCapabilitiesRestricted();
    return new NetworkRequest(nc, ConnectivityManager.TYPE_NONE, ConnectivityManager.REQUEST_ID_UNSET);
}",1,"/**
 * Build {@link NetworkRequest} give the current set of capabilities.
 */
","/**
 * Build {@link NetworkRequest} give the current set of capabilities.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The late implementation includes additional steps that modify `NetworkCapabilities` before creating a new `NetworkRequest`; a copy of `mNetworkCapabilities` is being created, and `maybeMarkCapabilitiesRestricted()` is called on it before it is passed to the constructor, so the code change types are 1 and 4.","The copy of `mNetworkCapabilities` and the call to `maybeMarkCapabilitiesRestricted()` potentially alters the state of the `NetworkCapabilities` object, which could result in `NetworkRequest` returning a different `NetworkCapabilities` than before, and thus a different `NetworkRequest`. Therefore, the CI type is 1."
258,<android.hardware.camera2.utils.TaskDrainer: void taskFinished(T)>,22,23,<android.hardware.camera2.utils.TaskDrainer: void taskFinished(T)>,<android.hardware.camera2.utils.TaskDrainer: void taskFinished(T)>,0,"{
    synchronized (mLock) {
        if (VERBOSE) {
            Log.v(TAG + ""["" + mName + ""]"", ""taskFinished "" + task);
        }
        if (!mTaskSet.remove(task)) {
            throw new IllegalStateException(""Task "" + task + "" was already finished"");
        }
        // If this is the last finished task and draining has already begun, fire #onDrained
        checkIfDrainFinished();
    }
}","{
    synchronized (mLock) {
        if (DEBUG) {
            Log.v(TAG + ""["" + mName + ""]"", ""taskFinished "" + task);
        }
        if (!mTaskSet.remove(task)) {
            throw new IllegalStateException(""Task "" + task + "" was already finished"");
        }
        // If this is the last finished task and draining has already begun, fire #onDrained
        checkIfDrainFinished();
    }
}",1,"/**
 * Mark an asynchronous task as having finished.
 *
 * <p>A task cannot be finished if it hasn't started. Once finished, a task
 * cannot be finished again (unless it's started again).</p>
 *
 * @param task a key to identify a task
 *
 * @see #taskStarted
 * @see #beginDrain
 *
 * @throws IllegalStateException
 * If attempting to start a task which is already finished (and not re-started),
 */
","/**
 * Mark an asynchronous task as having finished.
 *
 * <p>A task cannot be finished if it hasn't started. Once finished, a task
 * cannot be finished again (unless it's started again).</p>
 *
 * @param task a key to identify a task
 *
 * @see #taskStarted
 * @see #beginDrain
 *
 * @throws IllegalStateException
 * If attempting to start a task which is already finished (and not re-started),
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change is that the VERBOSE flag has been replaced with DEBUG flag for the logging. This type of change is related to logging levels and does not affect the functionality of the method, so the change type is 4.","Changing a log level from VERBOSE to DEBUG does not affect the method's behavior as it is only related to what is logged. This change does not lead to different return values, thrown exceptions or any control flow alterations in code execution, therefore there is no Compatibility Issue."
259,"<android.app.ApplicationPackageManager: int checkPermission(String,String)>",22,23,"<android.app.ApplicationPackageManager: int checkPermission(String,String)>","<android.app.ApplicationPackageManager: int checkPermission(String,String)>",0,"{
    try {
        return mPM.checkPermission(permName, pkgName);
    } catch (RemoteException e) {
        throw new RuntimeException(""Package manager has died"", e);
    }
}","{
    try {
        return mPM.checkPermission(permName, pkgName, mContext.getUserId());
    } catch (RemoteException e) {
        throw new RuntimeException(""Package manager has died"", e);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The method called within the try block has an additional parameter in the late version (mContext.getUserId()), which is an internal change to the method call and not a change to the control flow or exception handling logic. However, this changes the dependent API invocation indicating that the method's implementation has changed, hence the change types are 4 and 5.","There is no change in the behavior of how the API handles exceptions or in the values it returns, as the change to the dependent API likely involves internal logic for user-specific permission checking. Thus, no compatibility issue should arise due to this change, provided the underlying method `mPM.checkPermission` correctly handles the additional parameter. Therefore, there is no compatibility issue caused by potentially different return values or types, nor are there issues with different exception handling."
260,"<android.hardware.camera2.impl.CameraCaptureSessionImpl: int capture(CaptureRequest,CaptureCallback,Handler)>",22,23,"<android.hardware.camera2.impl.CameraCaptureSessionImpl: int capture(CaptureRequest,CaptureCallback,Handler)>","<android.hardware.camera2.impl.CameraCaptureSessionImpl: int capture(CaptureRequest,CaptureCallback,Handler)>",0,"{
    if (request == null) {
        throw new IllegalArgumentException(""request must not be null"");
    }
    checkNotClosed();
    handler = checkHandler(handler, callback);
    if (VERBOSE) {
        Log.v(TAG, mIdString + ""capture - request "" + request + "", callback "" + callback + "" handler "" + handler);
    }
    return addPendingSequence(mDeviceImpl.capture(request, createCaptureCallbackProxy(handler, callback), mDeviceHandler));
}","{
    if (request == null) {
        throw new IllegalArgumentException(""request must not be null"");
    } else if (request.isReprocess() && !isReprocessable()) {
        throw new IllegalArgumentException(""this capture session cannot handle reprocess "" + ""requests"");
    } else if (request.isReprocess() && request.getReprocessableSessionId() != mId) {
        throw new IllegalArgumentException(""capture request was created for another session"");
    }
    checkNotClosed();
    handler = checkHandler(handler, callback);
    if (DEBUG) {
        Log.v(TAG, mIdString + ""capture - request "" + request + "", callback "" + callback + "" handler "" + handler);
    }
    return addPendingSequence(mDeviceImpl.capture(request, createCaptureCallbackProxy(handler, callback), mDeviceHandler));
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,3","1,2","Exception handling 'IllegalArgumentException' and control statement 'if' has been added to check additional conditions for 'request' variable, and the VERBOSE constant was changed to DEBUG in logging, so the change type is 2,3.","The added exception handling could lead to different exceptions being thrown when the conditions are met (when the request is reprocessed but the session is not reprocessable, or the reprocessed request was created for another session), which can cause a Compatibility Issue. The logging change from VERBOSE to DEBUG does not affect the API behavior; however, the modification in control conditions could lead to a different return value or type if an exception is thrown, so the CI types are 1,2."
261,"<android.app.Fragment: void startActivity(Intent,Bundle)>",22,23,"<android.app.Fragment: void startActivity(Intent,Bundle)>","<android.app.Fragment: void startActivity(Intent,Bundle)>",0,"{
    if (mActivity == null) {
        throw new IllegalStateException(""Fragment "" + this + "" not attached to Activity"");
    }
    if (options != null) {
        mActivity.startActivityFromFragment(this, intent, -1, options);
    } else {
        // Note we want to go through this call for compatibility with
        // applications that may have overridden the method.
        mActivity.startActivityFromFragment(this, intent, -1);
    }
}","{
    if (mHost == null) {
        throw new IllegalStateException(""Fragment "" + this + "" not attached to Activity"");
    }
    if (options != null) {
        mHost.onStartActivityFromFragment(this, intent, -1, options);
    } else {
        // Note we want to go through this call for compatibility with
        // applications that may have overridden the method.
        mHost.onStartActivityFromFragment(this, intent, -1, null);
    }
}",1,"/**
 * Call {@link Activity#startActivity(Intent, Bundle)} from the fragment's
 * containing Activity.
 *
 * @param intent The intent to start.
 * @param options Additional options for how the Activity should be started.
 * See {@link android.content.Context#startActivity(Intent, Bundle)
 * Context.startActivity(Intent, Bundle)} for more details.
 */
","/**
 * Call {@link Activity#startActivity(Intent, Bundle)} from the fragment's
 * containing Activity.
 *
 * @param intent The intent to start.
 * @param options Additional options for how the Activity should be started.
 * See {@link android.content.Context#startActivity(Intent, Bundle)
 * Context.startActivity(Intent, Bundle)} for more details.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",0,"The code change involves renaming 'mActivity' to 'mHost' and the method calls from 'mActivity.startActivityFromFragment' to 'mHost.onStartActivityFromFragment' with changes to parameter values. These changes affect the control dependency as the null check at the beginning of the method changed the variable it checks. Additionally, there is a change in the dependent API called in the method body, which changes from one signature to another. The 'null' literal is explicitly passed as the fourth parameter in the latter call when 'options' is null, which is within the other statements change category. Therefore, the change types are 3,4,5.","There is no compatibility issue because the change does not alter the expected behavior of the method from the perspective of the caller. The startActivity method is void and doesn't return a value, and no new exceptions are thrown or existing ones are changed based on changes in the API structure alone. Hence, the CI type is 0."
263,"<android.app.FragmentManagerImpl: View onCreateView(View,String,Context,AttributeSet)>",22,23,"<android.app.FragmentManagerImpl: View onCreateView(View,String,Context,AttributeSet)>","<android.app.FragmentManagerImpl: View onCreateView(View,String,Context,AttributeSet)>",0,"{
    if (!""fragment"".equals(name)) {
        return null;
    }
    String fname = attrs.getAttributeValue(null, ""class"");
    TypedArray a = context.obtainStyledAttributes(attrs, com.android.internal.R.styleable.Fragment);
    if (fname == null) {
        fname = a.getString(com.android.internal.R.styleable.Fragment_name);
    }
    int id = a.getResourceId(com.android.internal.R.styleable.Fragment_id, View.NO_ID);
    String tag = a.getString(com.android.internal.R.styleable.Fragment_tag);
    a.recycle();
    int containerId = parent != null ? parent.getId() : 0;
    if (containerId == View.NO_ID && id == View.NO_ID && tag == null) {
        throw new IllegalArgumentException(attrs.getPositionDescription() + "": Must specify unique android:id, android:tag, or have a parent with"" + "" an id for "" + fname);
    }
    // If we restored from a previous state, we may already have
    // instantiated this fragment from the state and should use
    // that instance instead of making a new one.
    Fragment fragment = id != View.NO_ID ? findFragmentById(id) : null;
    if (fragment == null && tag != null) {
        fragment = findFragmentByTag(tag);
    }
    if (fragment == null && containerId != View.NO_ID) {
        fragment = findFragmentById(containerId);
    }
    if (FragmentManagerImpl.DEBUG)
        Log.v(TAG, ""onCreateView: id=0x"" + Integer.toHexString(id) + "" fname="" + fname + "" existing="" + fragment);
    if (fragment == null) {
        fragment = Fragment.instantiate(context, fname);
        fragment.mFromLayout = true;
        fragment.mFragmentId = id != 0 ? id : containerId;
        fragment.mContainerId = containerId;
        fragment.mTag = tag;
        fragment.mInLayout = true;
        fragment.mFragmentManager = this;
        fragment.onInflate(mActivity, attrs, fragment.mSavedFragmentState);
        addFragment(fragment, true);
    } else if (fragment.mInLayout) {
        // previous state.
        throw new IllegalArgumentException(attrs.getPositionDescription() + "": Duplicate id 0x"" + Integer.toHexString(id) + "", tag "" + tag + "", or parent id 0x"" + Integer.toHexString(containerId) + "" with another fragment for "" + fname);
    } else {
        // This fragment was retained from a previous instance; get it
        // going now.
        fragment.mInLayout = true;
        // initialize itself.
        if (!fragment.mRetaining) {
            fragment.onInflate(mActivity, attrs, fragment.mSavedFragmentState);
        }
    }
    // push the inflated child fragment along.
    if (mCurState < Fragment.CREATED && fragment.mFromLayout) {
        moveToState(fragment, Fragment.CREATED, 0, 0, false);
    } else {
        moveToState(fragment);
    }
    if (fragment.mView == null) {
        throw new IllegalStateException(""Fragment "" + fname + "" did not create a view."");
    }
    if (id != 0) {
        fragment.mView.setId(id);
    }
    if (fragment.mView.getTag() == null) {
        fragment.mView.setTag(tag);
    }
    return fragment.mView;
}","{
    if (!""fragment"".equals(name)) {
        return null;
    }
    String fname = attrs.getAttributeValue(null, ""class"");
    TypedArray a = context.obtainStyledAttributes(attrs, com.android.internal.R.styleable.Fragment);
    if (fname == null) {
        fname = a.getString(com.android.internal.R.styleable.Fragment_name);
    }
    int id = a.getResourceId(com.android.internal.R.styleable.Fragment_id, View.NO_ID);
    String tag = a.getString(com.android.internal.R.styleable.Fragment_tag);
    a.recycle();
    int containerId = parent != null ? parent.getId() : 0;
    if (containerId == View.NO_ID && id == View.NO_ID && tag == null) {
        throw new IllegalArgumentException(attrs.getPositionDescription() + "": Must specify unique android:id, android:tag, or have a parent with"" + "" an id for "" + fname);
    }
    // If we restored from a previous state, we may already have
    // instantiated this fragment from the state and should use
    // that instance instead of making a new one.
    Fragment fragment = id != View.NO_ID ? findFragmentById(id) : null;
    if (fragment == null && tag != null) {
        fragment = findFragmentByTag(tag);
    }
    if (fragment == null && containerId != View.NO_ID) {
        fragment = findFragmentById(containerId);
    }
    if (FragmentManagerImpl.DEBUG)
        Log.v(TAG, ""onCreateView: id=0x"" + Integer.toHexString(id) + "" fname="" + fname + "" existing="" + fragment);
    if (fragment == null) {
        fragment = Fragment.instantiate(context, fname);
        fragment.mFromLayout = true;
        fragment.mFragmentId = id != 0 ? id : containerId;
        fragment.mContainerId = containerId;
        fragment.mTag = tag;
        fragment.mInLayout = true;
        fragment.mFragmentManager = this;
        fragment.mHost = mHost;
        fragment.onInflate(mHost.getContext(), attrs, fragment.mSavedFragmentState);
        addFragment(fragment, true);
    } else if (fragment.mInLayout) {
        // previous state.
        throw new IllegalArgumentException(attrs.getPositionDescription() + "": Duplicate id 0x"" + Integer.toHexString(id) + "", tag "" + tag + "", or parent id 0x"" + Integer.toHexString(containerId) + "" with another fragment for "" + fname);
    } else {
        // This fragment was retained from a previous instance; get it
        // going now.
        fragment.mInLayout = true;
        // initialize itself.
        if (!fragment.mRetaining) {
            fragment.onInflate(mHost.getContext(), attrs, fragment.mSavedFragmentState);
        }
    }
    // push the inflated child fragment along.
    if (mCurState < Fragment.CREATED && fragment.mFromLayout) {
        moveToState(fragment, Fragment.CREATED, 0, 0, false);
    } else {
        moveToState(fragment);
    }
    if (fragment.mView == null) {
        throw new IllegalStateException(""Fragment "" + fname + "" did not create a view."");
    }
    if (id != 0) {
        fragment.mView.setId(id);
    }
    if (fragment.mView.getTag() == null) {
        fragment.mView.setTag(tag);
    }
    return fragment.mView;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
265,<android.net.DhcpStateMachine.RunningState: boolean processMessage(Message)>,22,23,<android.net.DhcpStateMachine.RunningState: boolean processMessage(Message)>,<android.net.DhcpStateMachine.RunningState: boolean processMessage(Message)>,0,"{
    boolean retValue = HANDLED;
    if (DBG)
        Log.d(TAG, getName() + message.toString() + ""\n"");
    switch(message.what) {
        case CMD_STOP_DHCP:
            mAlarmManager.cancel(mDhcpRenewalIntent);
            if (!NetworkUtils.stopDhcp(mInterfaceName)) {
                Log.e(TAG, ""Failed to stop Dhcp on "" + mInterfaceName);
            }
            transitionTo(mStoppedState);
            break;
        case CMD_RENEW_DHCP:
            if (mRegisteredForPreDhcpNotification) {
                /* Notify controller before starting DHCP */
                mController.sendMessage(CMD_PRE_DHCP_ACTION);
                transitionTo(mWaitBeforeRenewalState);
            // mDhcpRenewWakeLock is released in WaitBeforeRenewalState
            } else {
                if (!runDhcp(DhcpAction.RENEW)) {
                    transitionTo(mStoppedState);
                }
                mDhcpRenewWakeLock.release();
            }
            break;
        case CMD_START_DHCP:
            // ignore
            break;
        default:
            retValue = NOT_HANDLED;
    }
    return retValue;
}","{
    boolean retValue = HANDLED;
    if (DBG)
        Log.d(TAG, getName() + message.toString() + ""\n"");
    switch(message.what) {
        case CMD_STOP_DHCP:
            mAlarmManager.cancel(mDhcpRenewalIntent);
            transitionTo(mStoppedState);
            break;
        case CMD_RENEW_DHCP:
            if (mRegisteredForPreDhcpNotification) {
                /* Notify controller before starting DHCP */
                mController.sendMessage(CMD_PRE_DHCP_ACTION);
                transitionTo(mWaitBeforeRenewalState);
            // mDhcpRenewWakeLock is released in WaitBeforeRenewalState
            } else {
                if (!runDhcpRenew()) {
                    transitionTo(mStoppedState);
                }
                mDhcpRenewWakeLock.release();
            }
            break;
        case CMD_START_DHCP:
            // ignore
            break;
        default:
            retValue = NOT_HANDLED;
    }
    return retValue;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4,5",1,"The method NetworkUtils.stopDhcp(mInterfaceName) and the call to it has been removed in the late version. Additionally, the method runDhcp(DhcpAction.RENEW) has been replaced with runDhcpRenew() which indicates a change in dependent API, so the code change type is 3,4,5.","Removing the call to NetworkUtils.stopDhcp(mInterfaceName) alters the control flow and could stop the DHCP differently than in the early version. This along with replacement of the method call to runDhcp(DhcpAction.RENEW) with runDhcpRenew() could lead to a potential different outcome of renewing DHCP. These changes could lead to different return values, and the CI type is 1."
266,<android.widget.DatePickerCalendarDelegate: Parcelable onSaveInstanceState(Parcelable)>,22,23,<android.widget.DatePickerCalendarDelegate: Parcelable onSaveInstanceState(Parcelable)>,<android.widget.DatePickerCalendarDelegate: Parcelable onSaveInstanceState(Parcelable)>,0,"{
    final int year = mCurrentDate.get(Calendar.YEAR);
    final int month = mCurrentDate.get(Calendar.MONTH);
    final int day = mCurrentDate.get(Calendar.DAY_OF_MONTH);
    int listPosition = -1;
    int listPositionOffset = -1;
    if (mCurrentView == MONTH_AND_DAY_VIEW) {
        listPosition = mDayPickerView.getMostVisiblePosition();
    } else if (mCurrentView == YEAR_VIEW) {
        listPosition = mYearPickerView.getFirstVisiblePosition();
        listPositionOffset = mYearPickerView.getFirstPositionOffset();
    }
    return new SavedState(superState, year, month, day, mMinDate.getTimeInMillis(), mMaxDate.getTimeInMillis(), mCurrentView, listPosition, listPositionOffset);
}","{
    final int year = mCurrentDate.get(Calendar.YEAR);
    final int month = mCurrentDate.get(Calendar.MONTH);
    final int day = mCurrentDate.get(Calendar.DAY_OF_MONTH);
    int listPosition = -1;
    int listPositionOffset = -1;
    if (mCurrentView == VIEW_MONTH_DAY) {
        listPosition = mDayPickerView.getMostVisiblePosition();
    } else if (mCurrentView == VIEW_YEAR) {
        listPosition = mYearPickerView.getFirstVisiblePosition();
        listPositionOffset = mYearPickerView.getFirstPositionOffset();
    }
    return new SavedState(superState, year, month, day, mMinDate.getTimeInMillis(), mMaxDate.getTimeInMillis(), mCurrentView, listPosition, listPositionOffset);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,"The value assigned to `mCurrentView` inside the 'if' and 'else if' conditions changed from MONTH_AND_DAY_VIEW and YEAR_VIEW to VIEW_MONTH_DAY and VIEW_YEAR, respectively. This is a control dependency change, so the change type is 3.","There is no Compatibility Issue because the variables MONTH_AND_DAY_VIEW and YEAR_VIEW were likely renamed to VIEW_MONTH_DAY and VIEW_YEAR. The logic and behavior of the method remain the same; thus, it won't return different results or throw new exceptions due to this change."
268,<android.widget.Spinner: void setAdapter(SpinnerAdapter)>,22,23,<android.widget.Spinner: void setAdapter(SpinnerAdapter)>,<android.widget.Spinner: void setAdapter(SpinnerAdapter)>,0,"{
    super.setAdapter(adapter);
    mRecycler.clear();
    final int targetSdkVersion = mContext.getApplicationInfo().targetSdkVersion;
    if (targetSdkVersion >= Build.VERSION_CODES.LOLLIPOP && adapter != null && adapter.getViewTypeCount() != 1) {
        throw new IllegalArgumentException(""Spinner adapter view type count must be 1"");
    }
    if (mPopup != null) {
        mPopup.setAdapter(new DropDownAdapter(adapter));
    } else {
        mTempAdapter = new DropDownAdapter(adapter);
    }
}","{
    // Postpone doing anything until we've finished construction.
    if (mPopup == null) {
        mTempAdapter = adapter;
        return;
    }
    super.setAdapter(adapter);
    mRecycler.clear();
    final int targetSdkVersion = mContext.getApplicationInfo().targetSdkVersion;
    if (targetSdkVersion >= Build.VERSION_CODES.LOLLIPOP && adapter != null && adapter.getViewTypeCount() != 1) {
        throw new IllegalArgumentException(""Spinner adapter view type count must be 1"");
    }
    final Context popupContext = mPopupContext == null ? mContext : mPopupContext;
    mPopup.setAdapter(new DropDownAdapter(adapter, popupContext.getTheme()));
}",1,"/**
 * Sets the Adapter used to provide the data which backs this Spinner.
 * <p>
 * Note that Spinner overrides {@link Adapter#getViewTypeCount()} on the
 * Adapter associated with this view. Calling
 * {@link Adapter#getItemViewType(int) getItemViewType(int)} on the object
 * returned from {@link #getAdapter()} will always return 0. Calling
 * {@link Adapter#getViewTypeCount() getViewTypeCount()} will always return
 * 1. On API {@link Build.VERSION_CODES#LOLLIPOP} and above, attempting to set an
 * adapter with more than one view type will throw an
 * {@link IllegalArgumentException}.
 *
 * @param adapter the adapter to set
 *
 * @see AbsSpinner#setAdapter(SpinnerAdapter)
 * @throws IllegalArgumentException if the adapter has more than one view
 * type
 */
","/**
 * Sets the {@link SpinnerAdapter} used to provide the data which backs
 * this Spinner.
 * <p>
 * If this Spinner has a popup theme set in XML via the
 * {@link android.R.styleable#Spinner_popupTheme popupTheme} attribute, the
 * adapter should inflate drop-down views using the same theme. The easiest
 * way to achieve this is by using {@link #getPopupContext()} to obtain a
 * layout inflater for use in
 * {@link SpinnerAdapter#getDropDownView(int, View, ViewGroup)}.
 * <p>
 * Spinner overrides {@link Adapter#getViewTypeCount()} on the
 * Adapter associated with this view. Calling
 * {@link Adapter#getItemViewType(int) getItemViewType(int)} on the object
 * returned from {@link #getAdapter()} will always return 0. Calling
 * {@link Adapter#getViewTypeCount() getViewTypeCount()} will always return
 * 1. On API {@link Build.VERSION_CODES#LOLLIPOP} and above, attempting to set an
 * adapter with more than one view type will throw an
 * {@link IllegalArgumentException}.
 *
 * @param adapter the adapter to set
 *
 * @see AbsSpinner#setAdapter(SpinnerAdapter)
 * @throws IllegalArgumentException if the adapter has more than one view
 * type
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",0,The implementation has several changes:,- A new variable `popupContext` is introduced and used for the adapter creation.
270,<android.view.ViewGroup: void addChildrenForAccessibility(ArrayList<View>)>,22,23,<android.view.ViewGroup: void addChildrenForAccessibility(ArrayList<View>)>,<android.view.ViewGroup: void addChildrenForAccessibility(ArrayList<View>)>,0,"{
    ChildListForAccessibility children = ChildListForAccessibility.obtain(this, true);
    try {
        final int childrenCount = children.getChildCount();
        for (int i = 0; i < childrenCount; i++) {
            View child = children.getChildAt(i);
            if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE) {
                if (child.includeForAccessibility()) {
                    childrenForAccessibility.add(child);
                } else {
                    child.addChildrenForAccessibility(childrenForAccessibility);
                }
            }
        }
    } finally {
        children.recycle();
    }
}","{
    if (getAccessibilityNodeProvider() != null) {
        return;
    }
    ChildListForAccessibility children = ChildListForAccessibility.obtain(this, true);
    try {
        final int childrenCount = children.getChildCount();
        for (int i = 0; i < childrenCount; i++) {
            View child = children.getChildAt(i);
            if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE) {
                if (child.includeForAccessibility()) {
                    outChildren.add(child);
                } else {
                    child.addChildrenForAccessibility(outChildren);
                }
            }
        }
    } finally {
        children.recycle();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,There are multiple changes in the latest implementation of the API:,"2. The variable name within the method body has been changed from `childrenForAccessibility` to `outChildren`, which is an other statement changed (class 4), but in this context this change is syntactical and does not affect the behavior."
271,<android.app.backup.BackupAgent: void onFullBackup(FullBackupDataOutput)>,22,23,<android.app.backup.BackupAgent: void onFullBackup(FullBackupDataOutput)>,<android.app.backup.BackupAgent: void onFullBackup(FullBackupDataOutput)>,0,"{
    ApplicationInfo appInfo = getApplicationInfo();
    // Note that we don't need to think about the no_backup dir because it's outside
    // all of the ones we will be traversing
    String rootDir = new File(appInfo.dataDir).getCanonicalPath();
    String filesDir = getFilesDir().getCanonicalPath();
    String databaseDir = getDatabasePath(""foo"").getParentFile().getCanonicalPath();
    String sharedPrefsDir = getSharedPrefsFile(""foo"").getParentFile().getCanonicalPath();
    String cacheDir = getCacheDir().getCanonicalPath();
    String libDir = (appInfo.nativeLibraryDir != null) ? new File(appInfo.nativeLibraryDir).getCanonicalPath() : null;
    // Filters, the scan queue, and the set of resulting entities
    HashSet<String> filterSet = new HashSet<String>();
    String packageName = getPackageName();
    // Okay, start with the app's root tree, but exclude all of the canonical subdirs
    if (libDir != null) {
        filterSet.add(libDir);
    }
    filterSet.add(cacheDir);
    filterSet.add(databaseDir);
    filterSet.add(sharedPrefsDir);
    filterSet.add(filesDir);
    fullBackupFileTree(packageName, FullBackup.ROOT_TREE_TOKEN, rootDir, filterSet, data);
    // Now do the same for the files dir, db dir, and shared prefs dir
    filterSet.add(rootDir);
    filterSet.remove(filesDir);
    fullBackupFileTree(packageName, FullBackup.DATA_TREE_TOKEN, filesDir, filterSet, data);
    filterSet.add(filesDir);
    filterSet.remove(databaseDir);
    fullBackupFileTree(packageName, FullBackup.DATABASE_TREE_TOKEN, databaseDir, filterSet, data);
    filterSet.add(databaseDir);
    filterSet.remove(sharedPrefsDir);
    fullBackupFileTree(packageName, FullBackup.SHAREDPREFS_TREE_TOKEN, sharedPrefsDir, filterSet, data);
    // the log.
    if (Process.myUid() != Process.SYSTEM_UID) {
        File efLocation = getExternalFilesDir(null);
        if (efLocation != null) {
            fullBackupFileTree(packageName, FullBackup.MANAGED_EXTERNAL_TREE_TOKEN, efLocation.getCanonicalPath(), null, data);
        }
    }
}","{
    FullBackup.BackupScheme backupScheme = FullBackup.getBackupScheme(this);
    if (!backupScheme.isFullBackupContentEnabled()) {
        return;
    }
    Map<String, Set<String>> manifestIncludeMap;
    ArraySet<String> manifestExcludeSet;
    try {
        manifestIncludeMap = backupScheme.maybeParseAndGetCanonicalIncludePaths();
        manifestExcludeSet = backupScheme.maybeParseAndGetCanonicalExcludePaths();
    } catch (IOException | XmlPullParserException e) {
        if (Log.isLoggable(FullBackup.TAG_XML_PARSER, Log.VERBOSE)) {
            Log.v(FullBackup.TAG_XML_PARSER, ""Exception trying to parse fullBackupContent xml file!"" + "" Aborting full backup."", e);
        }
        return;
    }
    final String packageName = getPackageName();
    final ApplicationInfo appInfo = getApplicationInfo();
    String rootDir = new File(appInfo.dataDir).getCanonicalPath();
    String filesDir = getFilesDir().getCanonicalPath();
    String nobackupDir = getNoBackupFilesDir().getCanonicalPath();
    String databaseDir = getDatabasePath(""foo"").getParentFile().getCanonicalPath();
    String sharedPrefsDir = getSharedPrefsFile(""foo"").getParentFile().getCanonicalPath();
    String cacheDir = getCacheDir().getCanonicalPath();
    String codeCacheDir = getCodeCacheDir().getCanonicalPath();
    String libDir = (appInfo.nativeLibraryDir != null) ? new File(appInfo.nativeLibraryDir).getCanonicalPath() : null;
    // Maintain a set of excluded directories so that as we traverse the tree we know we're not
    // going places we don't expect, and so the manifest includes can't take precedence over
    // what the framework decides is not to be included.
    final ArraySet<String> traversalExcludeSet = new ArraySet<String>();
    // Add the directories we always exclude.
    traversalExcludeSet.add(cacheDir);
    traversalExcludeSet.add(codeCacheDir);
    traversalExcludeSet.add(nobackupDir);
    if (libDir != null) {
        traversalExcludeSet.add(libDir);
    }
    traversalExcludeSet.add(databaseDir);
    traversalExcludeSet.add(sharedPrefsDir);
    traversalExcludeSet.add(filesDir);
    // Root dir first.
    applyXmlFiltersAndDoFullBackupForDomain(packageName, FullBackup.ROOT_TREE_TOKEN, manifestIncludeMap, manifestExcludeSet, traversalExcludeSet, data);
    traversalExcludeSet.add(rootDir);
    // Data dir next.
    traversalExcludeSet.remove(filesDir);
    applyXmlFiltersAndDoFullBackupForDomain(packageName, FullBackup.DATA_TREE_TOKEN, manifestIncludeMap, manifestExcludeSet, traversalExcludeSet, data);
    traversalExcludeSet.add(filesDir);
    // Database directory.
    traversalExcludeSet.remove(databaseDir);
    applyXmlFiltersAndDoFullBackupForDomain(packageName, FullBackup.DATABASE_TREE_TOKEN, manifestIncludeMap, manifestExcludeSet, traversalExcludeSet, data);
    traversalExcludeSet.add(databaseDir);
    // SharedPrefs.
    traversalExcludeSet.remove(sharedPrefsDir);
    applyXmlFiltersAndDoFullBackupForDomain(packageName, FullBackup.SHAREDPREFS_TREE_TOKEN, manifestIncludeMap, manifestExcludeSet, traversalExcludeSet, data);
    traversalExcludeSet.add(sharedPrefsDir);
    // the log.
    if (Process.myUid() != Process.SYSTEM_UID) {
        File efLocation = getExternalFilesDir(null);
        if (efLocation != null) {
            applyXmlFiltersAndDoFullBackupForDomain(packageName, FullBackup.MANAGED_EXTERNAL_TREE_TOKEN, manifestIncludeMap, manifestExcludeSet, traversalExcludeSet, data);
        }
    }
}",1,"/**
 * The application is having its entire file system contents backed up.  {@code data}
 * points to the backup destination, and the app has the opportunity to choose which
 * files are to be stored.  To commit a file as part of the backup, call the
 * {@link #fullBackupFile(File, FullBackupDataOutput)} helper method.  After all file
 * data is written to the output, the agent returns from this method and the backup
 * operation concludes.
 *
 * <p>Certain parts of the app's data are never backed up even if the app explicitly
 * sends them to the output:
 *
 * <ul>
 * <li>The contents of the {@link #getCacheDir()} directory</li>
 * <li>The contents of the {@link #getNoBackupFilesDir()} directory</li>
 * <li>The contents of the app's shared library directory</li>
 * </ul>
 *
 * <p>The default implementation of this method backs up the entirety of the
 * application's ""owned"" file system trees to the output other than the few exceptions
 * listed above.  Apps only need to override this method if they need to impose special
 * limitations on which files are being stored beyond the control that
 * {@link #getNoBackupFilesDir()} offers.
 *
 * @param data A structured wrapper pointing to the backup destination.
 * @throws IOException
 *
 * @see Context#getNoBackupFilesDir()
 * @see #fullBackupFile(File, FullBackupDataOutput)
 * @see #onRestoreFile(ParcelFileDescriptor, long, File, int, long, long)
 */
","/**
 * The application is having its entire file system contents backed up.  {@code data}
 * points to the backup destination, and the app has the opportunity to choose which
 * files are to be stored.  To commit a file as part of the backup, call the
 * {@link #fullBackupFile(File, FullBackupDataOutput)} helper method.  After all file
 * data is written to the output, the agent returns from this method and the backup
 * operation concludes.
 *
 * <p>Certain parts of the app's data are never backed up even if the app explicitly
 * sends them to the output:
 *
 * <ul>
 * <li>The contents of the {@link #getCacheDir()} directory</li>
 * <li>The contents of the {@link #getCodeCacheDir()} directory</li>
 * <li>The contents of the {@link #getNoBackupFilesDir()} directory</li>
 * <li>The contents of the app's shared library directory</li>
 * </ul>
 *
 * <p>The default implementation of this method backs up the entirety of the
 * application's ""owned"" file system trees to the output other than the few exceptions
 * listed above.  Apps only need to override this method if they need to impose special
 * limitations on which files are being stored beyond the control that
 * {@link #getNoBackupFilesDir()} offers.
 * Alternatively they can provide an xml resource to specify what data to include or exclude.
 *
 * @param data A structured wrapper pointing to the backup destination.
 * @throws IOException
 *
 * @see Context#getNoBackupFilesDir()
 * @see ApplicationInfo#fullBackupContent
 * @see #fullBackupFile(File, FullBackupDataOutput)
 * @see #onRestoreFile(ParcelFileDescriptor, long, File, int, long, long)
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
273,<android.speech.tts.TextToSpeechService: List<Voice> onGetVoices()>,22,23,<android.speech.tts.TextToSpeechService: List<Voice> onGetVoices()>,<android.speech.tts.TextToSpeechService: List<Voice> onGetVoices()>,0,"{
    // Enumerate all locales and check if they are available
    ArrayList<Voice> voices = new ArrayList<Voice>();
    for (Locale locale : Locale.getAvailableLocales()) {
        int expectedStatus = getExpectedLanguageAvailableStatus(locale);
        try {
            int localeStatus = onIsLanguageAvailable(locale.getISO3Language(), locale.getISO3Country(), locale.getVariant());
            if (localeStatus != expectedStatus) {
                continue;
            }
        } catch (MissingResourceException e) {
            // Ignore locale without iso 3 codes
            continue;
        }
        Set<String> features = onGetFeaturesForLanguage(locale.getISO3Language(), locale.getISO3Country(), locale.getVariant());
        voices.add(new Voice(locale.toLanguageTag(), locale, Voice.QUALITY_NORMAL, Voice.LATENCY_NORMAL, false, features));
    }
    return voices;
}","{
    // Enumerate all locales and check if they are available
    ArrayList<Voice> voices = new ArrayList<Voice>();
    for (Locale locale : Locale.getAvailableLocales()) {
        int expectedStatus = getExpectedLanguageAvailableStatus(locale);
        try {
            int localeStatus = onIsLanguageAvailable(locale.getISO3Language(), locale.getISO3Country(), locale.getVariant());
            if (localeStatus != expectedStatus) {
                continue;
            }
        } catch (MissingResourceException e) {
            // Ignore locale without iso 3 codes
            continue;
        }
        Set<String> features = onGetFeaturesForLanguage(locale.getISO3Language(), locale.getISO3Country(), locale.getVariant());
        String voiceName = onGetDefaultVoiceNameFor(locale.getISO3Language(), locale.getISO3Country(), locale.getVariant());
        voices.add(new Voice(voiceName, locale, Voice.QUALITY_NORMAL, Voice.LATENCY_NORMAL, false, features));
    }
    return voices;
}",1,"/**
 * Queries the service for a set of supported voices.
 *
 * Can be called on multiple threads.
 *
 * The default implementation tries to enumerate all available locales, pass them to
 * {@link #onIsLanguageAvailable(String, String, String)} and create Voice instances (using
 * the locale's BCP-47 language tag as the voice name) for the ones that are supported.
 * Note, that this implementation is suitable only for engines that don't have multiple voices
 * for a single locale. Also, this implementation won't work with Locales not listed in the
 * set returned by the {@link Locale#getAvailableLocales()} method.
 *
 * @return A list of voices supported.
 */
","/**
 * Queries the service for a set of supported voices.
 *
 * Can be called on multiple threads.
 *
 * The default implementation tries to enumerate all available locales, pass them to
 * {@link #onIsLanguageAvailable(String, String, String)} and create Voice instances (using
 * the locale's BCP-47 language tag as the voice name) for the ones that are supported.
 * Note, that this implementation is suitable only for engines that don't have multiple voices
 * for a single locale. Also, this implementation won't work with Locales not listed in the
 * set returned by the {@link Locale#getAvailableLocales()} method.
 *
 * @return A list of voices supported.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"In the late version, a new method call `onGetDefaultVoiceNameFor(locale.getISO3Language(), locale.getISO3Country(), locale.getVariant())` has been added to determine the voice name, so the change type is 4.","The addition of determining the voice name using `onGetDefaultVoiceNameFor` instead of using `locale.toLanguageTag()` potentially changes the resulting Voice objects to have different names. Therefore, this introduces a possible CI due to the return values of the API potentially being different, hence the CI type is 1."
274,<android.view.GestureDetector: boolean onTouchEvent(MotionEvent)>,22,23,<android.view.GestureDetector: boolean onTouchEvent(MotionEvent)>,<android.view.GestureDetector: boolean onTouchEvent(MotionEvent)>,0,"{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(ev, 0);
    }
    final int action = ev.getAction();
    if (mVelocityTracker == null) {
        mVelocityTracker = VelocityTracker.obtain();
    }
    mVelocityTracker.addMovement(ev);
    final boolean pointerUp = (action & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_POINTER_UP;
    final int skipIndex = pointerUp ? ev.getActionIndex() : -1;
    // Determine focal point
    float sumX = 0, sumY = 0;
    final int count = ev.getPointerCount();
    for (int i = 0; i < count; i++) {
        if (skipIndex == i)
            continue;
        sumX += ev.getX(i);
        sumY += ev.getY(i);
    }
    final int div = pointerUp ? count - 1 : count;
    final float focusX = sumX / div;
    final float focusY = sumY / div;
    boolean handled = false;
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_POINTER_DOWN:
            mDownFocusX = mLastFocusX = focusX;
            mDownFocusY = mLastFocusY = focusY;
            // Cancel long press and taps
            cancelTaps();
            break;
        case MotionEvent.ACTION_POINTER_UP:
            mDownFocusX = mLastFocusX = focusX;
            mDownFocusY = mLastFocusY = focusY;
            // Check the dot product of current velocities.
            // If the pointer that left was opposing another velocity vector, clear.
            mVelocityTracker.computeCurrentVelocity(1000, mMaximumFlingVelocity);
            final int upIndex = ev.getActionIndex();
            final int id1 = ev.getPointerId(upIndex);
            final float x1 = mVelocityTracker.getXVelocity(id1);
            final float y1 = mVelocityTracker.getYVelocity(id1);
            for (int i = 0; i < count; i++) {
                if (i == upIndex)
                    continue;
                final int id2 = ev.getPointerId(i);
                final float x = x1 * mVelocityTracker.getXVelocity(id2);
                final float y = y1 * mVelocityTracker.getYVelocity(id2);
                final float dot = x + y;
                if (dot < 0) {
                    mVelocityTracker.clear();
                    break;
                }
            }
            break;
        case MotionEvent.ACTION_DOWN:
            if (mDoubleTapListener != null) {
                boolean hadTapMessage = mHandler.hasMessages(TAP);
                if (hadTapMessage)
                    mHandler.removeMessages(TAP);
                if ((mCurrentDownEvent != null) && (mPreviousUpEvent != null) && hadTapMessage && isConsideredDoubleTap(mCurrentDownEvent, mPreviousUpEvent, ev)) {
                    // This is a second tap
                    mIsDoubleTapping = true;
                    // Give a callback with the first tap of the double-tap
                    handled |= mDoubleTapListener.onDoubleTap(mCurrentDownEvent);
                    // Give a callback with down event of the double-tap
                    handled |= mDoubleTapListener.onDoubleTapEvent(ev);
                } else {
                    // This is a first tap
                    mHandler.sendEmptyMessageDelayed(TAP, DOUBLE_TAP_TIMEOUT);
                }
            }
            mDownFocusX = mLastFocusX = focusX;
            mDownFocusY = mLastFocusY = focusY;
            if (mCurrentDownEvent != null) {
                mCurrentDownEvent.recycle();
            }
            mCurrentDownEvent = MotionEvent.obtain(ev);
            mAlwaysInTapRegion = true;
            mAlwaysInBiggerTapRegion = true;
            mStillDown = true;
            mInLongPress = false;
            mDeferConfirmSingleTap = false;
            if (mIsLongpressEnabled) {
                mHandler.removeMessages(LONG_PRESS);
                mHandler.sendEmptyMessageAtTime(LONG_PRESS, mCurrentDownEvent.getDownTime() + TAP_TIMEOUT + LONGPRESS_TIMEOUT);
            }
            mHandler.sendEmptyMessageAtTime(SHOW_PRESS, mCurrentDownEvent.getDownTime() + TAP_TIMEOUT);
            handled |= mListener.onDown(ev);
            break;
        case MotionEvent.ACTION_MOVE:
            if (mInLongPress) {
                break;
            }
            final float scrollX = mLastFocusX - focusX;
            final float scrollY = mLastFocusY - focusY;
            if (mIsDoubleTapping) {
                // Give the move events of the double-tap
                handled |= mDoubleTapListener.onDoubleTapEvent(ev);
            } else if (mAlwaysInTapRegion) {
                final int deltaX = (int) (focusX - mDownFocusX);
                final int deltaY = (int) (focusY - mDownFocusY);
                int distance = (deltaX * deltaX) + (deltaY * deltaY);
                if (distance > mTouchSlopSquare) {
                    handled = mListener.onScroll(mCurrentDownEvent, ev, scrollX, scrollY);
                    mLastFocusX = focusX;
                    mLastFocusY = focusY;
                    mAlwaysInTapRegion = false;
                    mHandler.removeMessages(TAP);
                    mHandler.removeMessages(SHOW_PRESS);
                    mHandler.removeMessages(LONG_PRESS);
                }
                if (distance > mDoubleTapTouchSlopSquare) {
                    mAlwaysInBiggerTapRegion = false;
                }
            } else if ((Math.abs(scrollX) >= 1) || (Math.abs(scrollY) >= 1)) {
                handled = mListener.onScroll(mCurrentDownEvent, ev, scrollX, scrollY);
                mLastFocusX = focusX;
                mLastFocusY = focusY;
            }
            break;
        case MotionEvent.ACTION_UP:
            mStillDown = false;
            MotionEvent currentUpEvent = MotionEvent.obtain(ev);
            if (mIsDoubleTapping) {
                // Finally, give the up event of the double-tap
                handled |= mDoubleTapListener.onDoubleTapEvent(ev);
            } else if (mInLongPress) {
                mHandler.removeMessages(TAP);
                mInLongPress = false;
            } else if (mAlwaysInTapRegion) {
                handled = mListener.onSingleTapUp(ev);
                if (mDeferConfirmSingleTap && mDoubleTapListener != null) {
                    mDoubleTapListener.onSingleTapConfirmed(ev);
                }
            } else {
                // A fling must travel the minimum tap distance
                final VelocityTracker velocityTracker = mVelocityTracker;
                final int pointerId = ev.getPointerId(0);
                velocityTracker.computeCurrentVelocity(1000, mMaximumFlingVelocity);
                final float velocityY = velocityTracker.getYVelocity(pointerId);
                final float velocityX = velocityTracker.getXVelocity(pointerId);
                if ((Math.abs(velocityY) > mMinimumFlingVelocity) || (Math.abs(velocityX) > mMinimumFlingVelocity)) {
                    handled = mListener.onFling(mCurrentDownEvent, ev, velocityX, velocityY);
                }
            }
            if (mPreviousUpEvent != null) {
                mPreviousUpEvent.recycle();
            }
            // Hold the event we obtained above - listeners may have changed the original.
            mPreviousUpEvent = currentUpEvent;
            if (mVelocityTracker != null) {
                // This may have been cleared when we called out to the
                // application above.
                mVelocityTracker.recycle();
                mVelocityTracker = null;
            }
            mIsDoubleTapping = false;
            mDeferConfirmSingleTap = false;
            mHandler.removeMessages(SHOW_PRESS);
            mHandler.removeMessages(LONG_PRESS);
            break;
        case MotionEvent.ACTION_CANCEL:
            cancel();
            break;
    }
    if (!handled && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 0);
    }
    return handled;
}","{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(ev, 0);
    }
    final int action = ev.getAction();
    if (mVelocityTracker == null) {
        mVelocityTracker = VelocityTracker.obtain();
    }
    mVelocityTracker.addMovement(ev);
    final boolean pointerUp = (action & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_POINTER_UP;
    final int skipIndex = pointerUp ? ev.getActionIndex() : -1;
    // Determine focal point
    float sumX = 0, sumY = 0;
    final int count = ev.getPointerCount();
    for (int i = 0; i < count; i++) {
        if (skipIndex == i)
            continue;
        sumX += ev.getX(i);
        sumY += ev.getY(i);
    }
    final int div = pointerUp ? count - 1 : count;
    final float focusX = sumX / div;
    final float focusY = sumY / div;
    boolean handled = false;
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_POINTER_DOWN:
            mDownFocusX = mLastFocusX = focusX;
            mDownFocusY = mLastFocusY = focusY;
            // Cancel long press and taps
            cancelTaps();
            break;
        case MotionEvent.ACTION_POINTER_UP:
            mDownFocusX = mLastFocusX = focusX;
            mDownFocusY = mLastFocusY = focusY;
            // Check the dot product of current velocities.
            // If the pointer that left was opposing another velocity vector, clear.
            mVelocityTracker.computeCurrentVelocity(1000, mMaximumFlingVelocity);
            final int upIndex = ev.getActionIndex();
            final int id1 = ev.getPointerId(upIndex);
            final float x1 = mVelocityTracker.getXVelocity(id1);
            final float y1 = mVelocityTracker.getYVelocity(id1);
            for (int i = 0; i < count; i++) {
                if (i == upIndex)
                    continue;
                final int id2 = ev.getPointerId(i);
                final float x = x1 * mVelocityTracker.getXVelocity(id2);
                final float y = y1 * mVelocityTracker.getYVelocity(id2);
                final float dot = x + y;
                if (dot < 0) {
                    mVelocityTracker.clear();
                    break;
                }
            }
            break;
        case MotionEvent.ACTION_DOWN:
            if (mDoubleTapListener != null) {
                boolean hadTapMessage = mHandler.hasMessages(TAP);
                if (hadTapMessage)
                    mHandler.removeMessages(TAP);
                if ((mCurrentDownEvent != null) && (mPreviousUpEvent != null) && hadTapMessage && isConsideredDoubleTap(mCurrentDownEvent, mPreviousUpEvent, ev)) {
                    // This is a second tap
                    mIsDoubleTapping = true;
                    // Give a callback with the first tap of the double-tap
                    handled |= mDoubleTapListener.onDoubleTap(mCurrentDownEvent);
                    // Give a callback with down event of the double-tap
                    handled |= mDoubleTapListener.onDoubleTapEvent(ev);
                } else {
                    // This is a first tap
                    mHandler.sendEmptyMessageDelayed(TAP, DOUBLE_TAP_TIMEOUT);
                }
            }
            mDownFocusX = mLastFocusX = focusX;
            mDownFocusY = mLastFocusY = focusY;
            if (mCurrentDownEvent != null) {
                mCurrentDownEvent.recycle();
            }
            mCurrentDownEvent = MotionEvent.obtain(ev);
            mAlwaysInTapRegion = true;
            mAlwaysInBiggerTapRegion = true;
            mStillDown = true;
            mInLongPress = false;
            mDeferConfirmSingleTap = false;
            if (mIsLongpressEnabled) {
                mHandler.removeMessages(LONG_PRESS);
                mHandler.sendEmptyMessageAtTime(LONG_PRESS, mCurrentDownEvent.getDownTime() + TAP_TIMEOUT + LONGPRESS_TIMEOUT);
            }
            mHandler.sendEmptyMessageAtTime(SHOW_PRESS, mCurrentDownEvent.getDownTime() + TAP_TIMEOUT);
            handled |= mListener.onDown(ev);
            break;
        case MotionEvent.ACTION_MOVE:
            if (mInLongPress || mInContextClick) {
                break;
            }
            final float scrollX = mLastFocusX - focusX;
            final float scrollY = mLastFocusY - focusY;
            if (mIsDoubleTapping) {
                // Give the move events of the double-tap
                handled |= mDoubleTapListener.onDoubleTapEvent(ev);
            } else if (mAlwaysInTapRegion) {
                final int deltaX = (int) (focusX - mDownFocusX);
                final int deltaY = (int) (focusY - mDownFocusY);
                int distance = (deltaX * deltaX) + (deltaY * deltaY);
                if (distance > mTouchSlopSquare) {
                    handled = mListener.onScroll(mCurrentDownEvent, ev, scrollX, scrollY);
                    mLastFocusX = focusX;
                    mLastFocusY = focusY;
                    mAlwaysInTapRegion = false;
                    mHandler.removeMessages(TAP);
                    mHandler.removeMessages(SHOW_PRESS);
                    mHandler.removeMessages(LONG_PRESS);
                }
                if (distance > mDoubleTapTouchSlopSquare) {
                    mAlwaysInBiggerTapRegion = false;
                }
            } else if ((Math.abs(scrollX) >= 1) || (Math.abs(scrollY) >= 1)) {
                handled = mListener.onScroll(mCurrentDownEvent, ev, scrollX, scrollY);
                mLastFocusX = focusX;
                mLastFocusY = focusY;
            }
            break;
        case MotionEvent.ACTION_UP:
            mStillDown = false;
            MotionEvent currentUpEvent = MotionEvent.obtain(ev);
            if (mIsDoubleTapping) {
                // Finally, give the up event of the double-tap
                handled |= mDoubleTapListener.onDoubleTapEvent(ev);
            } else if (mInLongPress) {
                mHandler.removeMessages(TAP);
                mInLongPress = false;
            } else if (mAlwaysInTapRegion && !mIgnoreNextUpEvent) {
                handled = mListener.onSingleTapUp(ev);
                if (mDeferConfirmSingleTap && mDoubleTapListener != null) {
                    mDoubleTapListener.onSingleTapConfirmed(ev);
                }
            } else if (!mIgnoreNextUpEvent) {
                // A fling must travel the minimum tap distance
                final VelocityTracker velocityTracker = mVelocityTracker;
                final int pointerId = ev.getPointerId(0);
                velocityTracker.computeCurrentVelocity(1000, mMaximumFlingVelocity);
                final float velocityY = velocityTracker.getYVelocity(pointerId);
                final float velocityX = velocityTracker.getXVelocity(pointerId);
                if ((Math.abs(velocityY) > mMinimumFlingVelocity) || (Math.abs(velocityX) > mMinimumFlingVelocity)) {
                    handled = mListener.onFling(mCurrentDownEvent, ev, velocityX, velocityY);
                }
            }
            if (mPreviousUpEvent != null) {
                mPreviousUpEvent.recycle();
            }
            // Hold the event we obtained above - listeners may have changed the original.
            mPreviousUpEvent = currentUpEvent;
            if (mVelocityTracker != null) {
                // This may have been cleared when we called out to the
                // application above.
                mVelocityTracker.recycle();
                mVelocityTracker = null;
            }
            mIsDoubleTapping = false;
            mDeferConfirmSingleTap = false;
            mIgnoreNextUpEvent = false;
            mHandler.removeMessages(SHOW_PRESS);
            mHandler.removeMessages(LONG_PRESS);
            break;
        case MotionEvent.ACTION_CANCEL:
            cancel();
            break;
    }
    if (!handled && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 0);
    }
    return handled;
}",1,"/**
 * Analyzes the given motion event and if applicable triggers the
 * appropriate callbacks on the {@link OnGestureListener} supplied.
 *
 * @param ev The current motion event.
 * @return true if the {@link OnGestureListener} consumed the event,
 * else false.
 */
","/**
 * Analyzes the given motion event and if applicable triggers the
 * appropriate callbacks on the {@link OnGestureListener} supplied.
 *
 * @param ev The current motion event.
 * @return true if the {@link OnGestureListener} consumed the event,
 * else false.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
275,<android.bluetooth.BluetoothAdapter: boolean isOffloadedScanBatchingSupported()>,22,23,<android.bluetooth.BluetoothAdapter: boolean isOffloadedScanBatchingSupported()>,<android.bluetooth.BluetoothAdapter: boolean isOffloadedScanBatchingSupported()>,0,"{
    if (getState() != STATE_ON)
        return false;
    try {
        return mService.isOffloadedScanBatchingSupported();
    } catch (RemoteException e) {
        Log.e(TAG, ""failed to get isOffloadedScanBatchingSupported, error: "", e);
    }
    return false;
}","{
    if (!getLeAccess())
        return false;
    try {
        return mService.isOffloadedScanBatchingSupported();
    } catch (RemoteException e) {
        Log.e(TAG, ""failed to get isOffloadedScanBatchingSupported, error: "", e);
    }
    return false;
}",1,"/**
 * Return true if offloaded scan batching is supported
 *
 * @return true if chipset supports on-chip scan batching
 */
","/**
 * Return true if offloaded scan batching is supported
 *
 * @return true if chipset supports on-chip scan batching
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,5",0,"The control dependency has changed from if (getState() != STATE_ON) to if (!getLeAccess()), and the dependent API called within the condition has changed from getState() to getLeAccess(), hence the change types are 3 and 5.","There is no Compatibility Issue because the function is returning the same type of value (false) in the same condition branch which has been modified (i.e., when Bluetooth is not in the correct state for offloaded scan batching to be supported). The different method used for the condition check (getState() vs getLeAccess()) does not inherently cause a Compatibility Issue within the context of this method's operation, as the false return value is tied to a precondition not being met for both methods. So the precondition check (Bluetooth state/service access) has changed semantically, but the behavior when that precondition is not met (returning false) remains consistent."
277,"<android.os.ParcelFileDescriptor: void writeToParcel(Parcel,int)>",22,23,"<android.os.ParcelFileDescriptor: void writeToParcel(Parcel,int)>","<android.os.ParcelFileDescriptor: void writeToParcel(Parcel,int)>",0,"{
    // in frameworks/native/libs/binder/Parcel.cpp
    if (mWrapped != null) {
        try {
            mWrapped.writeToParcel(out, flags);
        } finally {
            releaseResources();
        }
    } else {
        out.writeFileDescriptor(mFd);
        if (mCommFd != null) {
            out.writeInt(1);
            out.writeFileDescriptor(mCommFd);
        } else {
            out.writeInt(0);
        }
        if ((flags & PARCELABLE_WRITE_RETURN_VALUE) != 0 && !mClosed) {
            // Not a real close, so emit no status
            closeWithStatus(Status.SILENCE, null);
        }
    }
}","{
    if (mWrapped != null) {
        try {
            mWrapped.writeToParcel(out, flags);
        } finally {
            releaseResources();
        }
    } else {
        if (mCommFd != null) {
            out.writeInt(1);
            out.writeFileDescriptor(mFd);
            out.writeFileDescriptor(mCommFd);
        } else {
            out.writeInt(0);
            out.writeFileDescriptor(mFd);
        }
        if ((flags & PARCELABLE_WRITE_RETURN_VALUE) != 0 && !mClosed) {
            // Not a real close, so emit no status
            closeWithStatus(Status.SILENCE, null);
        }
    }
}",1,"/**
 * {@inheritDoc}
 * If {@link Parcelable#PARCELABLE_WRITE_RETURN_VALUE} is set in flags,
 * the file descriptor will be closed after a copy is written to the Parcel.
 */
","/**
 * {@inheritDoc}
 * If {@link Parcelable#PARCELABLE_WRITE_RETURN_VALUE} is set in flags,
 * the file descriptor will be closed after a copy is written to the Parcel.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The structure of the if-else block related to `mCommFd` has been altered, and the sequence of write operations is changed—`out.writeInt` and `out.writeFileDescriptor(mFd)` has been moved within the conditional branches—hence there's a change in the control dependency and other changes as well.","There is no Compatibility Issue detected because the functionality remains the same. In both versions, depending on whether `mCommFd` is null or not, it writes an integer and then one or two file descriptors. The sequence of operations inside the if-else block has changed but this does not change the behavior from the perspective of the caller. No different values or exceptions are introduced by this change."
278,<android.app.FragmentManagerImpl: String toString()>,22,23,<android.app.FragmentManagerImpl: String toString()>,<android.app.FragmentManagerImpl: String toString()>,0,"{
    StringBuilder sb = new StringBuilder(128);
    sb.append(""FragmentManager{"");
    sb.append(Integer.toHexString(System.identityHashCode(this)));
    sb.append("" in "");
    if (mParent != null) {
        DebugUtils.buildShortClassTag(mParent, sb);
    } else {
        DebugUtils.buildShortClassTag(mActivity, sb);
    }
    sb.append(""}}"");
    return sb.toString();
}","{
    StringBuilder sb = new StringBuilder(128);
    sb.append(""FragmentManager{"");
    sb.append(Integer.toHexString(System.identityHashCode(this)));
    sb.append("" in "");
    if (mParent != null) {
        DebugUtils.buildShortClassTag(mParent, sb);
    } else {
        DebugUtils.buildShortClassTag(mHost, sb);
    }
    sb.append(""}}"");
    return sb.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"The implementation code change where the method `DebugUtils.buildShortClassTag()` is called with a different parameter (`mActivity` to `mHost`), so the code change type is 4,5.","The method call's parameter change can potentially return different string representations of the object's class, so the CI type is 1."
279,"<android.content.res.Resources: String getString(int,Object)>",22,23,"<android.content.res.Resources: String getString(int,Object)>","<android.content.res.Resources: String getString(int,Object)>",0,"{
    String raw = getString(id);
    return String.format(mConfiguration.locale, raw, formatArgs);
}","{
    final String raw = getString(id);
    return String.format(mConfiguration.locale, raw, formatArgs);
}",1,"/**
 * Return the string value associated with a particular resource ID,
 * substituting the format arguments as defined in {@link java.util.Formatter}
 * and {@link java.lang.String#format}. It will be stripped of any styled text
 * information.
 * {@more}
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 *
 * @param formatArgs The format arguments that will be used for substitution.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @return String The string data associated with the resource,
 * stripped of styled text information.
 */
","/**
 * Return the string value associated with a particular resource ID,
 * substituting the format arguments as defined in {@link java.util.Formatter}
 * and {@link java.lang.String#format}. It will be stripped of any styled text
 * information.
 * {@more}
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 *
 * @param formatArgs The format arguments that will be used for substitution.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @return String The string data associated with the resource,
 * stripped of styled text information.
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,0,0,"The only change in the implementation is the addition of the 'final' keyword to the string variable 'raw'. Adding 'final' to a variable declaration does not change its runtime behavior; it only prevents the variable from being reassigned. Therefore, there is no functional change to the API's behavior, and the code change type is 0.","There is no compatibility issue between the two versions as the 'final' keyword on a variable does not affect the returned value or the exceptions thrown by the method. The API's contract and behavior remain unchanged, so the CI type is 0."
280,<android.view.accessibility.AccessibilityNodeInfo: boolean refresh()>,22,23,<android.view.accessibility.AccessibilityNodeInfo: boolean refresh()>,<android.view.accessibility.AccessibilityNodeInfo: boolean refresh()>,0,"{
    return refresh(false);
}","{
    return refresh(true);
}",1,"/**
 * Refreshes this info with the latest state of the view it represents.
 * <p>
 * <strong>Note:</strong> If this method returns false this info is obsolete
 * since it represents a view that is no longer in the view tree and should
 * be recycled.
 * </p>
 * @return Whether the refresh succeeded.
 */
","/**
 * Refreshes this info with the latest state of the view it represents.
 * <p>
 * <strong>Note:</strong> If this method returns false this info is obsolete
 * since it represents a view that is no longer in the view tree and should
 * be recycled.
 * </p>
 * @return Whether the refresh succeeded.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The dependent API 'refresh()' is being passed a different literal value where 'false' has been changed to 'true' in the late implementation. Thus, the change type is 1,5 due to the different parameter values in the method call.","Since the refresh method is called with a different argument between versions, this could lead to different behaviors of the API, potentially resulting in different return values. Therefore, the CI type is 1."
282,<android.text.SpannableStringBuilder: int getSpanStart(Object)>,22,23,<android.text.SpannableStringBuilder: int getSpanStart(Object)>,<android.text.SpannableStringBuilder: int getSpanStart(Object)>,0,"{
    int count = mSpanCount;
    Object[] spans = mSpans;
    for (int i = count - 1; i >= 0; i--) {
        if (spans[i] == what) {
            int where = mSpanStarts[i];
            if (where > mGapStart)
                where -= mGapLength;
            return where;
        }
    }
    return -1;
}","{
    if (mIndexOfSpan == null)
        return -1;
    Integer i = mIndexOfSpan.get(what);
    return i == null ? -1 : resolveGap(mSpanStarts[i]);
}",1,"/**
 * Return the buffer offset of the beginning of the specified
 * markup object, or -1 if it is not attached to this buffer.
 */
","/**
 * Return the buffer offset of the beginning of the specified
 * markup object, or -1 if it is not attached to this buffer.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The for loop has been completely removed, and a new data structure 'mIndexOfSpan' together with new APIs 'mIndexOfSpan.get(what)' and 'resolveGap(mSpanStarts[i])' have been introduced. The type of ""what"" parameter and the logic for determining the index have undergone significant changes. The code change type is thus 1 (for the different return statements), 3 (for the removal of the control structure), 4 (for other changes like introducing new variables and altering the logic flow), and 5 (dependent API changed due to the introduction of new APIs and data structures).","Since the whole logic for calculating the span start has been rewritten, the method might return different results than before even when passing the same ""what"" parameter, and hence, the change introduces a potential Compatibility Issue due to different return values or types. The CI type is 1."
283,<android.content.res.TypedArray: int getChangingConfigurations()>,22,23,<android.content.res.TypedArray: int getChangingConfigurations()>,<android.content.res.TypedArray: int getChangingConfigurations()>,0,"{
    int changingConfig = 0;
    final int[] data = mData;
    final int N = length();
    for (int i = 0; i < N; i++) {
        final int index = i * AssetManager.STYLE_NUM_ENTRIES;
        final int type = data[index + AssetManager.STYLE_TYPE];
        if (type == TypedValue.TYPE_NULL) {
            continue;
        }
        changingConfig |= data[index + AssetManager.STYLE_CHANGING_CONFIGURATIONS];
    }
    return changingConfig;
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    int changingConfig = 0;
    final int[] data = mData;
    final int N = length();
    for (int i = 0; i < N; i++) {
        final int index = i * AssetManager.STYLE_NUM_ENTRIES;
        final int type = data[index + AssetManager.STYLE_TYPE];
        if (type == TypedValue.TYPE_NULL) {
            continue;
        }
        changingConfig |= data[index + AssetManager.STYLE_CHANGING_CONFIGURATIONS];
    }
    return changingConfig;
}",1,"/**
 * Return a mask of the configuration parameters for which the values in
 * this typed array may change.
 *
 * @return Returns a mask of the changing configuration parameters, as
 * defined by {@link android.content.pm.ActivityInfo}.
 * @see android.content.pm.ActivityInfo
 */
","/**
 * Return a mask of the configuration parameters for which the values in
 * this typed array may change.
 *
 * @return Returns a mask of the changing configuration parameters, as
 * defined by {@link android.content.pm.ActivityInfo}.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @see android.content.pm.ActivityInfo
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"The control dependency has changed by introducing a new 'if' check for mRecycled with an associated throw statement at the beginning of the late version, so the change type is 2,3.","The newly introduced 'if' check can cause the late version of the API to throw a RuntimeException that wasn't possible in the early version. Therefore, the change will potentially lead to a different exception handling, and the CI type is 2."
284,<android.print.PrintAttributes: boolean equals(Object)>,22,23,<android.print.PrintAttributes: boolean equals(Object)>,<android.print.PrintAttributes: boolean equals(Object)>,0,"{
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    PrintAttributes other = (PrintAttributes) obj;
    if (mColorMode != other.mColorMode) {
        return false;
    }
    if (mMinMargins == null) {
        if (other.mMinMargins != null) {
            return false;
        }
    } else if (!mMinMargins.equals(other.mMinMargins)) {
        return false;
    }
    if (mMediaSize == null) {
        if (other.mMediaSize != null) {
            return false;
        }
    } else if (!mMediaSize.equals(other.mMediaSize)) {
        return false;
    }
    if (mResolution == null) {
        if (other.mResolution != null) {
            return false;
        }
    } else if (!mResolution.equals(other.mResolution)) {
        return false;
    }
    return true;
}","{
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    PrintAttributes other = (PrintAttributes) obj;
    if (mColorMode != other.mColorMode) {
        return false;
    }
    if (mDuplexMode != other.mDuplexMode) {
        return false;
    }
    if (mMinMargins == null) {
        if (other.mMinMargins != null) {
            return false;
        }
    } else if (!mMinMargins.equals(other.mMinMargins)) {
        return false;
    }
    if (mMediaSize == null) {
        if (other.mMediaSize != null) {
            return false;
        }
    } else if (!mMediaSize.equals(other.mMediaSize)) {
        return false;
    }
    if (mResolution == null) {
        if (other.mResolution != null) {
            return false;
        }
    } else if (!mResolution.equals(other.mResolution)) {
        return false;
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,"A new condition to check ""mDuplexMode"" has been introduced in the late version which is not present in the early version, this is not a return, exception handling, or control dependency change but an ""Other statement changed"", hence the change type is 4.","This newly added condition introduces a new comparison which impacts the equality check between two PrintAttributes objects. Therefore, objects that were considered equal in the early version might not be equal in the late version if their mDuplexMode values differ, leading to potential Compatibility Issue by returning different boolean values, which corresponds to CI type 1."
285,"<android.appwidget.AppWidgetHost.Callbacks: void viewDataChanged(int,int)>",22,23,"<android.appwidget.AppWidgetHost.Callbacks: void viewDataChanged(int,int)>","<android.appwidget.AppWidgetHost.Callbacks: void viewDataChanged(int,int)>",0,"{
    Message msg = mHandler.obtainMessage(HANDLE_VIEW_DATA_CHANGED, appWidgetId, viewId);
    msg.sendToTarget();
}","{
    Handler handler = mWeakHandler.get();
    if (handler == null) {
        return;
    }
    Message msg = handler.obtainMessage(HANDLE_VIEW_DATA_CHANGED, appWidgetId, viewId);
    msg.sendToTarget();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The late version introduced new control dependency (the if statement) and a new variable handling (handler), which is a change in the control statements and other statements, therefore it's 3,4.","There is no Compatibility Issue because the newly introduced if condition only affects whether the method proceeds with sending a message, but it does not affect the behaviour of the method with respect to the types of values returned or exceptions thrown; it simply guards against a null Handler instance. Since the method is void, no return value is affected, and no new exceptions are thrown. Hence, the CI type is 0."
287,<android.transition.Transition: boolean isValidTarget(View)>,22,23,<android.transition.Transition: boolean isValidTarget(View)>,<android.transition.Transition: boolean isValidTarget(View)>,0,"{
    int targetId = target.getId();
    if (mTargetIdExcludes != null && mTargetIdExcludes.contains(targetId)) {
        return false;
    }
    if (mTargetExcludes != null && mTargetExcludes.contains(target)) {
        return false;
    }
    if (mTargetTypeExcludes != null && target != null) {
        int numTypes = mTargetTypeExcludes.size();
        for (int i = 0; i < numTypes; ++i) {
            Class type = mTargetTypeExcludes.get(i);
            if (type.isInstance(target)) {
                return false;
            }
        }
    }
    if (mTargetNameExcludes != null && target != null && target.getTransitionName() != null) {
        if (mTargetNameExcludes.contains(target.getTransitionName())) {
            return false;
        }
    }
    if (mTargetIds.size() == 0 && mTargets.size() == 0 && (mTargetTypes == null || mTargetTypes.isEmpty()) && (mTargetNames == null || mTargetNames.isEmpty())) {
        return true;
    }
    if (mTargetIds.contains(targetId) || mTargets.contains(target)) {
        return true;
    }
    if (mTargetNames != null && mTargetNames.contains(target.getTransitionName())) {
        return true;
    }
    if (mTargetTypes != null) {
        for (int i = 0; i < mTargetTypes.size(); ++i) {
            if (mTargetTypes.get(i).isInstance(target)) {
                return true;
            }
        }
    }
    return false;
}","{
    if (target == null) {
        return false;
    }
    int targetId = target.getId();
    if (mTargetIdExcludes != null && mTargetIdExcludes.contains(targetId)) {
        return false;
    }
    if (mTargetExcludes != null && mTargetExcludes.contains(target)) {
        return false;
    }
    if (mTargetTypeExcludes != null && target != null) {
        int numTypes = mTargetTypeExcludes.size();
        for (int i = 0; i < numTypes; ++i) {
            Class type = mTargetTypeExcludes.get(i);
            if (type.isInstance(target)) {
                return false;
            }
        }
    }
    if (mTargetNameExcludes != null && target != null && target.getTransitionName() != null) {
        if (mTargetNameExcludes.contains(target.getTransitionName())) {
            return false;
        }
    }
    if (mTargetIds.size() == 0 && mTargets.size() == 0 && (mTargetTypes == null || mTargetTypes.isEmpty()) && (mTargetNames == null || mTargetNames.isEmpty())) {
        return true;
    }
    if (mTargetIds.contains(targetId) || mTargets.contains(target)) {
        return true;
    }
    if (mTargetNames != null && mTargetNames.contains(target.getTransitionName())) {
        return true;
    }
    if (mTargetTypes != null) {
        for (int i = 0; i < mTargetTypes.size(); ++i) {
            if (mTargetTypes.get(i).isInstance(target)) {
                return true;
            }
        }
    }
    return false;
}",1,"/**
 * Internal utility method for checking whether a given view/id
 * is valid for this transition, where ""valid"" means that either
 * the Transition has no target/targetId list (the default, in which
 * cause the transition should act on all views in the hiearchy), or
 * the given view is in the target list or the view id is in the
 * targetId list. If the target parameter is null, then the target list
 * is not checked (this is in the case of ListView items, where the
 * views are ignored and only the ids are used).
 */
","/**
 * Internal utility method for checking whether a given view/id
 * is valid for this transition, where ""valid"" means that either
 * the Transition has no target/targetId list (the default, in which
 * cause the transition should act on all views in the hiearchy), or
 * the given view is in the target list or the view id is in the
 * targetId list. If the target parameter is null, then the target list
 * is not checked (this is in the case of ListView items, where the
 * views are ignored and only the ids are used).
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"An additional check for `target == null` at the beginning of the method was introduced in the late version which changes the control flow, so the code change type is 3.","The new `target == null` check potentially makes the API return a different value (false) for cases where target was previously null and not checked explicitly, where the old implementation might have thrown a NullPointerException or behaved differently. Thus, there is a potential Compatibility Issue caused by returning a different value, which is CI type 1."
288,<android.content.RestrictionEntry: boolean equals(Object)>,22,23,<android.content.RestrictionEntry: boolean equals(Object)>,<android.content.RestrictionEntry: boolean equals(Object)>,0,"{
    if (o == this)
        return true;
    if (!(o instanceof RestrictionEntry))
        return false;
    final RestrictionEntry other = (RestrictionEntry) o;
    // Make sure that either currentValue matches or currentValues matches.
    return mType == other.mType && mKey.equals(other.mKey) && ((mCurrentValues == null && other.mCurrentValues == null && mCurrentValue != null && mCurrentValue.equals(other.mCurrentValue)) || (mCurrentValue == null && other.mCurrentValue == null && mCurrentValues != null && equalArrays(mCurrentValues, other.mCurrentValues)));
}","{
    if (o == this)
        return true;
    if (!(o instanceof RestrictionEntry))
        return false;
    final RestrictionEntry other = (RestrictionEntry) o;
    if (mType != other.mType || !mKey.equals(other.mKey)) {
        return false;
    }
    if (mCurrentValues == null && other.mCurrentValues == null && mRestrictions == null && other.mRestrictions == null && Objects.equals(mCurrentValue, other.mCurrentValue)) {
        return true;
    }
    if (mCurrentValue == null && other.mCurrentValue == null && mRestrictions == null && other.mRestrictions == null && Arrays.equals(mCurrentValues, other.mCurrentValues)) {
        return true;
    }
    if (mCurrentValue == null && other.mCurrentValue == null && mCurrentValue == null && other.mCurrentValue == null && Arrays.equals(mRestrictions, other.mRestrictions)) {
        return true;
    }
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,"The logic for checking equality is restructured with additional conditions checks and includes a new check for `mRestrictions`. The usage of `equalArrays` is replaced with `Arrays.equals` and `mCurrentValue.equals` replaced with `Objects.equals`. These changes imply Return statement changed, Control dependency changed, and Other statement changed, hence, the change types are 1,3,4.","With the restructuring of the logic, this could potentially return a different result from the equality check, which constitutes a change in behavior. The introduction of new condition checks may also influence the outcome. Therefore, the CI type is 1."
289,<android.view.AccessibilityInteractionController.PrivateHandler: void handleMessage(Message)>,22,23,<android.view.AccessibilityInteractionController.PrivateHandler: void handleMessage(Message)>,<android.view.AccessibilityInteractionController.PrivateHandler: void handleMessage(Message)>,0,"{
    final int type = message.what;
    switch(type) {
        case MSG_FIND_ACCESSIBILITY_NODE_INFO_BY_ACCESSIBILITY_ID:
            {
                findAccessibilityNodeInfoByAccessibilityIdUiThread(message);
            }
            break;
        case MSG_PERFORM_ACCESSIBILITY_ACTION:
            {
                perfromAccessibilityActionUiThread(message);
            }
            break;
        case MSG_FIND_ACCESSIBILITY_NODE_INFOS_BY_VIEW_ID:
            {
                findAccessibilityNodeInfosByViewIdUiThread(message);
            }
            break;
        case MSG_FIND_ACCESSIBILITY_NODE_INFO_BY_TEXT:
            {
                findAccessibilityNodeInfosByTextUiThread(message);
            }
            break;
        case MSG_FIND_FOCUS:
            {
                findFocusUiThread(message);
            }
            break;
        case MSG_FOCUS_SEARCH:
            {
                focusSearchUiThread(message);
            }
            break;
        default:
            throw new IllegalArgumentException(""Unknown message type: "" + type);
    }
}","{
    final int type = message.what;
    switch(type) {
        case MSG_FIND_ACCESSIBILITY_NODE_INFO_BY_ACCESSIBILITY_ID:
            {
                findAccessibilityNodeInfoByAccessibilityIdUiThread(message);
            }
            break;
        case MSG_PERFORM_ACCESSIBILITY_ACTION:
            {
                performAccessibilityActionUiThread(message);
            }
            break;
        case MSG_FIND_ACCESSIBILITY_NODE_INFOS_BY_VIEW_ID:
            {
                findAccessibilityNodeInfosByViewIdUiThread(message);
            }
            break;
        case MSG_FIND_ACCESSIBILITY_NODE_INFO_BY_TEXT:
            {
                findAccessibilityNodeInfosByTextUiThread(message);
            }
            break;
        case MSG_FIND_FOCUS:
            {
                findFocusUiThread(message);
            }
            break;
        case MSG_FOCUS_SEARCH:
            {
                focusSearchUiThread(message);
            }
            break;
        default:
            throw new IllegalArgumentException(""Unknown message type: "" + type);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,0,0,"There is a typo correction from ""perfromAccessibilityActionUiThread"" to ""performAccessibilityActionUiThread"", but there is no actual other statement change as both indicate the same method call after the correction. The logic and flow of the code remain identical in both versions.","There is no Compatibility Issue, since the typo correction does not affect the API behavior from the early to the late version; the functionality and exception handling remain the same."
290,"<android.bluetooth.le.BluetoothLeScanner.BleScanCallbackWrapper: void onClientRegistered(int,int)>",22,23,"<android.bluetooth.le.BluetoothLeScanner.BleScanCallbackWrapper: void onClientRegistered(int,int)>","<android.bluetooth.le.BluetoothLeScanner.BleScanCallbackWrapper: void onClientRegistered(int,int)>",0,"{
    Log.d(TAG, ""onClientRegistered() - status="" + status + "" clientIf="" + clientIf);
    synchronized (this) {
        if (mClientIf == -1) {
            if (DBG)
                Log.d(TAG, ""onClientRegistered LE scan canceled"");
        }
        if (status == BluetoothGatt.GATT_SUCCESS) {
            mClientIf = clientIf;
            try {
                mBluetoothGatt.startScan(mClientIf, false, mSettings, mFilters, mResultStorages);
            } catch (RemoteException e) {
                Log.e(TAG, ""fail to start le scan: "" + e);
                mClientIf = -1;
            }
        } else {
            // registration failed
            mClientIf = -1;
        }
        notifyAll();
    }
}","{
    Log.d(TAG, ""onClientRegistered() - status="" + status + "" clientIf="" + clientIf);
    synchronized (this) {
        if (mClientIf == -1) {
            if (DBG)
                Log.d(TAG, ""onClientRegistered LE scan canceled"");
        }
        if (status == BluetoothGatt.GATT_SUCCESS) {
            mClientIf = clientIf;
            try {
                mBluetoothGatt.startScan(mClientIf, false, mSettings, mFilters, mResultStorages, ActivityThread.currentOpPackageName());
            } catch (RemoteException e) {
                Log.e(TAG, ""fail to start le scan: "" + e);
                mClientIf = -1;
            }
        } else {
            // registration failed
            mClientIf = -1;
        }
        notifyAll();
    }
}",1,"/**
 * Application interface registered - app is ready to go
 */
","/**
 * Application interface registered - app is ready to go
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The change is within the method `mBluetoothGatt.startScan`, which now includes one additional parameter, `ActivityThread.currentOpPackageName()`. This is an example of a 'Dependent API changed'.","There is no compatibility issue because the addition of a parameter to the internal API call does not alter the method's signature, nor does it change the type or value of what `onClientRegistered` returns, and it doesn't introduce new exception handling or change the control flow. It would not affect the existing code that calls `onClientRegistered`."
291,<android.widget.TextView: boolean onTouchEvent(MotionEvent)>,22,23,<android.widget.TextView: boolean onTouchEvent(MotionEvent)>,<android.widget.TextView: boolean onTouchEvent(MotionEvent)>,0,"{
    final int action = event.getActionMasked();
    if (mEditor != null)
        mEditor.onTouchEvent(event);
    final boolean superResult = super.onTouchEvent(event);
    /*
         * Don't handle the release after a long press, because it will
         * move the selection away from whatever the menu action was
         * trying to affect.
         */
    if (mEditor != null && mEditor.mDiscardNextActionUp && action == MotionEvent.ACTION_UP) {
        mEditor.mDiscardNextActionUp = false;
        return superResult;
    }
    final boolean touchIsFinished = (action == MotionEvent.ACTION_UP) && (mEditor == null || !mEditor.mIgnoreActionUpEvent) && isFocused();
    if ((mMovement != null || onCheckIsTextEditor()) && isEnabled() && mText instanceof Spannable && mLayout != null) {
        boolean handled = false;
        if (mMovement != null) {
            handled |= mMovement.onTouchEvent(this, (Spannable) mText, event);
        }
        final boolean textIsSelectable = isTextSelectable();
        if (touchIsFinished && mLinksClickable && mAutoLinkMask != 0 && textIsSelectable) {
            // The LinkMovementMethod which should handle taps on links has not been installed
            // on non editable text that support text selection.
            // We reproduce its behavior here to open links for these.
            ClickableSpan[] links = ((Spannable) mText).getSpans(getSelectionStart(), getSelectionEnd(), ClickableSpan.class);
            if (links.length > 0) {
                links[0].onClick(this);
                handled = true;
            }
        }
        if (touchIsFinished && (isTextEditable() || textIsSelectable)) {
            // Show the IME, except when selecting in read-only text.
            final InputMethodManager imm = InputMethodManager.peekInstance();
            viewClicked(imm);
            if (!textIsSelectable && mEditor.mShowSoftInputOnFocus) {
                handled |= imm != null && imm.showSoftInput(this, 0);
            }
            // The above condition ensures that the mEditor is not null
            mEditor.onTouchUpEvent(event);
            handled = true;
        }
        if (handled) {
            return true;
        }
    }
    return superResult;
}","{
    final int action = event.getActionMasked();
    if (mEditor != null && action == MotionEvent.ACTION_DOWN) {
        // Detect double tap and inform the Editor.
        if (mFirstTouch && (SystemClock.uptimeMillis() - mLastTouchUpTime) <= ViewConfiguration.getDoubleTapTimeout()) {
            mEditor.mDoubleTap = true;
            mFirstTouch = false;
        } else {
            mEditor.mDoubleTap = false;
            mFirstTouch = true;
        }
    }
    if (action == MotionEvent.ACTION_UP) {
        mLastTouchUpTime = SystemClock.uptimeMillis();
    }
    if (mEditor != null) {
        mEditor.onTouchEvent(event);
        if (mEditor.mSelectionModifierCursorController != null && mEditor.mSelectionModifierCursorController.isDragAcceleratorActive()) {
            return true;
        }
    }
    final boolean superResult = super.onTouchEvent(event);
    /*
         * Don't handle the release after a long press, because it will move the selection away from
         * whatever the menu action was trying to affect. If the long press should have triggered an
         * insertion action mode, we can now actually show it.
         */
    if (mEditor != null && mEditor.mDiscardNextActionUp && action == MotionEvent.ACTION_UP) {
        mEditor.mDiscardNextActionUp = false;
        if (mEditor.mIsInsertionActionModeStartPending) {
            mEditor.startInsertionActionMode();
            mEditor.mIsInsertionActionModeStartPending = false;
        }
        return superResult;
    }
    final boolean touchIsFinished = (action == MotionEvent.ACTION_UP) && (mEditor == null || !mEditor.mIgnoreActionUpEvent) && isFocused();
    if ((mMovement != null || onCheckIsTextEditor()) && isEnabled() && mText instanceof Spannable && mLayout != null) {
        boolean handled = false;
        if (mMovement != null) {
            handled |= mMovement.onTouchEvent(this, (Spannable) mText, event);
        }
        final boolean textIsSelectable = isTextSelectable();
        if (touchIsFinished && mLinksClickable && mAutoLinkMask != 0 && textIsSelectable) {
            // The LinkMovementMethod which should handle taps on links has not been installed
            // on non editable text that support text selection.
            // We reproduce its behavior here to open links for these.
            ClickableSpan[] links = ((Spannable) mText).getSpans(getSelectionStart(), getSelectionEnd(), ClickableSpan.class);
            if (links.length > 0) {
                links[0].onClick(this);
                handled = true;
            }
        }
        if (touchIsFinished && (isTextEditable() || textIsSelectable)) {
            // Show the IME, except when selecting in read-only text.
            final InputMethodManager imm = InputMethodManager.peekInstance();
            viewClicked(imm);
            if (!textIsSelectable && mEditor.mShowSoftInputOnFocus) {
                handled |= imm != null && imm.showSoftInput(this, 0);
            }
            // The above condition ensures that the mEditor is not null
            mEditor.onTouchUpEvent(event);
            handled = true;
        }
        if (handled) {
            return true;
        }
    }
    return superResult;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
292,<android.net.Network: void bindSocket(DatagramSocket)>,22,23,<android.net.Network: void bindSocket(DatagramSocket)>,<android.net.Network: void bindSocket(DatagramSocket)>,0,"{
    // Apparently, the kernel doesn't update a connected UDP socket's routing upon mark changes.
    if (socket.isConnected()) {
        throw new SocketException(""Socket is connected"");
    }
    // Query a property of the underlying socket to ensure that the socket's file descriptor
    // exists, is available to bind to a network and is not closed.
    socket.getReuseAddress();
    bindSocketFd(socket.getFileDescriptor$());
}","{
    // Query a property of the underlying socket to ensure that the socket's file descriptor
    // exists, is available to bind to a network and is not closed.
    socket.getReuseAddress();
    bindSocket(socket.getFileDescriptor$());
}",1,"/**
 * Binds the specified {@link DatagramSocket} to this {@code Network}. All data traffic on the
 * socket will be sent on this {@code Network}, irrespective of any process-wide network binding
 * set by {@link ConnectivityManager#setProcessDefaultNetwork}. The socket must not be
 * connected.
 */
","/**
 * Binds the specified {@link DatagramSocket} to this {@code Network}. All data traffic on the
 * socket will be sent on this {@code Network}, irrespective of any process-wide network binding
 * set by {@link ConnectivityManager#bindProcessToNetwork}. The socket must not be
 * connected.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"The early version has a conditional check that throws a SocketException if the socket is connected, which has been removed in the late version. This is an exception handling statement change (type 2). Also, there is a change in the method call from bindSocketFd(socket.getFileDescriptor$()) to bindSocket(socket.getFileDescriptor$()), but since the method signature does not provide information about the 'bindSocketFd' or 'bindSocket' methods, this change is considered as ""Other statement changed"" (type 4).","By removing the conditional check, the late version of the API no longer throws a SocketException when the socket is connected, which potentially leads to different exception handling. This is a Compatibility Issue of type 2."
293,"<android.accounts.AccountManager: AccountManagerFuture<Bundle> removeAccount(Account,Activity,AccountManagerCallback<Bundle>,Handler)>",22,23,"<android.accounts.AccountManager: AccountManagerFuture<Bundle> removeAccount(Account,Activity,AccountManagerCallback<Bundle>,Handler)>","<android.accounts.AccountManager: AccountManagerFuture<Bundle> removeAccount(Account,Activity,AccountManagerCallback<Bundle>,Handler)>",0,"{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    return new AmsTask(activity, handler, callback) {

        public void doWork() throws RemoteException {
            mService.removeAccount(mResponse, account, activity != null);
        }
    }.start();
}","{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    return new AmsTask(activity, handler, callback) {

        @Override
        public void doWork() throws RemoteException {
            mService.removeAccount(mResponse, account, activity != null);
        }
    }.start();
}",1,"/**
 * Removes an account from the AccountManager. Does nothing if the account
 * does not exist.  Does not delete the account from the server.
 * The authenticator may have its own policies preventing account
 * deletion, in which case the account will not be deleted.
 *
 * <p>This method may be called from any thread, but the returned
 * {@link AccountManagerFuture} must not be used on the main thread.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#MANAGE_ACCOUNTS}.
 *
 * @param account The {@link Account} to remove
 * @param activity The {@link Activity} context to use for launching a new
 * authenticator-defined sub-Activity to prompt the user to delete an
 * account; used only to call startActivity(); if null, the prompt
 * will not be launched directly, but the {@link Intent} may be
 * returned to the caller instead
 * @param callback Callback to invoke when the request completes,
 * null for no callback
 * @param handler {@link Handler} identifying the callback thread,
 * null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Bundle with
 * {@link #KEY_BOOLEAN_RESULT} if activity was specified and an account
 * was removed or if active. If no activity was specified, the returned
 * Bundle contains only {@link #KEY_INTENT} with the {@link Intent}
 * needed to launch the actual account removal process, if authenticator
 * needs the activity launch. If an error occurred,
 * {@link AccountManagerFuture#getResult()} throws:
 * <ul>
 * <li> {@link AuthenticatorException} if no authenticator was registered for
 * this account type or the authenticator failed to respond
 * <li> {@link OperationCanceledException} if the operation was canceled for
 * any reason, including the user canceling the creation process or
 * adding accounts (of this type) has been disabled by policy
 * </ul>
 */
","/**
 * Removes an account from the AccountManager. Does nothing if the account
 * does not exist.  Does not delete the account from the server.
 * The authenticator may have its own policies preventing account
 * deletion, in which case the account will not be deleted.
 *
 * <p>This method may be called from any thread, but the returned
 * {@link AccountManagerFuture} must not be used on the main thread.
 *
 * <p>This method requires the caller to have a signature match with the
 * authenticator that manages the specified account.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * MANAGE_ACCOUNTS permission is needed for those platforms. See docs for
 * this function in API level 22.
 *
 * @param account The {@link Account} to remove
 * @param activity The {@link Activity} context to use for launching a new
 * authenticator-defined sub-Activity to prompt the user to delete an
 * account; used only to call startActivity(); if null, the prompt
 * will not be launched directly, but the {@link Intent} may be
 * returned to the caller instead
 * @param callback Callback to invoke when the request completes,
 * null for no callback
 * @param handler {@link Handler} identifying the callback thread,
 * null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Bundle with
 * {@link #KEY_BOOLEAN_RESULT} if activity was specified and an account
 * was removed or if active. If no activity was specified, the returned
 * Bundle contains only {@link #KEY_INTENT} with the {@link Intent}
 * needed to launch the actual account removal process, if authenticator
 * needs the activity launch. If an error occurred,
 * {@link AccountManagerFuture#getResult()} throws:
 * <ul>
 * <li> {@link AuthenticatorException} if no authenticator was registered for
 * this account type or the authenticator failed to respond
 * <li> {@link OperationCanceledException} if the operation was canceled for
 * any reason, including the user canceling the creation process or
 * adding accounts (of this type) has been disabled by policy
 * </ul>
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"There is no actual code change other than the addition of the `@Override` annotation, which does not affect the behavior of the method.",There is no compatibility issue because the behavioral semantics of the API have not changed; the method still performs the same function in the same way.
294,"<android.app.ContextImpl: void startIntentSender(IntentSender,Intent,int,int,int,Bundle)>",22,23,"<android.app.ContextImpl: void startIntentSender(IntentSender,Intent,int,int,int,Bundle)>","<android.app.ContextImpl: void startIntentSender(IntentSender,Intent,int,int,int,Bundle)>",0,"{
    try {
        String resolvedType = null;
        if (fillInIntent != null) {
            fillInIntent.migrateExtraStreamToClipData();
            fillInIntent.prepareToLeaveProcess();
            resolvedType = fillInIntent.resolveTypeIfNeeded(getContentResolver());
        }
        int result = ActivityManagerNative.getDefault().startActivityIntentSender(mMainThread.getApplicationThread(), intent, fillInIntent, resolvedType, null, null, 0, flagsMask, flagsValues, options);
        if (result == ActivityManager.START_CANCELED) {
            throw new IntentSender.SendIntentException();
        }
        Instrumentation.checkStartActivityResult(result, null);
    } catch (RemoteException e) {
    }
}","{
    try {
        String resolvedType = null;
        if (fillInIntent != null) {
            fillInIntent.migrateExtraStreamToClipData();
            fillInIntent.prepareToLeaveProcess();
            resolvedType = fillInIntent.resolveTypeIfNeeded(getContentResolver());
        }
        int result = ActivityManagerNative.getDefault().startActivityIntentSender(mMainThread.getApplicationThread(), intent, fillInIntent, resolvedType, null, null, 0, flagsMask, flagsValues, options);
        if (result == ActivityManager.START_CANCELED) {
            throw new IntentSender.SendIntentException();
        }
        Instrumentation.checkStartActivityResult(result, null);
    } catch (RemoteException e) {
        throw new RuntimeException(""Failure from system"", e);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,2,2,"The late version has introduced a new throw statement inside the catch block for the RemoteException. Previously, the catch block was empty, so this is a change in the exception handling statement, which is type 2.","This change introduces a new RuntimeException being thrown in the case of a RemoteException, where previously there would not have been an exception thrown. This change could lead to different exception handling behavior when the late version of the API is invoked, which means there's a Compatibility Issue of type 2."
295,<android.net.http.HttpResponseCache: long size()>,22,23,<android.net.http.HttpResponseCache: long size()>,<android.net.http.HttpResponseCache: long size()>,0,"{
    return delegate.getSize();
}","{
    try {
        return delegate.size();
    } catch (IOException e) {
        // This can occur if the cache failed to lazily initialize.
        return -1;
    }
}",1,"/**
 * Returns the number of bytes currently being used to store the values in
 * this cache. This may be greater than the {@link #maxSize} if a background
 * deletion is pending.
 */
","/**
 * Returns the number of bytes currently being used to store the values in
 * this cache. This may be greater than the {@link #maxSize} if a background
 * deletion is pending. {@code -1} is returned if the size cannot be determined.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,5","1,2","The method that is called to get the size changed from getSize() to size(). Additionally, the late version includes exception handling which was not present in the early version. This leads to the change type of 1,2,5 because there's a return statement change, an exception handling change, and a change in the dependent API.","Because the dependent method to get the size has changed, the API could potentially return a different variable. Also, the new exception handling introduces a new behavior where an IOException results in a -1 return value. Hence, the result may be different from the early version if an exception occurs, which leads to the CI type being 1,2 for potential different return values or types and potential different exception handlings."
296,<android.app.usage.UsageStats: void add(UsageStats)>,22,23,<android.app.usage.UsageStats: void add(UsageStats)>,<android.app.usage.UsageStats: void add(UsageStats)>,0,"{
    if (!mPackageName.equals(right.mPackageName)) {
        throw new IllegalArgumentException(""Can't merge UsageStats for package '"" + mPackageName + ""' with UsageStats for package '"" + right.mPackageName + ""'."");
    }
    if (right.mEndTimeStamp > mEndTimeStamp) {
        mLastEvent = right.mLastEvent;
        mEndTimeStamp = right.mEndTimeStamp;
        mLastTimeUsed = right.mLastTimeUsed;
    }
    mBeginTimeStamp = Math.min(mBeginTimeStamp, right.mBeginTimeStamp);
    mTotalTimeInForeground += right.mTotalTimeInForeground;
    mLaunchCount += right.mLaunchCount;
}","{
    if (!mPackageName.equals(right.mPackageName)) {
        throw new IllegalArgumentException(""Can't merge UsageStats for package '"" + mPackageName + ""' with UsageStats for package '"" + right.mPackageName + ""'."");
    }
    if (right.mEndTimeStamp > mEndTimeStamp) {
        mLastEvent = right.mLastEvent;
        mEndTimeStamp = right.mEndTimeStamp;
        mLastTimeUsed = right.mLastTimeUsed;
        mBeginIdleTime = right.mBeginIdleTime;
        mLastTimeSystemUsed = right.mLastTimeSystemUsed;
    }
    mBeginTimeStamp = Math.min(mBeginTimeStamp, right.mBeginTimeStamp);
    mTotalTimeInForeground += right.mTotalTimeInForeground;
    mLaunchCount += right.mLaunchCount;
}",1,"/**
 * Add the statistics from the right {@link UsageStats} to the left. The package name for
 * both {@link UsageStats} objects must be the same.
 * @param right The {@link UsageStats} object to merge into this one.
 * @throws java.lang.IllegalArgumentException if the package names of the two
 * {@link UsageStats} objects are different.
 */
","/**
 * Add the statistics from the right {@link UsageStats} to the left. The package name for
 * both {@link UsageStats} objects must be the same.
 * @param right The {@link UsageStats} object to merge into this one.
 * @throws java.lang.IllegalArgumentException if the package names of the two
 * {@link UsageStats} objects are different.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The fields mBeginIdleTime and mLastTimeSystemUsed have been added in the if condition where right.mEndTimeStamp > mEndTimeStamp, which are assignment changes that do not fall into other specific categories mentioned above, so the code change type is 4.","The added field assignments within the if statement do not change how exceptions are thrown or how the method returns values (since there are no changes to return statements and it's a void method). The behavior of the method will change in terms of data state, but that does not affect return type or exception handling, meaning it does not lead to a Compatibility Issue as defined in the instructions. Therefore, the CI type is 0."
298,<android.os.Bundle: boolean hasFileDescriptors()>,22,23,<android.os.Bundle: boolean hasFileDescriptors()>,<android.os.Bundle: boolean hasFileDescriptors()>,0,"{
    if (!mFdsKnown) {
        // keep going until we find one or run out of data
        boolean fdFound = false;
        if (mParcelledData != null) {
            if (mParcelledData.hasFileDescriptors()) {
                fdFound = true;
            }
        } else {
            // It's been unparcelled, so we need to walk the map
            for (int i = mMap.size() - 1; i >= 0; i--) {
                Object obj = mMap.valueAt(i);
                if (obj instanceof Parcelable) {
                    if ((((Parcelable) obj).describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0) {
                        fdFound = true;
                        break;
                    }
                } else if (obj instanceof Parcelable[]) {
                    Parcelable[] array = (Parcelable[]) obj;
                    for (int n = array.length - 1; n >= 0; n--) {
                        if ((array[n].describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0) {
                            fdFound = true;
                            break;
                        }
                    }
                } else if (obj instanceof SparseArray) {
                    SparseArray<? extends Parcelable> array = (SparseArray<? extends Parcelable>) obj;
                    for (int n = array.size() - 1; n >= 0; n--) {
                        if ((array.valueAt(n).describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0) {
                            fdFound = true;
                            break;
                        }
                    }
                } else if (obj instanceof ArrayList) {
                    ArrayList array = (ArrayList) obj;
                    // Parcelables; only look inside for Parcelables
                    if (!array.isEmpty() && (array.get(0) instanceof Parcelable)) {
                        for (int n = array.size() - 1; n >= 0; n--) {
                            Parcelable p = (Parcelable) array.get(n);
                            if (p != null && ((p.describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0)) {
                                fdFound = true;
                                break;
                            }
                        }
                    }
                }
            }
        }
        mHasFds = fdFound;
        mFdsKnown = true;
    }
    return mHasFds;
}","{
    if (!mFdsKnown) {
        // keep going until we find one or run out of data
        boolean fdFound = false;
        if (mParcelledData != null) {
            if (mParcelledData.hasFileDescriptors()) {
                fdFound = true;
            }
        } else {
            // It's been unparcelled, so we need to walk the map
            for (int i = mMap.size() - 1; i >= 0; i--) {
                Object obj = mMap.valueAt(i);
                if (obj instanceof Parcelable) {
                    if ((((Parcelable) obj).describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0) {
                        fdFound = true;
                        break;
                    }
                } else if (obj instanceof Parcelable[]) {
                    Parcelable[] array = (Parcelable[]) obj;
                    for (int n = array.length - 1; n >= 0; n--) {
                        Parcelable p = array[n];
                        if (p != null && ((p.describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0)) {
                            fdFound = true;
                            break;
                        }
                    }
                } else if (obj instanceof SparseArray) {
                    SparseArray<? extends Parcelable> array = (SparseArray<? extends Parcelable>) obj;
                    for (int n = array.size() - 1; n >= 0; n--) {
                        Parcelable p = array.valueAt(n);
                        if (p != null && (p.describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0) {
                            fdFound = true;
                            break;
                        }
                    }
                } else if (obj instanceof ArrayList) {
                    ArrayList array = (ArrayList) obj;
                    // Parcelables; only look inside for Parcelables
                    if (!array.isEmpty() && (array.get(0) instanceof Parcelable)) {
                        for (int n = array.size() - 1; n >= 0; n--) {
                            Parcelable p = (Parcelable) array.get(n);
                            if (p != null && ((p.describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0)) {
                                fdFound = true;
                                break;
                            }
                        }
                    }
                }
            }
        }
        mHasFds = fdFound;
        mFdsKnown = true;
    }
    return mHasFds;
}",1,"/**
 * Reports whether the bundle contains any parcelled file descriptors.
 */
","/**
 * Reports whether the bundle contains any parcelled file descriptors.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"There is no change between the early version and the late version of the implementation, so the code change type is 0.","Since there is no change in the implementation, no compatibility issue can arise, making the CI type 0."
301,"<android.hardware.camera2.impl.CameraDeviceImpl.CameraDeviceCallbacks: void onResultReceived(CameraMetadataNative,CaptureResultExtras)>",22,23,"<android.hardware.camera2.impl.CameraDeviceImpl.CameraDeviceCallbacks: void onResultReceived(CameraMetadataNative,CaptureResultExtras)>","<android.hardware.camera2.impl.CameraDeviceImpl.CameraDeviceCallbacks: void onResultReceived(CameraMetadataNative,CaptureResultExtras)>",0,"{
    int requestId = resultExtras.getRequestId();
    long frameNumber = resultExtras.getFrameNumber();
    if (DEBUG) {
        Log.v(TAG, ""Received result frame "" + frameNumber + "" for id "" + requestId);
    }
    synchronized (mInterfaceLock) {
        // Camera already closed
        if (mRemoteDevice == null)
            return;
        // TODO: Handle CameraCharacteristics access from CaptureResult correctly.
        result.set(CameraCharacteristics.LENS_INFO_SHADING_MAP_SIZE, getCharacteristics().get(CameraCharacteristics.LENS_INFO_SHADING_MAP_SIZE));
        final CaptureCallbackHolder holder = CameraDeviceImpl.this.mCaptureCallbackMap.get(requestId);
        boolean isPartialResult = (resultExtras.getPartialResultCount() < mTotalPartialCount);
        // Check if we have a callback for this
        if (holder == null) {
            if (DEBUG) {
                Log.d(TAG, ""holder is null, early return at frame "" + frameNumber);
            }
            mFrameNumberTracker.updateTracker(frameNumber, /*result*/
            null, isPartialResult);
            return;
        }
        if (isClosed()) {
            if (DEBUG) {
                Log.d(TAG, ""camera is closed, early return at frame "" + frameNumber);
            }
            mFrameNumberTracker.updateTracker(frameNumber, /*result*/
            null, isPartialResult);
            return;
        }
        final CaptureRequest request = holder.getRequest(resultExtras.getSubsequenceId());
        Runnable resultDispatch = null;
        CaptureResult finalResult;
        // Either send a partial result or the final capture completed result
        if (isPartialResult) {
            final CaptureResult resultAsCapture = new CaptureResult(result, request, resultExtras);
            // Partial result
            resultDispatch = new Runnable() {

                @Override
                public void run() {
                    if (!CameraDeviceImpl.this.isClosed()) {
                        holder.getCallback().onCaptureProgressed(CameraDeviceImpl.this, request, resultAsCapture);
                    }
                }
            };
            finalResult = resultAsCapture;
        } else {
            List<CaptureResult> partialResults = mFrameNumberTracker.popPartialResults(frameNumber);
            final TotalCaptureResult resultAsCapture = new TotalCaptureResult(result, request, resultExtras, partialResults);
            // Final capture result
            resultDispatch = new Runnable() {

                @Override
                public void run() {
                    if (!CameraDeviceImpl.this.isClosed()) {
                        holder.getCallback().onCaptureCompleted(CameraDeviceImpl.this, request, resultAsCapture);
                    }
                }
            };
            finalResult = resultAsCapture;
        }
        holder.getHandler().post(resultDispatch);
        // Collect the partials for a total result; or mark the frame as totally completed
        mFrameNumberTracker.updateTracker(frameNumber, finalResult, isPartialResult);
        // Fire onCaptureSequenceCompleted
        if (!isPartialResult) {
            checkAndFireSequenceComplete();
        }
    }
}","{
    int requestId = resultExtras.getRequestId();
    long frameNumber = resultExtras.getFrameNumber();
    if (DEBUG) {
        Log.v(TAG, ""Received result frame "" + frameNumber + "" for id "" + requestId);
    }
    synchronized (mInterfaceLock) {
        // Camera already closed
        if (mRemoteDevice == null)
            return;
        // TODO: Handle CameraCharacteristics access from CaptureResult correctly.
        result.set(CameraCharacteristics.LENS_INFO_SHADING_MAP_SIZE, getCharacteristics().get(CameraCharacteristics.LENS_INFO_SHADING_MAP_SIZE));
        final CaptureCallbackHolder holder = CameraDeviceImpl.this.mCaptureCallbackMap.get(requestId);
        final CaptureRequest request = holder.getRequest(resultExtras.getSubsequenceId());
        boolean isPartialResult = (resultExtras.getPartialResultCount() < mTotalPartialCount);
        boolean isReprocess = request.isReprocess();
        // Check if we have a callback for this
        if (holder == null) {
            if (DEBUG) {
                Log.d(TAG, ""holder is null, early return at frame "" + frameNumber);
            }
            mFrameNumberTracker.updateTracker(frameNumber, /*result*/
            null, isPartialResult, isReprocess);
            return;
        }
        if (isClosed()) {
            if (DEBUG) {
                Log.d(TAG, ""camera is closed, early return at frame "" + frameNumber);
            }
            mFrameNumberTracker.updateTracker(frameNumber, /*result*/
            null, isPartialResult, isReprocess);
            return;
        }
        Runnable resultDispatch = null;
        CaptureResult finalResult;
        // Either send a partial result or the final capture completed result
        if (isPartialResult) {
            final CaptureResult resultAsCapture = new CaptureResult(result, request, resultExtras);
            // Partial result
            resultDispatch = new Runnable() {

                @Override
                public void run() {
                    if (!CameraDeviceImpl.this.isClosed()) {
                        holder.getCallback().onCaptureProgressed(CameraDeviceImpl.this, request, resultAsCapture);
                    }
                }
            };
            finalResult = resultAsCapture;
        } else {
            List<CaptureResult> partialResults = mFrameNumberTracker.popPartialResults(frameNumber);
            final TotalCaptureResult resultAsCapture = new TotalCaptureResult(result, request, resultExtras, partialResults, holder.getSessionId());
            // Final capture result
            resultDispatch = new Runnable() {

                @Override
                public void run() {
                    if (!CameraDeviceImpl.this.isClosed()) {
                        holder.getCallback().onCaptureCompleted(CameraDeviceImpl.this, request, resultAsCapture);
                    }
                }
            };
            finalResult = resultAsCapture;
        }
        holder.getHandler().post(resultDispatch);
        // Collect the partials for a total result; or mark the frame as totally completed
        mFrameNumberTracker.updateTracker(frameNumber, finalResult, isPartialResult, isReprocess);
        // Fire onCaptureSequenceCompleted
        if (!isPartialResult) {
            checkAndFireSequenceComplete();
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
302,"<android.text.Layout: int getOffsetForHorizontal(int,float)>",22,23,"<android.text.Layout: int getOffsetForHorizontal(int,float)>","<android.text.Layout: int getOffsetForHorizontal(int,float)>",0,"{
    int max = getLineEnd(line) - 1;
    int min = getLineStart(line);
    Directions dirs = getLineDirections(line);
    if (line == getLineCount() - 1)
        max++;
    int best = min;
    float bestdist = Math.abs(getPrimaryHorizontal(best) - horiz);
    for (int i = 0; i < dirs.mDirections.length; i += 2) {
        int here = min + dirs.mDirections[i];
        int there = here + (dirs.mDirections[i + 1] & RUN_LENGTH_MASK);
        int swap = (dirs.mDirections[i + 1] & RUN_RTL_FLAG) != 0 ? -1 : 1;
        if (there > max)
            there = max;
        int high = there - 1 + 1, low = here + 1 - 1, guess;
        while (high - low > 1) {
            guess = (high + low) / 2;
            int adguess = getOffsetAtStartOf(guess);
            if (getPrimaryHorizontal(adguess) * swap >= horiz * swap)
                high = guess;
            else
                low = guess;
        }
        if (low < here + 1)
            low = here + 1;
        if (low < there) {
            low = getOffsetAtStartOf(low);
            float dist = Math.abs(getPrimaryHorizontal(low) - horiz);
            int aft = TextUtils.getOffsetAfter(mText, low);
            if (aft < there) {
                float other = Math.abs(getPrimaryHorizontal(aft) - horiz);
                if (other < dist) {
                    dist = other;
                    low = aft;
                }
            }
            if (dist < bestdist) {
                bestdist = dist;
                best = low;
            }
        }
        float dist = Math.abs(getPrimaryHorizontal(here) - horiz);
        if (dist < bestdist) {
            bestdist = dist;
            best = here;
        }
    }
    float dist = Math.abs(getPrimaryHorizontal(max) - horiz);
    if (dist <= bestdist) {
        bestdist = dist;
        best = max;
    }
    return best;
}","{
    // TODO: use Paint.getOffsetForAdvance to avoid binary search
    int max = getLineEnd(line) - 1;
    int min = getLineStart(line);
    Directions dirs = getLineDirections(line);
    if (line == getLineCount() - 1)
        max++;
    int best = min;
    float bestdist = Math.abs(getPrimaryHorizontal(best) - horiz);
    for (int i = 0; i < dirs.mDirections.length; i += 2) {
        int here = min + dirs.mDirections[i];
        int there = here + (dirs.mDirections[i + 1] & RUN_LENGTH_MASK);
        int swap = (dirs.mDirections[i + 1] & RUN_RTL_FLAG) != 0 ? -1 : 1;
        if (there > max)
            there = max;
        int high = there - 1 + 1, low = here + 1 - 1, guess;
        while (high - low > 1) {
            guess = (high + low) / 2;
            int adguess = getOffsetAtStartOf(guess);
            if (getPrimaryHorizontal(adguess) * swap >= horiz * swap)
                high = guess;
            else
                low = guess;
        }
        if (low < here + 1)
            low = here + 1;
        if (low < there) {
            low = getOffsetAtStartOf(low);
            float dist = Math.abs(getPrimaryHorizontal(low) - horiz);
            int aft = TextUtils.getOffsetAfter(mText, low);
            if (aft < there) {
                float other = Math.abs(getPrimaryHorizontal(aft) - horiz);
                if (other < dist) {
                    dist = other;
                    low = aft;
                }
            }
            if (dist < bestdist) {
                bestdist = dist;
                best = low;
            }
        }
        float dist = Math.abs(getPrimaryHorizontal(here) - horiz);
        if (dist < bestdist) {
            bestdist = dist;
            best = here;
        }
    }
    float dist = Math.abs(getPrimaryHorizontal(max) - horiz);
    if (dist <= bestdist) {
        bestdist = dist;
        best = max;
    }
    return best;
}",1,"/**
 * Get the character offset on the specified line whose position is
 * closest to the specified horizontal position.
 */
","/**
 * Get the character offset on the specified line whose position is
 * closest to the specified horizontal position.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change in the code is the addition of a comment line (// TODO: use Paint.getOffsetForAdvance to avoid binary search). Comments do not affect the behavior or the execution of the code, so the change type is 4, which indicates it's an other statement changed classification.","Adding a comment does not introduce any compatibility issues as it does not affect how the code operates. The API's functionality and the values it returns remain the same, so no compatibility issues are detected."
307,"<android.view.View: void measure(int,int)>",22,23,"<android.view.View: void measure(int,int)>","<android.view.View: void measure(int,int)>",0,"{
    boolean optical = isLayoutModeOptical(this);
    if (optical != isLayoutModeOptical(mParent)) {
        Insets insets = getOpticalInsets();
        int oWidth = insets.left + insets.right;
        int oHeight = insets.top + insets.bottom;
        widthMeasureSpec = MeasureSpec.adjust(widthMeasureSpec, optical ? -oWidth : oWidth);
        heightMeasureSpec = MeasureSpec.adjust(heightMeasureSpec, optical ? -oHeight : oHeight);
    }
    // Suppress sign extension for the low bytes
    long key = (long) widthMeasureSpec << 32 | (long) heightMeasureSpec & 0xffffffffL;
    if (mMeasureCache == null)
        mMeasureCache = new LongSparseLongArray(2);
    final boolean forceLayout = (mPrivateFlags & PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT;
    final boolean isExactly = MeasureSpec.getMode(widthMeasureSpec) == MeasureSpec.EXACTLY && MeasureSpec.getMode(heightMeasureSpec) == MeasureSpec.EXACTLY;
    final boolean matchingSize = isExactly && getMeasuredWidth() == MeasureSpec.getSize(widthMeasureSpec) && getMeasuredHeight() == MeasureSpec.getSize(heightMeasureSpec);
    if (forceLayout || !matchingSize && (widthMeasureSpec != mOldWidthMeasureSpec || heightMeasureSpec != mOldHeightMeasureSpec)) {
        // first clears the measured dimension flag
        mPrivateFlags &= ~PFLAG_MEASURED_DIMENSION_SET;
        resolveRtlPropertiesIfNeeded();
        int cacheIndex = forceLayout ? -1 : mMeasureCache.indexOfKey(key);
        if (cacheIndex < 0 || sIgnoreMeasureCache) {
            // measure ourselves, this should set the measured dimension flag back
            onMeasure(widthMeasureSpec, heightMeasureSpec);
            mPrivateFlags3 &= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;
        } else {
            long value = mMeasureCache.valueAt(cacheIndex);
            // Casting a long to int drops the high 32 bits, no mask needed
            setMeasuredDimensionRaw((int) (value >> 32), (int) value);
            mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;
        }
        // an exception to warn the developer
        if ((mPrivateFlags & PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) {
            throw new IllegalStateException(""onMeasure() did not set the"" + "" measured dimension by calling"" + "" setMeasuredDimension()"");
        }
        mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;
    }
    mOldWidthMeasureSpec = widthMeasureSpec;
    mOldHeightMeasureSpec = heightMeasureSpec;
    mMeasureCache.put(key, ((long) mMeasuredWidth) << 32 | // suppress sign extension
    (long) mMeasuredHeight & 0xffffffffL);
}","{
    boolean optical = isLayoutModeOptical(this);
    if (optical != isLayoutModeOptical(mParent)) {
        Insets insets = getOpticalInsets();
        int oWidth = insets.left + insets.right;
        int oHeight = insets.top + insets.bottom;
        widthMeasureSpec = MeasureSpec.adjust(widthMeasureSpec, optical ? -oWidth : oWidth);
        heightMeasureSpec = MeasureSpec.adjust(heightMeasureSpec, optical ? -oHeight : oHeight);
    }
    // Suppress sign extension for the low bytes
    long key = (long) widthMeasureSpec << 32 | (long) heightMeasureSpec & 0xffffffffL;
    if (mMeasureCache == null)
        mMeasureCache = new LongSparseLongArray(2);
    if ((mPrivateFlags & PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT || widthMeasureSpec != mOldWidthMeasureSpec || heightMeasureSpec != mOldHeightMeasureSpec) {
        // first clears the measured dimension flag
        mPrivateFlags &= ~PFLAG_MEASURED_DIMENSION_SET;
        resolveRtlPropertiesIfNeeded();
        int cacheIndex = (mPrivateFlags & PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT ? -1 : mMeasureCache.indexOfKey(key);
        if (cacheIndex < 0 || sIgnoreMeasureCache) {
            // measure ourselves, this should set the measured dimension flag back
            onMeasure(widthMeasureSpec, heightMeasureSpec);
            mPrivateFlags3 &= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;
        } else {
            long value = mMeasureCache.valueAt(cacheIndex);
            // Casting a long to int drops the high 32 bits, no mask needed
            setMeasuredDimensionRaw((int) (value >> 32), (int) value);
            mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;
        }
        // an exception to warn the developer
        if ((mPrivateFlags & PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) {
            throw new IllegalStateException(""View with id "" + getId() + "": "" + getClass().getName() + ""#onMeasure() did not set the"" + "" measured dimension by calling"" + "" setMeasuredDimension()"");
        }
        mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;
    }
    mOldWidthMeasureSpec = widthMeasureSpec;
    mOldHeightMeasureSpec = heightMeasureSpec;
    mMeasureCache.put(key, ((long) mMeasuredWidth) << 32 | // suppress sign extension
    (long) mMeasuredHeight & 0xffffffffL);
}",1,"/**
 * <p>
 * This is called to find out how big a view should be. The parent
 * supplies constraint information in the width and height parameters.
 * </p>
 *
 * <p>
 * The actual measurement work of a view is performed in
 * {@link #onMeasure(int, int)}, called by this method. Therefore, only
 * {@link #onMeasure(int, int)} can and must be overridden by subclasses.
 * </p>
 *
 * @param widthMeasureSpec Horizontal space requirements as imposed by the
 * parent
 * @param heightMeasureSpec Vertical space requirements as imposed by the
 * parent
 *
 * @see #onMeasure(int, int)
 */
","/**
 * <p>
 * This is called to find out how big a view should be. The parent
 * supplies constraint information in the width and height parameters.
 * </p>
 *
 * <p>
 * The actual measurement work of a view is performed in
 * {@link #onMeasure(int, int)}, called by this method. Therefore, only
 * {@link #onMeasure(int, int)} can and must be overridden by subclasses.
 * </p>
 *
 * @param widthMeasureSpec Horizontal space requirements as imposed by the
 * parent
 * @param heightMeasureSpec Vertical space requirements as imposed by the
 * parent
 *
 * @see #onMeasure(int, int)
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
308,"<android.app.ContextImpl: void sendBroadcastAsUser(Intent,UserHandle)>",22,23,"<android.app.ContextImpl: void sendBroadcastAsUser(Intent,UserHandle)>","<android.app.ContextImpl: void sendBroadcastAsUser(Intent,UserHandle)>",0,"{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess();
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, false, false, user.getIdentifier());
    } catch (RemoteException e) {
    }
}","{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess();
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, false, user.getIdentifier());
    } catch (RemoteException e) {
        throw new RuntimeException(""Failure from system"", e);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,4",2,"The change includes the addition of a `throw new RuntimeException(""Failure from system"", e);` within the catch block for RemoteException and an update to the parameters of the method `broadcastIntent` from 'false' to 'null'. Therefore, the change types are 2 for the exception handling change and 4 for other statement changes.","The method now throws a new RuntimeException inside the catch block, which was not present in the previous version and could alter the exception handling behavior for clients, so the CI type is 2."
309,"<android.widget.Editor.HandleView: void positionAtCursorOffset(int,boolean)>",22,23,"<android.widget.Editor.HandleView: void positionAtCursorOffset(int,boolean)>","<android.widget.Editor.HandleView: void positionAtCursorOffset(int,boolean)>",0,"{
    // A HandleView relies on the layout, which may be nulled by external methods
    Layout layout = mTextView.getLayout();
    if (layout == null) {
        // Will update controllers' state, hiding them and stopping selection mode if needed
        prepareCursorControllers();
        return;
    }
    boolean offsetChanged = offset != mPreviousOffset;
    if (offsetChanged || parentScrolled) {
        if (offsetChanged) {
            updateSelection(offset);
            addPositionToTouchUpFilter(offset);
        }
        final int line = layout.getLineForOffset(offset);
        mPositionX = (int) (layout.getPrimaryHorizontal(offset) - 0.5f - mHotspotX - getHorizontalOffset() + getCursorOffset());
        mPositionY = layout.getLineBottom(line);
        // Take TextView's padding and scroll into account.
        mPositionX += mTextView.viewportToContentHorizontalOffset();
        mPositionY += mTextView.viewportToContentVerticalOffset();
        mPreviousOffset = offset;
        mPositionHasChanged = true;
    }
}","{
    // A HandleView relies on the layout, which may be nulled by external methods
    Layout layout = mTextView.getLayout();
    if (layout == null) {
        // Will update controllers' state, hiding them and stopping selection mode if needed
        prepareCursorControllers();
        return;
    }
    layout = getActiveLayout();
    boolean offsetChanged = offset != mPreviousOffset;
    if (offsetChanged || parentScrolled) {
        if (offsetChanged) {
            updateSelection(offset);
            addPositionToTouchUpFilter(offset);
        }
        final int line = layout.getLineForOffset(offset);
        mPrevLine = line;
        mPositionX = (int) (layout.getPrimaryHorizontal(offset) - 0.5f - mHotspotX - getHorizontalOffset() + getCursorOffset());
        mPositionY = layout.getLineBottom(line);
        // Take TextView's padding and scroll into account.
        mPositionX += mTextView.viewportToContentHorizontalOffset();
        mPositionY += mTextView.viewportToContentVerticalOffset();
        mPreviousOffset = offset;
        mPositionHasChanged = true;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The assignment to `layout` within the if-statement was added, and the variable `mPrevLine` is set in the late version but not the early version, so code changes are of type 3,4.","The introduction of `layout = getActiveLayout();` does not necessarily imply a behavior change since it's reassigning `layout` which would have previously been assigned by `layout = mTextView.getLayout();` if not null. It might be optimizing or ensuring to get the latest layout, but it does not inherently lead to a compatibility issue unless `getActiveLayout()` has different behavior from `mTextView.getLayout()`. The addition of `mPrevLine = line;`, if `mPrevLine` is not used to influence the behavior within this method (or it is not used to store state that affects subsequent calls to the method), would not cause a compatibility issue in itself. Since no sufficient information is provided to conclude that these changes cause a different return value or different exception handling, there is no compatibility issue."
311,"<android.speech.tts.TextToSpeechService: Set<String> onGetFeaturesForLanguage(String,String,String)>",22,23,"<android.speech.tts.TextToSpeechService: Set<String> onGetFeaturesForLanguage(String,String,String)>","<android.speech.tts.TextToSpeechService: Set<String> onGetFeaturesForLanguage(String,String,String)>",0,"{
    return null;
}","{
    return new HashSet<String>();
}",1,"/**
 * Queries the service for a set of features supported for a given language.
 *
 * Can be called on multiple threads.
 *
 * @param lang ISO-3 language code.
 * @param country ISO-3 country code. May be empty or null.
 * @param variant Language variant. May be empty or null.
 * @return A list of features supported for the given language.
 */
","/**
 * Queries the service for a set of features supported for a given language.
 *
 * Can be called on multiple threads.
 *
 * @param lang ISO-3 language code.
 * @param country ISO-3 country code. May be empty or null.
 * @param variant Language variant. May be empty or null.
 * @return A list of features supported for the given language.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement has changed from returning 'null' to returning a new instance of 'HashSet<String>()', so the code change type is 1.","Since the return value has changed from 'null' to an empty set, this can lead to a Compatibility Issue because calling code may not expect a non-null value, and thus, the behavior will be different in the newer API version. Therefore, the CI type is 1."
312,<android.content.ContentProviderClient: Uri canonicalize(Uri)>,22,23,<android.content.ContentProviderClient: Uri canonicalize(Uri)>,<android.content.ContentProviderClient: Uri canonicalize(Uri)>,0,"{
    beforeRemote();
    try {
        return mContentProvider.canonicalize(mPackageName, url);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}","{
    Preconditions.checkNotNull(url, ""url"");
    beforeRemote();
    try {
        return mContentProvider.canonicalize(mPackageName, url);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}",1,"/**
 * See {@link ContentProvider#canonicalize}
 */
","/**
 * See {@link ContentProvider#canonicalize}
 */
",-1,,[@Nullable],-1,-1,-1,-1,-1,-1,4,0,"There is an additional precondition check (Preconditions.checkNotNull(url, ""url"")) in the late implementation of the code, which is an 'Other statement changed', so the code change type is 4.","The added precondition check does not change the return value or the exception being thrown by the method directly. It may only result in an early IllegalArgumentException if 'url' is null, which is an additional check rather than a behavioral change in terms of method functionality and exception throwing. Therefore, there is no Compatibility Issue for this code change."
313,<android.os.Environment: boolean isExternalStorageEmulated()>,22,23,<android.os.Environment: boolean isExternalStorageEmulated()>,<android.os.Environment: boolean isExternalStorageEmulated()>,0,"{
    if (isStorageDisabled())
        return false;
    final File externalDir = sCurrentUser.getExternalDirsForApp()[0];
    return isExternalStorageEmulated(externalDir);
}","{
    if (isStorageDisabled())
        return false;
    final File externalDir = sCurrentUser.getExternalDirs()[0];
    return isExternalStorageEmulated(externalDir);
}",1,"/**
 * Returns whether the primary ""external"" storage device is emulated. If
 * true, data stored on this device will be stored on a portion of the
 * internal storage system.
 *
 * @see DevicePolicyManager#setStorageEncryption(android.content.ComponentName,
 * boolean)
 */
","/**
 * Returns whether the primary ""external"" storage device is emulated. If
 * true, data stored on this device will be stored on a portion of the
 * internal storage system.
 *
 * @see DevicePolicyManager#setStorageEncryption(android.content.ComponentName,
 * boolean)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation has changed by calling a different method: `getExternalDirsForApp()` in the early version and `getExternalDirs()` in the late version. This modification is not related to exception handling, return statements, or control structures, but it does involve a change in the dependent API. Thus, the code change type is 4,5.","Despite the change in the dependent API, since we do not have evidence that the method `getExternalDirs()` would return a different result when compared to `getExternalDirsForApp()`, we cannot conclusively declare that the behavior of `isExternalStorageEmulated()` would differ between the two versions. Therefore, based on the available information, we cannot assert that a compatibility issue due to a potentially different returned value exists. Hence, the CI type is 0."
315,"<android.app.admin.DevicePolicyManager: void setPasswordHistoryLength(ComponentName,int)>",22,23,"<android.app.admin.DevicePolicyManager: void setPasswordHistoryLength(ComponentName,int)>","<android.app.admin.DevicePolicyManager: void setPasswordHistoryLength(ComponentName,int)>",0,"{
    if (mService != null) {
        try {
            mService.setPasswordHistoryLength(admin, length, UserHandle.myUserId());
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    if (mService != null) {
        try {
            mService.setPasswordHistoryLength(admin, length);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}",1,"/**
 * Called by an application that is administering the device to set the length
 * of the password history. After setting this, the user will not be able to
 * enter a new password that is the same as any password in the history. Note
 * that the current password will remain until the user has set a new one, so
 * the change does not take place immediately. To prompt the user for a new
 * password, use {@link #ACTION_SET_NEW_PASSWORD} after setting this value.
 * This constraint is only imposed if the administrator has also requested
 * either {@link #PASSWORD_QUALITY_NUMERIC}, {@link #PASSWORD_QUALITY_NUMERIC_COMPLEX}
 * {@link #PASSWORD_QUALITY_ALPHABETIC}, or {@link #PASSWORD_QUALITY_ALPHANUMERIC}
 * with {@link #setPasswordQuality}.
 *
 * <p>
 * The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call this
 * method; if it has not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated
 * with.
 * @param length The new desired length of password history. A value of 0
 * means there is no restriction.
 */
","/**
 * Called by an application that is administering the device to set the length
 * of the password history. After setting this, the user will not be able to
 * enter a new password that is the same as any password in the history. Note
 * that the current password will remain until the user has set a new one, so
 * the change does not take place immediately. To prompt the user for a new
 * password, use {@link #ACTION_SET_NEW_PASSWORD} after setting this value.
 * This constraint is only imposed if the administrator has also requested
 * either {@link #PASSWORD_QUALITY_NUMERIC}, {@link #PASSWORD_QUALITY_NUMERIC_COMPLEX}
 * {@link #PASSWORD_QUALITY_ALPHABETIC}, or {@link #PASSWORD_QUALITY_ALPHANUMERIC}
 * with {@link #setPasswordQuality}.
 *
 * <p>
 * The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call this
 * method; if it has not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated
 * with.
 * @param length The new desired length of password history. A value of 0
 * means there is no restriction.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent method setPasswordHistoryLength(...) has undergone a change in its parameters. The late version no longer includes the third parameter UserHandle.myUserId(). Therefore, the code change type is 5.","Even though there's a change in the method's parameters, it doesn't necessarily lead to a compatibility issue from the perspective of this method's contract. This method's behavior from the caller's perspective remains unchanged, as it catches any RemoteExceptions. It is assumed that the internal implementation of setPasswordHistoryLength in the mService object appropriately handles the current user context without needing the explicit UserHandle.myUserId() parameter in the later version. Thus, there is no compatibility issue, and the CI type is 0."
316,"<android.app.LoaderManagerImpl.LoaderInfo: void onLoadComplete(Loader<Object>,Object)>",22,23,"<android.app.LoaderManagerImpl.LoaderInfo: void onLoadComplete(Loader<Object>,Object)>","<android.app.LoaderManagerImpl.LoaderInfo: void onLoadComplete(Loader<Object>,Object)>",0,"{
    if (DEBUG)
        Log.v(TAG, ""onLoadComplete: "" + this);
    if (mDestroyed) {
        if (DEBUG)
            Log.v(TAG, ""  Ignoring load complete -- destroyed"");
        return;
    }
    if (mLoaders.get(mId) != this) {
        // We don't care about it.
        if (DEBUG)
            Log.v(TAG, ""  Ignoring load complete -- not active"");
        return;
    }
    LoaderInfo pending = mPendingLoader;
    if (pending != null) {
        // it.  So now it is time, switch over to the new loader.
        if (DEBUG)
            Log.v(TAG, ""  Switching to pending loader: "" + pending);
        mPendingLoader = null;
        mLoaders.put(mId, null);
        destroy();
        installLoader(pending);
        return;
    }
    // we try to destroy it.
    if (mData != data || !mHaveData) {
        mData = data;
        mHaveData = true;
        if (mStarted) {
            callOnLoadFinished(loader, data);
        }
    }
    // if (DEBUG) Log.v(TAG, ""  onLoadFinished returned: "" + this);
    // We have now given the application the new loader with its
    // loaded data, so it should have stopped using the previous
    // loader.  If there is a previous loader on the inactive list,
    // clean it up.
    LoaderInfo info = mInactiveLoaders.get(mId);
    if (info != null && info != this) {
        info.mDeliveredData = false;
        info.destroy();
        mInactiveLoaders.remove(mId);
    }
    if (mActivity != null && !hasRunningLoaders()) {
        mActivity.mFragments.startPendingDeferredFragments();
    }
}","{
    if (DEBUG)
        Log.v(TAG, ""onLoadComplete: "" + this);
    if (mDestroyed) {
        if (DEBUG)
            Log.v(TAG, ""  Ignoring load complete -- destroyed"");
        return;
    }
    if (mLoaders.get(mId) != this) {
        // We don't care about it.
        if (DEBUG)
            Log.v(TAG, ""  Ignoring load complete -- not active"");
        return;
    }
    LoaderInfo pending = mPendingLoader;
    if (pending != null) {
        // it.  So now it is time, switch over to the new loader.
        if (DEBUG)
            Log.v(TAG, ""  Switching to pending loader: "" + pending);
        mPendingLoader = null;
        mLoaders.put(mId, null);
        destroy();
        installLoader(pending);
        return;
    }
    // we try to destroy it.
    if (mData != data || !mHaveData) {
        mData = data;
        mHaveData = true;
        if (mStarted) {
            callOnLoadFinished(loader, data);
        }
    }
    // if (DEBUG) Log.v(TAG, ""  onLoadFinished returned: "" + this);
    // We have now given the application the new loader with its
    // loaded data, so it should have stopped using the previous
    // loader.  If there is a previous loader on the inactive list,
    // clean it up.
    LoaderInfo info = mInactiveLoaders.get(mId);
    if (info != null && info != this) {
        info.mDeliveredData = false;
        info.destroy();
        mInactiveLoaders.remove(mId);
    }
    if (mHost != null && !hasRunningLoaders()) {
        mHost.mFragmentManager.startPendingDeferredFragments();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The only change in the code is in accessing a member variable of an object (from mActivity to mHost) and calling the same method (startPendingDeferredFragments). Because they call an identical method and nothing else in the method's logic is altered, we classify this change as type 4 (Other statement changed).","There is no Compatibility Issue because there are no changes in the control flow, exception handling, return statement, or dependent APIs that would alter the existing behavior in a way that would lead to different outcomes from the API. The change merely involves accessing a member variable that holds the same type of object, which is presumed to have the same behavior. Thus, the internal implementation change should be transparent to the users of the API."
318,<android.speech.tts.TextToSpeechService.SynthHandler: int stopAll()>,22,23,<android.speech.tts.TextToSpeechService.SynthHandler: int stopAll()>,<android.speech.tts.TextToSpeechService.SynthHandler: int stopAll()>,0,"{
    // Stop the current speech item unconditionally .
    SpeechItem current = setCurrentSpeechItem(null);
    if (current != null) {
        current.stop();
    }
    // Remove all other items from the queue.
    removeCallbacksAndMessages(null);
    // Remove all pending playback as well.
    mAudioPlaybackHandler.stop();
    return TextToSpeech.SUCCESS;
}","{
    // Order to flush pending messages
    startFlushingSpeechItems(null);
    // Stop the current speech item unconditionally .
    SpeechItem current = setCurrentSpeechItem(null);
    if (current != null) {
        current.stop();
    }
    // Remove all pending playback as well.
    mAudioPlaybackHandler.stop();
    // Message to stop flushing pending messages
    Runnable runnable = new Runnable() {

        @Override
        public void run() {
            endFlushingSpeechItems(null);
        }
    };
    sendMessage(Message.obtain(this, runnable));
    return TextToSpeech.SUCCESS;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"In the late version implementation, an additional method call startFlushingSpeechItems(null) has been added at the beginning, and an asynchronous task using sendMessage(Message.obtain(this, runnable)) to invoke endFlushingSpeechItems(null) has been introduced. However, none of the return statements and exception handling has been changed, so the code change type is 3,4.","The changes do not affect the value returned by the method (which is always TextToSpeech.SUCCESS), nor do they introduce a new exception handling statement or change the conditions under which exceptions may be thrown. Therefore, there's no Compatibility Issue, and the CI type is 0."
319,"<android.app.admin.DevicePolicyManager: void setCrossProfileCallerIdDisabled(ComponentName,boolean)>",22,23,"<android.app.admin.DevicePolicyManager: void setCrossProfileCallerIdDisabled(ComponentName,boolean)>","<android.app.admin.DevicePolicyManager: void setCrossProfileCallerIdDisabled(ComponentName,boolean)>",0,"{
    if (mService != null) {
        try {
            mService.setCrossProfileCallerIdDisabled(who, disabled);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    if (mService != null) {
        try {
            mService.setCrossProfileCallerIdDisabled(admin, disabled);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}",1,"/**
 * Called by a profile owner of a managed profile to set whether caller-Id information from
 * the managed profile will be shown in the parent profile, for incoming calls.
 *
 * <p>The calling device admin must be a profile owner. If it is not, a
 * security exception will be thrown.
 *
 * @param who Which {@link DeviceAdminReceiver} this request is associated with.
 * @param disabled If true caller-Id information in the managed profile is not displayed.
 */
","/**
 * Called by a profile owner of a managed profile to set whether caller-Id information from
 * the managed profile will be shown in the parent profile, for incoming calls.
 *
 * <p>The calling device admin must be a profile owner. If it is not, a
 * security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param disabled If true caller-Id information in the managed profile is not displayed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only difference between the early and late versions is the parameter name change from 'who' to 'admin' in the call to mService.setCrossProfileCallerIdDisabled. This is a variable name change and does not affect the method's behavior, hence the code change type is 4.",There is no compatibility issue as the change is only in the name of a parameter within the method body and does not alter the function's behavior or expected outcome.
322,"<android.text.style.LocaleSpan: void writeToParcel(Parcel,int)>",22,23,"<android.text.style.LocaleSpan: void writeToParcel(Parcel,int)>","<android.text.style.LocaleSpan: void writeToParcel(Parcel,int)>",0,"{
    dest.writeString(mLocale.getLanguage());
    dest.writeString(mLocale.getCountry());
    dest.writeString(mLocale.getVariant());
}","{
    writeToParcelInternal(dest, flags);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The late version of the method delegates all actions to ""writeToParcelInternal(dest, flags);"" rather than directly performing the parcel-writing within the method. Although the implementation detail has changed, it's an internal delegation to another method for the same class, and it's not explicit what ""writeToParcelInternal"" does. This suggests the change type is 4 due to internal logic change. The delegation also indicates a dependent API has changed (writeToParcelInternal), so it is a change type 5.","Without further context or changes in the behavior of ""writeToParcelInternal"", we cannot assume compatibility issues. The parcel writing action may still perform identically, just through a different internal method for code cleanliness or organization. There is no indication that the writeToParcel behavior visible to the caller has changed. Therefore, this is classified as no compatibility issues, 0."
323,"<android.text.method.ArrowKeyMovementMethod: boolean onTouchEvent(TextView,Spannable,MotionEvent)>",22,23,"<android.text.method.ArrowKeyMovementMethod: boolean onTouchEvent(TextView,Spannable,MotionEvent)>","<android.text.method.ArrowKeyMovementMethod: boolean onTouchEvent(TextView,Spannable,MotionEvent)>",0,"{
    int initialScrollX = -1;
    int initialScrollY = -1;
    final int action = event.getAction();
    final boolean isMouse = event.isFromSource(InputDevice.SOURCE_MOUSE);
    if (action == MotionEvent.ACTION_UP) {
        initialScrollX = Touch.getInitialScrollX(widget, buffer);
        initialScrollY = Touch.getInitialScrollY(widget, buffer);
    }
    boolean handled = Touch.onTouchEvent(widget, buffer, event);
    if (widget.isFocused() && !widget.didTouchFocusSelect()) {
        if (action == MotionEvent.ACTION_DOWN) {
            // For touch events, the code should run only when selection is active.
            if (isMouse || isTouchSelecting(isMouse, buffer)) {
                int offset = widget.getOffsetForPosition(event.getX(), event.getY());
                buffer.setSpan(LAST_TAP_DOWN, offset, offset, Spannable.SPAN_POINT_POINT);
                // Disallow intercepting of the touch events, so that
                // users can scroll and select at the same time.
                // without this, users would get booted out of select
                // mode once the view detected it needed to scroll.
                widget.getParent().requestDisallowInterceptTouchEvent(true);
            }
        } else if (action == MotionEvent.ACTION_MOVE) {
            // text selection will start from mouse pointer location.
            if (isMouse && Touch.isSelectionStarted(buffer)) {
                int offset = buffer.getSpanStart(LAST_TAP_DOWN);
                Selection.setSelection(buffer, offset);
            }
            if (isTouchSelecting(isMouse, buffer) && handled) {
                // Before selecting, make sure we've moved out of the ""slop"".
                // handled will be true, if we're in select mode AND we're
                // OUT of the slop
                // Turn long press off while we're selecting. User needs to
                // re-tap on the selection to enable long press
                widget.cancelLongPress();
                // Update selection as we're moving the selection area.
                // Get the current touch position
                int offset = widget.getOffsetForPosition(event.getX(), event.getY());
                Selection.extendSelection(buffer, offset);
                return true;
            }
        } else if (action == MotionEvent.ACTION_UP) {
            // to show it.
            if ((initialScrollY >= 0 && initialScrollY != widget.getScrollY()) || (initialScrollX >= 0 && initialScrollX != widget.getScrollX())) {
                widget.moveCursorToVisibleOffset();
                return true;
            }
            int offset = widget.getOffsetForPosition(event.getX(), event.getY());
            if (isTouchSelecting(isMouse, buffer)) {
                buffer.removeSpan(LAST_TAP_DOWN);
                Selection.extendSelection(buffer, offset);
            }
            MetaKeyKeyListener.adjustMetaAfterKeypress(buffer);
            MetaKeyKeyListener.resetLockedMeta(buffer);
            return true;
        }
    }
    return handled;
}","{
    int initialScrollX = -1;
    int initialScrollY = -1;
    final int action = event.getAction();
    final boolean isMouse = event.isFromSource(InputDevice.SOURCE_MOUSE);
    if (action == MotionEvent.ACTION_UP) {
        initialScrollX = Touch.getInitialScrollX(widget, buffer);
        initialScrollY = Touch.getInitialScrollY(widget, buffer);
    }
    boolean handled = Touch.onTouchEvent(widget, buffer, event);
    if (widget.didTouchFocusSelect() && !isMouse) {
        return handled;
    }
    if (action == MotionEvent.ACTION_DOWN) {
        // For touch events, the code should run only when selection is active.
        if (isMouse || isTouchSelecting(isMouse, buffer)) {
            if (!widget.isFocused()) {
                if (!widget.requestFocus()) {
                    return handled;
                }
            }
            int offset = widget.getOffsetForPosition(event.getX(), event.getY());
            buffer.setSpan(LAST_TAP_DOWN, offset, offset, Spannable.SPAN_POINT_POINT);
            // Disallow intercepting of the touch events, so that
            // users can scroll and select at the same time.
            // without this, users would get booted out of select
            // mode once the view detected it needed to scroll.
            widget.getParent().requestDisallowInterceptTouchEvent(true);
        }
    } else if (widget.isFocused()) {
        if (action == MotionEvent.ACTION_MOVE) {
            // text selection will start from mouse pointer location.
            if (isMouse && Touch.isSelectionStarted(buffer)) {
                int offset = buffer.getSpanStart(LAST_TAP_DOWN);
                Selection.setSelection(buffer, offset);
            }
            if (isTouchSelecting(isMouse, buffer) && handled) {
                // Before selecting, make sure we've moved out of the ""slop"".
                // handled will be true, if we're in select mode AND we're
                // OUT of the slop
                // Turn long press off while we're selecting. User needs to
                // re-tap on the selection to enable long press
                widget.cancelLongPress();
                // Update selection as we're moving the selection area.
                // Get the current touch position
                int offset = widget.getOffsetForPosition(event.getX(), event.getY());
                Selection.extendSelection(buffer, offset);
                return true;
            }
        } else if (action == MotionEvent.ACTION_UP) {
            // to show it.
            if ((initialScrollY >= 0 && initialScrollY != widget.getScrollY()) || (initialScrollX >= 0 && initialScrollX != widget.getScrollX())) {
                widget.moveCursorToVisibleOffset();
                return true;
            }
            int offset = widget.getOffsetForPosition(event.getX(), event.getY());
            if (isTouchSelecting(isMouse, buffer)) {
                buffer.removeSpan(LAST_TAP_DOWN);
                Selection.extendSelection(buffer, offset);
            }
            MetaKeyKeyListener.adjustMetaAfterKeypress(buffer);
            MetaKeyKeyListener.resetLockedMeta(buffer);
            return true;
        }
    }
    return handled;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
324,<android.text.style.QuoteSpan: int getSpanTypeId()>,22,23,<android.text.style.QuoteSpan: int getSpanTypeId()>,<android.text.style.QuoteSpan: int getSpanTypeId()>,0,"{
    return TextUtils.QUOTE_SPAN;
}","{
    return getSpanTypeIdInternal();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,5,0,"The return statement now invokes a different method `getSpanTypeIdInternal()` instead of directly returning a constant `TextUtils.QUOTE_SPAN`. This indicates a change in dependent API, making the change type 5.","There is no compatibility issue arising from this change since the method `getSpanTypeId()` is expected to return an internal identifier for the span type, and as long as the internal contract that `getSpanTypeIdInternal()` returns the correct identifier is kept, the outward behavior of the API remains the same. The result of calling `getSpanTypeId()` should be functionally identical, so the CI type is 0."
328,<android.provider.Browser: Cursor getAllBookmarks(ContentResolver)>,22,23,<android.provider.Browser: Cursor getAllBookmarks(ContentResolver)>,<android.provider.Browser: Cursor getAllBookmarks(ContentResolver)>,0,"{
    return cr.query(Bookmarks.CONTENT_URI, new String[] { Bookmarks.URL }, Bookmarks.IS_FOLDER + "" = 0"", null, null);
}","{
    return new MatrixCursor(new String[] { Bookmarks.URL }, 0);
}",1,"/**
 * Return a cursor pointing to a list of all the bookmarks. The cursor will have a single
 * column, {@link BookmarkColumns#URL}.
 * <p>
 * Requires {@link android.Manifest.permission#READ_HISTORY_BOOKMARKS}
 *
 * @param cr   The ContentResolver used to access the database.
 */
","/**
 * Return a cursor pointing to a list of all the bookmarks. The cursor will have a single
 * column, {@link BookmarkColumns#URL}.
 *
 * @param cr   The ContentResolver used to access the database.
 * @removed
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The implementation has completely changed from returning a 'Cursor' from a query on 'Bookmarks.CONTENT_URI' to now returning a new 'MatrixCursor' object with no data, so the code change type is 1.","As the return statement is changed to always return a new empty 'MatrixCursor', it potentially returns a different value from the early version, which returned a 'Cursor' with data queried from Bookmarks.CONTENT_URI. The CI type is 1."
329,<android.text.style.LeadingMarginSpan.Standard: int getSpanTypeId()>,22,23,<android.text.style.LeadingMarginSpan.Standard: int getSpanTypeId()>,<android.text.style.LeadingMarginSpan.Standard: int getSpanTypeId()>,0,"{
    return TextUtils.LEADING_MARGIN_SPAN;
}","{
    return getSpanTypeIdInternal();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method call within the return statement has changed from a direct return of a constant (TextUtils.LEADING_MARGIN_SPAN) to a call to another internal method (getSpanTypeIdInternal()), which implies a dependent API has changed, so the code change is of type 5.","There is no CI due to the change in the method call because getSpanTypeIdInternal() is expected to return the same value that was previously returned directly. The change indicates a refactoring towards using an internal method for obtaining the ID, likely without changing the behavior. Thus, the Compatibility Issue situation is 0."
330,<android.speech.tts.TextToSpeechService.SynthHandler: int stopForApp(Object)>,22,23,<android.speech.tts.TextToSpeechService.SynthHandler: int stopForApp(Object)>,<android.speech.tts.TextToSpeechService.SynthHandler: int stopForApp(Object)>,0,"{
    if (callerIdentity == null) {
        return TextToSpeech.ERROR;
    }
    removeCallbacksAndMessages(callerIdentity);
    // This stops writing data to the file / or publishing
    // items to the audio playback handler.
    // 
    // Note that the current speech item must be removed only if it
    // belongs to the callingApp, else the item will be ""orphaned"" and
    // not stopped correctly if a stop request comes along for the item
    // from the app it belongs to.
    SpeechItem current = maybeRemoveCurrentSpeechItem(callerIdentity);
    if (current != null) {
        current.stop();
    }
    // Remove any enqueued audio too.
    mAudioPlaybackHandler.stopForApp(callerIdentity);
    return TextToSpeech.SUCCESS;
}","{
    if (callerIdentity == null) {
        return TextToSpeech.ERROR;
    }
    // Flush pending messages from callerIdentity
    startFlushingSpeechItems(callerIdentity);
    // This stops writing data to the file / or publishing
    // items to the audio playback handler.
    // 
    // Note that the current speech item must be removed only if it
    // belongs to the callingApp, else the item will be ""orphaned"" and
    // not stopped correctly if a stop request comes along for the item
    // from the app it belongs to.
    SpeechItem current = maybeRemoveCurrentSpeechItem(callerIdentity);
    if (current != null) {
        current.stop();
    }
    // Remove any enqueued audio too.
    mAudioPlaybackHandler.stopForApp(callerIdentity);
    // Stop flushing pending messages
    Runnable runnable = new Runnable() {

        @Override
        public void run() {
            endFlushingSpeechItems(callerIdentity);
        }
    };
    sendMessage(Message.obtain(this, runnable));
    return TextToSpeech.SUCCESS;
}",1,"/**
 * Stops all speech output and removes any utterances still in the queue for
 * the calling app.
 *
 * Called on a service binder thread.
 */
","/**
 * Stops all speech output and removes any utterances still in the queue for
 * the calling app.
 *
 * Called on a service binder thread.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change consists of the replacement of removeCallbacksAndMessages(callerIdentity) with a different mechanism for flushing speech items (using startFlushingSpeechItems(callerIdentity) and endFlushingSpeechItems(callerIdentity)), and the addition of a message to the handler to stop flushing items. Thus, the code change type is 4.","There is no change in return statements or the exceptions thrown by the method; the behavior is essentially parallel, with a different internal implementation to achieve the same result. Therefore, there's no Compatibility Issue; the return values and exception handling remain consistent between versions."
332,<android.net.Network: URLConnection openConnection(URL)>,22,23,<android.net.Network: URLConnection openConnection(URL)>,<android.net.Network: URLConnection openConnection(URL)>,0,"{
    final ConnectivityManager cm = ConnectivityManager.getInstance();
    // TODO: Should this be optimized to avoid fetching the global proxy for every request?
    ProxyInfo proxyInfo = cm.getGlobalProxy();
    if (proxyInfo == null) {
        // TODO: Should this be optimized to avoid fetching LinkProperties for every request?
        final LinkProperties lp = cm.getLinkProperties(this);
        if (lp != null)
            proxyInfo = lp.getHttpProxy();
    }
    java.net.Proxy proxy = null;
    if (proxyInfo != null) {
        proxy = proxyInfo.makeProxy();
    } else {
        proxy = java.net.Proxy.NO_PROXY;
    }
    return openConnection(url, proxy);
}","{
    final ConnectivityManager cm = ConnectivityManager.getInstanceOrNull();
    if (cm == null) {
        throw new IOException(""No ConnectivityManager yet constructed, please construct one"");
    }
    // TODO: Should this be optimized to avoid fetching the global proxy for every request?
    final ProxyInfo proxyInfo = cm.getProxyForNetwork(this);
    java.net.Proxy proxy = null;
    if (proxyInfo != null) {
        proxy = proxyInfo.makeProxy();
    } else {
        proxy = java.net.Proxy.NO_PROXY;
    }
    return openConnection(url, proxy);
}",1,"/**
 * Opens the specified {@link URL} on this {@code Network}, such that all traffic will be sent
 * on this Network. The URL protocol must be {@code HTTP} or {@code HTTPS}.
 *
 * @return a {@code URLConnection} to the resource referred to by this URL.
 * @throws MalformedURLException if the URL protocol is not HTTP or HTTPS.
 * @throws IOException if an error occurs while opening the connection.
 * @see java.net.URL#openConnection()
 */
","/**
 * Opens the specified {@link URL} on this {@code Network}, such that all traffic will be sent
 * on this Network. The URL protocol must be {@code HTTP} or {@code HTTPS}.
 *
 * @return a {@code URLConnection} to the resource referred to by this URL.
 * @throws MalformedURLException if the URL protocol is not HTTP or HTTPS.
 * @throws IOException if an error occurs while opening the connection.
 * @see java.net.URL#openConnection()
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,5","1,2","The early implementation fetches a proxy using a two-step process involving `getGlobalProxy()` and `getLinkProperties()`. The late implementation fetches it directly using `getProxyForNetwork()`. A new `throw` statement has been introduced with `IOException` when the `ConnectivityManager` instance is null, which was not present in the early version, so the change types include exception handling (2), control dependency (3), and dependent API (5) since the method `ConnectivityManager.getInstance()` has been replaced with `ConnectivityManager.getInstanceOrNull()` and `cm.getGlobalProxy()` replaced with `cm.getProxyForNetwork(this)`.","Since the code introduces a new `throw` statement which may raise a new type of exception (`IOException`) when the `ConnectivityManager` instance is null, it may cause the late version of the API to show a different behavior by throwing an exception instead of silently failing or returning some default proxy setting. Additionally, the method `getProxyForNetwork()` could potentially return a different result than the previous combination of methods, so both return value and exception behavior might differ, resulting in types 1 and 2 for Compatibility Issues."
333,"<android.app.VoiceInteractor.AbortVoiceRequest: IVoiceInteractorRequest submit(IVoiceInteractor,String,IVoiceInteractorCallback)>",22,23,"<android.app.VoiceInteractor.AbortVoiceRequest: IVoiceInteractorRequest submit(IVoiceInteractor,String,IVoiceInteractorCallback)>","<android.app.VoiceInteractor.AbortVoiceRequest: IVoiceInteractorRequest submit(IVoiceInteractor,String,IVoiceInteractorCallback)>",0,"{
    return interactor.startAbortVoice(packageName, callback, mMessage, mExtras);
}","{
    return interactor.startAbortVoice(packageName, callback, mPrompt, mExtras);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The code change here is the replacement of one variable name in the parameter list of the method call from mMessage to mPrompt. This change indicates a change in the dependent API's expected argument (either the name or the semantics of the data it carries), hence the change type is 4,5.","Changing the argument from mMessage to mPrompt suggests that what is submitted could be different, potentially leading to different behavior when processing the voice interaction request. This difference could affect the outcome of the function, resulting in a different return value, thus leading to a CI of type 1."
334,<android.accounts.AccountManager: String getPassword(Account)>,22,23,<android.accounts.AccountManager: String getPassword(Account)>,<android.accounts.AccountManager: String getPassword(Account)>,0,"{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    try {
        return mService.getPassword(account);
    } catch (RemoteException e) {
        // will never happen
        throw new RuntimeException(e);
    }
}","{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    try {
        return mService.getPassword(account);
    } catch (RemoteException e) {
        // won't ever happen
        throw new RuntimeException(e);
    }
}",1,"/**
 * Gets the saved password associated with the account.
 * This is intended for authenticators and related code; applications
 * should get an auth token instead.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#AUTHENTICATE_ACCOUNTS}
 * and to have the same UID as the account's authenticator.
 *
 * @param account The account to query for a password
 * @return The account's password, null if none or if the account doesn't exist
 */
","/**
 * Gets the saved password associated with the account.
 * This is intended for authenticators and related code; applications
 * should get an auth token instead.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>This method requires the caller to have a signature match with the
 * authenticator that owns the specified account.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * AUTHENTICATE_ACCOUNTS permission is needed for those platforms. See docs for
 * this function in API level 22.
 *
 * @param account The account to query for a password. Must not be {@code null}.
 * @return The account's password, null if none or if the account doesn't exist
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"There is no code change other than a comment, the logic and functionality of the method remain identical between the two versions.",No Compatibility Issue because there is no actual code change that would affect the behavior of the API. Comments do not impact the execution or results of the method.
335,"<android.view.inputmethod.InputMethodManager: boolean startInputInner(IBinder,int,int,int)>",22,23,"<android.view.inputmethod.InputMethodManager: boolean startInputInner(IBinder,int,int,int)>","<android.view.inputmethod.InputMethodManager: boolean startInputInner(IBinder,int,int,int)>",0,"{
    final View view;
    synchronized (mH) {
        view = mServedView;
        // Make sure we have a window token for the served view.
        if (DEBUG)
            Log.v(TAG, ""Starting input: view="" + view);
        if (view == null) {
            if (DEBUG)
                Log.v(TAG, ""ABORT input: no served view!"");
            return false;
        }
    }
    // Now we need to get an input connection from the served view.
    // This is complicated in a couple ways: we can't be holding our lock
    // when calling out to the view, and we need to make sure we call into
    // the view on the same thread that is driving its view hierarchy.
    Handler vh = view.getHandler();
    if (vh == null) {
        // screen without a connection.
        if (DEBUG)
            Log.v(TAG, ""ABORT input: no handler for view! Close current input."");
        closeCurrentInput();
        return false;
    }
    if (vh.getLooper() != Looper.myLooper()) {
        // we need to reschedule our work for over there.
        if (DEBUG)
            Log.v(TAG, ""Starting input: reschedule to view thread"");
        vh.post(new Runnable() {

            @Override
            public void run() {
                startInputInner(null, 0, 0, 0);
            }
        });
        return false;
    }
    // Okay we are now ready to call into the served view and have it
    // do its stuff.
    // Life is good: let's hook everything up!
    EditorInfo tba = new EditorInfo();
    tba.packageName = view.getContext().getPackageName();
    tba.fieldId = view.getId();
    InputConnection ic = view.onCreateInputConnection(tba);
    if (DEBUG)
        Log.v(TAG, ""Starting input: tba="" + tba + "" ic="" + ic);
    synchronized (mH) {
        // changed.
        if (mServedView != view || !mServedConnecting) {
            // Something else happened, so abort.
            if (DEBUG)
                Log.v(TAG, ""Starting input: finished by someone else (view="" + mServedView + "" conn="" + mServedConnecting + "")"");
            return false;
        }
        // connected so we want to restart it.
        if (mCurrentTextBoxAttribute == null) {
            controlFlags |= CONTROL_START_INITIAL;
        }
        // Hook 'em up and let 'er rip.
        mCurrentTextBoxAttribute = tba;
        mServedConnecting = false;
        // Notify the served view that its previous input connection is finished
        notifyInputConnectionFinished();
        mServedInputConnection = ic;
        ControlledInputConnectionWrapper servedContext;
        if (ic != null) {
            mCursorSelStart = tba.initialSelStart;
            mCursorSelEnd = tba.initialSelEnd;
            mCursorCandStart = -1;
            mCursorCandEnd = -1;
            mCursorRect.setEmpty();
            mCursorAnchorInfo = null;
            servedContext = new ControlledInputConnectionWrapper(vh.getLooper(), ic, this);
        } else {
            servedContext = null;
        }
        if (mServedInputConnectionWrapper != null) {
            mServedInputConnectionWrapper.deactivate();
        }
        mServedInputConnectionWrapper = servedContext;
        try {
            if (DEBUG)
                Log.v(TAG, ""START INPUT: "" + view + "" ic="" + ic + "" tba="" + tba + "" controlFlags=#"" + Integer.toHexString(controlFlags));
            InputBindResult res;
            if (windowGainingFocus != null) {
                res = mService.windowGainedFocus(mClient, windowGainingFocus, controlFlags, softInputMode, windowFlags, tba, servedContext);
            } else {
                res = mService.startInput(mClient, servedContext, tba, controlFlags);
            }
            if (DEBUG)
                Log.v(TAG, ""Starting input: Bind result="" + res);
            if (res != null) {
                if (res.id != null) {
                    setInputChannelLocked(res.channel);
                    mBindSequence = res.sequence;
                    mCurMethod = res.method;
                    mCurId = res.id;
                    mNextUserActionNotificationSequenceNumber = res.userActionNotificationSequenceNumber;
                } else {
                    if (res.channel != null && res.channel != mCurChannel) {
                        res.channel.dispose();
                    }
                    if (mCurMethod == null) {
                        // This means there is no input method available.
                        if (DEBUG)
                            Log.v(TAG, ""ABORT input: no input method!"");
                        return true;
                    }
                }
            }
            if (mCurMethod != null && mCompletions != null) {
                try {
                    mCurMethod.displayCompletions(mCompletions);
                } catch (RemoteException e) {
                }
            }
        } catch (RemoteException e) {
            Log.w(TAG, ""IME died: "" + mCurId, e);
        }
    }
    return true;
}","{
    final View view;
    synchronized (mH) {
        view = mServedView;
        // Make sure we have a window token for the served view.
        if (DEBUG)
            Log.v(TAG, ""Starting input: view="" + view);
        if (view == null) {
            if (DEBUG)
                Log.v(TAG, ""ABORT input: no served view!"");
            return false;
        }
    }
    // Now we need to get an input connection from the served view.
    // This is complicated in a couple ways: we can't be holding our lock
    // when calling out to the view, and we need to make sure we call into
    // the view on the same thread that is driving its view hierarchy.
    Handler vh = view.getHandler();
    if (vh == null) {
        // screen without a connection.
        if (DEBUG)
            Log.v(TAG, ""ABORT input: no handler for view! Close current input."");
        closeCurrentInput();
        return false;
    }
    if (vh.getLooper() != Looper.myLooper()) {
        // we need to reschedule our work for over there.
        if (DEBUG)
            Log.v(TAG, ""Starting input: reschedule to view thread"");
        vh.post(new Runnable() {

            @Override
            public void run() {
                startInputInner(null, 0, 0, 0);
            }
        });
        return false;
    }
    // Okay we are now ready to call into the served view and have it
    // do its stuff.
    // Life is good: let's hook everything up!
    EditorInfo tba = new EditorInfo();
    // Note: Use Context#getOpPackageName() rather than Context#getPackageName() so that the
    // system can verify the consistency between the uid of this process and package name passed
    // from here. See comment of Context#getOpPackageName() for details.
    tba.packageName = view.getContext().getOpPackageName();
    tba.fieldId = view.getId();
    InputConnection ic = view.onCreateInputConnection(tba);
    if (DEBUG)
        Log.v(TAG, ""Starting input: tba="" + tba + "" ic="" + ic);
    synchronized (mH) {
        // changed.
        if (mServedView != view || !mServedConnecting) {
            // Something else happened, so abort.
            if (DEBUG)
                Log.v(TAG, ""Starting input: finished by someone else (view="" + mServedView + "" conn="" + mServedConnecting + "")"");
            return false;
        }
        // connected so we want to restart it.
        if (mCurrentTextBoxAttribute == null) {
            controlFlags |= CONTROL_START_INITIAL;
        }
        // Hook 'em up and let 'er rip.
        mCurrentTextBoxAttribute = tba;
        mServedConnecting = false;
        // Notify the served view that its previous input connection is finished
        notifyInputConnectionFinished();
        mServedInputConnection = ic;
        ControlledInputConnectionWrapper servedContext;
        if (ic != null) {
            mCursorSelStart = tba.initialSelStart;
            mCursorSelEnd = tba.initialSelEnd;
            mCursorCandStart = -1;
            mCursorCandEnd = -1;
            mCursorRect.setEmpty();
            mCursorAnchorInfo = null;
            servedContext = new ControlledInputConnectionWrapper(vh.getLooper(), ic, this);
        } else {
            servedContext = null;
        }
        if (mServedInputConnectionWrapper != null) {
            mServedInputConnectionWrapper.deactivate();
        }
        mServedInputConnectionWrapper = servedContext;
        try {
            if (DEBUG)
                Log.v(TAG, ""START INPUT: "" + view + "" ic="" + ic + "" tba="" + tba + "" controlFlags=#"" + Integer.toHexString(controlFlags));
            InputBindResult res;
            if (windowGainingFocus != null) {
                res = mService.windowGainedFocus(mClient, windowGainingFocus, controlFlags, softInputMode, windowFlags, tba, servedContext);
            } else {
                res = mService.startInput(mClient, servedContext, tba, controlFlags);
            }
            if (DEBUG)
                Log.v(TAG, ""Starting input: Bind result="" + res);
            if (res != null) {
                if (res.id != null) {
                    setInputChannelLocked(res.channel);
                    mBindSequence = res.sequence;
                    mCurMethod = res.method;
                    mCurId = res.id;
                    mNextUserActionNotificationSequenceNumber = res.userActionNotificationSequenceNumber;
                } else {
                    if (res.channel != null && res.channel != mCurChannel) {
                        res.channel.dispose();
                    }
                    if (mCurMethod == null) {
                        // This means there is no input method available.
                        if (DEBUG)
                            Log.v(TAG, ""ABORT input: no input method!"");
                        return true;
                    }
                }
            }
            if (mCurMethod != null && mCompletions != null) {
                try {
                    mCurMethod.displayCompletions(mCompletions);
                } catch (RemoteException e) {
                }
            }
        } catch (RemoteException e) {
            Log.w(TAG, ""IME died: "" + mCurId, e);
        }
    }
    return true;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
337,"<android.widget.Gallery: boolean onKeyDown(int,KeyEvent)>",22,23,"<android.widget.Gallery: boolean onKeyDown(int,KeyEvent)>","<android.widget.Gallery: boolean onKeyDown(int,KeyEvent)>",0,"{
    switch(keyCode) {
        case KeyEvent.KEYCODE_DPAD_LEFT:
            if (movePrevious()) {
                playSoundEffect(SoundEffectConstants.NAVIGATION_LEFT);
                return true;
            }
            break;
        case KeyEvent.KEYCODE_DPAD_RIGHT:
            if (moveNext()) {
                playSoundEffect(SoundEffectConstants.NAVIGATION_RIGHT);
                return true;
            }
            break;
        case KeyEvent.KEYCODE_DPAD_CENTER:
        case KeyEvent.KEYCODE_ENTER:
            mReceivedInvokeKeyDown = true;
    }
    return super.onKeyDown(keyCode, event);
}","{
    switch(keyCode) {
        case KeyEvent.KEYCODE_DPAD_LEFT:
            if (moveDirection(-1)) {
                playSoundEffect(SoundEffectConstants.NAVIGATION_LEFT);
                return true;
            }
            break;
        case KeyEvent.KEYCODE_DPAD_RIGHT:
            if (moveDirection(1)) {
                playSoundEffect(SoundEffectConstants.NAVIGATION_RIGHT);
                return true;
            }
            break;
        case KeyEvent.KEYCODE_DPAD_CENTER:
        case KeyEvent.KEYCODE_ENTER:
            mReceivedInvokeKeyDown = true;
    }
    return super.onKeyDown(keyCode, event);
}",1,"/**
 * Handles left, right, and clicking
 * @see android.view.View#onKeyDown
 */
","/**
 * Handles left, right, and clicking
 * @see android.view.View#onKeyDown
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,5",1,"The control dependency within the switch case for KEYCODE_DPAD_LEFT and KEYCODE_DPAD_RIGHT has been modified to use a new method moveDirection() with directional parameter instead of movePrevious() and moveNext(), also it is a change in the dependent API, so the code change type is 3,5.","As the new method moveDirection(-1) or moveDirection(1) could potentially have different implementations from movePrevious() or moveNext(), it may cause the method to return different values (either true or false), resulting in a behavioral change, therefore the CI type is 1."
340,<android.animation.ValueAnimator: boolean animationFrame(long)>,22,23,<android.animation.ValueAnimator: boolean animationFrame(long)>,<android.animation.ValueAnimator: boolean animationFrame(long)>,0,"{
    boolean done = false;
    switch(mPlayingState) {
        case RUNNING:
        case SEEKED:
            float fraction = mDuration > 0 ? (float) (currentTime - mStartTime) / mDuration : 1f;
            if (mDuration == 0 && mRepeatCount != INFINITE) {
                // Skip to the end
                mCurrentIteration = mRepeatCount;
                if (!mReversing) {
                    mPlayingBackwards = false;
                }
            }
            if (fraction >= 1f) {
                if (mCurrentIteration < mRepeatCount || mRepeatCount == INFINITE) {
                    // Time to repeat
                    if (mListeners != null) {
                        int numListeners = mListeners.size();
                        for (int i = 0; i < numListeners; ++i) {
                            mListeners.get(i).onAnimationRepeat(this);
                        }
                    }
                    if (mRepeatMode == REVERSE) {
                        mPlayingBackwards = !mPlayingBackwards;
                    }
                    mCurrentIteration += (int) fraction;
                    fraction = fraction % 1f;
                    mStartTime += mDuration;
                } else {
                    done = true;
                    fraction = Math.min(fraction, 1.0f);
                }
            }
            if (mPlayingBackwards) {
                fraction = 1f - fraction;
            }
            animateValue(fraction);
            break;
    }
    return done;
}","{
    boolean done = false;
    switch(mPlayingState) {
        case RUNNING:
        case SEEKED:
            float fraction = mDuration > 0 ? (float) (currentTime - mStartTime) / mDuration : 1f;
            if (mDuration == 0 && mRepeatCount != INFINITE) {
                // Skip to the end
                mCurrentIteration = mRepeatCount;
                if (!mReversing) {
                    mPlayingBackwards = false;
                }
            }
            if (fraction >= 1f) {
                if (mCurrentIteration < mRepeatCount || mRepeatCount == INFINITE) {
                    // Time to repeat
                    if (mListeners != null) {
                        int numListeners = mListeners.size();
                        for (int i = 0; i < numListeners; ++i) {
                            mListeners.get(i).onAnimationRepeat(this);
                        }
                    }
                    if (mRepeatMode == REVERSE) {
                        mPlayingBackwards = !mPlayingBackwards;
                    }
                    mCurrentIteration += (int) fraction;
                    fraction = fraction % 1f;
                    mStartTime += mDuration;
                // Note: We do not need to update the value of mStartTimeCommitted here
                // since we just added a duration offset.
                } else {
                    done = true;
                    fraction = Math.min(fraction, 1.0f);
                }
            }
            if (mPlayingBackwards) {
                fraction = 1f - fraction;
            }
            animateValue(fraction);
            break;
    }
    return done;
}",1,"/**
 * This internal function processes a single animation frame for a given animation. The
 * currentTime parameter is the timing pulse sent by the handler, used to calculate the
 * elapsed duration, and therefore
 * the elapsed fraction, of the animation. The return value indicates whether the animation
 * should be ended (which happens when the elapsed time of the animation exceeds the
 * animation's duration, including the repeatCount).
 *
 * @param currentTime The current time, as tracked by the static timing handler
 * @return true if the animation's duration, including any repetitions due to
 * <code>repeatCount</code>, has been exceeded and the animation should be ended.
 */
","/**
 * This internal function processes a single animation frame for a given animation. The
 * currentTime parameter is the timing pulse sent by the handler, used to calculate the
 * elapsed duration, and therefore
 * the elapsed fraction, of the animation. The return value indicates whether the animation
 * should be ended (which happens when the elapsed time of the animation exceeds the
 * animation's duration, including the repeatCount).
 *
 * @param currentTime The current time, as tracked by the static timing handler
 * @return true if the animation's duration, including any repetitions due to
 * <code>repeatCount</code>, has been exceeded and the animation should be ended.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,There is no code change between the two versions; the only difference is a comment which doesn't affect the execution flow or outcomes of the method.,"Since there is no code change, no potential Compatibility Issue could arise from this comparison."
341,<android.content.pm.LauncherActivityInfo: Drawable getIcon(int)>,22,23,<android.content.pm.LauncherActivityInfo: Drawable getIcon(int)>,<android.content.pm.LauncherActivityInfo: Drawable getIcon(int)>,0,"{
    // TODO: Use density
    return mActivityInfo.loadIcon(mPm);
}","{
    final int iconRes = mResolveInfo.getIconResource();
    Drawable icon = getDrawableForDensity(iconRes, density);
    // Get the default density icon
    if (icon == null) {
        icon = mResolveInfo.loadIcon(mPm);
    }
    return icon;
}",1,"/**
 * Returns the icon for this activity, without any badging for the profile.
 * @param density The preferred density of the icon, zero for default density. Use
 * density DPI values from {@link DisplayMetrics}.
 * @see #getBadgedIcon(int)
 * @see DisplayMetrics
 * @return The drawable associated with the activity
 */
","/**
 * Returns the icon for this activity, without any badging for the profile.
 * @param density The preferred density of the icon, zero for default density. Use
 * density DPI values from {@link DisplayMetrics}.
 * @see #getBadgedIcon(int)
 * @see DisplayMetrics
 * @return The drawable associated with the activity.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed the method of retrieving the Drawable icon, firstly attempting to obtain a density-specific drawable with getDrawableForDensity(), and falling back to mResolveInfo.loadIcon(mPm) if necessary. The code change type is 1 due to the difference in return statements, and 5 because the implementation now depends on a new method getDrawableForDensity(), which did not exist in the earlier version.","The implementation now handles different densities and attempts to load a density-specific icon, which can lead to returning a different Drawable object than the previous version. Since this can result in the method returning different values than before, the CI type is 1."
345,"<android.content.ContentResolver: Cursor query(Uri,String[],String,String[],String,CancellationSignal)>",22,23,"<android.content.ContentResolver: Cursor query(Uri,String[],String,String[],String,CancellationSignal)>","<android.content.ContentResolver: Cursor query(Uri,String[],String,String[],String,CancellationSignal)>",0,"{
    IContentProvider unstableProvider = acquireUnstableProvider(uri);
    if (unstableProvider == null) {
        return null;
    }
    IContentProvider stableProvider = null;
    Cursor qCursor = null;
    try {
        long startTime = SystemClock.uptimeMillis();
        ICancellationSignal remoteCancellationSignal = null;
        if (cancellationSignal != null) {
            cancellationSignal.throwIfCanceled();
            remoteCancellationSignal = unstableProvider.createCancellationSignal();
            cancellationSignal.setRemote(remoteCancellationSignal);
        }
        try {
            qCursor = unstableProvider.query(mPackageName, uri, projection, selection, selectionArgs, sortOrder, remoteCancellationSignal);
        } catch (DeadObjectException e) {
            // The remote process has died...  but we only hold an unstable
            // reference though, so we might recover!!!  Let's try!!!!
            // This is exciting!!1!!1!!!!1
            unstableProviderDied(unstableProvider);
            stableProvider = acquireProvider(uri);
            if (stableProvider == null) {
                return null;
            }
            qCursor = stableProvider.query(mPackageName, uri, projection, selection, selectionArgs, sortOrder, remoteCancellationSignal);
        }
        if (qCursor == null) {
            return null;
        }
        // Force query execution.  Might fail and throw a runtime exception here.
        qCursor.getCount();
        long durationMillis = SystemClock.uptimeMillis() - startTime;
        maybeLogQueryToEventLog(durationMillis, uri, projection, selection, sortOrder);
        // Wrap the cursor object into CursorWrapperInner object.
        CursorWrapperInner wrapper = new CursorWrapperInner(qCursor, stableProvider != null ? stableProvider : acquireProvider(uri));
        stableProvider = null;
        qCursor = null;
        return wrapper;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        if (qCursor != null) {
            qCursor.close();
        }
        if (cancellationSignal != null) {
            cancellationSignal.setRemote(null);
        }
        if (unstableProvider != null) {
            releaseUnstableProvider(unstableProvider);
        }
        if (stableProvider != null) {
            releaseProvider(stableProvider);
        }
    }
}","{
    Preconditions.checkNotNull(uri, ""uri"");
    IContentProvider unstableProvider = acquireUnstableProvider(uri);
    if (unstableProvider == null) {
        return null;
    }
    IContentProvider stableProvider = null;
    Cursor qCursor = null;
    try {
        long startTime = SystemClock.uptimeMillis();
        ICancellationSignal remoteCancellationSignal = null;
        if (cancellationSignal != null) {
            cancellationSignal.throwIfCanceled();
            remoteCancellationSignal = unstableProvider.createCancellationSignal();
            cancellationSignal.setRemote(remoteCancellationSignal);
        }
        try {
            qCursor = unstableProvider.query(mPackageName, uri, projection, selection, selectionArgs, sortOrder, remoteCancellationSignal);
        } catch (DeadObjectException e) {
            // The remote process has died...  but we only hold an unstable
            // reference though, so we might recover!!!  Let's try!!!!
            // This is exciting!!1!!1!!!!1
            unstableProviderDied(unstableProvider);
            stableProvider = acquireProvider(uri);
            if (stableProvider == null) {
                return null;
            }
            qCursor = stableProvider.query(mPackageName, uri, projection, selection, selectionArgs, sortOrder, remoteCancellationSignal);
        }
        if (qCursor == null) {
            return null;
        }
        // Force query execution.  Might fail and throw a runtime exception here.
        qCursor.getCount();
        long durationMillis = SystemClock.uptimeMillis() - startTime;
        maybeLogQueryToEventLog(durationMillis, uri, projection, selection, sortOrder);
        // Wrap the cursor object into CursorWrapperInner object.
        CursorWrapperInner wrapper = new CursorWrapperInner(qCursor, stableProvider != null ? stableProvider : acquireProvider(uri));
        stableProvider = null;
        qCursor = null;
        return wrapper;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        if (qCursor != null) {
            qCursor.close();
        }
        if (cancellationSignal != null) {
            cancellationSignal.setRemote(null);
        }
        if (unstableProvider != null) {
            releaseUnstableProvider(unstableProvider);
        }
        if (stableProvider != null) {
            releaseProvider(stableProvider);
        }
    }
}",1,"/**
 * Query the given URI, returning a {@link Cursor} over the result set
 * with optional support for cancellation.
 * <p>
 * For best performance, the caller should follow these guidelines:
 * <ul>
 * <li>Provide an explicit projection, to prevent
 * reading data from storage that aren't going to be used.</li>
 * <li>Use question mark parameter markers such as 'phone=?' instead of
 * explicit values in the {@code selection} parameter, so that queries
 * that differ only by those values will be recognized as the same
 * for caching purposes.</li>
 * </ul>
 * </p>
 *
 * @param uri The URI, using the content:// scheme, for the content to
 * retrieve.
 * @param projection A list of which columns to return. Passing null will
 * return all columns, which is inefficient.
 * @param selection A filter declaring which rows to return, formatted as an
 * SQL WHERE clause (excluding the WHERE itself). Passing null will
 * return all rows for the given URI.
 * @param selectionArgs You may include ?s in selection, which will be
 * replaced by the values from selectionArgs, in the order that they
 * appear in the selection. The values will be bound as Strings.
 * @param sortOrder How to order the rows, formatted as an SQL ORDER BY
 * clause (excluding the ORDER BY itself). Passing null will use the
 * default sort order, which may be unordered.
 * @param cancellationSignal A signal to cancel the operation in progress, or null if none.
 * If the operation is canceled, then {@link OperationCanceledException} will be thrown
 * when the query is executed.
 * @return A Cursor object, which is positioned before the first entry, or null
 * @see Cursor
 */
","/**
 * Query the given URI, returning a {@link Cursor} over the result set
 * with optional support for cancellation.
 * <p>
 * For best performance, the caller should follow these guidelines:
 * <ul>
 * <li>Provide an explicit projection, to prevent
 * reading data from storage that aren't going to be used.</li>
 * <li>Use question mark parameter markers such as 'phone=?' instead of
 * explicit values in the {@code selection} parameter, so that queries
 * that differ only by those values will be recognized as the same
 * for caching purposes.</li>
 * </ul>
 * </p>
 *
 * @param uri The URI, using the content:// scheme, for the content to
 * retrieve.
 * @param projection A list of which columns to return. Passing null will
 * return all columns, which is inefficient.
 * @param selection A filter declaring which rows to return, formatted as an
 * SQL WHERE clause (excluding the WHERE itself). Passing null will
 * return all rows for the given URI.
 * @param selectionArgs You may include ?s in selection, which will be
 * replaced by the values from selectionArgs, in the order that they
 * appear in the selection. The values will be bound as Strings.
 * @param sortOrder How to order the rows, formatted as an SQL ORDER BY
 * clause (excluding the ORDER BY itself). Passing null will use the
 * default sort order, which may be unordered.
 * @param cancellationSignal A signal to cancel the operation in progress, or null if none.
 * If the operation is canceled, then {@link OperationCanceledException} will be thrown
 * when the query is executed.
 * @return A Cursor object, which is positioned before the first entry, or null
 * @see Cursor
 */
",-1,,[@Nullable],-1,-1,-1,-1,-1,-1,4,0,"The code change involved in the early to late version is the addition of the precondition check (Preconditions.checkNotNull(uri, ""uri"")) at the beginning of the method. This change is an Other statement changed as it adds a check before the main logic of the method executes, but it is not a change in the return type, exception handling, or control flow dependencies.","The added precondition check only enforces that a null 'uri' cannot be passed to the method by throwing a NullPointerException if it is null. Since the early version would return null if 'uri' is null without any exception, the compatibility is maintained for valid (non-null) inputs. Therefore, there is no Compatibility Issue since it doesn't affect the behavior for non-null inputs which are expected by the method contract."
347,<android.hardware.SystemSensorManager.BaseEventQueue: boolean removeAllSensors()>,22,23,<android.hardware.SystemSensorManager.BaseEventQueue: boolean removeAllSensors()>,<android.hardware.SystemSensorManager.BaseEventQueue: boolean removeAllSensors()>,0,"{
    for (int i = 0; i < mActiveSensors.size(); i++) {
        if (mActiveSensors.valueAt(i) == true) {
            int handle = mActiveSensors.keyAt(i);
            Sensor sensor = sHandleToSensor.get(handle);
            if (sensor != null) {
                disableSensor(sensor);
                mActiveSensors.put(handle, false);
                removeSensorEvent(sensor);
            } else {
            // it should never happen -- just ignore.
            }
        }
    }
    return true;
}","{
    for (int i = 0; i < mActiveSensors.size(); i++) {
        if (mActiveSensors.valueAt(i) == true) {
            int handle = mActiveSensors.keyAt(i);
            Sensor sensor = mManager.mHandleToSensor.get(handle);
            if (sensor != null) {
                disableSensor(sensor);
                mActiveSensors.put(handle, false);
                removeSensorEvent(sensor);
            } else {
            // it should never happen -- just ignore.
            }
        }
    }
    return true;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The only change in the code is in how the Sensor object is retrieved, from a static reference sHandleToSensor to an instance reference mManager.mHandleToSensor, so the code change type is 4,5. This is a change in a dependent API because the way to access the sensor from the handle has been modified from a static variable to an instance variable within an object.",There is no Compatibility Issue associated with this change because the method's semantics have not changed. It still performs the same function and returns the same value. There is no change in the return statement or the exception thrown.
349,"<android.content.IntentSender: void sendIntent(Context,int,Intent,OnFinished,Handler,String)>",22,23,"<android.content.IntentSender: void sendIntent(Context,int,Intent,OnFinished,Handler,String)>","<android.content.IntentSender: void sendIntent(Context,int,Intent,OnFinished,Handler,String)>",0,"{
    try {
        String resolvedType = intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
        int res = mTarget.send(code, intent, resolvedType, onFinished != null ? new FinishedDispatcher(this, onFinished, handler) : null, requiredPermission);
        if (res < 0) {
            throw new SendIntentException();
        }
    } catch (RemoteException e) {
        throw new SendIntentException();
    }
}","{
    try {
        String resolvedType = intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
        int res = mTarget.send(code, intent, resolvedType, onFinished != null ? new FinishedDispatcher(this, onFinished, handler) : null, requiredPermission, null);
        if (res < 0) {
            throw new SendIntentException();
        }
    } catch (RemoteException e) {
        throw new SendIntentException();
    }
}",1,"/**
 * Perform the operation associated with this IntentSender, allowing the
 * caller to specify information about the Intent to use and be notified
 * when the send has completed.
 *
 * @param context The Context of the caller.  This may be null if
 * <var>intent</var> is also null.
 * @param code Result code to supply back to the IntentSender's target.
 * @param intent Additional Intent data.  See {@link Intent#fillIn
 * Intent.fillIn()} for information on how this is applied to the
 * original Intent.  Use null to not modify the original Intent.
 * @param onFinished The object to call back on when the send has
 * completed, or null for no callback.
 * @param handler Handler identifying the thread on which the callback
 * should happen.  If null, the callback will happen from the thread
 * pool of the process.
 * @param requiredPermission Name of permission that a recipient of the PendingIntent
 * is required to hold.  This is only valid for broadcast intents, and
 * corresponds to the permission argument in
 * {@link Context#sendBroadcast(Intent, String) Context.sendOrderedBroadcast(Intent, String)}.
 * If null, no permission is required.
 *
 * @throws SendIntentException Throws CanceledIntentException if the IntentSender
 * is no longer allowing more intents to be sent through it.
 */
","/**
 * Perform the operation associated with this IntentSender, allowing the
 * caller to specify information about the Intent to use and be notified
 * when the send has completed.
 *
 * @param context The Context of the caller.  This may be null if
 * <var>intent</var> is also null.
 * @param code Result code to supply back to the IntentSender's target.
 * @param intent Additional Intent data.  See {@link Intent#fillIn
 * Intent.fillIn()} for information on how this is applied to the
 * original Intent.  Use null to not modify the original Intent.
 * @param onFinished The object to call back on when the send has
 * completed, or null for no callback.
 * @param handler Handler identifying the thread on which the callback
 * should happen.  If null, the callback will happen from the thread
 * pool of the process.
 * @param requiredPermission Name of permission that a recipient of the PendingIntent
 * is required to hold.  This is only valid for broadcast intents, and
 * corresponds to the permission argument in
 * {@link Context#sendBroadcast(Intent, String) Context.sendOrderedBroadcast(Intent, String)}.
 * If null, no permission is required.
 *
 * @throws SendIntentException Throws CanceledIntentException if the IntentSender
 * is no longer allowing more intents to be sent through it.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,The dependent API `mTarget.send` call has received an additional parameter `null` at the end in the late version. This indicates a change in the dependency being called which falls under the category of Dependent API changed (5).,"Since the additional parameter `null` is being added to a method call, and that parameter might be for added functionality which by default does not change the previous behavior, and also there is no change in the method signature (parameter list) of `sendIntent` itself, nor in the exception thrown, we assume no compatibility issue arises from this particular change. As long as the contract of `mTarget.send` is not violated and just enhanced with an additional parameter, existing code should remain compatible. Therefore, CI is 0."
350,"<android.hardware.camera2.CameraMetadata: ArrayList<TKey> getKeysStatic(Class<?>,Class<TKey>,CameraMetadata<TKey>,int[])>",22,23,"<android.hardware.camera2.CameraMetadata: ArrayList<TKey> getKeysStatic(Class<?>,Class<TKey>,CameraMetadata<TKey>,int[])>","<android.hardware.camera2.CameraMetadata: ArrayList<TKey> getKeysStatic(Class<?>,Class<TKey>,CameraMetadata<TKey>,int[])>",0,"{
    if (VERBOSE)
        Log.v(TAG, ""getKeysStatic for "" + type);
    // TotalCaptureResult does not have any of the keys on it, use CaptureResult instead
    if (type.equals(TotalCaptureResult.class)) {
        type = CaptureResult.class;
    }
    if (filterTags != null) {
        Arrays.sort(filterTags);
    }
    ArrayList<TKey> keyList = new ArrayList<TKey>();
    Field[] fields = type.getDeclaredFields();
    for (Field field : fields) {
        // Filter for Keys that are public
        if (field.getType().isAssignableFrom(keyClass) && (field.getModifiers() & Modifier.PUBLIC) != 0) {
            TKey key;
            try {
                key = (TKey) field.get(instance);
            } catch (IllegalAccessException e) {
                throw new AssertionError(""Can't get IllegalAccessException"", e);
            } catch (IllegalArgumentException e) {
                throw new AssertionError(""Can't get IllegalArgumentException"", e);
            }
            if (instance == null || instance.getProtected(key) != null) {
                if (shouldKeyBeAdded(key, field, filterTags)) {
                    keyList.add(key);
                    if (VERBOSE) {
                        Log.v(TAG, ""getKeysStatic - key was added - "" + key);
                    }
                } else if (VERBOSE) {
                    Log.v(TAG, ""getKeysStatic - key was filtered - "" + key);
                }
            }
        }
    }
    return keyList;
}","{
    if (DEBUG)
        Log.v(TAG, ""getKeysStatic for "" + type);
    // TotalCaptureResult does not have any of the keys on it, use CaptureResult instead
    if (type.equals(TotalCaptureResult.class)) {
        type = CaptureResult.class;
    }
    if (filterTags != null) {
        Arrays.sort(filterTags);
    }
    ArrayList<TKey> keyList = new ArrayList<TKey>();
    Field[] fields = type.getDeclaredFields();
    for (Field field : fields) {
        // Filter for Keys that are public
        if (field.getType().isAssignableFrom(keyClass) && (field.getModifiers() & Modifier.PUBLIC) != 0) {
            TKey key;
            try {
                key = (TKey) field.get(instance);
            } catch (IllegalAccessException e) {
                throw new AssertionError(""Can't get IllegalAccessException"", e);
            } catch (IllegalArgumentException e) {
                throw new AssertionError(""Can't get IllegalArgumentException"", e);
            }
            if (instance == null || instance.getProtected(key) != null) {
                if (shouldKeyBeAdded(key, field, filterTags)) {
                    keyList.add(key);
                    if (DEBUG) {
                        Log.v(TAG, ""getKeysStatic - key was added - "" + key);
                    }
                } else if (DEBUG) {
                    Log.v(TAG, ""getKeysStatic - key was filtered - "" + key);
                }
            }
        }
    }
    ArrayList<TKey> vendorKeys = CameraMetadataNative.getAllVendorKeys(keyClass);
    if (vendorKeys != null) {
        for (TKey k : vendorKeys) {
            String keyName;
            if (k instanceof CaptureRequest.Key<?>) {
                keyName = ((CaptureRequest.Key<?>) k).getName();
            } else if (k instanceof CaptureResult.Key<?>) {
                keyName = ((CaptureResult.Key<?>) k).getName();
            } else if (k instanceof CameraCharacteristics.Key<?>) {
                keyName = ((CameraCharacteristics.Key<?>) k).getName();
            } else {
                continue;
            }
            if (filterTags == null || Arrays.binarySearch(filterTags, CameraMetadataNative.getTag(keyName)) >= 0) {
                keyList.add(k);
            }
        }
    }
    return keyList;
}",1,"/*package*/
","/*package*/
",-1,"[@SuppressWarnings(""unchecked"")]","[@SuppressWarnings(""unchecked"")]",-1,-1,-1,-1,-1,-1,"3,4",1,"The late version of the code adds a new block that inserts elements into `keyList` which were not present in the early version. The log statement now uses `DEBUG` instead of `VERBOSE`. Hence, the changes include a control dependency change (3) and other statements change (4).","The addition of new elements to `keyList` from `vendorKeys` is a significant change that was not part of the previous version and will cause the method to potentially return a different list of keys, so the CI is 1."
351,<android.app.ContextImpl: String[] fileList()>,22,23,<android.app.ContextImpl: String[] fileList()>,<android.app.ContextImpl: String[] fileList()>,0,"{
    final String[] list = getFilesDir().list();
    return (list != null) ? list : EMPTY_FILE_LIST;
}","{
    final String[] list = getFilesDir().list();
    return (list != null) ? list : EMPTY_STRING_ARRAY;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The code change consists of replacing EMPTY_FILE_LIST with EMPTY_STRING_ARRAY in the return statement, which is a type 1 (Return statement changed) and type 4 (Other statement changed) since it is a change of a value being returned.",The change in the return value from EMPTY_FILE_LIST to EMPTY_STRING_ARRAY can lead to a situation where the API in the later version returns a different value than the earlier version when the list is null. This constitutes a Compatibility Issue of type 1 (Compatibility Issue caused by potential different return values or types).
352,"<android.os.RecoverySystem: void installPackage(Context,File)>",22,23,"<android.os.RecoverySystem: void installPackage(Context,File)>","<android.os.RecoverySystem: void installPackage(Context,File)>",0,"{
    String filename = packageFile.getCanonicalPath();
    Log.w(TAG, ""!!! REBOOTING TO INSTALL "" + filename + "" !!!"");
    final String filenameArg = ""--update_package="" + filename;
    final String localeArg = ""--locale="" + Locale.getDefault().toString();
    bootCommand(context, filenameArg, localeArg);
}","{
    String filename = packageFile.getCanonicalPath();
    FileWriter uncryptFile = new FileWriter(UNCRYPT_FILE);
    try {
        uncryptFile.write(filename + ""\n"");
    } finally {
        uncryptFile.close();
    }
    Log.w(TAG, ""!!! REBOOTING TO INSTALL "" + filename + "" !!!"");
    // into COMMAND_FILE instead.
    if (filename.startsWith(""/data/"")) {
        filename = ""@/cache/recovery/block.map"";
    }
    final String filenameArg = ""--update_package="" + filename;
    final String localeArg = ""--locale="" + Locale.getDefault().toString();
    bootCommand(context, filenameArg, localeArg);
}",1,"/**
 * Reboots the device in order to install the given update
 * package.
 * Requires the {@link android.Manifest.permission#REBOOT} permission.
 *
 * @param context      the Context to use
 * @param packageFile  the update package to install.  Must be on
 * a partition mountable by recovery.  (The set of partitions
 * known to recovery may vary from device to device.  Generally,
 * /cache and /data are safe.)
 *
 * @throws IOException  if writing the recovery command file
 * fails, or if the reboot itself fails.
 */
","/**
 * Reboots the device in order to install the given update
 * package.
 * Requires the {@link android.Manifest.permission#REBOOT} permission.
 *
 * @param context      the Context to use
 * @param packageFile  the update package to install.  Must be on
 * a partition mountable by recovery.  (The set of partitions
 * known to recovery may vary from device to device.  Generally,
 * /cache and /data are safe.)
 *
 * @throws IOException  if writing the recovery command file
 * fails, or if the reboot itself fails.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4","1,2",The late implementation has introduced the use of a FileWriter and a conditional block to modify the filename under certain conditions. These changes are classified both as a control dependency change (3) due to the added if statement and as other statement changed (4) due to the manipulation of the FileWriter and the filename variable.,"There's a CI caused by potential different return values or types (1) since the modified filename can affect the behavior of bootCommand, potentially changing the outcome of the method execution. Also, there's a CI caused by potential different exception handlings (2) because the new implementation introduces file operations that can throw IOException, which was not present in the early version and are not handled inside this method."
353,<android.content.ContentProviderClient: Uri uncanonicalize(Uri)>,22,23,<android.content.ContentProviderClient: Uri uncanonicalize(Uri)>,<android.content.ContentProviderClient: Uri uncanonicalize(Uri)>,0,"{
    beforeRemote();
    try {
        return mContentProvider.uncanonicalize(mPackageName, url);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}","{
    Preconditions.checkNotNull(url, ""url"");
    beforeRemote();
    try {
        return mContentProvider.uncanonicalize(mPackageName, url);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}",1,"/**
 * See {@link ContentProvider#uncanonicalize}
 */
","/**
 * See {@link ContentProvider#uncanonicalize}
 */
",-1,,[@Nullable],-1,-1,-1,-1,-1,-1,4,0,"An additional check (Preconditions.checkNotNull(url, ""url"")) is added at the beginning of the method to ensure that the 'url' argument isn't null. Therefore, the type of change is 4 (Other statement changed).","This additional precondition check will not cause a Compatibility Issue as it validates the input before the actual business logic of the method starts; so it doesn't alter the behavior in case of valid input but rather ensures that invalid input (null 'url') is caught earlier. Thus, the addition of this precondition does not lead to a different value being returned or a different exception being thrown than would occur otherwise during the execution; the outcome will be the same, albeit an `IllegalArgumentException` might be thrown earlier."
354,"<android.app.ContextImpl: Context createApplicationContext(ApplicationInfo,int)>",22,23,"<android.app.ContextImpl: Context createApplicationContext(ApplicationInfo,int)>","<android.app.ContextImpl: Context createApplicationContext(ApplicationInfo,int)>",0,"{
    LoadedApk pi = mMainThread.getPackageInfo(application, mResources.getCompatibilityInfo(), flags | CONTEXT_REGISTER_PACKAGE);
    if (pi != null) {
        final boolean restricted = (flags & CONTEXT_RESTRICTED) == CONTEXT_RESTRICTED;
        ContextImpl c = new ContextImpl(this, mMainThread, pi, mActivityToken, new UserHandle(UserHandle.getUserId(application.uid)), restricted, mDisplay, mOverrideConfiguration);
        if (c.mResources != null) {
            return c;
        }
    }
    throw new PackageManager.NameNotFoundException(""Application package "" + application.packageName + "" not found"");
}","{
    LoadedApk pi = mMainThread.getPackageInfo(application, mResources.getCompatibilityInfo(), flags | CONTEXT_REGISTER_PACKAGE);
    if (pi != null) {
        final boolean restricted = (flags & CONTEXT_RESTRICTED) == CONTEXT_RESTRICTED;
        ContextImpl c = new ContextImpl(this, mMainThread, pi, mActivityToken, new UserHandle(UserHandle.getUserId(application.uid)), restricted, mDisplay, null, Display.INVALID_DISPLAY);
        if (c.mResources != null) {
            return c;
        }
    }
    throw new PackageManager.NameNotFoundException(""Application package "" + application.packageName + "" not found"");
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The change is in the instantiation of a new ContextImpl object where the constructor parameters have changed, replacing the 'mOverrideConfiguration' parameter with 'null' and adding 'Display.INVALID_DISPLAY' as the new parameter. Considering the method's signature did not change, and the implementation still ensures that the context returned fulfills the same contract (no changes in return statements or exception handling), the adjustment seems to ensure internal consistency with updated context configuration. Therefore, the change type is 4.","There is no Compatibility Issue because the returned type is the same (Context) and the function contract is preserved (still throws a PackageManager.NameNotFoundException on error). The API user would not experience a change in API behavior due to these internal adjustments as long as the returned context meets the requirements of the API specification. Thus, there's no CI, hence 0."
355,"<android.app.ApplicationPackageManager: Drawable getDrawable(String,int,ApplicationInfo)>",22,23,"<android.app.ApplicationPackageManager: Drawable getDrawable(String,int,ApplicationInfo)>","<android.app.ApplicationPackageManager: Drawable getDrawable(String,int,ApplicationInfo)>",0,"{
    ResourceName name = new ResourceName(packageName, resid);
    Drawable dr = getCachedIcon(name);
    if (dr != null) {
        return dr;
    }
    if (appInfo == null) {
        try {
            appInfo = getApplicationInfo(packageName, sDefaultFlags);
        } catch (NameNotFoundException e) {
            return null;
        }
    }
    try {
        Resources r = getResourcesForApplication(appInfo);
        dr = r.getDrawable(resid);
        if (false) {
            RuntimeException e = new RuntimeException(""here"");
            e.fillInStackTrace();
            Log.w(TAG, ""Getting drawable 0x"" + Integer.toHexString(resid) + "" from package "" + packageName + "": app scale="" + r.getCompatibilityInfo().applicationScale + "", caller scale="" + mContext.getResources().getCompatibilityInfo().applicationScale, e);
        }
        if (DEBUG_ICONS)
            Log.v(TAG, ""Getting drawable 0x"" + Integer.toHexString(resid) + "" from "" + r + "": "" + dr);
        putCachedIcon(name, dr);
        return dr;
    } catch (NameNotFoundException e) {
        Log.w(""PackageManager"", ""Failure retrieving resources for "" + appInfo.packageName);
    } catch (Resources.NotFoundException e) {
        Log.w(""PackageManager"", ""Failure retrieving resources for "" + appInfo.packageName + "": "" + e.getMessage());
    } catch (RuntimeException e) {
        // If an exception was thrown, fall through to return
        // default icon.
        Log.w(""PackageManager"", ""Failure retrieving icon 0x"" + Integer.toHexString(resid) + "" in package "" + packageName, e);
    }
    return null;
}","{
    final ResourceName name = new ResourceName(packageName, resId);
    final Drawable cachedIcon = getCachedIcon(name);
    if (cachedIcon != null) {
        return cachedIcon;
    }
    if (appInfo == null) {
        try {
            appInfo = getApplicationInfo(packageName, sDefaultFlags);
        } catch (NameNotFoundException e) {
            return null;
        }
    }
    if (resId != 0) {
        try {
            final Resources r = getResourcesForApplication(appInfo);
            final Drawable dr = r.getDrawable(resId, null);
            if (dr != null) {
                putCachedIcon(name, dr);
            }
            if (false) {
                RuntimeException e = new RuntimeException(""here"");
                e.fillInStackTrace();
                Log.w(TAG, ""Getting drawable 0x"" + Integer.toHexString(resId) + "" from package "" + packageName + "": app scale="" + r.getCompatibilityInfo().applicationScale + "", caller scale="" + mContext.getResources().getCompatibilityInfo().applicationScale, e);
            }
            if (DEBUG_ICONS) {
                Log.v(TAG, ""Getting drawable 0x"" + Integer.toHexString(resId) + "" from "" + r + "": "" + dr);
            }
            return dr;
        } catch (NameNotFoundException e) {
            Log.w(""PackageManager"", ""Failure retrieving resources for "" + appInfo.packageName);
        } catch (Resources.NotFoundException e) {
            Log.w(""PackageManager"", ""Failure retrieving resources for "" + appInfo.packageName + "": "" + e.getMessage());
        } catch (Exception e) {
            // If an exception was thrown, fall through to return
            // default icon.
            Log.w(""PackageManager"", ""Failure retrieving icon 0x"" + Integer.toHexString(resId) + "" in package "" + packageName, e);
        }
    }
    return null;
}",1,,,-1,[@Override],"[@Nullable, @Override]",-1,-1,-1,-1,-1,-1,"1,3,4,5",1,The changes include:,- The variable 'resid' has been renamed to 'resId' (case change).
356,<android.bluetooth.le.ScanSettings.Builder: Builder setScanMode(int)>,22,23,<android.bluetooth.le.ScanSettings.Builder: Builder setScanMode(int)>,<android.bluetooth.le.ScanSettings.Builder: Builder setScanMode(int)>,0,"{
    if (scanMode < SCAN_MODE_LOW_POWER || scanMode > SCAN_MODE_LOW_LATENCY) {
        throw new IllegalArgumentException(""invalid scan mode "" + scanMode);
    }
    mScanMode = scanMode;
    return this;
}","{
    if (scanMode < SCAN_MODE_OPPORTUNISTIC || scanMode > SCAN_MODE_LOW_LATENCY) {
        throw new IllegalArgumentException(""invalid scan mode "" + scanMode);
    }
    mScanMode = scanMode;
    return this;
}",1,"/**
 * Set scan mode for Bluetooth LE scan.
 *
 * @param scanMode The scan mode can be one of {@link ScanSettings#SCAN_MODE_LOW_POWER},
 * {@link ScanSettings#SCAN_MODE_BALANCED} or
 * {@link ScanSettings#SCAN_MODE_LOW_LATENCY}.
 * @throws IllegalArgumentException If the {@code scanMode} is invalid.
 */
","/**
 * Set scan mode for Bluetooth LE scan.
 *
 * @param scanMode The scan mode can be one of {@link ScanSettings#SCAN_MODE_LOW_POWER},
 * {@link ScanSettings#SCAN_MODE_BALANCED} or
 * {@link ScanSettings#SCAN_MODE_LOW_LATENCY}.
 * @throws IllegalArgumentException If the {@code scanMode} is invalid.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,5",1,"The lower bound check in the if condition statement has changed from SCAN_MODE_LOW_POWER to SCAN_MODE_OPPORTUNISTIC. This means there's a change in the control dependency and also a dependent API change because the constant `SCAN_MODE_OPPORTUNISTIC` must have been introduced or altered in the API in the later version, hence the code change types are 3,5.","The change in the boundary condition for the scan mode can lead to this method accepting different values for `scanMode` than it did previously, which changes the behavior of the API. This may lead to the API allowing different scan modes to pass through without throwing an IllegalArgumentException, which in the prior version would have resulted in an exception. Thus, a Compatibility Issue of type 1 (different return values or types) can arise."
357,<android.bluetooth.BluetoothDevice: boolean fetchUuidsWithSdp()>,22,23,<android.bluetooth.BluetoothDevice: boolean fetchUuidsWithSdp()>,<android.bluetooth.BluetoothDevice: boolean fetchUuidsWithSdp()>,0,"{
    IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, ""BT not enabled. Cannot fetchUuidsWithSdp"");
        return false;
    }
    try {
        return service.fetchRemoteUuids(this);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}","{
    IBluetooth service = sService;
    if (service == null || isBluetoothEnabled() == false) {
        Log.e(TAG, ""BT not enabled. Cannot fetchUuidsWithSdp"");
        return false;
    }
    try {
        return service.fetchRemoteUuids(this);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}",1,"/**
 * Perform a service discovery on the remote device to get the UUIDs supported.
 *
 * <p>This API is asynchronous and {@link #ACTION_UUID} intent is sent,
 * with the UUIDs supported by the remote end. If there is an error
 * in getting the SDP records or if the process takes a long time,
 * {@link #ACTION_UUID} intent is sent with the UUIDs that is currently
 * present in the cache. Clients should use the {@link #getUuids} to get UUIDs
 * if service discovery is not to be performed.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}.
 *
 * @return False if the sanity check fails, True if the process
 * of initiating an ACL connection to the remote device
 * was started.
 */
","/**
 * Perform a service discovery on the remote device to get the UUIDs supported.
 *
 * <p>This API is asynchronous and {@link #ACTION_UUID} intent is sent,
 * with the UUIDs supported by the remote end. If there is an error
 * in getting the SDP records or if the process takes a long time,
 * {@link #ACTION_UUID} intent is sent with the UUIDs that is currently
 * present in the cache. Clients should use the {@link #getUuids} to get UUIDs
 * if service discovery is not to be performed.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}.
 *
 * @return False if the sanity check fails, True if the process
 * of initiating an ACL connection to the remote device
 * was started.
 */
",-1,,[@RequiresPermission(Manifest.permission.BLUETOOTH)],-1,-1,-1,-1,-1,-1,3,0,"An additional condition has been added to the if statement: ""isBluetoothEnabled() == false"". This adds another control flow case where the method would return false, representing a change in a control dependency.","Despite the change in the control flow, the overall behavior of the method in terms of the return value or exception thrown has not changed from the perspective of a program using this API. It still returns false when the service is not available or when Bluetooth is not enabled. As such, there is no compatibility issue introduced by this change."
358,"<android.bluetooth.BluetoothSocket: int read(byte[],int,int)>",22,23,"<android.bluetooth.BluetoothSocket: int read(byte[],int,int)>","<android.bluetooth.BluetoothSocket: int read(byte[],int,int)>",0,"{
    if (mSocketIS == null)
        throw new IOException(""read is called on null InputStream"");
    if (VDBG)
        Log.d(TAG, ""read in:  "" + mSocketIS + "" len: "" + length);
    int ret = mSocketIS.read(b, offset, length);
    if (ret < 0)
        throw new IOException(""bt socket closed, read return: "" + ret);
    if (VDBG)
        Log.d(TAG, ""read out:  "" + mSocketIS + "" ret: "" + ret);
    return ret;
}","{
    int ret = 0;
    if (VDBG)
        Log.d(TAG, ""read in:  "" + mSocketIS + "" len: "" + length);
    if (mType == TYPE_L2CAP) {
        int bytesToRead = length;
        if (VDBG)
            Log.v(TAG, ""l2cap: read(): offset: "" + offset + "" length:"" + length + ""mL2capBuffer= "" + mL2capBuffer);
        if (mL2capBuffer == null) {
            createL2capRxBuffer();
        }
        if (mL2capBuffer.remaining() == 0) {
            if (VDBG)
                Log.v(TAG, ""l2cap buffer empty, refilling..."");
            if (fillL2capRxBuffer() == -1) {
                return -1;
            }
        }
        if (bytesToRead > mL2capBuffer.remaining()) {
            bytesToRead = mL2capBuffer.remaining();
        }
        if (VDBG)
            Log.v(TAG, ""get(): offset: "" + offset + "" bytesToRead: "" + bytesToRead);
        mL2capBuffer.get(b, offset, bytesToRead);
        ret = bytesToRead;
    } else {
        if (VDBG)
            Log.v(TAG, ""default: read(): offset: "" + offset + "" length:"" + length);
        ret = mSocketIS.read(b, offset, length);
    }
    if (ret < 0)
        throw new IOException(""bt socket closed, read return: "" + ret);
    if (VDBG)
        Log.d(TAG, ""read out:  "" + mSocketIS + "" ret: "" + ret);
    return ret;
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,"3,4","1,2","The control dependency has changed because a new condition (if mType == TYPE_L2CAP) is introduced, alongside new variable initialization and method calls (createL2capRxBuffer(), fillL2capRxBuffer()), which influence how the returned value is calculated. As a result, the code change types are 3 (control dependency change) and 4 (other statement changed).","Due to the added control statement which introduces a new code path for certain conditions (when mType is TYPE_L2CAP), there are new situations where a different value may be returned or a different exception handling could occur. The introduction of a possible return of -1 when fillL2capRxBuffer() returns -1, and the usage of mL2capBuffer, which did not previously exist, could cause different outcomes. Therefore, CI types are 1 (Compatibility Issue caused by potential different return values or types) and 2 (Compatibility Issue caused by potential different exception handlings)."
359,"<android.hardware.camera2.params.StreamConfigurationMap: long getOutputMinFrameDuration(Class<T>,Size)>",22,23,"<android.hardware.camera2.params.StreamConfigurationMap: long getOutputMinFrameDuration(Class<T>,Size)>","<android.hardware.camera2.params.StreamConfigurationMap: long getOutputMinFrameDuration(Class<T>,Size)>",0,"{
    if (!isOutputSupportedFor(klass)) {
        throw new IllegalArgumentException(""klass was not supported"");
    }
    return getInternalFormatDuration(HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED, size, DURATION_MIN_FRAME);
}","{
    if (!isOutputSupportedFor(klass)) {
        throw new IllegalArgumentException(""klass was not supported"");
    }
    return getInternalFormatDuration(HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED, HAL_DATASPACE_UNKNOWN, size, DURATION_MIN_FRAME);
}",1,"/**
 * Get the minimum {@link CaptureRequest#SENSOR_FRAME_DURATION frame duration}
 * for the class/size combination (in nanoseconds).
 *
 * <p>This assumes a the {@code klass} is set up to use an implementation-defined format.
 * For user-defined formats, use {@link #getOutputMinFrameDuration(int, Size)}.</p>
 *
 * <p>{@code klass} should be one of the ones which is supported by
 * {@link #isOutputSupportedFor(Class)}.</p>
 *
 * <p>{@code size} should be one of the ones returned by
 * {@link #getOutputSizes(int)}.</p>
 *
 * <p>This should correspond to the frame duration when only that stream is active, with all
 * processing (typically in {@code android.*.mode}) set to either {@code OFF} or {@code FAST}.
 * </p>
 *
 * <p>When multiple streams are used in a request, the minimum frame duration will be
 * {@code max(individual stream min durations)}.</p>
 *
 * <p>For devices that do not support manual sensor control
 * ({@link android.hardware.camera2.CameraMetadata#REQUEST_AVAILABLE_CAPABILITIES_MANUAL_SENSOR}),
 * this function may return 0.</p>
 *
 * <!--
 * TODO: uncomment after adding input stream support
 * <p>The minimum frame duration of a stream (of a particular format, size) is the same
 * regardless of whether the stream is input or output.</p>
 * -->
 *
 * @param klass
 * a class which is supported by {@link #isOutputSupportedFor(Class)} and has a
 * non-empty array returned by {@link #getOutputSizes(Class)}
 * @param size an output-compatible size
 * @return a minimum frame duration {@code >} 0 in nanoseconds, or
 * 0 if the minimum frame duration is not available.
 *
 * @throws IllegalArgumentException if {@code klass} or {@code size} was not supported
 * @throws NullPointerException if {@code size} or {@code klass} was {@code null}
 *
 * @see CaptureRequest#SENSOR_FRAME_DURATION
 * @see ImageFormat
 * @see PixelFormat
 */
","/**
 * Get the minimum {@link CaptureRequest#SENSOR_FRAME_DURATION frame duration}
 * for the class/size combination (in nanoseconds).
 *
 * <p>This assumes a the {@code klass} is set up to use {@link ImageFormat#PRIVATE}.
 * For user-defined formats, use {@link #getOutputMinFrameDuration(int, Size)}.</p>
 *
 * <p>{@code klass} should be one of the ones which is supported by
 * {@link #isOutputSupportedFor(Class)}.</p>
 *
 * <p>{@code size} should be one of the ones returned by
 * {@link #getOutputSizes(int)}.</p>
 *
 * <p>This should correspond to the frame duration when only that stream is active, with all
 * processing (typically in {@code android.*.mode}) set to either {@code OFF} or {@code FAST}.
 * </p>
 *
 * <p>When multiple streams are used in a request, the minimum frame duration will be
 * {@code max(individual stream min durations)}.</p>
 *
 * <p>For devices that do not support manual sensor control
 * ({@link android.hardware.camera2.CameraMetadata#REQUEST_AVAILABLE_CAPABILITIES_MANUAL_SENSOR}),
 * this function may return 0.</p>
 *
 * <!--
 * TODO: uncomment after adding input stream support
 * <p>The minimum frame duration of a stream (of a particular format, size) is the same
 * regardless of whether the stream is input or output.</p>
 * -->
 *
 * @param klass
 * a class which is supported by {@link #isOutputSupportedFor(Class)} and has a
 * non-empty array returned by {@link #getOutputSizes(Class)}
 * @param size an output-compatible size
 * @return a minimum frame duration {@code >} 0 in nanoseconds, or
 * 0 if the minimum frame duration is not available.
 *
 * @throws IllegalArgumentException if {@code klass} or {@code size} was not supported
 * @throws NullPointerException if {@code size} or {@code klass} was {@code null}
 *
 * @see CaptureRequest#SENSOR_FRAME_DURATION
 * @see ImageFormat
 * @see PixelFormat
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method getInternalFormatDuration has an additional parameter added in the late version (HAL_DATASPACE_UNKNOWN), which indicates that the dependent API has changed, so the code change type is 5.","There is no Compatibility Issue regarding the return value or exception handling, since the additional parameter does not change the method's behavior from the caller's perspective, assuming the behavior of getInternalFormatDuration internals correctly handles the extra argument. Thus the CI type is 0."
360,"<android.content.ContentResolver: int bulkInsert(Uri,ContentValues[])>",22,23,"<android.content.ContentResolver: int bulkInsert(Uri,ContentValues[])>","<android.content.ContentResolver: int bulkInsert(Uri,ContentValues[])>",0,"{
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        throw new IllegalArgumentException(""Unknown URL "" + url);
    }
    try {
        long startTime = SystemClock.uptimeMillis();
        int rowsCreated = provider.bulkInsert(mPackageName, url, values);
        long durationMillis = SystemClock.uptimeMillis() - startTime;
        maybeLogUpdateToEventLog(durationMillis, url, ""bulkinsert"", null);
        return rowsCreated;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return 0;
    } finally {
        releaseProvider(provider);
    }
}","{
    Preconditions.checkNotNull(url, ""url"");
    Preconditions.checkNotNull(values, ""values"");
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        throw new IllegalArgumentException(""Unknown URL "" + url);
    }
    try {
        long startTime = SystemClock.uptimeMillis();
        int rowsCreated = provider.bulkInsert(mPackageName, url, values);
        long durationMillis = SystemClock.uptimeMillis() - startTime;
        maybeLogUpdateToEventLog(durationMillis, url, ""bulkinsert"", null);
        return rowsCreated;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return 0;
    } finally {
        releaseProvider(provider);
    }
}",1,"/**
 * Inserts multiple rows into a table at the given URL.
 *
 * This function make no guarantees about the atomicity of the insertions.
 *
 * @param url The URL of the table to insert into.
 * @param values The initial values for the newly inserted rows. The key is the column name for
 * the field. Passing null will create an empty row.
 * @return the number of newly created rows.
 */
","/**
 * Inserts multiple rows into a table at the given URL.
 *
 * This function make no guarantees about the atomicity of the insertions.
 *
 * @param url The URL of the table to insert into.
 * @param values The initial values for the newly inserted rows. The key is the column name for
 * the field. Passing null will create an empty row.
 * @return the number of newly created rows.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"Two new checkNotNull validations for the parameters 'url' and 'values' have been added, so there is an 'Other statement changed', which is change type 4.","The newly added checkNotNull validations will not cause a Compatibility Issue, as they simply validate the non-nullity of method parameters which should have always been non-null according to previous method contract. Any compliant calling code would not pass null values for these parameters, and hence the behavior of the method is unchanged for compliant calling code. Therefore, there's no Compatibility Issue, which is CI type 0."
361,<android.service.voice.VoiceInteractionSession: void finish()>,22,23,<android.service.voice.VoiceInteractionSession: void finish()>,<android.service.voice.VoiceInteractionSession: void finish()>,0,"{
    if (mToken == null) {
        throw new IllegalStateException(""Can't call before onCreate()"");
    }
    hideWindow();
    try {
        mSystemService.finish(mToken);
    } catch (RemoteException e) {
    }
}","{
    if (mToken == null) {
        throw new IllegalStateException(""Can't call before onCreate()"");
    }
    try {
        mSystemService.finish(mToken);
    } catch (RemoteException e) {
    }
}",1,"/**
 * Finish the session.
 */
","/**
 * Finish the session.  This completely destroys the session -- the next time it is shown,
 * an entirely new one will be created.  You do not normally call this function; instead,
 * use {@link #hide} and allow the system to destroy your session if it needs its RAM.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The call to hideWindow() has been removed in the late version implementation, which does not affect the return type or exception handling of the method; hence, the change type is 4.","There is no compatibility issue because the removal of hideWindow() does not alter what the finish() method returns nor does it change what exceptions it may throw. The method's signature and exception handling remain unchanged, so its behavior from the API consumer's perspective should be consistent between versions."
362,<android.view.MotionEvent: String actionToString(int)>,22,23,<android.view.MotionEvent: String actionToString(int)>,<android.view.MotionEvent: String actionToString(int)>,0,"{
    switch(action) {
        case ACTION_DOWN:
            return ""ACTION_DOWN"";
        case ACTION_UP:
            return ""ACTION_UP"";
        case ACTION_CANCEL:
            return ""ACTION_CANCEL"";
        case ACTION_OUTSIDE:
            return ""ACTION_OUTSIDE"";
        case ACTION_MOVE:
            return ""ACTION_MOVE"";
        case ACTION_HOVER_MOVE:
            return ""ACTION_HOVER_MOVE"";
        case ACTION_SCROLL:
            return ""ACTION_SCROLL"";
        case ACTION_HOVER_ENTER:
            return ""ACTION_HOVER_ENTER"";
        case ACTION_HOVER_EXIT:
            return ""ACTION_HOVER_EXIT"";
    }
    int index = (action & ACTION_POINTER_INDEX_MASK) >> ACTION_POINTER_INDEX_SHIFT;
    switch(action & ACTION_MASK) {
        case ACTION_POINTER_DOWN:
            return ""ACTION_POINTER_DOWN("" + index + "")"";
        case ACTION_POINTER_UP:
            return ""ACTION_POINTER_UP("" + index + "")"";
        default:
            return Integer.toString(action);
    }
}","{
    switch(action) {
        case ACTION_DOWN:
            return ""ACTION_DOWN"";
        case ACTION_UP:
            return ""ACTION_UP"";
        case ACTION_CANCEL:
            return ""ACTION_CANCEL"";
        case ACTION_OUTSIDE:
            return ""ACTION_OUTSIDE"";
        case ACTION_MOVE:
            return ""ACTION_MOVE"";
        case ACTION_HOVER_MOVE:
            return ""ACTION_HOVER_MOVE"";
        case ACTION_SCROLL:
            return ""ACTION_SCROLL"";
        case ACTION_HOVER_ENTER:
            return ""ACTION_HOVER_ENTER"";
        case ACTION_HOVER_EXIT:
            return ""ACTION_HOVER_EXIT"";
        case ACTION_BUTTON_PRESS:
            return ""ACTION_BUTTON_PRESS"";
        case ACTION_BUTTON_RELEASE:
            return ""ACTION_BUTTON_RELEASE"";
    }
    int index = (action & ACTION_POINTER_INDEX_MASK) >> ACTION_POINTER_INDEX_SHIFT;
    switch(action & ACTION_MASK) {
        case ACTION_POINTER_DOWN:
            return ""ACTION_POINTER_DOWN("" + index + "")"";
        case ACTION_POINTER_UP:
            return ""ACTION_POINTER_UP("" + index + "")"";
        default:
            return Integer.toString(action);
    }
}",1,"/**
 * Returns a string that represents the symbolic name of the specified unmasked action
 * such as ""ACTION_DOWN"", ""ACTION_POINTER_DOWN(3)"" or an equivalent numeric constant
 * such as ""35"" if unknown.
 *
 * @param action The unmasked action.
 * @return The symbolic name of the specified action.
 * @see #getAction()
 */
","/**
 * Returns a string that represents the symbolic name of the specified unmasked action
 * such as ""ACTION_DOWN"", ""ACTION_POINTER_DOWN(3)"" or an equivalent numeric constant
 * such as ""35"" if unknown.
 *
 * @param action The unmasked action.
 * @return The symbolic name of the specified action.
 * @see #getAction()
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"Two case statements have been added to the switch block (ACTION_BUTTON_PRESS and ACTION_BUTTON_RELEASE) with their respective return statements, affecting how return values are produced, so the code change type is 1.","The addition of the two new case statements means that for some input values, the late version of the API will return a value that the early version could not, specifically the strings ""ACTION_BUTTON_PRESS"" and ""ACTION_BUTTON_RELEASE"", which implies that the CI type is 1 due to the potential different return values."
364,<android.hardware.display.DisplayManagerInternal.DisplayPowerRequest: boolean equals(DisplayPowerRequest)>,22,23,<android.hardware.display.DisplayManagerInternal.DisplayPowerRequest: boolean equals(DisplayPowerRequest)>,<android.hardware.display.DisplayManagerInternal.DisplayPowerRequest: boolean equals(DisplayPowerRequest)>,0,"{
    return other != null && policy == other.policy && useProximitySensor == other.useProximitySensor && screenBrightness == other.screenBrightness && screenAutoBrightnessAdjustment == other.screenAutoBrightnessAdjustment && useAutoBrightness == other.useAutoBrightness && blockScreenOn == other.blockScreenOn && lowPowerMode == other.lowPowerMode && boostScreenBrightness == other.boostScreenBrightness && dozeScreenBrightness == other.dozeScreenBrightness && dozeScreenState == other.dozeScreenState;
}","{
    return other != null && policy == other.policy && useProximitySensor == other.useProximitySensor && screenBrightness == other.screenBrightness && screenAutoBrightnessAdjustment == other.screenAutoBrightnessAdjustment && brightnessSetByUser == other.brightnessSetByUser && useAutoBrightness == other.useAutoBrightness && blockScreenOn == other.blockScreenOn && lowPowerMode == other.lowPowerMode && boostScreenBrightness == other.boostScreenBrightness && dozeScreenBrightness == other.dozeScreenBrightness && dozeScreenState == other.dozeScreenState;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,4",0,"The return statement is modified with an added condition (brightnessSetByUser == other.brightnessSetByUser) and the removal of an unrelated condition that was previously checked. This is quantified as both a 'Return statement changed' and an 'Other statement changed' because although it's a return statement, the logic on which the equality check is based has also evolved. Thus, the code changes involve a change in the logic for determining equality.","Despite the changes in the return statement's logic, this would not cause a Compatibility Issue. The 'equals' method still behaves as it should, returning 'true' or 'false' based on the state of the DisplayPowerRequest object, and these attributes simply reflect the current state of the object. The method's contract—to check for equality—remains intact because the return type and the overall behavior (returning a boolean indicating equality) do not change despite the difference in specific properties being compared. Therefore, no Compatibility Issue arises from this change."
366,<android.view.ViewRootImpl.InputStage: boolean shouldDropInputEvent(QueuedInputEvent)>,22,23,<android.view.ViewRootImpl.InputStage: boolean shouldDropInputEvent(QueuedInputEvent)>,<android.view.ViewRootImpl.InputStage: boolean shouldDropInputEvent(QueuedInputEvent)>,0,"{
    if (mView == null || !mAdded) {
        Slog.w(TAG, ""Dropping event due to root view being removed: "" + q.mEvent);
        return true;
    } else if ((!mAttachInfo.mHasWindowFocus || mStopped) && !q.mEvent.isFromSource(InputDevice.SOURCE_CLASS_POINTER)) {
        // but the window has lost focus or stopped in the meantime.
        if (isTerminalInputEvent(q.mEvent)) {
            // Don't drop terminal input events, however mark them as canceled.
            q.mEvent.cancel();
            Slog.w(TAG, ""Cancelling event due to no window focus: "" + q.mEvent);
            return false;
        }
        // Drop non-terminal input events.
        Slog.w(TAG, ""Dropping event due to no window focus: "" + q.mEvent);
        return true;
    }
    return false;
}","{
    if (mView == null || !mAdded) {
        Slog.w(TAG, ""Dropping event due to root view being removed: "" + q.mEvent);
        return true;
    } else if ((!mAttachInfo.mHasWindowFocus && !q.mEvent.isFromSource(InputDevice.SOURCE_CLASS_POINTER)) || mStopped || (mPausedForTransition && !isBack(q.mEvent))) {
        // but the window has lost focus or stopped in the meantime.
        if (isTerminalInputEvent(q.mEvent)) {
            // Don't drop terminal input events, however mark them as canceled.
            q.mEvent.cancel();
            Slog.w(TAG, ""Cancelling event due to no window focus: "" + q.mEvent);
            return false;
        }
        // Drop non-terminal input events.
        Slog.w(TAG, ""Dropping event due to no window focus: "" + q.mEvent);
        return true;
    }
    return false;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,1,"The control dependency has changed with the addition of a new condition 'mPausedForTransition && !isBack(q.mEvent)' in the else if statement, so the code change type is 3.","The introduced condition alters the circumstances under which an event may be cancelled or dropped; this could cause the function to return a different value since some input events that were previously not dropped may now be dropped due to the additional condition. Therefore, the CI type is 1."
368,<android.widget.AbsListView.RecycleBin: View getScrapView(int)>,22,23,<android.widget.AbsListView.RecycleBin: View getScrapView(int)>,<android.widget.AbsListView.RecycleBin: View getScrapView(int)>,0,"{
    if (mViewTypeCount == 1) {
        return retrieveFromScrap(mCurrentScrap, position);
    } else {
        final int whichScrap = mAdapter.getItemViewType(position);
        if (whichScrap >= 0 && whichScrap < mScrapViews.length) {
            return retrieveFromScrap(mScrapViews[whichScrap], position);
        }
    }
    return null;
}","{
    final int whichScrap = mAdapter.getItemViewType(position);
    if (whichScrap < 0) {
        return null;
    }
    if (mViewTypeCount == 1) {
        return retrieveFromScrap(mCurrentScrap, position);
    } else if (whichScrap < mScrapViews.length) {
        return retrieveFromScrap(mScrapViews[whichScrap], position);
    }
    return null;
}",1,"/**
 * @return A view from the ScrapViews collection. These are unordered.
 */
","/**
 * @return A view from the ScrapViews collection. These are unordered.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The control flow has been restructured. Previously, the check for `mViewTypeCount == 1` was the first condition, followed by checking the `whichScrap` index. In the late version, the check for `whichScrap < 0` is done first, and the `mViewTypeCount` condition has been moved inside the else block. Additionally, the `whichScrap` check is slightly restructured. This counts as a control dependency change, change type 3.","Despite the restructure of control flow, there is no potential Compatibility Issue. This is because the conditions and outcomes for each case remain functionally equivalent between the two versions. The method ultimately returns a view retrieved from scrap or null depending on the same conditions, irrespective of the ordering of these conditions. Therefore, the behavior this API would exhibit should be consistent across both versions, so the CI type is 0."
369,<android.app.Activity: void performStop()>,22,23,<android.app.Activity: void performStop()>,<android.app.Activity: void performStop()>,0,"{
    mDoReportFullyDrawn = false;
    if (mLoadersStarted) {
        mLoadersStarted = false;
        if (mLoaderManager != null) {
            if (!mChangingConfigurations) {
                mLoaderManager.doStop();
            } else {
                mLoaderManager.doRetain();
            }
        }
    }
    if (!mStopped) {
        if (mWindow != null) {
            mWindow.closeAllPanels();
        }
        if (mToken != null && mParent == null) {
            WindowManagerGlobal.getInstance().setStoppedState(mToken, true);
        }
        mFragments.dispatchStop();
        mCalled = false;
        mInstrumentation.callActivityOnStop(this);
        if (!mCalled) {
            throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onStop()"");
        }
        synchronized (mManagedCursors) {
            final int N = mManagedCursors.size();
            for (int i = 0; i < N; i++) {
                ManagedCursor mc = mManagedCursors.get(i);
                if (!mc.mReleased) {
                    mc.mCursor.deactivate();
                    mc.mReleased = true;
                }
            }
        }
        mStopped = true;
    }
    mResumed = false;
}","{
    mDoReportFullyDrawn = false;
    mFragments.doLoaderStop(mChangingConfigurations);
    if (!mStopped) {
        if (mWindow != null) {
            mWindow.closeAllPanels();
        }
        if (mToken != null && mParent == null) {
            WindowManagerGlobal.getInstance().setStoppedState(mToken, true);
        }
        mFragments.dispatchStop();
        mCalled = false;
        mInstrumentation.callActivityOnStop(this);
        if (!mCalled) {
            throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onStop()"");
        }
        synchronized (mManagedCursors) {
            final int N = mManagedCursors.size();
            for (int i = 0; i < N; i++) {
                ManagedCursor mc = mManagedCursors.get(i);
                if (!mc.mReleased) {
                    mc.mCursor.deactivate();
                    mc.mReleased = true;
                }
            }
        }
        mStopped = true;
    }
    mResumed = false;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,5",0,"The method implementation changes to remove the check and logic specific to 'mLoadersStarted' and replaces it with a call to 'mFragments.doLoaderStop(mChangingConfigurations)'. This is a control dependency change since the removed 'if' block had additional logic which is now hidden inside the 'doLoaderStop' method. Additionally, this is also a dependent API changed as the implementation now depends on 'doLoaderStop' method of 'mFragments' with different behavior depending on the changing configurations.","There seems to be no Compatibility Issue due to these changes, because the logic and behavior regarding the stopping of loaders have been moved inside 'mFragments.doLoaderStop(mChangingConfigurations)'. Unless 'doLoaderStop' is incorrectly implemented, it should handle the logic that was previously being taken care of in 'performStop'. Therefore, existing callers of 'performStop' will not experience a CI as the method's contract or expected behavior from a caller's perspective remains the same."
372,"<android.animation.AnimatorInflater: StateListAnimator loadStateListAnimator(Context,int)>",22,23,"<android.animation.AnimatorInflater: StateListAnimator loadStateListAnimator(Context,int)>","<android.animation.AnimatorInflater: StateListAnimator loadStateListAnimator(Context,int)>",0,"{
    final Resources resources = context.getResources();
    final ConfigurationBoundResourceCache<StateListAnimator> cache = resources.getStateListAnimatorCache();
    final Theme theme = context.getTheme();
    StateListAnimator animator = cache.get(id, theme);
    if (animator != null) {
        return animator;
    }
    XmlResourceParser parser = null;
    try {
        parser = resources.getAnimation(id);
        animator = createStateListAnimatorFromXml(context, parser, Xml.asAttributeSet(parser));
        if (animator != null) {
            animator.appendChangingConfigurations(getChangingConfigs(resources, id));
            final ConstantState<StateListAnimator> constantState = animator.createConstantState();
            if (constantState != null) {
                cache.put(id, theme, constantState);
                // return a clone so that the animator in constant state is never used.
                animator = constantState.newInstance(resources, theme);
            }
        }
        return animator;
    } catch (XmlPullParserException ex) {
        Resources.NotFoundException rnf = new Resources.NotFoundException(""Can't load state list animator resource ID #0x"" + Integer.toHexString(id));
        rnf.initCause(ex);
        throw rnf;
    } catch (IOException ex) {
        Resources.NotFoundException rnf = new Resources.NotFoundException(""Can't load state list animator resource ID #0x"" + Integer.toHexString(id));
        rnf.initCause(ex);
        throw rnf;
    } finally {
        if (parser != null) {
            parser.close();
        }
    }
}","{
    final Resources resources = context.getResources();
    final ConfigurationBoundResourceCache<StateListAnimator> cache = resources.getStateListAnimatorCache();
    final Theme theme = context.getTheme();
    StateListAnimator animator = cache.getInstance(id, theme);
    if (animator != null) {
        return animator;
    }
    XmlResourceParser parser = null;
    try {
        parser = resources.getAnimation(id);
        animator = createStateListAnimatorFromXml(context, parser, Xml.asAttributeSet(parser));
        if (animator != null) {
            animator.appendChangingConfigurations(getChangingConfigs(resources, id));
            final ConstantState<StateListAnimator> constantState = animator.createConstantState();
            if (constantState != null) {
                cache.put(id, theme, constantState);
                // return a clone so that the animator in constant state is never used.
                animator = constantState.newInstance(resources, theme);
            }
        }
        return animator;
    } catch (XmlPullParserException ex) {
        Resources.NotFoundException rnf = new Resources.NotFoundException(""Can't load state list animator resource ID #0x"" + Integer.toHexString(id));
        rnf.initCause(ex);
        throw rnf;
    } catch (IOException ex) {
        Resources.NotFoundException rnf = new Resources.NotFoundException(""Can't load state list animator resource ID #0x"" + Integer.toHexString(id));
        rnf.initCause(ex);
        throw rnf;
    } finally {
        if (parser != null) {
            parser.close();
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,5,0,"The code change is within the method cache.get(id, theme) which has been updated to cache.getInstance(id, theme). So, the change is due to the dependent API changed, which is type 5.","There is no direct indication that this would lead to a different value being returned or a different exception being thrown because the change is internal to the caching mechanism, which is supposed to return the same StateListAnimator for given parameters. Therefore, we presume no Compatibility Issue, classified as 0."
373,"<android.text.SpannableStringBuilder: int nextSpanTransition(int,int,Class)>",22,23,"<android.text.SpannableStringBuilder: int nextSpanTransition(int,int,Class)>","<android.text.SpannableStringBuilder: int nextSpanTransition(int,int,Class)>",0,"{
    int count = mSpanCount;
    Object[] spans = mSpans;
    int[] starts = mSpanStarts;
    int[] ends = mSpanEnds;
    int gapstart = mGapStart;
    int gaplen = mGapLength;
    if (kind == null) {
        kind = Object.class;
    }
    for (int i = 0; i < count; i++) {
        int st = starts[i];
        int en = ends[i];
        if (st > gapstart)
            st -= gaplen;
        if (en > gapstart)
            en -= gaplen;
        if (st > start && st < limit && kind.isInstance(spans[i]))
            limit = st;
        if (en > start && en < limit && kind.isInstance(spans[i]))
            limit = en;
    }
    return limit;
}","{
    if (mSpanCount == 0)
        return limit;
    if (kind == null) {
        kind = Object.class;
    }
    return nextSpanTransitionRec(start, limit, kind, treeRoot());
}",1,"/**
 * Return the next offset after <code>start</code> but less than or
 * equal to <code>limit</code> where a span of the specified type
 * begins or ends.
 */
","/**
 * Return the next offset after <code>start</code> but less than or
 * equal to <code>limit</code> where a span of the specified type
 * begins or ends.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,5","1,2","The late version introduces a control flow change by checking ""if (mSpanCount == 0)"" and returning limit early. It also removes the manual for-loop that was iterating over the spans and directly calls ""nextSpanTransitionRec(start, limit, kind, treeRoot())"" with modified logic to determine the next span transition. Additionally, the implementation relies on the new method ""treeRoot()"" which wasn't present in the early version, indicating a change in the dependent API (5). The code change type is 1, 3, and 5 because the return statement, the control flow, and a dependent method signature have been altered.","The early version manually iterates over the internal span storage to find the next span transition, while the late version uses a recursive method, potentially altering the return value (CI type 1). Furthermore, the removal of the loop and the addition of the early return check for ""mSpanCount == 0"" potentially change the method's behavior in terms of both the value returned and the exceptions that might be thrown (due to reliance on the new method ""treeRoot()""), resulting in both CI type 1 (different return values or types) and CI type 2 (different exception handlings)."
375,<android.net.DhcpStateMachine.StoppedState: boolean processMessage(Message)>,22,23,<android.net.DhcpStateMachine.StoppedState: boolean processMessage(Message)>,<android.net.DhcpStateMachine.StoppedState: boolean processMessage(Message)>,0,"{
    boolean retValue = HANDLED;
    if (DBG)
        Log.d(TAG, getName() + message.toString() + ""\n"");
    switch(message.what) {
        case CMD_START_DHCP:
            if (mRegisteredForPreDhcpNotification) {
                /* Notify controller before starting DHCP */
                mController.sendMessage(CMD_PRE_DHCP_ACTION);
                transitionTo(mWaitBeforeStartState);
            } else {
                if (runDhcp(DhcpAction.START)) {
                    transitionTo(mRunningState);
                }
            }
            break;
        case CMD_STOP_DHCP:
            // ignore
            break;
        default:
            retValue = NOT_HANDLED;
            break;
    }
    return retValue;
}","{
    boolean retValue = HANDLED;
    if (DBG)
        Log.d(TAG, getName() + message.toString() + ""\n"");
    switch(message.what) {
        case CMD_START_DHCP:
            if (mRegisteredForPreDhcpNotification) {
                /* Notify controller before starting DHCP */
                mController.sendMessage(CMD_PRE_DHCP_ACTION);
                transitionTo(mWaitBeforeStartState);
            } else {
                if (runDhcpStart()) {
                    transitionTo(mRunningState);
                }
            }
            break;
        case CMD_STOP_DHCP:
            // ignore
            break;
        default:
            retValue = NOT_HANDLED;
            break;
    }
    return retValue;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The change is in the invocation of a method from runDhcp(DhcpAction.START) to runDhcpStart(). This is an example of Dependent API changed (5). However, there are no changes to control flow statements or return statements, leading to Other statement changed (4).","Since there is no change in return values or in how exceptions are thrown/handled within the processMessage method itself, but rather a change in the invocation of another method which might still maintain the behavior if runDhcpStart() is equivalent to runDhcp(DhcpAction.START), there is No Compatibility Issue (0) in the context of this method's execution flow and error handling."
376,<android.widget.TextView: int getBaseline()>,22,23,<android.widget.TextView: int getBaseline()>,<android.widget.TextView: int getBaseline()>,0,"{
    if (mLayout == null) {
        return super.getBaseline();
    }
    int voffset = 0;
    if ((mGravity & Gravity.VERTICAL_GRAVITY_MASK) != Gravity.TOP) {
        voffset = getVerticalOffset(true);
    }
    if (isLayoutModeOptical(mParent)) {
        voffset -= getOpticalInsets().top;
    }
    return getExtendedPaddingTop() + voffset + mLayout.getLineBaseline(0);
}","{
    if (mLayout == null) {
        return super.getBaseline();
    }
    return getBaselineOffset() + mLayout.getLineBaseline(0);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,"The return statement has changed, as now it depends on a new method call getBaselineOffset() instead of previously calculated offset. Control and other statements related to vertical offset calculation are also removed, resulting in a change type of 1,3,4.","The changes in how the baseline is calculated lead to a possible different return value, meaning that the API could potentially return different values, which is a CI type of 1."
377,<android.widget.HorizontalScrollView.SavedState: String toString()>,22,23,<android.widget.HorizontalScrollView.SavedState: String toString()>,<android.widget.HorizontalScrollView.SavedState: String toString()>,0,"{
    return ""HorizontalScrollView.SavedState{"" + Integer.toHexString(System.identityHashCode(this)) + "" scrollPosition="" + scrollPosition + "" isLayoutRtl="" + isLayoutRtl + ""}"";
}","{
    return ""HorizontalScrollView.SavedState{"" + Integer.toHexString(System.identityHashCode(this)) + "" scrollPosition="" + scrollOffsetFromStart + ""}"";
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"The return statement has changed from including `scrollPosition` and `isLayoutRtl` in the string to only `scrollOffsetFromStart`, so the code change type is 1 as it modifies the return value structure.","Since the return statement has been altered to output different information, existing code parsing the output of the `toString()` method may fail or behave incorrectly after the change; thus, the CI type is 1."
381,<android.app.ActivityThread.H: void handleMessage(Message)>,22,23,<android.app.ActivityThread.H: void handleMessage(Message)>,<android.app.ActivityThread.H: void handleMessage(Message)>,0,"{
    if (DEBUG_MESSAGES)
        Slog.v(TAG, "">>> handling: "" + codeToString(msg.what));
    switch(msg.what) {
        case LAUNCH_ACTIVITY:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityStart"");
                final ActivityClientRecord r = (ActivityClientRecord) msg.obj;
                r.packageInfo = getPackageInfoNoCheck(r.activityInfo.applicationInfo, r.compatInfo);
                handleLaunchActivity(r, null);
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case RELAUNCH_ACTIVITY:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityRestart"");
                ActivityClientRecord r = (ActivityClientRecord) msg.obj;
                handleRelaunchActivity(r);
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case PAUSE_ACTIVITY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityPause"");
            handlePauseActivity((IBinder) msg.obj, false, (msg.arg1 & 1) != 0, msg.arg2, (msg.arg1 & 2) != 0);
            maybeSnapshot();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case PAUSE_ACTIVITY_FINISHING:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityPause"");
            handlePauseActivity((IBinder) msg.obj, true, (msg.arg1 & 1) != 0, msg.arg2, (msg.arg1 & 1) != 0);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case STOP_ACTIVITY_SHOW:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityStop"");
            handleStopActivity((IBinder) msg.obj, true, msg.arg2);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case STOP_ACTIVITY_HIDE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityStop"");
            handleStopActivity((IBinder) msg.obj, false, msg.arg2);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SHOW_WINDOW:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityShowWindow"");
            handleWindowVisibility((IBinder) msg.obj, true);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case HIDE_WINDOW:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityHideWindow"");
            handleWindowVisibility((IBinder) msg.obj, false);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case RESUME_ACTIVITY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityResume"");
            handleResumeActivity((IBinder) msg.obj, true, msg.arg1 != 0, true);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SEND_RESULT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityDeliverResult"");
            handleSendResult((ResultData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case DESTROY_ACTIVITY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityDestroy"");
            handleDestroyActivity((IBinder) msg.obj, msg.arg1 != 0, msg.arg2, false);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case BIND_APPLICATION:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""bindApplication"");
            AppBindData data = (AppBindData) msg.obj;
            handleBindApplication(data);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case EXIT_APPLICATION:
            if (mInitialApplication != null) {
                mInitialApplication.onTerminate();
            }
            Looper.myLooper().quit();
            break;
        case NEW_INTENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityNewIntent"");
            handleNewIntent((NewIntentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case RECEIVER:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastReceiveComp"");
            handleReceiver((ReceiverData) msg.obj);
            maybeSnapshot();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CREATE_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceCreate"");
            handleCreateService((CreateServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case BIND_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceBind"");
            handleBindService((BindServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UNBIND_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceUnbind"");
            handleUnbindService((BindServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SERVICE_ARGS:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceStart"");
            handleServiceArgs((ServiceArgsData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case STOP_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceStop"");
            handleStopService((IBinder) msg.obj);
            maybeSnapshot();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CONFIGURATION_CHANGED:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""configChanged"");
            mCurDefaultDisplayDpi = ((Configuration) msg.obj).densityDpi;
            handleConfigurationChanged((Configuration) msg.obj, null);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CLEAN_UP_CONTEXT:
            ContextCleanupInfo cci = (ContextCleanupInfo) msg.obj;
            cci.context.performFinalCleanup(cci.who, cci.what);
            break;
        case GC_WHEN_IDLE:
            scheduleGcIdler();
            break;
        case DUMP_SERVICE:
            handleDumpService((DumpComponentInfo) msg.obj);
            break;
        case LOW_MEMORY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""lowMemory"");
            handleLowMemory();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case ACTIVITY_CONFIGURATION_CHANGED:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityConfigChanged"");
            handleActivityConfigurationChanged((IBinder) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case PROFILER_CONTROL:
            handleProfilerControl(msg.arg1 != 0, (ProfilerInfo) msg.obj, msg.arg2);
            break;
        case CREATE_BACKUP_AGENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""backupCreateAgent"");
            handleCreateBackupAgent((CreateBackupAgentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case DESTROY_BACKUP_AGENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""backupDestroyAgent"");
            handleDestroyBackupAgent((CreateBackupAgentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SUICIDE:
            Process.killProcess(Process.myPid());
            break;
        case REMOVE_PROVIDER:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""providerRemove"");
            completeRemoveProvider((ProviderRefCount) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case ENABLE_JIT:
            ensureJitEnabled();
            break;
        case DISPATCH_PACKAGE_BROADCAST:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastPackage"");
            handleDispatchPackageBroadcast(msg.arg1, (String[]) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SCHEDULE_CRASH:
            throw new RemoteServiceException((String) msg.obj);
        case DUMP_HEAP:
            handleDumpHeap(msg.arg1 != 0, (DumpHeapData) msg.obj);
            break;
        case DUMP_ACTIVITY:
            handleDumpActivity((DumpComponentInfo) msg.obj);
            break;
        case DUMP_PROVIDER:
            handleDumpProvider((DumpComponentInfo) msg.obj);
            break;
        case SLEEPING:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""sleeping"");
            handleSleeping((IBinder) msg.obj, msg.arg1 != 0);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SET_CORE_SETTINGS:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""setCoreSettings"");
            handleSetCoreSettings((Bundle) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UPDATE_PACKAGE_COMPATIBILITY_INFO:
            handleUpdatePackageCompatibilityInfo((UpdateCompatibilityData) msg.obj);
            break;
        case TRIM_MEMORY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""trimMemory"");
            handleTrimMemory(msg.arg1);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UNSTABLE_PROVIDER_DIED:
            handleUnstableProviderDied((IBinder) msg.obj, false);
            break;
        case REQUEST_ASSIST_CONTEXT_EXTRAS:
            handleRequestAssistContextExtras((RequestAssistContextExtras) msg.obj);
            break;
        case TRANSLUCENT_CONVERSION_COMPLETE:
            handleTranslucentConversionComplete((IBinder) msg.obj, msg.arg1 == 1);
            break;
        case INSTALL_PROVIDER:
            handleInstallProvider((ProviderInfo) msg.obj);
            break;
        case ON_NEW_ACTIVITY_OPTIONS:
            Pair<IBinder, ActivityOptions> pair = (Pair<IBinder, ActivityOptions>) msg.obj;
            onNewActivityOptions(pair.first, pair.second);
            break;
        case CANCEL_VISIBLE_BEHIND:
            handleCancelVisibleBehind((IBinder) msg.obj);
            break;
        case BACKGROUND_VISIBLE_BEHIND_CHANGED:
            handleOnBackgroundVisibleBehindChanged((IBinder) msg.obj, msg.arg1 > 0);
            break;
        case ENTER_ANIMATION_COMPLETE:
            handleEnterAnimationComplete((IBinder) msg.obj);
            break;
    }
    if (DEBUG_MESSAGES)
        Slog.v(TAG, ""<<< done: "" + codeToString(msg.what));
}","{
    if (DEBUG_MESSAGES)
        Slog.v(TAG, "">>> handling: "" + codeToString(msg.what));
    switch(msg.what) {
        case LAUNCH_ACTIVITY:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityStart"");
                final ActivityClientRecord r = (ActivityClientRecord) msg.obj;
                r.packageInfo = getPackageInfoNoCheck(r.activityInfo.applicationInfo, r.compatInfo);
                handleLaunchActivity(r, null);
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case RELAUNCH_ACTIVITY:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityRestart"");
                ActivityClientRecord r = (ActivityClientRecord) msg.obj;
                handleRelaunchActivity(r);
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case PAUSE_ACTIVITY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityPause"");
            handlePauseActivity((IBinder) msg.obj, false, (msg.arg1 & 1) != 0, msg.arg2, (msg.arg1 & 2) != 0);
            maybeSnapshot();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case PAUSE_ACTIVITY_FINISHING:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityPause"");
            handlePauseActivity((IBinder) msg.obj, true, (msg.arg1 & 1) != 0, msg.arg2, (msg.arg1 & 1) != 0);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case STOP_ACTIVITY_SHOW:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityStop"");
            handleStopActivity((IBinder) msg.obj, true, msg.arg2);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case STOP_ACTIVITY_HIDE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityStop"");
            handleStopActivity((IBinder) msg.obj, false, msg.arg2);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SHOW_WINDOW:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityShowWindow"");
            handleWindowVisibility((IBinder) msg.obj, true);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case HIDE_WINDOW:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityHideWindow"");
            handleWindowVisibility((IBinder) msg.obj, false);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case RESUME_ACTIVITY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityResume"");
            handleResumeActivity((IBinder) msg.obj, true, msg.arg1 != 0, true);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SEND_RESULT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityDeliverResult"");
            handleSendResult((ResultData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case DESTROY_ACTIVITY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityDestroy"");
            handleDestroyActivity((IBinder) msg.obj, msg.arg1 != 0, msg.arg2, false);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case BIND_APPLICATION:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""bindApplication"");
            AppBindData data = (AppBindData) msg.obj;
            handleBindApplication(data);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case EXIT_APPLICATION:
            if (mInitialApplication != null) {
                mInitialApplication.onTerminate();
            }
            Looper.myLooper().quit();
            break;
        case NEW_INTENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityNewIntent"");
            handleNewIntent((NewIntentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case RECEIVER:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastReceiveComp"");
            handleReceiver((ReceiverData) msg.obj);
            maybeSnapshot();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CREATE_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceCreate"");
            handleCreateService((CreateServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case BIND_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceBind"");
            handleBindService((BindServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UNBIND_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceUnbind"");
            handleUnbindService((BindServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SERVICE_ARGS:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceStart"");
            handleServiceArgs((ServiceArgsData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case STOP_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceStop"");
            handleStopService((IBinder) msg.obj);
            maybeSnapshot();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CONFIGURATION_CHANGED:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""configChanged"");
            mCurDefaultDisplayDpi = ((Configuration) msg.obj).densityDpi;
            handleConfigurationChanged((Configuration) msg.obj, null);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CLEAN_UP_CONTEXT:
            ContextCleanupInfo cci = (ContextCleanupInfo) msg.obj;
            cci.context.performFinalCleanup(cci.who, cci.what);
            break;
        case GC_WHEN_IDLE:
            scheduleGcIdler();
            break;
        case DUMP_SERVICE:
            handleDumpService((DumpComponentInfo) msg.obj);
            break;
        case LOW_MEMORY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""lowMemory"");
            handleLowMemory();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case ACTIVITY_CONFIGURATION_CHANGED:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityConfigChanged"");
            handleActivityConfigurationChanged((ActivityConfigChangeData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case PROFILER_CONTROL:
            handleProfilerControl(msg.arg1 != 0, (ProfilerInfo) msg.obj, msg.arg2);
            break;
        case CREATE_BACKUP_AGENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""backupCreateAgent"");
            handleCreateBackupAgent((CreateBackupAgentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case DESTROY_BACKUP_AGENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""backupDestroyAgent"");
            handleDestroyBackupAgent((CreateBackupAgentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SUICIDE:
            Process.killProcess(Process.myPid());
            break;
        case REMOVE_PROVIDER:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""providerRemove"");
            completeRemoveProvider((ProviderRefCount) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case ENABLE_JIT:
            ensureJitEnabled();
            break;
        case DISPATCH_PACKAGE_BROADCAST:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastPackage"");
            handleDispatchPackageBroadcast(msg.arg1, (String[]) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SCHEDULE_CRASH:
            throw new RemoteServiceException((String) msg.obj);
        case DUMP_HEAP:
            handleDumpHeap(msg.arg1 != 0, (DumpHeapData) msg.obj);
            break;
        case DUMP_ACTIVITY:
            handleDumpActivity((DumpComponentInfo) msg.obj);
            break;
        case DUMP_PROVIDER:
            handleDumpProvider((DumpComponentInfo) msg.obj);
            break;
        case SLEEPING:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""sleeping"");
            handleSleeping((IBinder) msg.obj, msg.arg1 != 0);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SET_CORE_SETTINGS:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""setCoreSettings"");
            handleSetCoreSettings((Bundle) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UPDATE_PACKAGE_COMPATIBILITY_INFO:
            handleUpdatePackageCompatibilityInfo((UpdateCompatibilityData) msg.obj);
            break;
        case TRIM_MEMORY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""trimMemory"");
            handleTrimMemory(msg.arg1);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UNSTABLE_PROVIDER_DIED:
            handleUnstableProviderDied((IBinder) msg.obj, false);
            break;
        case REQUEST_ASSIST_CONTEXT_EXTRAS:
            handleRequestAssistContextExtras((RequestAssistContextExtras) msg.obj);
            break;
        case TRANSLUCENT_CONVERSION_COMPLETE:
            handleTranslucentConversionComplete((IBinder) msg.obj, msg.arg1 == 1);
            break;
        case INSTALL_PROVIDER:
            handleInstallProvider((ProviderInfo) msg.obj);
            break;
        case ON_NEW_ACTIVITY_OPTIONS:
            Pair<IBinder, ActivityOptions> pair = (Pair<IBinder, ActivityOptions>) msg.obj;
            onNewActivityOptions(pair.first, pair.second);
            break;
        case CANCEL_VISIBLE_BEHIND:
            handleCancelVisibleBehind((IBinder) msg.obj);
            break;
        case BACKGROUND_VISIBLE_BEHIND_CHANGED:
            handleOnBackgroundVisibleBehindChanged((IBinder) msg.obj, msg.arg1 > 0);
            break;
        case ENTER_ANIMATION_COMPLETE:
            handleEnterAnimationComplete((IBinder) msg.obj);
            break;
    }
    if (DEBUG_MESSAGES)
        Slog.v(TAG, ""<<< done: "" + codeToString(msg.what));
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
384,<android.os.Environment: String getExternalStorageState(File)>,22,23,<android.os.Environment: String getExternalStorageState(File)>,<android.os.Environment: String getExternalStorageState(File)>,0,"{
    final StorageVolume volume = getStorageVolume(path);
    if (volume != null) {
        final IMountService mountService = IMountService.Stub.asInterface(ServiceManager.getService(""mount""));
        try {
            return mountService.getVolumeState(volume.getPath());
        } catch (RemoteException e) {
        }
    }
    return Environment.MEDIA_UNKNOWN;
}","{
    final StorageVolume volume = StorageManager.getStorageVolume(path, UserHandle.myUserId());
    if (volume != null) {
        return volume.getState();
    } else {
        return MEDIA_UNKNOWN;
    }
}",1,"/**
 * Returns the current state of the storage device that provides the given
 * path.
 *
 * @return one of {@link #MEDIA_UNKNOWN}, {@link #MEDIA_REMOVED},
 * {@link #MEDIA_UNMOUNTED}, {@link #MEDIA_CHECKING},
 * {@link #MEDIA_NOFS}, {@link #MEDIA_MOUNTED},
 * {@link #MEDIA_MOUNTED_READ_ONLY}, {@link #MEDIA_SHARED},
 * {@link #MEDIA_BAD_REMOVAL}, or {@link #MEDIA_UNMOUNTABLE}.
 */
","/**
 * Returns the current state of the storage device that provides the given
 * path.
 *
 * @return one of {@link #MEDIA_UNKNOWN}, {@link #MEDIA_REMOVED},
 * {@link #MEDIA_UNMOUNTED}, {@link #MEDIA_CHECKING},
 * {@link #MEDIA_NOFS}, {@link #MEDIA_MOUNTED},
 * {@link #MEDIA_MOUNTED_READ_ONLY}, {@link #MEDIA_SHARED},
 * {@link #MEDIA_BAD_REMOVAL}, or {@link #MEDIA_UNMOUNTABLE}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The method for retrieving the StorageVolume instance has changed, which indicates a Dependent API change (changing from getStorageVolume(path) to getStorageVolume(path, UserHandle.myUserId())). There's also a return statement change since previously the code would return the state via an RPC call through mountService.getVolumeState(volume.getPath()), but now it directly returns the state with volume.getState(). Moreover, there is an Other statement change as the previous try-catch block is removed eliminating the potential RemoteException handling. Hence, the code change types are 1, 4, and 5.","Because the method is now retrieving the StorageVolume in a different way and directly returning its state, rather than making an RPC call to the IMountService, which can behave differently under various circumstances, it's clear that the return value of this method could potentially differ. Additionally, the way it handles a missing volume has changed slightly (it uses an else block now), and RemoteException is no longer caught. These changes could lead to a different return value or type, causing a Compatibility Issue of type 1."
387,"<com.android.server.backup.SystemBackupAgent: void onBackup(ParcelFileDescriptor,BackupDataOutput,ParcelFileDescriptor)>",22,23,"<com.android.server.backup.SystemBackupAgent: void onBackup(ParcelFileDescriptor,BackupDataOutput,ParcelFileDescriptor)>","<com.android.server.backup.SystemBackupAgent: void onBackup(ParcelFileDescriptor,BackupDataOutput,ParcelFileDescriptor)>",0,"{
    // We only back up the data under the current ""wallpaper"" schema with metadata
    IWallpaperManager wallpaper = (IWallpaperManager) ServiceManager.getService(Context.WALLPAPER_SERVICE);
    String[] files = new String[] { WALLPAPER_IMAGE, WALLPAPER_INFO };
    String[] keys = new String[] { WALLPAPER_IMAGE_KEY, WALLPAPER_INFO_KEY };
    if (wallpaper != null) {
        try {
            final String wallpaperName = wallpaper.getName();
            if (wallpaperName != null && wallpaperName.length() > 0) {
                // When the wallpaper has a name, back up the info by itself.
                // TODO: Don't rely on the innards of the service object like this!
                // TODO: Send a delete for any stored wallpaper image in this case?
                files = new String[] { WALLPAPER_INFO };
                keys = new String[] { WALLPAPER_INFO_KEY };
            }
        } catch (RemoteException re) {
            Slog.e(TAG, ""Couldn't get wallpaper name\n"" + re);
        }
    }
    addHelper(""wallpaper"", new WallpaperBackupHelper(SystemBackupAgent.this, files, keys));
    addHelper(""recents"", new RecentsBackupHelper(SystemBackupAgent.this));
    super.onBackup(oldState, data, newState);
}","{
    // We only back up the data under the current ""wallpaper"" schema with metadata
    IWallpaperManager wallpaper = (IWallpaperManager) ServiceManager.getService(Context.WALLPAPER_SERVICE);
    String[] files = new String[] { WALLPAPER_IMAGE, WALLPAPER_INFO };
    String[] keys = new String[] { WALLPAPER_IMAGE_KEY, WALLPAPER_INFO_KEY };
    if (wallpaper != null) {
        try {
            final String wallpaperName = wallpaper.getName();
            if (wallpaperName != null && wallpaperName.length() > 0) {
                // When the wallpaper has a name, back up the info by itself.
                // TODO: Don't rely on the innards of the service object like this!
                // TODO: Send a delete for any stored wallpaper image in this case?
                files = new String[] { WALLPAPER_INFO };
                keys = new String[] { WALLPAPER_INFO_KEY };
            }
        } catch (RemoteException re) {
            Slog.e(TAG, ""Couldn't get wallpaper name\n"" + re);
        }
    }
    addHelper(WALLPAPER_HELPER, new WallpaperBackupHelper(this, files, keys));
    addHelper(SYNC_SETTINGS_HELPER, new AccountSyncSettingsBackupHelper(this));
    addHelper(PREFERRED_HELPER, new PreferredActivityBackupHelper());
    addHelper(NOTIFICATION_HELPER, new NotificationBackupHelper(this));
    super.onBackup(oldState, data, newState);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The 'late' version uses the constants WALLPAPER_HELPER, SYNC_SETTINGS_HELPER, PREFERRED_HELPER, and NOTIFICATION_HELPER instead of the string literals in the 'addHelper' calls; new helper instances for syncing settings, preferred activities, and notifications have also been added. This results in change type 4 (Other statement changed).","The additions of new helper instances do not affect the return type or the exceptions thrown by the function. Thus, no Compatibility Issue arises, so the CI is 0 (No Compatibility Issue)."
390,"<android.text.format.DateUtils: CharSequence getRelativeDateTimeString(Context,long,long,long,int)>",22,23,"<android.text.format.DateUtils: CharSequence getRelativeDateTimeString(Context,long,long,long,int)>","<android.text.format.DateUtils: CharSequence getRelativeDateTimeString(Context,long,long,long,int)>",0,"{
    Resources r = Resources.getSystem();
    long now = System.currentTimeMillis();
    long duration = Math.abs(now - time);
    // transitionResolution as needed.
    if (transitionResolution > WEEK_IN_MILLIS) {
        transitionResolution = WEEK_IN_MILLIS;
    } else if (transitionResolution < DAY_IN_MILLIS) {
        transitionResolution = DAY_IN_MILLIS;
    }
    CharSequence timeClause = formatDateRange(c, time, time, FORMAT_SHOW_TIME);
    String result;
    if (duration < transitionResolution) {
        CharSequence relativeClause = getRelativeTimeSpanString(time, now, minResolution, flags);
        result = r.getString(com.android.internal.R.string.relative_time, relativeClause, timeClause);
    } else {
        CharSequence dateClause = getRelativeTimeSpanString(c, time, false);
        result = r.getString(com.android.internal.R.string.date_time, dateClause, timeClause);
    }
    return result;
}","{
    // Same reason as in formatDateRange() to explicitly indicate 12- or 24-hour format.
    if ((flags & (FORMAT_SHOW_TIME | FORMAT_12HOUR | FORMAT_24HOUR)) == FORMAT_SHOW_TIME) {
        flags |= DateFormat.is24HourFormat(c) ? FORMAT_24HOUR : FORMAT_12HOUR;
    }
    return RelativeDateTimeFormatter.getRelativeDateTimeString(Locale.getDefault(), TimeZone.getDefault(), time, System.currentTimeMillis(), minResolution, transitionResolution, flags);
}",1,"/**
 * Return string describing the elapsed time since startTime formatted like
 * ""[relative time/date], [time]"".
 * <p>
 * Example output strings for the US date format.
 * <ul>
 * <li>3 mins ago, 10:15 AM</li>
 * <li>yesterday, 12:20 PM</li>
 * <li>Dec 12, 4:12 AM</li>
 * <li>11/14/2007, 8:20 AM</li>
 * </ul>
 *
 * @param time some time in the past.
 * @param minResolution the minimum elapsed time (in milliseconds) to report
 * when showing relative times. For example, a time 3 seconds in
 * the past will be reported as ""0 minutes ago"" if this is set to
 * {@link #MINUTE_IN_MILLIS}.
 * @param transitionResolution the elapsed time (in milliseconds) at which
 * to stop reporting relative measurements. Elapsed times greater
 * than this resolution will default to normal date formatting.
 * For example, will transition from ""6 days ago"" to ""Dec 12""
 * when using {@link #WEEK_IN_MILLIS}.
 */
","/**
 * Return string describing the elapsed time since startTime formatted like
 * ""[relative time/date], [time]"".
 * <p>
 * Example output strings for the US date format.
 * <ul>
 * <li>3 min. ago, 10:15 AM</li>
 * <li>Yesterday, 12:20 PM</li>
 * <li>Dec 12, 4:12 AM</li>
 * <li>11/14/2007, 8:20 AM</li>
 * </ul>
 *
 * @param time some time in the past.
 * @param minResolution the minimum elapsed time (in milliseconds) to report
 * when showing relative times. For example, a time 3 seconds in
 * the past will be reported as ""0 minutes ago"" if this is set to
 * {@link #MINUTE_IN_MILLIS}.
 * @param transitionResolution the elapsed time (in milliseconds) at which
 * to stop reporting relative measurements. Elapsed times greater
 * than this resolution will default to normal date formatting.
 * For example, will transition from ""7 days ago"" to ""Dec 12""
 * when using {@link #WEEK_IN_MILLIS}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5","1,2","The return statement has changed from a multiple-step process involving conditional statements and localized string formatting to a single method call. Moreover, control dependency changes are present due to removal of conditional statements and use of a new method RelativeDateTimeFormatter.getRelativeDateTimeString(). Additionally, dependent APIs like formatDateRange and getRelativeTimeSpanString are no longer used, and the API is now utilizing the RelativeDateTimeFormatter.getRelativeDateTimeString, which is a change in dependent APIs. Other statements have also been changed, like the addition of code to determine 12-hour or 24-hour formatting. Therefore, the change types are 1,3,4,5.","This is a significant refactor of the method's implementation, with different logic for obtaining and formatting the output. The returned CharSequence is now being generated in a completely different manner, which could potentially result in different return values and types; this satisfies the criteria for a return statement change. Additionally, due to the removal of exception handling code that uses try-catch, a RemoteException is now more likely to propagate without being caught, thus leading to a changed exception handling behavior (although there's no specific exception handling code in either version provided above, the underlying API could have introduced or removed exception throwing which isn't visible in the given snippet). Therefore, the CI types are 1 and 2."
391,<android.view.WindowInsets: boolean hasInsets()>,22,23,<android.view.WindowInsets: boolean hasInsets()>,<android.view.WindowInsets: boolean hasInsets()>,0,"{
    return hasSystemWindowInsets() || hasWindowDecorInsets();
}","{
    return hasSystemWindowInsets() || hasWindowDecorInsets() || hasStableInsets();
}",1,"/**
 * Returns true if this WindowInsets has any nonzero insets.
 *
 * @return true if any inset values are nonzero
 */
","/**
 * Returns true if this WindowInsets has any nonzero insets.
 *
 * @return true if any inset values are nonzero
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement in the late version introduces an additional condition (hasStableInsets()), which was not present in the early version. Therefore, the code change type is 1.","The additional condition (hasStableInsets()) in the return statement could cause the method to potentially return a different boolean value than before, which could lead to a Compatibility Issue of type 1, where the API returns a different value."
392,<android.accounts.AccountManager: Account[] getAccounts()>,22,23,<android.accounts.AccountManager: Account[] getAccounts()>,<android.accounts.AccountManager: Account[] getAccounts()>,0,"{
    try {
        return mService.getAccounts(null);
    } catch (RemoteException e) {
        // won't ever happen
        throw new RuntimeException(e);
    }
}","{
    try {
        return mService.getAccounts(null, mContext.getOpPackageName());
    } catch (RemoteException e) {
        // won't ever happen
        throw new RuntimeException(e);
    }
}",1,"/**
 * Lists all accounts of any type registered on the device.
 * Equivalent to getAccountsByType(null).
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#GET_ACCOUNTS}.
 *
 * @return An array of {@link Account}, one for each account.  Empty
 * (never null) if no accounts have been added.
 */
","/**
 * Lists all accounts of any type registered on the device.
 * Equivalent to getAccountsByType(null).
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>Clients of this method that have not been granted the
 * {@link android.Manifest.permission#GET_ACCOUNTS} permission,
 * will only see those accounts managed by AbstractAccountAuthenticators whose
 * signature matches the client.
 *
 * @return An array of {@link Account}, one for each account.  Empty
 * (never null) if no accounts have been added.
 */
",-1,,[@RequiresPermission(GET_ACCOUNTS)],-1,-1,-1,-1,-1,-1,"1,5",1,"The method signature of the dependent API mService.getAccounts(...) has changed, it now includes an additional parameter (mContext.getOpPackageName()), hence the code change is type 5. Additionally, since this changes how the method is called, there may be a modification in the return value from the service, so it is also type 1.","The introduction of an additional parameter in the dependent API call could change the behavior of the API by returning different accounts based on the operation package name, which was not considered in the earlier version. This can result in a potential compatibility issue in terms of different return values (type 1)."
394,"<android.app.ContextImpl: ContextImpl createAppContext(ActivityThread,LoadedApk)>",22,23,"<android.app.ContextImpl: ContextImpl createAppContext(ActivityThread,LoadedApk)>","<android.app.ContextImpl: ContextImpl createAppContext(ActivityThread,LoadedApk)>",0,"{
    if (packageInfo == null)
        throw new IllegalArgumentException(""packageInfo"");
    return new ContextImpl(null, mainThread, packageInfo, null, null, false, null, null);
}","{
    if (packageInfo == null)
        throw new IllegalArgumentException(""packageInfo"");
    return new ContextImpl(null, mainThread, packageInfo, null, null, false, null, null, Display.INVALID_DISPLAY);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The constructor call for ContextImpl in the return statement has one additional parameter in the late version, so this is a change in the other statements (as the constructor signature is different) and also a change in the return statement, hence the classification is 1,4.","Since there is an extra parameter in the constructor in the late implementation, it could lead to a different instantiation behavior, potentially affecting the object's state (even if it's not explicitly altering the return type). So, a compatibility issue due to a potential different return value exists, classified as 1."
396,"<android.hardware.camera2.params.StreamConfigurationMap: long getOutputMinFrameDuration(int,Size)>",22,23,"<android.hardware.camera2.params.StreamConfigurationMap: long getOutputMinFrameDuration(int,Size)>","<android.hardware.camera2.params.StreamConfigurationMap: long getOutputMinFrameDuration(int,Size)>",0,"{
    checkNotNull(size, ""size must not be null"");
    checkArgumentFormatSupported(format, /*output*/
    true);
    return getInternalFormatDuration(imageFormatToInternal(format), size, DURATION_MIN_FRAME);
}","{
    checkNotNull(size, ""size must not be null"");
    checkArgumentFormatSupported(format, /*output*/
    true);
    return getInternalFormatDuration(imageFormatToInternal(format), imageFormatToDataspace(format), size, DURATION_MIN_FRAME);
}",1,"/**
 * Get the minimum {@link CaptureRequest#SENSOR_FRAME_DURATION frame duration}
 * for the format/size combination (in nanoseconds).
 *
 * <p>{@code format} should be one of the ones returned by {@link #getOutputFormats()}.</p>
 * <p>{@code size} should be one of the ones returned by
 * {@link #getOutputSizes(int)}.</p>
 *
 * <p>This should correspond to the frame duration when only that stream is active, with all
 * processing (typically in {@code android.*.mode}) set to either {@code OFF} or {@code FAST}.
 * </p>
 *
 * <p>When multiple streams are used in a request, the minimum frame duration will be
 * {@code max(individual stream min durations)}.</p>
 *
 * <p>For devices that do not support manual sensor control
 * ({@link android.hardware.camera2.CameraMetadata#REQUEST_AVAILABLE_CAPABILITIES_MANUAL_SENSOR}),
 * this function may return 0.</p>
 *
 * <!--
 * TODO: uncomment after adding input stream support
 * <p>The minimum frame duration of a stream (of a particular format, size) is the same
 * regardless of whether the stream is input or output.</p>
 * -->
 *
 * @param format an image format from {@link ImageFormat} or {@link PixelFormat}
 * @param size an output-compatible size
 * @return a minimum frame duration {@code >} 0 in nanoseconds, or
 * 0 if the minimum frame duration is not available.
 *
 * @throws IllegalArgumentException if {@code format} or {@code size} was not supported
 * @throws NullPointerException if {@code size} was {@code null}
 *
 * @see CaptureRequest#SENSOR_FRAME_DURATION
 * @see #getOutputStallDuration(int, Size)
 * @see ImageFormat
 * @see PixelFormat
 */
","/**
 * Get the minimum {@link CaptureRequest#SENSOR_FRAME_DURATION frame duration}
 * for the format/size combination (in nanoseconds).
 *
 * <p>{@code format} should be one of the ones returned by {@link #getOutputFormats()}.</p>
 * <p>{@code size} should be one of the ones returned by
 * {@link #getOutputSizes(int)}.</p>
 *
 * <p>This should correspond to the frame duration when only that stream is active, with all
 * processing (typically in {@code android.*.mode}) set to either {@code OFF} or {@code FAST}.
 * </p>
 *
 * <p>When multiple streams are used in a request, the minimum frame duration will be
 * {@code max(individual stream min durations)}.</p>
 *
 * <p>For devices that do not support manual sensor control
 * ({@link android.hardware.camera2.CameraMetadata#REQUEST_AVAILABLE_CAPABILITIES_MANUAL_SENSOR}),
 * this function may return 0.</p>
 *
 * <!--
 * TODO: uncomment after adding input stream support
 * <p>The minimum frame duration of a stream (of a particular format, size) is the same
 * regardless of whether the stream is input or output.</p>
 * -->
 *
 * @param format an image format from {@link ImageFormat} or {@link PixelFormat}
 * @param size an output-compatible size
 * @return a minimum frame duration {@code >} 0 in nanoseconds, or
 * 0 if the minimum frame duration is not available.
 *
 * @throws IllegalArgumentException if {@code format} or {@code size} was not supported
 * @throws NullPointerException if {@code size} was {@code null}
 *
 * @see CaptureRequest#SENSOR_FRAME_DURATION
 * @see #getOutputStallDuration(int, Size)
 * @see ImageFormat
 * @see PixelFormat
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The last return statement now has one additional argument - imageFormatToDataspace(format) is passed to getInternalFormatDuration. This means there has been a change involving internal function arguments, which represents a code change of type 4,5.","The addition of a new argument could change the behavior of the getInternalFormatDuration call if the additional argument alters the method execution, which means the API could return a different value, classifying this as a CI type 1."
397,<android.app.ApplicationPackageManager: int[] getPackageGids(String)>,22,23,<android.app.ApplicationPackageManager: int[] getPackageGids(String)>,<android.app.ApplicationPackageManager: int[] getPackageGids(String)>,0,"{
    try {
        int[] gids = mPM.getPackageGids(packageName);
        if (gids == null || gids.length > 0) {
            return gids;
        }
    } catch (RemoteException e) {
        throw new RuntimeException(""Package manager has died"", e);
    }
    throw new NameNotFoundException(packageName);
}","{
    try {
        int[] gids = mPM.getPackageGids(packageName, mContext.getUserId());
        if (gids != null) {
            return gids;
        }
    } catch (RemoteException e) {
        throw new RuntimeException(""Package manager has died"", e);
    }
    throw new NameNotFoundException(packageName);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,5",1,The code change includes:,"- Removal of ""gids.length > 0"" part of the if condition results in a return statement change (1)."
398,<android.webkit.WebView: WebBackForwardList restoreState(Bundle)>,22,23,<android.webkit.WebView: WebBackForwardList restoreState(Bundle)>,<android.webkit.WebView: WebBackForwardList restoreState(Bundle)>,0,"{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, ""restoreState"");
    return mProvider.restoreState(inState);
}","{
    checkThread();
    return mProvider.restoreState(inState);
}",1,"/**
 * Restores the state of this WebView from the given Bundle. This method is
 * intended for use in {@link android.app.Activity#onRestoreInstanceState}
 * and should be called to restore the state of this WebView. If
 * it is called after this WebView has had a chance to build state (load
 * pages, create a back/forward list, etc.) there may be undesirable
 * side-effects. Please note that this method no longer restores the
 * display data for this WebView.
 *
 * @param inState the incoming Bundle of state
 * @return the restored back/forward list or null if restoreState failed
 */
","/**
 * Restores the state of this WebView from the given Bundle. This method is
 * intended for use in {@link android.app.Activity#onRestoreInstanceState}
 * and should be called to restore the state of this WebView. If
 * it is called after this WebView has had a chance to build state (load
 * pages, create a back/forward list, etc.) there may be undesirable
 * side-effects. Please note that this method no longer restores the
 * display data for this WebView.
 *
 * @param inState the incoming Bundle of state
 * @return the restored back/forward list or null if restoreState failed
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"A logging statement has been removed (Log.d(LOGTAG, ""restoreState"")). So the change type is 4.","Removing a logging statement does not affect the behavior of the API with regards to the value returned or exceptions thrown. Therefore, there is no compatibility issue, and the CI type is 0."
399,<android.view.WindowManager.LayoutParams: int copyFrom(LayoutParams)>,22,23,<android.view.WindowManager.LayoutParams: int copyFrom(LayoutParams)>,<android.view.WindowManager.LayoutParams: int copyFrom(LayoutParams)>,0,"{
    int changes = 0;
    if (width != o.width) {
        width = o.width;
        changes |= LAYOUT_CHANGED;
    }
    if (height != o.height) {
        height = o.height;
        changes |= LAYOUT_CHANGED;
    }
    if (x != o.x) {
        x = o.x;
        changes |= LAYOUT_CHANGED;
    }
    if (y != o.y) {
        y = o.y;
        changes |= LAYOUT_CHANGED;
    }
    if (horizontalWeight != o.horizontalWeight) {
        horizontalWeight = o.horizontalWeight;
        changes |= LAYOUT_CHANGED;
    }
    if (verticalWeight != o.verticalWeight) {
        verticalWeight = o.verticalWeight;
        changes |= LAYOUT_CHANGED;
    }
    if (horizontalMargin != o.horizontalMargin) {
        horizontalMargin = o.horizontalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (verticalMargin != o.verticalMargin) {
        verticalMargin = o.verticalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (type != o.type) {
        type = o.type;
        changes |= TYPE_CHANGED;
    }
    if (flags != o.flags) {
        final int diff = flags ^ o.flags;
        if ((diff & (FLAG_TRANSLUCENT_STATUS | FLAG_TRANSLUCENT_NAVIGATION)) != 0) {
            changes |= TRANSLUCENT_FLAGS_CHANGED;
        }
        flags = o.flags;
        changes |= FLAGS_CHANGED;
    }
    if (privateFlags != o.privateFlags) {
        privateFlags = o.privateFlags;
        changes |= PRIVATE_FLAGS_CHANGED;
    }
    if (softInputMode != o.softInputMode) {
        softInputMode = o.softInputMode;
        changes |= SOFT_INPUT_MODE_CHANGED;
    }
    if (gravity != o.gravity) {
        gravity = o.gravity;
        changes |= LAYOUT_CHANGED;
    }
    if (format != o.format) {
        format = o.format;
        changes |= FORMAT_CHANGED;
    }
    if (windowAnimations != o.windowAnimations) {
        windowAnimations = o.windowAnimations;
        changes |= ANIMATION_CHANGED;
    }
    if (token == null) {
        // NOTE: token only copied if the recipient doesn't
        // already have one.
        token = o.token;
    }
    if (packageName == null) {
        // NOTE: packageName only copied if the recipient doesn't
        // already have one.
        packageName = o.packageName;
    }
    if (!mTitle.equals(o.mTitle)) {
        mTitle = o.mTitle;
        changes |= TITLE_CHANGED;
    }
    if (alpha != o.alpha) {
        alpha = o.alpha;
        changes |= ALPHA_CHANGED;
    }
    if (dimAmount != o.dimAmount) {
        dimAmount = o.dimAmount;
        changes |= DIM_AMOUNT_CHANGED;
    }
    if (screenBrightness != o.screenBrightness) {
        screenBrightness = o.screenBrightness;
        changes |= SCREEN_BRIGHTNESS_CHANGED;
    }
    if (buttonBrightness != o.buttonBrightness) {
        buttonBrightness = o.buttonBrightness;
        changes |= BUTTON_BRIGHTNESS_CHANGED;
    }
    if (rotationAnimation != o.rotationAnimation) {
        rotationAnimation = o.rotationAnimation;
        changes |= ROTATION_ANIMATION_CHANGED;
    }
    if (screenOrientation != o.screenOrientation) {
        screenOrientation = o.screenOrientation;
        changes |= SCREEN_ORIENTATION_CHANGED;
    }
    if (preferredRefreshRate != o.preferredRefreshRate) {
        preferredRefreshRate = o.preferredRefreshRate;
        changes |= PREFERRED_REFRESH_RATE_CHANGED;
    }
    if (systemUiVisibility != o.systemUiVisibility || subtreeSystemUiVisibility != o.subtreeSystemUiVisibility) {
        systemUiVisibility = o.systemUiVisibility;
        subtreeSystemUiVisibility = o.subtreeSystemUiVisibility;
        changes |= SYSTEM_UI_VISIBILITY_CHANGED;
    }
    if (hasSystemUiListeners != o.hasSystemUiListeners) {
        hasSystemUiListeners = o.hasSystemUiListeners;
        changes |= SYSTEM_UI_LISTENER_CHANGED;
    }
    if (inputFeatures != o.inputFeatures) {
        inputFeatures = o.inputFeatures;
        changes |= INPUT_FEATURES_CHANGED;
    }
    if (userActivityTimeout != o.userActivityTimeout) {
        userActivityTimeout = o.userActivityTimeout;
        changes |= USER_ACTIVITY_TIMEOUT_CHANGED;
    }
    if (!surfaceInsets.equals(o.surfaceInsets)) {
        surfaceInsets.set(o.surfaceInsets);
        changes |= SURFACE_INSETS_CHANGED;
    }
    if (needsMenuKey != o.needsMenuKey) {
        needsMenuKey = o.needsMenuKey;
        changes |= NEEDS_MENU_KEY_CHANGED;
    }
    return changes;
}","{
    int changes = 0;
    if (width != o.width) {
        width = o.width;
        changes |= LAYOUT_CHANGED;
    }
    if (height != o.height) {
        height = o.height;
        changes |= LAYOUT_CHANGED;
    }
    if (x != o.x) {
        x = o.x;
        changes |= LAYOUT_CHANGED;
    }
    if (y != o.y) {
        y = o.y;
        changes |= LAYOUT_CHANGED;
    }
    if (horizontalWeight != o.horizontalWeight) {
        horizontalWeight = o.horizontalWeight;
        changes |= LAYOUT_CHANGED;
    }
    if (verticalWeight != o.verticalWeight) {
        verticalWeight = o.verticalWeight;
        changes |= LAYOUT_CHANGED;
    }
    if (horizontalMargin != o.horizontalMargin) {
        horizontalMargin = o.horizontalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (verticalMargin != o.verticalMargin) {
        verticalMargin = o.verticalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (type != o.type) {
        type = o.type;
        changes |= TYPE_CHANGED;
    }
    if (flags != o.flags) {
        final int diff = flags ^ o.flags;
        if ((diff & (FLAG_TRANSLUCENT_STATUS | FLAG_TRANSLUCENT_NAVIGATION)) != 0) {
            changes |= TRANSLUCENT_FLAGS_CHANGED;
        }
        flags = o.flags;
        changes |= FLAGS_CHANGED;
    }
    if (privateFlags != o.privateFlags) {
        privateFlags = o.privateFlags;
        changes |= PRIVATE_FLAGS_CHANGED;
    }
    if (softInputMode != o.softInputMode) {
        softInputMode = o.softInputMode;
        changes |= SOFT_INPUT_MODE_CHANGED;
    }
    if (gravity != o.gravity) {
        gravity = o.gravity;
        changes |= LAYOUT_CHANGED;
    }
    if (format != o.format) {
        format = o.format;
        changes |= FORMAT_CHANGED;
    }
    if (windowAnimations != o.windowAnimations) {
        windowAnimations = o.windowAnimations;
        changes |= ANIMATION_CHANGED;
    }
    if (token == null) {
        // NOTE: token only copied if the recipient doesn't
        // already have one.
        token = o.token;
    }
    if (packageName == null) {
        // NOTE: packageName only copied if the recipient doesn't
        // already have one.
        packageName = o.packageName;
    }
    if (!mTitle.equals(o.mTitle)) {
        mTitle = o.mTitle;
        changes |= TITLE_CHANGED;
    }
    if (alpha != o.alpha) {
        alpha = o.alpha;
        changes |= ALPHA_CHANGED;
    }
    if (dimAmount != o.dimAmount) {
        dimAmount = o.dimAmount;
        changes |= DIM_AMOUNT_CHANGED;
    }
    if (screenBrightness != o.screenBrightness) {
        screenBrightness = o.screenBrightness;
        changes |= SCREEN_BRIGHTNESS_CHANGED;
    }
    if (buttonBrightness != o.buttonBrightness) {
        buttonBrightness = o.buttonBrightness;
        changes |= BUTTON_BRIGHTNESS_CHANGED;
    }
    if (rotationAnimation != o.rotationAnimation) {
        rotationAnimation = o.rotationAnimation;
        changes |= ROTATION_ANIMATION_CHANGED;
    }
    if (screenOrientation != o.screenOrientation) {
        screenOrientation = o.screenOrientation;
        changes |= SCREEN_ORIENTATION_CHANGED;
    }
    if (preferredRefreshRate != o.preferredRefreshRate) {
        preferredRefreshRate = o.preferredRefreshRate;
        changes |= PREFERRED_REFRESH_RATE_CHANGED;
    }
    if (preferredDisplayModeId != o.preferredDisplayModeId) {
        preferredDisplayModeId = o.preferredDisplayModeId;
        changes |= PREFERRED_DISPLAY_MODE_ID;
    }
    if (systemUiVisibility != o.systemUiVisibility || subtreeSystemUiVisibility != o.subtreeSystemUiVisibility) {
        systemUiVisibility = o.systemUiVisibility;
        subtreeSystemUiVisibility = o.subtreeSystemUiVisibility;
        changes |= SYSTEM_UI_VISIBILITY_CHANGED;
    }
    if (hasSystemUiListeners != o.hasSystemUiListeners) {
        hasSystemUiListeners = o.hasSystemUiListeners;
        changes |= SYSTEM_UI_LISTENER_CHANGED;
    }
    if (inputFeatures != o.inputFeatures) {
        inputFeatures = o.inputFeatures;
        changes |= INPUT_FEATURES_CHANGED;
    }
    if (userActivityTimeout != o.userActivityTimeout) {
        userActivityTimeout = o.userActivityTimeout;
        changes |= USER_ACTIVITY_TIMEOUT_CHANGED;
    }
    if (!surfaceInsets.equals(o.surfaceInsets)) {
        surfaceInsets.set(o.surfaceInsets);
        changes |= SURFACE_INSETS_CHANGED;
    }
    if (hasManualSurfaceInsets != o.hasManualSurfaceInsets) {
        hasManualSurfaceInsets = o.hasManualSurfaceInsets;
        changes |= SURFACE_INSETS_CHANGED;
    }
    if (needsMenuKey != o.needsMenuKey) {
        needsMenuKey = o.needsMenuKey;
        changes |= NEEDS_MENU_KEY_CHANGED;
    }
    return changes;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
400,<android.webkit.WebView: boolean overlayHorizontalScrollbar()>,22,23,<android.webkit.WebView: boolean overlayHorizontalScrollbar()>,<android.webkit.WebView: boolean overlayHorizontalScrollbar()>,0,"{
    checkThread();
    return mProvider.overlayHorizontalScrollbar();
}","{
    // The old implementation defaulted to true, so return true for consistency
    return true;
}",1,"/**
 * Gets whether horizontal scrollbar has overlay style.
 *
 * @return true if horizontal scrollbar has overlay style
 */
","/**
 * Gets whether horizontal scrollbar has overlay style.
 *
 * @deprecated This method is now obsolete.
 * @return true
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"1,4,5",1,"The method implementation changed from invoking a dependent API (mProvider.overlayHorizontalScrollbar()) to simply returning a constant value 'true', and the dependent API invocation is removed. Additionally, the method is marked as Deprecated in the new version. These changes make the code change type 1,4,5.","Since the method in the early version could potentially return different values depending on the state of mProvider.overlayHorizontalScrollbar(), but the late version always returns true regardless of any state, it could cause a compatibility issue by returning different values. The CI type is 1."
401,"<android.service.notification.NotificationListenerService.INotificationListenerWrapper: void onNotificationPosted(IStatusBarNotificationHolder,NotificationRankingUpdate)>",22,23,"<android.service.notification.NotificationListenerService.INotificationListenerWrapper: void onNotificationPosted(IStatusBarNotificationHolder,NotificationRankingUpdate)>","<android.service.notification.NotificationListenerService.INotificationListenerWrapper: void onNotificationPosted(IStatusBarNotificationHolder,NotificationRankingUpdate)>",0,"{
    StatusBarNotification sbn;
    try {
        sbn = sbnHolder.get();
    } catch (RemoteException e) {
        Log.w(TAG, ""onNotificationPosted: Error receiving StatusBarNotification"", e);
        return;
    }
    Notification.Builder.rebuild(getContext(), sbn.getNotification());
    // protect subclass from concurrent modifications of (@link mNotificationKeys}.
    synchronized (mWrapper) {
        applyUpdate(update);
        try {
            NotificationListenerService.this.onNotificationPosted(sbn, mRankingMap);
        } catch (Throwable t) {
            Log.w(TAG, ""Error running onNotificationPosted"", t);
        }
    }
}","{
    StatusBarNotification sbn;
    try {
        sbn = sbnHolder.get();
    } catch (RemoteException e) {
        Log.w(TAG, ""onNotificationPosted: Error receiving StatusBarNotification"", e);
        return;
    }
    try {
        Notification.Builder.rebuild(getContext(), sbn.getNotification());
        // convert icon metadata to legacy format for older clients
        createLegacyIconExtras(sbn.getNotification());
    } catch (IllegalArgumentException e) {
        // drop corrupt notification
        sbn = null;
        Log.w(TAG, ""onNotificationPosted: can't rebuild notification from "" + sbn.getPackageName());
    }
    // protect subclass from concurrent modifications of (@link mNotificationKeys}.
    synchronized (mWrapper) {
        applyUpdate(update);
        try {
            if (sbn != null) {
                NotificationListenerService.this.onNotificationPosted(sbn, mRankingMap);
            } else {
                // still pass along the ranking map, it may contain other information
                NotificationListenerService.this.onNotificationRankingUpdate(mRankingMap);
            }
        } catch (Throwable t) {
            Log.w(TAG, ""Error running onNotificationPosted"", t);
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,2,3,4","1,2","The late version includes a new try-catch block around Notification.Builder.rebuild and createLegacyIconExtras which can cause the method to return early and not post a notification by assigning null to sbn. Additionally, there is a new if-else block that changes how onNotificationPosted is invoked, or if it fails due to an IllegalArgumentException, invokes onNotificationRankingUpdate instead. Changes include return statement, exception handling statement, control dependency, and other statements, so the code change types are 1,2,3,4.","There are potential Compatibility Issues caused by different return values due to the new null check for sbn variable before calling onNotificationPosted as well as potential Compatibility Issues caused by different exception handling due to the additional IllegalArgumentException catch block. If an IllegalArgumentException occurs, previously a RuntimeException might propagate or arbitrary corrupted data might be used; now, the notification is explicitly dropped, and execution flow is altered to call onNotificationRankingUpdate instead. Thus, the CI types are 1 for the return value and 2 for the exception handling."
402,<android.hardware.camera2.impl.CameraCaptureSessionImpl: void close()>,22,23,<android.hardware.camera2.impl.CameraCaptureSessionImpl: void close()>,<android.hardware.camera2.impl.CameraCaptureSessionImpl: void close()>,0,"{
    if (mClosed) {
        if (VERBOSE)
            Log.v(TAG, mIdString + ""close - reentering"");
        return;
    }
    if (VERBOSE)
        Log.v(TAG, mIdString + ""close - first time"");
    mClosed = true;
    /*
         * Flush out any repeating request. Since camera is closed, no new requests
         * can be queued, and eventually the entire request queue will be drained.
         *
         * If the camera device was already closed, short circuit and do nothing; since
         * no more internal device callbacks will fire anyway.
         *
         * Otherwise, once stopRepeating is done, wait for camera to idle, then unconfigure the
         * camera. Once that's done, fire #onClosed.
         */
    try {
        mDeviceImpl.stopRepeating();
    } catch (IllegalStateException e) {
        // OK: Camera device may already be closed, nothing else to do
        Log.w(TAG, mIdString + ""The camera device was already closed: "", e);
        // TODO: Fire onClosed anytime we get the device onClosed or the ISE?
        // or just suppress the ISE only and rely onClosed.
        // Also skip any of the draining work if this is already closed.
        // Short-circuit; queue callback immediately and return
        mStateCallback.onClosed(this);
        return;
    } catch (CameraAccessException e) {
        // OK: close does not throw checked exceptions.
        Log.e(TAG, mIdString + ""Exception while stopping repeating: "", e);
    // TODO: call onError instead of onClosed if this happens
    }
    // If no sequences are pending, fire #onClosed immediately
    mSequenceDrainer.beginDrain();
}","{
    if (mClosed) {
        if (DEBUG)
            Log.v(TAG, mIdString + ""close - reentering"");
        return;
    }
    if (DEBUG)
        Log.v(TAG, mIdString + ""close - first time"");
    mClosed = true;
    /*
         * Flush out any repeating request. Since camera is closed, no new requests
         * can be queued, and eventually the entire request queue will be drained.
         *
         * If the camera device was already closed, short circuit and do nothing; since
         * no more internal device callbacks will fire anyway.
         *
         * Otherwise, once stopRepeating is done, wait for camera to idle, then unconfigure the
         * camera. Once that's done, fire #onClosed.
         */
    try {
        mDeviceImpl.stopRepeating();
    } catch (IllegalStateException e) {
        // OK: Camera device may already be closed, nothing else to do
        // TODO: Fire onClosed anytime we get the device onClosed or the ISE?
        // or just suppress the ISE only and rely onClosed.
        // Also skip any of the draining work if this is already closed.
        // Short-circuit; queue callback immediately and return
        mStateCallback.onClosed(this);
        return;
    } catch (CameraAccessException e) {
        // OK: close does not throw checked exceptions.
        Log.e(TAG, mIdString + ""Exception while stopping repeating: "", e);
    // TODO: call onError instead of onClosed if this happens
    }
    // If no sequences are pending, fire #onClosed immediately
    mSequenceDrainer.beginDrain();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The only change in the code is the use of the `DEBUG` flag instead of the `VERBOSE` flag in the logging statements. This is an example of an ""Other statement changed"" because it does not affect return statements, exception handling, control structures, or dependent APIs.","There is no Compatibility Issue since the change in the logging flag does not affect the method's behavior; it only affects the level of logging verbosity, which would not change the method's functionality or how it is used by clients."
403,<android.net.RouteInfo: boolean matches(InetAddress)>,22,23,<android.net.RouteInfo: boolean matches(InetAddress)>,<android.net.RouteInfo: boolean matches(InetAddress)>,0,"{
    if (destination == null)
        return false;
    // match the route destination and destination with prefix length
    InetAddress dstNet = NetworkUtils.getNetworkPart(destination, mDestination.getPrefixLength());
    return mDestination.getAddress().equals(dstNet);
}","{
    return mDestination.contains(destination);
}",1,"/**
 * Determines whether the destination and prefix of this route includes the specified
 * address.
 *
 * @param destination A {@link InetAddress} to test to see if it would match this route.
 * @return {@code true} if the destination and prefix length cover the given address.
 */
","/**
 * Determines whether the destination and prefix of this route includes the specified
 * address.
 *
 * @param destination A {@link InetAddress} to test to see if it would match this route.
 * @return {@code true} if the destination and prefix length cover the given address.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The early version implementation includes a null check for the destination, logic to get the network part of the destination address and a comparison for equality, while the late version directly utilizes a method call to 'mDestination.contains(destination)'. Since the logic of how the match is determined has changed and it relies on a different API (contains), the code change could be categorized as a Return statement change (1) and Dependent API change (5).","Due to the change in the method of checking for a match, from explicit logic in the early version to a single method call in the late version which presumably encapsulates the logic, the behavior can potentially be different. This means that for some input values, the early version could return a different result than the late version, thus causing a Compatibility Issue related to a potential different return value (1)."
406,<android.view.WindowManager.LayoutParams: String toString()>,22,23,<android.view.WindowManager.LayoutParams: String toString()>,<android.view.WindowManager.LayoutParams: String toString()>,0,"{
    StringBuilder sb = new StringBuilder(256);
    sb.append(""WM.LayoutParams{"");
    sb.append(""("");
    sb.append(x);
    sb.append(',');
    sb.append(y);
    sb.append("")("");
    sb.append((width == MATCH_PARENT ? ""fill"" : (width == WRAP_CONTENT ? ""wrap"" : width)));
    sb.append('x');
    sb.append((height == MATCH_PARENT ? ""fill"" : (height == WRAP_CONTENT ? ""wrap"" : height)));
    sb.append("")"");
    if (horizontalMargin != 0) {
        sb.append("" hm="");
        sb.append(horizontalMargin);
    }
    if (verticalMargin != 0) {
        sb.append("" vm="");
        sb.append(verticalMargin);
    }
    if (gravity != 0) {
        sb.append("" gr=#"");
        sb.append(Integer.toHexString(gravity));
    }
    if (softInputMode != 0) {
        sb.append("" sim=#"");
        sb.append(Integer.toHexString(softInputMode));
    }
    sb.append("" ty="");
    sb.append(type);
    sb.append("" fl=#"");
    sb.append(Integer.toHexString(flags));
    if (privateFlags != 0) {
        if ((privateFlags & PRIVATE_FLAG_COMPATIBLE_WINDOW) != 0) {
            sb.append("" compatible=true"");
        }
        sb.append("" pfl=0x"").append(Integer.toHexString(privateFlags));
    }
    if (format != PixelFormat.OPAQUE) {
        sb.append("" fmt="");
        sb.append(format);
    }
    if (windowAnimations != 0) {
        sb.append("" wanim=0x"");
        sb.append(Integer.toHexString(windowAnimations));
    }
    if (screenOrientation != ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED) {
        sb.append("" or="");
        sb.append(screenOrientation);
    }
    if (alpha != 1.0f) {
        sb.append("" alpha="");
        sb.append(alpha);
    }
    if (screenBrightness != BRIGHTNESS_OVERRIDE_NONE) {
        sb.append("" sbrt="");
        sb.append(screenBrightness);
    }
    if (buttonBrightness != BRIGHTNESS_OVERRIDE_NONE) {
        sb.append("" bbrt="");
        sb.append(buttonBrightness);
    }
    if (rotationAnimation != ROTATION_ANIMATION_ROTATE) {
        sb.append("" rotAnim="");
        sb.append(rotationAnimation);
    }
    if (preferredRefreshRate != 0) {
        sb.append("" preferredRefreshRate="");
        sb.append(preferredRefreshRate);
    }
    if (systemUiVisibility != 0) {
        sb.append("" sysui=0x"");
        sb.append(Integer.toHexString(systemUiVisibility));
    }
    if (subtreeSystemUiVisibility != 0) {
        sb.append("" vsysui=0x"");
        sb.append(Integer.toHexString(subtreeSystemUiVisibility));
    }
    if (hasSystemUiListeners) {
        sb.append("" sysuil="");
        sb.append(hasSystemUiListeners);
    }
    if (inputFeatures != 0) {
        sb.append("" if=0x"").append(Integer.toHexString(inputFeatures));
    }
    if (userActivityTimeout >= 0) {
        sb.append("" userActivityTimeout="").append(userActivityTimeout);
    }
    if (!surfaceInsets.equals(Insets.NONE)) {
        sb.append("" surfaceInsets="").append(surfaceInsets);
    }
    if (needsMenuKey != NEEDS_MENU_UNSET) {
        sb.append("" needsMenuKey="");
        sb.append(needsMenuKey);
    }
    sb.append('}');
    return sb.toString();
}","{
    StringBuilder sb = new StringBuilder(256);
    sb.append(""WM.LayoutParams{"");
    sb.append(""("");
    sb.append(x);
    sb.append(',');
    sb.append(y);
    sb.append("")("");
    sb.append((width == MATCH_PARENT ? ""fill"" : (width == WRAP_CONTENT ? ""wrap"" : width)));
    sb.append('x');
    sb.append((height == MATCH_PARENT ? ""fill"" : (height == WRAP_CONTENT ? ""wrap"" : height)));
    sb.append("")"");
    if (horizontalMargin != 0) {
        sb.append("" hm="");
        sb.append(horizontalMargin);
    }
    if (verticalMargin != 0) {
        sb.append("" vm="");
        sb.append(verticalMargin);
    }
    if (gravity != 0) {
        sb.append("" gr=#"");
        sb.append(Integer.toHexString(gravity));
    }
    if (softInputMode != 0) {
        sb.append("" sim=#"");
        sb.append(Integer.toHexString(softInputMode));
    }
    sb.append("" ty="");
    sb.append(type);
    sb.append("" fl=#"");
    sb.append(Integer.toHexString(flags));
    if (privateFlags != 0) {
        if ((privateFlags & PRIVATE_FLAG_COMPATIBLE_WINDOW) != 0) {
            sb.append("" compatible=true"");
        }
        sb.append("" pfl=0x"").append(Integer.toHexString(privateFlags));
    }
    if (format != PixelFormat.OPAQUE) {
        sb.append("" fmt="");
        sb.append(format);
    }
    if (windowAnimations != 0) {
        sb.append("" wanim=0x"");
        sb.append(Integer.toHexString(windowAnimations));
    }
    if (screenOrientation != ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED) {
        sb.append("" or="");
        sb.append(screenOrientation);
    }
    if (alpha != 1.0f) {
        sb.append("" alpha="");
        sb.append(alpha);
    }
    if (screenBrightness != BRIGHTNESS_OVERRIDE_NONE) {
        sb.append("" sbrt="");
        sb.append(screenBrightness);
    }
    if (buttonBrightness != BRIGHTNESS_OVERRIDE_NONE) {
        sb.append("" bbrt="");
        sb.append(buttonBrightness);
    }
    if (rotationAnimation != ROTATION_ANIMATION_ROTATE) {
        sb.append("" rotAnim="");
        sb.append(rotationAnimation);
    }
    if (preferredRefreshRate != 0) {
        sb.append("" preferredRefreshRate="");
        sb.append(preferredRefreshRate);
    }
    if (preferredDisplayModeId != 0) {
        sb.append("" preferredDisplayMode="");
        sb.append(preferredDisplayModeId);
    }
    if (systemUiVisibility != 0) {
        sb.append("" sysui=0x"");
        sb.append(Integer.toHexString(systemUiVisibility));
    }
    if (subtreeSystemUiVisibility != 0) {
        sb.append("" vsysui=0x"");
        sb.append(Integer.toHexString(subtreeSystemUiVisibility));
    }
    if (hasSystemUiListeners) {
        sb.append("" sysuil="");
        sb.append(hasSystemUiListeners);
    }
    if (inputFeatures != 0) {
        sb.append("" if=0x"").append(Integer.toHexString(inputFeatures));
    }
    if (userActivityTimeout >= 0) {
        sb.append("" userActivityTimeout="").append(userActivityTimeout);
    }
    if (surfaceInsets.left != 0 || surfaceInsets.top != 0 || surfaceInsets.right != 0 || surfaceInsets.bottom != 0 || hasManualSurfaceInsets) {
        sb.append("" surfaceInsets="").append(surfaceInsets);
        if (hasManualSurfaceInsets) {
            sb.append("" (manual)"");
        }
    }
    if (needsMenuKey != NEEDS_MENU_UNSET) {
        sb.append("" needsMenuKey="");
        sb.append(needsMenuKey);
    }
    sb.append('}');
    return sb.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
407,<android.content.AbstractThreadedSyncAdapter.SyncThread: void run()>,22,23,<android.content.AbstractThreadedSyncAdapter.SyncThread: void run()>,<android.content.AbstractThreadedSyncAdapter.SyncThread: void run()>,0,"{
    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
    // Trace this sync instance.  Note, conceptually this should be in
    // SyncStorageEngine.insertStartSyncEvent(), but the trace functions require unique
    // threads in order to track overlapping operations, so we'll do it here for now.
    Trace.traceBegin(Trace.TRACE_TAG_SYNC_MANAGER, mAuthority);
    SyncResult syncResult = new SyncResult();
    ContentProviderClient provider = null;
    try {
        if (isCanceled()) {
            return;
        }
        provider = mContext.getContentResolver().acquireContentProviderClient(mAuthority);
        if (provider != null) {
            AbstractThreadedSyncAdapter.this.onPerformSync(mAccount, mExtras, mAuthority, provider, syncResult);
        } else {
            syncResult.databaseError = true;
        }
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_SYNC_MANAGER);
        if (provider != null) {
            provider.release();
        }
        if (!isCanceled()) {
            mSyncContext.onFinished(syncResult);
        }
        // that also synchronize accesses to mSyncThreads
        synchronized (mSyncThreadLock) {
            mSyncThreads.remove(mThreadsKey);
        }
    }
}","{
    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
    // Trace this sync instance.  Note, conceptually this should be in
    // SyncStorageEngine.insertStartSyncEvent(), but the trace functions require unique
    // threads in order to track overlapping operations, so we'll do it here for now.
    Trace.traceBegin(Trace.TRACE_TAG_SYNC_MANAGER, mAuthority);
    SyncResult syncResult = new SyncResult();
    ContentProviderClient provider = null;
    try {
        if (isCanceled()) {
            return;
        }
        provider = mContext.getContentResolver().acquireContentProviderClient(mAuthority);
        if (provider != null) {
            AbstractThreadedSyncAdapter.this.onPerformSync(mAccount, mExtras, mAuthority, provider, syncResult);
        } else {
            syncResult.databaseError = true;
        }
    } catch (SecurityException e) {
        AbstractThreadedSyncAdapter.this.onSecurityException(mAccount, mExtras, mAuthority, syncResult);
        syncResult.databaseError = true;
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_SYNC_MANAGER);
        if (provider != null) {
            provider.release();
        }
        if (!isCanceled()) {
            mSyncContext.onFinished(syncResult);
        }
        // that also synchronize accesses to mSyncThreads
        synchronized (mSyncThreadLock) {
            mSyncThreads.remove(mThreadsKey);
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,2,2,"An exception handling statement for SecurityException has been introduced in the late version, so the change type is 2.","The addition of a new catch block for SecurityException means the late version API could throw a new exception that was not thrown in the early version. Therefore, a Compatibility Issue is present due to new exception handling, so the CI type is 2."
408,<android.content.pm.LauncherActivityInfo: Drawable getBadgedIcon(int)>,22,23,<android.content.pm.LauncherActivityInfo: Drawable getBadgedIcon(int)>,<android.content.pm.LauncherActivityInfo: Drawable getBadgedIcon(int)>,0,"{
    int iconRes = mActivityInfo.getIconResource();
    Resources resources = null;
    Drawable originalIcon = null;
    try {
        resources = mPm.getResourcesForApplication(mActivityInfo.applicationInfo);
        try {
            if (density != 0) {
                originalIcon = resources.getDrawableForDensity(iconRes, density);
            }
        } catch (Resources.NotFoundException e) {
        }
    } catch (NameNotFoundException nnfe) {
    }
    if (originalIcon == null) {
        originalIcon = mActivityInfo.loadIcon(mPm);
    }
    if (originalIcon instanceof BitmapDrawable) {
        return mPm.getUserBadgedIcon(originalIcon, mUser);
    } else {
        Log.e(TAG, ""Unable to create badged icon for "" + mActivityInfo);
    }
    return originalIcon;
}","{
    Drawable originalIcon = getOriginalIcon(density);
    if (originalIcon instanceof BitmapDrawable) {
        return mPm.getUserBadgedIcon(originalIcon, mUser);
    } else {
        Log.e(TAG, ""Unable to create badged icon for "" + mActivityInfo);
    }
    return originalIcon;
}",1,"/**
 * Returns the activity icon with badging appropriate for the profile.
 * @param density Optional density for the icon, or 0 to use the default density. Use
 * {@link DisplayMetrics} for DPI values.
 * @see DisplayMetrics
 * @return A badged icon for the activity.
 */
","/**
 * Returns the activity icon with badging appropriate for the profile.
 * @param density Optional density for the icon, or 0 to use the default density. Use
 * {@link DisplayMetrics} for DPI values.
 * @see DisplayMetrics
 * @return A badged icon for the activity.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The early version directly contains the code to fetch the icon, whereas the late version uses a method call getOriginalIcon(density) to achieve the same. This indicates that the implementation details have been abstrated into a separate method, which represents a change in the 'Other statement' type. However, since there are no details provided for getOriginalIcon(density) method, it cannot be determined if there have been any changes to its behavior, hence it is classified as type 5 indicating a potential 'Dependent API changed', assuming the new method is a dependent API that has been introduced in the late version.","Since the abstraction of the implementation details into a method does not inherently change the behavior of the getBadgedIcon(int) method itself (assuming the new method produces the same result as the inlined code it replaced), no compatibility issue can be directly inferred from the change described alone. Therefore, no compatibility issue is detected, provided that the outcome of getOriginalIcon(density) is consistent with the original inlined implementation."
409,"<android.hardware.camera2.marshal.impl.MarshalQueryableEnum: void registerEnumValues(Class<T>,int[])>",22,23,"<android.hardware.camera2.marshal.impl.MarshalQueryableEnum: void registerEnumValues(Class<T>,int[])>","<android.hardware.camera2.marshal.impl.MarshalQueryableEnum: void registerEnumValues(Class<T>,int[])>",0,"{
    if (enumType.getEnumConstants().length != values.length) {
        throw new IllegalArgumentException(""Expected values array to be the same size as the enumTypes values "" + values.length + "" for type "" + enumType);
    }
    if (VERBOSE) {
        Log.v(TAG, ""Registered enum values for type "" + enumType + "" values"");
    }
    sEnumValues.put(enumType, values);
}","{
    if (enumType.getEnumConstants().length != values.length) {
        throw new IllegalArgumentException(""Expected values array to be the same size as the enumTypes values "" + values.length + "" for type "" + enumType);
    }
    if (DEBUG) {
        Log.v(TAG, ""Registered enum values for type "" + enumType + "" values"");
    }
    sEnumValues.put(enumType, values);
}",1,"/**
 * Register a non-sequential set of values to be used with the marshal/unmarshal functions.
 *
 * <p>This enables get/set to correctly marshal the enum into a value that is C-compatible.</p>
 *
 * @param enumType The class for an enum
 * @param values A list of values mapping to the ordinals of the enum
 */
","/**
 * Register a non-sequential set of values to be used with the marshal/unmarshal functions.
 *
 * <p>This enables get/set to correctly marshal the enum into a value that is C-compatible.</p>
 *
 * @param enumType The class for an enum
 * @param values A list of values mapping to the ordinals of the enum
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change between the two versions is the condition for logging from VERBOSE to DEBUG. The execution flow and the outcomes of the method are not affected by this change; hence, it's classified under 4) Other statement changed.","There is no Compatibility Issue as the operational behavior of the function remains unchanged. The modification only affects the condition under which logging occurs and does not impact the return values or exception handlings of the method. Hence, the CI type is 0)."
410,"<android.transition.ArcMotion: Path getPath(float,float,float,float)>",22,23,"<android.transition.ArcMotion: Path getPath(float,float,float,float)>","<android.transition.ArcMotion: Path getPath(float,float,float,float)>",0,"{
    // Here's a little ascii art to show how this is calculated:
    // c---------- b
    // \        / |
    // \     d  |
    // \  /   e
    // a----f
    // This diagram assumes that the horizontal distance is less than the vertical
    // distance between The start point (a) and end point (b).
    // d is the midpoint between a and b. c is the center point of the circle with
    // This path is formed by assuming that start and end points are in
    // an arc on a circle. The end point is centered in the circle vertically
    // and start is a point on the circle.
    // Triangles bfa and bde form similar right triangles. The control points
    // for the cubic Bezier arc path are the midpoints between a and e and e and b.
    Path path = new Path();
    path.moveTo(startX, startY);
    float ex;
    float ey;
    if (startY == endY) {
        ex = (startX + endX) / 2;
        ey = startY + mMinimumHorizontalTangent * Math.abs(endX - startX) / 2;
    } else if (startX == endX) {
        ex = startX + mMinimumVerticalTangent * Math.abs(endY - startY) / 2;
        ey = (startY + endY) / 2;
    } else {
        float deltaX = endX - startX;
        // Y is inverted compared to diagram above.
        float deltaY = startY - endY;
        // hypotenuse squared.
        float h2 = deltaX * deltaX + deltaY * deltaY;
        // Midpoint between start and end
        float dx = (startX + endX) / 2;
        float dy = (startY + endY) / 2;
        // Distance squared between end point and mid point is (1/2 hypotenuse)^2
        float midDist2 = h2 * 0.25f;
        float minimumArcDist2 = 0;
        if (Math.abs(deltaX) < Math.abs(deltaY)) {
            // Similar triangles bfa and bde mean that (ab/fb = eb/bd)
            // Therefore, eb = ab * bd / fb
            // ab = hypotenuse
            // bd = hypotenuse/2
            // fb = deltaY
            float eDistY = h2 / (2 * deltaY);
            ey = endY + eDistY;
            ex = endX;
            minimumArcDist2 = midDist2 * mMinimumVerticalTangent * mMinimumVerticalTangent;
        } else {
            // Same as above, but flip X & Y
            float eDistX = h2 / (2 * deltaX);
            ex = endX + eDistX;
            ey = endY;
            minimumArcDist2 = midDist2 * mMinimumHorizontalTangent * mMinimumHorizontalTangent;
        }
        float arcDistX = dx - ex;
        float arcDistY = dy - ey;
        float arcDist2 = arcDistX * arcDistX + arcDistY * arcDistY;
        float maximumArcDist2 = midDist2 * mMaximumTangent * mMaximumTangent;
        float newArcDistance2 = 0;
        if (arcDist2 < minimumArcDist2) {
            newArcDistance2 = minimumArcDist2;
        } else if (arcDist2 > maximumArcDist2) {
            newArcDistance2 = maximumArcDist2;
        }
        if (newArcDistance2 != 0) {
            float ratio2 = newArcDistance2 / arcDist2;
            float ratio = FloatMath.sqrt(ratio2);
            ex = dx + (ratio * (ex - dx));
            ey = dy + (ratio * (ey - dy));
        }
    }
    float controlX1 = (startX + ex) / 2;
    float controlY1 = (startY + ey) / 2;
    float controlX2 = (ex + endX) / 2;
    float controlY2 = (ey + endY) / 2;
    path.cubicTo(controlX1, controlY1, controlX2, controlY2, endX, endY);
    return path;
}","{
    // Here's a little ascii art to show how this is calculated:
    // c---------- b
    // \        / |
    // \     d  |
    // \  /   e
    // a----f
    // This diagram assumes that the horizontal distance is less than the vertical
    // distance between The start point (a) and end point (b).
    // d is the midpoint between a and b. c is the center point of the circle with
    // This path is formed by assuming that start and end points are in
    // an arc on a circle. The end point is centered in the circle vertically
    // and start is a point on the circle.
    // Triangles bfa and bde form similar right triangles. The control points
    // for the cubic Bezier arc path are the midpoints between a and e and e and b.
    Path path = new Path();
    path.moveTo(startX, startY);
    float ex;
    float ey;
    if (startY == endY) {
        ex = (startX + endX) / 2;
        ey = startY + mMinimumHorizontalTangent * Math.abs(endX - startX) / 2;
    } else if (startX == endX) {
        ex = startX + mMinimumVerticalTangent * Math.abs(endY - startY) / 2;
        ey = (startY + endY) / 2;
    } else {
        float deltaX = endX - startX;
        // Y is inverted compared to diagram above.
        float deltaY = startY - endY;
        // hypotenuse squared.
        float h2 = deltaX * deltaX + deltaY * deltaY;
        // Midpoint between start and end
        float dx = (startX + endX) / 2;
        float dy = (startY + endY) / 2;
        // Distance squared between end point and mid point is (1/2 hypotenuse)^2
        float midDist2 = h2 * 0.25f;
        float minimumArcDist2 = 0;
        if (Math.abs(deltaX) < Math.abs(deltaY)) {
            // Similar triangles bfa and bde mean that (ab/fb = eb/bd)
            // Therefore, eb = ab * bd / fb
            // ab = hypotenuse
            // bd = hypotenuse/2
            // fb = deltaY
            float eDistY = h2 / (2 * deltaY);
            ey = endY + eDistY;
            ex = endX;
            minimumArcDist2 = midDist2 * mMinimumVerticalTangent * mMinimumVerticalTangent;
        } else {
            // Same as above, but flip X & Y
            float eDistX = h2 / (2 * deltaX);
            ex = endX + eDistX;
            ey = endY;
            minimumArcDist2 = midDist2 * mMinimumHorizontalTangent * mMinimumHorizontalTangent;
        }
        float arcDistX = dx - ex;
        float arcDistY = dy - ey;
        float arcDist2 = arcDistX * arcDistX + arcDistY * arcDistY;
        float maximumArcDist2 = midDist2 * mMaximumTangent * mMaximumTangent;
        float newArcDistance2 = 0;
        if (arcDist2 < minimumArcDist2) {
            newArcDistance2 = minimumArcDist2;
        } else if (arcDist2 > maximumArcDist2) {
            newArcDistance2 = maximumArcDist2;
        }
        if (newArcDistance2 != 0) {
            float ratio2 = newArcDistance2 / arcDist2;
            float ratio = (float) Math.sqrt(ratio2);
            ex = dx + (ratio * (ex - dx));
            ey = dy + (ratio * (ey - dy));
        }
    }
    float controlX1 = (startX + ex) / 2;
    float controlY1 = (startY + ey) / 2;
    float controlX2 = (ex + endX) / 2;
    float controlY2 = (ey + endY) / 2;
    path.cubicTo(controlX1, controlY1, controlX2, controlY2, endX, endY);
    return path;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
411,"<android.text.Layout: float measurePara(TextPaint,CharSequence,int,int)>",22,23,"<android.text.Layout: float measurePara(TextPaint,CharSequence,int,int)>","<android.text.Layout: float measurePara(TextPaint,CharSequence,int,int)>",0,"{
    MeasuredText mt = MeasuredText.obtain();
    TextLine tl = TextLine.obtain();
    try {
        mt.setPara(text, start, end, TextDirectionHeuristics.LTR);
        Directions directions;
        int dir;
        if (mt.mEasy) {
            directions = DIRS_ALL_LEFT_TO_RIGHT;
            dir = Layout.DIR_LEFT_TO_RIGHT;
        } else {
            directions = AndroidBidi.directions(mt.mDir, mt.mLevels, 0, mt.mChars, 0, mt.mLen);
            dir = mt.mDir;
        }
        char[] chars = mt.mChars;
        int len = mt.mLen;
        boolean hasTabs = false;
        TabStops tabStops = null;
        // leading margins should be taken into account when measuring a paragraph
        int margin = 0;
        if (text instanceof Spanned) {
            Spanned spanned = (Spanned) text;
            LeadingMarginSpan[] spans = getParagraphSpans(spanned, start, end, LeadingMarginSpan.class);
            for (LeadingMarginSpan lms : spans) {
                margin += lms.getLeadingMargin(true);
            }
        }
        for (int i = 0; i < len; ++i) {
            if (chars[i] == '\t') {
                hasTabs = true;
                if (text instanceof Spanned) {
                    Spanned spanned = (Spanned) text;
                    int spanEnd = spanned.nextSpanTransition(start, end, TabStopSpan.class);
                    TabStopSpan[] spans = getParagraphSpans(spanned, start, spanEnd, TabStopSpan.class);
                    if (spans.length > 0) {
                        tabStops = new TabStops(TAB_INCREMENT, spans);
                    }
                }
                break;
            }
        }
        tl.set(paint, text, start, end, dir, directions, hasTabs, tabStops);
        return margin + tl.metrics(null);
    } finally {
        TextLine.recycle(tl);
        MeasuredText.recycle(mt);
    }
}","{
    MeasuredText mt = MeasuredText.obtain();
    TextLine tl = TextLine.obtain();
    try {
        mt.setPara(text, start, end, TextDirectionHeuristics.LTR, null);
        Directions directions;
        int dir;
        if (mt.mEasy) {
            directions = DIRS_ALL_LEFT_TO_RIGHT;
            dir = Layout.DIR_LEFT_TO_RIGHT;
        } else {
            directions = AndroidBidi.directions(mt.mDir, mt.mLevels, 0, mt.mChars, 0, mt.mLen);
            dir = mt.mDir;
        }
        char[] chars = mt.mChars;
        int len = mt.mLen;
        boolean hasTabs = false;
        TabStops tabStops = null;
        // leading margins should be taken into account when measuring a paragraph
        int margin = 0;
        if (text instanceof Spanned) {
            Spanned spanned = (Spanned) text;
            LeadingMarginSpan[] spans = getParagraphSpans(spanned, start, end, LeadingMarginSpan.class);
            for (LeadingMarginSpan lms : spans) {
                margin += lms.getLeadingMargin(true);
            }
        }
        for (int i = 0; i < len; ++i) {
            if (chars[i] == '\t') {
                hasTabs = true;
                if (text instanceof Spanned) {
                    Spanned spanned = (Spanned) text;
                    int spanEnd = spanned.nextSpanTransition(start, end, TabStopSpan.class);
                    TabStopSpan[] spans = getParagraphSpans(spanned, start, spanEnd, TabStopSpan.class);
                    if (spans.length > 0) {
                        tabStops = new TabStops(TAB_INCREMENT, spans);
                    }
                }
                break;
            }
        }
        tl.set(paint, text, start, end, dir, directions, hasTabs, tabStops);
        return margin + tl.metrics(null);
    } finally {
        TextLine.recycle(tl);
        MeasuredText.recycle(mt);
    }
}",1,"/* package */
","/* package */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent API change occurs here where the call to mt.setPara has an additional null argument in the late version (mt.setPara(text, start, end, TextDirectionHeuristics.LTR, null);). No other code changes are present, so only code change type 5 applies.","The additional argument added is null, which is likely a placeholder for an optional argument that does not alter the behavior of setPara in any meaningful way. Therefore, this change should not cause any Compatibility Issue."
412,<android.content.pm.ResolveInfo: int getIconResource()>,22,23,<android.content.pm.ResolveInfo: int getIconResource()>,<android.content.pm.ResolveInfo: int getIconResource()>,0,"{
    if (noResourceId)
        return 0;
    if (icon != 0)
        return icon;
    final ComponentInfo ci = getComponentInfo();
    if (ci != null) {
        return ci.getIconResource();
    }
    return 0;
}","{
    if (noResourceId)
        return 0;
    return getIconResourceInternal();
}",1,"/**
 * Return the icon resource identifier to use for this match.  If the
 * match defines an icon, that is used; else if the activity defines
 * an icon, that is used; else, the application icon is used.
 *
 * @return The icon associated with this match.
 */
","/**
 * Return the icon resource identifier to use for this match.  If the
 * match defines an icon, that is used; else if the activity defines
 * an icon, that is used; else, the application icon is used.
 *
 * @return The icon associated with this match.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,5",1,"The late version of the code has removed two conditional checks and now directly calls a new method getIconResourceInternal(), which also suggests that the code depends on the changed dependent API. The control flow has been altered due to the removal of these conditions. The code change type is 3,5.","The removal of the condition checking for 'icon != 0' and the call to 'ci.getIconResource()' could lead to a return of a different value from the late version of the API. Since a direct method call has replaced these checks, the behavior of the API could potentially differ based on the new implementation of getIconResourceInternal(). Thus, the CI type is 1."
413,<android.app.ActivityManagerProxy: List<IAppTask> getAppTasks(String)>,22,23,<android.app.ActivityManagerProxy: List<IAppTask> getAppTasks(String)>,<android.app.ActivityManagerProxy: List<IAppTask> getAppTasks(String)>,0,"{
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    data.writeInterfaceToken(IActivityManager.descriptor);
    data.writeString(callingPackage);
    mRemote.transact(GET_APP_TASKS_TRANSACTION, data, reply, 0);
    reply.readException();
    ArrayList<IAppTask> list = null;
    int N = reply.readInt();
    if (N >= 0) {
        list = new ArrayList<IAppTask>();
        while (N > 0) {
            IAppTask task = IAppTask.Stub.asInterface(reply.readStrongBinder());
            list.add(task);
            N--;
        }
    }
    data.recycle();
    reply.recycle();
    return list;
}","{
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    data.writeInterfaceToken(IActivityManager.descriptor);
    data.writeString(callingPackage);
    mRemote.transact(GET_APP_TASKS_TRANSACTION, data, reply, 0);
    reply.readException();
    ArrayList<IAppTask> list = null;
    int N = reply.readInt();
    if (N >= 0) {
        list = new ArrayList<>();
        while (N > 0) {
            IAppTask task = IAppTask.Stub.asInterface(reply.readStrongBinder());
            list.add(task);
            N--;
        }
    }
    data.recycle();
    reply.recycle();
    return list;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,0,0,"There are no changes in the method body that affect the behavior; the only change is the removal of the generic type in the new ArrayList instantiation, which doesn't affect the executed code because it's inferred from the left side.","There are no compatibility issues since the executed bytecode will be the same. Java's type erasure means that the specific generic type is not enforced at runtime. Therefore, the change does not lead to any different behaviors in terms of return values, exception handling, or control flow."
414,<android.hardware.camera2.utils.TaskDrainer: void taskStarted(T)>,22,23,<android.hardware.camera2.utils.TaskDrainer: void taskStarted(T)>,<android.hardware.camera2.utils.TaskDrainer: void taskStarted(T)>,0,"{
    synchronized (mLock) {
        if (VERBOSE) {
            Log.v(TAG + ""["" + mName + ""]"", ""taskStarted "" + task);
        }
        if (mDraining) {
            throw new IllegalStateException(""Can't start more tasks after draining has begun"");
        }
        if (!mTaskSet.add(task)) {
            throw new IllegalStateException(""Task "" + task + "" was already started"");
        }
    }
}","{
    synchronized (mLock) {
        if (DEBUG) {
            Log.v(TAG + ""["" + mName + ""]"", ""taskStarted "" + task);
        }
        if (mDraining) {
            throw new IllegalStateException(""Can't start more tasks after draining has begun"");
        }
        if (!mTaskSet.add(task)) {
            throw new IllegalStateException(""Task "" + task + "" was already started"");
        }
    }
}",1,"/**
 * Mark an asynchronous task as having started.
 *
 * <p>A task cannot be started more than once without first having finished. Once
 * draining begins with {@link #beginDrain}, no new tasks can be started.</p>
 *
 * @param task a key to identify a task
 *
 * @see #taskFinished
 * @see #beginDrain
 *
 * @throws IllegalStateException
 * If attempting to start a task which is already started (and not finished),
 * or if attempting to start a task after draining has begun.
 */
","/**
 * Mark an asynchronous task as having started.
 *
 * <p>A task cannot be started more than once without first having finished. Once
 * draining begins with {@link #beginDrain}, no new tasks can be started.</p>
 *
 * @param task a key to identify a task
 *
 * @see #taskFinished
 * @see #beginDrain
 *
 * @throws IllegalStateException
 * If attempting to start a task which is already started (and not finished),
 * or if attempting to start a task after draining has begun.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"There is a change from VERBOSE to DEBUG which implies a logging level change. Since it's only impacting logging and doesn't affect the API's logic or outcome, the code change type is 4 (Other statement changed).","This change does not cause any potential compatibility issue since it does not affect the API's control flow or the data it handles. It's merely a change in the logging detail level, which does not manifest in the API's operational behavior. The API's input, output, and exception throwing conditions remain unchanged. Therefore, there is no compatibility issue."
415,"<android.os.MessageQueue: boolean enqueueMessage(Message,long)>",22,23,"<android.os.MessageQueue: boolean enqueueMessage(Message,long)>","<android.os.MessageQueue: boolean enqueueMessage(Message,long)>",0,"{
    if (msg.target == null) {
        throw new IllegalArgumentException(""Message must have a target."");
    }
    if (msg.isInUse()) {
        throw new IllegalStateException(msg + "" This message is already in use."");
    }
    synchronized (this) {
        if (mQuitting) {
            IllegalStateException e = new IllegalStateException(msg.target + "" sending message to a Handler on a dead thread"");
            Log.w(""MessageQueue"", e.getMessage(), e);
            msg.recycle();
            return false;
        }
        msg.markInUse();
        msg.when = when;
        Message p = mMessages;
        boolean needWake;
        if (p == null || when == 0 || when < p.when) {
            // New head, wake up the event queue if blocked.
            msg.next = p;
            mMessages = msg;
            needWake = mBlocked;
        } else {
            // Inserted within the middle of the queue.  Usually we don't have to wake
            // up the event queue unless there is a barrier at the head of the queue
            // and the message is the earliest asynchronous message in the queue.
            needWake = mBlocked && p.target == null && msg.isAsynchronous();
            Message prev;
            for (; ; ) {
                prev = p;
                p = p.next;
                if (p == null || when < p.when) {
                    break;
                }
                if (needWake && p.isAsynchronous()) {
                    needWake = false;
                }
            }
            // invariant: p == prev.next
            msg.next = p;
            prev.next = msg;
        }
        // We can assume mPtr != 0 because mQuitting is false.
        if (needWake) {
            nativeWake(mPtr);
        }
    }
    return true;
}","{
    if (msg.target == null) {
        throw new IllegalArgumentException(""Message must have a target."");
    }
    if (msg.isInUse()) {
        throw new IllegalStateException(msg + "" This message is already in use."");
    }
    synchronized (this) {
        if (mQuitting) {
            IllegalStateException e = new IllegalStateException(msg.target + "" sending message to a Handler on a dead thread"");
            Log.w(TAG, e.getMessage(), e);
            msg.recycle();
            return false;
        }
        msg.markInUse();
        msg.when = when;
        Message p = mMessages;
        boolean needWake;
        if (p == null || when == 0 || when < p.when) {
            // New head, wake up the event queue if blocked.
            msg.next = p;
            mMessages = msg;
            needWake = mBlocked;
        } else {
            // Inserted within the middle of the queue.  Usually we don't have to wake
            // up the event queue unless there is a barrier at the head of the queue
            // and the message is the earliest asynchronous message in the queue.
            needWake = mBlocked && p.target == null && msg.isAsynchronous();
            Message prev;
            for (; ; ) {
                prev = p;
                p = p.next;
                if (p == null || when < p.when) {
                    break;
                }
                if (needWake && p.isAsynchronous()) {
                    needWake = false;
                }
            }
            // invariant: p == prev.next
            msg.next = p;
            prev.next = msg;
        }
        // We can assume mPtr != 0 because mQuitting is false.
        if (needWake) {
            nativeWake(mPtr);
        }
    }
    return true;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,0,0,"The code between the early version and the late version of the API method android.os.MessageQueue.enqueueMessage(Message, long) has no changes.","There are no changes in the implementation, hence there is no potential for compatibility issues."
417,<android.widget.PopupWindow: void update()>,22,23,<android.widget.PopupWindow: void update()>,<android.widget.PopupWindow: void update()>,0,"{
    if (!isShowing() || mContentView == null) {
        return;
    }
    WindowManager.LayoutParams p = (WindowManager.LayoutParams) mPopupView.getLayoutParams();
    boolean update = false;
    final int newAnim = computeAnimationResource();
    if (newAnim != p.windowAnimations) {
        p.windowAnimations = newAnim;
        update = true;
    }
    final int newFlags = computeFlags(p.flags);
    if (newFlags != p.flags) {
        p.flags = newFlags;
        update = true;
    }
    if (update) {
        setLayoutDirectionFromAnchor();
        mWindowManager.updateViewLayout(mPopupView, p);
    }
}","{
    if (!isShowing() || mContentView == null) {
        return;
    }
    final WindowManager.LayoutParams p = (WindowManager.LayoutParams) mDecorView.getLayoutParams();
    boolean update = false;
    final int newAnim = computeAnimationResource();
    if (newAnim != p.windowAnimations) {
        p.windowAnimations = newAnim;
        update = true;
    }
    final int newFlags = computeFlags(p.flags);
    if (newFlags != p.flags) {
        p.flags = newFlags;
        update = true;
    }
    if (update) {
        setLayoutDirectionFromAnchor();
        mWindowManager.updateViewLayout(mDecorView, p);
    }
}",1,"/**
 * Updates the state of the popup window, if it is currently being displayed,
 * from the currently set state.  This includes:
 * {@link #setClippingEnabled(boolean)}, {@link #setFocusable(boolean)},
 * {@link #setIgnoreCheekPress()}, {@link #setInputMethodMode(int)},
 * {@link #setTouchable(boolean)}, and {@link #setAnimationStyle(int)}.
 */
","/**
 * Updates the state of the popup window, if it is currently being displayed,
 * from the currently set state.
 * <p>
 * This includes:
 * <ul>
 * <li>{@link #setClippingEnabled(boolean)}</li>
 * <li>{@link #setFocusable(boolean)}</li>
 * <li>{@link #setIgnoreCheekPress()}</li>
 * <li>{@link #setInputMethodMode(int)}</li>
 * <li>{@link #setTouchable(boolean)}</li>
 * <li>{@link #setAnimationStyle(int)}</li>
 * </ul>
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,5",0,"The variable `mPopupView` has been changed to `mDecorView`. This suggests that a dependent API has changed or the class property being used has been renamed, which is a type 5 change. Additionally, the control dependency within the method seems unchanged, but since the variable used within the control statement is changed, it would have a type 3 change.","There is no CI in this case, as none of the changes impact the method's behavior in terms of returning different values or throwing different exceptions. The method's control flow and logic remain the same; only the internal variable name is changed, which would not be observed by the method callers."
418,<android.content.ContentResolver: ContentProviderClient acquireContentProviderClient(String)>,22,23,<android.content.ContentResolver: ContentProviderClient acquireContentProviderClient(String)>,<android.content.ContentResolver: ContentProviderClient acquireContentProviderClient(String)>,0,"{
    IContentProvider provider = acquireProvider(name);
    if (provider != null) {
        return new ContentProviderClient(this, provider, true);
    }
    return null;
}","{
    Preconditions.checkNotNull(name, ""name"");
    IContentProvider provider = acquireProvider(name);
    if (provider != null) {
        return new ContentProviderClient(this, provider, true);
    }
    return null;
}",1,"/**
 * Returns a {@link ContentProviderClient} that is associated with the {@link ContentProvider}
 * with the authority of name, starting the provider if necessary. Returns
 * null if there is no provider associated wih the uri. The caller must indicate that they are
 * done with the provider by calling {@link ContentProviderClient#release} which will allow
 * the system to release the provider it it determines that there is no other reason for
 * keeping it active.
 * @param name specifies which provider should be acquired
 * @return a {@link ContentProviderClient} that is associated with the {@link ContentProvider}
 * with the authority of name or null if there isn't one.
 */
","/**
 * Returns a {@link ContentProviderClient} that is associated with the {@link ContentProvider}
 * with the authority of name, starting the provider if necessary. Returns
 * null if there is no provider associated wih the uri. The caller must indicate that they are
 * done with the provider by calling {@link ContentProviderClient#release} which will allow
 * the system to release the provider it it determines that there is no other reason for
 * keeping it active.
 * @param name specifies which provider should be acquired
 * @return a {@link ContentProviderClient} that is associated with the {@link ContentProvider}
 * with the authority of name or null if there isn't one.
 */
",-1,,[@Nullable],-1,-1,-1,-1,-1,-1,4,0,"The method implementation has added a pre-condition check for the 'name' parameter, so the change type is 4, which is 'Other statement changed.'","The added pre-condition check does not cause a Compatibility Issue since if 'name' is null, both the early and late versions would throw a NullPointerException (the former implicitly and the latter explicitly due to the Preconditions.checkNotNull). Hence, the behavior of the method in terms of what it returns or which exceptions it might throw does not change, and thus there is no Compatibility Issue, or CI type 0."
421,<android.app.FragmentManagerImpl: boolean popBackStackImmediate()>,22,23,<android.app.FragmentManagerImpl: boolean popBackStackImmediate()>,<android.app.FragmentManagerImpl: boolean popBackStackImmediate()>,0,"{
    checkStateLoss();
    executePendingTransactions();
    return popBackStackState(mActivity.mHandler, null, -1, 0);
}","{
    checkStateLoss();
    executePendingTransactions();
    return popBackStackState(mHost.getHandler(), null, -1, 0);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The change consists of replacing mActivity.mHandler with mHost.getHandler() in the call to popBackStackState, indicating a change in the dependent API. Therefore, the code change type is 5.","The change from mActivity.mHandler to mHost.getHandler() appears to be a refactoring to use a different way to obtain the Handler instance. As the signature of popBackStackState and its parameters remain unchanged, and assuming that mHost.getHandler() provides a Handler instance equivalent to mActivity.mHandler's role, there's no indication this would lead to different behavior of the popBackStackImmediate() method. Therefore, no Compatibility Issue is detected, and the CI type is 0."
422,<android.view.textservice.SpellCheckerSession.SpellCheckerSessionListenerImpl: void onServiceConnected(ISpellCheckerSession)>,22,23,<android.view.textservice.SpellCheckerSession.SpellCheckerSessionListenerImpl: void onServiceConnected(ISpellCheckerSession)>,<android.view.textservice.SpellCheckerSession.SpellCheckerSessionListenerImpl: void onServiceConnected(ISpellCheckerSession)>,0,"{
    synchronized (this) {
        mISpellCheckerSession = session;
        if (session.asBinder() instanceof Binder && mThread == null) {
            // If this is a local object, we need to do our own threading
            // to make sure we handle it asynchronously.
            mThread = new HandlerThread(""SpellCheckerSession"", Process.THREAD_PRIORITY_BACKGROUND);
            mThread.start();
            mAsyncHandler = new Handler(mThread.getLooper()) {

                @Override
                public void handleMessage(Message msg) {
                    SpellCheckerParams scp = (SpellCheckerParams) msg.obj;
                    processTask(scp.mSession, scp, true);
                }
            };
        }
        mOpened = true;
    }
    if (DBG)
        Log.d(TAG, ""onServiceConnected - Success"");
    while (!mPendingTasks.isEmpty()) {
        processTask(session, mPendingTasks.poll(), false);
    }
}","{
    synchronized (this) {
        switch(mState) {
            case STATE_WAIT_CONNECTION:
                // OK, go ahead.
                break;
            case STATE_CLOSED_BEFORE_CONNECTION:
                // in this connection. OK to ignore.
                if (DBG)
                    Log.i(TAG, ""ignoring onServiceConnected since the session is"" + "" already closed."");
                return;
            default:
                Log.e(TAG, ""ignoring onServiceConnected due to unexpected mState="" + stateToString(mState));
                return;
        }
        if (session == null) {
            Log.e(TAG, ""ignoring onServiceConnected due to session=null"");
            return;
        }
        mISpellCheckerSession = session;
        if (session.asBinder() instanceof Binder && mThread == null) {
            if (DBG)
                Log.d(TAG, ""starting HandlerThread in onServiceConnected."");
            // If this is a local object, we need to do our own threading
            // to make sure we handle it asynchronously.
            mThread = new HandlerThread(""SpellCheckerSession"", Process.THREAD_PRIORITY_BACKGROUND);
            mThread.start();
            mAsyncHandler = new Handler(mThread.getLooper()) {

                @Override
                public void handleMessage(Message msg) {
                    SpellCheckerParams scp = (SpellCheckerParams) msg.obj;
                    processTask(scp.mSession, scp, true);
                }
            };
        }
        mState = STATE_CONNECTED;
        if (DBG) {
            Log.d(TAG, ""processed onServiceConnected: mISpellCheckerSession.hashCode()=#"" + Integer.toHexString(mISpellCheckerSession.hashCode()) + "" mPendingTasks.size()="" + mPendingTasks.size());
        }
    }
    while (!mPendingTasks.isEmpty()) {
        processTask(session, mPendingTasks.poll(), false);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"2,3,4","1,2","The change includes the introduction of a switch statement with multiple cases, checking the session for null, and changing the state of the object. A debug log statement and an early return have been added. Due to these, the code changes include exception handling statement changed (2), control dependency changed (3), and other statements changed (4).","The new switch statement and null check for the session object could lead to early returns before the method modifications are applied, potentially causing a CI due to a different exception being thrown or an absence of an exception that was present in the previous version. Additionally, the change in control flow could lead to a CI because it might alter whether and how the subsequent code is executed, which includes returning without setting values that would be set after the while loop (CI type 1). Meanwhile, throwing an unchecked RuntimeException within a 'synchronized' statement changes the behavior in case of an error or invalid state; such a change could lead to clients of this API method being impacted by different exception-related side effects that they had not anticipated (CI type 2)."
423,"<android.inputmethodservice.InputMethodService: boolean onKeyUp(int,KeyEvent)>",22,23,"<android.inputmethodservice.InputMethodService: boolean onKeyUp(int,KeyEvent)>","<android.inputmethodservice.InputMethodService: boolean onKeyUp(int,KeyEvent)>",0,"{
    if (event.getKeyCode() == KeyEvent.KEYCODE_BACK && event.isTracking() && !event.isCanceled()) {
        return handleBack(true);
    }
    return doMovementKey(keyCode, event, MOVEMENT_UP);
}","{
    if (event.getKeyCode() == KeyEvent.KEYCODE_BACK) {
        final ExtractEditText eet = getExtractEditTextIfVisible();
        if (eet != null && eet.handleBackInTextActionModeIfNeeded(event)) {
            return true;
        }
        if (event.isTracking() && !event.isCanceled()) {
            return handleBack(true);
        }
    }
    return doMovementKey(keyCode, event, MOVEMENT_UP);
}",1,"/**
 * Override this to intercept key up events before they are processed by the
 * application.  If you return true, the application will not itself
 * process the event.  If you return false, the normal application processing
 * will occur as if the IME had not seen the event at all.
 *
 * <p>The default implementation intercepts {@link KeyEvent#KEYCODE_BACK
 * KeyEvent.KEYCODE_BACK} to hide the current IME UI if it is shown.  In
 * addition, in fullscreen mode only, it will consume DPAD movement
 * events to move the cursor in the extracted text view, not allowing
 * them to perform navigation in the underlying application.
 */
","/**
 * Override this to intercept key up events before they are processed by the
 * application.  If you return true, the application will not itself
 * process the event.  If you return false, the normal application processing
 * will occur as if the IME had not seen the event at all.
 *
 * <p>The default implementation intercepts {@link KeyEvent#KEYCODE_BACK
 * KeyEvent.KEYCODE_BACK} to hide the current IME UI if it is shown.  In
 * addition, in fullscreen mode only, it will consume DPAD movement
 * events to move the cursor in the extracted text view, not allowing
 * them to perform navigation in the underlying application.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"The control flow within the if statement checking KeyEvent.KEYCODE_BACK has been modified by adding an additional check for a visible ExtractEditText that can handle the back event. A new method call eet.handleBackInTextActionModeIfNeeded(event) has been introduced that can change the return value of the method, so the change type is 3.","The additional check and method call within the if statement could potentially result in a different return value when the back key is handled by the visible ExtractEditText. As a result, there may be a different behavior when the if condition is satisfied, leading to a different return value and a CI type of 1."
424,<android.hardware.camera2.impl.CameraCaptureSessionImpl.SequenceDrainListener: void onDrained()>,22,23,<android.hardware.camera2.impl.CameraCaptureSessionImpl.SequenceDrainListener: void onDrained()>,<android.hardware.camera2.impl.CameraCaptureSessionImpl.SequenceDrainListener: void onDrained()>,0,"{
    /*
             * No repeating request is set; and the capture queue has fully drained.
             *
             * If no captures were queued to begin with, and an abort was queued,
             * it's still possible to get another BUSY before the last IDLE.
             *
             * If the camera is already ""IDLE"" and no aborts are pending,
             * then the drain immediately finishes.
             */
    if (VERBOSE)
        Log.v(TAG, mIdString + ""onSequenceDrained"");
    mAbortDrainer.beginDrain();
}","{
    /*
             * No repeating request is set; and the capture queue has fully drained.
             *
             * If no captures were queued to begin with, and an abort was queued,
             * it's still possible to get another BUSY before the last IDLE.
             *
             * If the camera is already ""IDLE"" and no aborts are pending,
             * then the drain immediately finishes.
             */
    if (DEBUG)
        Log.v(TAG, mIdString + ""onSequenceDrained"");
    // Fire session close as soon as all sequences are complete.
    // We may still need to unconfigure the device, but a new session might be created
    // past this point, and notifications would then stop to this instance.
    mStateCallback.onClosed(CameraCaptureSessionImpl.this);
    // as we won't get state updates any more anyway.
    if (mSkipUnconfigure) {
        return;
    }
    mAbortDrainer.beginDrain();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"A conditional logging statement has changed from VERBOSE to DEBUG, and new statements have been added inside the method like mStateCallback.onClosed(CameraCaptureSessionImpl.this) and a conditional return. Given the nature of the inserted code segment, this is an Other statement changed type 4, and as the new 'if' condition introduces a new control flow, it's also a Control dependency changed type 3.","There is no Compatibility Issue detected because the method is void and has no return value that can be altered. The added statements are related to the sequence of operations (notifying state callback and conditionally skipping further execution), which do not change the method's expected outputs or exception handling capabilities for the calling code. The onClosed callback is a part of regular session lifecycle management and does not indicate any change in the behavior of the onDrained method itself from an external point of view. The addition of a conditional return based on mSkipUnconfigure does not affect the outward behavior or contract of the method since it's a void method and the condition pertains to internal flow control."
427,"<android.widget.Editor.SelectionStartHandleView: void updatePosition(float,float)>",22,23,"<android.widget.Editor.SelectionStartHandleView: void updatePosition(float,float)>","<android.widget.Editor.SelectionStartHandleView: void updatePosition(float,float)>",0,"{
    int offset = mTextView.getOffsetForPosition(x, y);
    // Handles can not cross and selection is at least one character
    final int selectionEnd = mTextView.getSelectionEnd();
    if (offset >= selectionEnd)
        offset = Math.max(0, selectionEnd - 1);
    positionAtCursorOffset(offset, false);
}","{
    final Layout layout = mTextView.getLayout();
    if (layout == null) {
        // HandleView will deal appropriately in positionAtCursorOffset when
        // layout is null.
        positionAndAdjustForCrossingHandles(mTextView.getOffsetForPosition(x, y));
        return;
    }
    if (mPreviousLineTouched == UNSET_LINE) {
        mPreviousLineTouched = mTextView.getLineAtCoordinate(y);
    }
    boolean positionCursor = false;
    final int selectionEnd = mTextView.getSelectionEnd();
    int currLine = getCurrentLineAdjustedForSlop(layout, mPreviousLineTouched, y);
    int initialOffset = mTextView.getOffsetAtCoordinate(currLine, x);
    if (initialOffset >= selectionEnd) {
        // Handles have crossed, bound it to the last selected line and
        // adjust by word / char as normal.
        currLine = layout.getLineForOffset(selectionEnd);
        initialOffset = mTextView.getOffsetAtCoordinate(currLine, x);
    }
    int offset = initialOffset;
    int end = getWordEnd(offset);
    int start = getWordStart(offset);
    if (mPrevX == UNSET_X_VALUE) {
        mPrevX = x;
    }
    final int selectionStart = mTextView.getSelectionStart();
    final boolean selectionStartRtl = layout.isRtlCharAt(selectionStart);
    final boolean atRtl = layout.isRtlCharAt(offset);
    final boolean isLvlBoundary = layout.isLevelBoundary(offset);
    boolean isExpanding;
    // the cursor at the current position.
    if (isLvlBoundary || (selectionStartRtl && !atRtl) || (!selectionStartRtl && atRtl)) {
        // We're on a boundary or this is the first direction change -- just update
        // to the current position.
        mLanguageDirectionChanged = true;
        mTouchWordDelta = 0.0f;
        positionAndAdjustForCrossingHandles(offset);
        return;
    } else if (mLanguageDirectionChanged && !isLvlBoundary) {
        // We've just moved past the boundary so update the position. After this we can
        // figure out if the user is expanding or shrinking to go by word or character.
        positionAndAdjustForCrossingHandles(offset);
        mTouchWordDelta = 0.0f;
        mLanguageDirectionChanged = false;
        return;
    } else {
        final float xDiff = x - mPrevX;
        if (atRtl) {
            isExpanding = xDiff > 0 || currLine > mPreviousLineTouched;
        } else {
            isExpanding = xDiff < 0 || currLine < mPreviousLineTouched;
        }
    }
    if (mTextView.getHorizontallyScrolling()) {
        if (positionNearEdgeOfScrollingView(x, atRtl) && (mTextView.getScrollX() != 0) && ((isExpanding && offset < selectionStart) || !isExpanding)) {
            // If we're expanding ensure that the offset is smaller than the
            // selection start, if the handle snapped to the word, the finger position
            // may be out of sync and we don't want the selection to jump back.
            mTouchWordDelta = 0.0f;
            final int nextOffset = atRtl ? layout.getOffsetToRightOf(mPreviousOffset) : layout.getOffsetToLeftOf(mPreviousOffset);
            positionAndAdjustForCrossingHandles(nextOffset);
            return;
        }
    }
    if (isExpanding) {
        // User is increasing the selection.
        if (!mInWord || currLine < mPrevLine) {
            // Sometimes words can be broken across lines (Chinese, hyphenation).
            // We still snap to the start of the word but we only use the letters on the
            // current line to determine if the user is far enough into the word to snap.
            int wordStartOnCurrLine = start;
            if (layout != null && layout.getLineForOffset(start) != currLine) {
                wordStartOnCurrLine = layout.getLineStart(currLine);
            }
            int offsetThresholdToSnap = end - ((end - wordStartOnCurrLine) / 2);
            if (offset <= offsetThresholdToSnap || currLine < mPrevLine) {
                // User is far enough into the word or on a different
                // line so we expand by word.
                offset = start;
            } else {
                offset = mPreviousOffset;
            }
        }
        if (layout != null && offset < initialOffset) {
            final float adjustedX = layout.getPrimaryHorizontal(offset);
            mTouchWordDelta = mTextView.convertToLocalHorizontalCoordinate(x) - adjustedX;
        } else {
            mTouchWordDelta = 0.0f;
        }
        positionCursor = true;
    } else {
        final int adjustedOffset = mTextView.getOffsetAtCoordinate(currLine, x - mTouchWordDelta);
        if (adjustedOffset > mPreviousOffset || currLine > mPrevLine) {
            // User is shrinking the selection.
            if (currLine > mPrevLine) {
                // We're on a different line, so we'll snap to word boundaries.
                offset = start;
                if (layout != null && offset < initialOffset) {
                    final float adjustedX = layout.getPrimaryHorizontal(offset);
                    mTouchWordDelta = mTextView.convertToLocalHorizontalCoordinate(x) - adjustedX;
                } else {
                    mTouchWordDelta = 0.0f;
                }
            } else {
                offset = adjustedOffset;
            }
            positionCursor = true;
        } else if (adjustedOffset < mPreviousOffset) {
            // Handle has jumped to the start of the word, and the user is moving
            // their finger towards the handle, the delta should be updated.
            mTouchWordDelta = mTextView.convertToLocalHorizontalCoordinate(x) - layout.getPrimaryHorizontal(mPreviousOffset);
        }
    }
    if (positionCursor) {
        mPreviousLineTouched = currLine;
        positionAndAdjustForCrossingHandles(offset);
    }
    mPrevX = x;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
428,<android.bluetooth.BluetoothAdapter: int getState()>,22,23,<android.bluetooth.BluetoothAdapter: int getState()>,<android.bluetooth.BluetoothAdapter: int getState()>,0,"{
    try {
        synchronized (mManagerCallback) {
            if (mService != null) {
                int state = mService.getState();
                if (VDBG)
                    Log.d(TAG, """" + hashCode() + "": getState(). Returning "" + state);
                return state;
            }
        // TODO(BT) there might be a small gap during STATE_TURNING_ON that
        // mService is null, handle that case
        }
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    if (DBG)
        Log.d(TAG, """" + hashCode() + "": getState() :  mService = null. Returning STATE_OFF"");
    return STATE_OFF;
}","{
    try {
        synchronized (mManagerCallback) {
            if (mService != null) {
                int state = mService.getState();
                if (VDBG)
                    Log.d(TAG, """" + hashCode() + "": getState(). Returning "" + state);
                // consider all internal states as OFF
                if (state == BluetoothAdapter.STATE_BLE_ON || state == BluetoothAdapter.STATE_BLE_TURNING_ON || state == BluetoothAdapter.STATE_BLE_TURNING_OFF) {
                    if (VDBG)
                        Log.d(TAG, ""Consider internal state as OFF"");
                    state = BluetoothAdapter.STATE_OFF;
                }
                return state;
            }
        // TODO(BT) there might be a small gap during STATE_TURNING_ON that
        // mService is null, handle that case
        }
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return STATE_OFF;
}",1,"/**
 * Get the current state of the local Bluetooth adapter.
 * <p>Possible return values are
 * {@link #STATE_OFF},
 * {@link #STATE_TURNING_ON},
 * {@link #STATE_ON},
 * {@link #STATE_TURNING_OFF}.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
 *
 * @return current state of Bluetooth adapter
 */
","/**
 * Get the current state of the local Bluetooth adapter.
 * <p>Possible return values are
 * {@link #STATE_OFF},
 * {@link #STATE_TURNING_ON},
 * {@link #STATE_ON},
 * {@link #STATE_TURNING_OFF}.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
 *
 * @return current state of Bluetooth adapter
 */
",-1,,"[@RequiresPermission(Manifest.permission.BLUETOOTH), @AdapterState]",-1,-1,-1,-1,-1,-1,"1,3",1,"There is an insertion of the control dependency which includes a condition that modifies the state before returning, and this results in the potential for the API to return different values. Hence, the change type is a combination of 1 and 3.","The change directly affects the return value of the method due to the added conditions that will map some states to `STATE_OFF`. Therefore, the late version of the method could return a different value than the early version, which constitutes a compatibility issue of type 1."
429,"<android.widget.ScrollView: void onMeasure(int,int)>",22,23,"<android.widget.ScrollView: void onMeasure(int,int)>","<android.widget.ScrollView: void onMeasure(int,int)>",0,"{
    super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    if (!mFillViewport) {
        return;
    }
    final int heightMode = MeasureSpec.getMode(heightMeasureSpec);
    if (heightMode == MeasureSpec.UNSPECIFIED) {
        return;
    }
    if (getChildCount() > 0) {
        final View child = getChildAt(0);
        int height = getMeasuredHeight();
        if (child.getMeasuredHeight() < height) {
            final FrameLayout.LayoutParams lp = (LayoutParams) child.getLayoutParams();
            int childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec, mPaddingLeft + mPaddingRight, lp.width);
            height -= mPaddingTop;
            height -= mPaddingBottom;
            int childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(height, MeasureSpec.EXACTLY);
            child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
        }
    }
}","{
    super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    if (!mFillViewport) {
        return;
    }
    final int heightMode = MeasureSpec.getMode(heightMeasureSpec);
    if (heightMode == MeasureSpec.UNSPECIFIED) {
        return;
    }
    if (getChildCount() > 0) {
        final View child = getChildAt(0);
        final int height = getMeasuredHeight();
        if (child.getMeasuredHeight() < height) {
            final int widthPadding;
            final int heightPadding;
            final FrameLayout.LayoutParams lp = (LayoutParams) child.getLayoutParams();
            final int targetSdkVersion = getContext().getApplicationInfo().targetSdkVersion;
            if (targetSdkVersion >= VERSION_CODES.M) {
                widthPadding = mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin;
                heightPadding = mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin;
            } else {
                widthPadding = mPaddingLeft + mPaddingRight;
                heightPadding = mPaddingTop + mPaddingBottom;
            }
            final int childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec, widthPadding, lp.width);
            final int childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(height - heightPadding, MeasureSpec.EXACTLY);
            child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The late version introduced variables for padding and added conditional logic based on the target SDK version, which affects the calculated paddings and measurement specs. These statements include the declarations of widthPadding and heightPadding, the conditional block that sets their values, and the modifications to the calculations for childWidthMeasureSpec and childHeightMeasureSpec. Therefore, the changes are classified under control dependency (due to new if condition) and other statement changes.","There is no compatibility issue since the behavior only changes for apps targeting SDK versions greater than or equal to VERSION_CODES.M. For applications targeting lower SDK versions, the behavior remains unchanged. Thus, existing applications which were compiled against an older target SDK would not experience a compatibility issue, as their code paths would not hit the new conditions. The ScrollView's behavior changes only for those explicitly targeting newer versions of the platform, which should be aware of the potential behavior changes due to version targeting. This is a common pattern in Android development used to preserve backward compatibility while allowing for new behavior for targeting newer SDKs."
431,"<android.widget.Editor.SelectionEndHandleView: void updatePosition(float,float)>",22,23,"<android.widget.Editor.SelectionEndHandleView: void updatePosition(float,float)>","<android.widget.Editor.SelectionEndHandleView: void updatePosition(float,float)>",0,"{
    int offset = mTextView.getOffsetForPosition(x, y);
    // Handles can not cross and selection is at least one character
    final int selectionStart = mTextView.getSelectionStart();
    if (offset <= selectionStart) {
        offset = Math.min(selectionStart + 1, mTextView.getText().length());
    }
    positionAtCursorOffset(offset, false);
}","{
    final Layout layout = mTextView.getLayout();
    if (layout == null) {
        // HandleView will deal appropriately in positionAtCursorOffset when
        // layout is null.
        positionAndAdjustForCrossingHandles(mTextView.getOffsetForPosition(x, y));
        return;
    }
    if (mPreviousLineTouched == UNSET_LINE) {
        mPreviousLineTouched = mTextView.getLineAtCoordinate(y);
    }
    boolean positionCursor = false;
    final int selectionStart = mTextView.getSelectionStart();
    int currLine = getCurrentLineAdjustedForSlop(layout, mPreviousLineTouched, y);
    int initialOffset = mTextView.getOffsetAtCoordinate(currLine, x);
    if (initialOffset <= selectionStart) {
        // Handles have crossed, bound it to the first selected line and
        // adjust by word / char as normal.
        currLine = layout.getLineForOffset(selectionStart);
        initialOffset = mTextView.getOffsetAtCoordinate(currLine, x);
    }
    int offset = initialOffset;
    int end = getWordEnd(offset);
    int start = getWordStart(offset);
    if (mPrevX == UNSET_X_VALUE) {
        mPrevX = x;
    }
    final int selectionEnd = mTextView.getSelectionEnd();
    final boolean selectionEndRtl = layout.isRtlCharAt(selectionEnd);
    final boolean atRtl = layout.isRtlCharAt(offset);
    final boolean isLvlBoundary = layout.isLevelBoundary(offset);
    boolean isExpanding;
    // the cursor at the current position.
    if (isLvlBoundary || (selectionEndRtl && !atRtl) || (!selectionEndRtl && atRtl)) {
        // We're on a boundary or this is the first direction change -- just update
        // to the current position.
        mLanguageDirectionChanged = true;
        mTouchWordDelta = 0.0f;
        positionAndAdjustForCrossingHandles(offset);
        return;
    } else if (mLanguageDirectionChanged && !isLvlBoundary) {
        // We've just moved past the boundary so update the position. After this we can
        // figure out if the user is expanding or shrinking to go by word or character.
        positionAndAdjustForCrossingHandles(offset);
        mTouchWordDelta = 0.0f;
        mLanguageDirectionChanged = false;
        return;
    } else {
        final float xDiff = x - mPrevX;
        if (atRtl) {
            isExpanding = xDiff < 0 || currLine < mPreviousLineTouched;
        } else {
            isExpanding = xDiff > 0 || currLine > mPreviousLineTouched;
        }
    }
    if (mTextView.getHorizontallyScrolling()) {
        if (positionNearEdgeOfScrollingView(x, atRtl) && mTextView.canScrollHorizontally(atRtl ? -1 : 1) && ((isExpanding && offset > selectionEnd) || !isExpanding)) {
            // If we're expanding ensure that the offset is actually greater than the
            // selection end, if the handle snapped to the word, the finger position
            // may be out of sync and we don't want the selection to jump back.
            mTouchWordDelta = 0.0f;
            final int nextOffset = atRtl ? layout.getOffsetToLeftOf(mPreviousOffset) : layout.getOffsetToRightOf(mPreviousOffset);
            positionAndAdjustForCrossingHandles(nextOffset);
            return;
        }
    }
    if (isExpanding) {
        // User is increasing the selection.
        if (!mInWord || currLine > mPrevLine) {
            // Sometimes words can be broken across lines (Chinese, hyphenation).
            // We still snap to the end of the word but we only use the letters on the
            // current line to determine if the user is far enough into the word to snap.
            int wordEndOnCurrLine = end;
            if (layout != null && layout.getLineForOffset(end) != currLine) {
                wordEndOnCurrLine = layout.getLineEnd(currLine);
            }
            final int offsetThresholdToSnap = start + ((wordEndOnCurrLine - start) / 2);
            if (offset >= offsetThresholdToSnap || currLine > mPrevLine) {
                // User is far enough into the word or on a different
                // line so we expand by word.
                offset = end;
            } else {
                offset = mPreviousOffset;
            }
        }
        if (offset > initialOffset) {
            final float adjustedX = layout.getPrimaryHorizontal(offset);
            mTouchWordDelta = adjustedX - mTextView.convertToLocalHorizontalCoordinate(x);
        } else {
            mTouchWordDelta = 0.0f;
        }
        positionCursor = true;
    } else {
        final int adjustedOffset = mTextView.getOffsetAtCoordinate(currLine, x + mTouchWordDelta);
        if (adjustedOffset < mPreviousOffset || currLine < mPrevLine) {
            // User is shrinking the selection.
            if (currLine < mPrevLine) {
                // We're on a different line, so we'll snap to word boundaries.
                offset = end;
                if (offset > initialOffset) {
                    final float adjustedX = layout.getPrimaryHorizontal(offset);
                    mTouchWordDelta = adjustedX - mTextView.convertToLocalHorizontalCoordinate(x);
                } else {
                    mTouchWordDelta = 0.0f;
                }
            } else {
                offset = adjustedOffset;
            }
            positionCursor = true;
        } else if (adjustedOffset > mPreviousOffset) {
            // Handle has jumped to the end of the word, and the user is moving
            // their finger towards the handle, the delta should be updated.
            mTouchWordDelta = layout.getPrimaryHorizontal(mPreviousOffset) - mTextView.convertToLocalHorizontalCoordinate(x);
        }
    }
    if (positionCursor) {
        mPreviousLineTouched = currLine;
        positionAndAdjustForCrossingHandles(offset);
    }
    mPrevX = x;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
432,"<android.widget.AbsListView: View obtainView(int,boolean[])>",22,23,"<android.widget.AbsListView: View obtainView(int,boolean[])>","<android.widget.AbsListView: View obtainView(int,boolean[])>",0,"{
    Trace.traceBegin(Trace.TRACE_TAG_VIEW, ""obtainView"");
    isScrap[0] = false;
    // Check whether we have a transient state view. Attempt to re-bind the
    // data and discard the view if we fail.
    final View transientView = mRecycler.getTransientStateView(position);
    if (transientView != null) {
        final LayoutParams params = (LayoutParams) transientView.getLayoutParams();
        // If the view type hasn't changed, attempt to re-bind the data.
        if (params.viewType == mAdapter.getItemViewType(position)) {
            final View updatedView = mAdapter.getView(position, transientView, this);
            // If we failed to re-bind the data, scrap the obtained view.
            if (updatedView != transientView) {
                setItemViewLayoutParams(updatedView, position);
                mRecycler.addScrapView(updatedView, position);
            }
        }
        // Scrap view implies temporary detachment.
        isScrap[0] = true;
        return transientView;
    }
    final View scrapView = mRecycler.getScrapView(position);
    final View child = mAdapter.getView(position, scrapView, this);
    if (scrapView != null) {
        if (child != scrapView) {
            // Failed to re-bind the data, return scrap to the heap.
            mRecycler.addScrapView(scrapView, position);
        } else {
            isScrap[0] = true;
            child.dispatchFinishTemporaryDetach();
        }
    }
    if (mCacheColorHint != 0) {
        child.setDrawingCacheBackgroundColor(mCacheColorHint);
    }
    if (child.getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
        child.setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);
    }
    setItemViewLayoutParams(child, position);
    if (AccessibilityManager.getInstance(mContext).isEnabled()) {
        if (mAccessibilityDelegate == null) {
            mAccessibilityDelegate = new ListItemAccessibilityDelegate();
        }
        if (child.getAccessibilityDelegate() == null) {
            child.setAccessibilityDelegate(mAccessibilityDelegate);
        }
    }
    Trace.traceEnd(Trace.TRACE_TAG_VIEW);
    return child;
}","{
    Trace.traceBegin(Trace.TRACE_TAG_VIEW, ""obtainView"");
    isScrap[0] = false;
    // Check whether we have a transient state view. Attempt to re-bind the
    // data and discard the view if we fail.
    final View transientView = mRecycler.getTransientStateView(position);
    if (transientView != null) {
        final LayoutParams params = (LayoutParams) transientView.getLayoutParams();
        // If the view type hasn't changed, attempt to re-bind the data.
        if (params.viewType == mAdapter.getItemViewType(position)) {
            final View updatedView = mAdapter.getView(position, transientView, this);
            // If we failed to re-bind the data, scrap the obtained view.
            if (updatedView != transientView) {
                setItemViewLayoutParams(updatedView, position);
                mRecycler.addScrapView(updatedView, position);
            }
        }
        isScrap[0] = true;
        // Finish the temporary detach started in addScrapView().
        transientView.dispatchFinishTemporaryDetach();
        return transientView;
    }
    final View scrapView = mRecycler.getScrapView(position);
    final View child = mAdapter.getView(position, scrapView, this);
    if (scrapView != null) {
        if (child != scrapView) {
            // Failed to re-bind the data, return scrap to the heap.
            mRecycler.addScrapView(scrapView, position);
        } else {
            isScrap[0] = true;
            // Finish the temporary detach started in addScrapView().
            child.dispatchFinishTemporaryDetach();
        }
    }
    if (mCacheColorHint != 0) {
        child.setDrawingCacheBackgroundColor(mCacheColorHint);
    }
    if (child.getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
        child.setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);
    }
    setItemViewLayoutParams(child, position);
    if (AccessibilityManager.getInstance(mContext).isEnabled()) {
        if (mAccessibilityDelegate == null) {
            mAccessibilityDelegate = new ListItemAccessibilityDelegate();
        }
        if (child.getAccessibilityDelegate() == null) {
            child.setAccessibilityDelegate(mAccessibilityDelegate);
        }
    }
    Trace.traceEnd(Trace.TRACE_TAG_VIEW);
    return child;
}",1,"/**
 * Get a view and have it show the data associated with the specified
 * position. This is called when we have already discovered that the view is
 * not available for reuse in the recycle bin. The only choices left are
 * converting an old view or making a new one.
 *
 * @param position The position to display
 * @param isScrap Array of at least 1 boolean, the first entry will become true if
 * the returned view was taken from the scrap heap, false if otherwise.
 *
 * @return A view displaying the data associated with the specified position
 */
","/**
 * Get a view and have it show the data associated with the specified
 * position. This is called when we have already discovered that the view is
 * not available for reuse in the recycle bin. The only choices left are
 * converting an old view or making a new one.
 *
 * @param position The position to display
 * @param isScrap Array of at least 1 boolean, the first entry will become true if
 * the returned view was taken from the scrap heap, false if otherwise.
 *
 * @return A view displaying the data associated with the specified position
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The code change consists of the removal of a conditional if block related to the 'updatedView' not being the same as 'transientView', and the addition of a statement `transientView.dispatchFinishTemporaryDetach()` outside of the earlier conditional block. Hence, the change types are 3 for Control dependency changed, and 4 for Other statement changed.","Even though statements have been moved and modified, the behavior of the method remains the same. There are no changes in return values or exception handlings that would lead to different behavior from the client code perspective. Therefore, there is no compatibility issue, and the CI type is 0."
433,"<android.accounts.AbstractAccountAuthenticator.Transport: void updateCredentials(IAccountAuthenticatorResponse,Account,String,Bundle)>",22,23,"<android.accounts.AbstractAccountAuthenticator.Transport: void updateCredentials(IAccountAuthenticatorResponse,Account,String,Bundle)>","<android.accounts.AbstractAccountAuthenticator.Transport: void updateCredentials(IAccountAuthenticatorResponse,Account,String,Bundle)>",0,"{
    if (Log.isLoggable(TAG, Log.VERBOSE)) {
        Log.v(TAG, ""updateCredentials: "" + account + "", authTokenType "" + authTokenType);
    }
    checkBinderPermission();
    try {
        final Bundle result = AbstractAccountAuthenticator.this.updateCredentials(new AccountAuthenticatorResponse(response), account, authTokenType, loginOptions);
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            // force it to be unparcelled
            result.keySet();
            Log.v(TAG, ""updateCredentials: result "" + AccountManager.sanitizeResult(result));
        }
        if (result != null) {
            response.onResult(result);
        }
    } catch (Exception e) {
        handleException(response, ""updateCredentials"", account.toString() + "","" + authTokenType, e);
    }
}","{
    if (Log.isLoggable(TAG, Log.VERBOSE)) {
        Log.v(TAG, ""updateCredentials: "" + account + "", authTokenType "" + authTokenType);
    }
    checkBinderPermission();
    try {
        final Bundle result = AbstractAccountAuthenticator.this.updateCredentials(new AccountAuthenticatorResponse(response), account, authTokenType, loginOptions);
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            // Result may be null.
            if (result != null) {
                // force it to be unparcelled
                result.keySet();
            }
            Log.v(TAG, ""updateCredentials: result "" + AccountManager.sanitizeResult(result));
        }
        if (result != null) {
            response.onResult(result);
        }
    } catch (Exception e) {
        handleException(response, ""updateCredentials"", account.toString() + "","" + authTokenType, e);
    }
}",1,,,-1,,[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"An ""if (result != null)"" check has been added before ""result.keySet()"" to prevent potential null pointer exceptions, which adds an additional control dependency. Also, a comment has been updated for clarity, which is not a structural code change but an ""other statement changed"". Hence, the code change types are 3 (control dependency change) and 4 (other statement changed).","There is no Compatibility Issue introduced by this change as the functional behavior of the API remains the same. The result is still produced in the same way and passed back with the same method call, and exception handling remains unchanged. The added null check simply ensures that a method is not called on a null object, which would not change the outcome for non-null results and prevents an exception for null cases that would have occurred in the earlier version already. Therefore, the CI classification is 0 (no Compatibility Issue)."
435,"<android.app.FragmentManagerImpl: Animator loadAnimator(Fragment,int,boolean,int)>",22,23,"<android.app.FragmentManagerImpl: Animator loadAnimator(Fragment,int,boolean,int)>","<android.app.FragmentManagerImpl: Animator loadAnimator(Fragment,int,boolean,int)>",0,"{
    Animator animObj = fragment.onCreateAnimator(transit, enter, fragment.mNextAnim);
    if (animObj != null) {
        return animObj;
    }
    if (fragment.mNextAnim != 0) {
        Animator anim = AnimatorInflater.loadAnimator(mActivity, fragment.mNextAnim);
        if (anim != null) {
            return anim;
        }
    }
    if (transit == 0) {
        return null;
    }
    int styleIndex = transitToStyleIndex(transit, enter);
    if (styleIndex < 0) {
        return null;
    }
    if (transitionStyle == 0 && mActivity.getWindow() != null) {
        transitionStyle = mActivity.getWindow().getAttributes().windowAnimations;
    }
    if (transitionStyle == 0) {
        return null;
    }
    TypedArray attrs = mActivity.obtainStyledAttributes(transitionStyle, com.android.internal.R.styleable.FragmentAnimation);
    int anim = attrs.getResourceId(styleIndex, 0);
    attrs.recycle();
    if (anim == 0) {
        return null;
    }
    return AnimatorInflater.loadAnimator(mActivity, anim);
}","{
    Animator animObj = fragment.onCreateAnimator(transit, enter, fragment.mNextAnim);
    if (animObj != null) {
        return animObj;
    }
    if (fragment.mNextAnim != 0) {
        Animator anim = AnimatorInflater.loadAnimator(mHost.getContext(), fragment.mNextAnim);
        if (anim != null) {
            return anim;
        }
    }
    if (transit == 0) {
        return null;
    }
    int styleIndex = transitToStyleIndex(transit, enter);
    if (styleIndex < 0) {
        return null;
    }
    if (transitionStyle == 0 && mHost.onHasWindowAnimations()) {
        transitionStyle = mHost.onGetWindowAnimations();
    }
    if (transitionStyle == 0) {
        return null;
    }
    TypedArray attrs = mHost.getContext().obtainStyledAttributes(transitionStyle, com.android.internal.R.styleable.FragmentAnimation);
    int anim = attrs.getResourceId(styleIndex, 0);
    attrs.recycle();
    if (anim == 0) {
        return null;
    }
    return AnimatorInflater.loadAnimator(mHost.getContext(), anim);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,5",0,"The code has changes in dependent API calls such as `AnimatorInflater.loadAnimator(mActivity, ...)` to `AnimatorInflater.loadAnimator(mHost.getContext(),...)` and `mActivity.getWindow()` to `mHost.onHasWindowAnimations()` and `mActivity.getWindow().getAttributes().windowAnimations` to `mHost.onGetWindowAnimations()`. These changes indicate that the animator is now being loaded using the host's context rather than the activity's context and the window animations are retrieved differently. This is classified under a change in control dependency (usage of host instead of activity for context) and also a change in the dependent API as the source of methods that provide context and window animations has changed from mActivity to mHost. Thus, the change type is 3,5.","There is no compatibility issue predicted in this scenario. The alterations do not change the logic of the method's execution flow, nor do they affect the expected return value of the method as long as the underlying contract of the `mHost.getContext()` and the `mHost` related window animation methods remains consistent with that of `mActivity`. The intermediary variables and checks for null or conditions remain the same, which suggests that even with re-routing of API calls from mActivity to mHost, if they are supposed to represent the same context/conditions, the behavior should be consistent with the previous implementation. Hence, the CI type is 0."
436,<android.hardware.camera2.impl.CameraDeviceImpl: Builder createCaptureRequest(int)>,22,23,<android.hardware.camera2.impl.CameraDeviceImpl: Builder createCaptureRequest(int)>,<android.hardware.camera2.impl.CameraDeviceImpl: Builder createCaptureRequest(int)>,0,"{
    synchronized (mInterfaceLock) {
        checkIfCameraClosedOrInError();
        CameraMetadataNative templatedRequest = new CameraMetadataNative();
        try {
            mRemoteDevice.createDefaultRequest(templateType, /*out*/
            templatedRequest);
        } catch (CameraRuntimeException e) {
            throw e.asChecked();
        } catch (RemoteException e) {
            // impossible
            return null;
        }
        CaptureRequest.Builder builder = new CaptureRequest.Builder(templatedRequest);
        return builder;
    }
}","{
    synchronized (mInterfaceLock) {
        checkIfCameraClosedOrInError();
        CameraMetadataNative templatedRequest = new CameraMetadataNative();
        try {
            mRemoteDevice.createDefaultRequest(templateType, /*out*/
            templatedRequest);
        } catch (CameraRuntimeException e) {
            throw e.asChecked();
        } catch (RemoteException e) {
            // impossible
            return null;
        }
        CaptureRequest.Builder builder = new CaptureRequest.Builder(templatedRequest, /*reprocess*/
        false, CameraCaptureSession.SESSION_ID_NONE);
        return builder;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"The way a `CaptureRequest.Builder` is instantiated has changed by adding new parameters to its constructor, even though the core functionality of creating a request stays the same. Therefore, the change type is 4,5 because the constructor call has changed and the dependent API, which is the constructor for `CaptureRequest.Builder`, has changed.","Since the constructor of `CaptureRequest.Builder` has additional parameters in the late version, it can potentially initialize the builder object differently, which could lead to a different return type or value (e.g., if the additional parameters influence the behavior of the builder). The CI type is 1 because of the potential for different returned values."
437,<android.os.Environment: boolean isExternalStorageRemovable(File)>,22,23,<android.os.Environment: boolean isExternalStorageRemovable(File)>,<android.os.Environment: boolean isExternalStorageRemovable(File)>,0,"{
    final StorageVolume volume = getStorageVolume(path);
    if (volume != null) {
        return volume.isRemovable();
    } else {
        throw new IllegalArgumentException(""Failed to find storage device at "" + path);
    }
}","{
    final StorageVolume volume = StorageManager.getStorageVolume(path, UserHandle.myUserId());
    if (volume != null) {
        return volume.isRemovable();
    } else {
        throw new IllegalArgumentException(""Failed to find storage device at "" + path);
    }
}",1,"/**
 * Returns whether the storage device that provides the given path is
 * removable.
 *
 * @return true if the storage device can be removed (such as an SD card),
 * or false if the storage device is built in and cannot be
 * physically removed.
 * @throws IllegalArgumentException if the path is not a valid storage
 * device.
 */
","/**
 * Returns whether the storage device that provides the given path is
 * removable.
 *
 * @return true if the storage device can be removed (such as an SD card),
 * or false if the storage device is built in and cannot be
 * physically removed.
 * @throws IllegalArgumentException if the path is not a valid storage
 * device.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method call within the first line has changed from getStorageVolume(path) to StorageManager.getStorageVolume(path, UserHandle.myUserId()). Though a new argument is introduced, the overall logic remains the same. This means the code change type is 4,5 (Other statement changed and Dependent API changed).","Despite the change in the method call, the behavior of the API has not altered in terms of return values or exception handling. It still returns the same boolean value based on the volume's removability and throws the same exception if the volume is not found. Therefore, there is no Compatibility Issue, and the CI type is 0."
438,"<android.app.Notification: void writeToParcel(Parcel,int)>",22,23,"<android.app.Notification: void writeToParcel(Parcel,int)>","<android.app.Notification: void writeToParcel(Parcel,int)>",0,"{
    parcel.writeInt(1);
    parcel.writeLong(when);
    parcel.writeInt(icon);
    parcel.writeInt(number);
    if (contentIntent != null) {
        parcel.writeInt(1);
        contentIntent.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    if (deleteIntent != null) {
        parcel.writeInt(1);
        deleteIntent.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    if (tickerText != null) {
        parcel.writeInt(1);
        TextUtils.writeToParcel(tickerText, parcel, flags);
    } else {
        parcel.writeInt(0);
    }
    if (tickerView != null) {
        parcel.writeInt(1);
        tickerView.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    if (contentView != null) {
        parcel.writeInt(1);
        contentView.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    if (largeIcon != null) {
        parcel.writeInt(1);
        largeIcon.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    parcel.writeInt(defaults);
    parcel.writeInt(this.flags);
    if (sound != null) {
        parcel.writeInt(1);
        sound.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    parcel.writeInt(audioStreamType);
    if (audioAttributes != null) {
        parcel.writeInt(1);
        audioAttributes.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    parcel.writeLongArray(vibrate);
    parcel.writeInt(ledARGB);
    parcel.writeInt(ledOnMS);
    parcel.writeInt(ledOffMS);
    parcel.writeInt(iconLevel);
    if (fullScreenIntent != null) {
        parcel.writeInt(1);
        fullScreenIntent.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    parcel.writeInt(priority);
    parcel.writeString(category);
    parcel.writeString(mGroupKey);
    parcel.writeString(mSortKey);
    // null ok
    parcel.writeBundle(extras);
    // null ok
    parcel.writeTypedArray(actions, 0);
    if (bigContentView != null) {
        parcel.writeInt(1);
        bigContentView.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    if (headsUpContentView != null) {
        parcel.writeInt(1);
        headsUpContentView.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    parcel.writeInt(visibility);
    if (publicVersion != null) {
        parcel.writeInt(1);
        publicVersion.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    parcel.writeInt(color);
}","{
    parcel.writeInt(1);
    parcel.writeLong(when);
    if (mSmallIcon == null && icon != 0) {
        // you snuck an icon in here without using the builder; let's try to keep it
        mSmallIcon = Icon.createWithResource("""", icon);
    }
    if (mSmallIcon != null) {
        parcel.writeInt(1);
        mSmallIcon.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    parcel.writeInt(number);
    if (contentIntent != null) {
        parcel.writeInt(1);
        contentIntent.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    if (deleteIntent != null) {
        parcel.writeInt(1);
        deleteIntent.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    if (tickerText != null) {
        parcel.writeInt(1);
        TextUtils.writeToParcel(tickerText, parcel, flags);
    } else {
        parcel.writeInt(0);
    }
    if (tickerView != null) {
        parcel.writeInt(1);
        tickerView.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    if (contentView != null) {
        parcel.writeInt(1);
        contentView.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    if (mLargeIcon != null) {
        parcel.writeInt(1);
        mLargeIcon.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    parcel.writeInt(defaults);
    parcel.writeInt(this.flags);
    if (sound != null) {
        parcel.writeInt(1);
        sound.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    parcel.writeInt(audioStreamType);
    if (audioAttributes != null) {
        parcel.writeInt(1);
        audioAttributes.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    parcel.writeLongArray(vibrate);
    parcel.writeInt(ledARGB);
    parcel.writeInt(ledOnMS);
    parcel.writeInt(ledOffMS);
    parcel.writeInt(iconLevel);
    if (fullScreenIntent != null) {
        parcel.writeInt(1);
        fullScreenIntent.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    parcel.writeInt(priority);
    parcel.writeString(category);
    parcel.writeString(mGroupKey);
    parcel.writeString(mSortKey);
    // null ok
    parcel.writeBundle(extras);
    // null ok
    parcel.writeTypedArray(actions, 0);
    if (bigContentView != null) {
        parcel.writeInt(1);
        bigContentView.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    if (headsUpContentView != null) {
        parcel.writeInt(1);
        headsUpContentView.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    parcel.writeInt(visibility);
    if (publicVersion != null) {
        parcel.writeInt(1);
        publicVersion.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    parcel.writeInt(color);
}",1,"/**
 * Flatten this notification from a parcel.
 */
","/**
 * Flatten this notification into a parcel.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
439,<android.net.NetworkCapabilities: String toString()>,22,23,<android.net.NetworkCapabilities: String toString()>,<android.net.NetworkCapabilities: String toString()>,0,"{
    int[] types = getTransportTypes();
    String transports = (types.length > 0 ? "" Transports: "" : """");
    for (int i = 0; i < types.length; ) {
        switch(types[i]) {
            case TRANSPORT_CELLULAR:
                transports += ""CELLULAR"";
                break;
            case TRANSPORT_WIFI:
                transports += ""WIFI"";
                break;
            case TRANSPORT_BLUETOOTH:
                transports += ""BLUETOOTH"";
                break;
            case TRANSPORT_ETHERNET:
                transports += ""ETHERNET"";
                break;
            case TRANSPORT_VPN:
                transports += ""VPN"";
                break;
        }
        if (++i < types.length)
            transports += ""|"";
    }
    types = getCapabilities();
    String capabilities = (types.length > 0 ? "" Capabilities: "" : """");
    for (int i = 0; i < types.length; ) {
        switch(types[i]) {
            case NET_CAPABILITY_MMS:
                capabilities += ""MMS"";
                break;
            case NET_CAPABILITY_SUPL:
                capabilities += ""SUPL"";
                break;
            case NET_CAPABILITY_DUN:
                capabilities += ""DUN"";
                break;
            case NET_CAPABILITY_FOTA:
                capabilities += ""FOTA"";
                break;
            case NET_CAPABILITY_IMS:
                capabilities += ""IMS"";
                break;
            case NET_CAPABILITY_CBS:
                capabilities += ""CBS"";
                break;
            case NET_CAPABILITY_WIFI_P2P:
                capabilities += ""WIFI_P2P"";
                break;
            case NET_CAPABILITY_IA:
                capabilities += ""IA"";
                break;
            case NET_CAPABILITY_RCS:
                capabilities += ""RCS"";
                break;
            case NET_CAPABILITY_XCAP:
                capabilities += ""XCAP"";
                break;
            case NET_CAPABILITY_EIMS:
                capabilities += ""EIMS"";
                break;
            case NET_CAPABILITY_NOT_METERED:
                capabilities += ""NOT_METERED"";
                break;
            case NET_CAPABILITY_INTERNET:
                capabilities += ""INTERNET"";
                break;
            case NET_CAPABILITY_NOT_RESTRICTED:
                capabilities += ""NOT_RESTRICTED"";
                break;
            case NET_CAPABILITY_TRUSTED:
                capabilities += ""TRUSTED"";
                break;
            case NET_CAPABILITY_NOT_VPN:
                capabilities += ""NOT_VPN"";
                break;
        }
        if (++i < types.length)
            capabilities += ""&"";
    }
    String upBand = ((mLinkUpBandwidthKbps > 0) ? "" LinkUpBandwidth>="" + mLinkUpBandwidthKbps + ""Kbps"" : """");
    String dnBand = ((mLinkDownBandwidthKbps > 0) ? "" LinkDnBandwidth>="" + mLinkDownBandwidthKbps + ""Kbps"" : """");
    String specifier = (mNetworkSpecifier == null ? """" : "" Specifier: <"" + mNetworkSpecifier + "">"");
    return ""["" + transports + capabilities + upBand + dnBand + specifier + ""]"";
}","{
    int[] types = getTransportTypes();
    String transports = (types.length > 0 ? "" Transports: "" : """");
    for (int i = 0; i < types.length; ) {
        switch(types[i]) {
            case TRANSPORT_CELLULAR:
                transports += ""CELLULAR"";
                break;
            case TRANSPORT_WIFI:
                transports += ""WIFI"";
                break;
            case TRANSPORT_BLUETOOTH:
                transports += ""BLUETOOTH"";
                break;
            case TRANSPORT_ETHERNET:
                transports += ""ETHERNET"";
                break;
            case TRANSPORT_VPN:
                transports += ""VPN"";
                break;
        }
        if (++i < types.length)
            transports += ""|"";
    }
    types = getCapabilities();
    String capabilities = (types.length > 0 ? "" Capabilities: "" : """");
    for (int i = 0; i < types.length; ) {
        switch(types[i]) {
            case NET_CAPABILITY_MMS:
                capabilities += ""MMS"";
                break;
            case NET_CAPABILITY_SUPL:
                capabilities += ""SUPL"";
                break;
            case NET_CAPABILITY_DUN:
                capabilities += ""DUN"";
                break;
            case NET_CAPABILITY_FOTA:
                capabilities += ""FOTA"";
                break;
            case NET_CAPABILITY_IMS:
                capabilities += ""IMS"";
                break;
            case NET_CAPABILITY_CBS:
                capabilities += ""CBS"";
                break;
            case NET_CAPABILITY_WIFI_P2P:
                capabilities += ""WIFI_P2P"";
                break;
            case NET_CAPABILITY_IA:
                capabilities += ""IA"";
                break;
            case NET_CAPABILITY_RCS:
                capabilities += ""RCS"";
                break;
            case NET_CAPABILITY_XCAP:
                capabilities += ""XCAP"";
                break;
            case NET_CAPABILITY_EIMS:
                capabilities += ""EIMS"";
                break;
            case NET_CAPABILITY_NOT_METERED:
                capabilities += ""NOT_METERED"";
                break;
            case NET_CAPABILITY_INTERNET:
                capabilities += ""INTERNET"";
                break;
            case NET_CAPABILITY_NOT_RESTRICTED:
                capabilities += ""NOT_RESTRICTED"";
                break;
            case NET_CAPABILITY_TRUSTED:
                capabilities += ""TRUSTED"";
                break;
            case NET_CAPABILITY_NOT_VPN:
                capabilities += ""NOT_VPN"";
                break;
            case NET_CAPABILITY_VALIDATED:
                capabilities += ""VALIDATED"";
                break;
            case NET_CAPABILITY_CAPTIVE_PORTAL:
                capabilities += ""CAPTIVE_PORTAL"";
                break;
        }
        if (++i < types.length)
            capabilities += ""&"";
    }
    String upBand = ((mLinkUpBandwidthKbps > 0) ? "" LinkUpBandwidth>="" + mLinkUpBandwidthKbps + ""Kbps"" : """");
    String dnBand = ((mLinkDownBandwidthKbps > 0) ? "" LinkDnBandwidth>="" + mLinkDownBandwidthKbps + ""Kbps"" : """");
    String specifier = (mNetworkSpecifier == null ? """" : "" Specifier: <"" + mNetworkSpecifier + "">"");
    return ""["" + transports + capabilities + upBand + dnBand + specifier + ""]"";
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
440,<android.text.style.TtsSpan: int getSpanTypeId()>,22,23,<android.text.style.TtsSpan: int getSpanTypeId()>,<android.text.style.TtsSpan: int getSpanTypeId()>,0,"{
    return TextUtils.TTS_SPAN;
}","{
    return getSpanTypeIdInternal();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,1,"The return statement has changed from directly returning a constant (TextUtils.TTS_SPAN) to calling a method (getSpanTypeIdInternal()), so the code change type is 5 because a dependent API is called.","The return value depends on what getSpanTypeIdInternal() returns, which could be different from the constant TextUtils.TTS_SPAN previously returned, so the CI type is 1, indicating a potential difference in returned value."
441,"<android.view.LayoutInflater: View inflate(XmlPullParser,ViewGroup,boolean)>",22,23,"<android.view.LayoutInflater: View inflate(XmlPullParser,ViewGroup,boolean)>","<android.view.LayoutInflater: View inflate(XmlPullParser,ViewGroup,boolean)>",0,"{
    synchronized (mConstructorArgs) {
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, ""inflate"");
        final AttributeSet attrs = Xml.asAttributeSet(parser);
        Context lastContext = (Context) mConstructorArgs[0];
        mConstructorArgs[0] = mContext;
        View result = root;
        try {
            // Look for the root node.
            int type;
            while ((type = parser.next()) != XmlPullParser.START_TAG && type != XmlPullParser.END_DOCUMENT) {
            // Empty
            }
            if (type != XmlPullParser.START_TAG) {
                throw new InflateException(parser.getPositionDescription() + "": No start tag found!"");
            }
            final String name = parser.getName();
            if (DEBUG) {
                System.out.println(""**************************"");
                System.out.println(""Creating root view: "" + name);
                System.out.println(""**************************"");
            }
            if (TAG_MERGE.equals(name)) {
                if (root == null || !attachToRoot) {
                    throw new InflateException(""<merge /> can be used only with a valid "" + ""ViewGroup root and attachToRoot=true"");
                }
                rInflate(parser, root, attrs, false, false);
            } else {
                // Temp is the root view that was found in the xml
                final View temp = createViewFromTag(root, name, attrs, false);
                ViewGroup.LayoutParams params = null;
                if (root != null) {
                    if (DEBUG) {
                        System.out.println(""Creating params from root: "" + root);
                    }
                    // Create layout params that match root, if supplied
                    params = root.generateLayoutParams(attrs);
                    if (!attachToRoot) {
                        // Set the layout params for temp if we are not
                        // attaching. (If we are, we use addView, below)
                        temp.setLayoutParams(params);
                    }
                }
                if (DEBUG) {
                    System.out.println(""-----> start inflating children"");
                }
                // Inflate all children under temp
                rInflate(parser, temp, attrs, true, true);
                if (DEBUG) {
                    System.out.println(""-----> done inflating children"");
                }
                // to root. Do that now.
                if (root != null && attachToRoot) {
                    root.addView(temp, params);
                }
                // top view found in xml.
                if (root == null || !attachToRoot) {
                    result = temp;
                }
            }
        } catch (XmlPullParserException e) {
            InflateException ex = new InflateException(e.getMessage());
            ex.initCause(e);
            throw ex;
        } catch (IOException e) {
            InflateException ex = new InflateException(parser.getPositionDescription() + "": "" + e.getMessage());
            ex.initCause(e);
            throw ex;
        } finally {
            // Don't retain static reference on context.
            mConstructorArgs[0] = lastContext;
            mConstructorArgs[1] = null;
        }
        Trace.traceEnd(Trace.TRACE_TAG_VIEW);
        return result;
    }
}","{
    synchronized (mConstructorArgs) {
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, ""inflate"");
        final Context inflaterContext = mContext;
        final AttributeSet attrs = Xml.asAttributeSet(parser);
        Context lastContext = (Context) mConstructorArgs[0];
        mConstructorArgs[0] = inflaterContext;
        View result = root;
        try {
            // Look for the root node.
            int type;
            while ((type = parser.next()) != XmlPullParser.START_TAG && type != XmlPullParser.END_DOCUMENT) {
            // Empty
            }
            if (type != XmlPullParser.START_TAG) {
                throw new InflateException(parser.getPositionDescription() + "": No start tag found!"");
            }
            final String name = parser.getName();
            if (DEBUG) {
                System.out.println(""**************************"");
                System.out.println(""Creating root view: "" + name);
                System.out.println(""**************************"");
            }
            if (TAG_MERGE.equals(name)) {
                if (root == null || !attachToRoot) {
                    throw new InflateException(""<merge /> can be used only with a valid "" + ""ViewGroup root and attachToRoot=true"");
                }
                rInflate(parser, root, inflaterContext, attrs, false);
            } else {
                // Temp is the root view that was found in the xml
                final View temp = createViewFromTag(root, name, inflaterContext, attrs);
                ViewGroup.LayoutParams params = null;
                if (root != null) {
                    if (DEBUG) {
                        System.out.println(""Creating params from root: "" + root);
                    }
                    // Create layout params that match root, if supplied
                    params = root.generateLayoutParams(attrs);
                    if (!attachToRoot) {
                        // Set the layout params for temp if we are not
                        // attaching. (If we are, we use addView, below)
                        temp.setLayoutParams(params);
                    }
                }
                if (DEBUG) {
                    System.out.println(""-----> start inflating children"");
                }
                // Inflate all children under temp against its context.
                rInflateChildren(parser, temp, attrs, true);
                if (DEBUG) {
                    System.out.println(""-----> done inflating children"");
                }
                // to root. Do that now.
                if (root != null && attachToRoot) {
                    root.addView(temp, params);
                }
                // top view found in xml.
                if (root == null || !attachToRoot) {
                    result = temp;
                }
            }
        } catch (XmlPullParserException e) {
            InflateException ex = new InflateException(e.getMessage());
            ex.initCause(e);
            throw ex;
        } catch (Exception e) {
            InflateException ex = new InflateException(parser.getPositionDescription() + "": "" + e.getMessage());
            ex.initCause(e);
            throw ex;
        } finally {
            // Don't retain static reference on context.
            mConstructorArgs[0] = lastContext;
            mConstructorArgs[1] = null;
        }
        Trace.traceEnd(Trace.TRACE_TAG_VIEW);
        return result;
    }
}",1,"/**
 * Inflate a new view hierarchy from the specified XML node. Throws
 * {@link InflateException} if there is an error.
 * <p>
 * <em><strong>Important</strong></em>&nbsp;&nbsp;&nbsp;For performance
 * reasons, view inflation relies heavily on pre-processing of XML files
 * that is done at build time. Therefore, it is not currently possible to
 * use LayoutInflater with an XmlPullParser over a plain XML file at runtime.
 *
 * @param parser XML dom node containing the description of the view
 * hierarchy.
 * @param root Optional view to be the parent of the generated hierarchy (if
 * <em>attachToRoot</em> is true), or else simply an object that
 * provides a set of LayoutParams values for root of the returned
 * hierarchy (if <em>attachToRoot</em> is false.)
 * @param attachToRoot Whether the inflated hierarchy should be attached to
 * the root parameter? If false, root is only used to create the
 * correct subclass of LayoutParams for the root view in the XML.
 * @return The root View of the inflated hierarchy. If root was supplied and
 * attachToRoot is true, this is root; otherwise it is the root of
 * the inflated XML file.
 */
","/**
 * Inflate a new view hierarchy from the specified XML node. Throws
 * {@link InflateException} if there is an error.
 * <p>
 * <em><strong>Important</strong></em>&nbsp;&nbsp;&nbsp;For performance
 * reasons, view inflation relies heavily on pre-processing of XML files
 * that is done at build time. Therefore, it is not currently possible to
 * use LayoutInflater with an XmlPullParser over a plain XML file at runtime.
 *
 * @param parser XML dom node containing the description of the view
 * hierarchy.
 * @param root Optional view to be the parent of the generated hierarchy (if
 * <em>attachToRoot</em> is true), or else simply an object that
 * provides a set of LayoutParams values for root of the returned
 * hierarchy (if <em>attachToRoot</em> is false.)
 * @param attachToRoot Whether the inflated hierarchy should be attached to
 * the root parameter? If false, root is only used to create the
 * correct subclass of LayoutParams for the root view in the XML.
 * @return The root View of the inflated hierarchy. If root was supplied and
 * attachToRoot is true, this is root; otherwise it is the root of
 * the inflated XML file.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
442,"<android.content.ContentResolver: void releasePersistableUriPermission(Uri,int)>",22,23,"<android.content.ContentResolver: void releasePersistableUriPermission(Uri,int)>","<android.content.ContentResolver: void releasePersistableUriPermission(Uri,int)>",0,"{
    try {
        ActivityManagerNative.getDefault().releasePersistableUriPermission(ContentProvider.getUriWithoutUserId(uri), modeFlags, resolveUserId(uri));
    } catch (RemoteException e) {
    }
}","{
    Preconditions.checkNotNull(uri, ""uri"");
    try {
        ActivityManagerNative.getDefault().releasePersistableUriPermission(ContentProvider.getUriWithoutUserId(uri), modeFlags, resolveUserId(uri));
    } catch (RemoteException e) {
    }
}",1,"/**
 * Relinquish a persisted URI permission grant. The URI must have been
 * previously made persistent with
 * {@link #takePersistableUriPermission(Uri, int)}. Any non-persistent
 * grants to the calling package will remain intact.
 *
 * @see #getPersistedUriPermissions()
 */
","/**
 * Relinquish a persisted URI permission grant. The URI must have been
 * previously made persistent with
 * {@link #takePersistableUriPermission(Uri, int)}. Any non-persistent
 * grants to the calling package will remain intact.
 *
 * @see #getPersistedUriPermissions()
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The addition of a Preconditions.checkNotNull(uri, ""uri"") call is the only code change, which is a precondition check and does not affect the method's behavior, so the code change type is 4.","Since Preconditions.checkNotNull(uri, ""uri"") only serves as a check and will raise a NullPointerException if the 'uri' is null, which would have resulted in an IllegalStateException within ActivityManagerNative.getDefault().releasePersistableUriPermission call in the early version anyway, there's no actual difference in how the exceptions are handled or the return behavior of the method. As such, there is no compatibility issue here, and the method behavior remains the same if it's called with the same arguments that meet the method's requirement (a non-null 'uri')."
443,<android.widget.ListView: void layoutChildren()>,22,23,<android.widget.ListView: void layoutChildren()>,<android.widget.ListView: void layoutChildren()>,0,"{
    final boolean blockLayoutRequests = mBlockLayoutRequests;
    if (blockLayoutRequests) {
        return;
    }
    mBlockLayoutRequests = true;
    try {
        super.layoutChildren();
        invalidate();
        if (mAdapter == null) {
            resetList();
            invokeOnItemScrollListener();
            return;
        }
        final int childrenTop = mListPadding.top;
        final int childrenBottom = mBottom - mTop - mListPadding.bottom;
        final int childCount = getChildCount();
        int index = 0;
        int delta = 0;
        View sel;
        View oldSel = null;
        View oldFirst = null;
        View newSel = null;
        // Remember stuff we will need down below
        switch(mLayoutMode) {
            case LAYOUT_SET_SELECTION:
                index = mNextSelectedPosition - mFirstPosition;
                if (index >= 0 && index < childCount) {
                    newSel = getChildAt(index);
                }
                break;
            case LAYOUT_FORCE_TOP:
            case LAYOUT_FORCE_BOTTOM:
            case LAYOUT_SPECIFIC:
            case LAYOUT_SYNC:
                break;
            case LAYOUT_MOVE_SELECTION:
            default:
                // Remember the previously selected view
                index = mSelectedPosition - mFirstPosition;
                if (index >= 0 && index < childCount) {
                    oldSel = getChildAt(index);
                }
                // Remember the previous first child
                oldFirst = getChildAt(0);
                if (mNextSelectedPosition >= 0) {
                    delta = mNextSelectedPosition - mSelectedPosition;
                }
                // Caution: newSel might be null
                newSel = getChildAt(index + delta);
        }
        boolean dataChanged = mDataChanged;
        if (dataChanged) {
            handleDataChanged();
        }
        // and calling it a day
        if (mItemCount == 0) {
            resetList();
            invokeOnItemScrollListener();
            return;
        } else if (mItemCount != mAdapter.getCount()) {
            throw new IllegalStateException(""The content of the adapter has changed but "" + ""ListView did not receive a notification. Make sure the content of "" + ""your adapter is not modified from a background thread, but only from "" + ""the UI thread. Make sure your adapter calls notifyDataSetChanged() "" + ""when its content changes. [in ListView("" + getId() + "", "" + getClass() + "") with Adapter("" + mAdapter.getClass() + "")]"");
        }
        setSelectedPositionInt(mNextSelectedPosition);
        AccessibilityNodeInfo accessibilityFocusLayoutRestoreNode = null;
        View accessibilityFocusLayoutRestoreView = null;
        int accessibilityFocusPosition = INVALID_POSITION;
        // Remember which child, if any, had accessibility focus. This must
        // occur before recycling any views, since that will clear
        // accessibility focus.
        final ViewRootImpl viewRootImpl = getViewRootImpl();
        if (viewRootImpl != null) {
            final View focusHost = viewRootImpl.getAccessibilityFocusedHost();
            if (focusHost != null) {
                final View focusChild = getAccessibilityFocusedChild(focusHost);
                if (focusChild != null) {
                    if (!dataChanged || isDirectChildHeaderOrFooter(focusChild) || focusChild.hasTransientState() || mAdapterHasStableIds) {
                        // The views won't be changing, so try to maintain
                        // focus on the current host and virtual view.
                        accessibilityFocusLayoutRestoreView = focusHost;
                        accessibilityFocusLayoutRestoreNode = viewRootImpl.getAccessibilityFocusedVirtualView();
                    }
                    // If all else fails, maintain focus at the same
                    // position.
                    accessibilityFocusPosition = getPositionForView(focusChild);
                }
            }
        }
        View focusLayoutRestoreDirectChild = null;
        View focusLayoutRestoreView = null;
        // Take focus back to us temporarily to avoid the eventual call to
        // clear focus when removing the focused child below from messing
        // things up when ViewAncestor assigns focus back to someone else.
        final View focusedChild = getFocusedChild();
        if (focusedChild != null) {
            // header or footer.
            if (!dataChanged || isDirectChildHeaderOrFooter(focusedChild)) {
                focusLayoutRestoreDirectChild = focusedChild;
                // Remember the specific view that had focus.
                focusLayoutRestoreView = findFocus();
                if (focusLayoutRestoreView != null) {
                    // Tell it we are going to mess with it.
                    focusLayoutRestoreView.onStartTemporaryDetach();
                }
            }
            requestFocus();
        }
        // Pull all children into the RecycleBin.
        // These views will be reused if possible
        final int firstPosition = mFirstPosition;
        final RecycleBin recycleBin = mRecycler;
        if (dataChanged) {
            for (int i = 0; i < childCount; i++) {
                recycleBin.addScrapView(getChildAt(i), firstPosition + i);
            }
        } else {
            recycleBin.fillActiveViews(childCount, firstPosition);
        }
        // Clear out old views
        detachAllViewsFromParent();
        recycleBin.removeSkippedScrap();
        switch(mLayoutMode) {
            case LAYOUT_SET_SELECTION:
                if (newSel != null) {
                    sel = fillFromSelection(newSel.getTop(), childrenTop, childrenBottom);
                } else {
                    sel = fillFromMiddle(childrenTop, childrenBottom);
                }
                break;
            case LAYOUT_SYNC:
                sel = fillSpecific(mSyncPosition, mSpecificTop);
                break;
            case LAYOUT_FORCE_BOTTOM:
                sel = fillUp(mItemCount - 1, childrenBottom);
                adjustViewsUpOrDown();
                break;
            case LAYOUT_FORCE_TOP:
                mFirstPosition = 0;
                sel = fillFromTop(childrenTop);
                adjustViewsUpOrDown();
                break;
            case LAYOUT_SPECIFIC:
                sel = fillSpecific(reconcileSelectedPosition(), mSpecificTop);
                break;
            case LAYOUT_MOVE_SELECTION:
                sel = moveSelection(oldSel, newSel, delta, childrenTop, childrenBottom);
                break;
            default:
                if (childCount == 0) {
                    if (!mStackFromBottom) {
                        final int position = lookForSelectablePosition(0, true);
                        setSelectedPositionInt(position);
                        sel = fillFromTop(childrenTop);
                    } else {
                        final int position = lookForSelectablePosition(mItemCount - 1, false);
                        setSelectedPositionInt(position);
                        sel = fillUp(mItemCount - 1, childrenBottom);
                    }
                } else {
                    if (mSelectedPosition >= 0 && mSelectedPosition < mItemCount) {
                        sel = fillSpecific(mSelectedPosition, oldSel == null ? childrenTop : oldSel.getTop());
                    } else if (mFirstPosition < mItemCount) {
                        sel = fillSpecific(mFirstPosition, oldFirst == null ? childrenTop : oldFirst.getTop());
                    } else {
                        sel = fillSpecific(0, childrenTop);
                    }
                }
                break;
        }
        // Flush any cached views that did not get reused above
        recycleBin.scrapActiveViews();
        if (sel != null) {
            // focusable.
            if (mItemsCanFocus && hasFocus() && !sel.hasFocus()) {
                final boolean focusWasTaken = (sel == focusLayoutRestoreDirectChild && focusLayoutRestoreView != null && focusLayoutRestoreView.requestFocus()) || sel.requestFocus();
                if (!focusWasTaken) {
                    // Selected item didn't take focus, but we still want to
                    // make sure something else outside of the selected view
                    // has focus.
                    final View focused = getFocusedChild();
                    if (focused != null) {
                        focused.clearFocus();
                    }
                    positionSelector(INVALID_POSITION, sel);
                } else {
                    sel.setSelected(false);
                    mSelectorRect.setEmpty();
                }
            } else {
                positionSelector(INVALID_POSITION, sel);
            }
            mSelectedTop = sel.getTop();
        } else {
            final boolean inTouchMode = mTouchMode == TOUCH_MODE_TAP || mTouchMode == TOUCH_MODE_DONE_WAITING;
            if (inTouchMode) {
                // If the user's finger is down, select the motion position.
                final View child = getChildAt(mMotionPosition - mFirstPosition);
                if (child != null) {
                    positionSelector(mMotionPosition, child);
                }
            } else if (mSelectorPosition != INVALID_POSITION) {
                // If we had previously positioned the selector somewhere,
                // put it back there. It might not match up with the data,
                // but it's transitioning out so it's not a big deal.
                final View child = getChildAt(mSelectorPosition - mFirstPosition);
                if (child != null) {
                    positionSelector(mSelectorPosition, child);
                }
            } else {
                // Otherwise, clear selection.
                mSelectedTop = 0;
                mSelectorRect.setEmpty();
            }
            // restore focus (i.e. something focusable in touch mode).
            if (hasFocus() && focusLayoutRestoreView != null) {
                focusLayoutRestoreView.requestFocus();
            }
        }
        // Attempt to restore accessibility focus, if necessary.
        if (viewRootImpl != null) {
            final View newAccessibilityFocusedView = viewRootImpl.getAccessibilityFocusedHost();
            if (newAccessibilityFocusedView == null) {
                if (accessibilityFocusLayoutRestoreView != null && accessibilityFocusLayoutRestoreView.isAttachedToWindow()) {
                    final AccessibilityNodeProvider provider = accessibilityFocusLayoutRestoreView.getAccessibilityNodeProvider();
                    if (accessibilityFocusLayoutRestoreNode != null && provider != null) {
                        final int virtualViewId = AccessibilityNodeInfo.getVirtualDescendantId(accessibilityFocusLayoutRestoreNode.getSourceNodeId());
                        provider.performAction(virtualViewId, AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS, null);
                    } else {
                        accessibilityFocusLayoutRestoreView.requestAccessibilityFocus();
                    }
                } else if (accessibilityFocusPosition != INVALID_POSITION) {
                    // Bound the position within the visible children.
                    final int position = MathUtils.constrain(accessibilityFocusPosition - mFirstPosition, 0, getChildCount() - 1);
                    final View restoreView = getChildAt(position);
                    if (restoreView != null) {
                        restoreView.requestAccessibilityFocus();
                    }
                }
            }
        }
        // our view hierarchy.
        if (focusLayoutRestoreView != null && focusLayoutRestoreView.getWindowToken() != null) {
            focusLayoutRestoreView.onFinishTemporaryDetach();
        }
        mLayoutMode = LAYOUT_NORMAL;
        mDataChanged = false;
        if (mPositionScrollAfterLayout != null) {
            post(mPositionScrollAfterLayout);
            mPositionScrollAfterLayout = null;
        }
        mNeedSync = false;
        setNextSelectedPositionInt(mSelectedPosition);
        updateScrollIndicators();
        if (mItemCount > 0) {
            checkSelectionChanged();
        }
        invokeOnItemScrollListener();
    } finally {
        if (!blockLayoutRequests) {
            mBlockLayoutRequests = false;
        }
    }
}","{
    final boolean blockLayoutRequests = mBlockLayoutRequests;
    if (blockLayoutRequests) {
        return;
    }
    mBlockLayoutRequests = true;
    try {
        super.layoutChildren();
        invalidate();
        if (mAdapter == null) {
            resetList();
            invokeOnItemScrollListener();
            return;
        }
        final int childrenTop = mListPadding.top;
        final int childrenBottom = mBottom - mTop - mListPadding.bottom;
        final int childCount = getChildCount();
        int index = 0;
        int delta = 0;
        View sel;
        View oldSel = null;
        View oldFirst = null;
        View newSel = null;
        // Remember stuff we will need down below
        switch(mLayoutMode) {
            case LAYOUT_SET_SELECTION:
                index = mNextSelectedPosition - mFirstPosition;
                if (index >= 0 && index < childCount) {
                    newSel = getChildAt(index);
                }
                break;
            case LAYOUT_FORCE_TOP:
            case LAYOUT_FORCE_BOTTOM:
            case LAYOUT_SPECIFIC:
            case LAYOUT_SYNC:
                break;
            case LAYOUT_MOVE_SELECTION:
            default:
                // Remember the previously selected view
                index = mSelectedPosition - mFirstPosition;
                if (index >= 0 && index < childCount) {
                    oldSel = getChildAt(index);
                }
                // Remember the previous first child
                oldFirst = getChildAt(0);
                if (mNextSelectedPosition >= 0) {
                    delta = mNextSelectedPosition - mSelectedPosition;
                }
                // Caution: newSel might be null
                newSel = getChildAt(index + delta);
        }
        boolean dataChanged = mDataChanged;
        if (dataChanged) {
            handleDataChanged();
        }
        // and calling it a day
        if (mItemCount == 0) {
            resetList();
            invokeOnItemScrollListener();
            return;
        } else if (mItemCount != mAdapter.getCount()) {
            throw new IllegalStateException(""The content of the adapter has changed but "" + ""ListView did not receive a notification. Make sure the content of "" + ""your adapter is not modified from a background thread, but only from "" + ""the UI thread. Make sure your adapter calls notifyDataSetChanged() "" + ""when its content changes. [in ListView("" + getId() + "", "" + getClass() + "") with Adapter("" + mAdapter.getClass() + "")]"");
        }
        setSelectedPositionInt(mNextSelectedPosition);
        AccessibilityNodeInfo accessibilityFocusLayoutRestoreNode = null;
        View accessibilityFocusLayoutRestoreView = null;
        int accessibilityFocusPosition = INVALID_POSITION;
        // Remember which child, if any, had accessibility focus. This must
        // occur before recycling any views, since that will clear
        // accessibility focus.
        final ViewRootImpl viewRootImpl = getViewRootImpl();
        if (viewRootImpl != null) {
            final View focusHost = viewRootImpl.getAccessibilityFocusedHost();
            if (focusHost != null) {
                final View focusChild = getAccessibilityFocusedChild(focusHost);
                if (focusChild != null) {
                    if (!dataChanged || isDirectChildHeaderOrFooter(focusChild) || focusChild.hasTransientState() || mAdapterHasStableIds) {
                        // The views won't be changing, so try to maintain
                        // focus on the current host and virtual view.
                        accessibilityFocusLayoutRestoreView = focusHost;
                        accessibilityFocusLayoutRestoreNode = viewRootImpl.getAccessibilityFocusedVirtualView();
                    }
                    // If all else fails, maintain focus at the same
                    // position.
                    accessibilityFocusPosition = getPositionForView(focusChild);
                }
            }
        }
        View focusLayoutRestoreDirectChild = null;
        View focusLayoutRestoreView = null;
        // Take focus back to us temporarily to avoid the eventual call to
        // clear focus when removing the focused child below from messing
        // things up when ViewAncestor assigns focus back to someone else.
        final View focusedChild = getFocusedChild();
        if (focusedChild != null) {
            // header or footer.
            if (!dataChanged || isDirectChildHeaderOrFooter(focusedChild) || focusedChild.hasTransientState() || mAdapterHasStableIds) {
                focusLayoutRestoreDirectChild = focusedChild;
                // Remember the specific view that had focus.
                focusLayoutRestoreView = findFocus();
                if (focusLayoutRestoreView != null) {
                    // Tell it we are going to mess with it.
                    focusLayoutRestoreView.onStartTemporaryDetach();
                }
            }
            requestFocus();
        }
        // Pull all children into the RecycleBin.
        // These views will be reused if possible
        final int firstPosition = mFirstPosition;
        final RecycleBin recycleBin = mRecycler;
        if (dataChanged) {
            for (int i = 0; i < childCount; i++) {
                recycleBin.addScrapView(getChildAt(i), firstPosition + i);
            }
        } else {
            recycleBin.fillActiveViews(childCount, firstPosition);
        }
        // Clear out old views
        detachAllViewsFromParent();
        recycleBin.removeSkippedScrap();
        switch(mLayoutMode) {
            case LAYOUT_SET_SELECTION:
                if (newSel != null) {
                    sel = fillFromSelection(newSel.getTop(), childrenTop, childrenBottom);
                } else {
                    sel = fillFromMiddle(childrenTop, childrenBottom);
                }
                break;
            case LAYOUT_SYNC:
                sel = fillSpecific(mSyncPosition, mSpecificTop);
                break;
            case LAYOUT_FORCE_BOTTOM:
                sel = fillUp(mItemCount - 1, childrenBottom);
                adjustViewsUpOrDown();
                break;
            case LAYOUT_FORCE_TOP:
                mFirstPosition = 0;
                sel = fillFromTop(childrenTop);
                adjustViewsUpOrDown();
                break;
            case LAYOUT_SPECIFIC:
                sel = fillSpecific(reconcileSelectedPosition(), mSpecificTop);
                break;
            case LAYOUT_MOVE_SELECTION:
                sel = moveSelection(oldSel, newSel, delta, childrenTop, childrenBottom);
                break;
            default:
                if (childCount == 0) {
                    if (!mStackFromBottom) {
                        final int position = lookForSelectablePosition(0, true);
                        setSelectedPositionInt(position);
                        sel = fillFromTop(childrenTop);
                    } else {
                        final int position = lookForSelectablePosition(mItemCount - 1, false);
                        setSelectedPositionInt(position);
                        sel = fillUp(mItemCount - 1, childrenBottom);
                    }
                } else {
                    if (mSelectedPosition >= 0 && mSelectedPosition < mItemCount) {
                        sel = fillSpecific(mSelectedPosition, oldSel == null ? childrenTop : oldSel.getTop());
                    } else if (mFirstPosition < mItemCount) {
                        sel = fillSpecific(mFirstPosition, oldFirst == null ? childrenTop : oldFirst.getTop());
                    } else {
                        sel = fillSpecific(0, childrenTop);
                    }
                }
                break;
        }
        // Flush any cached views that did not get reused above
        recycleBin.scrapActiveViews();
        if (sel != null) {
            // focusable.
            if (mItemsCanFocus && hasFocus() && !sel.hasFocus()) {
                final boolean focusWasTaken = (sel == focusLayoutRestoreDirectChild && focusLayoutRestoreView != null && focusLayoutRestoreView.requestFocus()) || sel.requestFocus();
                if (!focusWasTaken) {
                    // Selected item didn't take focus, but we still want to
                    // make sure something else outside of the selected view
                    // has focus.
                    final View focused = getFocusedChild();
                    if (focused != null) {
                        focused.clearFocus();
                    }
                    positionSelector(INVALID_POSITION, sel);
                } else {
                    sel.setSelected(false);
                    mSelectorRect.setEmpty();
                }
            } else {
                positionSelector(INVALID_POSITION, sel);
            }
            mSelectedTop = sel.getTop();
        } else {
            final boolean inTouchMode = mTouchMode == TOUCH_MODE_TAP || mTouchMode == TOUCH_MODE_DONE_WAITING;
            if (inTouchMode) {
                // If the user's finger is down, select the motion position.
                final View child = getChildAt(mMotionPosition - mFirstPosition);
                if (child != null) {
                    positionSelector(mMotionPosition, child);
                }
            } else if (mSelectorPosition != INVALID_POSITION) {
                // If we had previously positioned the selector somewhere,
                // put it back there. It might not match up with the data,
                // but it's transitioning out so it's not a big deal.
                final View child = getChildAt(mSelectorPosition - mFirstPosition);
                if (child != null) {
                    positionSelector(mSelectorPosition, child);
                }
            } else {
                // Otherwise, clear selection.
                mSelectedTop = 0;
                mSelectorRect.setEmpty();
            }
            // restore focus (i.e. something focusable in touch mode).
            if (hasFocus() && focusLayoutRestoreView != null) {
                focusLayoutRestoreView.requestFocus();
            }
        }
        // Attempt to restore accessibility focus, if necessary.
        if (viewRootImpl != null) {
            final View newAccessibilityFocusedView = viewRootImpl.getAccessibilityFocusedHost();
            if (newAccessibilityFocusedView == null) {
                if (accessibilityFocusLayoutRestoreView != null && accessibilityFocusLayoutRestoreView.isAttachedToWindow()) {
                    final AccessibilityNodeProvider provider = accessibilityFocusLayoutRestoreView.getAccessibilityNodeProvider();
                    if (accessibilityFocusLayoutRestoreNode != null && provider != null) {
                        final int virtualViewId = AccessibilityNodeInfo.getVirtualDescendantId(accessibilityFocusLayoutRestoreNode.getSourceNodeId());
                        provider.performAction(virtualViewId, AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS, null);
                    } else {
                        accessibilityFocusLayoutRestoreView.requestAccessibilityFocus();
                    }
                } else if (accessibilityFocusPosition != INVALID_POSITION) {
                    // Bound the position within the visible children.
                    final int position = MathUtils.constrain(accessibilityFocusPosition - mFirstPosition, 0, getChildCount() - 1);
                    final View restoreView = getChildAt(position);
                    if (restoreView != null) {
                        restoreView.requestAccessibilityFocus();
                    }
                }
            }
        }
        // our view hierarchy.
        if (focusLayoutRestoreView != null && focusLayoutRestoreView.getWindowToken() != null) {
            focusLayoutRestoreView.onFinishTemporaryDetach();
        }
        mLayoutMode = LAYOUT_NORMAL;
        mDataChanged = false;
        if (mPositionScrollAfterLayout != null) {
            post(mPositionScrollAfterLayout);
            mPositionScrollAfterLayout = null;
        }
        mNeedSync = false;
        setNextSelectedPositionInt(mSelectedPosition);
        updateScrollIndicators();
        if (mItemCount > 0) {
            checkSelectionChanged();
        }
        invokeOnItemScrollListener();
    } finally {
        if (!blockLayoutRequests) {
            mBlockLayoutRequests = false;
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
444,"<android.hardware.camera2.legacy.LegacyResultMapper: CameraMetadataNative cachedConvertResultMetadata(LegacyRequest,long)>",22,23,"<android.hardware.camera2.legacy.LegacyResultMapper: CameraMetadataNative cachedConvertResultMetadata(LegacyRequest,long)>","<android.hardware.camera2.legacy.LegacyResultMapper: CameraMetadataNative cachedConvertResultMetadata(LegacyRequest,long)>",0,"{
    CameraMetadataNative result;
    boolean cached;
    /*
         * Attempt to look up the result from the cache if the parameters haven't changed
         */
    if (mCachedRequest != null && legacyRequest.parameters.same(mCachedRequest.parameters)) {
        result = new CameraMetadataNative(mCachedResult);
        cached = true;
    } else {
        result = convertResultMetadata(legacyRequest);
        cached = false;
        // Always cache a *copy* of the metadata result,
        // since api2's client side takes ownership of it after it receives a result
        mCachedRequest = legacyRequest;
        mCachedResult = new CameraMetadataNative(result);
    }
    /*
         * Unconditionally set fields that change in every single frame
         */
    {
        // sensor.timestamp
        result.set(SENSOR_TIMESTAMP, timestamp);
    }
    if (VERBOSE) {
        Log.v(TAG, ""cachedConvertResultMetadata - cached? "" + cached + "" timestamp = "" + timestamp);
        Log.v(TAG, ""----- beginning of result dump ------"");
        result.dumpToLog();
        Log.v(TAG, ""----- end of result dump ------"");
    }
    return result;
}","{
    CameraMetadataNative result;
    boolean cached;
    /*
         * Attempt to look up the result from the cache if the parameters haven't changed
         */
    if (mCachedRequest != null && legacyRequest.parameters.same(mCachedRequest.parameters)) {
        result = new CameraMetadataNative(mCachedResult);
        cached = true;
    } else {
        result = convertResultMetadata(legacyRequest);
        cached = false;
        // Always cache a *copy* of the metadata result,
        // since api2's client side takes ownership of it after it receives a result
        mCachedRequest = legacyRequest;
        mCachedResult = new CameraMetadataNative(result);
    }
    /*
         * Unconditionally set fields that change in every single frame
         */
    {
        // sensor.timestamp
        result.set(SENSOR_TIMESTAMP, timestamp);
    }
    if (DEBUG) {
        Log.v(TAG, ""cachedConvertResultMetadata - cached? "" + cached + "" timestamp = "" + timestamp);
        Log.v(TAG, ""----- beginning of result dump ------"");
        result.dumpToLog();
        Log.v(TAG, ""----- end of result dump ------"");
    }
    return result;
}",1,"/**
 * Generate capture result metadata from the legacy camera request.
 *
 * <p>This method caches and reuses the result from the previous call to this method if
 * the {@code parameters} of the subsequent {@link LegacyRequest} passed to this method
 * have not changed.</p>
 *
 * @param legacyRequest a non-{@code null} legacy request containing the latest parameters
 * @param timestamp the timestamp to use for this result in nanoseconds.
 *
 * @return {@link CameraMetadataNative} object containing result metadata.
 */
","/**
 * Generate capture result metadata from the legacy camera request.
 *
 * <p>This method caches and reuses the result from the previous call to this method if
 * the {@code parameters} of the subsequent {@link LegacyRequest} passed to this method
 * have not changed.</p>
 *
 * @param legacyRequest a non-{@code null} legacy request containing the latest parameters
 * @param timestamp the timestamp to use for this result in nanoseconds.
 *
 * @return {@link CameraMetadataNative} object containing result metadata.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change is that the VERBOSE constant has been changed to DEBUG in the logging statement. As logging statements generally do not alter the behavior of the method (they are side-effects that do not interfere with the method's purpose or its return value), the type of change is 4 (Other statement changed).","Since the change is limited to a logging statement and does not affect the method's functionality, return values, exception handling, or control flow, there is no Compatibility Issue. Logging changes are typically considered non-breaking changes since they do not affect the public contract of the method."
445,"<android.provider.DocumentsProvider: Bundle call(String,String,Bundle)>",22,23,"<android.provider.DocumentsProvider: Bundle call(String,String,Bundle)>","<android.provider.DocumentsProvider: Bundle call(String,String,Bundle)>",0,"{
    if (!method.startsWith(""android:"")) {
        // Ignore non-platform methods
        return super.call(method, arg, extras);
    }
    final Context context = getContext();
    final Uri documentUri = extras.getParcelable(DocumentsContract.EXTRA_URI);
    final String authority = documentUri.getAuthority();
    final String documentId = DocumentsContract.getDocumentId(documentUri);
    if (!mAuthority.equals(authority)) {
        throw new SecurityException(""Requested authority "" + authority + "" doesn't match provider "" + mAuthority);
    }
    enforceTree(documentUri);
    final Bundle out = new Bundle();
    try {
        if (METHOD_CREATE_DOCUMENT.equals(method)) {
            enforceWritePermissionInner(documentUri, null);
            final String mimeType = extras.getString(Document.COLUMN_MIME_TYPE);
            final String displayName = extras.getString(Document.COLUMN_DISPLAY_NAME);
            final String newDocumentId = createDocument(documentId, mimeType, displayName);
            // No need to issue new grants here, since caller either has
            // manage permission or a prefix grant. We might generate a
            // tree style URI if that's how they called us.
            final Uri newDocumentUri = buildDocumentUriMaybeUsingTree(documentUri, newDocumentId);
            out.putParcelable(DocumentsContract.EXTRA_URI, newDocumentUri);
        } else if (METHOD_RENAME_DOCUMENT.equals(method)) {
            enforceWritePermissionInner(documentUri, null);
            final String displayName = extras.getString(Document.COLUMN_DISPLAY_NAME);
            final String newDocumentId = renameDocument(documentId, displayName);
            if (newDocumentId != null) {
                final Uri newDocumentUri = buildDocumentUriMaybeUsingTree(documentUri, newDocumentId);
                // narrow grant for the newly renamed document.
                if (!isTreeUri(newDocumentUri)) {
                    final int modeFlags = getCallingOrSelfUriPermissionModeFlags(context, documentUri);
                    context.grantUriPermission(getCallingPackage(), newDocumentUri, modeFlags);
                }
                out.putParcelable(DocumentsContract.EXTRA_URI, newDocumentUri);
                // Original document no longer exists, clean up any grants
                revokeDocumentPermission(documentId);
            }
        } else if (METHOD_DELETE_DOCUMENT.equals(method)) {
            enforceWritePermissionInner(documentUri, null);
            deleteDocument(documentId);
            // Document no longer exists, clean up any grants
            revokeDocumentPermission(documentId);
        } else {
            throw new UnsupportedOperationException(""Method not supported "" + method);
        }
    } catch (FileNotFoundException e) {
        throw new IllegalStateException(""Failed call "" + method, e);
    }
    return out;
}","{
    if (!method.startsWith(""android:"")) {
        // Ignore non-platform methods
        return super.call(method, arg, extras);
    }
    final Context context = getContext();
    final Uri documentUri = extras.getParcelable(DocumentsContract.EXTRA_URI);
    final String authority = documentUri.getAuthority();
    final String documentId = DocumentsContract.getDocumentId(documentUri);
    if (!mAuthority.equals(authority)) {
        throw new SecurityException(""Requested authority "" + authority + "" doesn't match provider "" + mAuthority);
    }
    enforceTree(documentUri);
    final Bundle out = new Bundle();
    try {
        if (METHOD_CREATE_DOCUMENT.equals(method)) {
            enforceWritePermissionInner(documentUri, getCallingPackage(), null);
            final String mimeType = extras.getString(Document.COLUMN_MIME_TYPE);
            final String displayName = extras.getString(Document.COLUMN_DISPLAY_NAME);
            final String newDocumentId = createDocument(documentId, mimeType, displayName);
            // No need to issue new grants here, since caller either has
            // manage permission or a prefix grant. We might generate a
            // tree style URI if that's how they called us.
            final Uri newDocumentUri = buildDocumentUriMaybeUsingTree(documentUri, newDocumentId);
            out.putParcelable(DocumentsContract.EXTRA_URI, newDocumentUri);
        } else if (METHOD_RENAME_DOCUMENT.equals(method)) {
            enforceWritePermissionInner(documentUri, getCallingPackage(), null);
            final String displayName = extras.getString(Document.COLUMN_DISPLAY_NAME);
            final String newDocumentId = renameDocument(documentId, displayName);
            if (newDocumentId != null) {
                final Uri newDocumentUri = buildDocumentUriMaybeUsingTree(documentUri, newDocumentId);
                // narrow grant for the newly renamed document.
                if (!isTreeUri(newDocumentUri)) {
                    final int modeFlags = getCallingOrSelfUriPermissionModeFlags(context, documentUri);
                    context.grantUriPermission(getCallingPackage(), newDocumentUri, modeFlags);
                }
                out.putParcelable(DocumentsContract.EXTRA_URI, newDocumentUri);
                // Original document no longer exists, clean up any grants
                revokeDocumentPermission(documentId);
            }
        } else if (METHOD_DELETE_DOCUMENT.equals(method)) {
            enforceWritePermissionInner(documentUri, getCallingPackage(), null);
            deleteDocument(documentId);
            // Document no longer exists, clean up any grants
            revokeDocumentPermission(documentId);
        } else {
            throw new UnsupportedOperationException(""Method not supported "" + method);
        }
    } catch (FileNotFoundException e) {
        throw new IllegalStateException(""Failed call "" + method, e);
    }
    return out;
}",1,"/**
 * Implementation is provided by the parent class. Can be overridden to
 * provide additional functionality, but subclasses <em>must</em> always
 * call the superclass. If the superclass returns {@code null}, the subclass
 * may implement custom behavior.
 */
","/**
 * Implementation is provided by the parent class. Can be overridden to
 * provide additional functionality, but subclasses <em>must</em> always
 * call the superclass. If the superclass returns {@code null}, the subclass
 * may implement custom behavior.
 */
",-1,[@Override],"[@CallSuper, @Override]",-1,-1,-1,-1,-1,-1,,,,
446,"<android.service.wallpaper.WallpaperService.Engine: void updateSurface(boolean,boolean,boolean)>",22,23,"<android.service.wallpaper.WallpaperService.Engine: void updateSurface(boolean,boolean,boolean)>","<android.service.wallpaper.WallpaperService.Engine: void updateSurface(boolean,boolean,boolean)>",0,"{
    if (mDestroyed) {
        Log.w(TAG, ""Ignoring updateSurface: destroyed"");
    }
    boolean fixedSize = false;
    int myWidth = mSurfaceHolder.getRequestedWidth();
    if (myWidth <= 0)
        myWidth = ViewGroup.LayoutParams.MATCH_PARENT;
    else
        fixedSize = true;
    int myHeight = mSurfaceHolder.getRequestedHeight();
    if (myHeight <= 0)
        myHeight = ViewGroup.LayoutParams.MATCH_PARENT;
    else
        fixedSize = true;
    final boolean creating = !mCreated;
    final boolean surfaceCreating = !mSurfaceCreated;
    final boolean formatChanged = mFormat != mSurfaceHolder.getRequestedFormat();
    boolean sizeChanged = mWidth != myWidth || mHeight != myHeight;
    boolean insetsChanged = !mCreated;
    final boolean typeChanged = mType != mSurfaceHolder.getRequestedType();
    final boolean flagsChanged = mCurWindowFlags != mWindowFlags || mCurWindowPrivateFlags != mWindowPrivateFlags;
    if (forceRelayout || creating || surfaceCreating || formatChanged || sizeChanged || typeChanged || flagsChanged || redrawNeeded || !mIWallpaperEngine.mShownReported) {
        if (DEBUG)
            Log.v(TAG, ""Changes: creating="" + creating + "" format="" + formatChanged + "" size="" + sizeChanged);
        try {
            mWidth = myWidth;
            mHeight = myHeight;
            mFormat = mSurfaceHolder.getRequestedFormat();
            mType = mSurfaceHolder.getRequestedType();
            mLayout.x = 0;
            mLayout.y = 0;
            mLayout.width = myWidth;
            mLayout.height = myHeight;
            mLayout.format = mFormat;
            mCurWindowFlags = mWindowFlags;
            mLayout.flags = mWindowFlags | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
            mCurWindowPrivateFlags = mWindowPrivateFlags;
            mLayout.privateFlags = mWindowPrivateFlags;
            mLayout.memoryType = mType;
            mLayout.token = mWindowToken;
            if (!mCreated) {
                // Retrieve watch round and outset info
                final WindowManager windowService = (WindowManager) getSystemService(Context.WINDOW_SERVICE);
                TypedArray windowStyle = obtainStyledAttributes(com.android.internal.R.styleable.Window);
                final Display display = windowService.getDefaultDisplay();
                final boolean shouldUseBottomOutset = display.getDisplayId() == Display.DEFAULT_DISPLAY;
                if (shouldUseBottomOutset && windowStyle.hasValue(R.styleable.Window_windowOutsetBottom)) {
                    if (mOutsetBottom == null)
                        mOutsetBottom = new TypedValue();
                    windowStyle.getValue(R.styleable.Window_windowOutsetBottom, mOutsetBottom);
                } else {
                    mOutsetBottom = null;
                }
                mWindowIsRound = getResources().getBoolean(com.android.internal.R.bool.config_windowIsRound);
                windowStyle.recycle();
                // detect emulator
                mIsEmulator = Build.HARDWARE.contains(""goldfish"");
                mIsCircularEmulator = SystemProperties.getBoolean(ViewRootImpl.PROPERTY_EMULATOR_CIRCULAR, false);
                // Add window
                mLayout.type = mIWallpaperEngine.mWindowType;
                mLayout.gravity = Gravity.START | Gravity.TOP;
                mLayout.setTitle(WallpaperService.this.getClass().getName());
                mLayout.windowAnimations = com.android.internal.R.style.Animation_Wallpaper;
                mInputChannel = new InputChannel();
                if (mSession.addToDisplay(mWindow, mWindow.mSeq, mLayout, View.VISIBLE, Display.DEFAULT_DISPLAY, mContentInsets, mStableInsets, mInputChannel) < 0) {
                    Log.w(TAG, ""Failed to add window while updating wallpaper surface."");
                    return;
                }
                mCreated = true;
                mInputEventReceiver = new WallpaperInputEventReceiver(mInputChannel, Looper.myLooper());
            }
            mSurfaceHolder.mSurfaceLock.lock();
            mDrawingAllowed = true;
            if (!fixedSize) {
                mLayout.surfaceInsets.set(mIWallpaperEngine.mDisplayPadding);
            } else {
                mLayout.surfaceInsets.set(0, 0, 0, 0);
            }
            final int relayoutResult = mSession.relayout(mWindow, mWindow.mSeq, mLayout, mWidth, mHeight, View.VISIBLE, 0, mWinFrame, mOverscanInsets, mContentInsets, mVisibleInsets, mStableInsets, mConfiguration, mSurfaceHolder.mSurface);
            if (DEBUG)
                Log.v(TAG, ""New surface: "" + mSurfaceHolder.mSurface + "", frame="" + mWinFrame);
            int w = mWinFrame.width();
            int h = mWinFrame.height();
            if (!fixedSize) {
                final Rect padding = mIWallpaperEngine.mDisplayPadding;
                w += padding.left + padding.right;
                h += padding.top + padding.bottom;
                mOverscanInsets.left += padding.left;
                mOverscanInsets.top += padding.top;
                mOverscanInsets.right += padding.right;
                mOverscanInsets.bottom += padding.bottom;
                mContentInsets.left += padding.left;
                mContentInsets.top += padding.top;
                mContentInsets.right += padding.right;
                mContentInsets.bottom += padding.bottom;
                mStableInsets.left += padding.left;
                mStableInsets.top += padding.top;
                mStableInsets.right += padding.right;
                mStableInsets.bottom += padding.bottom;
            }
            if (mCurWidth != w) {
                sizeChanged = true;
                mCurWidth = w;
            }
            if (mCurHeight != h) {
                sizeChanged = true;
                mCurHeight = h;
            }
            insetsChanged |= !mDispatchedOverscanInsets.equals(mOverscanInsets);
            insetsChanged |= !mDispatchedContentInsets.equals(mContentInsets);
            insetsChanged |= !mDispatchedStableInsets.equals(mStableInsets);
            mSurfaceHolder.setSurfaceFrameSize(w, h);
            mSurfaceHolder.mSurfaceLock.unlock();
            if (!mSurfaceHolder.mSurface.isValid()) {
                reportSurfaceDestroyed();
                if (DEBUG)
                    Log.v(TAG, ""Layout: Surface destroyed"");
                return;
            }
            boolean didSurface = false;
            try {
                mSurfaceHolder.ungetCallbacks();
                if (surfaceCreating) {
                    mIsCreating = true;
                    didSurface = true;
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceCreated("" + mSurfaceHolder + ""): "" + this);
                    onSurfaceCreated(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceCreated(mSurfaceHolder);
                        }
                    }
                }
                redrawNeeded |= creating || (relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0;
                if (forceReport || creating || surfaceCreating || formatChanged || sizeChanged) {
                    if (DEBUG) {
                        RuntimeException e = new RuntimeException();
                        e.fillInStackTrace();
                        Log.w(TAG, ""forceReport="" + forceReport + "" creating="" + creating + "" formatChanged="" + formatChanged + "" sizeChanged="" + sizeChanged, e);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceChanged("" + mSurfaceHolder + "", "" + mFormat + "", "" + mCurWidth + "", "" + mCurHeight + ""): "" + this);
                    didSurface = true;
                    onSurfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                        }
                    }
                }
                if (insetsChanged) {
                    mDispatchedOverscanInsets.set(mOverscanInsets);
                    mDispatchedContentInsets.set(mContentInsets);
                    mDispatchedStableInsets.set(mStableInsets);
                    final boolean isRound = (mIsEmulator && mIsCircularEmulator) || mWindowIsRound;
                    mFinalSystemInsets.set(mDispatchedOverscanInsets);
                    mFinalStableInsets.set(mDispatchedStableInsets);
                    if (mOutsetBottom != null) {
                        final DisplayMetrics metrics = getResources().getDisplayMetrics();
                        mFinalSystemInsets.bottom = ((int) mOutsetBottom.getDimension(metrics)) + mIWallpaperEngine.mDisplayPadding.bottom;
                    }
                    WindowInsets insets = new WindowInsets(mFinalSystemInsets, null, mFinalStableInsets, isRound);
                    onApplyWindowInsets(insets);
                }
                if (redrawNeeded) {
                    onSurfaceRedrawNeeded(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            if (c instanceof SurfaceHolder.Callback2) {
                                ((SurfaceHolder.Callback2) c).surfaceRedrawNeeded(mSurfaceHolder);
                            }
                        }
                    }
                }
                if (didSurface && !mReportedVisible) {
                    // don't want wallpapers running when not visible.
                    if (mIsCreating) {
                        // the state to get them to notice.
                        if (DEBUG)
                            Log.v(TAG, ""onVisibilityChanged(true) at surface: "" + this);
                        onVisibilityChanged(true);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onVisibilityChanged(false) at surface: "" + this);
                    onVisibilityChanged(false);
                }
            } finally {
                mIsCreating = false;
                mSurfaceCreated = true;
                if (redrawNeeded) {
                    mSession.finishDrawing(mWindow);
                }
                mIWallpaperEngine.reportShown();
            }
        } catch (RemoteException ex) {
        }
        if (DEBUG)
            Log.v(TAG, ""Layout: x="" + mLayout.x + "" y="" + mLayout.y + "" w="" + mLayout.width + "" h="" + mLayout.height);
    }
}","{
    if (mDestroyed) {
        Log.w(TAG, ""Ignoring updateSurface: destroyed"");
    }
    boolean fixedSize = false;
    int myWidth = mSurfaceHolder.getRequestedWidth();
    if (myWidth <= 0)
        myWidth = ViewGroup.LayoutParams.MATCH_PARENT;
    else
        fixedSize = true;
    int myHeight = mSurfaceHolder.getRequestedHeight();
    if (myHeight <= 0)
        myHeight = ViewGroup.LayoutParams.MATCH_PARENT;
    else
        fixedSize = true;
    final boolean creating = !mCreated;
    final boolean surfaceCreating = !mSurfaceCreated;
    final boolean formatChanged = mFormat != mSurfaceHolder.getRequestedFormat();
    boolean sizeChanged = mWidth != myWidth || mHeight != myHeight;
    boolean insetsChanged = !mCreated;
    final boolean typeChanged = mType != mSurfaceHolder.getRequestedType();
    final boolean flagsChanged = mCurWindowFlags != mWindowFlags || mCurWindowPrivateFlags != mWindowPrivateFlags;
    if (forceRelayout || creating || surfaceCreating || formatChanged || sizeChanged || typeChanged || flagsChanged || redrawNeeded || !mIWallpaperEngine.mShownReported) {
        if (DEBUG)
            Log.v(TAG, ""Changes: creating="" + creating + "" format="" + formatChanged + "" size="" + sizeChanged);
        try {
            mWidth = myWidth;
            mHeight = myHeight;
            mFormat = mSurfaceHolder.getRequestedFormat();
            mType = mSurfaceHolder.getRequestedType();
            mLayout.x = 0;
            mLayout.y = 0;
            mLayout.width = myWidth;
            mLayout.height = myHeight;
            mLayout.format = mFormat;
            mCurWindowFlags = mWindowFlags;
            mLayout.flags = mWindowFlags | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
            mCurWindowPrivateFlags = mWindowPrivateFlags;
            mLayout.privateFlags = mWindowPrivateFlags;
            mLayout.memoryType = mType;
            mLayout.token = mWindowToken;
            if (!mCreated) {
                // Retrieve watch round info
                TypedArray windowStyle = obtainStyledAttributes(com.android.internal.R.styleable.Window);
                windowStyle.recycle();
                // Add window
                mLayout.type = mIWallpaperEngine.mWindowType;
                mLayout.gravity = Gravity.START | Gravity.TOP;
                mLayout.setTitle(WallpaperService.this.getClass().getName());
                mLayout.windowAnimations = com.android.internal.R.style.Animation_Wallpaper;
                mInputChannel = new InputChannel();
                if (mSession.addToDisplay(mWindow, mWindow.mSeq, mLayout, View.VISIBLE, Display.DEFAULT_DISPLAY, mContentInsets, mStableInsets, mOutsets, mInputChannel) < 0) {
                    Log.w(TAG, ""Failed to add window while updating wallpaper surface."");
                    return;
                }
                mCreated = true;
                mInputEventReceiver = new WallpaperInputEventReceiver(mInputChannel, Looper.myLooper());
            }
            mSurfaceHolder.mSurfaceLock.lock();
            mDrawingAllowed = true;
            if (!fixedSize) {
                mLayout.surfaceInsets.set(mIWallpaperEngine.mDisplayPadding);
                mLayout.surfaceInsets.left += mOutsets.left;
                mLayout.surfaceInsets.top += mOutsets.top;
                mLayout.surfaceInsets.right += mOutsets.right;
                mLayout.surfaceInsets.bottom += mOutsets.bottom;
            } else {
                mLayout.surfaceInsets.set(0, 0, 0, 0);
            }
            final int relayoutResult = mSession.relayout(mWindow, mWindow.mSeq, mLayout, mWidth, mHeight, View.VISIBLE, 0, mWinFrame, mOverscanInsets, mContentInsets, mVisibleInsets, mStableInsets, mOutsets, mConfiguration, mSurfaceHolder.mSurface);
            if (DEBUG)
                Log.v(TAG, ""New surface: "" + mSurfaceHolder.mSurface + "", frame="" + mWinFrame);
            int w = mWinFrame.width();
            int h = mWinFrame.height();
            if (!fixedSize) {
                final Rect padding = mIWallpaperEngine.mDisplayPadding;
                w += padding.left + padding.right + mOutsets.left + mOutsets.right;
                h += padding.top + padding.bottom + mOutsets.top + mOutsets.bottom;
                mOverscanInsets.left += padding.left;
                mOverscanInsets.top += padding.top;
                mOverscanInsets.right += padding.right;
                mOverscanInsets.bottom += padding.bottom;
                mContentInsets.left += padding.left;
                mContentInsets.top += padding.top;
                mContentInsets.right += padding.right;
                mContentInsets.bottom += padding.bottom;
                mStableInsets.left += padding.left;
                mStableInsets.top += padding.top;
                mStableInsets.right += padding.right;
                mStableInsets.bottom += padding.bottom;
            }
            if (mCurWidth != w) {
                sizeChanged = true;
                mCurWidth = w;
            }
            if (mCurHeight != h) {
                sizeChanged = true;
                mCurHeight = h;
            }
            if (DEBUG) {
                Log.v(TAG, ""Wallpaper size has changed: ("" + mCurWidth + "", "" + mCurHeight);
            }
            insetsChanged |= !mDispatchedOverscanInsets.equals(mOverscanInsets);
            insetsChanged |= !mDispatchedContentInsets.equals(mContentInsets);
            insetsChanged |= !mDispatchedStableInsets.equals(mStableInsets);
            insetsChanged |= !mDispatchedOutsets.equals(mOutsets);
            mSurfaceHolder.setSurfaceFrameSize(w, h);
            mSurfaceHolder.mSurfaceLock.unlock();
            if (!mSurfaceHolder.mSurface.isValid()) {
                reportSurfaceDestroyed();
                if (DEBUG)
                    Log.v(TAG, ""Layout: Surface destroyed"");
                return;
            }
            boolean didSurface = false;
            try {
                mSurfaceHolder.ungetCallbacks();
                if (surfaceCreating) {
                    mIsCreating = true;
                    didSurface = true;
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceCreated("" + mSurfaceHolder + ""): "" + this);
                    onSurfaceCreated(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceCreated(mSurfaceHolder);
                        }
                    }
                }
                redrawNeeded |= creating || (relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0;
                if (forceReport || creating || surfaceCreating || formatChanged || sizeChanged) {
                    if (DEBUG) {
                        RuntimeException e = new RuntimeException();
                        e.fillInStackTrace();
                        Log.w(TAG, ""forceReport="" + forceReport + "" creating="" + creating + "" formatChanged="" + formatChanged + "" sizeChanged="" + sizeChanged, e);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceChanged("" + mSurfaceHolder + "", "" + mFormat + "", "" + mCurWidth + "", "" + mCurHeight + ""): "" + this);
                    didSurface = true;
                    onSurfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                        }
                    }
                }
                if (insetsChanged) {
                    mDispatchedOverscanInsets.set(mOverscanInsets);
                    mDispatchedOverscanInsets.left += mOutsets.left;
                    mDispatchedOverscanInsets.top += mOutsets.top;
                    mDispatchedOverscanInsets.right += mOutsets.right;
                    mDispatchedOverscanInsets.bottom += mOutsets.bottom;
                    mDispatchedContentInsets.set(mContentInsets);
                    mDispatchedStableInsets.set(mStableInsets);
                    mDispatchedOutsets.set(mOutsets);
                    mFinalSystemInsets.set(mDispatchedOverscanInsets);
                    mFinalStableInsets.set(mDispatchedStableInsets);
                    WindowInsets insets = new WindowInsets(mFinalSystemInsets, null, mFinalStableInsets, getResources().getConfiguration().isScreenRound());
                    if (DEBUG) {
                        Log.v(TAG, ""dispatching insets="" + insets);
                    }
                    onApplyWindowInsets(insets);
                }
                if (redrawNeeded) {
                    onSurfaceRedrawNeeded(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            if (c instanceof SurfaceHolder.Callback2) {
                                ((SurfaceHolder.Callback2) c).surfaceRedrawNeeded(mSurfaceHolder);
                            }
                        }
                    }
                }
                if (didSurface && !mReportedVisible) {
                    // don't want wallpapers running when not visible.
                    if (mIsCreating) {
                        // the state to get them to notice.
                        if (DEBUG)
                            Log.v(TAG, ""onVisibilityChanged(true) at surface: "" + this);
                        onVisibilityChanged(true);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onVisibilityChanged(false) at surface: "" + this);
                    onVisibilityChanged(false);
                }
            } finally {
                mIsCreating = false;
                mSurfaceCreated = true;
                if (redrawNeeded) {
                    mSession.finishDrawing(mWindow);
                }
                mIWallpaperEngine.reportShown();
            }
        } catch (RemoteException ex) {
        }
        if (DEBUG)
            Log.v(TAG, ""Layout: x="" + mLayout.x + "" y="" + mLayout.y + "" w="" + mLayout.width + "" h="" + mLayout.height);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
447,"<android.content.res.ColorStateList: ColorStateList createFromXml(Resources,XmlPullParser)>",22,23,"<android.content.res.ColorStateList: ColorStateList createFromXml(Resources,XmlPullParser)>","<android.content.res.ColorStateList: ColorStateList createFromXml(Resources,XmlPullParser)>",0,"{
    final AttributeSet attrs = Xml.asAttributeSet(parser);
    int type;
    while ((type = parser.next()) != XmlPullParser.START_TAG && type != XmlPullParser.END_DOCUMENT) {
    }
    if (type != XmlPullParser.START_TAG) {
        throw new XmlPullParserException(""No start tag found"");
    }
    return createFromXmlInner(r, parser, attrs);
}","{
    return createFromXml(r, parser, null);
}",1,"/**
 * Create a ColorStateList from an XML document, given a set of {@link Resources}.
 */
","/**
 * Creates a ColorStateList from an XML document.
 *
 * @param r Resources against which the ColorStateList should be inflated.
 * @param parser Parser for the XML document defining the ColorStateList.
 * @return A new color state list.
 *
 * @deprecated Use #createFromXml(Resources, XmlPullParser parser, Theme)
 */
",-1,,"[@NonNull, @Deprecated]",-1,-1,-1,-1,-1,-1,"1,4",1,"The early implementation has a while loop with XML parsing logic before calling createFromXmlInner, but the late implementation directly returns the result from createFromXml, also bypassing the XmlPullParserException that was thrown in the early version. Furthermore, there is a change from passing 'attrs' to passing 'null'. Thus, there is a return statement changed (since the creation process and what is returned could potentially be different), and other statements changed due to removal of the parsing loop and exception throwing, so the change type is 1,4.","Since the late version skips the potential XmlPullParserException and the initial XML parsing logic and also because of the change in the method being called with different arguments, it could lead to different returned values. Therefore, the CI type is 1."
448,<android.text.style.StyleSpan: int getSpanTypeId()>,22,23,<android.text.style.StyleSpan: int getSpanTypeId()>,<android.text.style.StyleSpan: int getSpanTypeId()>,0,"{
    return TextUtils.STYLE_SPAN;
}","{
    return getSpanTypeIdInternal();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method in the return statement has changed from directly returning a constant TextUtils.STYLE_SPAN to calling another method getSpanTypeIdInternal(). The actual implementation of getSpanTypeIdInternal() is not provided, but we assume it's an internal method with the same behavior intended for the previous constant return value. Therefore, this is considered as a change in a dependent API, so the code change type is 5.","Although there's a change in the implementation, we have no information indicating that getSpanTypeIdInternal() would return a value different from TextUtils.STYLE_SPAN. The change appears to be an internal refactoring without changing the external behavior. Hence, there's no CI since we do not expect different return values from this change, so the CI type is 0."
450,<android.view.ViewGroup: void removeAllViewsInLayout()>,22,23,<android.view.ViewGroup: void removeAllViewsInLayout()>,<android.view.ViewGroup: void removeAllViewsInLayout()>,0,"{
    final int count = mChildrenCount;
    if (count <= 0) {
        return;
    }
    final View[] children = mChildren;
    mChildrenCount = 0;
    final View focused = mFocused;
    final boolean detach = mAttachInfo != null;
    boolean clearChildFocus = false;
    needGlobalAttributesUpdate(false);
    for (int i = count - 1; i >= 0; i--) {
        final View view = children[i];
        if (mTransition != null) {
            mTransition.removeChild(this, view);
        }
        if (view == focused) {
            view.unFocus(null);
            clearChildFocus = true;
        }
        view.clearAccessibilityFocus();
        cancelTouchTarget(view);
        cancelHoverTarget(view);
        if (view.getAnimation() != null || (mTransitioningViews != null && mTransitioningViews.contains(view))) {
            addDisappearingView(view);
        } else if (detach) {
            view.dispatchDetachedFromWindow();
        }
        if (view.hasTransientState()) {
            childHasTransientStateChanged(view, false);
        }
        onViewRemoved(view);
        view.mParent = null;
        children[i] = null;
    }
    if (clearChildFocus) {
        clearChildFocus(focused);
        if (!rootViewRequestFocus()) {
            notifyGlobalFocusCleared(focused);
        }
    }
}","{
    final int count = mChildrenCount;
    if (count <= 0) {
        return;
    }
    final View[] children = mChildren;
    mChildrenCount = 0;
    final View focused = mFocused;
    final boolean detach = mAttachInfo != null;
    boolean clearChildFocus = false;
    needGlobalAttributesUpdate(false);
    for (int i = count - 1; i >= 0; i--) {
        final View view = children[i];
        if (mTransition != null) {
            mTransition.removeChild(this, view);
        }
        if (view == focused) {
            view.unFocus(null);
            clearChildFocus = true;
        }
        view.clearAccessibilityFocus();
        cancelTouchTarget(view);
        cancelHoverTarget(view);
        if (view.getAnimation() != null || (mTransitioningViews != null && mTransitioningViews.contains(view))) {
            addDisappearingView(view);
        } else if (detach) {
            view.dispatchDetachedFromWindow();
        }
        if (view.hasTransientState()) {
            childHasTransientStateChanged(view, false);
        }
        dispatchViewRemoved(view);
        view.mParent = null;
        children[i] = null;
    }
    if (clearChildFocus) {
        clearChildFocus(focused);
        if (!rootViewRequestFocus()) {
            notifyGlobalFocusCleared(focused);
        }
    }
}",1,"/**
 * Called by a ViewGroup subclass to remove child views from itself,
 * when it must first know its size on screen before it can calculate how many
 * child views it will render. An example is a Gallery or a ListView, which
 * may ""have"" 50 children, but actually only render the number of children
 * that can currently fit inside the object on screen. Do not call
 * this method unless you are extending ViewGroup and understand the
 * view measuring and layout pipeline.
 *
 * <p><strong>Note:</strong> do not invoke this method from
 * {@link #draw(android.graphics.Canvas)}, {@link #onDraw(android.graphics.Canvas)},
 * {@link #dispatchDraw(android.graphics.Canvas)} or any related method.</p>
 */
","/**
 * Called by a ViewGroup subclass to remove child views from itself,
 * when it must first know its size on screen before it can calculate how many
 * child views it will render. An example is a Gallery or a ListView, which
 * may ""have"" 50 children, but actually only render the number of children
 * that can currently fit inside the object on screen. Do not call
 * this method unless you are extending ViewGroup and understand the
 * view measuring and layout pipeline.
 *
 * <p><strong>Note:</strong> do not invoke this method from
 * {@link #draw(android.graphics.Canvas)}, {@link #onDraw(android.graphics.Canvas)},
 * {@link #dispatchDraw(android.graphics.Canvas)} or any related method.</p>
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"A single method call is changed from onViewRemoved(view) to dispatchViewRemoved(view), this falls under the category of ""Other statement changed"", which is code change type 4.","Despite the method call change, the context implies that both methods likely serve the same purpose within the context of the class but have slightly different implementations or naming conventions. There is no indication provided that the change in method name alters the return type or value or the behavior of the exception handling. Therefore, there's no Compatibility Issue to be expected, hence CI type is 0."
451,"<android.text.format.Formatter: String formatShortFileSize(Context,long)>",22,23,"<android.text.format.Formatter: String formatShortFileSize(Context,long)>","<android.text.format.Formatter: String formatShortFileSize(Context,long)>",0,"{
    return formatFileSize(context, number, true);
}","{
    if (context == null) {
        return """";
    }
    final BytesResult res = formatBytes(context.getResources(), sizeBytes, FLAG_SHORTER);
    return bidiWrap(context, context.getString(com.android.internal.R.string.fileSizeSuffix, res.value, res.units));
}",1,"/**
 * Like {@link #formatFileSize}, but trying to generate shorter numbers
 * (showing fewer digits of precision).
 */
","/**
 * Like {@link #formatFileSize}, but trying to generate shorter numbers
 * (showing fewer digits of precision).
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The late version adds a new 'if' check for a null context, changes the body of the method to no longer call formatFileSize, and instead calls formatBytes and bidiWrap with different parameters. This introduces new control dependency changes, as well as changes to other statements and the behavior of dependent APIs, resulting in change types 1,3,4 and 5.","Due to the changes in the implementation, specifically the introduction of new checks and use of different internal methods, the function may return different strings than in the early version. Particularly, if the context is null, the late version returns an empty string, whereas the early version would have proceeded to call formatFileSize, potentially throwing a NullPointerException. The later changes also affect how the file size is formatted, leading to potentially different return values. Thus, the CI type is 1."
452,<android.app.WallpaperManager: void setResource(int)>,22,23,<android.app.WallpaperManager: void setResource(int)>,<android.app.WallpaperManager: void setResource(int)>,0,"{
    if (sGlobals.mService == null) {
        Log.w(TAG, ""WallpaperService not running"");
        return;
    }
    try {
        Resources resources = mContext.getResources();
        /* Set the wallpaper to the default values */
        ParcelFileDescriptor fd = sGlobals.mService.setWallpaper(""res:"" + resources.getResourceName(resid));
        if (fd != null) {
            FileOutputStream fos = null;
            try {
                fos = new ParcelFileDescriptor.AutoCloseOutputStream(fd);
                setWallpaper(resources.openRawResource(resid), fos);
            } finally {
                if (fos != null) {
                    fos.close();
                }
            }
        }
    } catch (RemoteException e) {
    // Ignore
    }
}","{
    if (sGlobals.mService == null) {
        Log.w(TAG, ""WallpaperService not running"");
        return;
    }
    try {
        Resources resources = mContext.getResources();
        /* Set the wallpaper to the default values */
        ParcelFileDescriptor fd = sGlobals.mService.setWallpaper(""res:"" + resources.getResourceName(resid), mContext.getOpPackageName());
        if (fd != null) {
            FileOutputStream fos = null;
            try {
                fos = new ParcelFileDescriptor.AutoCloseOutputStream(fd);
                setWallpaper(resources.openRawResource(resid), fos);
            } finally {
                if (fos != null) {
                    fos.close();
                }
            }
        }
    } catch (RemoteException e) {
    // Ignore
    }
}",1,"/**
 * Change the current system wallpaper to the bitmap in the given resource.
 * The resource is opened as a raw data stream and copied into the
 * wallpaper; it must be a valid PNG or JPEG image.  On success, the intent
 * {@link Intent#ACTION_WALLPAPER_CHANGED} is broadcast.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#SET_WALLPAPER}.
 *
 * @param resid The bitmap to save.
 *
 * @throws IOException If an error occurs reverting to the built-in
 * wallpaper.
 */
","/**
 * Change the current system wallpaper to the bitmap in the given resource.
 * The resource is opened as a raw data stream and copied into the
 * wallpaper; it must be a valid PNG or JPEG image.  On success, the intent
 * {@link Intent#ACTION_WALLPAPER_CHANGED} is broadcast.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#SET_WALLPAPER}.
 *
 * @param resid The bitmap to save.
 *
 * @throws IOException If an error occurs reverting to the built-in
 * wallpaper.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The change in the implementation is in the call to sGlobals.mService.setWallpaper() where a second parameter, mContext.getOpPackageName(), is added. This represents a change to a dependent API and not within the method itself, so the code change type is 5.","There's no Compatibility Issue since the method signature hasn't changed, it's not introducing a new return statement or exception handling, and the control flow of the method also remains the same. Thus, the clients calling this API would not have to handle any new exceptions or expect different return values. Therefore, there's no expected change in behavior from the perspective of an API consumer, and the CI type is 0."
453,<android.service.wallpaper.WallpaperService.IWallpaperEngineWrapper: void executeMessage(Message)>,22,23,<android.service.wallpaper.WallpaperService.IWallpaperEngineWrapper: void executeMessage(Message)>,<android.service.wallpaper.WallpaperService.IWallpaperEngineWrapper: void executeMessage(Message)>,0,"{
    switch(message.what) {
        case DO_ATTACH:
            {
                try {
                    mConnection.attachEngine(this);
                } catch (RemoteException e) {
                    Log.w(TAG, ""Wallpaper host disappeared"", e);
                    return;
                }
                Engine engine = onCreateEngine();
                mEngine = engine;
                mActiveEngines.add(engine);
                engine.attach(this);
                return;
            }
        case DO_DETACH:
            {
                mActiveEngines.remove(mEngine);
                mEngine.detach();
                return;
            }
        case DO_SET_DESIRED_SIZE:
            {
                mEngine.doDesiredSizeChanged(message.arg1, message.arg2);
                return;
            }
        case DO_SET_DISPLAY_PADDING:
            {
                mEngine.doDisplayPaddingChanged((Rect) message.obj);
            }
        case MSG_UPDATE_SURFACE:
            mEngine.updateSurface(true, false, false);
            break;
        case MSG_VISIBILITY_CHANGED:
            if (DEBUG)
                Log.v(TAG, ""Visibility change in "" + mEngine + "": "" + message.arg1);
            mEngine.doVisibilityChanged(message.arg1 != 0);
            break;
        case MSG_WALLPAPER_OFFSETS:
            {
                mEngine.doOffsetsChanged(true);
            }
            break;
        case MSG_WALLPAPER_COMMAND:
            {
                WallpaperCommand cmd = (WallpaperCommand) message.obj;
                mEngine.doCommand(cmd);
            }
            break;
        case MSG_WINDOW_RESIZED:
            {
                final boolean reportDraw = message.arg1 != 0;
                mEngine.updateSurface(true, false, reportDraw);
                mEngine.doOffsetsChanged(true);
            }
            break;
        case MSG_WINDOW_MOVED:
            {
            // Do nothing. What does it mean for a Wallpaper to move?
            }
            break;
        case MSG_TOUCH_EVENT:
            {
                boolean skip = false;
                MotionEvent ev = (MotionEvent) message.obj;
                if (ev.getAction() == MotionEvent.ACTION_MOVE) {
                    synchronized (mEngine.mLock) {
                        if (mEngine.mPendingMove == ev) {
                            mEngine.mPendingMove = null;
                        } else {
                            // this is not the motion event we are looking for....
                            skip = true;
                        }
                    }
                }
                if (!skip) {
                    if (DEBUG)
                        Log.v(TAG, ""Delivering touch event: "" + ev);
                    mEngine.onTouchEvent(ev);
                }
                ev.recycle();
            }
            break;
        default:
            Log.w(TAG, ""Unknown message type "" + message.what);
    }
}","{
    switch(message.what) {
        case DO_ATTACH:
            {
                try {
                    mConnection.attachEngine(this);
                } catch (RemoteException e) {
                    Log.w(TAG, ""Wallpaper host disappeared"", e);
                    return;
                }
                Engine engine = onCreateEngine();
                mEngine = engine;
                mActiveEngines.add(engine);
                engine.attach(this);
                return;
            }
        case DO_DETACH:
            {
                mActiveEngines.remove(mEngine);
                mEngine.detach();
                return;
            }
        case DO_SET_DESIRED_SIZE:
            {
                mEngine.doDesiredSizeChanged(message.arg1, message.arg2);
                return;
            }
        case DO_SET_DISPLAY_PADDING:
            {
                mEngine.doDisplayPaddingChanged((Rect) message.obj);
            }
        case MSG_UPDATE_SURFACE:
            mEngine.updateSurface(true, false, false);
            break;
        case MSG_VISIBILITY_CHANGED:
            if (DEBUG)
                Log.v(TAG, ""Visibility change in "" + mEngine + "": "" + message.arg1);
            mEngine.doVisibilityChanged(message.arg1 != 0);
            break;
        case MSG_WALLPAPER_OFFSETS:
            {
                mEngine.doOffsetsChanged(true);
            }
            break;
        case MSG_WALLPAPER_COMMAND:
            {
                WallpaperCommand cmd = (WallpaperCommand) message.obj;
                mEngine.doCommand(cmd);
            }
            break;
        case MSG_WINDOW_RESIZED:
            {
                final boolean reportDraw = message.arg1 != 0;
                mEngine.mOutsets.set((Rect) message.obj);
                mEngine.updateSurface(true, false, reportDraw);
                mEngine.doOffsetsChanged(true);
            }
            break;
        case MSG_WINDOW_MOVED:
            {
            // Do nothing. What does it mean for a Wallpaper to move?
            }
            break;
        case MSG_TOUCH_EVENT:
            {
                boolean skip = false;
                MotionEvent ev = (MotionEvent) message.obj;
                if (ev.getAction() == MotionEvent.ACTION_MOVE) {
                    synchronized (mEngine.mLock) {
                        if (mEngine.mPendingMove == ev) {
                            mEngine.mPendingMove = null;
                        } else {
                            // this is not the motion event we are looking for....
                            skip = true;
                        }
                    }
                }
                if (!skip) {
                    if (DEBUG)
                        Log.v(TAG, ""Delivering touch event: "" + ev);
                    mEngine.onTouchEvent(ev);
                }
                ev.recycle();
            }
            break;
        default:
            Log.w(TAG, ""Unknown message type "" + message.what);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
455,<android.hardware.GeomagneticField: float getHorizontalStrength()>,22,23,<android.hardware.GeomagneticField: float getHorizontalStrength()>,<android.hardware.GeomagneticField: float getHorizontalStrength()>,0,"{
    return (float) Math.sqrt(mX * mX + mY * mY);
}","{
    return (float) Math.hypot(mX, mY);
}",1,"/**
 * @return  Horizontal component of the field strength in nonoteslas.
 */
","/**
 * @return  Horizontal component of the field strength in nonoteslas.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The return statement has changed but it is essentially performing the same calculation using a different method, Math.hypot(mX, mY) instead of Math.sqrt(mX * mX + mY * mY), which would result in the same value for the horizontal strength, so the code change is 4 (Other statement changed).","There is no Compatibility Issue because the change does not affect the behaviour of the API; it still returns the same computed value, although using a different method. Hence, the CI type is 0 (No Compatibility Issue)."
457,<android.inputmethodservice.ExtractEditText: boolean onTextContextMenuItem(int)>,22,23,<android.inputmethodservice.ExtractEditText: boolean onTextContextMenuItem(int)>,<android.inputmethodservice.ExtractEditText: boolean onTextContextMenuItem(int)>,0,"{
    if (mIME != null && mIME.onExtractTextContextMenuItem(id)) {
        // Cut and paste will change the text, which stops selection mode.
        if (id == android.R.id.copy)
            stopSelectionActionMode();
        return true;
    }
    return super.onTextContextMenuItem(id);
}","{
    // extracted one.
    if (id == android.R.id.selectAll || id == android.R.id.replaceText) {
        return super.onTextContextMenuItem(id);
    }
    if (mIME != null && mIME.onExtractTextContextMenuItem(id)) {
        // Cut will change the text, which stops selection mode.
        if (id == android.R.id.copy || id == android.R.id.paste)
            stopTextActionMode();
        return true;
    }
    return super.onTextContextMenuItem(id);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"The control dependency changed with the addition of a new if statement checking for specific 'id' values and the introduction of the id == android.R.id.replaceText case. Moreover, the return statement has changed, especially with the condition 'if (id == android.R.id.selectAll || id == android.R.id.replaceText)' now directly returning the result of super.onTextContextMenuItem(id). Also, the method stopped by stopSelectionActionMode() has changed to stopTextActionMode(). Hence, the change type is 1,3.","The newly introduced condition and the subsequent return statement from super.onTextContextMenuItem(id) indicate that for certain conditions, the method may return a different value than it did before; hence, a Compatibility Issue can arise due to potential different return values, which corresponds to CI type 1."
458,"<android.hardware.SystemSensorManager.TriggerEventQueue: void dispatchSensorEvent(int,float[],int,long)>",22,23,"<android.hardware.SystemSensorManager.TriggerEventQueue: void dispatchSensorEvent(int,float[],int,long)>","<android.hardware.SystemSensorManager.TriggerEventQueue: void dispatchSensorEvent(int,float[],int,long)>",0,"{
    final Sensor sensor = sHandleToSensor.get(handle);
    TriggerEvent t = null;
    synchronized (mTriggerEvents) {
        t = mTriggerEvents.get(handle);
    }
    if (t == null) {
        Log.e(TAG, ""Error: Trigger Event is null for Sensor: "" + sensor);
        return;
    }
    // Copy from the values array.
    System.arraycopy(values, 0, t.values, 0, t.values.length);
    t.timestamp = timestamp;
    t.sensor = sensor;
    // A trigger sensor is auto disabled. So just clean up and don't call native
    // disable.
    mManager.cancelTriggerSensorImpl(mListener, sensor, false);
    mListener.onTrigger(t);
}","{
    final Sensor sensor = mManager.mHandleToSensor.get(handle);
    TriggerEvent t = null;
    synchronized (mTriggerEvents) {
        t = mTriggerEvents.get(handle);
    }
    if (t == null) {
        Log.e(TAG, ""Error: Trigger Event is null for Sensor: "" + sensor);
        return;
    }
    // Copy from the values array.
    System.arraycopy(values, 0, t.values, 0, t.values.length);
    t.timestamp = timestamp;
    t.sensor = sensor;
    // A trigger sensor is auto disabled. So just clean up and don't call native
    // disable.
    mManager.cancelTriggerSensorImpl(mListener, sensor, false);
    mListener.onTrigger(t);
}",1,"// Called from native code.
","// Called from native code.
",-1,"[@SuppressWarnings(""unused""), @Override]","[@SuppressWarnings(""unused""), @Override]",-1,-1,-1,-1,-1,-1,0,0,There were no changes made in the actual implementation code between the early and late versions. The references were slightly adjusted but they did not affect the behavior of the code.,No compatibility issue could arise from this API since there were no changes made to its behavior.
460,"<android.speech.tts.TextToSpeechService.SynthHandler: int enqueueSpeechItem(int,SpeechItem)>",22,23,"<android.speech.tts.TextToSpeechService.SynthHandler: int enqueueSpeechItem(int,SpeechItem)>","<android.speech.tts.TextToSpeechService.SynthHandler: int enqueueSpeechItem(int,SpeechItem)>",0,"{
    UtteranceProgressDispatcher utterenceProgress = null;
    if (speechItem instanceof UtteranceProgressDispatcher) {
        utterenceProgress = (UtteranceProgressDispatcher) speechItem;
    }
    if (!speechItem.isValid()) {
        if (utterenceProgress != null) {
            utterenceProgress.dispatchOnError(TextToSpeech.ERROR_INVALID_REQUEST);
        }
        return TextToSpeech.ERROR;
    }
    if (queueMode == TextToSpeech.QUEUE_FLUSH) {
        stopForApp(speechItem.getCallerIdentity());
    } else if (queueMode == TextToSpeech.QUEUE_DESTROY) {
        stopAll();
    }
    Runnable runnable = new Runnable() {

        @Override
        public void run() {
            setCurrentSpeechItem(speechItem);
            speechItem.play();
            setCurrentSpeechItem(null);
        }
    };
    Message msg = Message.obtain(this, runnable);
    // The obj is used to remove all callbacks from the given app in
    // stopForApp(String).
    // 
    // Note that this string is interned, so the == comparison works.
    msg.obj = speechItem.getCallerIdentity();
    if (sendMessage(msg)) {
        return TextToSpeech.SUCCESS;
    } else {
        Log.w(TAG, ""SynthThread has quit"");
        if (utterenceProgress != null) {
            utterenceProgress.dispatchOnError(TextToSpeech.ERROR_SERVICE);
        }
        return TextToSpeech.ERROR;
    }
}","{
    UtteranceProgressDispatcher utterenceProgress = null;
    if (speechItem instanceof UtteranceProgressDispatcher) {
        utterenceProgress = (UtteranceProgressDispatcher) speechItem;
    }
    if (!speechItem.isValid()) {
        if (utterenceProgress != null) {
            utterenceProgress.dispatchOnError(TextToSpeech.ERROR_INVALID_REQUEST);
        }
        return TextToSpeech.ERROR;
    }
    if (queueMode == TextToSpeech.QUEUE_FLUSH) {
        stopForApp(speechItem.getCallerIdentity());
    } else if (queueMode == TextToSpeech.QUEUE_DESTROY) {
        stopAll();
    }
    Runnable runnable = new Runnable() {

        @Override
        public void run() {
            if (isFlushed(speechItem)) {
                speechItem.stop();
            } else {
                setCurrentSpeechItem(speechItem);
                speechItem.play();
                setCurrentSpeechItem(null);
            }
        }
    };
    Message msg = Message.obtain(this, runnable);
    // The obj is used to remove all callbacks from the given app in
    // stopForApp(String).
    // 
    // Note that this string is interned, so the == comparison works.
    msg.obj = speechItem.getCallerIdentity();
    if (sendMessage(msg)) {
        return TextToSpeech.SUCCESS;
    } else {
        Log.w(TAG, ""SynthThread has quit"");
        if (utterenceProgress != null) {
            utterenceProgress.dispatchOnError(TextToSpeech.ERROR_SERVICE);
        }
        return TextToSpeech.ERROR;
    }
}",1,"/**
 * Adds a speech item to the queue.
 *
 * Called on a service binder thread.
 */
","/**
 * Adds a speech item to the queue.
 *
 * Called on a service binder thread.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"There is an additional decision-making structure introduced with the conditional statement ""if (isFlushed(speechItem))"" to check if the speech item has been flushed and an associated call to ""speechItem.stop();"" within the Runnable's ""run()"" method. So, the code change includes changes in the control dependency (3), as well as other statement changes that do not fit return statement or exception handling criteria (4).","Since the new code introduces a conditional check that can stop the speech item from playing, this could lead to a different return value (the decision influences whether TextToSpeech.SUCCESS or an error is returned). This represents a potential change in behavior, which classifies it as a CI caused by potential different return values or types (1)."
461,<android.provider.Browser: Cursor getAllVisitedUrls(ContentResolver)>,22,23,<android.provider.Browser: Cursor getAllVisitedUrls(ContentResolver)>,<android.provider.Browser: Cursor getAllVisitedUrls(ContentResolver)>,0,"{
    return cr.query(Combined.CONTENT_URI, new String[] { Combined.URL }, null, null, Combined.DATE_CREATED + "" ASC"");
}","{
    return new MatrixCursor(new String[] { Combined.URL }, 0);
}",1,"/**
 * Return a cursor pointing to a list of all visited site urls. The cursor will
 * have a single column, {@link BookmarkColumns#URL}.
 * <p>
 * Requires {@link android.Manifest.permission#READ_HISTORY_BOOKMARKS}
 *
 * @param cr   The ContentResolver used to access the database.
 */
","/**
 * Return a cursor pointing to a list of all visited site urls. The cursor will
 * have a single column, {@link BookmarkColumns#URL}.
 *
 * @param cr   The ContentResolver used to access the database.
 * @removed
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement changed from cr.query(...) to new MatrixCursor(...), which indicates the method is now returning a completely different type of `Cursor`. This means the way data is accessed and what data is returned could be substantially different; the code change type is 1.","Since the method is returning an entirely different cursor object, it will lead to a different behavior for any code relying on the content of the cursor. Clients expecting the cursor to contain data from a query on the `Combined.CONTENT_URI` will now receive an empty `MatrixCursor` with no data, and thus the CI type is 1."
462,<android.os.MessageQueue: Message next()>,22,23,<android.os.MessageQueue: Message next()>,<android.os.MessageQueue: Message next()>,0,"{
    // Return here if the message loop has already quit and been disposed.
    // This can happen if the application tries to restart a looper after quit
    // which is not supported.
    final long ptr = mPtr;
    if (ptr == 0) {
        return null;
    }
    // -1 only during first iteration
    int pendingIdleHandlerCount = -1;
    int nextPollTimeoutMillis = 0;
    for (; ; ) {
        if (nextPollTimeoutMillis != 0) {
            Binder.flushPendingCommands();
        }
        nativePollOnce(ptr, nextPollTimeoutMillis);
        synchronized (this) {
            // Try to retrieve the next message.  Return if found.
            final long now = SystemClock.uptimeMillis();
            Message prevMsg = null;
            Message msg = mMessages;
            if (msg != null && msg.target == null) {
                // Stalled by a barrier.  Find the next asynchronous message in the queue.
                do {
                    prevMsg = msg;
                    msg = msg.next;
                } while (msg != null && !msg.isAsynchronous());
            }
            if (msg != null) {
                if (now < msg.when) {
                    // Next message is not ready.  Set a timeout to wake up when it is ready.
                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);
                } else {
                    // Got a message.
                    mBlocked = false;
                    if (prevMsg != null) {
                        prevMsg.next = msg.next;
                    } else {
                        mMessages = msg.next;
                    }
                    msg.next = null;
                    if (false)
                        Log.v(""MessageQueue"", ""Returning message: "" + msg);
                    return msg;
                }
            } else {
                // No more messages.
                nextPollTimeoutMillis = -1;
            }
            // Process the quit message now that all pending messages have been handled.
            if (mQuitting) {
                dispose();
                return null;
            }
            // in the queue (possibly a barrier) is due to be handled in the future.
            if (pendingIdleHandlerCount < 0 && (mMessages == null || now < mMessages.when)) {
                pendingIdleHandlerCount = mIdleHandlers.size();
            }
            if (pendingIdleHandlerCount <= 0) {
                // No idle handlers to run.  Loop and wait some more.
                mBlocked = true;
                continue;
            }
            if (mPendingIdleHandlers == null) {
                mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];
            }
            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);
        }
        // We only ever reach this code block during the first iteration.
        for (int i = 0; i < pendingIdleHandlerCount; i++) {
            final IdleHandler idler = mPendingIdleHandlers[i];
            // release the reference to the handler
            mPendingIdleHandlers[i] = null;
            boolean keep = false;
            try {
                keep = idler.queueIdle();
            } catch (Throwable t) {
                Log.wtf(""MessageQueue"", ""IdleHandler threw exception"", t);
            }
            if (!keep) {
                synchronized (this) {
                    mIdleHandlers.remove(idler);
                }
            }
        }
        // Reset the idle handler count to 0 so we do not run them again.
        pendingIdleHandlerCount = 0;
        // While calling an idle handler, a new message could have been delivered
        // so go back and look again for a pending message without waiting.
        nextPollTimeoutMillis = 0;
    }
}","{
    // Return here if the message loop has already quit and been disposed.
    // This can happen if the application tries to restart a looper after quit
    // which is not supported.
    final long ptr = mPtr;
    if (ptr == 0) {
        return null;
    }
    // -1 only during first iteration
    int pendingIdleHandlerCount = -1;
    int nextPollTimeoutMillis = 0;
    for (; ; ) {
        if (nextPollTimeoutMillis != 0) {
            Binder.flushPendingCommands();
        }
        nativePollOnce(ptr, nextPollTimeoutMillis);
        synchronized (this) {
            // Try to retrieve the next message.  Return if found.
            final long now = SystemClock.uptimeMillis();
            Message prevMsg = null;
            Message msg = mMessages;
            if (msg != null && msg.target == null) {
                // Stalled by a barrier.  Find the next asynchronous message in the queue.
                do {
                    prevMsg = msg;
                    msg = msg.next;
                } while (msg != null && !msg.isAsynchronous());
            }
            if (msg != null) {
                if (now < msg.when) {
                    // Next message is not ready.  Set a timeout to wake up when it is ready.
                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);
                } else {
                    // Got a message.
                    mBlocked = false;
                    if (prevMsg != null) {
                        prevMsg.next = msg.next;
                    } else {
                        mMessages = msg.next;
                    }
                    msg.next = null;
                    if (DEBUG)
                        Log.v(TAG, ""Returning message: "" + msg);
                    msg.markInUse();
                    return msg;
                }
            } else {
                // No more messages.
                nextPollTimeoutMillis = -1;
            }
            // Process the quit message now that all pending messages have been handled.
            if (mQuitting) {
                dispose();
                return null;
            }
            // in the queue (possibly a barrier) is due to be handled in the future.
            if (pendingIdleHandlerCount < 0 && (mMessages == null || now < mMessages.when)) {
                pendingIdleHandlerCount = mIdleHandlers.size();
            }
            if (pendingIdleHandlerCount <= 0) {
                // No idle handlers to run.  Loop and wait some more.
                mBlocked = true;
                continue;
            }
            if (mPendingIdleHandlers == null) {
                mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];
            }
            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);
        }
        // We only ever reach this code block during the first iteration.
        for (int i = 0; i < pendingIdleHandlerCount; i++) {
            final IdleHandler idler = mPendingIdleHandlers[i];
            // release the reference to the handler
            mPendingIdleHandlers[i] = null;
            boolean keep = false;
            try {
                keep = idler.queueIdle();
            } catch (Throwable t) {
                Log.wtf(TAG, ""IdleHandler threw exception"", t);
            }
            if (!keep) {
                synchronized (this) {
                    mIdleHandlers.remove(idler);
                }
            }
        }
        // Reset the idle handler count to 0 so we do not run them again.
        pendingIdleHandlerCount = 0;
        // While calling an idle handler, a new message could have been delivered
        // so go back and look again for a pending message without waiting.
        nextPollTimeoutMillis = 0;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
463,<android.app.Activity: ActionMode onWindowStartingActionMode(Callback)>,22,23,<android.app.Activity: ActionMode onWindowStartingActionMode(Callback)>,<android.app.Activity: ActionMode onWindowStartingActionMode(Callback)>,0,"{
    initWindowDecorActionBar();
    if (mActionBar != null) {
        return mActionBar.startActionMode(callback);
    }
    return null;
}","{
    // Only Primary ActionModes are represented in the ActionBar.
    if (mActionModeTypeStarting == ActionMode.TYPE_PRIMARY) {
        initWindowDecorActionBar();
        if (mActionBar != null) {
            return mActionBar.startActionMode(callback);
        }
    }
    return null;
}",1,"/**
 * Give the Activity a chance to control the UI for an action mode requested
 * by the system.
 *
 * <p>Note: If you are looking for a notification callback that an action mode
 * has been started for this activity, see {@link #onActionModeStarted(ActionMode)}.</p>
 *
 * @param callback The callback that should control the new action mode
 * @return The new action mode, or <code>null</code> if the activity does not want to
 * provide special handling for this action mode. (It will be handled by the system.)
 */
","/**
 * Give the Activity a chance to control the UI for an action mode requested
 * by the system.
 *
 * <p>Note: If you are looking for a notification callback that an action mode
 * has been started for this activity, see {@link #onActionModeStarted(ActionMode)}.</p>
 *
 * @param callback The callback that should control the new action mode
 * @return The new action mode, or <code>null</code> if the activity does not want to
 * provide special handling for this action mode. (It will be handled by the system.)
 */
",-1,"[@Nullable, @Override]","[@Nullable, @Override]",-1,-1,-1,-1,-1,-1,3,0,"The implementation code in the late version introduces an additional control dependency with the if statement `if (mActionModeTypeStarting == ActionMode.TYPE_PRIMARY)` which wraps the existing code, so the code change type is 3.","There could be cases where `mActionModeTypeStarting` is not equal to `ActionMode.TYPE_PRIMARY` and in those cases, the late version of the method would return null whereas the early version would proceed with the initialization and potential action mode start. However, since the null return is consistent in both versions when the relevant conditions fail, there is no compatibility issue caused by potential differences in return values or types. Thus, the CI type is 0."
464,"<android.app.admin.DevicePolicyManager: void setPasswordMinimumLength(ComponentName,int)>",22,23,"<android.app.admin.DevicePolicyManager: void setPasswordMinimumLength(ComponentName,int)>","<android.app.admin.DevicePolicyManager: void setPasswordMinimumLength(ComponentName,int)>",0,"{
    if (mService != null) {
        try {
            mService.setPasswordMinimumLength(admin, length, UserHandle.myUserId());
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    if (mService != null) {
        try {
            mService.setPasswordMinimumLength(admin, length);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}",1,"/**
 * Called by an application that is administering the device to set the
 * minimum allowed password length.  After setting this, the user
 * will not be able to enter a new password that is not at least as
 * restrictive as what has been set.  Note that the current password
 * will remain until the user has set a new one, so the change does not
 * take place immediately.  To prompt the user for a new password, use
 * {@link #ACTION_SET_NEW_PASSWORD} after setting this value.  This
 * constraint is only imposed if the administrator has also requested either
 * {@link #PASSWORD_QUALITY_NUMERIC}, {@link #PASSWORD_QUALITY_NUMERIC_COMPLEX},
 * {@link #PASSWORD_QUALITY_ALPHABETIC}, {@link #PASSWORD_QUALITY_ALPHANUMERIC},
 * or {@link #PASSWORD_QUALITY_COMPLEX} with {@link #setPasswordQuality}.
 *
 * <p>The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call
 * this method; if it has not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param length The new desired minimum password length.  A value of 0
 * means there is no restriction.
 */
","/**
 * Called by an application that is administering the device to set the
 * minimum allowed password length.  After setting this, the user
 * will not be able to enter a new password that is not at least as
 * restrictive as what has been set.  Note that the current password
 * will remain until the user has set a new one, so the change does not
 * take place immediately.  To prompt the user for a new password, use
 * {@link #ACTION_SET_NEW_PASSWORD} after setting this value.  This
 * constraint is only imposed if the administrator has also requested either
 * {@link #PASSWORD_QUALITY_NUMERIC}, {@link #PASSWORD_QUALITY_NUMERIC_COMPLEX},
 * {@link #PASSWORD_QUALITY_ALPHABETIC}, {@link #PASSWORD_QUALITY_ALPHANUMERIC},
 * or {@link #PASSWORD_QUALITY_COMPLEX} with {@link #setPasswordQuality}.
 *
 * <p>The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call
 * this method; if it has not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param length The new desired minimum password length.  A value of 0
 * means there is no restriction.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method call mService.setPasswordMinimumLength(admin, length, UserHandle.myUserId()) in the early version has been changed to mService.setPasswordMinimumLength(admin, length) in the late version; the number of parameters has been reduced by removing UserHandle.myUserId(). Hence, the code change is related to a dependent API change, making the change type 5.","Even though the dependent API signature has changed, there is no direct evidence of a change in return type/value or exception handling in the provided information. Therefore, there's no compatibility issue detected, leading to a CI type of 0."
465,<android.view.ViewRootImpl.ViewRootHandler: String getMessageName(Message)>,22,23,<android.view.ViewRootImpl.ViewRootHandler: String getMessageName(Message)>,<android.view.ViewRootImpl.ViewRootHandler: String getMessageName(Message)>,0,"{
    switch(message.what) {
        case MSG_INVALIDATE:
            return ""MSG_INVALIDATE"";
        case MSG_INVALIDATE_RECT:
            return ""MSG_INVALIDATE_RECT"";
        case MSG_DIE:
            return ""MSG_DIE"";
        case MSG_RESIZED:
            return ""MSG_RESIZED"";
        case MSG_RESIZED_REPORT:
            return ""MSG_RESIZED_REPORT"";
        case MSG_WINDOW_FOCUS_CHANGED:
            return ""MSG_WINDOW_FOCUS_CHANGED"";
        case MSG_DISPATCH_INPUT_EVENT:
            return ""MSG_DISPATCH_INPUT_EVENT"";
        case MSG_DISPATCH_APP_VISIBILITY:
            return ""MSG_DISPATCH_APP_VISIBILITY"";
        case MSG_DISPATCH_GET_NEW_SURFACE:
            return ""MSG_DISPATCH_GET_NEW_SURFACE"";
        case MSG_DISPATCH_KEY_FROM_IME:
            return ""MSG_DISPATCH_KEY_FROM_IME"";
        case MSG_FINISH_INPUT_CONNECTION:
            return ""MSG_FINISH_INPUT_CONNECTION"";
        case MSG_CHECK_FOCUS:
            return ""MSG_CHECK_FOCUS"";
        case MSG_CLOSE_SYSTEM_DIALOGS:
            return ""MSG_CLOSE_SYSTEM_DIALOGS"";
        case MSG_DISPATCH_DRAG_EVENT:
            return ""MSG_DISPATCH_DRAG_EVENT"";
        case MSG_DISPATCH_DRAG_LOCATION_EVENT:
            return ""MSG_DISPATCH_DRAG_LOCATION_EVENT"";
        case MSG_DISPATCH_SYSTEM_UI_VISIBILITY:
            return ""MSG_DISPATCH_SYSTEM_UI_VISIBILITY"";
        case MSG_UPDATE_CONFIGURATION:
            return ""MSG_UPDATE_CONFIGURATION"";
        case MSG_PROCESS_INPUT_EVENTS:
            return ""MSG_PROCESS_INPUT_EVENTS"";
        case MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST:
            return ""MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST"";
        case MSG_DISPATCH_DONE_ANIMATING:
            return ""MSG_DISPATCH_DONE_ANIMATING"";
        case MSG_WINDOW_MOVED:
            return ""MSG_WINDOW_MOVED"";
        case MSG_SYNTHESIZE_INPUT_EVENT:
            return ""MSG_SYNTHESIZE_INPUT_EVENT"";
        case MSG_DISPATCH_WINDOW_SHOWN:
            return ""MSG_DISPATCH_WINDOW_SHOWN"";
    }
    return super.getMessageName(message);
}","{
    switch(message.what) {
        case MSG_INVALIDATE:
            return ""MSG_INVALIDATE"";
        case MSG_INVALIDATE_RECT:
            return ""MSG_INVALIDATE_RECT"";
        case MSG_DIE:
            return ""MSG_DIE"";
        case MSG_RESIZED:
            return ""MSG_RESIZED"";
        case MSG_RESIZED_REPORT:
            return ""MSG_RESIZED_REPORT"";
        case MSG_WINDOW_FOCUS_CHANGED:
            return ""MSG_WINDOW_FOCUS_CHANGED"";
        case MSG_DISPATCH_INPUT_EVENT:
            return ""MSG_DISPATCH_INPUT_EVENT"";
        case MSG_DISPATCH_APP_VISIBILITY:
            return ""MSG_DISPATCH_APP_VISIBILITY"";
        case MSG_DISPATCH_GET_NEW_SURFACE:
            return ""MSG_DISPATCH_GET_NEW_SURFACE"";
        case MSG_DISPATCH_KEY_FROM_IME:
            return ""MSG_DISPATCH_KEY_FROM_IME"";
        case MSG_FINISH_INPUT_CONNECTION:
            return ""MSG_FINISH_INPUT_CONNECTION"";
        case MSG_CHECK_FOCUS:
            return ""MSG_CHECK_FOCUS"";
        case MSG_CLOSE_SYSTEM_DIALOGS:
            return ""MSG_CLOSE_SYSTEM_DIALOGS"";
        case MSG_DISPATCH_DRAG_EVENT:
            return ""MSG_DISPATCH_DRAG_EVENT"";
        case MSG_DISPATCH_DRAG_LOCATION_EVENT:
            return ""MSG_DISPATCH_DRAG_LOCATION_EVENT"";
        case MSG_DISPATCH_SYSTEM_UI_VISIBILITY:
            return ""MSG_DISPATCH_SYSTEM_UI_VISIBILITY"";
        case MSG_UPDATE_CONFIGURATION:
            return ""MSG_UPDATE_CONFIGURATION"";
        case MSG_PROCESS_INPUT_EVENTS:
            return ""MSG_PROCESS_INPUT_EVENTS"";
        case MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST:
            return ""MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST"";
        case MSG_DISPATCH_WINDOW_ANIMATION_STARTED:
            return ""MSG_DISPATCH_WINDOW_ANIMATION_STARTED"";
        case MSG_DISPATCH_WINDOW_ANIMATION_STOPPED:
            return ""MSG_DISPATCH_WINDOW_ANIMATION_STOPPED"";
        case MSG_WINDOW_MOVED:
            return ""MSG_WINDOW_MOVED"";
        case MSG_SYNTHESIZE_INPUT_EVENT:
            return ""MSG_SYNTHESIZE_INPUT_EVENT"";
        case MSG_DISPATCH_WINDOW_SHOWN:
            return ""MSG_DISPATCH_WINDOW_SHOWN"";
    }
    return super.getMessageName(message);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",0,"There is a change in the `switch` statement: two new cases (MSG_DISPATCH_WINDOW_ANIMATION_STARTED and MSG_DISPATCH_WINDOW_ANIMATION_STOPPED) are added. These changes indicate change type 1,3.","Although new cases are added, there is no indication that these additions would result in a different value returned for the pre-existing `case` statements. The method's functionality is expanded but not altered where it would cause existing behavior to change. Messages that previously matched no case would have returned the result of `super.getMessageName(message)`, which is the same behavior in the late version for unrecognized messages. Hence no CI is detected, which corresponds to situation 0."
467,"<android.content.ContentProviderClient: int delete(Uri,String,String[])>",22,23,"<android.content.ContentProviderClient: int delete(Uri,String,String[])>","<android.content.ContentProviderClient: int delete(Uri,String,String[])>",0,"{
    beforeRemote();
    try {
        return mContentProvider.delete(mPackageName, url, selection, selectionArgs);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}","{
    Preconditions.checkNotNull(url, ""url"");
    beforeRemote();
    try {
        return mContentProvider.delete(mPackageName, url, selection, selectionArgs);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}",1,"/**
 * See {@link ContentProvider#delete ContentProvider.delete}
 */
","/**
 * See {@link ContentProvider#delete ContentProvider.delete}
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"An additional precondition check (Preconditions.checkNotNull(url, ""url"")) has been introduced before the main logic of the method. This change is not related to return statements, exception handling, or control dependency changes; therefore, the code change type is 4.","The newly added precondition only checks for a null URL argument and throws a NullPointerException if it's null, which would have naturally occurred later at the same point the original method made its call to the 'delete' method on 'mContentProvider'. Since it does not affect the overall behavior of the API in terms of what it would return or the exceptions it would throw (besides a potentially more informative exception message), this does not introduce a Compatibility Issue, and thus the CI type is 0."
468,<android.os.Environment: String getExternalStorageState()>,22,23,<android.os.Environment: String getExternalStorageState()>,<android.os.Environment: String getExternalStorageState()>,0,"{
    final File externalDir = sCurrentUser.getExternalDirsForApp()[0];
    return getExternalStorageState(externalDir);
}","{
    final File externalDir = sCurrentUser.getExternalDirs()[0];
    return getExternalStorageState(externalDir);
}",1,"/**
 * Returns the current state of the primary ""external"" storage device.
 *
 * @see #getExternalStorageDirectory()
 * @return one of {@link #MEDIA_UNKNOWN}, {@link #MEDIA_REMOVED},
 * {@link #MEDIA_UNMOUNTED}, {@link #MEDIA_CHECKING},
 * {@link #MEDIA_NOFS}, {@link #MEDIA_MOUNTED},
 * {@link #MEDIA_MOUNTED_READ_ONLY}, {@link #MEDIA_SHARED},
 * {@link #MEDIA_BAD_REMOVAL}, or {@link #MEDIA_UNMOUNTABLE}.
 */
","/**
 * Returns the current state of the primary ""external"" storage device.
 *
 * @see #getExternalStorageDirectory()
 * @return one of {@link #MEDIA_UNKNOWN}, {@link #MEDIA_REMOVED},
 * {@link #MEDIA_UNMOUNTED}, {@link #MEDIA_CHECKING},
 * {@link #MEDIA_NOFS}, {@link #MEDIA_MOUNTED},
 * {@link #MEDIA_MOUNTED_READ_ONLY}, {@link #MEDIA_SHARED},
 * {@link #MEDIA_BAD_REMOVAL}, or {@link #MEDIA_UNMOUNTABLE}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"There is a change in the method called on the `sCurrentUser` object: `getExternalDirsForApp()` has been replaced with `getExternalDirs()`. The modification applies to a dependent API, so the code change type is 5.","Despite the fact that a dependent API has been altered, this change alone does not immediately indicate a Compatibility Issue. Based on the publicly visible signature of the method, which remains the same between versions, and the lack of any other changes in exception handling or return values within this method's body, there is no implication that the different behavior in the dependent API would lead to a different return value on this level. Thus, we deduce no Compatibility Issue unless the behavior of `getExternalDirs()` is different from `getExternalDirsForApp()` in a way that affects the state returned. That information is not provided here, so the default assumption is no Compatibility Issue."
469,"<android.hardware.camera2.legacy.LegacyFaceDetectMapper: void processFaceDetectMode(CaptureRequest,Parameters)>",22,23,"<android.hardware.camera2.legacy.LegacyFaceDetectMapper: void processFaceDetectMode(CaptureRequest,Parameters)>","<android.hardware.camera2.legacy.LegacyFaceDetectMapper: void processFaceDetectMode(CaptureRequest,Parameters)>",0,"{
    checkNotNull(captureRequest, ""captureRequest must not be null"");
    /*
         * statistics.faceDetectMode
         */
    int fdMode = ParamsUtils.getOrDefault(captureRequest, STATISTICS_FACE_DETECT_MODE, STATISTICS_FACE_DETECT_MODE_OFF);
    if (fdMode != STATISTICS_FACE_DETECT_MODE_OFF && !mFaceDetectSupported) {
        Log.w(TAG, ""processFaceDetectMode - Ignoring statistics.faceDetectMode; "" + ""face detection is not available"");
        return;
    }
    /*
         * control.sceneMode
         */
    int sceneMode = ParamsUtils.getOrDefault(captureRequest, CONTROL_SCENE_MODE, CONTROL_SCENE_MODE_DISABLED);
    if (sceneMode == CONTROL_SCENE_MODE_FACE_PRIORITY && !mFaceDetectSupported) {
        Log.w(TAG, ""processFaceDetectMode - ignoring control.sceneMode == FACE_PRIORITY; "" + ""face detection is not available"");
        return;
    }
    // Print some warnings out in case the values were wrong
    switch(fdMode) {
        case STATISTICS_FACE_DETECT_MODE_OFF:
        case STATISTICS_FACE_DETECT_MODE_SIMPLE:
            break;
        case STATISTICS_FACE_DETECT_MODE_FULL:
            Log.w(TAG, ""processFaceDetectMode - statistics.faceDetectMode == FULL unsupported, "" + ""downgrading to SIMPLE"");
            break;
        default:
            Log.w(TAG, ""processFaceDetectMode - ignoring unknown statistics.faceDetectMode = "" + fdMode);
            return;
    }
    boolean enableFaceDetect = (fdMode != STATISTICS_FACE_DETECT_MODE_OFF) || (sceneMode == CONTROL_SCENE_MODE_FACE_PRIORITY);
    synchronized (mLock) {
        // Enable/disable face detection if it's changed since last time
        if (enableFaceDetect != mFaceDetectEnabled) {
            if (enableFaceDetect) {
                mCamera.startFaceDetection();
                if (VERBOSE) {
                    Log.v(TAG, ""processFaceDetectMode - start face detection"");
                }
            } else {
                mCamera.stopFaceDetection();
                if (VERBOSE) {
                    Log.v(TAG, ""processFaceDetectMode - stop face detection"");
                }
                mFaces = null;
            }
            mFaceDetectEnabled = enableFaceDetect;
            mFaceDetectScenePriority = sceneMode == CONTROL_SCENE_MODE_FACE_PRIORITY;
            mFaceDetectReporting = fdMode != STATISTICS_FACE_DETECT_MODE_OFF;
        }
    }
}","{
    checkNotNull(captureRequest, ""captureRequest must not be null"");
    /*
         * statistics.faceDetectMode
         */
    int fdMode = ParamsUtils.getOrDefault(captureRequest, STATISTICS_FACE_DETECT_MODE, STATISTICS_FACE_DETECT_MODE_OFF);
    if (fdMode != STATISTICS_FACE_DETECT_MODE_OFF && !mFaceDetectSupported) {
        Log.w(TAG, ""processFaceDetectMode - Ignoring statistics.faceDetectMode; "" + ""face detection is not available"");
        return;
    }
    /*
         * control.sceneMode
         */
    int sceneMode = ParamsUtils.getOrDefault(captureRequest, CONTROL_SCENE_MODE, CONTROL_SCENE_MODE_DISABLED);
    if (sceneMode == CONTROL_SCENE_MODE_FACE_PRIORITY && !mFaceDetectSupported) {
        Log.w(TAG, ""processFaceDetectMode - ignoring control.sceneMode == FACE_PRIORITY; "" + ""face detection is not available"");
        return;
    }
    // Print some warnings out in case the values were wrong
    switch(fdMode) {
        case STATISTICS_FACE_DETECT_MODE_OFF:
        case STATISTICS_FACE_DETECT_MODE_SIMPLE:
            break;
        case STATISTICS_FACE_DETECT_MODE_FULL:
            Log.w(TAG, ""processFaceDetectMode - statistics.faceDetectMode == FULL unsupported, "" + ""downgrading to SIMPLE"");
            break;
        default:
            Log.w(TAG, ""processFaceDetectMode - ignoring unknown statistics.faceDetectMode = "" + fdMode);
            return;
    }
    boolean enableFaceDetect = (fdMode != STATISTICS_FACE_DETECT_MODE_OFF) || (sceneMode == CONTROL_SCENE_MODE_FACE_PRIORITY);
    synchronized (mLock) {
        // Enable/disable face detection if it's changed since last time
        if (enableFaceDetect != mFaceDetectEnabled) {
            if (enableFaceDetect) {
                mCamera.startFaceDetection();
                if (DEBUG) {
                    Log.v(TAG, ""processFaceDetectMode - start face detection"");
                }
            } else {
                mCamera.stopFaceDetection();
                if (DEBUG) {
                    Log.v(TAG, ""processFaceDetectMode - stop face detection"");
                }
                mFaces = null;
            }
            mFaceDetectEnabled = enableFaceDetect;
            mFaceDetectScenePriority = sceneMode == CONTROL_SCENE_MODE_FACE_PRIORITY;
            mFaceDetectReporting = fdMode != STATISTICS_FACE_DETECT_MODE_OFF;
        }
    }
}",1,"/**
 * Process the face detect mode from the capture request into an api1 face detect toggle.
 *
 * <p>This method should be called after the parameters are {@link LegacyRequestMapper mapped}
 * with the request.</p>
 *
 * <p>Callbacks are processed in the background, and the next call to {@link #mapResultTriggers}
 * will have the latest faces detected as reflected by the camera1 callbacks.</p>
 *
 * <p>None of the arguments will be mutated.</p>
 *
 * @param captureRequest a non-{@code null} request
 * @param parameters a non-{@code null} parameters corresponding to this request (read-only)
 */
","/**
 * Process the face detect mode from the capture request into an api1 face detect toggle.
 *
 * <p>This method should be called after the parameters are {@link LegacyRequestMapper mapped}
 * with the request.</p>
 *
 * <p>Callbacks are processed in the background, and the next call to {@link #mapResultTriggers}
 * will have the latest faces detected as reflected by the camera1 callbacks.</p>
 *
 * <p>None of the arguments will be mutated.</p>
 *
 * @param captureRequest a non-{@code null} request
 * @param parameters a non-{@code null} parameters corresponding to this request (read-only)
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only code change occurs within the logging condition where `VERBOSE` is replaced with `DEBUG`. This is not a functional change, just a change in the log verbosity level, so the code change type is 4.","Since the modification is strictly related to logging and does not affect the logic or the output of the method, it will not cause any compatibility issues. Hence, the CI type is 0."
472,<android.view.View: void draw(Canvas)>,22,23,<android.view.View: void draw(Canvas)>,<android.view.View: void draw(Canvas)>,0,"{
    final int privateFlags = mPrivateFlags;
    final boolean dirtyOpaque = (privateFlags & PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE && (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState);
    mPrivateFlags = (privateFlags & ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;
    /*
         * Draw traversal performs several drawing steps which must be executed
         * in the appropriate order:
         *
         *      1. Draw the background
         *      2. If necessary, save the canvas' layers to prepare for fading
         *      3. Draw view's content
         *      4. Draw children
         *      5. If necessary, draw the fading edges and restore layers
         *      6. Draw decorations (scrollbars for instance)
         */
    // Step 1, draw the background, if needed
    int saveCount;
    if (!dirtyOpaque) {
        drawBackground(canvas);
    }
    // skip step 2 & 5 if possible (common case)
    final int viewFlags = mViewFlags;
    boolean horizontalEdges = (viewFlags & FADING_EDGE_HORIZONTAL) != 0;
    boolean verticalEdges = (viewFlags & FADING_EDGE_VERTICAL) != 0;
    if (!verticalEdges && !horizontalEdges) {
        // Step 3, draw the content
        if (!dirtyOpaque)
            onDraw(canvas);
        // Step 4, draw the children
        dispatchDraw(canvas);
        // Step 6, draw decorations (scrollbars)
        onDrawScrollBars(canvas);
        if (mOverlay != null && !mOverlay.isEmpty()) {
            mOverlay.getOverlayView().dispatchDraw(canvas);
        }
        // we're done...
        return;
    }
    /*
         * Here we do the full fledged routine...
         * (this is an uncommon case where speed matters less,
         * this is why we repeat some of the tests that have been
         * done above)
         */
    boolean drawTop = false;
    boolean drawBottom = false;
    boolean drawLeft = false;
    boolean drawRight = false;
    float topFadeStrength = 0.0f;
    float bottomFadeStrength = 0.0f;
    float leftFadeStrength = 0.0f;
    float rightFadeStrength = 0.0f;
    // Step 2, save the canvas' layers
    int paddingLeft = mPaddingLeft;
    final boolean offsetRequired = isPaddingOffsetRequired();
    if (offsetRequired) {
        paddingLeft += getLeftPaddingOffset();
    }
    int left = mScrollX + paddingLeft;
    int right = left + mRight - mLeft - mPaddingRight - paddingLeft;
    int top = mScrollY + getFadeTop(offsetRequired);
    int bottom = top + getFadeHeight(offsetRequired);
    if (offsetRequired) {
        right += getRightPaddingOffset();
        bottom += getBottomPaddingOffset();
    }
    final ScrollabilityCache scrollabilityCache = mScrollCache;
    final float fadeHeight = scrollabilityCache.fadingEdgeLength;
    int length = (int) fadeHeight;
    // overlapping fades produce odd-looking artifacts
    if (verticalEdges && (top + length > bottom - length)) {
        length = (bottom - top) / 2;
    }
    // also clip horizontal fades if necessary
    if (horizontalEdges && (left + length > right - length)) {
        length = (right - left) / 2;
    }
    if (verticalEdges) {
        topFadeStrength = Math.max(0.0f, Math.min(1.0f, getTopFadingEdgeStrength()));
        drawTop = topFadeStrength * fadeHeight > 1.0f;
        bottomFadeStrength = Math.max(0.0f, Math.min(1.0f, getBottomFadingEdgeStrength()));
        drawBottom = bottomFadeStrength * fadeHeight > 1.0f;
    }
    if (horizontalEdges) {
        leftFadeStrength = Math.max(0.0f, Math.min(1.0f, getLeftFadingEdgeStrength()));
        drawLeft = leftFadeStrength * fadeHeight > 1.0f;
        rightFadeStrength = Math.max(0.0f, Math.min(1.0f, getRightFadingEdgeStrength()));
        drawRight = rightFadeStrength * fadeHeight > 1.0f;
    }
    saveCount = canvas.getSaveCount();
    int solidColor = getSolidColor();
    if (solidColor == 0) {
        final int flags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG;
        if (drawTop) {
            canvas.saveLayer(left, top, right, top + length, null, flags);
        }
        if (drawBottom) {
            canvas.saveLayer(left, bottom - length, right, bottom, null, flags);
        }
        if (drawLeft) {
            canvas.saveLayer(left, top, left + length, bottom, null, flags);
        }
        if (drawRight) {
            canvas.saveLayer(right - length, top, right, bottom, null, flags);
        }
    } else {
        scrollabilityCache.setFadeColor(solidColor);
    }
    // Step 3, draw the content
    if (!dirtyOpaque)
        onDraw(canvas);
    // Step 4, draw the children
    dispatchDraw(canvas);
    // Step 5, draw the fade effect and restore layers
    final Paint p = scrollabilityCache.paint;
    final Matrix matrix = scrollabilityCache.matrix;
    final Shader fade = scrollabilityCache.shader;
    if (drawTop) {
        matrix.setScale(1, fadeHeight * topFadeStrength);
        matrix.postTranslate(left, top);
        fade.setLocalMatrix(matrix);
        p.setShader(fade);
        canvas.drawRect(left, top, right, top + length, p);
    }
    if (drawBottom) {
        matrix.setScale(1, fadeHeight * bottomFadeStrength);
        matrix.postRotate(180);
        matrix.postTranslate(left, bottom);
        fade.setLocalMatrix(matrix);
        p.setShader(fade);
        canvas.drawRect(left, bottom - length, right, bottom, p);
    }
    if (drawLeft) {
        matrix.setScale(1, fadeHeight * leftFadeStrength);
        matrix.postRotate(-90);
        matrix.postTranslate(left, top);
        fade.setLocalMatrix(matrix);
        p.setShader(fade);
        canvas.drawRect(left, top, left + length, bottom, p);
    }
    if (drawRight) {
        matrix.setScale(1, fadeHeight * rightFadeStrength);
        matrix.postRotate(90);
        matrix.postTranslate(right, top);
        fade.setLocalMatrix(matrix);
        p.setShader(fade);
        canvas.drawRect(right - length, top, right, bottom, p);
    }
    canvas.restoreToCount(saveCount);
    // Step 6, draw decorations (scrollbars)
    onDrawScrollBars(canvas);
    if (mOverlay != null && !mOverlay.isEmpty()) {
        mOverlay.getOverlayView().dispatchDraw(canvas);
    }
}","{
    final int privateFlags = mPrivateFlags;
    final boolean dirtyOpaque = (privateFlags & PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE && (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState);
    mPrivateFlags = (privateFlags & ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;
    /*
         * Draw traversal performs several drawing steps which must be executed
         * in the appropriate order:
         *
         *      1. Draw the background
         *      2. If necessary, save the canvas' layers to prepare for fading
         *      3. Draw view's content
         *      4. Draw children
         *      5. If necessary, draw the fading edges and restore layers
         *      6. Draw decorations (scrollbars for instance)
         */
    // Step 1, draw the background, if needed
    int saveCount;
    if (!dirtyOpaque) {
        drawBackground(canvas);
    }
    // skip step 2 & 5 if possible (common case)
    final int viewFlags = mViewFlags;
    boolean horizontalEdges = (viewFlags & FADING_EDGE_HORIZONTAL) != 0;
    boolean verticalEdges = (viewFlags & FADING_EDGE_VERTICAL) != 0;
    if (!verticalEdges && !horizontalEdges) {
        // Step 3, draw the content
        if (!dirtyOpaque)
            onDraw(canvas);
        // Step 4, draw the children
        dispatchDraw(canvas);
        // Overlay is part of the content and draws beneath Foreground
        if (mOverlay != null && !mOverlay.isEmpty()) {
            mOverlay.getOverlayView().dispatchDraw(canvas);
        }
        // Step 6, draw decorations (foreground, scrollbars)
        onDrawForeground(canvas);
        // we're done...
        return;
    }
    /*
         * Here we do the full fledged routine...
         * (this is an uncommon case where speed matters less,
         * this is why we repeat some of the tests that have been
         * done above)
         */
    boolean drawTop = false;
    boolean drawBottom = false;
    boolean drawLeft = false;
    boolean drawRight = false;
    float topFadeStrength = 0.0f;
    float bottomFadeStrength = 0.0f;
    float leftFadeStrength = 0.0f;
    float rightFadeStrength = 0.0f;
    // Step 2, save the canvas' layers
    int paddingLeft = mPaddingLeft;
    final boolean offsetRequired = isPaddingOffsetRequired();
    if (offsetRequired) {
        paddingLeft += getLeftPaddingOffset();
    }
    int left = mScrollX + paddingLeft;
    int right = left + mRight - mLeft - mPaddingRight - paddingLeft;
    int top = mScrollY + getFadeTop(offsetRequired);
    int bottom = top + getFadeHeight(offsetRequired);
    if (offsetRequired) {
        right += getRightPaddingOffset();
        bottom += getBottomPaddingOffset();
    }
    final ScrollabilityCache scrollabilityCache = mScrollCache;
    final float fadeHeight = scrollabilityCache.fadingEdgeLength;
    int length = (int) fadeHeight;
    // overlapping fades produce odd-looking artifacts
    if (verticalEdges && (top + length > bottom - length)) {
        length = (bottom - top) / 2;
    }
    // also clip horizontal fades if necessary
    if (horizontalEdges && (left + length > right - length)) {
        length = (right - left) / 2;
    }
    if (verticalEdges) {
        topFadeStrength = Math.max(0.0f, Math.min(1.0f, getTopFadingEdgeStrength()));
        drawTop = topFadeStrength * fadeHeight > 1.0f;
        bottomFadeStrength = Math.max(0.0f, Math.min(1.0f, getBottomFadingEdgeStrength()));
        drawBottom = bottomFadeStrength * fadeHeight > 1.0f;
    }
    if (horizontalEdges) {
        leftFadeStrength = Math.max(0.0f, Math.min(1.0f, getLeftFadingEdgeStrength()));
        drawLeft = leftFadeStrength * fadeHeight > 1.0f;
        rightFadeStrength = Math.max(0.0f, Math.min(1.0f, getRightFadingEdgeStrength()));
        drawRight = rightFadeStrength * fadeHeight > 1.0f;
    }
    saveCount = canvas.getSaveCount();
    int solidColor = getSolidColor();
    if (solidColor == 0) {
        final int flags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG;
        if (drawTop) {
            canvas.saveLayer(left, top, right, top + length, null, flags);
        }
        if (drawBottom) {
            canvas.saveLayer(left, bottom - length, right, bottom, null, flags);
        }
        if (drawLeft) {
            canvas.saveLayer(left, top, left + length, bottom, null, flags);
        }
        if (drawRight) {
            canvas.saveLayer(right - length, top, right, bottom, null, flags);
        }
    } else {
        scrollabilityCache.setFadeColor(solidColor);
    }
    // Step 3, draw the content
    if (!dirtyOpaque)
        onDraw(canvas);
    // Step 4, draw the children
    dispatchDraw(canvas);
    // Step 5, draw the fade effect and restore layers
    final Paint p = scrollabilityCache.paint;
    final Matrix matrix = scrollabilityCache.matrix;
    final Shader fade = scrollabilityCache.shader;
    if (drawTop) {
        matrix.setScale(1, fadeHeight * topFadeStrength);
        matrix.postTranslate(left, top);
        fade.setLocalMatrix(matrix);
        p.setShader(fade);
        canvas.drawRect(left, top, right, top + length, p);
    }
    if (drawBottom) {
        matrix.setScale(1, fadeHeight * bottomFadeStrength);
        matrix.postRotate(180);
        matrix.postTranslate(left, bottom);
        fade.setLocalMatrix(matrix);
        p.setShader(fade);
        canvas.drawRect(left, bottom - length, right, bottom, p);
    }
    if (drawLeft) {
        matrix.setScale(1, fadeHeight * leftFadeStrength);
        matrix.postRotate(-90);
        matrix.postTranslate(left, top);
        fade.setLocalMatrix(matrix);
        p.setShader(fade);
        canvas.drawRect(left, top, left + length, bottom, p);
    }
    if (drawRight) {
        matrix.setScale(1, fadeHeight * rightFadeStrength);
        matrix.postRotate(90);
        matrix.postTranslate(right, top);
        fade.setLocalMatrix(matrix);
        p.setShader(fade);
        canvas.drawRect(right - length, top, right, bottom, p);
    }
    canvas.restoreToCount(saveCount);
    // Overlay is part of the content and draws beneath Foreground
    if (mOverlay != null && !mOverlay.isEmpty()) {
        mOverlay.getOverlayView().dispatchDraw(canvas);
    }
    // Step 6, draw decorations (foreground, scrollbars)
    onDrawForeground(canvas);
}",1,"/**
 * Manually render this view (and all of its children) to the given Canvas.
 * The view must have already done a full layout before this function is
 * called.  When implementing a view, implement
 * {@link #onDraw(android.graphics.Canvas)} instead of overriding this method.
 * If you do need to override this method, call the superclass version.
 *
 * @param canvas The Canvas to which the View is rendered.
 */
","/**
 * Manually render this view (and all of its children) to the given Canvas.
 * The view must have already done a full layout before this function is
 * called.  When implementing a view, implement
 * {@link #onDraw(android.graphics.Canvas)} instead of overriding this method.
 * If you do need to override this method, call the superclass version.
 *
 * @param canvas The Canvas to which the View is rendered.
 */
",-1,,[@CallSuper],-1,-1,-1,-1,-1,-1,,,,
473,<android.widget.TextView: TextDirectionHeuristic getTextDirectionHeuristic()>,22,23,<android.widget.TextView: TextDirectionHeuristic getTextDirectionHeuristic()>,<android.widget.TextView: TextDirectionHeuristic getTextDirectionHeuristic()>,0,"{
    if (hasPasswordTransformationMethod()) {
        // passwords fields should be LTR
        return TextDirectionHeuristics.LTR;
    }
    // Always need to resolve layout direction first
    final boolean defaultIsRtl = (getLayoutDirection() == LAYOUT_DIRECTION_RTL);
    // Now, we can select the heuristic
    switch(getTextDirection()) {
        default:
        case TEXT_DIRECTION_FIRST_STRONG:
            return (defaultIsRtl ? TextDirectionHeuristics.FIRSTSTRONG_RTL : TextDirectionHeuristics.FIRSTSTRONG_LTR);
        case TEXT_DIRECTION_ANY_RTL:
            return TextDirectionHeuristics.ANYRTL_LTR;
        case TEXT_DIRECTION_LTR:
            return TextDirectionHeuristics.LTR;
        case TEXT_DIRECTION_RTL:
            return TextDirectionHeuristics.RTL;
        case TEXT_DIRECTION_LOCALE:
            return TextDirectionHeuristics.LOCALE;
    }
}","{
    if (hasPasswordTransformationMethod()) {
        // passwords fields should be LTR
        return TextDirectionHeuristics.LTR;
    }
    // Always need to resolve layout direction first
    final boolean defaultIsRtl = (getLayoutDirection() == LAYOUT_DIRECTION_RTL);
    // Now, we can select the heuristic
    switch(getTextDirection()) {
        default:
        case TEXT_DIRECTION_FIRST_STRONG:
            return (defaultIsRtl ? TextDirectionHeuristics.FIRSTSTRONG_RTL : TextDirectionHeuristics.FIRSTSTRONG_LTR);
        case TEXT_DIRECTION_ANY_RTL:
            return TextDirectionHeuristics.ANYRTL_LTR;
        case TEXT_DIRECTION_LTR:
            return TextDirectionHeuristics.LTR;
        case TEXT_DIRECTION_RTL:
            return TextDirectionHeuristics.RTL;
        case TEXT_DIRECTION_LOCALE:
            return TextDirectionHeuristics.LOCALE;
        case TEXT_DIRECTION_FIRST_STRONG_LTR:
            return TextDirectionHeuristics.FIRSTSTRONG_LTR;
        case TEXT_DIRECTION_FIRST_STRONG_RTL:
            return TextDirectionHeuristics.FIRSTSTRONG_RTL;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,0,"A control dependency has changed with the addition of two new cases (`TEXT_DIRECTION_FIRST_STRONG_LTR` and `TEXT_DIRECTION_FIRST_STRONG_RTL`) in the `switch` statement, indicating type 3 change.","No Compatibility Issue arises because the added cases for `TEXT_DIRECTION_FIRST_STRONG_LTR` and `TEXT_DIRECTION_FIRST_STRONG_RTL` provide specific return values that align with the existing default behavior for `TEXT_DIRECTION_FIRST_STRONG`. The return values for the other cases remain unchanged, thereby not affecting existing behavior and not leading to a compatibility issue."
475,<android.app.ContextImpl: Object getSystemService(String)>,22,23,<android.app.ContextImpl: Object getSystemService(String)>,<android.app.ContextImpl: Object getSystemService(String)>,0,"{
    ServiceFetcher fetcher = SYSTEM_SERVICE_MAP.get(name);
    return fetcher == null ? null : fetcher.getService(this);
}","{
    return SystemServiceRegistry.getSystemService(this, name);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The implementation of the getSystemService method has changed, with the SERVICE_MAP lookup being replaced by a call to SystemServiceRegistry.getSystemService. This change is a dependent API changed, indicated by code change type 5.","The reimplemented method internally delegates to another method, and there's no change in the expected behavior or contract of the API. There are no apparent differences in return values or the way exceptions are handled; hence, there is no compatibility issue, resulting in CI type 0."
476,<android.hardware.camera2.legacy.LegacyExceptionUtils: int throwOnError(int)>,22,23,<android.hardware.camera2.legacy.LegacyExceptionUtils: int throwOnError(int)>,<android.hardware.camera2.legacy.LegacyExceptionUtils: int throwOnError(int)>,0,"{
    switch(errorFlag) {
        case CameraBinderDecorator.NO_ERROR:
            {
                return CameraBinderDecorator.NO_ERROR;
            }
        case CameraBinderDecorator.ENODEV:
            {
                throw new BufferQueueAbandonedException();
            }
    }
    if (errorFlag < 0) {
        throw new UnsupportedOperationException(""Unknown error "" + errorFlag);
    }
    return errorFlag;
}","{
    switch(errorFlag) {
        case CameraBinderDecorator.NO_ERROR:
            {
                return CameraBinderDecorator.NO_ERROR;
            }
        case CameraBinderDecorator.BAD_VALUE:
            {
                throw new BufferQueueAbandonedException();
            }
    }
    if (errorFlag < 0) {
        throw new UnsupportedOperationException(""Unknown error "" + errorFlag);
    }
    return errorFlag;
}",1,"/**
 * Throw error codes used by legacy device methods as exceptions.
 *
 * <p>Non-negative return values are passed through, negative return values are thrown as
 * exceptions.</p>
 *
 * @param errorFlag error to throw as an exception.
 * @throws {@link BufferQueueAbandonedException} for {@link CameraBinderDecorator#ENODEV}.
 * @throws {@link UnsupportedOperationException} for an unknown negative error code.
 * @return {@code errorFlag} if the value was non-negative, throws otherwise.
 */
","/**
 * Throw error codes used by legacy device methods as exceptions.
 *
 * <p>Non-negative return values are passed through, negative return values are thrown as
 * exceptions.</p>
 *
 * @param errorFlag error to throw as an exception.
 * @throws {@link BufferQueueAbandonedException} for {@link CameraBinderDecorator#ENODEV}.
 * @throws {@link UnsupportedOperationException} for an unknown negative error code.
 * @return {@code errorFlag} if the value was non-negative, throws otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"There is a change within a switch-case statement, where the case has changed from `CameraBinderDecorator.ENODEV` to `CameraBinderDecorator.BAD_VALUE`. This is a control dependency change, so the code change type is 3.","The switched case from `CameraBinderDecorator.ENODEV` to `CameraBinderDecorator.BAD_VALUE` does not introduce a Compatibility Issue because the overall behavior of the method remains the same: it throws an exception for an error. Whether it throws for `BAD_VALUE` instead of `ENODEV`, the method still throws `BufferQueueAbandonedException` for an error and `UnsupportedOperationException` for unknown errors. There's no new behavior introduced, so there's no Compatibility Issue, which classifies as 0."
478,<android.content.res.Resources: ColorStateList getColorStateList(int)>,22,23,<android.content.res.Resources: ColorStateList getColorStateList(int)>,<android.content.res.Resources: ColorStateList getColorStateList(int)>,0,"{
    TypedValue value;
    synchronized (mAccessLock) {
        value = mTmpValue;
        if (value == null) {
            value = new TypedValue();
        } else {
            mTmpValue = null;
        }
        getValue(id, value, true);
    }
    ColorStateList res = loadColorStateList(value, id);
    synchronized (mAccessLock) {
        if (mTmpValue == null) {
            mTmpValue = value;
        }
    }
    return res;
}","{
    final ColorStateList csl = getColorStateList(id, null);
    if (csl != null && csl.canApplyTheme()) {
        Log.w(TAG, ""ColorStateList "" + getResourceName(id) + "" has "" + ""unresolved theme attributes! Consider using "" + ""Resources.getColorStateList(int, Theme) or "" + ""Context.getColorStateList(int)."", new RuntimeException());
    }
    return csl;
}",1,"/**
 * Return a color state list associated with a particular resource ID.  The
 * resource may contain either a single raw color value, or a complex
 * {@link android.content.res.ColorStateList} holding multiple possible colors.
 *
 * @param id The desired resource identifier of a {@link ColorStateList},
 * as generated by the aapt tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @return Returns a ColorStateList object containing either a single
 * solid color or multiple colors that can be selected based on a state.
 */
","/**
 * Returns a color state list associated with a particular resource ID. The
 * resource may contain either a single raw color value or a complex
 * {@link ColorStateList} holding multiple possible colors.
 *
 * @param id The desired resource identifier of a {@link ColorStateList},
 * as generated by the aapt tool. This integer encodes the
 * package, type, and resource entry. The value 0 is an invalid
 * identifier.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does
 * not exist.
 *
 * @return A ColorStateList object containing either a single solid color
 * or multiple colors that can be selected based on a state.
 * @deprecated Use {@link #getColorStateList(int, Theme)} instead.
 */
",-1,,"[@Nullable, @Deprecated]",-1,-1,-1,-1,-1,-1,"1,4,5",1,"The method implementation has been significantly modified with a new process flow. It has gone from a manual retrieval and synchronization on mAccessLock to a direct call to getColorStateList, which returns a potentially nullable ColorStateList and can trigger a warning log if the theme attributes are unresolved. This constitutes a significant code change including a return statement change (1), dependent API changed (5), as well as an other statement changed (4).","The new implementation could potentially return a different ColorStateList object from the older version because it relies on whether csl can apply a theme, which was not a condition in the early version. Also, the additional logging can reveal different runtime behavior. Therefore, a Compatibility Issue (CI) of type 1, which is caused by potential different return values or types, exists."
479,"<android.os.BatteryStats.HistoryEventTracker: boolean updateState(int,String,int,int)>",22,23,"<android.os.BatteryStats.HistoryEventTracker: boolean updateState(int,String,int,int)>","<android.os.BatteryStats.HistoryEventTracker: boolean updateState(int,String,int,int)>",0,"{
    if ((code & HistoryItem.EVENT_FLAG_START) != 0) {
        int idx = code & HistoryItem.EVENT_TYPE_MASK;
        HashMap<String, SparseIntArray> active = mActiveEvents[idx];
        if (active == null) {
            active = new HashMap<String, SparseIntArray>();
            mActiveEvents[idx] = active;
        }
        SparseIntArray uids = active.get(name);
        if (uids == null) {
            uids = new SparseIntArray();
            active.put(name, uids);
        }
        if (uids.indexOfKey(uid) >= 0) {
            // Already set, nothing to do!
            return false;
        }
        uids.put(uid, poolIdx);
    } else if ((code & HistoryItem.EVENT_FLAG_FINISH) != 0) {
        int idx = code & HistoryItem.EVENT_TYPE_MASK;
        HashMap<String, SparseIntArray> active = mActiveEvents[idx];
        if (active == null) {
            // not currently active, nothing to do.
            return false;
        }
        SparseIntArray uids = active.get(name);
        if (uids == null) {
            // not currently active, nothing to do.
            return false;
        }
        idx = uids.indexOfKey(uid);
        if (idx < 0) {
            // not currently active, nothing to do.
            return false;
        }
        uids.removeAt(idx);
        if (uids.size() <= 0) {
            active.remove(name);
        }
    }
    return true;
}","{
    if ((code & HistoryItem.EVENT_FLAG_START) != 0) {
        int idx = code & HistoryItem.EVENT_TYPE_MASK;
        HashMap<String, SparseIntArray> active = mActiveEvents[idx];
        if (active == null) {
            active = new HashMap<>();
            mActiveEvents[idx] = active;
        }
        SparseIntArray uids = active.get(name);
        if (uids == null) {
            uids = new SparseIntArray();
            active.put(name, uids);
        }
        if (uids.indexOfKey(uid) >= 0) {
            // Already set, nothing to do!
            return false;
        }
        uids.put(uid, poolIdx);
    } else if ((code & HistoryItem.EVENT_FLAG_FINISH) != 0) {
        int idx = code & HistoryItem.EVENT_TYPE_MASK;
        HashMap<String, SparseIntArray> active = mActiveEvents[idx];
        if (active == null) {
            // not currently active, nothing to do.
            return false;
        }
        SparseIntArray uids = active.get(name);
        if (uids == null) {
            // not currently active, nothing to do.
            return false;
        }
        idx = uids.indexOfKey(uid);
        if (idx < 0) {
            // not currently active, nothing to do.
            return false;
        }
        uids.removeAt(idx);
        if (uids.size() <= 0) {
            active.remove(name);
        }
    }
    return true;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,The only change is the use of the diamond operator in HashMap instantiation. This change is syntax sugar and does not affect the semantics of the code. The change type is therefore 4.,"There is no Compatibility Issue because the behavior of the method remains the same; the change in the code does not affect the return values, exceptions thrown, or control flow, so there is no CI. The use of the diamond operator simply infers the type parameters from the context, and it would compile to the same bytecode as the explicit type parameters in earlier versions of Java."
483,"<android.hardware.camera2.legacy.SurfaceTextureRenderer: void configureSurfaces(Collection<Pair<Surface, Size>>)>",22,23,"<android.hardware.camera2.legacy.SurfaceTextureRenderer: void configureSurfaces(Collection<Pair<Surface, Size>>)>","<android.hardware.camera2.legacy.SurfaceTextureRenderer: void configureSurfaces(Collection<Pair<Surface, Size>>)>",0,"{
    releaseEGLContext();
    if (surfaces == null || surfaces.size() == 0) {
        Log.w(TAG, ""No output surfaces configured for GL drawing."");
        return;
    }
    for (Pair<Surface, Size> p : surfaces) {
        Surface s = p.first;
        Size surfaceSize = p.second;
        // If pixel conversions aren't handled by egl, use a pbuffer
        try {
            EGLSurfaceHolder holder = new EGLSurfaceHolder();
            holder.surface = s;
            holder.width = surfaceSize.getWidth();
            holder.height = surfaceSize.getHeight();
            if (LegacyCameraDevice.needsConversion(s)) {
                // Always override to YV12 output for YUV surface formats.
                LegacyCameraDevice.setSurfaceFormat(s, ImageFormat.YV12);
                mConversionSurfaces.add(holder);
            } else {
                mSurfaces.add(holder);
            }
        } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
            Log.w(TAG, ""Surface abandoned, skipping configuration... "", e);
        }
    }
    // Set up egl display
    configureEGLContext();
    // Set up regular egl surfaces if needed
    if (mSurfaces.size() > 0) {
        configureEGLOutputSurfaces(mSurfaces);
    }
    // Set up pbuffer surface if needed
    if (mConversionSurfaces.size() > 0) {
        configureEGLPbufferSurfaces(mConversionSurfaces);
    }
    makeCurrent((mSurfaces.size() > 0) ? mSurfaces.get(0).eglSurface : mConversionSurfaces.get(0).eglSurface);
    initializeGLState();
    mSurfaceTexture = new SurfaceTexture(getTextureId());
    // Set up performance tracking if enabled
    if (SystemProperties.getBoolean(LEGACY_PERF_PROPERTY, false)) {
        setupGlTiming();
    }
}","{
    releaseEGLContext();
    if (surfaces == null || surfaces.size() == 0) {
        Log.w(TAG, ""No output surfaces configured for GL drawing."");
        return;
    }
    for (Pair<Surface, Size> p : surfaces) {
        Surface s = p.first;
        Size surfaceSize = p.second;
        // If pixel conversions aren't handled by egl, use a pbuffer
        try {
            EGLSurfaceHolder holder = new EGLSurfaceHolder();
            holder.surface = s;
            holder.width = surfaceSize.getWidth();
            holder.height = surfaceSize.getHeight();
            if (LegacyCameraDevice.needsConversion(s)) {
                mConversionSurfaces.add(holder);
            } else {
                mSurfaces.add(holder);
            }
        } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
            Log.w(TAG, ""Surface abandoned, skipping configuration... "", e);
        }
    }
    // Set up egl display
    configureEGLContext();
    // Set up regular egl surfaces if needed
    if (mSurfaces.size() > 0) {
        configureEGLOutputSurfaces(mSurfaces);
    }
    // Set up pbuffer surface if needed
    if (mConversionSurfaces.size() > 0) {
        configureEGLPbufferSurfaces(mConversionSurfaces);
    }
    makeCurrent((mSurfaces.size() > 0) ? mSurfaces.get(0).eglSurface : mConversionSurfaces.get(0).eglSurface);
    initializeGLState();
    mSurfaceTexture = new SurfaceTexture(getTextureId());
    // Set up performance tracking if enabled
    if (SystemProperties.getBoolean(LEGACY_PERF_PROPERTY, false)) {
        setupGlTiming();
    }
}",1,"/**
 * Set a collection of output {@link Surface}s that can be drawn to.
 *
 * @param surfaces a {@link Collection} of surfaces.
 */
","/**
 * Set a collection of output {@link Surface}s that can be drawn to.
 *
 * @param surfaces a {@link Collection} of surfaces.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,There is the deletion of an other statement call and it's a dependent API changed:,
484,<android.content.IntentFilter: void writeToXml(XmlSerializer)>,22,23,<android.content.IntentFilter: void writeToXml(XmlSerializer)>,<android.content.IntentFilter: void writeToXml(XmlSerializer)>,0,"{
    int N = countActions();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, ACTION_STR);
        serializer.attribute(null, NAME_STR, mActions.get(i));
        serializer.endTag(null, ACTION_STR);
    }
    N = countCategories();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, CAT_STR);
        serializer.attribute(null, NAME_STR, mCategories.get(i));
        serializer.endTag(null, CAT_STR);
    }
    N = countDataTypes();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, TYPE_STR);
        String type = mDataTypes.get(i);
        if (type.indexOf('/') < 0)
            type = type + ""/*"";
        serializer.attribute(null, NAME_STR, type);
        serializer.endTag(null, TYPE_STR);
    }
    N = countDataSchemes();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, SCHEME_STR);
        serializer.attribute(null, NAME_STR, mDataSchemes.get(i));
        serializer.endTag(null, SCHEME_STR);
    }
    N = countDataSchemeSpecificParts();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, SSP_STR);
        PatternMatcher pe = mDataSchemeSpecificParts.get(i);
        switch(pe.getType()) {
            case PatternMatcher.PATTERN_LITERAL:
                serializer.attribute(null, LITERAL_STR, pe.getPath());
                break;
            case PatternMatcher.PATTERN_PREFIX:
                serializer.attribute(null, PREFIX_STR, pe.getPath());
                break;
            case PatternMatcher.PATTERN_SIMPLE_GLOB:
                serializer.attribute(null, SGLOB_STR, pe.getPath());
                break;
        }
        serializer.endTag(null, SSP_STR);
    }
    N = countDataAuthorities();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, AUTH_STR);
        AuthorityEntry ae = mDataAuthorities.get(i);
        serializer.attribute(null, HOST_STR, ae.getHost());
        if (ae.getPort() >= 0) {
            serializer.attribute(null, PORT_STR, Integer.toString(ae.getPort()));
        }
        serializer.endTag(null, AUTH_STR);
    }
    N = countDataPaths();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, PATH_STR);
        PatternMatcher pe = mDataPaths.get(i);
        switch(pe.getType()) {
            case PatternMatcher.PATTERN_LITERAL:
                serializer.attribute(null, LITERAL_STR, pe.getPath());
                break;
            case PatternMatcher.PATTERN_PREFIX:
                serializer.attribute(null, PREFIX_STR, pe.getPath());
                break;
            case PatternMatcher.PATTERN_SIMPLE_GLOB:
                serializer.attribute(null, SGLOB_STR, pe.getPath());
                break;
        }
        serializer.endTag(null, PATH_STR);
    }
}","{
    if (getAutoVerify()) {
        serializer.attribute(null, AUTO_VERIFY_STR, Boolean.toString(true));
    }
    int N = countActions();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, ACTION_STR);
        serializer.attribute(null, NAME_STR, mActions.get(i));
        serializer.endTag(null, ACTION_STR);
    }
    N = countCategories();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, CAT_STR);
        serializer.attribute(null, NAME_STR, mCategories.get(i));
        serializer.endTag(null, CAT_STR);
    }
    N = countDataTypes();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, TYPE_STR);
        String type = mDataTypes.get(i);
        if (type.indexOf('/') < 0)
            type = type + ""/*"";
        serializer.attribute(null, NAME_STR, type);
        serializer.endTag(null, TYPE_STR);
    }
    N = countDataSchemes();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, SCHEME_STR);
        serializer.attribute(null, NAME_STR, mDataSchemes.get(i));
        serializer.endTag(null, SCHEME_STR);
    }
    N = countDataSchemeSpecificParts();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, SSP_STR);
        PatternMatcher pe = mDataSchemeSpecificParts.get(i);
        switch(pe.getType()) {
            case PatternMatcher.PATTERN_LITERAL:
                serializer.attribute(null, LITERAL_STR, pe.getPath());
                break;
            case PatternMatcher.PATTERN_PREFIX:
                serializer.attribute(null, PREFIX_STR, pe.getPath());
                break;
            case PatternMatcher.PATTERN_SIMPLE_GLOB:
                serializer.attribute(null, SGLOB_STR, pe.getPath());
                break;
        }
        serializer.endTag(null, SSP_STR);
    }
    N = countDataAuthorities();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, AUTH_STR);
        AuthorityEntry ae = mDataAuthorities.get(i);
        serializer.attribute(null, HOST_STR, ae.getHost());
        if (ae.getPort() >= 0) {
            serializer.attribute(null, PORT_STR, Integer.toString(ae.getPort()));
        }
        serializer.endTag(null, AUTH_STR);
    }
    N = countDataPaths();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, PATH_STR);
        PatternMatcher pe = mDataPaths.get(i);
        switch(pe.getType()) {
            case PatternMatcher.PATTERN_LITERAL:
                serializer.attribute(null, LITERAL_STR, pe.getPath());
                break;
            case PatternMatcher.PATTERN_PREFIX:
                serializer.attribute(null, PREFIX_STR, pe.getPath());
                break;
            case PatternMatcher.PATTERN_SIMPLE_GLOB:
                serializer.attribute(null, SGLOB_STR, pe.getPath());
                break;
        }
        serializer.endTag(null, PATH_STR);
    }
}",1,"/**
 * Write the contents of the IntentFilter as an XML stream.
 */
","/**
 * Write the contents of the IntentFilter as an XML stream.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
485,<android.hardware.camera2.legacy.RequestHandlerThread: void waitUntilIdle()>,22,23,<android.hardware.camera2.legacy.RequestHandlerThread: void waitUntilIdle()>,<android.hardware.camera2.legacy.RequestHandlerThread: void waitUntilIdle()>,0,"{
    Handler handler = waitAndGetHandler();
    Looper looper = handler.getLooper();
    if (looper.isIdling()) {
        return;
    }
    mIdle.close();
    looper.getQueue().addIdleHandler(mIdleHandler);
    // Ensure that the idle handler gets run even if the looper already went idle
    handler.sendEmptyMessage(MSG_POKE_IDLE_HANDLER);
    if (looper.isIdling()) {
        return;
    }
    mIdle.block();
}","{
    Handler handler = waitAndGetHandler();
    MessageQueue queue = handler.getLooper().getQueue();
    if (queue.isIdle()) {
        return;
    }
    mIdle.close();
    queue.addIdleHandler(mIdleHandler);
    // Ensure that the idle handler gets run even if the looper already went idle
    handler.sendEmptyMessage(MSG_POKE_IDLE_HANDLER);
    if (queue.isIdle()) {
        return;
    }
    mIdle.block();
}",1,"// Blocks until thread is idling
","// Blocks until thread is idling
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change occurs due to storing the return value of `handler.getLooper().getQueue()` into the local variable `queue` and using `queue.isIdle()` instead of using `looper.isIdling()`. This alteration is simply a refactoring to use the `MessageQueue` instance directly instead of calling the method `isIdling` on a `Looper` object, so the change type is 4.","There is no change in the way the method behaves externally. Both versions effectively check if the queue is idle and perform the same operations, and the functionality remains identical. Therefore, there is no compatibility issue, and the CI type is 0."
486,<android.transition.TransitionManager.MultiListener: boolean onPreDraw()>,22,23,<android.transition.TransitionManager.MultiListener: boolean onPreDraw()>,<android.transition.TransitionManager.MultiListener: boolean onPreDraw()>,0,"{
    removeListeners();
    sPendingTransitions.remove(mSceneRoot);
    // Add to running list, handle end to remove it
    final ArrayMap<ViewGroup, ArrayList<Transition>> runningTransitions = getRunningTransitions();
    ArrayList<Transition> currentTransitions = runningTransitions.get(mSceneRoot);
    ArrayList<Transition> previousRunningTransitions = null;
    if (currentTransitions == null) {
        currentTransitions = new ArrayList<Transition>();
        runningTransitions.put(mSceneRoot, currentTransitions);
    } else if (currentTransitions.size() > 0) {
        previousRunningTransitions = new ArrayList<Transition>(currentTransitions);
    }
    currentTransitions.add(mTransition);
    mTransition.addListener(new Transition.TransitionListenerAdapter() {

        @Override
        public void onTransitionEnd(Transition transition) {
            ArrayList<Transition> currentTransitions = runningTransitions.get(mSceneRoot);
            currentTransitions.remove(transition);
        }
    });
    mTransition.captureValues(mSceneRoot, false);
    if (previousRunningTransitions != null) {
        for (Transition runningTransition : previousRunningTransitions) {
            runningTransition.resume(mSceneRoot);
        }
    }
    mTransition.playTransition(mSceneRoot);
    return true;
}","{
    removeListeners();
    // Don't start the transition if it's no longer pending.
    if (!sPendingTransitions.remove(mSceneRoot)) {
        return true;
    }
    // Add to running list, handle end to remove it
    final ArrayMap<ViewGroup, ArrayList<Transition>> runningTransitions = getRunningTransitions();
    ArrayList<Transition> currentTransitions = runningTransitions.get(mSceneRoot);
    ArrayList<Transition> previousRunningTransitions = null;
    if (currentTransitions == null) {
        currentTransitions = new ArrayList<Transition>();
        runningTransitions.put(mSceneRoot, currentTransitions);
    } else if (currentTransitions.size() > 0) {
        previousRunningTransitions = new ArrayList<Transition>(currentTransitions);
    }
    currentTransitions.add(mTransition);
    mTransition.addListener(new Transition.TransitionListenerAdapter() {

        @Override
        public void onTransitionEnd(Transition transition) {
            ArrayList<Transition> currentTransitions = runningTransitions.get(mSceneRoot);
            currentTransitions.remove(transition);
        }
    });
    mTransition.captureValues(mSceneRoot, false);
    if (previousRunningTransitions != null) {
        for (Transition runningTransition : previousRunningTransitions) {
            runningTransition.resume(mSceneRoot);
        }
    }
    mTransition.playTransition(mSceneRoot);
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"The change includes a new 'if' conditional check `if (!sPendingTransitions.remove(mSceneRoot))` and the associated return statement `return true;` being introduced before the execution of transition operations. Additionally, the original sPendingTransitions.remove(mSceneRoot) was removed from where it was earlier placed, resulting in changes in the control dependency and other statements, hence the code change type is 3,4.","The introduction of the new conditional check can cause the method to return `true` and terminate early without executing the subsequent transition logic that was always executed in the earlier version. This constitutes a change in behavior that can potentially lead to different return values when conditions are met for that early return. Thus, the CI type is 1."
487,<android.hardware.camera2.params.StreamConfigurationMap: int checkArgumentFormatInternal(int)>,22,23,<android.hardware.camera2.params.StreamConfigurationMap: int checkArgumentFormatInternal(int)>,<android.hardware.camera2.params.StreamConfigurationMap: int checkArgumentFormatInternal(int)>,0,"{
    switch(format) {
        case HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED:
        case HAL_PIXEL_FORMAT_BLOB:
        case HAL_PIXEL_FORMAT_RAW_OPAQUE:
            return format;
        case ImageFormat.JPEG:
            throw new IllegalArgumentException(""ImageFormat.JPEG is an unknown internal format"");
        default:
            return checkArgumentFormat(format);
    }
}","{
    switch(format) {
        case HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED:
        case HAL_PIXEL_FORMAT_BLOB:
        case HAL_PIXEL_FORMAT_RAW_OPAQUE:
        case HAL_PIXEL_FORMAT_Y16:
            return format;
        case ImageFormat.JPEG:
            throw new IllegalArgumentException(""ImageFormat.JPEG is an unknown internal format"");
        default:
            return checkArgumentFormat(format);
    }
}",1,"/**
 * Ensures that the format is either user-defined or implementation defined.
 *
 * <p>If a format has a different internal representation than the public representation,
 * passing in the public representation here will fail.</p>
 *
 * <p>For example if trying to use {@link ImageFormat#JPEG}:
 * it has a different public representation than the internal representation
 * {@code HAL_PIXEL_FORMAT_BLOB}, this check will fail.</p>
 *
 * <p>Any invalid/undefined formats will raise an exception.</p>
 *
 * @param format image format
 * @return the format
 *
 * @throws IllegalArgumentException if the format was invalid
 */
","/**
 * Ensures that the format is either user-defined or implementation defined.
 *
 * <p>If a format has a different internal representation than the public representation,
 * passing in the public representation here will fail.</p>
 *
 * <p>For example if trying to use {@link ImageFormat#JPEG}:
 * it has a different public representation than the internal representation
 * {@code HAL_PIXEL_FORMAT_BLOB}, this check will fail.</p>
 *
 * <p>Any invalid/undefined formats will raise an exception.</p>
 *
 * @param format image format
 * @return the format
 *
 * @throws IllegalArgumentException if the format was invalid
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The switch statement has been altered to include an additional case (HAL_PIXEL_FORMAT_Y16) that returns format. Thus, the change type is 3 due to control dependency change.","However, there is no Compatibility Issue introduced because the additional case (HAL_PIXEL_FORMAT_Y16) simply allows for another format to be accepted and returned directly, which would not result in a behavior change for previously supported formats or cause an exception to be thrown that wasn't before. Therefore, the CI type is 0."
490,<android.webkit.WebView: HitTestResult getHitTestResult()>,22,23,<android.webkit.WebView: HitTestResult getHitTestResult()>,<android.webkit.WebView: HitTestResult getHitTestResult()>,0,"{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, ""getHitTestResult"");
    return mProvider.getHitTestResult();
}","{
    checkThread();
    return mProvider.getHitTestResult();
}",1,"/**
 * Gets a HitTestResult based on the current cursor node. If a HTML::a
 * tag is found and the anchor has a non-JavaScript URL, the HitTestResult
 * type is set to SRC_ANCHOR_TYPE and the URL is set in the ""extra"" field.
 * If the anchor does not have a URL or if it is a JavaScript URL, the type
 * will be UNKNOWN_TYPE and the URL has to be retrieved through
 * {@link #requestFocusNodeHref} asynchronously. If a HTML::img tag is
 * found, the HitTestResult type is set to IMAGE_TYPE and the URL is set in
 * the ""extra"" field. A type of
 * SRC_IMAGE_ANCHOR_TYPE indicates an anchor with a URL that has an image as
 * a child node. If a phone number is found, the HitTestResult type is set
 * to PHONE_TYPE and the phone number is set in the ""extra"" field of
 * HitTestResult. If a map address is found, the HitTestResult type is set
 * to GEO_TYPE and the address is set in the ""extra"" field of HitTestResult.
 * If an email address is found, the HitTestResult type is set to EMAIL_TYPE
 * and the email is set in the ""extra"" field of HitTestResult. Otherwise,
 * HitTestResult type is set to UNKNOWN_TYPE.
 */
","/**
 * Gets a HitTestResult based on the current cursor node. If a HTML::a
 * tag is found and the anchor has a non-JavaScript URL, the HitTestResult
 * type is set to SRC_ANCHOR_TYPE and the URL is set in the ""extra"" field.
 * If the anchor does not have a URL or if it is a JavaScript URL, the type
 * will be UNKNOWN_TYPE and the URL has to be retrieved through
 * {@link #requestFocusNodeHref} asynchronously. If a HTML::img tag is
 * found, the HitTestResult type is set to IMAGE_TYPE and the URL is set in
 * the ""extra"" field. A type of
 * SRC_IMAGE_ANCHOR_TYPE indicates an anchor with a URL that has an image as
 * a child node. If a phone number is found, the HitTestResult type is set
 * to PHONE_TYPE and the phone number is set in the ""extra"" field of
 * HitTestResult. If a map address is found, the HitTestResult type is set
 * to GEO_TYPE and the address is set in the ""extra"" field of HitTestResult.
 * If an email address is found, the HitTestResult type is set to EMAIL_TYPE
 * and the email is set in the ""extra"" field of HitTestResult. Otherwise,
 * HitTestResult type is set to UNKNOWN_TYPE.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change between the two versions is the deletion of a logging statement. This is classified as an 'Other statement changed' because it does not affect the return statement, exception handling, control dependency, or dependent API.","Despite the logging statement being removed, this will not lead to a compatibility issue because it does not affect the behavior of the method in terms of the value returned or exceptions thrown. The API call to 'mProvider.getHitTestResult()' and the 'checkThread()' method call remain unchanged. Therefore, there's no Compatibility Issue."
493,<android.app.ContextImpl: ContextImpl createSystemContext(ActivityThread)>,22,23,<android.app.ContextImpl: ContextImpl createSystemContext(ActivityThread)>,<android.app.ContextImpl: ContextImpl createSystemContext(ActivityThread)>,0,"{
    LoadedApk packageInfo = new LoadedApk(mainThread);
    ContextImpl context = new ContextImpl(null, mainThread, packageInfo, null, null, false, null, null);
    context.mResources.updateConfiguration(context.mResourcesManager.getConfiguration(), context.mResourcesManager.getDisplayMetricsLocked(Display.DEFAULT_DISPLAY));
    return context;
}","{
    LoadedApk packageInfo = new LoadedApk(mainThread);
    ContextImpl context = new ContextImpl(null, mainThread, packageInfo, null, null, false, null, null, Display.INVALID_DISPLAY);
    context.mResources.updateConfiguration(context.mResourcesManager.getConfiguration(), context.mResourcesManager.getDisplayMetricsLocked());
    return context;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The construction of `ContextImpl` instance and the method call to `getDisplayMetricsLocked()` have changed. Specifically, `Display.INVALID_DISPLAY` is now passed as a parameter to the `ContextImpl` constructor, and the parameter `Display.DEFAULT_DISPLAY` has been removed from `getDisplayMetricsLocked()`. These code changes are classified as 4 (Other statement changed) due to the changes in method invocation and parameters, and also 5 (Dependent API changed) because the change in the constructor call and method call argument signifies a change in the dependent API.","The change in passing `Display.INVALID_DISPLAY` instead of `null` to the constructor could potentially have an effect on the behavior of the `ContextImpl` object. However, the change does not lead to different return values from the `createSystemContext` method itself, as the method is still returning a `ContextImpl` object. Moreover, there are no changes to exception handling, so the compatibility issue types 1 and 2 do not apply. Therefore, pred_CI is 0 (No Compatibility Issue)."
496,"<android.app.Activity: void dispatchActivityResult(String,int,int,Intent)>",22,23,"<android.app.Activity: void dispatchActivityResult(String,int,int,Intent)>","<android.app.Activity: void dispatchActivityResult(String,int,int,Intent)>",0,"{
    if (false)
        Log.v(TAG, ""Dispatching result: who="" + who + "", reqCode="" + requestCode + "", resCode="" + resultCode + "", data="" + data);
    mFragments.noteStateNotSaved();
    if (who == null) {
        onActivityResult(requestCode, resultCode, data);
    } else {
        Fragment frag = mFragments.findFragmentByWho(who);
        if (frag != null) {
            frag.onActivityResult(requestCode, resultCode, data);
        }
    }
}","{
    if (false)
        Log.v(TAG, ""Dispatching result: who="" + who + "", reqCode="" + requestCode + "", resCode="" + resultCode + "", data="" + data);
    mFragments.noteStateNotSaved();
    if (who == null) {
        onActivityResult(requestCode, resultCode, data);
    } else if (who.startsWith(REQUEST_PERMISSIONS_WHO_PREFIX)) {
        who = who.substring(REQUEST_PERMISSIONS_WHO_PREFIX.length());
        if (TextUtils.isEmpty(who)) {
            dispatchRequestPermissionsResult(requestCode, data);
        } else {
            Fragment frag = mFragments.findFragmentByWho(who);
            if (frag != null) {
                dispatchRequestPermissionsResultToFragment(requestCode, data, frag);
            }
        }
    } else if (who.startsWith(""@android:view:"")) {
        ArrayList<ViewRootImpl> views = WindowManagerGlobal.getInstance().getRootViews(getActivityToken());
        for (ViewRootImpl viewRoot : views) {
            if (viewRoot.getView() != null && viewRoot.getView().dispatchActivityResult(who, requestCode, resultCode, data)) {
                return;
            }
        }
    } else {
        Fragment frag = mFragments.findFragmentByWho(who);
        if (frag != null) {
            frag.onActivityResult(requestCode, resultCode, data);
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"Control dependency has changed due to the addition of new conditional branches which check the prefix of the 'who' parameter and call different methods based on the result. Additionally, other statements have been added within these new branches to support the added functionality, so the code change type is 3,4.","The change in control flow can lead to a different method being called (e.g., dispatchRequestPermissionsResult or dispatchRequestPermissionsResultToFragment), and may also result in an early return from the method when a view root processes the activity result, leading to a different return value or behavior. Therefore, CI type is 1."
499,<android.app.Activity: LoaderManager getLoaderManager()>,22,23,<android.app.Activity: LoaderManager getLoaderManager()>,<android.app.Activity: LoaderManager getLoaderManager()>,0,"{
    if (mLoaderManager != null) {
        return mLoaderManager;
    }
    mCheckedForLoaderManager = true;
    mLoaderManager = getLoaderManager(""(root)"", mLoadersStarted, true);
    return mLoaderManager;
}","{
    return mFragments.getLoaderManager();
}",1,"/**
 * Return the LoaderManager for this activity, creating it if needed.
 */
","/**
 * Return the LoaderManager for this activity, creating it if needed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method implementation has completely changed from a conditional implementation with a potential new loader manager creation to a single line return returning the loader manager from a different source (`mFragments.getLoaderManager()`), which indicates a dependent API change, and thus the code change type is 1,5.","The late version of the API does not create and/or check for a loader manager directly, but instead retrieves it from the fragments. This change may lead to different return values depending on the internal state and implementation of `mFragments.getLoaderManager()`, and the CI type is 1."
500,"<android.content.pm.LauncherApps: List<LauncherActivityInfo> getActivityList(String,UserHandle)>",22,23,"<android.content.pm.LauncherApps: List<LauncherActivityInfo> getActivityList(String,UserHandle)>","<android.content.pm.LauncherApps: List<LauncherActivityInfo> getActivityList(String,UserHandle)>",0,"{
    List<ResolveInfo> activities = null;
    try {
        activities = mService.getLauncherActivities(packageName, user);
    } catch (RemoteException re) {
    }
    if (activities == null) {
        return Collections.EMPTY_LIST;
    }
    ArrayList<LauncherActivityInfo> lais = new ArrayList<LauncherActivityInfo>();
    final int count = activities.size();
    for (int i = 0; i < count; i++) {
        ResolveInfo ri = activities.get(i);
        long firstInstallTime = 0;
        try {
            firstInstallTime = mPm.getPackageInfo(ri.activityInfo.packageName, PackageManager.GET_UNINSTALLED_PACKAGES).firstInstallTime;
        } catch (NameNotFoundException nnfe) {
        // Sorry, can't find package
        }
        LauncherActivityInfo lai = new LauncherActivityInfo(mContext, ri, user, firstInstallTime);
        if (DEBUG) {
            Log.v(TAG, ""Returning activity for profile "" + user + "" : "" + lai.getComponentName());
        }
        lais.add(lai);
    }
    return lais;
}","{
    List<ResolveInfo> activities = null;
    try {
        activities = mService.getLauncherActivities(packageName, user);
    } catch (RemoteException re) {
        throw new RuntimeException(""Failed to call LauncherAppsService"");
    }
    if (activities == null) {
        return Collections.EMPTY_LIST;
    }
    ArrayList<LauncherActivityInfo> lais = new ArrayList<LauncherActivityInfo>();
    final int count = activities.size();
    for (int i = 0; i < count; i++) {
        ResolveInfo ri = activities.get(i);
        long firstInstallTime = 0;
        try {
            firstInstallTime = mPm.getPackageInfo(ri.activityInfo.packageName, PackageManager.GET_UNINSTALLED_PACKAGES).firstInstallTime;
        } catch (NameNotFoundException nnfe) {
        // Sorry, can't find package
        }
        LauncherActivityInfo lai = new LauncherActivityInfo(mContext, ri, user, firstInstallTime);
        if (DEBUG) {
            Log.v(TAG, ""Returning activity for profile "" + user + "" : "" + lai.getComponentName());
        }
        lais.add(lai);
    }
    return lais;
}",1,"/**
 * Retrieves a list of launchable activities that match {@link Intent#ACTION_MAIN} and
 * {@link Intent#CATEGORY_LAUNCHER}, for a specified user.
 *
 * @param packageName The specific package to query. If null, it checks all installed packages
 * in the profile.
 * @param user The UserHandle of the profile.
 * @return List of launchable activities. Can be an empty list but will not be null.
 */
","/**
 * Retrieves a list of launchable activities that match {@link Intent#ACTION_MAIN} and
 * {@link Intent#CATEGORY_LAUNCHER}, for a specified user.
 *
 * @param packageName The specific package to query. If null, it checks all installed packages
 * in the profile.
 * @param user The UserHandle of the profile.
 * @return List of launchable activities. Can be an empty list but will not be null.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The change in the code is within the RemoteException catch block. In the early version, it is empty and there’s no action taken when a RemoteException occurs. In the late version, it throws a new RuntimeException if a RemoteException is caught. So the change type is 2.","By introducing a throw statement for a new RuntimeException inside the catch block for RemoteException, this change may lead to a situation where an exception is thrown to the caller of this method which previously would not have been thrown. Therefore, this constitutes a potential exception handling behavior change, and the CI type is 2."
501,<android.print.PrintDocumentInfo: int hashCode()>,22,23,<android.print.PrintDocumentInfo: int hashCode()>,<android.print.PrintDocumentInfo: int hashCode()>,0,"{
    final int prime = 31;
    int result = 1;
    result = prime * result + ((mName != null) ? mName.hashCode() : 0);
    result = prime * result + mContentType;
    result = prime * result + mPageCount;
    result = prime * result + (int) mDataSize;
    result = prime * result + (int) mDataSize >> 32;
    return result;
}","{
    final int prime = 31;
    int result = 1;
    result = prime * result + ((mName != null) ? mName.hashCode() : 0);
    result = prime * result + mContentType;
    result = prime * result + mPageCount;
    result = prime * result + (int) mDataSize;
    result = prime * result + (int) (mDataSize >> 32);
    return result;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The only change in code is a minor change in parentheses in the expression calculating the result. This does not affect the result since it simply clarifies the order of operations but does not change it, so the code change type is 4.","There is no Compatibility Issue. The change in parentheses does not alter the behavior of the hashCode calculation; therefore, it does not result in a different return value or exception handling, so the CI type is 0."
502,"<android.app.admin.DevicePolicyManager: void setPasswordExpirationTimeout(ComponentName,long)>",22,23,"<android.app.admin.DevicePolicyManager: void setPasswordExpirationTimeout(ComponentName,long)>","<android.app.admin.DevicePolicyManager: void setPasswordExpirationTimeout(ComponentName,long)>",0,"{
    if (mService != null) {
        try {
            mService.setPasswordExpirationTimeout(admin, timeout, UserHandle.myUserId());
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    if (mService != null) {
        try {
            mService.setPasswordExpirationTimeout(admin, timeout);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}",1,"/**
 * Called by a device admin to set the password expiration timeout. Calling this method
 * will restart the countdown for password expiration for the given admin, as will changing
 * the device password (for all admins).
 *
 * <p>The provided timeout is the time delta in ms and will be added to the current time.
 * For example, to have the password expire 5 days from now, timeout would be
 * 5 * 86400 * 1000 = 432000000 ms for timeout.
 *
 * <p>To disable password expiration, a value of 0 may be used for timeout.
 *
 * <p>The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_EXPIRE_PASSWORD} to be able to call this
 * method; if it has not, a security exception will be thrown.
 *
 * <p> Note that setting the password will automatically reset the expiration time for all
 * active admins. Active admins do not need to explicitly call this method in that case.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param timeout The limit (in ms) that a password can remain in effect. A value of 0
 * means there is no restriction (unlimited).
 */
","/**
 * Called by a device admin to set the password expiration timeout. Calling this method
 * will restart the countdown for password expiration for the given admin, as will changing
 * the device password (for all admins).
 *
 * <p>The provided timeout is the time delta in ms and will be added to the current time.
 * For example, to have the password expire 5 days from now, timeout would be
 * 5 * 86400 * 1000 = 432000000 ms for timeout.
 *
 * <p>To disable password expiration, a value of 0 may be used for timeout.
 *
 * <p>The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_EXPIRE_PASSWORD} to be able to call this
 * method; if it has not, a security exception will be thrown.
 *
 * <p> Note that setting the password will automatically reset the expiration time for all
 * active admins. Active admins do not need to explicitly call this method in that case.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param timeout The limit (in ms) that a password can remain in effect. A value of 0
 * means there is no restriction (unlimited).
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,"The method signature of the dependent API mService.setPasswordExpirationTimeout() has changed, it no longer requires the third parameter 'UserHandle.myUserId()', which suggests a potential change in behavior, so the code change type is 5.","The dependent API call now passes different arguments, possibly altering the behavior of the setPasswordExpirationTimeout method when it's called. Because the UserHandle.myUserId() parameter is no longer passed, it may affect the operation for a different user than before, or the implementation might now apply to all users by default. Thus, the CI type is 1."
504,<android.widget.FrameLayout: int getPaddingRightWithForeground()>,22,23,<android.widget.FrameLayout: int getPaddingRightWithForeground()>,<android.widget.FrameLayout: int getPaddingRightWithForeground()>,0,"{
    return mForegroundInPadding ? Math.max(mPaddingRight, mForegroundPaddingRight) : mPaddingRight + mForegroundPaddingRight;
}","{
    return isForegroundInsidePadding() ? Math.max(mPaddingRight, mForegroundPaddingRight) : mPaddingRight + mForegroundPaddingRight;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,5",1,"The change is in the conditional check for deciding the padding value. The method call mForegroundInPadding is replaced with a new dependent API call isForegroundInsidePadding(). Therefore, this is a control dependency change as well as a dependent API change, thus the code change type is 3,5.","Since there is a new conditional check which could potentially evaluate differently from the original one, this could lead to a change in the value being returned by the getPaddingRightWithForeground() method. Therefore, the CI type is 1, as it could potentially return a different value."
505,"<android.widget.Toolbar.ExpandedActionViewMenuPresenter: boolean collapseItemActionView(MenuBuilder,MenuItemImpl)>",22,23,"<android.widget.Toolbar.ExpandedActionViewMenuPresenter: boolean collapseItemActionView(MenuBuilder,MenuItemImpl)>","<android.widget.Toolbar.ExpandedActionViewMenuPresenter: boolean collapseItemActionView(MenuBuilder,MenuItemImpl)>",0,"{
    // it needs to dismiss the soft keyboard, etc.
    if (mExpandedActionView instanceof CollapsibleActionView) {
        ((CollapsibleActionView) mExpandedActionView).onActionViewCollapsed();
    }
    removeView(mExpandedActionView);
    removeView(mCollapseButtonView);
    mExpandedActionView = null;
    setChildVisibilityForExpandedActionView(false);
    mCurrentExpandedItem = null;
    requestLayout();
    item.setActionViewExpanded(false);
    return true;
}","{
    // it needs to dismiss the soft keyboard, etc.
    if (mExpandedActionView instanceof CollapsibleActionView) {
        ((CollapsibleActionView) mExpandedActionView).onActionViewCollapsed();
    }
    removeView(mExpandedActionView);
    removeView(mCollapseButtonView);
    mExpandedActionView = null;
    addChildrenForExpandedActionView();
    mCurrentExpandedItem = null;
    requestLayout();
    item.setActionViewExpanded(false);
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The only change between the two versions is that the method `setChildVisibilityForExpandedActionView(false);` is removed and replaced by `addChildrenForExpandedActionView();` in the late version. No return statements or exception handling statements have been altered, and no control dependencies have changed. Hence, the code change type is 4.","Although there is a change in the method implementation, there is no Compatibility Issue because the method's behavior, in terms of what it returns or the exceptions it might throw, has not been altered. It always returns true, and no new exceptions are introduced or handled. Therefore, the CI type is 0."
506,<android.content.ContentResolver: ContentProviderClient acquireUnstableContentProviderClient(Uri)>,22,23,<android.content.ContentResolver: ContentProviderClient acquireUnstableContentProviderClient(Uri)>,<android.content.ContentResolver: ContentProviderClient acquireUnstableContentProviderClient(Uri)>,0,"{
    IContentProvider provider = acquireUnstableProvider(uri);
    if (provider != null) {
        return new ContentProviderClient(this, provider, false);
    }
    return null;
}","{
    Preconditions.checkNotNull(uri, ""uri"");
    IContentProvider provider = acquireUnstableProvider(uri);
    if (provider != null) {
        return new ContentProviderClient(this, provider, false);
    }
    return null;
}",1,"/**
 * Like {@link #acquireContentProviderClient(Uri)}, but for use when you do
 * not trust the stability of the target content provider.  This turns off
 * the mechanism in the platform clean up processes that are dependent on
 * a content provider if that content provider's process goes away.  Normally
 * you can safely assume that once you have acquired a provider, you can freely
 * use it as needed and it won't disappear, even if your process is in the
 * background.  If using this method, you need to take care to deal with any
 * failures when communicating with the provider, and be sure to close it
 * so that it can be re-opened later.  In particular, catching a
 * {@link android.os.DeadObjectException} from the calls there will let you
 * know that the content provider has gone away; at that point the current
 * ContentProviderClient object is invalid, and you should release it.  You
 * can acquire a new one if you would like to try to restart the provider
 * and perform new operations on it.
 */
","/**
 * Like {@link #acquireContentProviderClient(Uri)}, but for use when you do
 * not trust the stability of the target content provider.  This turns off
 * the mechanism in the platform clean up processes that are dependent on
 * a content provider if that content provider's process goes away.  Normally
 * you can safely assume that once you have acquired a provider, you can freely
 * use it as needed and it won't disappear, even if your process is in the
 * background.  If using this method, you need to take care to deal with any
 * failures when communicating with the provider, and be sure to close it
 * so that it can be re-opened later.  In particular, catching a
 * {@link android.os.DeadObjectException} from the calls there will let you
 * know that the content provider has gone away; at that point the current
 * ContentProviderClient object is invalid, and you should release it.  You
 * can acquire a new one if you would like to try to restart the provider
 * and perform new operations on it.
 */
",-1,,[@Nullable],-1,-1,-1,-1,-1,-1,4,0,"The code change includes adding a precondition check for the 'uri' parameter using Preconditions.checkNotNull, which does not affect the return value or the exception handling of the method, therefore the change type is 4 (Other statement changed).","The insertion of the precondition check for 'uri' will lead to an early IllegalArgumentException if 'uri' is null before any other operations are executed. However, because a null 'uri' would have resulted in a NullPointerException from 'acquireUnstableProvider(uri)' in the early version and an IllegalArgumentException in the late version, both scenarios lead to an exception if 'uri' is null. Thus this does not constitute a change in the potential behavior of the method in terms of what clients would need to handle, and therefore there is no Compatibility Issue."
507,<android.content.ContentResolver: InputStream openInputStream(Uri)>,22,23,<android.content.ContentResolver: InputStream openInputStream(Uri)>,<android.content.ContentResolver: InputStream openInputStream(Uri)>,0,"{
    String scheme = uri.getScheme();
    if (SCHEME_ANDROID_RESOURCE.equals(scheme)) {
        // Note: left here to avoid breaking compatibility.  May be removed
        // with sufficient testing.
        OpenResourceIdResult r = getResourceId(uri);
        try {
            InputStream stream = r.r.openRawResource(r.id);
            return stream;
        } catch (Resources.NotFoundException ex) {
            throw new FileNotFoundException(""Resource does not exist: "" + uri);
        }
    } else if (SCHEME_FILE.equals(scheme)) {
        // with sufficient testing.
        return new FileInputStream(uri.getPath());
    } else {
        AssetFileDescriptor fd = openAssetFileDescriptor(uri, ""r"", null);
        try {
            return fd != null ? fd.createInputStream() : null;
        } catch (IOException e) {
            throw new FileNotFoundException(""Unable to create stream"");
        }
    }
}","{
    Preconditions.checkNotNull(uri, ""uri"");
    String scheme = uri.getScheme();
    if (SCHEME_ANDROID_RESOURCE.equals(scheme)) {
        // Note: left here to avoid breaking compatibility.  May be removed
        // with sufficient testing.
        OpenResourceIdResult r = getResourceId(uri);
        try {
            InputStream stream = r.r.openRawResource(r.id);
            return stream;
        } catch (Resources.NotFoundException ex) {
            throw new FileNotFoundException(""Resource does not exist: "" + uri);
        }
    } else if (SCHEME_FILE.equals(scheme)) {
        // with sufficient testing.
        return new FileInputStream(uri.getPath());
    } else {
        AssetFileDescriptor fd = openAssetFileDescriptor(uri, ""r"", null);
        try {
            return fd != null ? fd.createInputStream() : null;
        } catch (IOException e) {
            throw new FileNotFoundException(""Unable to create stream"");
        }
    }
}",1,"/**
 * Open a stream on to the content associated with a content URI.  If there
 * is no data associated with the URI, FileNotFoundException is thrown.
 *
 * <h5>Accepts the following URI schemes:</h5>
 * <ul>
 * <li>content ({@link #SCHEME_CONTENT})</li>
 * <li>android.resource ({@link #SCHEME_ANDROID_RESOURCE})</li>
 * <li>file ({@link #SCHEME_FILE})</li>
 * </ul>
 *
 * <p>See {@link #openAssetFileDescriptor(Uri, String)} for more information
 * on these schemes.
 *
 * @param uri The desired URI.
 * @return InputStream
 * @throws FileNotFoundException if the provided URI could not be opened.
 * @see #openAssetFileDescriptor(Uri, String)
 */
","/**
 * Open a stream on to the content associated with a content URI.  If there
 * is no data associated with the URI, FileNotFoundException is thrown.
 *
 * <h5>Accepts the following URI schemes:</h5>
 * <ul>
 * <li>content ({@link #SCHEME_CONTENT})</li>
 * <li>android.resource ({@link #SCHEME_ANDROID_RESOURCE})</li>
 * <li>file ({@link #SCHEME_FILE})</li>
 * </ul>
 *
 * <p>See {@link #openAssetFileDescriptor(Uri, String)} for more information
 * on these schemes.
 *
 * @param uri The desired URI.
 * @return InputStream
 * @throws FileNotFoundException if the provided URI could not be opened.
 * @see #openAssetFileDescriptor(Uri, String)
 */
",-1,,[@Nullable],-1,-1,-1,-1,-1,-1,4,0,"The only change between the early and late implementations is the addition of a call to Preconditions.checkNotNull(uri, ""uri"") at the start of the method. This is a type of precondition check to ensure method contracts are respected; it is not a return statement change, exception handling statement change, control dependency change, or a dependent API change, and therefore, it is classified as a change type 4.","The added precondition check will cause an exception to be thrown if the 'uri' parameter is null before any other code is executed, which will not lead to a change in return value for non-null 'uri' inputs and adheres to the previous method contract for null 'uri' inputs (assuming that previously passing a null 'uri' would have resulted in some sort of error anyway). Given this, there are no Compatibility Issues introduced; therefore, the pred_CI is 0."
508,<android.print.PrintAttributes: String colorModeToString(int)>,22,23,<android.print.PrintAttributes: String colorModeToString(int)>,<android.print.PrintAttributes: String colorModeToString(int)>,0,"{
    switch(colorMode) {
        case COLOR_MODE_MONOCHROME:
            {
                return ""COLOR_MODE_MONOCHROME"";
            }
        case COLOR_MODE_COLOR:
            {
                return ""COLOR_MODE_COLOR"";
            }
        default:
            return ""COLOR_MODE_UNKNOWN"";
    }
}","{
    switch(colorMode) {
        case COLOR_MODE_MONOCHROME:
            {
                return ""COLOR_MODE_MONOCHROME"";
            }
        case COLOR_MODE_COLOR:
            {
                return ""COLOR_MODE_COLOR"";
            }
        default:
            {
                return ""COLOR_MODE_UNKNOWN"";
            }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,0,0,"There is no code change between the two versions, only the formatting is slightly different with the addition of curly braces in the default case, which does not alter the behavior.","Since there are no actual code or logic changes, there will be no compatibility issues between these versions."
509,<android.app.Activity: NonConfigurationInstances retainNonConfigurationInstances()>,22,23,<android.app.Activity: NonConfigurationInstances retainNonConfigurationInstances()>,<android.app.Activity: NonConfigurationInstances retainNonConfigurationInstances()>,0,"{
    Object activity = onRetainNonConfigurationInstance();
    HashMap<String, Object> children = onRetainNonConfigurationChildInstances();
    ArrayList<Fragment> fragments = mFragments.retainNonConfig();
    boolean retainLoaders = false;
    if (mAllLoaderManagers != null) {
        // prune out any loader managers that were already stopped and so
        // have nothing useful to retain.
        final int N = mAllLoaderManagers.size();
        LoaderManagerImpl[] loaders = new LoaderManagerImpl[N];
        for (int i = N - 1; i >= 0; i--) {
            loaders[i] = mAllLoaderManagers.valueAt(i);
        }
        for (int i = 0; i < N; i++) {
            LoaderManagerImpl lm = loaders[i];
            if (lm.mRetaining) {
                retainLoaders = true;
            } else {
                lm.doDestroy();
                mAllLoaderManagers.remove(lm.mWho);
            }
        }
    }
    if (activity == null && children == null && fragments == null && !retainLoaders && mVoiceInteractor == null) {
        return null;
    }
    NonConfigurationInstances nci = new NonConfigurationInstances();
    nci.activity = activity;
    nci.children = children;
    nci.fragments = fragments;
    nci.loaders = mAllLoaderManagers;
    nci.voiceInteractor = mVoiceInteractor;
    return nci;
}","{
    Object activity = onRetainNonConfigurationInstance();
    HashMap<String, Object> children = onRetainNonConfigurationChildInstances();
    List<Fragment> fragments = mFragments.retainNonConfig();
    ArrayMap<String, LoaderManager> loaders = mFragments.retainLoaderNonConfig();
    if (activity == null && children == null && fragments == null && loaders == null && mVoiceInteractor == null) {
        return null;
    }
    NonConfigurationInstances nci = new NonConfigurationInstances();
    nci.activity = activity;
    nci.children = children;
    nci.fragments = fragments;
    nci.loaders = loaders;
    if (mVoiceInteractor != null) {
        mVoiceInteractor.retainInstance();
        nci.voiceInteractor = mVoiceInteractor;
    }
    return nci;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",1,The implementation includes several changes:,- A new dependent API 'retainLoaderNonConfig()' is used.
510,"<android.content.ContentResolver: void takePersistableUriPermission(Uri,int)>",22,23,"<android.content.ContentResolver: void takePersistableUriPermission(Uri,int)>","<android.content.ContentResolver: void takePersistableUriPermission(Uri,int)>",0,"{
    try {
        ActivityManagerNative.getDefault().takePersistableUriPermission(ContentProvider.getUriWithoutUserId(uri), modeFlags, resolveUserId(uri));
    } catch (RemoteException e) {
    }
}","{
    Preconditions.checkNotNull(uri, ""uri"");
    try {
        ActivityManagerNative.getDefault().takePersistableUriPermission(ContentProvider.getUriWithoutUserId(uri), modeFlags, resolveUserId(uri));
    } catch (RemoteException e) {
    }
}",1,"/**
 * Take a persistable URI permission grant that has been offered. Once
 * taken, the permission grant will be remembered across device reboots.
 * Only URI permissions granted with
 * {@link Intent#FLAG_GRANT_PERSISTABLE_URI_PERMISSION} can be persisted. If
 * the grant has already been persisted, taking it again will touch
 * {@link UriPermission#getPersistedTime()}.
 *
 * @see #getPersistedUriPermissions()
 */
","/**
 * Take a persistable URI permission grant that has been offered. Once
 * taken, the permission grant will be remembered across device reboots.
 * Only URI permissions granted with
 * {@link Intent#FLAG_GRANT_PERSISTABLE_URI_PERMISSION} can be persisted. If
 * the grant has already been persisted, taking it again will touch
 * {@link UriPermission#getPersistedTime()}.
 *
 * @see #getPersistedUriPermissions()
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"A new statement ""Preconditions.checkNotNull(uri, ""uri"");"" was added before the try block in the late version. This is neither a return statement change, an exception handling change, nor a control dependency change; it checks the precondition of a parameter. Thus, the code change type is 4.","This change does not lead to different return values since the method is void. It also does not affect the exception handling related to the functionality of the method, as it introduces a check that throws a NullPointerException if the 'uri' parameter is null, which will prevent further execution and the RemoteException catch block remains unchanged. This is just enforcing a parameter precondition and should not affect existing callers who are passing a non-null 'uri', hence no compatibility issue is expected. The Compatibility Issue type is 0."
511,<android.os.ParcelFileDescriptor: ParcelFileDescriptor[] createReliableSocketPair()>,22,23,<android.os.ParcelFileDescriptor: ParcelFileDescriptor[] createReliableSocketPair()>,<android.os.ParcelFileDescriptor: ParcelFileDescriptor[] createReliableSocketPair()>,0,"{
    try {
        final FileDescriptor[] comm = createCommSocketPair();
        final FileDescriptor fd0 = new FileDescriptor();
        final FileDescriptor fd1 = new FileDescriptor();
        Os.socketpair(AF_UNIX, SOCK_STREAM, 0, fd0, fd1);
        return new ParcelFileDescriptor[] { new ParcelFileDescriptor(fd0, comm[0]), new ParcelFileDescriptor(fd1, comm[1]) };
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}","{
    return createReliableSocketPair(SOCK_STREAM);
}",1,"/**
 * Create two ParcelFileDescriptors structured as a pair of sockets
 * connected to each other. The two sockets are indistinguishable.
 * <p>
 * Both ends have the ability to deliver an error message through
 * {@link #closeWithError(String)} which can be detected by the other end
 * calling {@link #checkError()}, usually after detecting an EOF.
 * This can also be used to detect remote crashes.
 */
","/**
 * Create two ParcelFileDescriptors structured as a pair of sockets
 * connected to each other. The two sockets are indistinguishable.
 * <p>
 * Both ends have the ability to deliver an error message through
 * {@link #closeWithError(String)} which can be detected by the other end
 * calling {@link #checkError()}, usually after detecting an EOF.
 * This can also be used to detect remote crashes.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The late version of the API is using a completely different method createReliableSocketPair(SOCK_STREAM) which is replacing the entire block of the early version implementation. It indicates a Dependent API change (5). Moreover, since the full implementation has been modified, the returned ParcelFileDescriptor[] could potentially be constructed differently (1).","Because the implementation now calls a different method to create the socket pair, it's possible that the created ParcelFileDescriptor[] objects will have different internal states or behaviors, resulting in a potential different return value or type. The CI type is therefore 1."
513,<android.app.Fragment: Activity getActivity()>,22,23,<android.app.Fragment: Activity getActivity()>,<android.app.Fragment: Activity getActivity()>,0,"{
    return mActivity;
}","{
    return mHost == null ? null : mHost.getActivity();
}",1,"/**
 * Return the Activity this fragment is currently associated with.
 */
","/**
 * Return the Activity this fragment is currently associated with.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,The return statement has changed from directly returning mActivity to conditionally returning the result of mHost.getActivity() if mHost is not null. This implies that the previous version relied on mActivity while the new version adds a conditional check.,"Since the return value now depends on whether mHost is null or not, which is a different behavior from the unconditioned return value of mActivity in the previous version, there is a potential for returning a different value. Therefore, the CI type is 1."
515,"<android.content.res.TypedArray: float getFloat(int,float)>",22,23,"<android.content.res.TypedArray: float getFloat(int,float)>","<android.content.res.TypedArray: float getFloat(int,float)>",0,"{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_FLOAT) {
        return Float.intBitsToFloat(data[index + AssetManager.STYLE_DATA]);
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA];
    }
    TypedValue v = mValue;
    if (getValueAt(index, v)) {
        Log.w(Resources.TAG, ""Converting to float: "" + v);
        CharSequence str = v.coerceToString();
        if (str != null) {
            return Float.parseFloat(str.toString());
        }
    }
    Log.w(Resources.TAG, ""getFloat of bad type: 0x"" + Integer.toHexString(type));
    return defValue;
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_FLOAT) {
        return Float.intBitsToFloat(data[index + AssetManager.STYLE_DATA]);
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA];
    }
    final TypedValue v = mValue;
    if (getValueAt(index, v)) {
        final CharSequence str = v.coerceToString();
        if (str != null) {
            StrictMode.noteResourceMismatch(v);
            return Float.parseFloat(str.toString());
        }
    }
    // We already checked for TYPE_NULL. This should never happen.
    throw new RuntimeException(""getFloat of bad type: 0x"" + Integer.toHexString(type));
}",1,"/**
 * Retrieve the float value for the attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return Attribute float value, or defValue if not defined..
 */
","/**
 * Retrieve the float value for the attribute at <var>index</var>.
 * <p>
 * If the attribute is not a float or an integer, this method will attempt
 * to coerce it to a float using {@link Float#parseFloat(String)}.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return Attribute float value, or defValue if the attribute was
 * not defined or could not be coerced to a float.
 * @throws RuntimeException if the TypedArray has already been recycled.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2",The code change includes:,
516,"<android.app.Fragment: void startActivityForResult(Intent,int,Bundle)>",22,23,"<android.app.Fragment: void startActivityForResult(Intent,int,Bundle)>","<android.app.Fragment: void startActivityForResult(Intent,int,Bundle)>",0,"{
    if (mActivity == null) {
        throw new IllegalStateException(""Fragment "" + this + "" not attached to Activity"");
    }
    if (options != null) {
        mActivity.startActivityFromFragment(this, intent, requestCode, options);
    } else {
        // Note we want to go through this call for compatibility with
        // applications that may have overridden the method.
        mActivity.startActivityFromFragment(this, intent, requestCode, options);
    }
}","{
    if (mHost == null) {
        throw new IllegalStateException(""Fragment "" + this + "" not attached to Activity"");
    }
    mHost.onStartActivityFromFragment(this, intent, requestCode, options);
}",1,"/**
 * Call {@link Activity#startActivityForResult(Intent, int, Bundle)} from the fragment's
 * containing Activity.
 */
","/**
 * Call {@link Activity#startActivityForResult(Intent, int, Bundle)} from the fragment's
 * containing Activity.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,5","1,2",The change involves a couple of aspects:,3) The control dependency under 'if (options != null)' has been deleted as the if-else construct has been removed.
518,<android.widget.ZoomButtonsController: void setVisible(boolean)>,22,23,<android.widget.ZoomButtonsController: void setVisible(boolean)>,<android.widget.ZoomButtonsController: void setVisible(boolean)>,0,"{
    if (visible) {
        if (mOwnerView.getWindowToken() == null) {
            /*
                 * We need a window token to show ourselves, maybe the owner's
                 * window hasn't been created yet but it will have been by the
                 * time the looper is idle, so post the setVisible(true) call.
                 */
            if (!mHandler.hasMessages(MSG_POST_SET_VISIBLE)) {
                mHandler.sendEmptyMessage(MSG_POST_SET_VISIBLE);
            }
            return;
        }
        dismissControlsDelayed(ZOOM_CONTROLS_TIMEOUT);
    }
    if (mIsVisible == visible) {
        return;
    }
    mIsVisible = visible;
    if (visible) {
        if (mContainerLayoutParams.token == null) {
            mContainerLayoutParams.token = mOwnerView.getWindowToken();
        }
        mWindowManager.addView(mContainer, mContainerLayoutParams);
        if (mPostedVisibleInitializer == null) {
            mPostedVisibleInitializer = new Runnable() {

                public void run() {
                    refreshPositioningVariables();
                    if (mCallback != null) {
                        mCallback.onVisibilityChanged(true);
                    }
                }
            };
        }
        mHandler.post(mPostedVisibleInitializer);
        // Handle configuration changes when visible
        mContext.registerReceiver(mConfigurationChangedReceiver, mConfigurationChangedFilter);
        // Steal touches events from the owner
        mOwnerView.setOnTouchListener(this);
        mReleaseTouchListenerOnUp = false;
    } else {
        // Don't want to steal any more touches
        if (mTouchTargetView != null) {
            // We are still stealing the touch events for this touch
            // sequence, so release the touch listener later
            mReleaseTouchListenerOnUp = true;
        } else {
            mOwnerView.setOnTouchListener(null);
        }
        // No longer care about configuration changes
        mContext.unregisterReceiver(mConfigurationChangedReceiver);
        mWindowManager.removeView(mContainer);
        mHandler.removeCallbacks(mPostedVisibleInitializer);
        if (mCallback != null) {
            mCallback.onVisibilityChanged(false);
        }
    }
}","{
    if (visible) {
        if (mOwnerView.getWindowToken() == null) {
            /*
                 * We need a window token to show ourselves, maybe the owner's
                 * window hasn't been created yet but it will have been by the
                 * time the looper is idle, so post the setVisible(true) call.
                 */
            if (!mHandler.hasMessages(MSG_POST_SET_VISIBLE)) {
                mHandler.sendEmptyMessage(MSG_POST_SET_VISIBLE);
            }
            return;
        }
        dismissControlsDelayed(ZOOM_CONTROLS_TIMEOUT);
    }
    if (mIsVisible == visible) {
        return;
    }
    mIsVisible = visible;
    if (visible) {
        if (mContainerLayoutParams.token == null) {
            mContainerLayoutParams.token = mOwnerView.getWindowToken();
        }
        mWindowManager.addView(mContainer, mContainerLayoutParams);
        if (mPostedVisibleInitializer == null) {
            mPostedVisibleInitializer = new Runnable() {

                public void run() {
                    refreshPositioningVariables();
                    if (mCallback != null) {
                        mCallback.onVisibilityChanged(true);
                    }
                }
            };
        }
        mHandler.post(mPostedVisibleInitializer);
        // Handle configuration changes when visible
        mContext.registerReceiver(mConfigurationChangedReceiver, mConfigurationChangedFilter);
        // Steal touches events from the owner
        mOwnerView.setOnTouchListener(this);
        mReleaseTouchListenerOnUp = false;
    } else {
        // Don't want to steal any more touches
        if (mTouchTargetView != null) {
            // We are still stealing the touch events for this touch
            // sequence, so release the touch listener later
            mReleaseTouchListenerOnUp = true;
        } else {
            mOwnerView.setOnTouchListener(null);
        }
        // No longer care about configuration changes
        mContext.unregisterReceiver(mConfigurationChangedReceiver);
        mWindowManager.removeViewImmediate(mContainer);
        mHandler.removeCallbacks(mPostedVisibleInitializer);
        if (mCallback != null) {
            mCallback.onVisibilityChanged(false);
        }
    }
}",1,"/**
 * Sets whether the zoom controls should be visible to the user.
 *
 * @param visible Whether the zoom controls should be visible to the user.
 */
","/**
 * Sets whether the zoom controls should be visible to the user.
 *
 * @param visible Whether the zoom controls should be visible to the user.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change is only in the method called from `mWindowManager.removeView(mContainer)` to `mWindowManager.removeViewImmediate(mContainer)`. This represents a change in how the view is removed, ""immediate"" suggesting that it could be done synchronously, without waiting for the message queue to process the removal request, but since the exact behavior depends on the method specification which isn't provided here, it must be classified as 'Other statement changed'.","Such an internal change in how the view is removed from the window manager does not directly lead to a difference in the value returned by the method or the exceptions it throws since the method in question (`setVisible`) returns void and does not throw any checked exceptions. The change does not alter the control flow in a way that leads to a change in the method output or exception handling behavior. Therefore, there is no compatibility issue expected from this change."
522,<android.text.SpannableStringBuilder: int getSpanFlags(Object)>,22,23,<android.text.SpannableStringBuilder: int getSpanFlags(Object)>,<android.text.SpannableStringBuilder: int getSpanFlags(Object)>,0,"{
    int count = mSpanCount;
    Object[] spans = mSpans;
    for (int i = count - 1; i >= 0; i--) {
        if (spans[i] == what) {
            return mSpanFlags[i];
        }
    }
    return 0;
}","{
    if (mIndexOfSpan == null)
        return 0;
    Integer i = mIndexOfSpan.get(what);
    return i == null ? 0 : mSpanFlags[i];
}",1,"/**
 * Return the flags of the end of the specified
 * markup object, or 0 if it is not attached to this buffer.
 */
","/**
 * Return the flags of the end of the specified
 * markup object, or 0 if it is not attached to this buffer.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,5",1,"The loop from the early version has been replaced with a check for mIndexOfSpan being null and the usage of a Map get operation in the late version. This introduces a new way of finding the index and significantly changes the control flow, so the code change type includes 1, 3, and 5.","The changed method of obtaining span flags means that there is a potential for different return values from this method, even if the input is the same. As such, this represents a possible change in behavior, leading to a compatibility issue of type 1."
523,<android.hardware.camera2.impl.CameraCaptureSessionImpl: void abortCaptures()>,22,23,<android.hardware.camera2.impl.CameraCaptureSessionImpl: void abortCaptures()>,<android.hardware.camera2.impl.CameraCaptureSessionImpl: void abortCaptures()>,0,"{
    checkNotClosed();
    if (VERBOSE) {
        Log.v(TAG, mIdString + ""abortCaptures"");
    }
    if (mAborting) {
        Log.w(TAG, mIdString + ""abortCaptures - Session is already aborting; doing nothing"");
        return;
    }
    mAborting = true;
    mAbortDrainer.taskStarted();
    mDeviceImpl.flush();
// The next BUSY -> IDLE set of transitions will mark the end of the abort.
}","{
    checkNotClosed();
    if (DEBUG) {
        Log.v(TAG, mIdString + ""abortCaptures"");
    }
    if (mAborting) {
        Log.w(TAG, mIdString + ""abortCaptures - Session is already aborting; doing nothing"");
        return;
    }
    mAborting = true;
    mAbortDrainer.taskStarted();
    mDeviceImpl.flush();
// The next BUSY -> IDLE set of transitions will mark the end of the abort.
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The change is the conditional check for the log verbosity level from `VERBOSE` to `DEBUG`. This is a change to a debugging statement, so the code change type is 4.","Debugging and logging do not affect the behavior of the API from the perspective of the caller. The functionality of the `abortCaptures` method has not been modified. Therefore, there is no Compatibility Issue."
524,"<android.content.IntentFilter: void dump(Printer,String)>",22,23,"<android.content.IntentFilter: void dump(Printer,String)>","<android.content.IntentFilter: void dump(Printer,String)>",0,"{
    StringBuilder sb = new StringBuilder(256);
    if (mActions.size() > 0) {
        Iterator<String> it = mActions.iterator();
        while (it.hasNext()) {
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Action: \"""");
            sb.append(it.next());
            sb.append(""\"""");
            du.println(sb.toString());
        }
    }
    if (mCategories != null) {
        Iterator<String> it = mCategories.iterator();
        while (it.hasNext()) {
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Category: \"""");
            sb.append(it.next());
            sb.append(""\"""");
            du.println(sb.toString());
        }
    }
    if (mDataSchemes != null) {
        Iterator<String> it = mDataSchemes.iterator();
        while (it.hasNext()) {
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Scheme: \"""");
            sb.append(it.next());
            sb.append(""\"""");
            du.println(sb.toString());
        }
    }
    if (mDataSchemeSpecificParts != null) {
        Iterator<PatternMatcher> it = mDataSchemeSpecificParts.iterator();
        while (it.hasNext()) {
            PatternMatcher pe = it.next();
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Ssp: \"""");
            sb.append(pe);
            sb.append(""\"""");
            du.println(sb.toString());
        }
    }
    if (mDataAuthorities != null) {
        Iterator<AuthorityEntry> it = mDataAuthorities.iterator();
        while (it.hasNext()) {
            AuthorityEntry ae = it.next();
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Authority: \"""");
            sb.append(ae.mHost);
            sb.append(""\"": "");
            sb.append(ae.mPort);
            if (ae.mWild)
                sb.append("" WILD"");
            du.println(sb.toString());
        }
    }
    if (mDataPaths != null) {
        Iterator<PatternMatcher> it = mDataPaths.iterator();
        while (it.hasNext()) {
            PatternMatcher pe = it.next();
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Path: \"""");
            sb.append(pe);
            sb.append(""\"""");
            du.println(sb.toString());
        }
    }
    if (mDataTypes != null) {
        Iterator<String> it = mDataTypes.iterator();
        while (it.hasNext()) {
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Type: \"""");
            sb.append(it.next());
            sb.append(""\"""");
            du.println(sb.toString());
        }
    }
    if (mPriority != 0 || mHasPartialTypes) {
        sb.setLength(0);
        sb.append(prefix);
        sb.append(""mPriority="");
        sb.append(mPriority);
        sb.append("", mHasPartialTypes="");
        sb.append(mHasPartialTypes);
        du.println(sb.toString());
    }
}","{
    StringBuilder sb = new StringBuilder(256);
    if (mActions.size() > 0) {
        Iterator<String> it = mActions.iterator();
        while (it.hasNext()) {
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Action: \"""");
            sb.append(it.next());
            sb.append(""\"""");
            du.println(sb.toString());
        }
    }
    if (mCategories != null) {
        Iterator<String> it = mCategories.iterator();
        while (it.hasNext()) {
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Category: \"""");
            sb.append(it.next());
            sb.append(""\"""");
            du.println(sb.toString());
        }
    }
    if (mDataSchemes != null) {
        Iterator<String> it = mDataSchemes.iterator();
        while (it.hasNext()) {
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Scheme: \"""");
            sb.append(it.next());
            sb.append(""\"""");
            du.println(sb.toString());
        }
    }
    if (mDataSchemeSpecificParts != null) {
        Iterator<PatternMatcher> it = mDataSchemeSpecificParts.iterator();
        while (it.hasNext()) {
            PatternMatcher pe = it.next();
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Ssp: \"""");
            sb.append(pe);
            sb.append(""\"""");
            du.println(sb.toString());
        }
    }
    if (mDataAuthorities != null) {
        Iterator<AuthorityEntry> it = mDataAuthorities.iterator();
        while (it.hasNext()) {
            AuthorityEntry ae = it.next();
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Authority: \"""");
            sb.append(ae.mHost);
            sb.append(""\"": "");
            sb.append(ae.mPort);
            if (ae.mWild)
                sb.append("" WILD"");
            du.println(sb.toString());
        }
    }
    if (mDataPaths != null) {
        Iterator<PatternMatcher> it = mDataPaths.iterator();
        while (it.hasNext()) {
            PatternMatcher pe = it.next();
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Path: \"""");
            sb.append(pe);
            sb.append(""\"""");
            du.println(sb.toString());
        }
    }
    if (mDataTypes != null) {
        Iterator<String> it = mDataTypes.iterator();
        while (it.hasNext()) {
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Type: \"""");
            sb.append(it.next());
            sb.append(""\"""");
            du.println(sb.toString());
        }
    }
    if (mPriority != 0 || mHasPartialTypes) {
        sb.setLength(0);
        sb.append(prefix);
        sb.append(""mPriority="");
        sb.append(mPriority);
        sb.append("", mHasPartialTypes="");
        sb.append(mHasPartialTypes);
        du.println(sb.toString());
    }
    {
        sb.setLength(0);
        sb.append(prefix);
        sb.append(""AutoVerify="");
        sb.append(getAutoVerify());
        du.println(sb.toString());
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
526,<android.view.TextureView: void setSurfaceTexture(SurfaceTexture)>,22,23,<android.view.TextureView: void setSurfaceTexture(SurfaceTexture)>,<android.view.TextureView: void setSurfaceTexture(SurfaceTexture)>,0,"{
    if (surfaceTexture == null) {
        throw new NullPointerException(""surfaceTexture must not be null"");
    }
    if (mSurface != null) {
        mSurface.release();
    }
    mSurface = surfaceTexture;
    mUpdateSurface = true;
    invalidateParentIfNeeded();
}","{
    if (surfaceTexture == null) {
        throw new NullPointerException(""surfaceTexture must not be null"");
    }
    if (surfaceTexture == mSurface) {
        throw new IllegalArgumentException(""Trying to setSurfaceTexture to "" + ""the same SurfaceTexture that's already set."");
    }
    if (surfaceTexture.isReleased()) {
        throw new IllegalArgumentException(""Cannot setSurfaceTexture to a "" + ""released SurfaceTexture"");
    }
    if (mSurface != null) {
        mSurface.release();
    }
    mSurface = surfaceTexture;
    /*
         * If the view is visible and we already made a layer, update the
         * listener in the new surface to use the existing listener in the view.
         * Otherwise this will be called when the view becomes visible or the
         * layer is created
         */
    if (((mViewFlags & VISIBILITY_MASK) == VISIBLE) && mLayer != null) {
        mSurface.setOnFrameAvailableListener(mUpdateListener, mAttachInfo.mHandler);
    }
    mUpdateSurface = true;
    invalidateParentIfNeeded();
}",1,"/**
 * Set the {@link SurfaceTexture} for this view to use. If a {@link
 * SurfaceTexture} is already being used by this view, it is immediately
 * released and not be usable any more.  The {@link
 * SurfaceTextureListener#onSurfaceTextureDestroyed} callback is <b>not</b>
 * called for the previous {@link SurfaceTexture}.  Similarly, the {@link
 * SurfaceTextureListener#onSurfaceTextureAvailable} callback is <b>not</b>
 * called for the {@link SurfaceTexture} passed to setSurfaceTexture.
 *
 * The {@link SurfaceTexture} object must be detached from all OpenGL ES
 * contexts prior to calling this method.
 *
 * @param surfaceTexture The {@link SurfaceTexture} that the view should use.
 * @see SurfaceTexture#detachFromGLContext()
 */
","/**
 * Set the {@link SurfaceTexture} for this view to use. If a {@link
 * SurfaceTexture} is already being used by this view, it is immediately
 * released and not be usable any more.  The {@link
 * SurfaceTextureListener#onSurfaceTextureDestroyed} callback is <b>not</b>
 * called for the previous {@link SurfaceTexture}.  Similarly, the {@link
 * SurfaceTextureListener#onSurfaceTextureAvailable} callback is <b>not</b>
 * called for the {@link SurfaceTexture} passed to setSurfaceTexture.
 *
 * The {@link SurfaceTexture} object must be detached from all OpenGL ES
 * contexts prior to calling this method.
 *
 * @param surfaceTexture The {@link SurfaceTexture} that the view should use.
 * @see SurfaceTexture#detachFromGLContext()
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,3,4","1,2","The late version introduces new checks in the method, changes and adds exception handling statements, and also adds a new block for setting the on-frame available listener. This includes a change in return statement, exception handling statement, control dependency change (due to a new 'if' block), and other statements for the listener setup. Thus, the changes are of type 1,2,3,4.","The new exception handling statements could cause the method to throw a new type of exception (`IllegalArgumentException`) if the provided `SurfaceTexture` is already set or if it has been released. In addition, control flow has been affected by the added 'if' block, potentially affecting when the surface listener is set, thus changing the behavior of the API and possibly the values returned. Therefore, the CI type is 1,2."
527,<android.view.View: View findViewByAccessibilityId(int)>,22,23,<android.view.View: View findViewByAccessibilityId(int)>,<android.view.View: View findViewByAccessibilityId(int)>,0,"{
    if (accessibilityId < 0) {
        return null;
    }
    return findViewByAccessibilityIdTraversal(accessibilityId);
}","{
    if (accessibilityId < 0) {
        return null;
    }
    View view = findViewByAccessibilityIdTraversal(accessibilityId);
    if (view != null) {
        return view.includeForAccessibility() ? view : null;
    }
    return null;
}",1,"/**
 * Finds a view by its unuque and stable accessibility id.
 *
 * @param accessibilityId The searched accessibility id.
 * @return The found view.
 */
","/**
 * Finds a view by its unuque and stable accessibility id.
 *
 * @param accessibilityId The searched accessibility id.
 * @return The found view.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"There is a new control dependency introduced by checking if the retrieved view is not null and should be included for accessibility. There is also a new return statement conditioned on the result of 'view.includeForAccessibility()', which could potentially return a different value. Therefore, the code change types are 1 and 3.","The late version of the method includes additional logic which may prevent some views from being returned even if they match the accessibility ID. The CI type is 1, because this new logic introduces the potential for a different return value—the early version always returned the view that matched the accessibility ID, while the late version may now return null for some views that would have previously been returned."
528,<android.hardware.camera2.CaptureRequest: int hashCode()>,22,23,<android.hardware.camera2.CaptureRequest: int hashCode()>,<android.hardware.camera2.CaptureRequest: int hashCode()>,0,"{
    return HashCodeHelpers.hashCode(mSettings, mSurfaceSet, mUserTag);
}","{
    return HashCodeHelpers.hashCodeGeneric(mSettings, mSurfaceSet, mUserTag);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The method HashCodeHelpers.hashCode() is replaced with HashCodeHelpers.hashCodeGeneric() in the method body. This indicates that a dependent API has changed, so the code change type is 5.","While the method used for creating the hash code has changed, the behavior is presumed to be consistent with how hash codes are generated, namely, that the new method should provide a hash code that fulfills the same contract as the previous one. It should still return an int derived from the fields of the object, and thus, it's unlikely this would constitute a compatibility issue unless the new hashCodeGeneric method introduced changes to the algorithm that would affect the output for the same inputs which has not been indicated. Therefore, I conclude there is no compatibility issue, and the CI type is 0."
529,<android.text.style.TextAppearanceSpan: int getSpanTypeId()>,22,23,<android.text.style.TextAppearanceSpan: int getSpanTypeId()>,<android.text.style.TextAppearanceSpan: int getSpanTypeId()>,0,"{
    return TextUtils.TEXT_APPEARANCE_SPAN;
}","{
    return getSpanTypeIdInternal();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation has changed from returning a constant, TextUtils.TEXT_APPEARANCE_SPAN, to calling another method, getSpanTypeIdInternal(). The change is in the method used to determine the return value, so the code change type is 5.","There's no Compatibility Issue if the getSpanTypeIdInternal() returns the same value as the constant TextUtils.TEXT_APPEARANCE_SPAN that was returned in the early version; thus, unless there's reason to believe getSpanTypeIdInternal() returns a different value (which is not indicated by provided information), the change should not cause a CI. Therefore, assuming getSpanTypeIdInternal() returns the correct typeId that corresponds with TEXT_APPEARANCE_SPAN, there is no CI."
532,<android.text.format.DateFormat: char[] getDateFormatOrder(Context)>,22,23,<android.text.format.DateFormat: char[] getDateFormatOrder(Context)>,<android.text.format.DateFormat: char[] getDateFormatOrder(Context)>,0,"{
    return ICU.getDateFormatOrder(getDateFormatString(context));
}","{
    return ICU.getDateFormatOrder(getDateFormatString());
}",1,"/**
 * Gets the current date format stored as a char array. Returns a 3 element
 * array containing the day ({@code 'd'}), month ({@code 'M'}), and year ({@code 'y'}))
 * in the order specified by the user's format preference.  Note that this order is
 * <i>only</i> appropriate for all-numeric dates; spelled-out (MEDIUM and LONG)
 * dates will generally contain other punctuation, spaces, or words,
 * not just the day, month, and year, and not necessarily in the same
 * order returned here.
 */
","/**
 * Gets the current date format stored as a char array. Returns a 3 element
 * array containing the day ({@code 'd'}), month ({@code 'M'}), and year ({@code 'y'}))
 * in the order specified by the user's format preference.  Note that this order is
 * <i>only</i> appropriate for all-numeric dates; spelled-out (MEDIUM and LONG)
 * dates will generally contain other punctuation, spaces, or words,
 * not just the day, month, and year, and not necessarily in the same
 * order returned here.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent API getDateFormatString() no longer takes a parameter in the late version, which indicates that there was a change in the dependent API, hence the code change type is 5.","Since there's only a change in how the dependent API is called without any change to the control flow, return statements, or exception handling, there's no indication that this would lead to a different return value or type, or throw a different exception. Hence, there's no Compatibility Issue as far as we can tell from the given change, therefore, the CI type is 0."
533,<android.content.RestrictionEntry: int hashCode()>,22,23,<android.content.RestrictionEntry: int hashCode()>,<android.content.RestrictionEntry: int hashCode()>,0,"{
    int result = 17;
    result = 31 * result + mKey.hashCode();
    if (mCurrentValue != null) {
        result = 31 * result + mCurrentValue.hashCode();
    } else if (mCurrentValues != null) {
        for (String value : mCurrentValues) {
            if (value != null) {
                result = 31 * result + value.hashCode();
            }
        }
    }
    return result;
}","{
    int result = 17;
    result = 31 * result + mKey.hashCode();
    if (mCurrentValue != null) {
        result = 31 * result + mCurrentValue.hashCode();
    } else if (mCurrentValues != null) {
        for (String value : mCurrentValues) {
            if (value != null) {
                result = 31 * result + value.hashCode();
            }
        }
    } else if (mRestrictions != null) {
        result = 31 * result + Arrays.hashCode(mRestrictions);
    }
    return result;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"An additional condition with a statement (`else if (mRestrictions != null) { result = 31 * result + Arrays.hashCode(mRestrictions); }`) was added to the early implementation in the late version, which constitutes both a new control dependency (an additional else-if branch) and a change in the statements within the method body. This leads to a change type of 1,4.","Because of the added else-if statement, in the late version, the hashCode may return a different value when `mRestrictions` is not null. Consequently, two objects that might have been considered equal in the earlier version (because their `mRestrictions` were not considered in the hashCode computation) may not be considered equal in the late version, leading to a CI of type 1."
534,<android.bluetooth.BluetoothAdapter: BluetoothLeScanner getBluetoothLeScanner()>,22,23,<android.bluetooth.BluetoothAdapter: BluetoothLeScanner getBluetoothLeScanner()>,<android.bluetooth.BluetoothAdapter: BluetoothLeScanner getBluetoothLeScanner()>,0,"{
    if (getState() != STATE_ON) {
        return null;
    }
    synchronized (mLock) {
        if (sBluetoothLeScanner == null) {
            sBluetoothLeScanner = new BluetoothLeScanner(mManagerService);
        }
    }
    return sBluetoothLeScanner;
}","{
    if (!getLeAccess())
        return null;
    synchronized (mLock) {
        if (sBluetoothLeScanner == null) {
            sBluetoothLeScanner = new BluetoothLeScanner(mManagerService);
        }
    }
    return sBluetoothLeScanner;
}",1,"/**
 * Returns a {@link BluetoothLeScanner} object for Bluetooth LE scan operations.
 */
","/**
 * Returns a {@link BluetoothLeScanner} object for Bluetooth LE scan operations.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,5",1,"The conditional check has changed from 'getState() != STATE_ON' to '!getLeAccess()', which indicates a change in control dependency and the condition on which the method's behavior is based. Additionally, the changed condition relies on a different method to determine the outcome, so the dependent API has also changed. The code change types are 3 and 5.","Due to the change in the conditional check before the 'return null' statement, now the method could potentially return null in different situations based on the new 'getLeAccess()' condition rather than the earlier 'getState() != STATE_ON' check. Therefore, this is a potential Compatibility Issue caused by potentially different return values or types. The CI type is 1."
536,"<android.view.ViewGroup: int getChildMeasureSpec(int,int,int)>",22,23,"<android.view.ViewGroup: int getChildMeasureSpec(int,int,int)>","<android.view.ViewGroup: int getChildMeasureSpec(int,int,int)>",0,"{
    int specMode = MeasureSpec.getMode(spec);
    int specSize = MeasureSpec.getSize(spec);
    int size = Math.max(0, specSize - padding);
    int resultSize = 0;
    int resultMode = 0;
    switch(specMode) {
        // Parent has imposed an exact size on us
        case MeasureSpec.EXACTLY:
            if (childDimension >= 0) {
                resultSize = childDimension;
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.MATCH_PARENT) {
                // Child wants to be our size. So be it.
                resultSize = size;
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.WRAP_CONTENT) {
                // Child wants to determine its own size. It can't be
                // bigger than us.
                resultSize = size;
                resultMode = MeasureSpec.AT_MOST;
            }
            break;
        // Parent has imposed a maximum size on us
        case MeasureSpec.AT_MOST:
            if (childDimension >= 0) {
                // Child wants a specific size... so be it
                resultSize = childDimension;
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.MATCH_PARENT) {
                // Child wants to be our size, but our size is not fixed.
                // Constrain child to not be bigger than us.
                resultSize = size;
                resultMode = MeasureSpec.AT_MOST;
            } else if (childDimension == LayoutParams.WRAP_CONTENT) {
                // Child wants to determine its own size. It can't be
                // bigger than us.
                resultSize = size;
                resultMode = MeasureSpec.AT_MOST;
            }
            break;
        // Parent asked to see how big we want to be
        case MeasureSpec.UNSPECIFIED:
            if (childDimension >= 0) {
                // Child wants a specific size... let him have it
                resultSize = childDimension;
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.MATCH_PARENT) {
                // Child wants to be our size... find out how big it should
                // be
                resultSize = 0;
                resultMode = MeasureSpec.UNSPECIFIED;
            } else if (childDimension == LayoutParams.WRAP_CONTENT) {
                // Child wants to determine its own size.... find out how
                // big it should be
                resultSize = 0;
                resultMode = MeasureSpec.UNSPECIFIED;
            }
            break;
    }
    return MeasureSpec.makeMeasureSpec(resultSize, resultMode);
}","{
    int specMode = MeasureSpec.getMode(spec);
    int specSize = MeasureSpec.getSize(spec);
    int size = Math.max(0, specSize - padding);
    int resultSize = 0;
    int resultMode = 0;
    switch(specMode) {
        // Parent has imposed an exact size on us
        case MeasureSpec.EXACTLY:
            if (childDimension >= 0) {
                resultSize = childDimension;
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.MATCH_PARENT) {
                // Child wants to be our size. So be it.
                resultSize = size;
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.WRAP_CONTENT) {
                // Child wants to determine its own size. It can't be
                // bigger than us.
                resultSize = size;
                resultMode = MeasureSpec.AT_MOST;
            }
            break;
        // Parent has imposed a maximum size on us
        case MeasureSpec.AT_MOST:
            if (childDimension >= 0) {
                // Child wants a specific size... so be it
                resultSize = childDimension;
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.MATCH_PARENT) {
                // Child wants to be our size, but our size is not fixed.
                // Constrain child to not be bigger than us.
                resultSize = size;
                resultMode = MeasureSpec.AT_MOST;
            } else if (childDimension == LayoutParams.WRAP_CONTENT) {
                // Child wants to determine its own size. It can't be
                // bigger than us.
                resultSize = size;
                resultMode = MeasureSpec.AT_MOST;
            }
            break;
        // Parent asked to see how big we want to be
        case MeasureSpec.UNSPECIFIED:
            if (childDimension >= 0) {
                // Child wants a specific size... let him have it
                resultSize = childDimension;
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.MATCH_PARENT) {
                // Child wants to be our size... find out how big it should
                // be
                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;
                resultMode = MeasureSpec.UNSPECIFIED;
            } else if (childDimension == LayoutParams.WRAP_CONTENT) {
                // Child wants to determine its own size.... find out how
                // big it should be
                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;
                resultMode = MeasureSpec.UNSPECIFIED;
            }
            break;
    }
    return MeasureSpec.makeMeasureSpec(resultSize, resultMode);
}",1,"/**
 * Does the hard part of measureChildren: figuring out the MeasureSpec to
 * pass to a particular child. This method figures out the right MeasureSpec
 * for one dimension (height or width) of one child view.
 *
 * The goal is to combine information from our MeasureSpec with the
 * LayoutParams of the child to get the best possible results. For example,
 * if the this view knows its size (because its MeasureSpec has a mode of
 * EXACTLY), and the child has indicated in its LayoutParams that it wants
 * to be the same size as the parent, the parent should ask the child to
 * layout given an exact size.
 *
 * @param spec The requirements for this view
 * @param padding The padding of this view for the current dimension and
 * margins, if applicable
 * @param childDimension How big the child wants to be in the current
 * dimension
 * @return a MeasureSpec integer for the child
 */
","/**
 * Does the hard part of measureChildren: figuring out the MeasureSpec to
 * pass to a particular child. This method figures out the right MeasureSpec
 * for one dimension (height or width) of one child view.
 *
 * The goal is to combine information from our MeasureSpec with the
 * LayoutParams of the child to get the best possible results. For example,
 * if the this view knows its size (because its MeasureSpec has a mode of
 * EXACTLY), and the child has indicated in its LayoutParams that it wants
 * to be the same size as the parent, the parent should ask the child to
 * layout given an exact size.
 *
 * @param spec The requirements for this view
 * @param padding The padding of this view for the current dimension and
 * margins, if applicable
 * @param childDimension How big the child wants to be in the current
 * dimension
 * @return a MeasureSpec integer for the child
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
537,"<android.hardware.camera2.legacy.LegacyMetadataMapper: CameraMetadataNative createRequestTemplate(CameraCharacteristics,int)>",22,23,"<android.hardware.camera2.legacy.LegacyMetadataMapper: CameraMetadataNative createRequestTemplate(CameraCharacteristics,int)>","<android.hardware.camera2.legacy.LegacyMetadataMapper: CameraMetadataNative createRequestTemplate(CameraCharacteristics,int)>",0,"{
    if (!ArrayUtils.contains(sAllowedTemplates, templateId)) {
        throw new IllegalArgumentException(""templateId out of range"");
    }
    CameraMetadataNative m = new CameraMetadataNative();
    /*
         * NOTE: If adding new code here and it needs to query the static info,
         * query the camera characteristics, so we can reuse this for api2 code later
         * to create our own templates in the framework
         */
    /*
         * control.*
         */
    // control.awbMode
    m.set(CaptureRequest.CONTROL_AWB_MODE, CameraMetadata.CONTROL_AWB_MODE_AUTO);
    // AWB is always unconditionally available in API1 devices
    // control.aeAntibandingMode
    m.set(CaptureRequest.CONTROL_AE_ANTIBANDING_MODE, CONTROL_AE_ANTIBANDING_MODE_AUTO);
    // control.aeExposureCompensation
    m.set(CaptureRequest.CONTROL_AE_EXPOSURE_COMPENSATION, 0);
    // control.aeLock
    m.set(CaptureRequest.CONTROL_AE_LOCK, false);
    // control.aePrecaptureTrigger
    m.set(CaptureRequest.CONTROL_AE_PRECAPTURE_TRIGGER, CONTROL_AE_PRECAPTURE_TRIGGER_IDLE);
    // control.afTrigger
    m.set(CaptureRequest.CONTROL_AF_TRIGGER, CONTROL_AF_TRIGGER_IDLE);
    // control.awbMode
    m.set(CaptureRequest.CONTROL_AWB_MODE, CONTROL_AWB_MODE_AUTO);
    // control.awbLock
    m.set(CaptureRequest.CONTROL_AWB_LOCK, false);
    // control.aeRegions, control.awbRegions, control.afRegions
    {
        Rect activeArray = c.get(SENSOR_INFO_ACTIVE_ARRAY_SIZE);
        MeteringRectangle[] activeRegions = new MeteringRectangle[] { new MeteringRectangle(/*x*/
        0, /*y*/
        0, /*width*/
        activeArray.width() - 1, /*height*/
        activeArray.height() - 1, /*weight*/
        0) };
        m.set(CaptureRequest.CONTROL_AE_REGIONS, activeRegions);
        m.set(CaptureRequest.CONTROL_AWB_REGIONS, activeRegions);
        m.set(CaptureRequest.CONTROL_AF_REGIONS, activeRegions);
    }
    // control.captureIntent
    {
        int captureIntent;
        switch(templateId) {
            case CameraDevice.TEMPLATE_PREVIEW:
                captureIntent = CONTROL_CAPTURE_INTENT_PREVIEW;
                break;
            case CameraDevice.TEMPLATE_STILL_CAPTURE:
                captureIntent = CONTROL_CAPTURE_INTENT_STILL_CAPTURE;
                break;
            case CameraDevice.TEMPLATE_RECORD:
                captureIntent = CONTROL_CAPTURE_INTENT_VIDEO_RECORD;
                break;
            default:
                // Can't get anything else since it's guarded by the IAE check
                throw new AssertionError(""Impossible; keep in sync with sAllowedTemplates"");
        }
        m.set(CaptureRequest.CONTROL_CAPTURE_INTENT, captureIntent);
    }
    // control.aeMode
    m.set(CaptureRequest.CONTROL_AE_MODE, CameraMetadata.CONTROL_AE_MODE_ON);
    // AE is always unconditionally available in API1 devices
    // control.mode
    m.set(CaptureRequest.CONTROL_MODE, CONTROL_MODE_AUTO);
    // control.afMode
    {
        Float minimumFocusDistance = c.get(LENS_INFO_MINIMUM_FOCUS_DISTANCE);
        int afMode;
        if (minimumFocusDistance != null && minimumFocusDistance == LENS_INFO_MINIMUM_FOCUS_DISTANCE_FIXED_FOCUS) {
            // Cannot control auto-focus with fixed-focus cameras
            afMode = CameraMetadata.CONTROL_AF_MODE_OFF;
        } else {
            // If a minimum focus distance is reported; the camera must have AF
            afMode = CameraMetadata.CONTROL_AF_MODE_AUTO;
            if (templateId == CameraDevice.TEMPLATE_RECORD || templateId == CameraDevice.TEMPLATE_VIDEO_SNAPSHOT) {
                if (ArrayUtils.contains(c.get(CONTROL_AF_AVAILABLE_MODES), CONTROL_AF_MODE_CONTINUOUS_VIDEO)) {
                    afMode = CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_VIDEO;
                }
            } else if (templateId == CameraDevice.TEMPLATE_PREVIEW || templateId == CameraDevice.TEMPLATE_STILL_CAPTURE) {
                if (ArrayUtils.contains(c.get(CONTROL_AF_AVAILABLE_MODES), CONTROL_AF_MODE_CONTINUOUS_PICTURE)) {
                    afMode = CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE;
                }
            }
        }
        if (VERBOSE) {
            Log.v(TAG, ""createRequestTemplate (templateId="" + templateId + ""),"" + "" afMode="" + afMode + "", minimumFocusDistance="" + minimumFocusDistance);
        }
        m.set(CaptureRequest.CONTROL_AF_MODE, afMode);
    }
    {
        // control.aeTargetFpsRange
        Range<Integer>[] availableFpsRange = c.get(CameraCharacteristics.CONTROL_AE_AVAILABLE_TARGET_FPS_RANGES);
        // Pick FPS range with highest max value, tiebreak on higher min value
        Range<Integer> bestRange = availableFpsRange[0];
        for (Range<Integer> r : availableFpsRange) {
            if (bestRange.getUpper() < r.getUpper()) {
                bestRange = r;
            } else if (bestRange.getUpper() == r.getUpper() && bestRange.getLower() < r.getLower()) {
                bestRange = r;
            }
        }
        m.set(CaptureRequest.CONTROL_AE_TARGET_FPS_RANGE, bestRange);
    }
    // control.sceneMode -- DISABLED is always available
    m.set(CaptureRequest.CONTROL_SCENE_MODE, CONTROL_SCENE_MODE_DISABLED);
    /*
         * statistics.*
         */
    // statistics.faceDetectMode
    m.set(CaptureRequest.STATISTICS_FACE_DETECT_MODE, STATISTICS_FACE_DETECT_MODE_OFF);
    /*
         * flash.*
         */
    // flash.mode
    m.set(CaptureRequest.FLASH_MODE, FLASH_MODE_OFF);
    /*
         * noiseReduction.*
         */
    m.set(CaptureRequest.NOISE_REDUCTION_MODE, NOISE_REDUCTION_MODE_FAST);
    /*
         * lens.*
         */
    // lens.focalLength
    m.set(CaptureRequest.LENS_FOCAL_LENGTH, c.get(CameraCharacteristics.LENS_INFO_AVAILABLE_FOCAL_LENGTHS)[0]);
    /*
         * jpeg.*
         */
    // jpeg.thumbnailSize - set smallest non-zero size if possible
    Size[] sizes = c.get(CameraCharacteristics.JPEG_AVAILABLE_THUMBNAIL_SIZES);
    m.set(CaptureRequest.JPEG_THUMBNAIL_SIZE, (sizes.length > 1) ? sizes[1] : sizes[0]);
    // TODO: map other request template values
    return m;
}","{
    if (!ArrayUtils.contains(sAllowedTemplates, templateId)) {
        throw new IllegalArgumentException(""templateId out of range"");
    }
    CameraMetadataNative m = new CameraMetadataNative();
    /*
         * NOTE: If adding new code here and it needs to query the static info,
         * query the camera characteristics, so we can reuse this for api2 code later
         * to create our own templates in the framework
         */
    /*
         * control.*
         */
    // control.awbMode
    m.set(CaptureRequest.CONTROL_AWB_MODE, CameraMetadata.CONTROL_AWB_MODE_AUTO);
    // AWB is always unconditionally available in API1 devices
    // control.aeAntibandingMode
    m.set(CaptureRequest.CONTROL_AE_ANTIBANDING_MODE, CONTROL_AE_ANTIBANDING_MODE_AUTO);
    // control.aeExposureCompensation
    m.set(CaptureRequest.CONTROL_AE_EXPOSURE_COMPENSATION, 0);
    // control.aeLock
    m.set(CaptureRequest.CONTROL_AE_LOCK, false);
    // control.aePrecaptureTrigger
    m.set(CaptureRequest.CONTROL_AE_PRECAPTURE_TRIGGER, CONTROL_AE_PRECAPTURE_TRIGGER_IDLE);
    // control.afTrigger
    m.set(CaptureRequest.CONTROL_AF_TRIGGER, CONTROL_AF_TRIGGER_IDLE);
    // control.awbMode
    m.set(CaptureRequest.CONTROL_AWB_MODE, CONTROL_AWB_MODE_AUTO);
    // control.awbLock
    m.set(CaptureRequest.CONTROL_AWB_LOCK, false);
    // control.aeRegions, control.awbRegions, control.afRegions
    {
        Rect activeArray = c.get(SENSOR_INFO_ACTIVE_ARRAY_SIZE);
        MeteringRectangle[] activeRegions = new MeteringRectangle[] { new MeteringRectangle(/*x*/
        0, /*y*/
        0, /*width*/
        activeArray.width() - 1, /*height*/
        activeArray.height() - 1, /*weight*/
        0) };
        m.set(CaptureRequest.CONTROL_AE_REGIONS, activeRegions);
        m.set(CaptureRequest.CONTROL_AWB_REGIONS, activeRegions);
        m.set(CaptureRequest.CONTROL_AF_REGIONS, activeRegions);
    }
    // control.captureIntent
    {
        int captureIntent;
        switch(templateId) {
            case CameraDevice.TEMPLATE_PREVIEW:
                captureIntent = CONTROL_CAPTURE_INTENT_PREVIEW;
                break;
            case CameraDevice.TEMPLATE_STILL_CAPTURE:
                captureIntent = CONTROL_CAPTURE_INTENT_STILL_CAPTURE;
                break;
            case CameraDevice.TEMPLATE_RECORD:
                captureIntent = CONTROL_CAPTURE_INTENT_VIDEO_RECORD;
                break;
            default:
                // Can't get anything else since it's guarded by the IAE check
                throw new AssertionError(""Impossible; keep in sync with sAllowedTemplates"");
        }
        m.set(CaptureRequest.CONTROL_CAPTURE_INTENT, captureIntent);
    }
    // control.aeMode
    m.set(CaptureRequest.CONTROL_AE_MODE, CameraMetadata.CONTROL_AE_MODE_ON);
    // AE is always unconditionally available in API1 devices
    // control.mode
    m.set(CaptureRequest.CONTROL_MODE, CONTROL_MODE_AUTO);
    // control.afMode
    {
        Float minimumFocusDistance = c.get(LENS_INFO_MINIMUM_FOCUS_DISTANCE);
        int afMode;
        if (minimumFocusDistance != null && minimumFocusDistance == LENS_INFO_MINIMUM_FOCUS_DISTANCE_FIXED_FOCUS) {
            // Cannot control auto-focus with fixed-focus cameras
            afMode = CameraMetadata.CONTROL_AF_MODE_OFF;
        } else {
            // If a minimum focus distance is reported; the camera must have AF
            afMode = CameraMetadata.CONTROL_AF_MODE_AUTO;
            if (templateId == CameraDevice.TEMPLATE_RECORD || templateId == CameraDevice.TEMPLATE_VIDEO_SNAPSHOT) {
                if (ArrayUtils.contains(c.get(CONTROL_AF_AVAILABLE_MODES), CONTROL_AF_MODE_CONTINUOUS_VIDEO)) {
                    afMode = CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_VIDEO;
                }
            } else if (templateId == CameraDevice.TEMPLATE_PREVIEW || templateId == CameraDevice.TEMPLATE_STILL_CAPTURE) {
                if (ArrayUtils.contains(c.get(CONTROL_AF_AVAILABLE_MODES), CONTROL_AF_MODE_CONTINUOUS_PICTURE)) {
                    afMode = CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE;
                }
            }
        }
        if (DEBUG) {
            Log.v(TAG, ""createRequestTemplate (templateId="" + templateId + ""),"" + "" afMode="" + afMode + "", minimumFocusDistance="" + minimumFocusDistance);
        }
        m.set(CaptureRequest.CONTROL_AF_MODE, afMode);
    }
    {
        // control.aeTargetFpsRange
        Range<Integer>[] availableFpsRange = c.get(CameraCharacteristics.CONTROL_AE_AVAILABLE_TARGET_FPS_RANGES);
        // Pick FPS range with highest max value, tiebreak on higher min value
        Range<Integer> bestRange = availableFpsRange[0];
        for (Range<Integer> r : availableFpsRange) {
            if (bestRange.getUpper() < r.getUpper()) {
                bestRange = r;
            } else if (bestRange.getUpper() == r.getUpper() && bestRange.getLower() < r.getLower()) {
                bestRange = r;
            }
        }
        m.set(CaptureRequest.CONTROL_AE_TARGET_FPS_RANGE, bestRange);
    }
    // control.sceneMode -- DISABLED is always available
    m.set(CaptureRequest.CONTROL_SCENE_MODE, CONTROL_SCENE_MODE_DISABLED);
    /*
         * statistics.*
         */
    // statistics.faceDetectMode
    m.set(CaptureRequest.STATISTICS_FACE_DETECT_MODE, STATISTICS_FACE_DETECT_MODE_OFF);
    /*
         * flash.*
         */
    // flash.mode
    m.set(CaptureRequest.FLASH_MODE, FLASH_MODE_OFF);
    /*
         * noiseReduction.*
         */
    m.set(CaptureRequest.NOISE_REDUCTION_MODE, NOISE_REDUCTION_MODE_FAST);
    /*
         * lens.*
         */
    // lens.focalLength
    m.set(CaptureRequest.LENS_FOCAL_LENGTH, c.get(CameraCharacteristics.LENS_INFO_AVAILABLE_FOCAL_LENGTHS)[0]);
    /*
         * jpeg.*
         */
    // jpeg.thumbnailSize - set smallest non-zero size if possible
    Size[] sizes = c.get(CameraCharacteristics.JPEG_AVAILABLE_THUMBNAIL_SIZES);
    m.set(CaptureRequest.JPEG_THUMBNAIL_SIZE, (sizes.length > 1) ? sizes[1] : sizes[0]);
    // TODO: map other request template values
    return m;
}",1,"/**
 * Create a request template
 *
 * @param c a non-{@code null} camera characteristics for this camera
 * @param templateId a non-negative template ID
 *
 * @return a non-{@code null} request template
 *
 * @throws IllegalArgumentException if {@code templateId} was invalid
 *
 * @see android.hardware.camera2.CameraDevice#TEMPLATE_MANUAL
 */
","/**
 * Create a request template
 *
 * @param c a non-{@code null} camera characteristics for this camera
 * @param templateId a non-negative template ID
 *
 * @return a non-{@code null} request template
 *
 * @throws IllegalArgumentException if {@code templateId} was invalid
 *
 * @see android.hardware.camera2.CameraDevice#TEMPLATE_MANUAL
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
538,"<android.view.View.MeasureSpec: int adjust(int,int)>",22,23,"<android.view.View.MeasureSpec: int adjust(int,int)>","<android.view.View.MeasureSpec: int adjust(int,int)>",0,"{
    final int mode = getMode(measureSpec);
    if (mode == UNSPECIFIED) {
        // No need to adjust size for UNSPECIFIED mode.
        return makeMeasureSpec(0, UNSPECIFIED);
    }
    int size = getSize(measureSpec) + delta;
    if (size < 0) {
        Log.e(VIEW_LOG_TAG, ""MeasureSpec.adjust: new size would be negative! ("" + size + "") spec: "" + toString(measureSpec) + "" delta: "" + delta);
        size = 0;
    }
    return makeMeasureSpec(size, mode);
}","{
    final int mode = getMode(measureSpec);
    int size = getSize(measureSpec);
    if (mode == UNSPECIFIED) {
        // No need to adjust size for UNSPECIFIED mode.
        return makeMeasureSpec(size, UNSPECIFIED);
    }
    size += delta;
    if (size < 0) {
        Log.e(VIEW_LOG_TAG, ""MeasureSpec.adjust: new size would be negative! ("" + size + "") spec: "" + toString(measureSpec) + "" delta: "" + delta);
        size = 0;
    }
    return makeMeasureSpec(size, mode);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,Several changes are observed:,- No change in exception handling is present.
541,<android.hardware.camera2.params.StreamConfigurationMap: Size[] getOutputSizes(int)>,22,23,<android.hardware.camera2.params.StreamConfigurationMap: Size[] getOutputSizes(int)>,<android.hardware.camera2.params.StreamConfigurationMap: Size[] getOutputSizes(int)>,0,"{
    return getPublicFormatSizes(format, /*output*/
    true);
}","{
    return getPublicFormatSizes(format, /*output*/
    true, /*highRes*/
    false);
}",1,"/**
 * Get a list of sizes compatible with the requested image {@code format}.
 *
 * <p>The {@code format} should be a supported format (one of the formats returned by
 * {@link #getOutputFormats}).</p>
 *
 * @param format an image format from {@link ImageFormat} or {@link PixelFormat}
 * @return
 * an array of supported sizes,
 * or {@code null} if the {@code format} is not a supported output
 *
 * @see ImageFormat
 * @see PixelFormat
 * @see #getOutputFormats
 */
","/**
 * Get a list of sizes compatible with the requested image {@code format}.
 *
 * <p>The {@code format} should be a supported format (one of the formats returned by
 * {@link #getOutputFormats}).</p>
 *
 * As of API level 23, the {@link #getHighResolutionOutputSizes} method can be used on devices
 * that support the
 * {@link android.hardware.camera2.CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES_BURST_CAPTURE BURST_CAPTURE}
 * capability to get a list of high-resolution output sizes that cannot operate at the preferred
 * 20fps rate. This means that for some supported formats, this method will return an empty
 * list, if all the supported resolutions operate at below 20fps.  For devices that do not
 * support the BURST_CAPTURE capability, all output resolutions are listed through this method.
 *
 * @param format an image format from {@link ImageFormat} or {@link PixelFormat}
 * @return
 * an array of supported sizes,
 * or {@code null} if the {@code format} is not a supported output
 *
 * @see ImageFormat
 * @see PixelFormat
 * @see #getOutputFormats
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The code change is an invocation of a method where the late implementation added a boolean parameter 'false' to the getPublicFormatSizes, therefore the code change type is 5.","There is no Compatibility Issue here. It depends on whether the added parameter 'false' to the method getPublicFormatSizes alters behavior internal to the getOutputSizes API, the definition of a CI requires the return value or exception handling of the API itself to change, which is not evident solely from this added parameter. Without further information on how the internal method getPublicFormatSizes behaves with the new parameter, it cannot be concluded that a CI will occur. Therefore, pred_CI is classified as 0."
542,<android.view.View: void onRestoreInstanceState(Parcelable)>,22,23,<android.view.View: void onRestoreInstanceState(Parcelable)>,<android.view.View: void onRestoreInstanceState(Parcelable)>,0,"{
    mPrivateFlags |= PFLAG_SAVE_STATE_CALLED;
    if (state != BaseSavedState.EMPTY_STATE && state != null) {
        throw new IllegalArgumentException(""Wrong state class, expecting View State but "" + ""received "" + state.getClass().toString() + "" instead. This usually happens "" + ""when two views of different type have the same id in the same hierarchy. "" + ""This view's id is "" + ViewDebug.resolveId(mContext, getId()) + "". Make sure "" + ""other views do not use the same id."");
    }
}","{
    mPrivateFlags |= PFLAG_SAVE_STATE_CALLED;
    if (state != null && !(state instanceof AbsSavedState)) {
        throw new IllegalArgumentException(""Wrong state class, expecting View State but "" + ""received "" + state.getClass().toString() + "" instead. This usually happens "" + ""when two views of different type have the same id in the same hierarchy. "" + ""This view's id is "" + ViewDebug.resolveId(mContext, getId()) + "". Make sure "" + ""other views do not use the same id."");
    }
    if (state != null && state instanceof BaseSavedState) {
        mStartActivityRequestWho = ((BaseSavedState) state).mStartActivityRequestWhoSaved;
    }
}",1,"/**
 * Hook allowing a view to re-apply a representation of its internal state that had previously
 * been generated by {@link #onSaveInstanceState}. This function will never be called with a
 * null state.
 *
 * @param state The frozen state that had previously been returned by
 * {@link #onSaveInstanceState}.
 *
 * @see #onSaveInstanceState()
 * @see #restoreHierarchyState(android.util.SparseArray)
 * @see #dispatchRestoreInstanceState(android.util.SparseArray)
 */
","/**
 * Hook allowing a view to re-apply a representation of its internal state that had previously
 * been generated by {@link #onSaveInstanceState}. This function will never be called with a
 * null state.
 *
 * @param state The frozen state that had previously been returned by
 * {@link #onSaveInstanceState}.
 *
 * @see #onSaveInstanceState()
 * @see #restoreHierarchyState(android.util.SparseArray)
 * @see #dispatchRestoreInstanceState(android.util.SparseArray)
 */
",-1,,[@CallSuper],-1,-1,-1,-1,-1,-1,"1,3,4","1,2","The exception check has been changed from checking against BaseSavedState.EMPTY_STATE to checking if it is an instance of AbsSavedState, which is a broader check as AbsSavedState is likely to be a superclass of BaseSavedState. Additionally, there is a new control block (if statement) that assigns a value to mStartActivityRequestWho based on the state, and an assignment operation added to mStartActivityRequestWho based on the state's content. Therefore, the code change types are 1,3,4.","The change in the check for the state parameter's type could lead to a different exception being thrown under certain circumstances (if an object that is not a BaseSavedState but is an instance of AbsSavedState is passed in), representing a Compatibility Issue of type 2. Furthermore, with the addition of the new if statement and assignment operation to mStartActivityRequestWho, the method's behavior has changed since it may now modify the state of the object based on the provided Parcelable, which was not possible previously. This second modification can cause the API to behave differently and return different outcomes (even if indirectly, as the method's return type is void), leading to a CI of type 1."
543,<android.widget.FastScroller: boolean onInterceptTouchEvent(MotionEvent)>,22,23,<android.widget.FastScroller: boolean onInterceptTouchEvent(MotionEvent)>,<android.widget.FastScroller: boolean onInterceptTouchEvent(MotionEvent)>,0,"{
    if (!isEnabled()) {
        return false;
    }
    switch(ev.getActionMasked()) {
        case MotionEvent.ACTION_DOWN:
            if (isPointInside(ev.getX(), ev.getY())) {
                // event.
                if (!mList.isInScrollingContainer()) {
                    beginDrag();
                    return true;
                }
                mInitialTouchY = ev.getY();
                startPendingDrag();
            }
            break;
        case MotionEvent.ACTION_MOVE:
            if (!isPointInside(ev.getX(), ev.getY())) {
                cancelPendingDrag();
            } else if (mPendingDrag >= 0 && mPendingDrag <= SystemClock.uptimeMillis()) {
                beginDrag();
                final float pos = getPosFromMotionEvent(mInitialTouchY);
                scrollTo(pos);
                return onTouchEvent(ev);
            }
            break;
        case MotionEvent.ACTION_UP:
        case MotionEvent.ACTION_CANCEL:
            cancelPendingDrag();
            break;
    }
    return false;
}","{
    if (!isEnabled()) {
        return false;
    }
    switch(ev.getActionMasked()) {
        case MotionEvent.ACTION_DOWN:
            if (isPointInside(ev.getX(), ev.getY())) {
                // event.
                if (!mList.isInScrollingContainer()) {
                    // dragging there.
                    return true;
                }
                mInitialTouchY = ev.getY();
                startPendingDrag();
            }
            break;
        case MotionEvent.ACTION_MOVE:
            if (!isPointInside(ev.getX(), ev.getY())) {
                cancelPendingDrag();
            } else if (mPendingDrag >= 0 && mPendingDrag <= SystemClock.uptimeMillis()) {
                beginDrag();
                final float pos = getPosFromMotionEvent(mInitialTouchY);
                scrollTo(pos);
                // doesn't really matter since we'll already be in a drag.
                return onTouchEvent(ev);
            }
            break;
        case MotionEvent.ACTION_UP:
        case MotionEvent.ACTION_CANCEL:
            cancelPendingDrag();
            break;
    }
    return false;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,0,0,"There are comments added in the late version of implementation, but the executable code remains exactly the same as the early version implementation. Comments do not affect the functionality of the code.","Since there are no changes to the executable code, there are no changes in behavior of the API. Therefore, no Compatibility Issue arises."
545,"<android.content.BroadcastReceiver: IBinder peekService(Context,Intent)>",22,23,"<android.content.BroadcastReceiver: IBinder peekService(Context,Intent)>","<android.content.BroadcastReceiver: IBinder peekService(Context,Intent)>",0,"{
    IActivityManager am = ActivityManagerNative.getDefault();
    IBinder binder = null;
    try {
        service.prepareToLeaveProcess();
        binder = am.peekService(service, service.resolveTypeIfNeeded(myContext.getContentResolver()));
    } catch (RemoteException e) {
    }
    return binder;
}","{
    IActivityManager am = ActivityManagerNative.getDefault();
    IBinder binder = null;
    try {
        service.prepareToLeaveProcess();
        binder = am.peekService(service, service.resolveTypeIfNeeded(myContext.getContentResolver()), myContext.getOpPackageName());
    } catch (RemoteException e) {
    }
    return binder;
}",1,"/**
 * Provide a binder to an already-running service.  This method is synchronous
 * and will not start the target service if it is not present, so it is safe
 * to call from {@link #onReceive}.
 *
 * @param myContext The Context that had been passed to {@link #onReceive(Context, Intent)}
 * @param service The Intent indicating the service you wish to use.  See {@link
 * Context#startService(Intent)} for more information.
 */
","/**
 * Provide a binder to an already-running service.  This method is synchronous
 * and will not start the target service if it is not present, so it is safe
 * to call from {@link #onReceive}.
 *
 * @param myContext The Context that had been passed to {@link #onReceive(Context, Intent)}
 * @param service The Intent indicating the service you wish to use.  See {@link
 * Context#startService(Intent)} for more information.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The change consists of an additional parameter to the method call `am.peekService()`. The extra parameter is `myContext.getOpPackageName()`, which doesn't affect the return value or the exception thrown by the method. Therefore, the change type is 5, which indicates a dependent API change.",There is no Compatibility Issue because the new parameter should not affect the behavior of the API for existing clients. The new parameter is additional context but does not change how the method behaves in terms of the return value or the exceptions it throws. Hence the CI type is 0.
546,"<android.app.VoiceInteractor.CompleteVoiceRequest: IVoiceInteractorRequest submit(IVoiceInteractor,String,IVoiceInteractorCallback)>",22,23,"<android.app.VoiceInteractor.CompleteVoiceRequest: IVoiceInteractorRequest submit(IVoiceInteractor,String,IVoiceInteractorCallback)>","<android.app.VoiceInteractor.CompleteVoiceRequest: IVoiceInteractorRequest submit(IVoiceInteractor,String,IVoiceInteractorCallback)>",0,"{
    return interactor.startCompleteVoice(packageName, callback, mMessage, mExtras);
}","{
    return interactor.startCompleteVoice(packageName, callback, mPrompt, mExtras);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The method call changes from startCompleteVoice(packageName, callback, mMessage, mExtras) to startCompleteVoice(packageName, callback, mPrompt, mExtras), which suggests a change in the arguments passed to the method startCompleteVoice; therefore, the code change involves a different parameter in a method call, leading to type 4 (Other statement changed) and type 5 (Dependent API changed).","This change means a different argument (from mMessage to mPrompt) is passed to the method startCompleteVoice which could result in different behavior of the API. Therefore, it could cause the API to return a different value, making it a potential Compatibility Issue of type 1 (Compatibility Issue caused by potential different return values or types)."
547,"<android.content.res.TypedArray: float getFraction(int,int,int,float)>",22,23,"<android.content.res.TypedArray: float getFraction(int,int,int,float)>","<android.content.res.TypedArray: float getFraction(int,int,int,float)>",0,"{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_FRACTION) {
        return TypedValue.complexToFraction(data[index + AssetManager.STYLE_DATA], base, pbase);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        throw new RuntimeException(""Failed to resolve attribute at index "" + index);
    }
    throw new UnsupportedOperationException(""Can't convert to fraction: type=0x"" + Integer.toHexString(type));
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_FRACTION) {
        return TypedValue.complexToFraction(data[index + AssetManager.STYLE_DATA], base, pbase);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, value);
        throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + index + "": "" + value);
    }
    throw new UnsupportedOperationException(""Can't convert to fraction: type=0x"" + Integer.toHexString(type));
}",1,"/**
 * Retrieve a fractional unit attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 * @param base The base value of this fraction.  In other words, a
 * standard fraction is multiplied by this value.
 * @param pbase The parent base value of this fraction.  In other
 * words, a parent fraction (nn%p) is multiplied by this
 * value.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute fractional value multiplied by the appropriate
 * base value, or defValue if not defined.
 */
","/**
 * Retrieves a fractional unit attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 * @param base The base value of this fraction.  In other words, a
 * standard fraction is multiplied by this value.
 * @param pbase The parent base value of this fraction.  In other
 * words, a parent fraction (nn%p) is multiplied by this
 * value.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute fractional value multiplied by the appropriate
 * base value, or defValue if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not a fraction.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change is in the message of the RuntimeException that is thrown when the type is TypedValue.TYPE_ATTRIBUTE. Specifically, it now includes information about the value. No change in control flow, return values, or exception handling has been made, so the code change type is 4.","Since the exception thrown is of the same type (RuntimeException) and the action (throwing an exception) is just as likely to occur as before, but with a more detailed message, this does not introduce a Compatibility Issue with respect to return values or exception handling. The API behaves in the same way as before, just with an enhanced error message. Therefore, there is no Compatibility Issue."
550,<android.os.storage.IMountServiceListener.Stub.Proxy: void onUsbMassStorageConnectionChanged(boolean)>,22,23,<android.os.storage.IMountServiceListener.Stub.Proxy: void onUsbMassStorageConnectionChanged(boolean)>,<android.os.storage.IMountServiceListener.Stub.Proxy: void onUsbMassStorageConnectionChanged(boolean)>,0,"{
    Parcel _data = Parcel.obtain();
    Parcel _reply = Parcel.obtain();
    try {
        _data.writeInterfaceToken(DESCRIPTOR);
        _data.writeInt(((connected) ? (1) : (0)));
        mRemote.transact(Stub.TRANSACTION_onUsbMassStorageConnectionChanged, _data, _reply, 0);
        _reply.readException();
    } finally {
        _reply.recycle();
        _data.recycle();
    }
}","{
    Parcel _data = Parcel.obtain();
    Parcel _reply = Parcel.obtain();
    try {
        _data.writeInterfaceToken(DESCRIPTOR);
        _data.writeInt(((connected) ? (1) : (0)));
        mRemote.transact(Stub.TRANSACTION_onUsbMassStorageConnectionChanged, _data, _reply, android.os.IBinder.FLAG_ONEWAY);
        _reply.readException();
    } finally {
        _reply.recycle();
        _data.recycle();
    }
}",1,"/**
 * Detection state of USB Mass Storage has changed
 *
 * @param available true if a UMS host is connected.
 */
","/**
 * Detection state of USB Mass Storage has changed
 *
 * @param available true if a UMS host is connected.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change in the implementation is the flag value passed to the transact method: from 0 to android.os.IBinder.FLAG_ONEWAY. This change does not affect the return type or value, nor does it affect exception handling. It is an implementation detail related to the way IPC is handled. Therefore, the number for this change is 4.","Although there was a change in how the method handles IPC communication, this does not constitute a Compatibility Issue for the clients of the API, as it will not alter the return value or exceptions thrown by the method. Hence, there will be no Compatibility Issue, 0."
551,<android.content.res.ColorStateList: ColorStateList valueOf(int)>,22,23,<android.content.res.ColorStateList: ColorStateList valueOf(int)>,<android.content.res.ColorStateList: ColorStateList valueOf(int)>,0,"{
    // TODO: should we collect these eventually?
    synchronized (sCache) {
        final WeakReference<ColorStateList> ref = sCache.get(color);
        ColorStateList csl = ref != null ? ref.get() : null;
        if (csl != null) {
            return csl;
        }
        csl = new ColorStateList(EMPTY, new int[] { color });
        sCache.put(color, new WeakReference<ColorStateList>(csl));
        return csl;
    }
}","{
    synchronized (sCache) {
        final int index = sCache.indexOfKey(color);
        if (index >= 0) {
            final ColorStateList cached = sCache.valueAt(index).get();
            if (cached != null) {
                return cached;
            }
            // Prune missing entry.
            sCache.removeAt(index);
        }
        // Prune the cache before adding new items.
        final int N = sCache.size();
        for (int i = N - 1; i >= 0; i--) {
            if (sCache.valueAt(i).get() == null) {
                sCache.removeAt(i);
            }
        }
        final ColorStateList csl = new ColorStateList(EMPTY, new int[] { color });
        sCache.put(color, new WeakReference<>(csl));
        return csl;
    }
}",1,"/**
 * Creates or retrieves a ColorStateList that always returns a single color.
 */
","/**
 * @return A ColorStateList containing a single color.
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,"3,4",0,"The way the cache is accessed and modified has changed, which includes control dependency changes and other changes in the statements. New control structures are introduced, such as checking the index and using sCache.valueAt(index) instead of sCache.get(color). The cache pruning logic has also been added, which affects other statements. Therefore, the code change type is 3,4.","Despite the differences in the implementation details regarding the cache handling, the method's contract and return type have not changed, and there is no change in the API behavior that affects the value being returned or exceptions being thrown. Therefore, there is no Compatibility Issue, and the CI type is 0."
552,<android.widget.TextView: boolean selectAllText()>,22,23,<android.widget.TextView: boolean selectAllText()>,<android.widget.TextView: boolean selectAllText()>,0,"{
    final int length = mText.length();
    Selection.setSelection((Spannable) mText, 0, length);
    return length > 0;
}","{
    // selection.
    if (mEditor != null) {
        mEditor.hideInsertionPointCursorController();
    }
    final int length = mText.length();
    Selection.setSelection((Spannable) mText, 0, length);
    return length > 0;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The late implementation of this method includes an additional block of code that involves calling `mEditor.hideInsertionPointCursorController();`. This is a change to a statement that is not a return statement, exception handling, or a control dependency, so the code change type is 4.","The new statement does not affect the behavior of returning a different variable or throwing a new exception. The method still returns the same boolean value based on the length of `mText` and does not introduce any new exception handling. Therefore, there is no compatibility issue, so the CI type is 0."
553,"<android.widget.SimpleMonthView.MonthViewTouchHelper: int getVirtualViewAt(float,float)>",22,23,"<android.widget.SimpleMonthView.MonthViewTouchHelper: int getVirtualViewAt(float,float)>","<android.widget.SimpleMonthView.MonthViewTouchHelper: int getVirtualViewAt(float,float)>",0,"{
    final int day = getDayFromLocation(x, y);
    if (day >= 0) {
        return day;
    }
    return ExploreByTouchHelper.INVALID_ID;
}","{
    final int day = getDayAtLocation((int) (x + 0.5f), (int) (y + 0.5f));
    if (day != -1) {
        return day;
    }
    return ExploreByTouchHelper.INVALID_ID;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4,5",1,"The method getDayFromLocation in the early version has been changed to getDayAtLocation in the late version, with the addition of type casting and a slight mathematical alteration to the input parameters (x + 0.5f, y + 0.5f) which could fundamentally change the return value of the method, indicating a dependent API change (5). The control dependency has also changed where the early version checks if the day is greater than or equal to 0, while the late version checks if the day is not equal to -1 (4). Additionally, an Other statement change is observed due to the mathematical adjustment in the parameters. The return statement has not changed because in both implementations it still returns the same value based on a condition, but the change in the condition check itself is significant enough to potentially alter the return value (1).","The change in the condition check (from day >= 0 to day != -1) could potentially result in different return values, as well as the change in the dependent API's usage and its parameters, leading to different days being calculated. Thus, the CI type is 1."
554,"<android.app.ContextImpl: void sendOrderedBroadcast(Intent,String)>",22,23,"<android.app.ContextImpl: void sendOrderedBroadcast(Intent,String)>","<android.app.ContextImpl: void sendOrderedBroadcast(Intent,String)>",0,"{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess();
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermission, AppOpsManager.OP_NONE, true, false, getUserId());
    } catch (RemoteException e) {
    }
}","{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess();
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, AppOpsManager.OP_NONE, null, true, false, getUserId());
    } catch (RemoteException e) {
        throw new RuntimeException(""Failure from system"", e);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,4",2,"The late version introduces a new variable ""receiverPermissions"" and a new exception handling (""throw new RuntimeException(""Failure from system"", e)""). These changes are categorized as other statement changed and exception handling statement changed, so the change type is 2,4.","The new code throws a RuntimeException when encountering a RemoteException, whereas the early version simply catches and ignores it. This change in exception handling could result in a Compatibility Issue if the clients of the method are not prepared to handle the newly thrown RuntimeException. Therefore, the CI type is 2."
555,<android.webkit.WebView: boolean pageUp(boolean)>,22,23,<android.webkit.WebView: boolean pageUp(boolean)>,<android.webkit.WebView: boolean pageUp(boolean)>,0,"{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, ""pageUp"");
    return mProvider.pageUp(top);
}","{
    checkThread();
    return mProvider.pageUp(top);
}",1,"/**
 * Scrolls the contents of this WebView up by half the view size.
 *
 * @param top true to jump to the top of the page
 * @return true if the page was scrolled
 */
","/**
 * Scrolls the contents of this WebView up by half the view size.
 *
 * @param top true to jump to the top of the page
 * @return true if the page was scrolled
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"There is a logging statement that has been deleted (Log.d(LOGTAG, ""pageUp"");), so the code change type is 4.","The deletion of the logging statement is not affecting the behavior of the method in terms of return value or exception throwing, so there is no Compatibility Issue (CI type is 0)."
556,"<android.app.FragmentManagerImpl: boolean popBackStackImmediate(String,int)>",22,23,"<android.app.FragmentManagerImpl: boolean popBackStackImmediate(String,int)>","<android.app.FragmentManagerImpl: boolean popBackStackImmediate(String,int)>",0,"{
    checkStateLoss();
    executePendingTransactions();
    return popBackStackState(mActivity.mHandler, name, -1, flags);
}","{
    checkStateLoss();
    executePendingTransactions();
    return popBackStackState(mHost.getHandler(), name, -1, flags);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The change is from mActivity.mHandler to mHost.getHandler(), which indicates a dependent API change, so the code change type is 5.","Given that only the dependent API for obtaining the handler has changed, and not the logic of how 'popBackStackImmediate' functions internally or returns values, this would not lead to a CI in terms of return values or exception handling from the perspective of an API user. Therefore, there appears to be no compatibility issue present with this change, and the CI type is 0."
557,"<android.widget.ResourceCursorAdapter: View newDropDownView(Context,Cursor,ViewGroup)>",22,23,"<android.widget.ResourceCursorAdapter: View newDropDownView(Context,Cursor,ViewGroup)>","<android.widget.ResourceCursorAdapter: View newDropDownView(Context,Cursor,ViewGroup)>",0,"{
    return mInflater.inflate(mDropDownLayout, parent, false);
}","{
    return mDropDownInflater.inflate(mDropDownLayout, parent, false);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The code has changed to use `mDropDownInflater` instead of `mInflater` for inflating the layout, which corresponds to an ""Other statement changed"" and ""Dependent API changed"" since it alters the inflater object being used, so the code change type is 4,5.","There is no compatibility issue indicated by this change, as long as `mDropDownInflater` is correctly initialized as an inflater (which is an internal detail not visible in the API change) the behavior should remain the same, thus no different return values or exception handlings will occur solely because of the inflater instance change. Therefore, the CI type is 0."
558,<android.widget.TabHost.LabelAndIconIndicatorStrategy: View createIndicatorView()>,22,23,<android.widget.TabHost.LabelAndIconIndicatorStrategy: View createIndicatorView()>,<android.widget.TabHost.LabelAndIconIndicatorStrategy: View createIndicatorView()>,0,"{
    final Context context = getContext();
    LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    View tabIndicator = inflater.inflate(mTabLayoutId, // tab widget is the parent
    mTabWidget, // no inflate params
    false);
    final TextView tv = (TextView) tabIndicator.findViewById(R.id.title);
    final ImageView iconView = (ImageView) tabIndicator.findViewById(R.id.icon);
    // when icon is gone by default, we're in exclusive mode
    final boolean exclusive = iconView.getVisibility() == View.GONE;
    final boolean bindIcon = !exclusive || TextUtils.isEmpty(mLabel);
    tv.setText(mLabel);
    if (bindIcon && mIcon != null) {
        iconView.setImageDrawable(mIcon);
        iconView.setVisibility(VISIBLE);
    }
    if (context.getApplicationInfo().targetSdkVersion <= Build.VERSION_CODES.DONUT) {
        // Donut apps get old color scheme
        tabIndicator.setBackgroundResource(R.drawable.tab_indicator_v4);
        tv.setTextColor(context.getResources().getColorStateList(R.color.tab_indicator_text_v4));
    }
    return tabIndicator;
}","{
    final Context context = getContext();
    LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    View tabIndicator = inflater.inflate(mTabLayoutId, // tab widget is the parent
    mTabWidget, // no inflate params
    false);
    final TextView tv = (TextView) tabIndicator.findViewById(R.id.title);
    final ImageView iconView = (ImageView) tabIndicator.findViewById(R.id.icon);
    // when icon is gone by default, we're in exclusive mode
    final boolean exclusive = iconView.getVisibility() == View.GONE;
    final boolean bindIcon = !exclusive || TextUtils.isEmpty(mLabel);
    tv.setText(mLabel);
    if (bindIcon && mIcon != null) {
        iconView.setImageDrawable(mIcon);
        iconView.setVisibility(VISIBLE);
    }
    if (context.getApplicationInfo().targetSdkVersion <= Build.VERSION_CODES.DONUT) {
        // Donut apps get old color scheme
        tabIndicator.setBackgroundResource(R.drawable.tab_indicator_v4);
        tv.setTextColor(context.getColorStateList(R.color.tab_indicator_text_v4));
    }
    return tabIndicator;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The statement ""tv.setTextColor(context.getResources().getColorStateList(R.color.tab_indicator_text_v4));"" in the early version has been changed to ""tv.setTextColor(context.getColorStateList(R.color.tab_indicator_text_v4));"" in the late version, representing a change in the way the color state list is retrieved from the context. This is an example of Other statement changed (4) and Dependent API changed (5).","The change in the way the color state list is retrieved does not affect the return value or exception handling of the method. The object returned by getColorStateList is intended to provide the same functionality as what was previously returned by getResources().getColorStateList, hence no Compatibility Issue should arise from this modification. Although the dependent API has changed, this does not result in a different behavior in terms of the output of the method; therefore, there is No Compatibility Issue (0)."
559,<android.widget.TimePicker: void setIs24HourView(Boolean)>,22,23,<android.widget.TimePicker: void setIs24HourView(Boolean)>,<android.widget.TimePicker: void setIs24HourView(Boolean)>,0,"{
    mDelegate.setIs24HourView(is24HourView);
}","{
    if (is24HourView == null) {
        return;
    }
    mDelegate.setIs24HourView(is24HourView);
}",1,"/**
 * Set whether in 24 hour or AM/PM mode.
 *
 * @param is24HourView True = 24 hour mode. False = AM/PM.
 */
","/**
 * Sets whether this widget displays time in 24-hour mode or 12-hour mode
 * with an AM/PM picker.
 *
 * @param is24HourView {@code true} to display in 24-hour mode,
 * {@code false} for 12-hour mode with AM/PM
 * @see #is24HourView()
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The late version introduces a new control dependency by checking if the parameter 'is24HourView' is null, and if so, it returns early without calling mDelegate.setIs24HourView(is24HourView). So the change type is a control dependency change, which is 3.","Despite the introduction of an early return in the case that 'is24HourView' is null, it does not constitue a Compatibility Issue. In the early version, passing null would likely lead to an exception or an error further within the mDelegate.setIs24HourView method (depending on its implementation), while in the late version, it simply results in a no-op (nothing happens). The change to guard against a null input is generally considered as an enhancement to the robustness of the method and should not affect the existing code that passes a non-null reference. Therefore, there is no Compatibility Issue here, which is 0."
560,<android.net.VpnService: Intent prepare(Context)>,22,23,<android.net.VpnService: Intent prepare(Context)>,<android.net.VpnService: Intent prepare(Context)>,0,"{
    try {
        if (getService().prepareVpn(context.getPackageName(), null)) {
            return null;
        }
    } catch (RemoteException e) {
    // ignore
    }
    return VpnConfig.getIntentForConfirmation();
}","{
    try {
        if (getService().prepareVpn(context.getPackageName(), null, UserHandle.myUserId())) {
            return null;
        }
    } catch (RemoteException e) {
    // ignore
    }
    return VpnConfig.getIntentForConfirmation();
}",1,"/**
 * Prepare to establish a VPN connection. This method returns {@code null}
 * if the VPN application is already prepared or if the user has previously
 * consented to the VPN application. Otherwise, it returns an
 * {@link Intent} to a system activity. The application should launch the
 * activity using {@link Activity#startActivityForResult} to get itself
 * prepared. The activity may pop up a dialog to require user action, and
 * the result will come back via its {@link Activity#onActivityResult}.
 * If the result is {@link Activity#RESULT_OK}, the application becomes
 * prepared and is granted to use other methods in this class.
 *
 * <p>Only one application can be granted at the same time. The right
 * is revoked when another application is granted. The application
 * losing the right will be notified via its {@link #onRevoke}. Unless
 * it becomes prepared again, subsequent calls to other methods in this
 * class will fail.
 *
 * <p>The user may disable the VPN at any time while it is activated, in
 * which case this method will return an intent the next time it is
 * executed to obtain the user's consent again.
 *
 * @see #onRevoke
 */
","/**
 * Prepare to establish a VPN connection. This method returns {@code null}
 * if the VPN application is already prepared or if the user has previously
 * consented to the VPN application. Otherwise, it returns an
 * {@link Intent} to a system activity. The application should launch the
 * activity using {@link Activity#startActivityForResult} to get itself
 * prepared. The activity may pop up a dialog to require user action, and
 * the result will come back via its {@link Activity#onActivityResult}.
 * If the result is {@link Activity#RESULT_OK}, the application becomes
 * prepared and is granted to use other methods in this class.
 *
 * <p>Only one application can be granted at the same time. The right
 * is revoked when another application is granted. The application
 * losing the right will be notified via its {@link #onRevoke}. Unless
 * it becomes prepared again, subsequent calls to other methods in this
 * class will fail.
 *
 * <p>The user may disable the VPN at any time while it is activated, in
 * which case this method will return an intent the next time it is
 * executed to obtain the user's consent again.
 *
 * @see #onRevoke
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"There has been a change in a dependent API call: getService().prepareVpn(), which now includes an additional parameter UserHandle.myUserId(). Hence, the code change type is 5.","There is no CI as the try-catch block is still intact, ignoring exceptions as before, and returning a value conditionally remains the same. The additional parameter will not affect the returned intent or caught exception, just which VPN is being prepared; this does not indicate different return values or exceptions between versions."
561,"<android.widget.Editor.CursorAnchorInfoNotifier: void updatePosition(int,int,boolean,boolean)>",22,23,"<android.widget.Editor.CursorAnchorInfoNotifier: void updatePosition(int,int,boolean,boolean)>","<android.widget.Editor.CursorAnchorInfoNotifier: void updatePosition(int,int,boolean,boolean)>",0,"{
    final InputMethodState ims = mInputMethodState;
    if (ims == null || ims.mBatchEditNesting > 0) {
        return;
    }
    final InputMethodManager imm = InputMethodManager.peekInstance();
    if (null == imm) {
        return;
    }
    if (!imm.isActive(mTextView)) {
        return;
    }
    // Skip if the IME has not requested the cursor/anchor position.
    if (!imm.isCursorAnchorInfoEnabled()) {
        return;
    }
    Layout layout = mTextView.getLayout();
    if (layout == null) {
        return;
    }
    final CursorAnchorInfo.Builder builder = mSelectionInfoBuilder;
    builder.reset();
    final int selectionStart = mTextView.getSelectionStart();
    builder.setSelectionRange(selectionStart, mTextView.getSelectionEnd());
    // Construct transformation matrix from view local coordinates to screen coordinates.
    mViewToScreenMatrix.set(mTextView.getMatrix());
    mTextView.getLocationOnScreen(mTmpIntOffset);
    mViewToScreenMatrix.postTranslate(mTmpIntOffset[0], mTmpIntOffset[1]);
    builder.setMatrix(mViewToScreenMatrix);
    final float viewportToContentHorizontalOffset = mTextView.viewportToContentHorizontalOffset();
    final float viewportToContentVerticalOffset = mTextView.viewportToContentVerticalOffset();
    final CharSequence text = mTextView.getText();
    if (text instanceof Spannable) {
        final Spannable sp = (Spannable) text;
        int composingTextStart = EditableInputConnection.getComposingSpanStart(sp);
        int composingTextEnd = EditableInputConnection.getComposingSpanEnd(sp);
        if (composingTextEnd < composingTextStart) {
            final int temp = composingTextEnd;
            composingTextEnd = composingTextStart;
            composingTextStart = temp;
        }
        final boolean hasComposingText = (0 <= composingTextStart) && (composingTextStart < composingTextEnd);
        if (hasComposingText) {
            final CharSequence composingText = text.subSequence(composingTextStart, composingTextEnd);
            builder.setComposingText(composingTextStart, composingText);
            final int minLine = layout.getLineForOffset(composingTextStart);
            final int maxLine = layout.getLineForOffset(composingTextEnd - 1);
            for (int line = minLine; line <= maxLine; ++line) {
                final int lineStart = layout.getLineStart(line);
                final int lineEnd = layout.getLineEnd(line);
                final int offsetStart = Math.max(lineStart, composingTextStart);
                final int offsetEnd = Math.min(lineEnd, composingTextEnd);
                final boolean ltrLine = layout.getParagraphDirection(line) == Layout.DIR_LEFT_TO_RIGHT;
                final float[] widths = new float[offsetEnd - offsetStart];
                layout.getPaint().getTextWidths(text, offsetStart, offsetEnd, widths);
                final float top = layout.getLineTop(line);
                final float bottom = layout.getLineBottom(line);
                for (int offset = offsetStart; offset < offsetEnd; ++offset) {
                    final float charWidth = widths[offset - offsetStart];
                    final boolean isRtl = layout.isRtlCharAt(offset);
                    final float primary = layout.getPrimaryHorizontal(offset);
                    final float secondary = layout.getSecondaryHorizontal(offset);
                    // TODO: This doesn't work perfectly for text with custom styles and
                    // TAB chars.
                    final float left;
                    final float right;
                    if (ltrLine) {
                        if (isRtl) {
                            left = secondary - charWidth;
                            right = secondary;
                        } else {
                            left = primary;
                            right = primary + charWidth;
                        }
                    } else {
                        if (!isRtl) {
                            left = secondary;
                            right = secondary + charWidth;
                        } else {
                            left = primary - charWidth;
                            right = primary;
                        }
                    }
                    // TODO: Check top-right and bottom-left as well.
                    final float localLeft = left + viewportToContentHorizontalOffset;
                    final float localRight = right + viewportToContentHorizontalOffset;
                    final float localTop = top + viewportToContentVerticalOffset;
                    final float localBottom = bottom + viewportToContentVerticalOffset;
                    final boolean isTopLeftVisible = isPositionVisible(localLeft, localTop);
                    final boolean isBottomRightVisible = isPositionVisible(localRight, localBottom);
                    int characterBoundsFlags = 0;
                    if (isTopLeftVisible || isBottomRightVisible) {
                        characterBoundsFlags |= CursorAnchorInfo.FLAG_HAS_VISIBLE_REGION;
                    }
                    if (!isTopLeftVisible || !isTopLeftVisible) {
                        characterBoundsFlags |= CursorAnchorInfo.FLAG_HAS_INVISIBLE_REGION;
                    }
                    if (isRtl) {
                        characterBoundsFlags |= CursorAnchorInfo.FLAG_IS_RTL;
                    }
                    // Here offset is the index in Java chars.
                    builder.addCharacterBounds(offset, localLeft, localTop, localRight, localBottom, characterBoundsFlags);
                }
            }
        }
    }
    // Treat selectionStart as the insertion point.
    if (0 <= selectionStart) {
        final int offset = selectionStart;
        final int line = layout.getLineForOffset(offset);
        final float insertionMarkerX = layout.getPrimaryHorizontal(offset) + viewportToContentHorizontalOffset;
        final float insertionMarkerTop = layout.getLineTop(line) + viewportToContentVerticalOffset;
        final float insertionMarkerBaseline = layout.getLineBaseline(line) + viewportToContentVerticalOffset;
        final float insertionMarkerBottom = layout.getLineBottom(line) + viewportToContentVerticalOffset;
        final boolean isTopVisible = isPositionVisible(insertionMarkerX, insertionMarkerTop);
        final boolean isBottomVisible = isPositionVisible(insertionMarkerX, insertionMarkerBottom);
        int insertionMarkerFlags = 0;
        if (isTopVisible || isBottomVisible) {
            insertionMarkerFlags |= CursorAnchorInfo.FLAG_HAS_VISIBLE_REGION;
        }
        if (!isTopVisible || !isBottomVisible) {
            insertionMarkerFlags |= CursorAnchorInfo.FLAG_HAS_INVISIBLE_REGION;
        }
        if (layout.isRtlCharAt(offset)) {
            insertionMarkerFlags |= CursorAnchorInfo.FLAG_IS_RTL;
        }
        builder.setInsertionMarkerLocation(insertionMarkerX, insertionMarkerTop, insertionMarkerBaseline, insertionMarkerBottom, insertionMarkerFlags);
    }
    imm.updateCursorAnchorInfo(mTextView, builder.build());
}","{
    final InputMethodState ims = mInputMethodState;
    if (ims == null || ims.mBatchEditNesting > 0) {
        return;
    }
    final InputMethodManager imm = InputMethodManager.peekInstance();
    if (null == imm) {
        return;
    }
    if (!imm.isActive(mTextView)) {
        return;
    }
    // Skip if the IME has not requested the cursor/anchor position.
    if (!imm.isCursorAnchorInfoEnabled()) {
        return;
    }
    Layout layout = mTextView.getLayout();
    if (layout == null) {
        return;
    }
    final CursorAnchorInfo.Builder builder = mSelectionInfoBuilder;
    builder.reset();
    final int selectionStart = mTextView.getSelectionStart();
    builder.setSelectionRange(selectionStart, mTextView.getSelectionEnd());
    // Construct transformation matrix from view local coordinates to screen coordinates.
    mViewToScreenMatrix.set(mTextView.getMatrix());
    mTextView.getLocationOnScreen(mTmpIntOffset);
    mViewToScreenMatrix.postTranslate(mTmpIntOffset[0], mTmpIntOffset[1]);
    builder.setMatrix(mViewToScreenMatrix);
    final float viewportToContentHorizontalOffset = mTextView.viewportToContentHorizontalOffset();
    final float viewportToContentVerticalOffset = mTextView.viewportToContentVerticalOffset();
    final CharSequence text = mTextView.getText();
    if (text instanceof Spannable) {
        final Spannable sp = (Spannable) text;
        int composingTextStart = EditableInputConnection.getComposingSpanStart(sp);
        int composingTextEnd = EditableInputConnection.getComposingSpanEnd(sp);
        if (composingTextEnd < composingTextStart) {
            final int temp = composingTextEnd;
            composingTextEnd = composingTextStart;
            composingTextStart = temp;
        }
        final boolean hasComposingText = (0 <= composingTextStart) && (composingTextStart < composingTextEnd);
        if (hasComposingText) {
            final CharSequence composingText = text.subSequence(composingTextStart, composingTextEnd);
            builder.setComposingText(composingTextStart, composingText);
            final int minLine = layout.getLineForOffset(composingTextStart);
            final int maxLine = layout.getLineForOffset(composingTextEnd - 1);
            for (int line = minLine; line <= maxLine; ++line) {
                final int lineStart = layout.getLineStart(line);
                final int lineEnd = layout.getLineEnd(line);
                final int offsetStart = Math.max(lineStart, composingTextStart);
                final int offsetEnd = Math.min(lineEnd, composingTextEnd);
                final boolean ltrLine = layout.getParagraphDirection(line) == Layout.DIR_LEFT_TO_RIGHT;
                final float[] widths = new float[offsetEnd - offsetStart];
                layout.getPaint().getTextWidths(text, offsetStart, offsetEnd, widths);
                final float top = layout.getLineTop(line);
                final float bottom = layout.getLineBottom(line);
                for (int offset = offsetStart; offset < offsetEnd; ++offset) {
                    final float charWidth = widths[offset - offsetStart];
                    final boolean isRtl = layout.isRtlCharAt(offset);
                    final float primary = layout.getPrimaryHorizontal(offset);
                    final float secondary = layout.getSecondaryHorizontal(offset);
                    // TODO: This doesn't work perfectly for text with custom styles and
                    // TAB chars.
                    final float left;
                    final float right;
                    if (ltrLine) {
                        if (isRtl) {
                            left = secondary - charWidth;
                            right = secondary;
                        } else {
                            left = primary;
                            right = primary + charWidth;
                        }
                    } else {
                        if (!isRtl) {
                            left = secondary;
                            right = secondary + charWidth;
                        } else {
                            left = primary - charWidth;
                            right = primary;
                        }
                    }
                    // TODO: Check top-right and bottom-left as well.
                    final float localLeft = left + viewportToContentHorizontalOffset;
                    final float localRight = right + viewportToContentHorizontalOffset;
                    final float localTop = top + viewportToContentVerticalOffset;
                    final float localBottom = bottom + viewportToContentVerticalOffset;
                    final boolean isTopLeftVisible = isPositionVisible(localLeft, localTop);
                    final boolean isBottomRightVisible = isPositionVisible(localRight, localBottom);
                    int characterBoundsFlags = 0;
                    if (isTopLeftVisible || isBottomRightVisible) {
                        characterBoundsFlags |= CursorAnchorInfo.FLAG_HAS_VISIBLE_REGION;
                    }
                    if (!isTopLeftVisible || !isBottomRightVisible) {
                        characterBoundsFlags |= CursorAnchorInfo.FLAG_HAS_INVISIBLE_REGION;
                    }
                    if (isRtl) {
                        characterBoundsFlags |= CursorAnchorInfo.FLAG_IS_RTL;
                    }
                    // Here offset is the index in Java chars.
                    builder.addCharacterBounds(offset, localLeft, localTop, localRight, localBottom, characterBoundsFlags);
                }
            }
        }
    }
    // Treat selectionStart as the insertion point.
    if (0 <= selectionStart) {
        final int offset = selectionStart;
        final int line = layout.getLineForOffset(offset);
        final float insertionMarkerX = layout.getPrimaryHorizontal(offset) + viewportToContentHorizontalOffset;
        final float insertionMarkerTop = layout.getLineTop(line) + viewportToContentVerticalOffset;
        final float insertionMarkerBaseline = layout.getLineBaseline(line) + viewportToContentVerticalOffset;
        final float insertionMarkerBottom = layout.getLineBottom(line) + viewportToContentVerticalOffset;
        final boolean isTopVisible = isPositionVisible(insertionMarkerX, insertionMarkerTop);
        final boolean isBottomVisible = isPositionVisible(insertionMarkerX, insertionMarkerBottom);
        int insertionMarkerFlags = 0;
        if (isTopVisible || isBottomVisible) {
            insertionMarkerFlags |= CursorAnchorInfo.FLAG_HAS_VISIBLE_REGION;
        }
        if (!isTopVisible || !isBottomVisible) {
            insertionMarkerFlags |= CursorAnchorInfo.FLAG_HAS_INVISIBLE_REGION;
        }
        if (layout.isRtlCharAt(offset)) {
            insertionMarkerFlags |= CursorAnchorInfo.FLAG_IS_RTL;
        }
        builder.setInsertionMarkerLocation(insertionMarkerX, insertionMarkerTop, insertionMarkerBaseline, insertionMarkerBottom, insertionMarkerFlags);
    }
    imm.updateCursorAnchorInfo(mTextView, builder.build());
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
562,"<android.content.res.ColorStateList: int getColorForState(int[],int)>",22,23,"<android.content.res.ColorStateList: int getColorForState(int[],int)>","<android.content.res.ColorStateList: int getColorForState(int[],int)>",0,"{
    final int setLength = mStateSpecs.length;
    for (int i = 0; i < setLength; i++) {
        int[] stateSpec = mStateSpecs[i];
        if (StateSet.stateSetMatches(stateSpec, stateSet)) {
            return mColors[i];
        }
    }
    return defaultColor;
}","{
    final int setLength = mStateSpecs.length;
    for (int i = 0; i < setLength; i++) {
        final int[] stateSpec = mStateSpecs[i];
        if (StateSet.stateSetMatches(stateSpec, stateSet)) {
            return mColors[i];
        }
    }
    return defaultColor;
}",1,"/**
 * Return the color associated with the given set of {@link android.view.View} states.
 *
 * @param stateSet an array of {@link android.view.View} states
 * @param defaultColor the color to return if there's not state spec in this
 * {@link ColorStateList} that matches the stateSet.
 *
 * @return the color associated with that set of states in this {@link ColorStateList}.
 */
","/**
 * Return the color associated with the given set of
 * {@link android.view.View} states.
 *
 * @param stateSet an array of {@link android.view.View} states
 * @param defaultColor the color to return if there's no matching state
 * spec in this {@link ColorStateList} that matches the
 * stateSet.
 *
 * @return the color associated with that set of states in this {@link ColorStateList}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"There is no actual change in the behavior of the code between the versions, the modification is simply adding the 'final' keyword to the variable 'stateSpec', which doesn't affect the API's contract or behavior. It is only a change in local variable declaration.",There is no Compatibility Issue because the change does not affect the output of the method or how it operates.
564,"<android.app.WallpaperManager.Globals: Bitmap peekWallpaperBitmap(Context,boolean)>",22,23,"<android.app.WallpaperManager.Globals: Bitmap peekWallpaperBitmap(Context,boolean)>","<android.app.WallpaperManager.Globals: Bitmap peekWallpaperBitmap(Context,boolean)>",0,"{
    synchronized (this) {
        if (mWallpaper != null) {
            return mWallpaper;
        }
        if (mDefaultWallpaper != null) {
            return mDefaultWallpaper;
        }
        mWallpaper = null;
        try {
            mWallpaper = getCurrentWallpaperLocked(context);
        } catch (OutOfMemoryError e) {
            Log.w(TAG, ""No memory load current wallpaper"", e);
        }
        if (returnDefault) {
            if (mWallpaper == null) {
                mDefaultWallpaper = getDefaultWallpaperLocked(context);
                return mDefaultWallpaper;
            } else {
                mDefaultWallpaper = null;
            }
        }
        return mWallpaper;
    }
}","{
    synchronized (this) {
        if (mService != null) {
            try {
                if (!mService.isWallpaperSupported(context.getOpPackageName())) {
                    return null;
                }
            } catch (RemoteException e) {
            // Ignore
            }
        }
        if (mWallpaper != null) {
            return mWallpaper;
        }
        if (mDefaultWallpaper != null) {
            return mDefaultWallpaper;
        }
        mWallpaper = null;
        try {
            mWallpaper = getCurrentWallpaperLocked(context);
        } catch (OutOfMemoryError e) {
            Log.w(TAG, ""No memory load current wallpaper"", e);
        }
        if (returnDefault) {
            if (mWallpaper == null) {
                mDefaultWallpaper = getDefaultWallpaperLocked(context);
                return mDefaultWallpaper;
            } else {
                mDefaultWallpaper = null;
            }
        }
        return mWallpaper;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3","1,2","The addition of a new condition checking if wallpaper is supported (if (!mService.isWallpaperSupported(context.getOpPackageName())) {}) and the possibility to return null based on this condition before the previous logic are new control dependency changes(type 3). Since it's a new return statement, it's also a type 1 change.","The new condition to check if wallpaper is supported can potentially return a different value and the possibility of the `return null;` statement may lead to a different return value (type 1). Additionally, the added catch for RemoteException, even though not rethrowing an exception, is an added layer of exception handling behavior (type 2), catching a possible RemoteException that wasn't previously caught, therefore causing a potential CI due to different exception handling."
565,<android.widget.Editor.HandleView: void show()>,22,23,<android.widget.Editor.HandleView: void show()>,<android.widget.Editor.HandleView: void show()>,0,"{
    if (isShowing())
        return;
    getPositionListener().addSubscriber(this, true);
    // Make sure the offset is always considered new, even when focusing at same position
    mPreviousOffset = -1;
    positionAtCursorOffset(getCurrentCursorOffset(), false);
    hideActionPopupWindow();
}","{
    if (isShowing())
        return;
    getPositionListener().addSubscriber(this, true);
    // Make sure the offset is always considered new, even when focusing at same position
    mPreviousOffset = -1;
    positionAtCursorOffset(getCurrentCursorOffset(), false);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The late version of the code has removed the call to hideActionPopupWindow(); hence, the change type is 4.","Since the removed statement does not affect the return value or exception handling of the method; thus, it does not introduce a compatibility issue, so the CI type is 0."
567,"<android.widget.Spinner: int measureContentWidth(SpinnerAdapter,Drawable)>",22,23,"<android.widget.Spinner: int measureContentWidth(SpinnerAdapter,Drawable)>","<android.widget.Spinner: int measureContentWidth(SpinnerAdapter,Drawable)>",0,"{
    if (adapter == null) {
        return 0;
    }
    int width = 0;
    View itemView = null;
    int itemType = 0;
    final int widthMeasureSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);
    final int heightMeasureSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);
    // Make sure the number of items we'll measure is capped. If it's a huge data set
    // with wildly varying sizes, oh well.
    int start = Math.max(0, getSelectedItemPosition());
    final int end = Math.min(adapter.getCount(), start + MAX_ITEMS_MEASURED);
    final int count = end - start;
    start = Math.max(0, start - (MAX_ITEMS_MEASURED - count));
    for (int i = start; i < end; i++) {
        final int positionType = adapter.getItemViewType(i);
        if (positionType != itemType) {
            itemType = positionType;
            itemView = null;
        }
        itemView = adapter.getView(i, itemView, this);
        if (itemView.getLayoutParams() == null) {
            itemView.setLayoutParams(new ViewGroup.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT));
        }
        itemView.measure(widthMeasureSpec, heightMeasureSpec);
        width = Math.max(width, itemView.getMeasuredWidth());
    }
    // Add background padding to measured width
    if (background != null) {
        background.getPadding(mTempRect);
        width += mTempRect.left + mTempRect.right;
    }
    return width;
}","{
    if (adapter == null) {
        return 0;
    }
    int width = 0;
    View itemView = null;
    int itemType = 0;
    final int widthMeasureSpec = MeasureSpec.makeSafeMeasureSpec(getMeasuredWidth(), MeasureSpec.UNSPECIFIED);
    final int heightMeasureSpec = MeasureSpec.makeSafeMeasureSpec(getMeasuredHeight(), MeasureSpec.UNSPECIFIED);
    // Make sure the number of items we'll measure is capped. If it's a huge data set
    // with wildly varying sizes, oh well.
    int start = Math.max(0, getSelectedItemPosition());
    final int end = Math.min(adapter.getCount(), start + MAX_ITEMS_MEASURED);
    final int count = end - start;
    start = Math.max(0, start - (MAX_ITEMS_MEASURED - count));
    for (int i = start; i < end; i++) {
        final int positionType = adapter.getItemViewType(i);
        if (positionType != itemType) {
            itemType = positionType;
            itemView = null;
        }
        itemView = adapter.getView(i, itemView, this);
        if (itemView.getLayoutParams() == null) {
            itemView.setLayoutParams(new ViewGroup.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT));
        }
        itemView.measure(widthMeasureSpec, heightMeasureSpec);
        width = Math.max(width, itemView.getMeasuredWidth());
    }
    // Add background padding to measured width
    if (background != null) {
        background.getPadding(mTempRect);
        width += mTempRect.left + mTempRect.right;
    }
    return width;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"There are two other statement changes observed in the late implementation. The measure specifications for width and height `MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED)` were updated to `MeasureSpec.makeSafeMeasureSpec(getMeasuredWidth(), MeasureSpec.UNSPECIFIED)` and `MeasureSpec.makeSafeMeasureSpec(getMeasuredHeight(), MeasureSpec.UNSPECIFIED)` respectively. Additionally, there's a change in statements that are not related to control dependency, return, exception handling, or dependent APIs.","The method 'makeSafeMeasureSpec' presumably takes into account additional considerations that could potentially allow it to return different measure specifications compared to 'makeMeasureSpec', which could lead to a difference in the calculated 'width' that is being returned. Therefore, these changes may alter the behavior of the `measureContentWidth` method between the versions, causing the potential return of different values. The CI type is 1."
570,<android.content.res.TypedArray: ColorStateList getColorStateList(int)>,22,23,<android.content.res.TypedArray: ColorStateList getColorStateList(int)>,<android.content.res.TypedArray: ColorStateList getColorStateList(int)>,0,"{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    final TypedValue value = mValue;
    if (getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, value)) {
        if (value.type == TypedValue.TYPE_ATTRIBUTE) {
            throw new RuntimeException(""Failed to resolve attribute at index "" + index);
        }
        return mResources.loadColorStateList(value, value.resourceId);
    }
    return null;
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    final TypedValue value = mValue;
    if (getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, value)) {
        if (value.type == TypedValue.TYPE_ATTRIBUTE) {
            throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + index + "": "" + value);
        }
        return mResources.loadColorStateList(value, value.resourceId, mTheme);
    }
    return null;
}",1,"/**
 * Retrieve the ColorStateList for the attribute at <var>index</var>.
 * The value may be either a single solid color or a reference to
 * a color or complex {@link android.content.res.ColorStateList} description.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return ColorStateList for the attribute, or null if not defined.
 */
","/**
 * Retrieve the ColorStateList for the attribute at <var>index</var>.
 * The value may be either a single solid color or a reference to
 * a color or complex {@link android.content.res.ColorStateList}
 * description.
 * <p>
 * This method will return {@code null} if the attribute is not defined or
 * is not an integer color or color state list.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return ColorStateList for the attribute, or {@code null} if not
 * defined.
 * @throws RuntimeException if the attribute if the TypedArray has already
 * been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not an integer color or color state list.
 */
",-1,,[@Nullable],-1,-1,-1,-1,-1,-1,"1,2,5","1,2","The exception thrown for a TYPE_ATTRIBUTE value type has changed from RuntimeException to UnsupportedOperationException. There is also an additional parameter 'mTheme' added to the method mResources.loadColorStateList(). Hence, the code change type is 1,2,5.","The change from RuntimeException to UnsupportedOperationException when encountering a TypedValue of TYPE_ATTRIBUTE means the method will potentially throw a different exception, which indicates a CI of type 2. Additionally, the addition of 'mTheme' as a parameter in the dependent API mResources.loadColorStateList() could lead to the method returning a different ColorStateList, indicating a CI of type 1."
572,<android.content.pm.ResolveInfo: Drawable loadIcon(PackageManager)>,22,23,<android.content.pm.ResolveInfo: Drawable loadIcon(PackageManager)>,<android.content.pm.ResolveInfo: Drawable loadIcon(PackageManager)>,0,"{
    Drawable dr;
    if (resolvePackageName != null && icon != 0) {
        dr = pm.getDrawable(resolvePackageName, icon, null);
        if (dr != null) {
            return dr;
        }
    }
    ComponentInfo ci = getComponentInfo();
    ApplicationInfo ai = ci.applicationInfo;
    if (icon != 0) {
        dr = pm.getDrawable(ci.packageName, icon, ai);
        if (dr != null) {
            return dr;
        }
    }
    return ci.loadIcon(pm);
}","{
    Drawable dr = null;
    if (resolvePackageName != null && iconResourceId != 0) {
        dr = pm.getDrawable(resolvePackageName, iconResourceId, null);
    }
    ComponentInfo ci = getComponentInfo();
    if (dr == null && iconResourceId != 0) {
        ApplicationInfo ai = ci.applicationInfo;
        dr = pm.getDrawable(ci.packageName, iconResourceId, ai);
    }
    if (dr != null) {
        return pm.getUserBadgedIcon(dr, new UserHandle(UserHandle.myUserId()));
    }
    return ci.loadIcon(pm);
}",1,"/**
 * Retrieve the current graphical icon associated with this resolution.  This
 * will call back on the given PackageManager to load the icon from
 * the application.
 *
 * @param pm A PackageManager from which the icon can be loaded; usually
 * the PackageManager from which you originally retrieved this item.
 *
 * @return Returns a Drawable containing the resolution's icon.  If the
 * item does not have an icon, the default activity icon is returned.
 */
","/**
 * Retrieve the current graphical icon associated with this resolution.  This
 * will call back on the given PackageManager to load the icon from
 * the application.
 *
 * @param pm A PackageManager from which the icon can be loaded; usually
 * the PackageManager from which you originally retrieved this item.
 *
 * @return Returns a Drawable containing the resolution's icon.  If the
 * item does not have an icon, the default activity icon is returned.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,The code has multiple changes: ,- An additional call to 'pm.getUserBadgedIcon()' modifies the drawable before returning it.
574,"<android.util.Log: int wtf(int,String,String,Throwable,boolean,boolean)>",22,23,"<android.util.Log: int wtf(int,String,String,Throwable,boolean,boolean)>","<android.util.Log: int wtf(int,String,String,Throwable,boolean,boolean)>",0,"{
    TerribleFailure what = new TerribleFailure(msg, tr);
    int bytes = println_native(logId, ASSERT, tag, msg + '\n' + getStackTraceString(localStack ? what : tr));
    sWtfHandler.onTerribleFailure(tag, what, system);
    return bytes;
}","{
    TerribleFailure what = new TerribleFailure(msg, tr);
    // Only mark this as ERROR, do not use ASSERT since that should be
    // reserved for cases where the system is guaranteed to abort.
    // The onTerribleFailure call does not always cause a crash.
    int bytes = println_native(logId, ERROR, tag, msg + '\n' + getStackTraceString(localStack ? what : tr));
    sWtfHandler.onTerribleFailure(tag, what, system);
    return bytes;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The parameter for the log level in the call to println_native() has changed from ASSERT to ERROR, which is a change in the log severity level, and the implementation contains a new comment, which is also an 'Other statement changed', so the code change type is 1,4.","Since the log level has changed from ASSERT to ERROR, the behavior of the API could be different because the output of the logging will be different. For example, different log levels can be handled differently by the system or any processes that are monitoring logs, leading to different responses. As such, changing the log level could be perceived as changing the return value from a behavioral perspective because the logging behavior constitutes part of the method's return value. This would qualify as a CI type 1."
575,<android.app.LoaderManagerImpl: String toString()>,22,23,<android.app.LoaderManagerImpl: String toString()>,<android.app.LoaderManagerImpl: String toString()>,0,"{
    StringBuilder sb = new StringBuilder(128);
    sb.append(""LoaderManager{"");
    sb.append(Integer.toHexString(System.identityHashCode(this)));
    sb.append("" in "");
    DebugUtils.buildShortClassTag(mActivity, sb);
    sb.append(""}}"");
    return sb.toString();
}","{
    StringBuilder sb = new StringBuilder(128);
    sb.append(""LoaderManager{"");
    sb.append(Integer.toHexString(System.identityHashCode(this)));
    sb.append("" in "");
    DebugUtils.buildShortClassTag(mHost, sb);
    sb.append(""}}"");
    return sb.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The change in the code is the argument passed to the function `DebugUtils.buildShortClassTag`, it changed from `mActivity` to `mHost`. There might be an update in the internal representation from an activity to a more generalized host concept. Since this is a change to a value that gets built into a string, and it doesn't affect the control flow or exception handling, the change type is 4 (Other statement changed).","There will be no Compatibility Issue as a result of this change — the method will still return a string representation of the object. The output will contain a different class tag, but this won't cause any behavior changes in terms of return values or exception handling. It is an internal detail of the string representation. The CI type is 0 (No Compatibility Issue)."
576,<android.bluetooth.BluetoothDevice: ParcelUuid[] getUuids()>,22,23,<android.bluetooth.BluetoothDevice: ParcelUuid[] getUuids()>,<android.bluetooth.BluetoothDevice: ParcelUuid[] getUuids()>,0,"{
    if (sService == null) {
        Log.e(TAG, ""BT not enabled. Cannot get remote device Uuids"");
        return null;
    }
    try {
        return sService.getRemoteUuids(this);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return null;
}","{
    if (sService == null || isBluetoothEnabled() == false) {
        Log.e(TAG, ""BT not enabled. Cannot get remote device Uuids"");
        return null;
    }
    try {
        return sService.getRemoteUuids(this);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return null;
}",1,"/**
 * Returns the supported features (UUIDs) of the remote device.
 *
 * <p>This method does not start a service discovery procedure to retrieve the UUIDs
 * from the remote device. Instead, the local cached copy of the service
 * UUIDs are returned.
 * <p>Use {@link #fetchUuidsWithSdp} if fresh UUIDs are desired.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}.
 *
 * @return the supported features (UUIDs) of the remote device,
 * or null on error
 */
","/**
 * Returns the supported features (UUIDs) of the remote device.
 *
 * <p>This method does not start a service discovery procedure to retrieve the UUIDs
 * from the remote device. Instead, the local cached copy of the service
 * UUIDs are returned.
 * <p>Use {@link #fetchUuidsWithSdp} if fresh UUIDs are desired.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}.
 *
 * @return the supported features (UUIDs) of the remote device,
 * or null on error
 */
",-1,,[@RequiresPermission(Manifest.permission.BLUETOOTH)],-1,-1,-1,-1,-1,-1,3,0,"There's an added condition in the if statement that checks if the bluetooth is enabled with `isBluetoothEnabled() == false`. This is a control dependency change, so the code change type is 3.","However, this additional check does not introduce a compatibility issue since the method already returned `null` if `sService` was `null`. The behavior when bluetooth is not enabled (either `sService` is `null` or `isBluetoothEnabled() == false`) is the same: the method returns `null`. Therefore, there is no Compatibility Issue here."
577,"<android.app.admin.DevicePolicyManager: void setPasswordMinimumLetters(ComponentName,int)>",22,23,"<android.app.admin.DevicePolicyManager: void setPasswordMinimumLetters(ComponentName,int)>","<android.app.admin.DevicePolicyManager: void setPasswordMinimumLetters(ComponentName,int)>",0,"{
    if (mService != null) {
        try {
            mService.setPasswordMinimumLetters(admin, length, UserHandle.myUserId());
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    if (mService != null) {
        try {
            mService.setPasswordMinimumLetters(admin, length);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}",1,"/**
 * Called by an application that is administering the device to set the
 * minimum number of letters required in the password. After setting this,
 * the user will not be able to enter a new password that is not at least as
 * restrictive as what has been set. Note that the current password will
 * remain until the user has set a new one, so the change does not take
 * place immediately. To prompt the user for a new password, use
 * {@link #ACTION_SET_NEW_PASSWORD} after setting this value. This
 * constraint is only imposed if the administrator has also requested
 * {@link #PASSWORD_QUALITY_COMPLEX} with {@link #setPasswordQuality}. The
 * default value is 1.
 * <p>
 * The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call
 * this method; if it has not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated
 * with.
 * @param length The new desired minimum number of letters required in the
 * password. A value of 0 means there is no restriction.
 */
","/**
 * Called by an application that is administering the device to set the
 * minimum number of letters required in the password. After setting this,
 * the user will not be able to enter a new password that is not at least as
 * restrictive as what has been set. Note that the current password will
 * remain until the user has set a new one, so the change does not take
 * place immediately. To prompt the user for a new password, use
 * {@link #ACTION_SET_NEW_PASSWORD} after setting this value. This
 * constraint is only imposed if the administrator has also requested
 * {@link #PASSWORD_QUALITY_COMPLEX} with {@link #setPasswordQuality}. The
 * default value is 1.
 * <p>
 * The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call
 * this method; if it has not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated
 * with.
 * @param length The new desired minimum number of letters required in the
 * password. A value of 0 means there is no restriction.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method setPasswordMinimumLetters of the mService object has been called with a different number of parameters, so the code change type is 5.","There is no new return statement, nor a deletion of an old one, and the exception handling remains the same. Hence, there is no Compatibility Issue as per the given definitions, thus the CI type is 0."
578,"<android.app.SearchManager: void triggerSearch(String,ComponentName,Bundle)>",22,23,"<android.app.SearchManager: void triggerSearch(String,ComponentName,Bundle)>","<android.app.SearchManager: void triggerSearch(String,ComponentName,Bundle)>",0,"{
    if (!mAssociatedPackage.equals(launchActivity.getPackageName())) {
        throw new IllegalArgumentException(""invoking app search on a different package "" + ""not associated with this search manager"");
    }
    if (query == null || TextUtils.getTrimmedLength(query) == 0) {
        Log.w(TAG, ""triggerSearch called with empty query, ignoring."");
        return;
    }
    startSearch(query, false, launchActivity, appSearchData, false);
    mSearchDialog.launchQuerySearch();
}","{
    if (query == null || TextUtils.getTrimmedLength(query) == 0) {
        Log.w(TAG, ""triggerSearch called with empty query, ignoring."");
        return;
    }
    startSearch(query, false, launchActivity, appSearchData, false);
    mSearchDialog.launchQuerySearch();
}",1,"/**
 * Similar to {@link #startSearch} but actually fires off the search query after invoking
 * the search dialog.  Made available for testing purposes.
 *
 * @param query The query to trigger.  If empty, request will be ignored.
 * @param launchActivity The ComponentName of the activity that has launched this search.
 * @param appSearchData An application can insert application-specific
 * context here, in order to improve quality or specificity of its own
 * searches.  This data will be returned with SEARCH intent(s).  Null if
 * no extra data is required.
 *
 * @see #startSearch
 */
","/**
 * Similar to {@link #startSearch} but actually fires off the search query after invoking
 * the search dialog.  Made available for testing purposes.
 *
 * @param query The query to trigger.  If empty, request will be ignored.
 * @param launchActivity The ComponentName of the activity that has launched this search.
 * @param appSearchData An application can insert application-specific
 * context here, in order to improve quality or specificity of its own
 * searches.  This data will be returned with SEARCH intent(s).  Null if
 * no extra data is required.
 *
 * @see #startSearch
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The early version has a condition checking the package name and throws an IllegalArgumentException if the package names do not match. This condition and the associated exception throwing has been removed in the late version, hence the code change type is 2.","The removal of the IllegalArgumentException in the late version means that the late version will not throw an exception where the early version might have, thus potentially leading to a different exception handling and causing the CI to be type 2."
579,"<android.app.admin.DevicePolicyManager: void setCameraDisabled(ComponentName,boolean)>",22,23,"<android.app.admin.DevicePolicyManager: void setCameraDisabled(ComponentName,boolean)>","<android.app.admin.DevicePolicyManager: void setCameraDisabled(ComponentName,boolean)>",0,"{
    if (mService != null) {
        try {
            mService.setCameraDisabled(admin, disabled, UserHandle.myUserId());
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    if (mService != null) {
        try {
            mService.setCameraDisabled(admin, disabled);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}",1,"/**
 * Called by an application that is administering the device to disable all cameras
 * on the device, for this user. After setting this, no applications running as this user
 * will be able to access any cameras on the device.
 *
 * <p>The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_DISABLE_CAMERA} to be able to call
 * this method; if it has not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param disabled Whether or not the camera should be disabled.
 */
","/**
 * Called by an application that is administering the device to disable all cameras
 * on the device, for this user. After setting this, no applications running as this user
 * will be able to access any cameras on the device.
 *
 * <p>The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_DISABLE_CAMERA} to be able to call
 * this method; if it has not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param disabled Whether or not the camera should be disabled.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method signature of mService.setCameraDisabled() is changed by removing the third parameter UserHandle.myUserId(), which is a dependent API alteration. Therefore, the code change type is 1,5 because the dependent API changed and the code related to how the method is invoked has changed as well.","The removal of the UserHandle.myUserId() parameter in the method call potentially alters the behavior of the method. Where before the method was called with the current user's ID, now it is not specified, which could potentially lead to a different behavior, especially in a multi-user environment. Hence, the CI type is 1, because this change could result in different return values or types."
580,<android.content.ContentProviderClient: String getType(Uri)>,22,23,<android.content.ContentProviderClient: String getType(Uri)>,<android.content.ContentProviderClient: String getType(Uri)>,0,"{
    beforeRemote();
    try {
        return mContentProvider.getType(url);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}","{
    Preconditions.checkNotNull(url, ""url"");
    beforeRemote();
    try {
        return mContentProvider.getType(url);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}",1,"/**
 * See {@link ContentProvider#getType ContentProvider.getType}
 */
","/**
 * See {@link ContentProvider#getType ContentProvider.getType}
 */
",-1,,[@Nullable],-1,-1,-1,-1,-1,-1,4,0,"The code change is the addition of a new precondition check before the rest of the code executes, so the code change type is 4.","The precondition check might throw a NullPointerException if the argument 'url' is null, which would have happened anyway when the 'url' is used inside the method. Thus, the exception type has not changed from the previous version, and it would not be considered a Compatibility Issue. Therefore, the CI type is 0."
583,<android.text.style.StrikethroughSpan: int getSpanTypeId()>,22,23,<android.text.style.StrikethroughSpan: int getSpanTypeId()>,<android.text.style.StrikethroughSpan: int getSpanTypeId()>,0,"{
    return TextUtils.STRIKETHROUGH_SPAN;
}","{
    return getSpanTypeIdInternal();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,5,1,"The return statement now returns the result of a different method (getSpanTypeIdInternal() rather than directly returning TextUtils.STRIKETHROUGH_SPAN), so the code change type is 5.","Since the method being returned has changed, the API potentially returns a different value in the late version. The change in the return source indicates a potential for different return types or values, thus the CI type is 1."
584,"<android.app.ContextImpl: void sendStickyOrderedBroadcastAsUser(Intent,UserHandle,BroadcastReceiver,Handler,int,String,Bundle)>",22,23,"<android.app.ContextImpl: void sendStickyOrderedBroadcastAsUser(Intent,UserHandle,BroadcastReceiver,Handler,int,String,Bundle)>","<android.app.ContextImpl: void sendStickyOrderedBroadcastAsUser(Intent,UserHandle,BroadcastReceiver,Handler,int,String,Bundle)>",0,"{
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess();
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, rd, initialCode, initialData, initialExtras, null, AppOpsManager.OP_NONE, true, true, user.getIdentifier());
    } catch (RemoteException e) {
    }
}","{
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess();
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, rd, initialCode, initialData, initialExtras, null, AppOpsManager.OP_NONE, null, true, true, user.getIdentifier());
    } catch (RemoteException e) {
        throw new RuntimeException(""Failure from system"", e);
    }
}",1,,,-1,[@Override],"[@Override, @Deprecated]",-1,-1,-1,-1,-1,-1,"2,4",2,"The RemoteException is no longer swallowed silently; instead, it now throws a new RuntimeException. Another change is made to the parameter list of the ActivityManagerNative.getDefault().broadcastIntent(), where a 'null' argument replaces the 'true' argument. This is treated as an ""Other statement changed"" because it affects the call to the broadcastIntent() method but is not strictly related to the return statement or control dependency.","Since there is a new RuntimeException being thrown in case of a RemoteException and 'null' is provided as an argument instead of 'true', these changes could lead to different behavior in the way exceptions are handled. This indicates a potential change in the exception flow of the method, and thus causes a compatibility issue of type 2."
585,<android.text.style.BulletSpan: int getSpanTypeId()>,22,23,<android.text.style.BulletSpan: int getSpanTypeId()>,<android.text.style.BulletSpan: int getSpanTypeId()>,0,"{
    return TextUtils.BULLET_SPAN;
}","{
    return getSpanTypeIdInternal();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,5,1,"The `getSpanTypeId()` method was changed to return the result of a different method, `getSpanTypeIdInternal()`, instead of directly returning a constant `TextUtils.BULLET_SPAN`. This is a change in the dependent API, so the code change type is 5.","This change alters the returned value of the `getSpanTypeId()` method, potentially returning a different integer value if `getSpanTypeIdInternal()` does not return `TextUtils.BULLET_SPAN`. Consequently, the CI type is 1."
587,"<android.transition.Visibility: Animator onAppear(ViewGroup,TransitionValues,int,TransitionValues,int)>",22,23,"<android.transition.Visibility: Animator onAppear(ViewGroup,TransitionValues,int,TransitionValues,int)>","<android.transition.Visibility: Animator onAppear(ViewGroup,TransitionValues,int,TransitionValues,int)>",0,"{
    if ((mMode & MODE_IN) != MODE_IN || endValues == null) {
        return null;
    }
    if (startValues == null) {
        VisibilityInfo parentVisibilityInfo = null;
        View endParent = (View) endValues.view.getParent();
        TransitionValues startParentValues = getMatchedTransitionValues(endParent, false);
        TransitionValues endParentValues = getTransitionValues(endParent, false);
        parentVisibilityInfo = getVisibilityChangeInfo(startParentValues, endParentValues);
        if (parentVisibilityInfo.visibilityChange) {
            return null;
        }
    }
    return onAppear(sceneRoot, endValues.view, startValues, endValues);
}","{
    if ((mMode & MODE_IN) != MODE_IN || endValues == null) {
        return null;
    }
    if (startValues == null) {
        VisibilityInfo parentVisibilityInfo = null;
        View endParent = (View) endValues.view.getParent();
        TransitionValues startParentValues = getMatchedTransitionValues(endParent, false);
        TransitionValues endParentValues = getTransitionValues(endParent, false);
        parentVisibilityInfo = getVisibilityChangeInfo(startParentValues, endParentValues);
        if (parentVisibilityInfo.visibilityChange) {
            return null;
        }
    }
    final boolean isForcedVisibility = mForcedStartVisibility != -1 || mForcedEndVisibility != -1;
    if (isForcedVisibility) {
        // Make sure that we reverse the effect of onDisappear's setTransitionAlpha(0)
        endValues.view.setTransitionAlpha(1);
    }
    return onAppear(sceneRoot, endValues.view, startValues, endValues);
}",1,"/**
 * The default implementation of this method calls
 * {@link #onAppear(ViewGroup, View, TransitionValues, TransitionValues)}.
 * Subclasses should override this method or
 * {@link #onAppear(ViewGroup, View, TransitionValues, TransitionValues)}.
 * if they need to create an Animator when targets appear.
 * The method should only be called by the Visibility class; it is
 * not intended to be called from external classes.
 *
 * @param sceneRoot The root of the transition hierarchy
 * @param startValues The target values in the start scene
 * @param startVisibility The target visibility in the start scene
 * @param endValues The target values in the end scene
 * @param endVisibility The target visibility in the end scene
 * @return An Animator to be started at the appropriate time in the
 * overall transition for this scene change. A null value means no animation
 * should be run.
 */
","/**
 * The default implementation of this method calls
 * {@link #onAppear(ViewGroup, View, TransitionValues, TransitionValues)}.
 * Subclasses should override this method or
 * {@link #onAppear(ViewGroup, View, TransitionValues, TransitionValues)}.
 * if they need to create an Animator when targets appear.
 * The method should only be called by the Visibility class; it is
 * not intended to be called from external classes.
 *
 * @param sceneRoot The root of the transition hierarchy
 * @param startValues The target values in the start scene
 * @param startVisibility The target visibility in the start scene
 * @param endValues The target values in the end scene
 * @param endVisibility The target visibility in the end scene
 * @return An Animator to be started at the appropriate time in the
 * overall transition for this scene change. A null value means no animation
 * should be run.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The addition of new variable declaration (`final boolean isForcedVisibility`) and condition check (`if (isForcedVisibility)`) along with the call to `endValues.view.setTransitionAlpha(1)` within the if-block, constitute changes in control dependency (3) and other statements (4).","Although there is a change in the late version implementation that affects control flows, this doesn't result in a Compatibility Issue. The early version of the API does not return a different value or throw a different exception based on the added condition and method call. The method call `setTransitionAlpha(1)` might change the state of `endValues.view`, but since it is acting on the `endValues.view` object and not affecting the return value of the `onAppear` method itself, there's no change in the method's behavior in regards to its output being returned to the caller. Thus, no Compatibility Issue is detected."
588,<android.widget.QuickContactBadge: void onClick(View)>,22,23,<android.widget.QuickContactBadge: void onClick(View)>,<android.widget.QuickContactBadge: void onClick(View)>,0,"{
    // If contact has been assigned, mExtras should no longer be null, but do a null check
    // anyway just in case assignContactFromPhone or Email was called with a null bundle or
    // wasn't assigned previously.
    final Bundle extras = (mExtras == null) ? new Bundle() : mExtras;
    if (mContactUri != null) {
        QuickContact.showQuickContact(getContext(), QuickContactBadge.this, mContactUri, QuickContact.MODE_LARGE, mExcludeMimes);
    } else if (mContactEmail != null && mQueryHandler != null) {
        extras.putString(EXTRA_URI_CONTENT, mContactEmail);
        mQueryHandler.startQuery(TOKEN_EMAIL_LOOKUP_AND_TRIGGER, extras, Uri.withAppendedPath(Email.CONTENT_LOOKUP_URI, Uri.encode(mContactEmail)), EMAIL_LOOKUP_PROJECTION, null, null, null);
    } else if (mContactPhone != null && mQueryHandler != null) {
        extras.putString(EXTRA_URI_CONTENT, mContactPhone);
        mQueryHandler.startQuery(TOKEN_PHONE_LOOKUP_AND_TRIGGER, extras, Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI, mContactPhone), PHONE_LOOKUP_PROJECTION, null, null, null);
    } else {
        // If a contact hasn't been assigned, don't react to click.
        return;
    }
}","{
    // If contact has been assigned, mExtras should no longer be null, but do a null check
    // anyway just in case assignContactFromPhone or Email was called with a null bundle or
    // wasn't assigned previously.
    final Bundle extras = (mExtras == null) ? new Bundle() : mExtras;
    if (mContactUri != null) {
        QuickContact.showQuickContact(getContext(), QuickContactBadge.this, mContactUri, mExcludeMimes, mPrioritizedMimeType);
    } else if (mContactEmail != null && mQueryHandler != null) {
        extras.putString(EXTRA_URI_CONTENT, mContactEmail);
        mQueryHandler.startQuery(TOKEN_EMAIL_LOOKUP_AND_TRIGGER, extras, Uri.withAppendedPath(Email.CONTENT_LOOKUP_URI, Uri.encode(mContactEmail)), EMAIL_LOOKUP_PROJECTION, null, null, null);
    } else if (mContactPhone != null && mQueryHandler != null) {
        extras.putString(EXTRA_URI_CONTENT, mContactPhone);
        mQueryHandler.startQuery(TOKEN_PHONE_LOOKUP_AND_TRIGGER, extras, Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI, mContactPhone), PHONE_LOOKUP_PROJECTION, null, null, null);
    } else {
        // If a contact hasn't been assigned, don't react to click.
        return;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The API's implementation change is in the 'showQuickContact' method parameters where 'QuickContact.MODE_LARGE' has been replaced with 'mExcludeMimes' and 'mPrioritizedMimeType'. This is a method call parameter change, therefore the code change type is 4.","The change in parameters to the method call does not constitute a return statement change or an exception handling statement change. It's an internal behavior change of how the 'showQuickContact' is called which may or may not lead to a different behavior based on the implementation of 'showQuickContact'. Based on the given information alone, we cannot determine a potential Compatibility Issue since the method 'onClick' does not return a value or throw a new type of exception."
590,<android.hardware.camera2.params.StreamConfigurationMap: int imageFormatToPublic(int)>,22,23,<android.hardware.camera2.params.StreamConfigurationMap: int imageFormatToPublic(int)>,<android.hardware.camera2.params.StreamConfigurationMap: int imageFormatToPublic(int)>,0,"{
    switch(format) {
        case HAL_PIXEL_FORMAT_BLOB:
            return ImageFormat.JPEG;
        case ImageFormat.JPEG:
            throw new IllegalArgumentException(""ImageFormat.JPEG is an unknown internal format"");
        case HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED:
            throw new IllegalArgumentException(""IMPLEMENTATION_DEFINED must not leak to public API"");
        default:
            return format;
    }
}","{
    switch(format) {
        case HAL_PIXEL_FORMAT_BLOB:
            return ImageFormat.JPEG;
        case ImageFormat.JPEG:
            throw new IllegalArgumentException(""ImageFormat.JPEG is an unknown internal format"");
        default:
            return format;
    }
}",1,"/**
 * Convert a public-visible {@code ImageFormat} into an internal format
 * compatible with {@code graphics.h}.
 *
 * <p>In particular these formats are converted:
 * <ul>
 * <li>HAL_PIXEL_FORMAT_BLOB => ImageFormat.JPEG
 * </ul>
 * </p>
 *
 * <p>Passing in an implementation-defined format which has no public equivalent will fail;
 * as will passing in a public format which has a different internal format equivalent.
 * See {@link #checkArgumentFormat} for more details about a legal public format.</p>
 *
 * <p>All other formats are returned as-is, no further invalid check is performed.</p>
 *
 * <p>This function is the dual of {@link #imageFormatToInternal}.</p>
 *
 * @param format image format from {@link ImageFormat} or {@link PixelFormat}
 * @return the converted image formats
 *
 * @throws IllegalArgumentException
 * if {@code format} is {@code HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED} or
 * {@link ImageFormat#JPEG}
 *
 * @see ImageFormat
 * @see PixelFormat
 * @see #checkArgumentFormat
 */
","/**
 * Convert an internal format compatible with {@code graphics.h} into public-visible
 * {@code ImageFormat}. This assumes the dataspace of the format is not HAL_DATASPACE_DEPTH.
 *
 * <p>In particular these formats are converted:
 * <ul>
 * <li>HAL_PIXEL_FORMAT_BLOB => ImageFormat.JPEG</li>
 * </ul>
 * </p>
 *
 * <p>Passing in a format which has no public equivalent will fail;
 * as will passing in a public format which has a different internal format equivalent.
 * See {@link #checkArgumentFormat} for more details about a legal public format.</p>
 *
 * <p>All other formats are returned as-is, no further invalid check is performed.</p>
 *
 * <p>This function is the dual of {@link #imageFormatToInternal} for dataspaces other than
 * HAL_DATASPACE_DEPTH.</p>
 *
 * @param format image format from {@link ImageFormat} or {@link PixelFormat}
 * @return the converted image formats
 *
 * @throws IllegalArgumentException
 * if {@code format} is {@code HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED} or
 * {@link ImageFormat#JPEG}
 *
 * @see ImageFormat
 * @see PixelFormat
 * @see #checkArgumentFormat
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","A case (`HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED`) has been removed from the switch statement which removes the condition that would throw an `IllegalArgumentException`, so the change type is both 1 (removal of exception throw for a specific case) and 2 (modification in control flow through removal of a case statement).","Due to the removal of a case that throws an exception, this change could prevent an exception from being thrown when it would have been thrown in the earlier version. Also, if the format matches the removed case, it will now return the format itself instead of throwing an exception, leading to a different return value. Thus, the potential CI could be both 1 (different return value) and 2 (different exception handling)."
592,<android.widget.SpellChecker.SpellParser: void parse()>,22,23,<android.widget.SpellChecker.SpellParser: void parse()>,<android.widget.SpellChecker.SpellParser: void parse()>,0,"{
    Editable editable = (Editable) mTextView.getText();
    // Iterate over the newly added text and schedule new SpellCheckSpans
    final int start;
    if (mIsSentenceSpellCheckSupported) {
        // TODO: Find the start position of the sentence.
        // Set span with the context
        start = Math.max(0, editable.getSpanStart(mRange) - MIN_SENTENCE_LENGTH);
    } else {
        start = editable.getSpanStart(mRange);
    }
    final int end = editable.getSpanEnd(mRange);
    int wordIteratorWindowEnd = Math.min(end, start + WORD_ITERATOR_INTERVAL);
    mWordIterator.setCharSequence(editable, start, wordIteratorWindowEnd);
    // Move back to the beginning of the current word, if any
    int wordStart = mWordIterator.preceding(start);
    int wordEnd;
    if (wordStart == BreakIterator.DONE) {
        wordEnd = mWordIterator.following(start);
        if (wordEnd != BreakIterator.DONE) {
            wordStart = mWordIterator.getBeginning(wordEnd);
        }
    } else {
        wordEnd = mWordIterator.getEnd(wordStart);
    }
    if (wordEnd == BreakIterator.DONE) {
        if (DBG) {
            Log.i(TAG, ""No more spell check."");
        }
        removeRangeSpan(editable);
        return;
    }
    // We need to expand by one character because we want to include the spans that
    // end/start at position start/end respectively.
    SpellCheckSpan[] spellCheckSpans = editable.getSpans(start - 1, end + 1, SpellCheckSpan.class);
    SuggestionSpan[] suggestionSpans = editable.getSpans(start - 1, end + 1, SuggestionSpan.class);
    int wordCount = 0;
    boolean scheduleOtherSpellCheck = false;
    if (mIsSentenceSpellCheckSupported) {
        if (wordIteratorWindowEnd < end) {
            if (DBG) {
                Log.i(TAG, ""schedule other spell check."");
            }
            // Several batches needed on that region. Cut after last previous word
            scheduleOtherSpellCheck = true;
        }
        int spellCheckEnd = mWordIterator.preceding(wordIteratorWindowEnd);
        boolean correct = spellCheckEnd != BreakIterator.DONE;
        if (correct) {
            spellCheckEnd = mWordIterator.getEnd(spellCheckEnd);
            correct = spellCheckEnd != BreakIterator.DONE;
        }
        if (!correct) {
            if (DBG) {
                Log.i(TAG, ""Incorrect range span."");
            }
            removeRangeSpan(editable);
            return;
        }
        do {
            // TODO: Find the start position of the sentence.
            int spellCheckStart = wordStart;
            boolean createSpellCheckSpan = true;
            // Cancel or merge overlapped spell check spans
            for (int i = 0; i < mLength; ++i) {
                final SpellCheckSpan spellCheckSpan = mSpellCheckSpans[i];
                if (mIds[i] < 0 || spellCheckSpan.isSpellCheckInProgress()) {
                    continue;
                }
                final int spanStart = editable.getSpanStart(spellCheckSpan);
                final int spanEnd = editable.getSpanEnd(spellCheckSpan);
                if (spanEnd < spellCheckStart || spellCheckEnd < spanStart) {
                    // No need to merge
                    continue;
                }
                if (spanStart <= spellCheckStart && spellCheckEnd <= spanEnd) {
                    // There is a completely overlapped spell check span
                    // skip this span
                    createSpellCheckSpan = false;
                    if (DBG) {
                        Log.i(TAG, ""The range is overrapped. Skip spell check."");
                    }
                    break;
                }
                // This spellCheckSpan is replaced by the one we are creating
                editable.removeSpan(spellCheckSpan);
                spellCheckStart = Math.min(spanStart, spellCheckStart);
                spellCheckEnd = Math.max(spanEnd, spellCheckEnd);
            }
            if (DBG) {
                Log.d(TAG, ""addSpellCheckSpan: "" + "", End = "" + spellCheckEnd + "", Start = "" + spellCheckStart + "", next = "" + scheduleOtherSpellCheck + ""\n"" + editable.subSequence(spellCheckStart, spellCheckEnd));
            }
            // Stop spell checking when there are no characters in the range.
            if (spellCheckEnd < start) {
                break;
            }
            if (spellCheckEnd <= spellCheckStart) {
                Log.w(TAG, ""Trying to spellcheck invalid region, from "" + start + "" to "" + end);
                break;
            }
            if (createSpellCheckSpan) {
                addSpellCheckSpan(editable, spellCheckStart, spellCheckEnd);
            }
        } while (false);
        wordStart = spellCheckEnd;
    } else {
        while (wordStart <= end) {
            if (wordEnd >= start && wordEnd > wordStart) {
                if (wordCount >= MAX_NUMBER_OF_WORDS) {
                    scheduleOtherSpellCheck = true;
                    break;
                }
                // not valid anymore and must be removed.
                if (wordStart < start && wordEnd > start) {
                    removeSpansAt(editable, start, spellCheckSpans);
                    removeSpansAt(editable, start, suggestionSpans);
                }
                if (wordStart < end && wordEnd > end) {
                    removeSpansAt(editable, end, spellCheckSpans);
                    removeSpansAt(editable, end, suggestionSpans);
                }
                // Do not create new boundary spans if they already exist
                boolean createSpellCheckSpan = true;
                if (wordEnd == start) {
                    for (int i = 0; i < spellCheckSpans.length; i++) {
                        final int spanEnd = editable.getSpanEnd(spellCheckSpans[i]);
                        if (spanEnd == start) {
                            createSpellCheckSpan = false;
                            break;
                        }
                    }
                }
                if (wordStart == end) {
                    for (int i = 0; i < spellCheckSpans.length; i++) {
                        final int spanStart = editable.getSpanStart(spellCheckSpans[i]);
                        if (spanStart == end) {
                            createSpellCheckSpan = false;
                            break;
                        }
                    }
                }
                if (createSpellCheckSpan) {
                    addSpellCheckSpan(editable, wordStart, wordEnd);
                }
                wordCount++;
            }
            // iterate word by word
            int originalWordEnd = wordEnd;
            wordEnd = mWordIterator.following(wordEnd);
            if ((wordIteratorWindowEnd < end) && (wordEnd == BreakIterator.DONE || wordEnd >= wordIteratorWindowEnd)) {
                wordIteratorWindowEnd = Math.min(end, originalWordEnd + WORD_ITERATOR_INTERVAL);
                mWordIterator.setCharSequence(editable, originalWordEnd, wordIteratorWindowEnd);
                wordEnd = mWordIterator.following(originalWordEnd);
            }
            if (wordEnd == BreakIterator.DONE)
                break;
            wordStart = mWordIterator.getBeginning(wordEnd);
            if (wordStart == BreakIterator.DONE) {
                break;
            }
        }
    }
    if (scheduleOtherSpellCheck && wordStart <= end) {
        // Update range span: start new spell check from last wordStart
        setRangeSpan(editable, wordStart, end);
    } else {
        if (DBG && scheduleOtherSpellCheck) {
            Log.w(TAG, ""Trying to schedule spellcheck for invalid region, from "" + wordStart + "" to "" + end);
        }
        removeRangeSpan(editable);
    }
    spellCheck();
}","{
    Editable editable = (Editable) mTextView.getText();
    // Iterate over the newly added text and schedule new SpellCheckSpans
    final int start;
    if (mIsSentenceSpellCheckSupported) {
        // TODO: Find the start position of the sentence.
        // Set span with the context
        start = Math.max(0, editable.getSpanStart(mRange) - MIN_SENTENCE_LENGTH);
    } else {
        start = editable.getSpanStart(mRange);
    }
    final int end = editable.getSpanEnd(mRange);
    int wordIteratorWindowEnd = Math.min(end, start + WORD_ITERATOR_INTERVAL);
    mWordIterator.setCharSequence(editable, start, wordIteratorWindowEnd);
    // Move back to the beginning of the current word, if any
    int wordStart = mWordIterator.preceding(start);
    int wordEnd;
    if (wordStart == BreakIterator.DONE) {
        wordEnd = mWordIterator.following(start);
        if (wordEnd != BreakIterator.DONE) {
            wordStart = mWordIterator.getBeginning(wordEnd);
        }
    } else {
        wordEnd = mWordIterator.getEnd(wordStart);
    }
    if (wordEnd == BreakIterator.DONE) {
        if (DBG) {
            Log.i(TAG, ""No more spell check."");
        }
        removeRangeSpan(editable);
        return;
    }
    // We need to expand by one character because we want to include the spans that
    // end/start at position start/end respectively.
    SpellCheckSpan[] spellCheckSpans = editable.getSpans(start - 1, end + 1, SpellCheckSpan.class);
    SuggestionSpan[] suggestionSpans = editable.getSpans(start - 1, end + 1, SuggestionSpan.class);
    int wordCount = 0;
    boolean scheduleOtherSpellCheck = false;
    if (mIsSentenceSpellCheckSupported) {
        if (wordIteratorWindowEnd < end) {
            if (DBG) {
                Log.i(TAG, ""schedule other spell check."");
            }
            // Several batches needed on that region. Cut after last previous word
            scheduleOtherSpellCheck = true;
        }
        int spellCheckEnd = mWordIterator.preceding(wordIteratorWindowEnd);
        boolean correct = spellCheckEnd != BreakIterator.DONE;
        if (correct) {
            spellCheckEnd = mWordIterator.getEnd(spellCheckEnd);
            correct = spellCheckEnd != BreakIterator.DONE;
        }
        if (!correct) {
            if (DBG) {
                Log.i(TAG, ""Incorrect range span."");
            }
            removeRangeSpan(editable);
            return;
        }
        do {
            // TODO: Find the start position of the sentence.
            int spellCheckStart = wordStart;
            boolean createSpellCheckSpan = true;
            // Cancel or merge overlapped spell check spans
            for (int i = 0; i < mLength; ++i) {
                final SpellCheckSpan spellCheckSpan = mSpellCheckSpans[i];
                if (mIds[i] < 0 || spellCheckSpan.isSpellCheckInProgress()) {
                    continue;
                }
                final int spanStart = editable.getSpanStart(spellCheckSpan);
                final int spanEnd = editable.getSpanEnd(spellCheckSpan);
                if (spanEnd < spellCheckStart || spellCheckEnd < spanStart) {
                    // No need to merge
                    continue;
                }
                if (spanStart <= spellCheckStart && spellCheckEnd <= spanEnd) {
                    // There is a completely overlapped spell check span
                    // skip this span
                    createSpellCheckSpan = false;
                    if (DBG) {
                        Log.i(TAG, ""The range is overrapped. Skip spell check."");
                    }
                    break;
                }
                // This spellCheckSpan is replaced by the one we are creating
                editable.removeSpan(spellCheckSpan);
                spellCheckStart = Math.min(spanStart, spellCheckStart);
                spellCheckEnd = Math.max(spanEnd, spellCheckEnd);
            }
            if (DBG) {
                Log.d(TAG, ""addSpellCheckSpan: "" + "", End = "" + spellCheckEnd + "", Start = "" + spellCheckStart + "", next = "" + scheduleOtherSpellCheck + ""\n"" + editable.subSequence(spellCheckStart, spellCheckEnd));
            }
            // Stop spell checking when there are no characters in the range.
            if (spellCheckEnd < start) {
                break;
            }
            if (spellCheckEnd <= spellCheckStart) {
                Log.w(TAG, ""Trying to spellcheck invalid region, from "" + start + "" to "" + end);
                break;
            }
            if (createSpellCheckSpan) {
                addSpellCheckSpan(editable, spellCheckStart, spellCheckEnd);
            }
        } while (false);
        wordStart = spellCheckEnd;
    } else {
        while (wordStart <= end) {
            if (wordEnd >= start && wordEnd > wordStart) {
                if (wordCount >= MAX_NUMBER_OF_WORDS) {
                    scheduleOtherSpellCheck = true;
                    break;
                }
                // not valid anymore and must be removed.
                if (wordStart < start && wordEnd > start) {
                    removeSpansAt(editable, start, spellCheckSpans);
                    removeSpansAt(editable, start, suggestionSpans);
                }
                if (wordStart < end && wordEnd > end) {
                    removeSpansAt(editable, end, spellCheckSpans);
                    removeSpansAt(editable, end, suggestionSpans);
                }
                // Do not create new boundary spans if they already exist
                boolean createSpellCheckSpan = true;
                if (wordEnd == start) {
                    for (int i = 0; i < spellCheckSpans.length; i++) {
                        final int spanEnd = editable.getSpanEnd(spellCheckSpans[i]);
                        if (spanEnd == start) {
                            createSpellCheckSpan = false;
                            break;
                        }
                    }
                }
                if (wordStart == end) {
                    for (int i = 0; i < spellCheckSpans.length; i++) {
                        final int spanStart = editable.getSpanStart(spellCheckSpans[i]);
                        if (spanStart == end) {
                            createSpellCheckSpan = false;
                            break;
                        }
                    }
                }
                if (createSpellCheckSpan) {
                    addSpellCheckSpan(editable, wordStart, wordEnd);
                }
                wordCount++;
            }
            // iterate word by word
            int originalWordEnd = wordEnd;
            wordEnd = mWordIterator.following(wordEnd);
            if ((wordIteratorWindowEnd < end) && (wordEnd == BreakIterator.DONE || wordEnd >= wordIteratorWindowEnd)) {
                wordIteratorWindowEnd = Math.min(end, originalWordEnd + WORD_ITERATOR_INTERVAL);
                mWordIterator.setCharSequence(editable, originalWordEnd, wordIteratorWindowEnd);
                wordEnd = mWordIterator.following(originalWordEnd);
            }
            if (wordEnd == BreakIterator.DONE)
                break;
            wordStart = mWordIterator.getBeginning(wordEnd);
            if (wordStart == BreakIterator.DONE) {
                break;
            }
        }
    }
    if (scheduleOtherSpellCheck && wordStart != BreakIterator.DONE && wordStart <= end) {
        // Update range span: start new spell check from last wordStart
        setRangeSpan(editable, wordStart, end);
    } else {
        removeRangeSpan(editable);
    }
    spellCheck();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
593,"<android.text.format.DateUtils: CharSequence getRelativeTimeSpanString(long,long,long,int)>",22,23,"<android.text.format.DateUtils: CharSequence getRelativeTimeSpanString(long,long,long,int)>","<android.text.format.DateUtils: CharSequence getRelativeTimeSpanString(long,long,long,int)>",0,"{
    Resources r = Resources.getSystem();
    boolean abbrevRelative = (flags & (FORMAT_ABBREV_RELATIVE | FORMAT_ABBREV_ALL)) != 0;
    boolean past = (now >= time);
    long duration = Math.abs(now - time);
    int resId;
    long count;
    if (duration < MINUTE_IN_MILLIS && minResolution < MINUTE_IN_MILLIS) {
        count = duration / SECOND_IN_MILLIS;
        if (past) {
            if (abbrevRelative) {
                resId = com.android.internal.R.plurals.abbrev_num_seconds_ago;
            } else {
                resId = com.android.internal.R.plurals.num_seconds_ago;
            }
        } else {
            if (abbrevRelative) {
                resId = com.android.internal.R.plurals.abbrev_in_num_seconds;
            } else {
                resId = com.android.internal.R.plurals.in_num_seconds;
            }
        }
    } else if (duration < HOUR_IN_MILLIS && minResolution < HOUR_IN_MILLIS) {
        count = duration / MINUTE_IN_MILLIS;
        if (past) {
            if (abbrevRelative) {
                resId = com.android.internal.R.plurals.abbrev_num_minutes_ago;
            } else {
                resId = com.android.internal.R.plurals.num_minutes_ago;
            }
        } else {
            if (abbrevRelative) {
                resId = com.android.internal.R.plurals.abbrev_in_num_minutes;
            } else {
                resId = com.android.internal.R.plurals.in_num_minutes;
            }
        }
    } else if (duration < DAY_IN_MILLIS && minResolution < DAY_IN_MILLIS) {
        count = duration / HOUR_IN_MILLIS;
        if (past) {
            if (abbrevRelative) {
                resId = com.android.internal.R.plurals.abbrev_num_hours_ago;
            } else {
                resId = com.android.internal.R.plurals.num_hours_ago;
            }
        } else {
            if (abbrevRelative) {
                resId = com.android.internal.R.plurals.abbrev_in_num_hours;
            } else {
                resId = com.android.internal.R.plurals.in_num_hours;
            }
        }
    } else if (duration < WEEK_IN_MILLIS && minResolution < WEEK_IN_MILLIS) {
        return getRelativeDayString(r, time, now);
    } else {
        // in a null context.
        return formatDateRange(null, time, time, flags);
    }
    String format = r.getQuantityString(resId, (int) count);
    return String.format(format, count);
}","{
    return RelativeDateTimeFormatter.getRelativeTimeSpanString(Locale.getDefault(), TimeZone.getDefault(), time, now, minResolution, flags);
}",1,"/**
 * Returns a string describing 'time' as a time relative to 'now'.
 * <p>
 * Time spans in the past are formatted like ""42 minutes ago"". Time spans in
 * the future are formatted like ""in 42 minutes"".
 * <p>
 * Can use {@link #FORMAT_ABBREV_RELATIVE} flag to use abbreviated relative
 * times, like ""42 mins ago"".
 *
 * @param time the time to describe, in milliseconds
 * @param now the current time in milliseconds
 * @param minResolution the minimum timespan to report. For example, a time
 * 3 seconds in the past will be reported as ""0 minutes ago"" if
 * this is set to MINUTE_IN_MILLIS. Pass one of 0,
 * MINUTE_IN_MILLIS, HOUR_IN_MILLIS, DAY_IN_MILLIS,
 * WEEK_IN_MILLIS
 * @param flags a bit mask of formatting options, such as
 * {@link #FORMAT_NUMERIC_DATE} or
 * {@link #FORMAT_ABBREV_RELATIVE}
 */
","/**
 * Returns a string describing 'time' as a time relative to 'now'.
 * <p>
 * Time spans in the past are formatted like ""42 minutes ago"". Time spans in
 * the future are formatted like ""In 42 minutes"".
 * <p>
 * Can use {@link #FORMAT_ABBREV_RELATIVE} flag to use abbreviated relative
 * times, like ""42 mins ago"".
 *
 * @param time the time to describe, in milliseconds
 * @param now the current time in milliseconds
 * @param minResolution the minimum timespan to report. For example, a time
 * 3 seconds in the past will be reported as ""0 minutes ago"" if
 * this is set to MINUTE_IN_MILLIS. Pass one of 0,
 * MINUTE_IN_MILLIS, HOUR_IN_MILLIS, DAY_IN_MILLIS,
 * WEEK_IN_MILLIS
 * @param flags a bit mask of formatting options, such as
 * {@link #FORMAT_NUMERIC_DATE} or
 * {@link #FORMAT_ABBREV_RELATIVE}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The entire implementation of the method has been replaced with a call to a different API ""RelativeDateTimeFormatter.getRelativeTimeSpanString"", this is both a return statement change and a dependent API change, making the code change types 1,5.","Since the original method implementation relied on several local computations and resource lookups, by moving to a new API that potentially has an entirely different implementation, the result returned by the API can differ. Thus, this is a compatibility issue caused by potential different return values, which is type 1."
595,<android.hardware.SensorManager: Sensor getDefaultSensor(int)>,22,23,<android.hardware.SensorManager: Sensor getDefaultSensor(int)>,<android.hardware.SensorManager: Sensor getDefaultSensor(int)>,0,"{
    // TODO: need to be smarter, for now, just return the 1st sensor
    List<Sensor> l = getSensorList(type);
    boolean wakeUpSensor = false;
    // non_wake-up version.
    if (type == Sensor.TYPE_PROXIMITY || type == Sensor.TYPE_SIGNIFICANT_MOTION || type == Sensor.TYPE_TILT_DETECTOR || type == Sensor.TYPE_WAKE_GESTURE || type == Sensor.TYPE_GLANCE_GESTURE || type == Sensor.TYPE_PICK_UP_GESTURE) {
        wakeUpSensor = true;
    }
    for (Sensor sensor : l) {
        if (sensor.isWakeUpSensor() == wakeUpSensor)
            return sensor;
    }
    return null;
}","{
    // TODO: need to be smarter, for now, just return the 1st sensor
    List<Sensor> l = getSensorList(type);
    boolean wakeUpSensor = false;
    // non_wake-up version.
    if (type == Sensor.TYPE_PROXIMITY || type == Sensor.TYPE_SIGNIFICANT_MOTION || type == Sensor.TYPE_TILT_DETECTOR || type == Sensor.TYPE_WAKE_GESTURE || type == Sensor.TYPE_GLANCE_GESTURE || type == Sensor.TYPE_PICK_UP_GESTURE || type == Sensor.TYPE_WRIST_TILT_GESTURE) {
        wakeUpSensor = true;
    }
    for (Sensor sensor : l) {
        if (sensor.isWakeUpSensor() == wakeUpSensor)
            return sensor;
    }
    return null;
}",1,"/**
 * Use this method to get the default sensor for a given type. Note that the
 * returned sensor could be a composite sensor, and its data could be
 * averaged or filtered. If you need to access the raw sensors use
 * {@link SensorManager#getSensorList(int) getSensorList}.
 *
 * @param type
 * of sensors requested
 *
 * @return the default sensor matching the requested type if one exists and the application
 * has the necessary permissions, or null otherwise.
 *
 * @see #getSensorList(int)
 * @see Sensor
 */
","/**
 * Use this method to get the default sensor for a given type. Note that the
 * returned sensor could be a composite sensor, and its data could be
 * averaged or filtered. If you need to access the raw sensors use
 * {@link SensorManager#getSensorList(int) getSensorList}.
 *
 * @param type
 * of sensors requested
 *
 * @return the default sensor matching the requested type if one exists and the application
 * has the necessary permissions, or null otherwise.
 *
 * @see #getSensorList(int)
 * @see Sensor
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,There is a change in the control dependency where a new sensor type condition `Sensor.TYPE_WRIST_TILT_GESTURE` has been added to the if statement block that assigns the 'wakeUpSensor' variable. So the code change type is 3.,"Because of the new sensor type condition, the behavior of setting 'wakeUpSensor' to true might change when the type is `Sensor.TYPE_WRIST_TILT_GESTURE`. The 'return sensor' will depend on what sensors are in the list and how they report 'isWakeUpSensor'. Therefore, the API may return different sensors in the late version as compared to the early version if a sensor of type `Sensor.TYPE_WRIST_TILT_GESTURE` is present in the system. This could potentially return a different sensor object from the method, so the CI type is 1."
598,<android.webkit.WebView: boolean pageDown(boolean)>,22,23,<android.webkit.WebView: boolean pageDown(boolean)>,<android.webkit.WebView: boolean pageDown(boolean)>,0,"{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, ""pageDown"");
    return mProvider.pageDown(bottom);
}","{
    checkThread();
    return mProvider.pageDown(bottom);
}",1,"/**
 * Scrolls the contents of this WebView down by half the page size.
 *
 * @param bottom true to jump to bottom of page
 * @return true if the page was scrolled
 */
","/**
 * Scrolls the contents of this WebView down by half the page size.
 *
 * @param bottom true to jump to bottom of page
 * @return true if the page was scrolled
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,The only change is the deletion of a logging statement. This change type is 4 as it's neither a control dependency change nor does it affect the return value or exception handling.,"Since the change only involves a non-functional logging statement and doesn't impact the method's behavior related to return values, exceptions, or its control flow, there's no Compatibility Issue. The API's behavior remains functionally unchanged between the two versions."
600,"<android.app.WallpaperManager: void suggestDesiredDimensions(int,int)>",22,23,"<android.app.WallpaperManager: void suggestDesiredDimensions(int,int)>","<android.app.WallpaperManager: void suggestDesiredDimensions(int,int)>",0,"{
    try {
        /**
         * The framework makes no attempt to limit the window size
         * to the maximum texture size. Any window larger than this
         * cannot be composited.
         *
         * Read maximum texture size from system property and scale down
         * minimumWidth and minimumHeight accordingly.
         */
        int maximumTextureSize;
        try {
            maximumTextureSize = SystemProperties.getInt(""sys.max_texture_size"", 0);
        } catch (Exception e) {
            maximumTextureSize = 0;
        }
        if (maximumTextureSize > 0) {
            if ((minimumWidth > maximumTextureSize) || (minimumHeight > maximumTextureSize)) {
                float aspect = (float) minimumHeight / (float) minimumWidth;
                if (minimumWidth > minimumHeight) {
                    minimumWidth = maximumTextureSize;
                    minimumHeight = (int) ((minimumWidth * aspect) + 0.5);
                } else {
                    minimumHeight = maximumTextureSize;
                    minimumWidth = (int) ((minimumHeight / aspect) + 0.5);
                }
            }
        }
        if (sGlobals.mService == null) {
            Log.w(TAG, ""WallpaperService not running"");
        } else {
            sGlobals.mService.setDimensionHints(minimumWidth, minimumHeight);
        }
    } catch (RemoteException e) {
    // Ignore
    }
}","{
    try {
        /**
         * The framework makes no attempt to limit the window size
         * to the maximum texture size. Any window larger than this
         * cannot be composited.
         *
         * Read maximum texture size from system property and scale down
         * minimumWidth and minimumHeight accordingly.
         */
        int maximumTextureSize;
        try {
            maximumTextureSize = SystemProperties.getInt(""sys.max_texture_size"", 0);
        } catch (Exception e) {
            maximumTextureSize = 0;
        }
        if (maximumTextureSize > 0) {
            if ((minimumWidth > maximumTextureSize) || (minimumHeight > maximumTextureSize)) {
                float aspect = (float) minimumHeight / (float) minimumWidth;
                if (minimumWidth > minimumHeight) {
                    minimumWidth = maximumTextureSize;
                    minimumHeight = (int) ((minimumWidth * aspect) + 0.5);
                } else {
                    minimumHeight = maximumTextureSize;
                    minimumWidth = (int) ((minimumHeight / aspect) + 0.5);
                }
            }
        }
        if (sGlobals.mService == null) {
            Log.w(TAG, ""WallpaperService not running"");
        } else {
            sGlobals.mService.setDimensionHints(minimumWidth, minimumHeight, mContext.getOpPackageName());
        }
    } catch (RemoteException e) {
    // Ignore
    }
}",1,"/**
 * For use only by the current home application, to specify the size of
 * wallpaper it would like to use.  This allows such applications to have
 * a virtual wallpaper that is larger than the physical screen, matching
 * the size of their workspace.
 *
 * <p>Note developers, who don't seem to be reading this.  This is
 * for <em>home screens</em> to tell what size wallpaper they would like.
 * Nobody else should be calling this!  Certainly not other non-home-screen
 * apps that change the wallpaper.  Those apps are supposed to
 * <b>retrieve</b> the suggested size so they can construct a wallpaper
 * that matches it.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#SET_WALLPAPER_HINTS}.
 *
 * @param minimumWidth Desired minimum width
 * @param minimumHeight Desired minimum height
 */
","/**
 * For use only by the current home application, to specify the size of
 * wallpaper it would like to use.  This allows such applications to have
 * a virtual wallpaper that is larger than the physical screen, matching
 * the size of their workspace.
 *
 * <p>Note developers, who don't seem to be reading this.  This is
 * for <em>home screens</em> to tell what size wallpaper they would like.
 * Nobody else should be calling this!  Certainly not other non-home-screen
 * apps that change the wallpaper.  Those apps are supposed to
 * <b>retrieve</b> the suggested size so they can construct a wallpaper
 * that matches it.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#SET_WALLPAPER_HINTS}.
 *
 * @param minimumWidth Desired minimum width
 * @param minimumHeight Desired minimum height
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The arguments for the method sGlobals.mService.setDimensionHints() have changed with an additional parameter, mContext.getOpPackageName(), being passed in the late version.","There is no Compatibility Issue since the extra argument doesn't affect the behavior of the method suggestDesiredDimensions() itself — the method signature remains the same, and it doesn't have a return value nor throw a different exception. It's an internal change to a dependent API call which doesn't directly impact the consumer of suggestDesiredDimensions()."
603,"<android.net.ConnectivityManager: int startUsingNetworkFeature(int,String)>",22,23,"<android.net.ConnectivityManager: int startUsingNetworkFeature(int,String)>","<android.net.ConnectivityManager: int startUsingNetworkFeature(int,String)>",0,"{
    NetworkCapabilities netCap = networkCapabilitiesForFeature(networkType, feature);
    if (netCap == null) {
        Log.d(TAG, ""Can't satisfy startUsingNetworkFeature for "" + networkType + "", "" + feature);
        return PhoneConstants.APN_REQUEST_FAILED;
    }
    NetworkRequest request = null;
    synchronized (sLegacyRequests) {
        LegacyRequest l = sLegacyRequests.get(netCap);
        if (l != null) {
            Log.d(TAG, ""renewing startUsingNetworkFeature request "" + l.networkRequest);
            renewRequestLocked(l);
            if (l.currentNetwork != null) {
                return PhoneConstants.APN_ALREADY_ACTIVE;
            } else {
                return PhoneConstants.APN_REQUEST_STARTED;
            }
        }
        request = requestNetworkForFeatureLocked(netCap);
    }
    if (request != null) {
        Log.d(TAG, ""starting startUsingNetworkFeature for request "" + request);
        return PhoneConstants.APN_REQUEST_STARTED;
    } else {
        Log.d(TAG, "" request Failed"");
        return PhoneConstants.APN_REQUEST_FAILED;
    }
}","{
    checkLegacyRoutingApiAccess();
    NetworkCapabilities netCap = networkCapabilitiesForFeature(networkType, feature);
    if (netCap == null) {
        Log.d(TAG, ""Can't satisfy startUsingNetworkFeature for "" + networkType + "", "" + feature);
        return PhoneConstants.APN_REQUEST_FAILED;
    }
    NetworkRequest request = null;
    synchronized (sLegacyRequests) {
        LegacyRequest l = sLegacyRequests.get(netCap);
        if (l != null) {
            Log.d(TAG, ""renewing startUsingNetworkFeature request "" + l.networkRequest);
            renewRequestLocked(l);
            if (l.currentNetwork != null) {
                return PhoneConstants.APN_ALREADY_ACTIVE;
            } else {
                return PhoneConstants.APN_REQUEST_STARTED;
            }
        }
        request = requestNetworkForFeatureLocked(netCap);
    }
    if (request != null) {
        Log.d(TAG, ""starting startUsingNetworkFeature for request "" + request);
        return PhoneConstants.APN_REQUEST_STARTED;
    } else {
        Log.d(TAG, "" request Failed"");
        return PhoneConstants.APN_REQUEST_FAILED;
    }
}",1,"/**
 * Tells the underlying networking system that the caller wants to
 * begin using the named feature. The interpretation of {@code feature}
 * is completely up to each networking implementation.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#CHANGE_NETWORK_STATE}.
 * @param networkType specifies which network the request pertains to
 * @param feature the name of the feature to be used
 * @return an integer value representing the outcome of the request.
 * The interpretation of this value is specific to each networking
 * implementation+feature combination, except that the value {@code -1}
 * always indicates failure.
 *
 * @deprecated Deprecated in favor of the cleaner {@link #requestNetwork} api.
 */
","/**
 * Tells the underlying networking system that the caller wants to
 * begin using the named feature. The interpretation of {@code feature}
 * is completely up to each networking implementation.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#CHANGE_NETWORK_STATE}.
 * @param networkType specifies which network the request pertains to
 * @param feature the name of the feature to be used
 * @return an integer value representing the outcome of the request.
 * The interpretation of this value is specific to each networking
 * implementation+feature combination, except that the value {@code -1}
 * always indicates failure.
 *
 * @deprecated Deprecated in favor of the cleaner
 * {@link #requestNetwork(NetworkRequest, NetworkCallback)} API.
 * In {@link VERSION_CODES#M}, and above, this method is unsupported and will
 * throw {@code UnsupportedOperationException} if called.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"Only a new method call `checkLegacyRoutingApiAccess();` has been added at the beginning of the method, without altering any existing functionality or control flow, so the code change type is 4.","The addition of `checkLegacyRoutingApiAccess();` does not by itself cause a change in return value or thrown exceptions as it doesn't seem to be directly involved in the values being returned or any exceptions being thrown, so there is no Compatibility Issue, classified as 0."
605,"<android.transition.Slide: Animator onDisappear(ViewGroup,View,TransitionValues,TransitionValues)>",22,23,"<android.transition.Slide: Animator onDisappear(ViewGroup,View,TransitionValues,TransitionValues)>","<android.transition.Slide: Animator onDisappear(ViewGroup,View,TransitionValues,TransitionValues)>",0,"{
    if (startValues == null) {
        return null;
    }
    int[] position = (int[]) startValues.values.get(PROPNAME_SCREEN_POSITION);
    float startX = view.getTranslationX();
    float startY = view.getTranslationY();
    float endX = mSlideCalculator.getGoneX(sceneRoot, view);
    float endY = mSlideCalculator.getGoneY(sceneRoot, view);
    return TranslationAnimationCreator.createAnimation(view, startValues, position[0], position[1], startX, startY, endX, endY, sAccelerate);
}","{
    if (startValues == null) {
        return null;
    }
    int[] position = (int[]) startValues.values.get(PROPNAME_SCREEN_POSITION);
    float startX = view.getTranslationX();
    float startY = view.getTranslationY();
    float endX = mSlideCalculator.getGoneX(sceneRoot, view);
    float endY = mSlideCalculator.getGoneY(sceneRoot, view);
    return TranslationAnimationCreator.createAnimation(view, startValues, position[0], position[1], startX, startY, endX, endY, sAccelerate, this);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"An additional parameter 'this' was added to the `TranslationAnimationCreator.createAnimation` method call, which is a change in the parameter list of another API call, so the code change type is 4.","This change will not cause a Compatibility Issue since no change in the function's logic, exception handling, or return statements has occurred. The change may affect the internal operation of the `createAnimation` method, but since this internal detail is not exposed, the change is unlikely to change the behavior of the `onDisappear` method as observed by the caller, assuming the contract of `createAnimation` remains the same despite the new parameter. Thus, there is no potential Compatibility Issue."
607,<android.app.ActivityView.ActivityViewSurfaceTextureListener: boolean onSurfaceTextureDestroyed(SurfaceTexture)>,22,23,<android.app.ActivityView.ActivityViewSurfaceTextureListener: boolean onSurfaceTextureDestroyed(SurfaceTexture)>,<android.app.ActivityView.ActivityViewSurfaceTextureListener: boolean onSurfaceTextureDestroyed(SurfaceTexture)>,0,"{
    if (mActivityContainer == null) {
        return true;
    }
    if (DEBUG)
        Log.d(TAG, ""onSurfaceTextureDestroyed"");
    mSurface.release();
    mSurface = null;
    try {
        mActivityContainer.setSurface(null, mWidth, mHeight, mMetrics.densityDpi);
    } catch (RemoteException e) {
        throw new RuntimeException(""ActivityView: Unable to set surface of ActivityContainer. "" + e);
    }
    return true;
}","{
    if (mActivityContainer == null) {
        return true;
    }
    if (DEBUG)
        Log.d(TAG, ""onSurfaceTextureDestroyed"");
    mSurface.release();
    mSurface = null;
    try {
        mActivityContainer.setSurface(null, mWidth, mHeight, mMetrics.densityDpi);
    } catch (RemoteException e) {
        throw new RuntimeException(""ActivityView: Unable to set surface of ActivityContainer. "" + e);
    }
    if (mActivityViewCallback != null) {
        mActivityViewCallback.onSurfaceDestroyed(ActivityView.this);
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"New control statement (if) and a method call 'mActivityViewCallback.onSurfaceDestroyed(ActivityView.this)' have been added, which is a new statement under control dependency, so the code change type is 3,4.","Even though there is a change in control dependency and other statements, these changes do not affect the return value of the method or the exceptions that it throws. The method still returns true at the end, and exception handling is not altered. Therefore, there is no Compatibility Issue, and the CI type is 0."
608,"<android.content.ContentResolver: Uri insert(Uri,ContentValues)>",22,23,"<android.content.ContentResolver: Uri insert(Uri,ContentValues)>","<android.content.ContentResolver: Uri insert(Uri,ContentValues)>",0,"{
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        throw new IllegalArgumentException(""Unknown URL "" + url);
    }
    try {
        long startTime = SystemClock.uptimeMillis();
        Uri createdRow = provider.insert(mPackageName, url, values);
        long durationMillis = SystemClock.uptimeMillis() - startTime;
        maybeLogUpdateToEventLog(durationMillis, url, ""insert"", null);
        return createdRow;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        releaseProvider(provider);
    }
}","{
    Preconditions.checkNotNull(url, ""url"");
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        throw new IllegalArgumentException(""Unknown URL "" + url);
    }
    try {
        long startTime = SystemClock.uptimeMillis();
        Uri createdRow = provider.insert(mPackageName, url, values);
        long durationMillis = SystemClock.uptimeMillis() - startTime;
        maybeLogUpdateToEventLog(durationMillis, url, ""insert"", null);
        return createdRow;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        releaseProvider(provider);
    }
}",1,"/**
 * Inserts a row into a table at the given URL.
 *
 * If the content provider supports transactions the insertion will be atomic.
 *
 * @param url The URL of the table to insert into.
 * @param values The initial values for the newly inserted row. The key is the column name for
 * the field. Passing an empty ContentValues will create an empty row.
 * @return the URL of the newly created row.
 */
","/**
 * Inserts a row into a table at the given URL.
 *
 * If the content provider supports transactions the insertion will be atomic.
 *
 * @param url The URL of the table to insert into.
 * @param values The initial values for the newly inserted row. The key is the column name for
 * the field. Passing an empty ContentValues will create an empty row.
 * @return the URL of the newly created row.
 */
",-1,,[@Nullable],-1,-1,-1,-1,-1,-1,4,0,"The code has changed by adding a check on the 'url' parameter with Preconditions.checkNotNull(url, ""url""). This is a precondition check and doesn't change the control flow or the behavior of the API in regards to return values or exception handling (as the IllegalArgumentException would have been thrown anyway if 'url' was null) but adds an explicit check. Therefore, the change class is 4.","There is no Compatibility Issue since the added precondition check for 'url' does not alter the overall API behavior—it will throw an IllegalArgumentException if the 'url' is null, which the previous implementation would also do implicitly when trying to use a null 'url'."
609,<android.hardware.camera2.legacy.CameraDeviceUserShim.CameraCallbackThread.CallbackHandler: void handleMessage(Message)>,22,23,<android.hardware.camera2.legacy.CameraDeviceUserShim.CameraCallbackThread.CallbackHandler: void handleMessage(Message)>,<android.hardware.camera2.legacy.CameraDeviceUserShim.CameraCallbackThread.CallbackHandler: void handleMessage(Message)>,0,"{
    try {
        switch(msg.what) {
            case CAMERA_ERROR:
                {
                    int errorCode = msg.arg1;
                    CaptureResultExtras resultExtras = (CaptureResultExtras) msg.obj;
                    mCallbacks.onDeviceError(errorCode, resultExtras);
                    break;
                }
            case CAMERA_IDLE:
                mCallbacks.onDeviceIdle();
                break;
            case CAPTURE_STARTED:
                {
                    long timestamp = msg.arg2 & 0xFFFFFFFFL;
                    timestamp = (timestamp << 32) | (msg.arg1 & 0xFFFFFFFFL);
                    CaptureResultExtras resultExtras = (CaptureResultExtras) msg.obj;
                    mCallbacks.onCaptureStarted(resultExtras, timestamp);
                    break;
                }
            case RESULT_RECEIVED:
                {
                    Object[] resultArray = (Object[]) msg.obj;
                    CameraMetadataNative result = (CameraMetadataNative) resultArray[0];
                    CaptureResultExtras resultExtras = (CaptureResultExtras) resultArray[1];
                    mCallbacks.onResultReceived(result, resultExtras);
                    break;
                }
            default:
                throw new IllegalArgumentException(""Unknown callback message "" + msg.what);
        }
    } catch (RemoteException e) {
        throw new IllegalStateException(""Received remote exception during camera callback "" + msg.what, e);
    }
}","{
    try {
        switch(msg.what) {
            case CAMERA_ERROR:
                {
                    int errorCode = msg.arg1;
                    CaptureResultExtras resultExtras = (CaptureResultExtras) msg.obj;
                    mCallbacks.onDeviceError(errorCode, resultExtras);
                    break;
                }
            case CAMERA_IDLE:
                mCallbacks.onDeviceIdle();
                break;
            case CAPTURE_STARTED:
                {
                    long timestamp = msg.arg2 & 0xFFFFFFFFL;
                    timestamp = (timestamp << 32) | (msg.arg1 & 0xFFFFFFFFL);
                    CaptureResultExtras resultExtras = (CaptureResultExtras) msg.obj;
                    mCallbacks.onCaptureStarted(resultExtras, timestamp);
                    break;
                }
            case RESULT_RECEIVED:
                {
                    Object[] resultArray = (Object[]) msg.obj;
                    CameraMetadataNative result = (CameraMetadataNative) resultArray[0];
                    CaptureResultExtras resultExtras = (CaptureResultExtras) resultArray[1];
                    mCallbacks.onResultReceived(result, resultExtras);
                    break;
                }
            case PREPARED:
                {
                    int streamId = msg.arg1;
                    mCallbacks.onPrepared(streamId);
                    break;
                }
            default:
                throw new IllegalArgumentException(""Unknown callback message "" + msg.what);
        }
    } catch (RemoteException e) {
        throw new IllegalStateException(""Received remote exception during camera callback "" + msg.what, e);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"A new case 'PREPARED' is added to the switch statement to handle a new message type, which is a change in the control dependency (3). No other changes took place in the exception handling or return statements. However, since a new callback method is invoked (mCallbacks.onPrepared(streamId)), this also qualifies as an other statement change (4).","The addition of a new case in the switch statement could change the behavior of the handleMessage method by introducing a new callback method for certain message types, leading to the potential for different outcomes. This qualifies as a change that could cause different return values or behaviors, so the CI type is 1."
611,<android.widget.OverScroller: float getCurrVelocity()>,22,23,<android.widget.OverScroller: float getCurrVelocity()>,<android.widget.OverScroller: float getCurrVelocity()>,0,"{
    float squaredNorm = mScrollerX.mCurrVelocity * mScrollerX.mCurrVelocity;
    squaredNorm += mScrollerY.mCurrVelocity * mScrollerY.mCurrVelocity;
    return FloatMath.sqrt(squaredNorm);
}","{
    return (float) Math.hypot(mScrollerX.mCurrVelocity, mScrollerY.mCurrVelocity);
}",1,"/**
 * Returns the absolute value of the current velocity.
 *
 * @return The original velocity less the deceleration, norm of the X and Y velocity vector.
 */
","/**
 * Returns the absolute value of the current velocity.
 *
 * @return The original velocity less the deceleration, norm of the X and Y velocity vector.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement's implementation has changed from using FloatMath.sqrt to Math.hypot, which also changes the way to calculate the current velocity. Additionally, FloatMath.sqrt method is deprecated and is replaced with java.lang.Math methods, which is a change in the dependent API, so the code change types are 1 and 5.","This change could potentially cause the API to return a different float value due to a different calculation method, even if for the same inputs, thus a CI for type 1 is given."
613,"<android.widget.SimpleAdapter: View getView(int,View,ViewGroup)>",22,23,"<android.widget.SimpleAdapter: View getView(int,View,ViewGroup)>","<android.widget.SimpleAdapter: View getView(int,View,ViewGroup)>",0,"{
    return createViewFromResource(position, convertView, parent, mResource);
}","{
    return createViewFromResource(mInflater, position, convertView, parent, mResource);
}",1,"/**
 * @see android.widget.Adapter#getView(int, View, ViewGroup)
 */
","/**
 * @see android.widget.Adapter#getView(int, View, ViewGroup)
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method call createViewFromResource has an additional parameter mInflater in its newer version, which infers a difference in the method's signature. Therefore, the change is categorized as a dependent API change (5).","There is no compatibility issue detected, as the additional argument does not alter the method's behaviour from an external perspective. The method still returns a View, and its signature remains the same. Thus, the change does not lead to a potential different return value or exception thrown. Therefore, the CI type is 0."
615,"<android.app.admin.DevicePolicyManager: int setStorageEncryption(ComponentName,boolean)>",22,23,"<android.app.admin.DevicePolicyManager: int setStorageEncryption(ComponentName,boolean)>","<android.app.admin.DevicePolicyManager: int setStorageEncryption(ComponentName,boolean)>",0,"{
    if (mService != null) {
        try {
            return mService.setStorageEncryption(admin, encrypt, UserHandle.myUserId());
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
    return ENCRYPTION_STATUS_UNSUPPORTED;
}","{
    if (mService != null) {
        try {
            return mService.setStorageEncryption(admin, encrypt);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
    return ENCRYPTION_STATUS_UNSUPPORTED;
}",1,"/**
 * Called by an application that is administering the device to
 * request that the storage system be encrypted.
 *
 * <p>When multiple device administrators attempt to control device
 * encryption, the most secure, supported setting will always be
 * used.  If any device administrator requests device encryption,
 * it will be enabled;  Conversely, if a device administrator
 * attempts to disable device encryption while another
 * device administrator has enabled it, the call to disable will
 * fail (most commonly returning {@link #ENCRYPTION_STATUS_ACTIVE}).
 *
 * <p>This policy controls encryption of the secure (application data) storage area.  Data
 * written to other storage areas may or may not be encrypted, and this policy does not require
 * or control the encryption of any other storage areas.
 * There is one exception:  If {@link android.os.Environment#isExternalStorageEmulated()} is
 * {@code true}, then the directory returned by
 * {@link android.os.Environment#getExternalStorageDirectory()} must be written to disk
 * within the encrypted storage area.
 *
 * <p>Important Note:  On some devices, it is possible to encrypt storage without requiring
 * the user to create a device PIN or Password.  In this case, the storage is encrypted, but
 * the encryption key may not be fully secured.  For maximum security, the administrator should
 * also require (and check for) a pattern, PIN, or password.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param encrypt true to request encryption, false to release any previous request
 * @return the new request status (for all active admins) - will be one of
 * {@link #ENCRYPTION_STATUS_UNSUPPORTED}, {@link #ENCRYPTION_STATUS_INACTIVE}, or
 * {@link #ENCRYPTION_STATUS_ACTIVE}.  This is the value of the requests;  Use
 * {@link #getStorageEncryptionStatus()} to query the actual device state.
 */
","/**
 * Called by an application that is administering the device to
 * request that the storage system be encrypted.
 *
 * <p>When multiple device administrators attempt to control device
 * encryption, the most secure, supported setting will always be
 * used.  If any device administrator requests device encryption,
 * it will be enabled;  Conversely, if a device administrator
 * attempts to disable device encryption while another
 * device administrator has enabled it, the call to disable will
 * fail (most commonly returning {@link #ENCRYPTION_STATUS_ACTIVE}).
 *
 * <p>This policy controls encryption of the secure (application data) storage area.  Data
 * written to other storage areas may or may not be encrypted, and this policy does not require
 * or control the encryption of any other storage areas.
 * There is one exception:  If {@link android.os.Environment#isExternalStorageEmulated()} is
 * {@code true}, then the directory returned by
 * {@link android.os.Environment#getExternalStorageDirectory()} must be written to disk
 * within the encrypted storage area.
 *
 * <p>Important Note:  On some devices, it is possible to encrypt storage without requiring
 * the user to create a device PIN or Password.  In this case, the storage is encrypted, but
 * the encryption key may not be fully secured.  For maximum security, the administrator should
 * also require (and check for) a pattern, PIN, or password.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param encrypt true to request encryption, false to release any previous request
 * @return the new request status (for all active admins) - will be one of
 * {@link #ENCRYPTION_STATUS_UNSUPPORTED}, {@link #ENCRYPTION_STATUS_INACTIVE}, or
 * {@link #ENCRYPTION_STATUS_ACTIVE}.  This is the value of the requests;  Use
 * {@link #getStorageEncryptionStatus()} to query the actual device state.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The change from setStorageEncryption(admin, encrypt, UserHandle.myUserId()) to setStorageEncryption(admin, encrypt) indicates that a parameter from the method call has been removed, which is a dependent API change. So the code change type is 5.","There is no Compatibility Issue because the removed parameter UserHandle.myUserId() is internally called and managed within the same API call rather than changing the method's behavior seen by the caller. It doesn't affect the variable returned by this method or the exceptions it may throw. The change is presumed to have no impact on current applications using this method, as the implementation detail is still abstracted away from the user. Therefore, the CI type is 0."
616,<android.widget.CalendarViewMaterialDelegate: int getDateTextAppearance()>,22,23,<android.widget.CalendarViewMaterialDelegate: int getDateTextAppearance()>,<android.widget.CalendarViewMaterialDelegate: int getDateTextAppearance()>,0,"{
    return 0;
}","{
    return mDayPickerView.getDayTextAppearance();
}",1,,,-1,[@Override],"[@StyleRes, @Override]",-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from returning a hardcoded '0' to returning the result of `mDayPickerView.getDayTextAppearance()`, which is a method call. This is a significant change, and hence the code change type is 1. Additionally, since the method appears to be relying on a dependent API (`mDayPickerView.getDayTextAppearance()`), it is also classified as type 5.","Since the late version of the method is not returning a hardcoded value anymore and instead is relying on another method, `mDayPickerView.getDayTextAppearance()`, which can potentially return different values based on the state of `mDayPickerView`, this is a potential Compatibility Issue of type 1, as the return value has potentially changed."
617,<android.os.ParcelFileDescriptor: ParcelFileDescriptor[] createSocketPair()>,22,23,<android.os.ParcelFileDescriptor: ParcelFileDescriptor[] createSocketPair()>,<android.os.ParcelFileDescriptor: ParcelFileDescriptor[] createSocketPair()>,0,"{
    try {
        final FileDescriptor fd0 = new FileDescriptor();
        final FileDescriptor fd1 = new FileDescriptor();
        Os.socketpair(AF_UNIX, SOCK_STREAM, 0, fd0, fd1);
        return new ParcelFileDescriptor[] { new ParcelFileDescriptor(fd0), new ParcelFileDescriptor(fd1) };
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}","{
    return createSocketPair(SOCK_STREAM);
}",1,"/**
 * Create two ParcelFileDescriptors structured as a pair of sockets
 * connected to each other. The two sockets are indistinguishable.
 */
","/**
 * Create two ParcelFileDescriptors structured as a pair of sockets
 * connected to each other. The two sockets are indistinguishable.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method implementation has changed to call another method ""createSocketPair(SOCK_STREAM);"" instead of directly creating the ParcelFileDescriptor array with the socket pair, which is a change in how the method body executes its logic (Other statement changed) and there is a change in which dependent API ""createSocketPair"" is used (Dependent API changed), making it a 4,5 code change type.","There is no Compatibility Issue detected. Although the implementation has been altered, the end result of creating a socket pair is preserved. The functionality appears to be the same, which would aim to return an array of ParcelFileDescriptor connected by a socket pair. There is no indication of different return values or types, nor a change in exception handling; hence, the API behavior should remain consistent."
618,<android.text.style.UnderlineSpan: int getSpanTypeId()>,22,23,<android.text.style.UnderlineSpan: int getSpanTypeId()>,<android.text.style.UnderlineSpan: int getSpanTypeId()>,0,"{
    return TextUtils.UNDERLINE_SPAN;
}","{
    return getSpanTypeIdInternal();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method body of getSpanTypeId() changed from directly returning a static field (TextUtils.UNDERLINE_SPAN) to calling another method (getSpanTypeIdInternal()), which is a dependent API change, so the code change types are 1 and 5.","The change in the method that is being called for the return statement indicates that there could be a potential change in the value returned by getSpanTypeId(), and thus the CI type is 1."
622,"<android.transition.Visibility: Animator onDisappear(ViewGroup,TransitionValues,int,TransitionValues,int)>",22,23,"<android.transition.Visibility: Animator onDisappear(ViewGroup,TransitionValues,int,TransitionValues,int)>","<android.transition.Visibility: Animator onDisappear(ViewGroup,TransitionValues,int,TransitionValues,int)>",0,"{
    if ((mMode & MODE_OUT) != MODE_OUT) {
        return null;
    }
    View startView = (startValues != null) ? startValues.view : null;
    View endView = (endValues != null) ? endValues.view : null;
    View overlayView = null;
    View viewToKeep = null;
    if (endView == null || endView.getParent() == null) {
        if (endView != null) {
            // endView was removed from its parent - add it to the overlay
            overlayView = endView;
        } else if (startView != null) {
            // it being removed from its current parent
            if (startView.getParent() == null) {
                // no parent - safe to use
                overlayView = startView;
            } else if (startView.getParent() instanceof View) {
                View startParent = (View) startView.getParent();
                TransitionValues startParentValues = getTransitionValues(startParent, true);
                TransitionValues endParentValues = getMatchedTransitionValues(startParent, true);
                VisibilityInfo parentVisibilityInfo = getVisibilityChangeInfo(startParentValues, endParentValues);
                if (!parentVisibilityInfo.visibilityChange) {
                    overlayView = TransitionUtils.copyViewImage(sceneRoot, startView, startParent);
                } else if (startParent.getParent() == null) {
                    int id = startParent.getId();
                    if (id != View.NO_ID && sceneRoot.findViewById(id) != null && mCanRemoveViews) {
                        // no parent, but its parent is unparented  but the parent
                        // hierarchy has been replaced by a new hierarchy with the same id
                        // and it is safe to un-parent startView
                        overlayView = startView;
                    }
                }
            }
        }
    } else {
        // visibility change
        if (endVisibility == View.INVISIBLE) {
            viewToKeep = endView;
        } else {
            // Becoming GONE
            if (startView == endView) {
                viewToKeep = endView;
            } else {
                overlayView = startView;
            }
        }
    }
    final int finalVisibility = endVisibility;
    final ViewGroup finalSceneRoot = sceneRoot;
    if (overlayView != null) {
        // TODO: Need to do this for general case of adding to overlay
        int[] screenLoc = (int[]) startValues.values.get(PROPNAME_SCREEN_LOCATION);
        int screenX = screenLoc[0];
        int screenY = screenLoc[1];
        int[] loc = new int[2];
        sceneRoot.getLocationOnScreen(loc);
        overlayView.offsetLeftAndRight((screenX - loc[0]) - overlayView.getLeft());
        overlayView.offsetTopAndBottom((screenY - loc[1]) - overlayView.getTop());
        sceneRoot.getOverlay().add(overlayView);
        Animator animator = onDisappear(sceneRoot, overlayView, startValues, endValues);
        if (animator == null) {
            sceneRoot.getOverlay().remove(overlayView);
        } else {
            final View finalOverlayView = overlayView;
            animator.addListener(new AnimatorListenerAdapter() {

                @Override
                public void onAnimationEnd(Animator animation) {
                    finalSceneRoot.getOverlay().remove(finalOverlayView);
                }
            });
        }
        return animator;
    }
    if (viewToKeep != null) {
        int originalVisibility = -1;
        final boolean isForcedVisibility = mForcedStartVisibility != -1 || mForcedEndVisibility != -1;
        if (!isForcedVisibility) {
            originalVisibility = viewToKeep.getVisibility();
            viewToKeep.setVisibility(View.VISIBLE);
        }
        Animator animator = onDisappear(sceneRoot, viewToKeep, startValues, endValues);
        if (animator != null) {
            final View finalViewToKeep = viewToKeep;
            animator.addListener(new AnimatorListenerAdapter() {

                boolean mCanceled = false;

                @Override
                public void onAnimationPause(Animator animation) {
                    if (!mCanceled && !isForcedVisibility) {
                        finalViewToKeep.setVisibility(finalVisibility);
                    }
                }

                @Override
                public void onAnimationResume(Animator animation) {
                    if (!mCanceled && !isForcedVisibility) {
                        finalViewToKeep.setVisibility(View.VISIBLE);
                    }
                }

                @Override
                public void onAnimationCancel(Animator animation) {
                    mCanceled = true;
                }

                @Override
                public void onAnimationEnd(Animator animation) {
                    if (!mCanceled) {
                        if (isForcedVisibility) {
                            finalViewToKeep.setTransitionAlpha(0);
                        } else {
                            finalViewToKeep.setVisibility(finalVisibility);
                        }
                    }
                }
            });
        } else if (!isForcedVisibility) {
            viewToKeep.setVisibility(originalVisibility);
        }
        return animator;
    }
    return null;
}","{
    if ((mMode & MODE_OUT) != MODE_OUT) {
        return null;
    }
    View startView = (startValues != null) ? startValues.view : null;
    View endView = (endValues != null) ? endValues.view : null;
    View overlayView = null;
    View viewToKeep = null;
    if (endView == null || endView.getParent() == null) {
        if (endView != null) {
            // endView was removed from its parent - add it to the overlay
            overlayView = endView;
        } else if (startView != null) {
            // it being removed from its current parent
            if (startView.getParent() == null) {
                // no parent - safe to use
                overlayView = startView;
            } else if (startView.getParent() instanceof View) {
                View startParent = (View) startView.getParent();
                TransitionValues startParentValues = getTransitionValues(startParent, true);
                TransitionValues endParentValues = getMatchedTransitionValues(startParent, true);
                VisibilityInfo parentVisibilityInfo = getVisibilityChangeInfo(startParentValues, endParentValues);
                if (!parentVisibilityInfo.visibilityChange) {
                    overlayView = TransitionUtils.copyViewImage(sceneRoot, startView, startParent);
                } else if (startParent.getParent() == null) {
                    int id = startParent.getId();
                    if (id != View.NO_ID && sceneRoot.findViewById(id) != null && mCanRemoveViews) {
                        // no parent, but its parent is unparented  but the parent
                        // hierarchy has been replaced by a new hierarchy with the same id
                        // and it is safe to un-parent startView
                        overlayView = startView;
                    }
                }
            }
        }
    } else {
        // visibility change
        if (endVisibility == View.INVISIBLE) {
            viewToKeep = endView;
        } else {
            // Becoming GONE
            if (startView == endView) {
                viewToKeep = endView;
            } else {
                overlayView = startView;
            }
        }
    }
    final int finalVisibility = endVisibility;
    final ViewGroup finalSceneRoot = sceneRoot;
    if (overlayView != null) {
        // TODO: Need to do this for general case of adding to overlay
        int[] screenLoc = (int[]) startValues.values.get(PROPNAME_SCREEN_LOCATION);
        int screenX = screenLoc[0];
        int screenY = screenLoc[1];
        int[] loc = new int[2];
        sceneRoot.getLocationOnScreen(loc);
        overlayView.offsetLeftAndRight((screenX - loc[0]) - overlayView.getLeft());
        overlayView.offsetTopAndBottom((screenY - loc[1]) - overlayView.getTop());
        sceneRoot.getOverlay().add(overlayView);
        Animator animator = onDisappear(sceneRoot, overlayView, startValues, endValues);
        if (animator == null) {
            sceneRoot.getOverlay().remove(overlayView);
        } else {
            final View finalOverlayView = overlayView;
            addListener(new TransitionListenerAdapter() {

                @Override
                public void onTransitionEnd(Transition transition) {
                    finalSceneRoot.getOverlay().remove(finalOverlayView);
                }
            });
        }
        return animator;
    }
    if (viewToKeep != null) {
        int originalVisibility = -1;
        final boolean isForcedVisibility = mForcedStartVisibility != -1 || mForcedEndVisibility != -1;
        if (!isForcedVisibility) {
            originalVisibility = viewToKeep.getVisibility();
            viewToKeep.setTransitionVisibility(View.VISIBLE);
        }
        Animator animator = onDisappear(sceneRoot, viewToKeep, startValues, endValues);
        if (animator != null) {
            DisappearListener disappearListener = new DisappearListener(viewToKeep, finalVisibility, isForcedVisibility);
            animator.addListener(disappearListener);
            animator.addPauseListener(disappearListener);
            addListener(disappearListener);
        } else if (!isForcedVisibility) {
            viewToKeep.setTransitionVisibility(originalVisibility);
        }
        return animator;
    }
    return null;
}",1,"/**
 * Subclasses should override this method or
 * {@link #onDisappear(ViewGroup, View, TransitionValues, TransitionValues)}
 * if they need to create an Animator when targets disappear.
 * The method should only be called by the Visibility class; it is
 * not intended to be called from external classes.
 * <p>
 * The default implementation of this method attempts to find a View to use to call
 * {@link #onDisappear(ViewGroup, View, TransitionValues, TransitionValues)},
 * based on the situation of the View in the View hierarchy. For example,
 * if a View was simply removed from its parent, then the View will be added
 * into a {@link android.view.ViewGroupOverlay} and passed as the <code>view</code>
 * parameter in {@link #onDisappear(ViewGroup, View, TransitionValues, TransitionValues)}.
 * If a visible View is changed to be {@link View#GONE} or {@link View#INVISIBLE},
 * then it can be used as the <code>view</code> and the visibility will be changed
 * to {@link View#VISIBLE} for the duration of the animation. However, if a View
 * is in a hierarchy which is also altering its visibility, the situation can be
 * more complicated. In general, if a view that is no longer in the hierarchy in
 * the end scene still has a parent (so its parent hierarchy was removed, but it
 * was not removed from its parent), then it will be left alone to avoid side-effects from
 * improperly removing it from its parent. The only exception to this is if
 * the previous {@link Scene} was {@link Scene#getSceneForLayout(ViewGroup, int,
 * android.content.Context) created from a layout resource file}, then it is considered
 * safe to un-parent the starting scene view in order to make it disappear.</p>
 *
 * @param sceneRoot The root of the transition hierarchy
 * @param startValues The target values in the start scene
 * @param startVisibility The target visibility in the start scene
 * @param endValues The target values in the end scene
 * @param endVisibility The target visibility in the end scene
 * @return An Animator to be started at the appropriate time in the
 * overall transition for this scene change. A null value means no animation
 * should be run.
 */
","/**
 * Subclasses should override this method or
 * {@link #onDisappear(ViewGroup, View, TransitionValues, TransitionValues)}
 * if they need to create an Animator when targets disappear.
 * The method should only be called by the Visibility class; it is
 * not intended to be called from external classes.
 * <p>
 * The default implementation of this method attempts to find a View to use to call
 * {@link #onDisappear(ViewGroup, View, TransitionValues, TransitionValues)},
 * based on the situation of the View in the View hierarchy. For example,
 * if a View was simply removed from its parent, then the View will be added
 * into a {@link android.view.ViewGroupOverlay} and passed as the <code>view</code>
 * parameter in {@link #onDisappear(ViewGroup, View, TransitionValues, TransitionValues)}.
 * If a visible View is changed to be {@link View#GONE} or {@link View#INVISIBLE},
 * then it can be used as the <code>view</code> and the visibility will be changed
 * to {@link View#VISIBLE} for the duration of the animation. However, if a View
 * is in a hierarchy which is also altering its visibility, the situation can be
 * more complicated. In general, if a view that is no longer in the hierarchy in
 * the end scene still has a parent (so its parent hierarchy was removed, but it
 * was not removed from its parent), then it will be left alone to avoid side-effects from
 * improperly removing it from its parent. The only exception to this is if
 * the previous {@link Scene} was {@link Scene#getSceneForLayout(ViewGroup, int,
 * android.content.Context) created from a layout resource file}, then it is considered
 * safe to un-parent the starting scene view in order to make it disappear.</p>
 *
 * @param sceneRoot The root of the transition hierarchy
 * @param startValues The target values in the start scene
 * @param startVisibility The target visibility in the start scene
 * @param endValues The target values in the end scene
 * @param endVisibility The target visibility in the end scene
 * @return An Animator to be started at the appropriate time in the
 * overall transition for this scene change. A null value means no animation
 * should be run.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
625,"<android.transition.TransitionInflater: TransitionManager inflateTransitionManager(int,ViewGroup)>",22,23,"<android.transition.TransitionInflater: TransitionManager inflateTransitionManager(int,ViewGroup)>","<android.transition.TransitionInflater: TransitionManager inflateTransitionManager(int,ViewGroup)>",0,"{
    XmlResourceParser parser = mContext.getResources().getXml(resource);
    try {
        return createTransitionManagerFromXml(parser, Xml.asAttributeSet(parser), sceneRoot);
    } catch (XmlPullParserException e) {
        InflateException ex = new InflateException(e.getMessage());
        ex.initCause(e);
        throw ex;
    } catch (IOException e) {
        InflateException ex = new InflateException(parser.getPositionDescription() + "": "" + e.getMessage());
        ex.initCause(e);
        throw ex;
    } finally {
        parser.close();
    }
}","{
    // noinspection ResourceType
    XmlResourceParser parser = mContext.getResources().getXml(resource);
    try {
        return createTransitionManagerFromXml(parser, Xml.asAttributeSet(parser), sceneRoot);
    } catch (XmlPullParserException e) {
        InflateException ex = new InflateException(e.getMessage());
        ex.initCause(e);
        throw ex;
    } catch (IOException e) {
        InflateException ex = new InflateException(parser.getPositionDescription() + "": "" + e.getMessage());
        ex.initCause(e);
        throw ex;
    } finally {
        parser.close();
    }
}",1,"/**
 * Loads a {@link TransitionManager} object from a resource
 *
 * @param resource The resource id of the transition manager to load
 * @return The loaded TransitionManager object
 * @throws android.content.res.Resources.NotFoundException when the
 * transition manager cannot be loaded
 */
","/**
 * Loads a {@link TransitionManager} object from a resource
 *
 * @param resource The resource id of the transition manager to load
 * @return The loaded TransitionManager object
 * @throws android.content.res.Resources.NotFoundException when the
 * transition manager cannot be loaded
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"There are no differences between the early and the late versions of the implementation besides a comment added // noinspection ResourceType. Since comments do not affect the behavior of the code, no change is detected in the code.","Since there is no change in the implementation between the two versions, there is no Compatibility Issue."
626,<android.net.DhcpStateMachine.WaitBeforeStartState: boolean processMessage(Message)>,22,23,<android.net.DhcpStateMachine.WaitBeforeStartState: boolean processMessage(Message)>,<android.net.DhcpStateMachine.WaitBeforeStartState: boolean processMessage(Message)>,0,"{
    boolean retValue = HANDLED;
    if (DBG)
        Log.d(TAG, getName() + message.toString() + ""\n"");
    switch(message.what) {
        case CMD_PRE_DHCP_ACTION_COMPLETE:
            if (runDhcp(DhcpAction.START)) {
                transitionTo(mRunningState);
            } else {
                transitionTo(mStoppedState);
            }
            break;
        case CMD_STOP_DHCP:
            transitionTo(mStoppedState);
            break;
        case CMD_START_DHCP:
            // ignore
            break;
        default:
            retValue = NOT_HANDLED;
            break;
    }
    return retValue;
}","{
    boolean retValue = HANDLED;
    if (DBG)
        Log.d(TAG, getName() + message.toString() + ""\n"");
    switch(message.what) {
        case CMD_PRE_DHCP_ACTION_COMPLETE:
            if (runDhcpStart()) {
                transitionTo(mRunningState);
            } else {
                transitionTo(mPollingState);
            }
            break;
        case CMD_STOP_DHCP:
            transitionTo(mStoppedState);
            break;
        case CMD_START_DHCP:
            // ignore
            break;
        default:
            retValue = NOT_HANDLED;
            break;
    }
    return retValue;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,5",0,"The dependent API `runDhcp(DhcpAction.START)` in the early version has been changed to `runDhcpStart()` in the late version, which is a method signature change, so the code change type includes 5. Additionally, the transition state has been changed from `transitionTo(mStoppedState)` to `transitionTo(mPollingState)` within the `CMD_PRE_DHCP_ACTION_COMPLETE` case which changes a control dependency (switch case action), so the code change type includes 3.","There is no Compatibility Issue because all the cases in the switch return the same boolean value (`retValue`) as before, and the default action remains unchanged. Changes inside switch cases do not affect the returned boolean value, which is determined by whether or not the message is `HANDLED` or `NOT_HANDLED`. The internal state transition to a different state (`mPollingState` instead of `mStoppedState`) does not affect the return value, thus it does not directly lead to a Compatibility Issue based on the results provided from this API."
627,"<android.hardware.camera2.CameraManager: void openCamera(String,StateCallback,Handler)>",22,23,"<android.hardware.camera2.CameraManager: void openCamera(String,StateCallback,Handler)>","<android.hardware.camera2.CameraManager: void openCamera(String,StateCallback,Handler)>",0,"{
    if (cameraId == null) {
        throw new IllegalArgumentException(""cameraId was null"");
    } else if (callback == null) {
        throw new IllegalArgumentException(""callback was null"");
    } else if (handler == null) {
        if (Looper.myLooper() != null) {
            handler = new Handler();
        } else {
            throw new IllegalArgumentException(""Looper doesn't exist in the calling thread"");
        }
    }
    openCameraDeviceUserAsync(cameraId, callback, handler);
}","{
    if (cameraId == null) {
        throw new IllegalArgumentException(""cameraId was null"");
    } else if (callback == null) {
        throw new IllegalArgumentException(""callback was null"");
    } else if (handler == null) {
        if (Looper.myLooper() != null) {
            handler = new Handler();
        } else {
            throw new IllegalArgumentException(""Handler argument is null, but no looper exists in the calling thread"");
        }
    }
    openCameraDeviceUserAsync(cameraId, callback, handler);
}",1,"/**
 * Open a connection to a camera with the given ID.
 *
 * <p>Use {@link #getCameraIdList} to get the list of available camera
 * devices. Note that even if an id is listed, open may fail if the device
 * is disconnected between the calls to {@link #getCameraIdList} and
 * {@link #openCamera}.</p>
 *
 * <p>Once the camera is successfully opened, {@link CameraDevice.StateCallback#onOpened} will
 * be invoked with the newly opened {@link CameraDevice}. The camera device can then be set up
 * for operation by calling {@link CameraDevice#createCaptureSession} and
 * {@link CameraDevice#createCaptureRequest}</p>
 *
 * <!--
 * <p>Since the camera device will be opened asynchronously, any asynchronous operations done
 * on the returned CameraDevice instance will be queued up until the device startup has
 * completed and the callback's {@link CameraDevice.StateCallback#onOpened onOpened} method is
 * called. The pending operations are then processed in order.</p>
 * -->
 * <p>If the camera becomes disconnected during initialization
 * after this function call returns,
 * {@link CameraDevice.StateCallback#onDisconnected} with a
 * {@link CameraDevice} in the disconnected state (and
 * {@link CameraDevice.StateCallback#onOpened} will be skipped).</p>
 *
 * <p>If opening the camera device fails, then the device callback's
 * {@link CameraDevice.StateCallback#onError onError} method will be called, and subsequent
 * calls on the camera device will throw a {@link CameraAccessException}.</p>
 *
 * @param cameraId
 * The unique identifier of the camera device to open
 * @param callback
 * The callback which is invoked once the camera is opened
 * @param handler
 * The handler on which the callback should be invoked, or
 * {@code null} to use the current thread's {@link android.os.Looper looper}.
 *
 * @throws CameraAccessException if the camera is disabled by device policy,
 * or the camera has become or was disconnected.
 *
 * @throws IllegalArgumentException if cameraId or the callback was null,
 * or the cameraId does not match any currently or previously available
 * camera device.
 *
 * @throws SecurityException if the application does not have permission to
 * access the camera
 *
 * @see #getCameraIdList
 * @see android.app.admin.DevicePolicyManager#setCameraDisabled
 */
","/**
 * Open a connection to a camera with the given ID.
 *
 * <p>Use {@link #getCameraIdList} to get the list of available camera
 * devices. Note that even if an id is listed, open may fail if the device
 * is disconnected between the calls to {@link #getCameraIdList} and
 * {@link #openCamera}, or if a higher-priority camera API client begins using the
 * camera device.</p>
 *
 * <p>As of API level 23, devices for which the
 * {@link AvailabilityCallback#onCameraUnavailable(String)} callback has been called due to the
 * device being in use by a lower-priority, background camera API client can still potentially
 * be opened by calling this method when the calling camera API client has a higher priority
 * than the current camera API client using this device.  In general, if the top, foreground
 * activity is running within your application process, your process will be given the highest
 * priority when accessing the camera, and this method will succeed even if the camera device is
 * in use by another camera API client. Any lower-priority application that loses control of the
 * camera in this way will receive an
 * {@link android.hardware.camera2.CameraDevice.StateCallback#onDisconnected} callback.</p>
 *
 * <p>Once the camera is successfully opened, {@link CameraDevice.StateCallback#onOpened} will
 * be invoked with the newly opened {@link CameraDevice}. The camera device can then be set up
 * for operation by calling {@link CameraDevice#createCaptureSession} and
 * {@link CameraDevice#createCaptureRequest}</p>
 *
 * <!--
 * <p>Since the camera device will be opened asynchronously, any asynchronous operations done
 * on the returned CameraDevice instance will be queued up until the device startup has
 * completed and the callback's {@link CameraDevice.StateCallback#onOpened onOpened} method is
 * called. The pending operations are then processed in order.</p>
 * -->
 * <p>If the camera becomes disconnected during initialization
 * after this function call returns,
 * {@link CameraDevice.StateCallback#onDisconnected} with a
 * {@link CameraDevice} in the disconnected state (and
 * {@link CameraDevice.StateCallback#onOpened} will be skipped).</p>
 *
 * <p>If opening the camera device fails, then the device callback's
 * {@link CameraDevice.StateCallback#onError onError} method will be called, and subsequent
 * calls on the camera device will throw a {@link CameraAccessException}.</p>
 *
 * @param cameraId
 * The unique identifier of the camera device to open
 * @param callback
 * The callback which is invoked once the camera is opened
 * @param handler
 * The handler on which the callback should be invoked, or
 * {@code null} to use the current thread's {@link android.os.Looper looper}.
 *
 * @throws CameraAccessException if the camera is disabled by device policy,
 * has been disconnected, or is being used by a higher-priority camera API client.
 *
 * @throws IllegalArgumentException if cameraId or the callback was null,
 * or the cameraId does not match any currently or previously available
 * camera device.
 *
 * @throws SecurityException if the application does not have permission to
 * access the camera
 *
 * @see #getCameraIdList
 * @see android.app.admin.DevicePolicyManager#setCameraDisabled
 */
",-1,,[@RequiresPermission(android.Manifest.permission.CAMERA)],-1,-1,-1,-1,-1,-1,4,0,"The only change in the code is the message argument for the IllegalArgumentException when the handler is null and there is no Looper in the calling thread. This change does not affect the behavior or outcome of the method invocation, so it is classified as other statements changed, type 4.","There is no Compatibility Issue since there is no change in behavior or logic of the method, the exception type remains the same and even with a different error message, it does not affect how the API works or handle exceptions from an API usage perspective. The change in the exception message does not lead to different return values or exception handlings. The Compatibility Issue type is 0."
628,<android.text.style.SuggestionSpan: int getSpanTypeId()>,22,23,<android.text.style.SuggestionSpan: int getSpanTypeId()>,<android.text.style.SuggestionSpan: int getSpanTypeId()>,0,"{
    return TextUtils.SUGGESTION_SPAN;
}","{
    return getSpanTypeIdInternal();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The implementation has changed from returning a constant directly to calling getSpanTypeIdInternal(), which represents a change to a dependent API, hence the change type is 5.","Since the dependent API getSpanTypeIdInternal() could be designed to return the same value as the constant TextUtils.SUGGESTION_SPAN, there is no direct evidence of a CI based solely on the provided code. Additional information about the implementation of getSpanTypeIdInternal() would be required to determine if a CI exists. With current information, we should consider that there is no CI."
629,<android.animation.KeyframeSet: Object getValue(float)>,22,23,<android.animation.KeyframeSet: Object getValue(float)>,<android.animation.KeyframeSet: Object getValue(float)>,0,"{
    // Special-case optimization for the common case of only two keyframes
    if (mNumKeyframes == 2) {
        if (mInterpolator != null) {
            fraction = mInterpolator.getInterpolation(fraction);
        }
        return mEvaluator.evaluate(fraction, mFirstKeyframe.getValue(), mLastKeyframe.getValue());
    }
    if (fraction <= 0f) {
        final Keyframe nextKeyframe = mKeyframes.get(1);
        final TimeInterpolator interpolator = nextKeyframe.getInterpolator();
        if (interpolator != null) {
            fraction = interpolator.getInterpolation(fraction);
        }
        final float prevFraction = mFirstKeyframe.getFraction();
        float intervalFraction = (fraction - prevFraction) / (nextKeyframe.getFraction() - prevFraction);
        return mEvaluator.evaluate(intervalFraction, mFirstKeyframe.getValue(), nextKeyframe.getValue());
    } else if (fraction >= 1f) {
        final Keyframe prevKeyframe = mKeyframes.get(mNumKeyframes - 2);
        final TimeInterpolator interpolator = mLastKeyframe.getInterpolator();
        if (interpolator != null) {
            fraction = interpolator.getInterpolation(fraction);
        }
        final float prevFraction = prevKeyframe.getFraction();
        float intervalFraction = (fraction - prevFraction) / (mLastKeyframe.getFraction() - prevFraction);
        return mEvaluator.evaluate(intervalFraction, prevKeyframe.getValue(), mLastKeyframe.getValue());
    }
    Keyframe prevKeyframe = mFirstKeyframe;
    for (int i = 1; i < mNumKeyframes; ++i) {
        Keyframe nextKeyframe = mKeyframes.get(i);
        if (fraction < nextKeyframe.getFraction()) {
            final TimeInterpolator interpolator = nextKeyframe.getInterpolator();
            if (interpolator != null) {
                fraction = interpolator.getInterpolation(fraction);
            }
            final float prevFraction = prevKeyframe.getFraction();
            float intervalFraction = (fraction - prevFraction) / (nextKeyframe.getFraction() - prevFraction);
            return mEvaluator.evaluate(intervalFraction, prevKeyframe.getValue(), nextKeyframe.getValue());
        }
        prevKeyframe = nextKeyframe;
    }
    // shouldn't reach here
    return mLastKeyframe.getValue();
}","{
    // Special-case optimization for the common case of only two keyframes
    if (mNumKeyframes == 2) {
        if (mInterpolator != null) {
            fraction = mInterpolator.getInterpolation(fraction);
        }
        return mEvaluator.evaluate(fraction, mFirstKeyframe.getValue(), mLastKeyframe.getValue());
    }
    if (fraction <= 0f) {
        final Keyframe nextKeyframe = mKeyframes.get(1);
        final TimeInterpolator interpolator = nextKeyframe.getInterpolator();
        if (interpolator != null) {
            fraction = interpolator.getInterpolation(fraction);
        }
        final float prevFraction = mFirstKeyframe.getFraction();
        float intervalFraction = (fraction - prevFraction) / (nextKeyframe.getFraction() - prevFraction);
        return mEvaluator.evaluate(intervalFraction, mFirstKeyframe.getValue(), nextKeyframe.getValue());
    } else if (fraction >= 1f) {
        final Keyframe prevKeyframe = mKeyframes.get(mNumKeyframes - 2);
        final TimeInterpolator interpolator = mLastKeyframe.getInterpolator();
        if (interpolator != null) {
            fraction = interpolator.getInterpolation(fraction);
        }
        final float prevFraction = prevKeyframe.getFraction();
        float intervalFraction = (fraction - prevFraction) / (mLastKeyframe.getFraction() - prevFraction);
        return mEvaluator.evaluate(intervalFraction, prevKeyframe.getValue(), mLastKeyframe.getValue());
    }
    Keyframe prevKeyframe = mFirstKeyframe;
    for (int i = 1; i < mNumKeyframes; ++i) {
        Keyframe nextKeyframe = mKeyframes.get(i);
        if (fraction < nextKeyframe.getFraction()) {
            final TimeInterpolator interpolator = nextKeyframe.getInterpolator();
            final float prevFraction = prevKeyframe.getFraction();
            float intervalFraction = (fraction - prevFraction) / (nextKeyframe.getFraction() - prevFraction);
            // Apply interpolator on the proportional duration.
            if (interpolator != null) {
                intervalFraction = interpolator.getInterpolation(intervalFraction);
            }
            return mEvaluator.evaluate(intervalFraction, prevKeyframe.getValue(), nextKeyframe.getValue());
        }
        prevKeyframe = nextKeyframe;
    }
    // shouldn't reach here
    return mLastKeyframe.getValue();
}",1,"/**
 * Gets the animated value, given the elapsed fraction of the animation (interpolated by the
 * animation's interpolator) and the evaluator used to calculate in-between values. This
 * function maps the input fraction to the appropriate keyframe interval and a fraction
 * between them and returns the interpolated value. Note that the input fraction may fall
 * outside the [0-1] bounds, if the animation's interpolator made that happen (e.g., a
 * spring interpolation that might send the fraction past 1.0). We handle this situation by
 * just using the two keyframes at the appropriate end when the value is outside those bounds.
 *
 * @param fraction The elapsed fraction of the animation
 * @return The animated value.
 */
","/**
 * Gets the animated value, given the elapsed fraction of the animation (interpolated by the
 * animation's interpolator) and the evaluator used to calculate in-between values. This
 * function maps the input fraction to the appropriate keyframe interval and a fraction
 * between them and returns the interpolated value. Note that the input fraction may fall
 * outside the [0-1] bounds, if the animation's interpolator made that happen (e.g., a
 * spring interpolation that might send the fraction past 1.0). We handle this situation by
 * just using the two keyframes at the appropriate end when the value is outside those bounds.
 *
 * @param fraction The elapsed fraction of the animation
 * @return The animated value.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The difference between the Early_Version and the Late_Version is located in the loop for calculating the `intervalFraction` when the `fraction < nextKeyframe.getFraction()` condition is true. In the Early_Version, `fraction` is interpolated before calculating `intervalFraction` whereas in the Late_Version, the interpolation is applied to `intervalFraction` after it is calculated. There is a change in other statements because the point at which the interpolation calculation takes place has been moved, resulting in a change type of 3,4.","Since the interpolation is applied at a different point in the calculation of the Keyframe value, there is a potential behavior change in how the `intervalFraction` is calculated, which could lead to a different return value from the `mEvaluator.evaluate` calls. Therefore, the API could return different values, indicating a CI type of 1."
630,<android.view.textservice.SpellCheckerSession.SpellCheckerSessionListenerImpl: boolean isDisconnected()>,22,23,<android.view.textservice.SpellCheckerSession.SpellCheckerSessionListenerImpl: boolean isDisconnected()>,<android.view.textservice.SpellCheckerSession.SpellCheckerSessionListenerImpl: boolean isDisconnected()>,0,"{
    return mOpened && mISpellCheckerSession == null;
}","{
    synchronized (this) {
        return mState != STATE_CONNECTED;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement has completely changed from returning the evaluation of `mOpened && mISpellCheckerSession == null` to returning the evaluation of `mState != STATE_CONNECTED` within a `synchronized` block. This indicates a significant change in the logic used to determine if the class is 'disconnected', so the code change type is 1.","Given that the logic for determining disconnection state relies on entirely different conditions in the new implementation, clients relying on this method may see a behavioral change when upgrading from early version to late version. Therefore, the CI type is 1."
631,<android.webkit.WebView: int findAll(String)>,22,23,<android.webkit.WebView: int findAll(String)>,<android.webkit.WebView: int findAll(String)>,0,"{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, ""findAll"");
    StrictMode.noteSlowCall(""findAll blocks UI: prefer findAllAsync"");
    return mProvider.findAll(find);
}","{
    checkThread();
    StrictMode.noteSlowCall(""findAll blocks UI: prefer findAllAsync"");
    return mProvider.findAll(find);
}",1,"/**
 * Finds all instances of find on the page and highlights them.
 * Notifies any registered {@link FindListener}.
 *
 * @param find the string to find
 * @return the number of occurances of the String ""find"" that were found
 * @deprecated {@link #findAllAsync} is preferred.
 * @see #setFindListener
 */
","/**
 * Finds all instances of find on the page and highlights them.
 * Notifies any registered {@link FindListener}.
 *
 * @param find the string to find
 * @return the number of occurances of the String ""find"" that were found
 * @deprecated {@link #findAllAsync} is preferred.
 * @see #setFindListener
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,4,0,"The only code change is that the tracing log statement Log.d(LOGTAG, ""findAll"") has been removed. This is an example of an Other statement changed and is categorized as type 4.","The removal of the log statement does not affect the API's behavior in terms of the return value or exception handling. So, it does not lead to a Compatibility Issue. Therefore, no CI is detected, which is type 0."
632,<android.content.pm.LauncherActivityInfo: CharSequence getLabel()>,22,23,<android.content.pm.LauncherActivityInfo: CharSequence getLabel()>,<android.content.pm.LauncherActivityInfo: CharSequence getLabel()>,0,"{
    return mActivityInfo.loadLabel(mPm);
}","{
    return mResolveInfo.loadLabel(mPm);
}",1,"/**
 * Retrieves the label for the activity.
 *
 * @return The label for the activity.
 */
","/**
 * Retrieves the label for the activity.
 *
 * @return The label for the activity.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,"The implementation changes from using mActivityInfo.loadLabel(mPm) to mResolveInfo.loadLabel(mPm). This indicates that a dependent API changed, so the code change type is 5.","The change from one object (mActivityInfo) to another (mResolveInfo) for the invocation of loadLabel(mPm) could potentially return a different CharSequence, as these are different sources of the label data. Therefore, the CI type is 1."
633,"<android.app.FragmentManagerImpl: void enqueueAction(Runnable,boolean)>",22,23,"<android.app.FragmentManagerImpl: void enqueueAction(Runnable,boolean)>","<android.app.FragmentManagerImpl: void enqueueAction(Runnable,boolean)>",0,"{
    if (!allowStateLoss) {
        checkStateLoss();
    }
    synchronized (this) {
        if (mDestroyed || mActivity == null) {
            throw new IllegalStateException(""Activity has been destroyed"");
        }
        if (mPendingActions == null) {
            mPendingActions = new ArrayList<Runnable>();
        }
        mPendingActions.add(action);
        if (mPendingActions.size() == 1) {
            mActivity.mHandler.removeCallbacks(mExecCommit);
            mActivity.mHandler.post(mExecCommit);
        }
    }
}","{
    if (!allowStateLoss) {
        checkStateLoss();
    }
    synchronized (this) {
        if (mDestroyed || mHost == null) {
            throw new IllegalStateException(""Activity has been destroyed"");
        }
        if (mPendingActions == null) {
            mPendingActions = new ArrayList<Runnable>();
        }
        mPendingActions.add(action);
        if (mPendingActions.size() == 1) {
            mHost.getHandler().removeCallbacks(mExecCommit);
            mHost.getHandler().post(mExecCommit);
        }
    }
}",1,"/**
 * Adds an action to the queue of pending actions.
 *
 * @param action the action to add
 * @param allowStateLoss whether to allow loss of state information
 * @throws IllegalStateException if the activity has been destroyed
 */
","/**
 * Adds an action to the queue of pending actions.
 *
 * @param action the action to add
 * @param allowStateLoss whether to allow loss of state information
 * @throws IllegalStateException if the activity has been destroyed
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code has changed from accessing mHandler directly from mActivity to accessing it from mHost. Although the data type and access methodology have changed, the behaviour would be the same assuming that mHost is a valid replacement for mActivity with respect to obtaining the handler (mHost.getHandler() is behaving the same as mActivity.mHandler in terms of posting and removing callbacks). The dependent API change doesn't happen because the signature of mHandler, post(), or removeCallbacks() doesn't change, but the change is related to how mHandler is being accessed, which falls under Other statement changed.","This change doesn't cause a Compatibility Issue as long as mHost.getHandler() returns the same Handler object as mActivity.mHandler did. There's no change in the control dependencies, return statements, or exception handling mechanisms in the given context that would affect the behavior of this method; hence, there is no CI in this case."
635,"<android.app.ContextImpl: void sendStickyBroadcastAsUser(Intent,UserHandle)>",22,23,"<android.app.ContextImpl: void sendStickyBroadcastAsUser(Intent,UserHandle)>","<android.app.ContextImpl: void sendStickyBroadcastAsUser(Intent,UserHandle)>",0,"{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess();
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, false, true, user.getIdentifier());
    } catch (RemoteException e) {
    }
}","{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess();
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, true, user.getIdentifier());
    } catch (RemoteException e) {
        throw new RuntimeException(""Failure from system"", e);
    }
}",1,,,-1,[@Override],"[@Override, @Deprecated]",-1,-1,-1,-1,-1,-1,"2,4",2,"The implementation changes include: a different parameter passed to broadcastIntent (from 'false' to 'null') and a change in the exception handling (from an empty catch block to throwing a new RuntimeException with the caught RemoteException). This represents a change in other statements and a change in exception handling statements, corresponding to codes 2,4.","The change introduces a new RuntimeException that will be thrown in case of a RemoteException which alters the exception handling behavior of this method. This represents a Compatibility Issue due to potential different exception handling, coded as 2. There is no change in the return type or value, so CI related to the return statement (such as type 1) does not apply."
636,<android.widget.HorizontalScrollView: Parcelable onSaveInstanceState()>,22,23,<android.widget.HorizontalScrollView: Parcelable onSaveInstanceState()>,<android.widget.HorizontalScrollView: Parcelable onSaveInstanceState()>,0,"{
    if (mContext.getApplicationInfo().targetSdkVersion <= Build.VERSION_CODES.JELLY_BEAN_MR2) {
        // Don't break them, but they don't get scroll state restoration.
        return super.onSaveInstanceState();
    }
    Parcelable superState = super.onSaveInstanceState();
    SavedState ss = new SavedState(superState);
    ss.scrollPosition = mScrollX;
    ss.isLayoutRtl = isLayoutRtl();
    return ss;
}","{
    if (mContext.getApplicationInfo().targetSdkVersion <= Build.VERSION_CODES.JELLY_BEAN_MR2) {
        // Don't break them, but they don't get scroll state restoration.
        return super.onSaveInstanceState();
    }
    Parcelable superState = super.onSaveInstanceState();
    SavedState ss = new SavedState(superState);
    ss.scrollOffsetFromStart = isLayoutRtl() ? -mScrollX : mScrollX;
    return ss;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,"The attribute of the `SavedState` object that's being set has changed from `scrollPosition` to `scrollOffsetFromStart`, and the way the value is calculated has also been modified to consider the layout direction, so the code change type is 4.","This could lead to a Compatibility Issue since the saved state representation of the scroll position might be different, which could impact the state restoration when the view's state is restored, so the CI type is 1."
637,"<android.app.ContextImpl: void sendOrderedBroadcastAsUser(Intent,UserHandle,String,int,BroadcastReceiver,Handler,int,String,Bundle)>",22,23,"<android.app.ContextImpl: void sendOrderedBroadcastAsUser(Intent,UserHandle,String,int,BroadcastReceiver,Handler,int,String,Bundle)>","<android.app.ContextImpl: void sendOrderedBroadcastAsUser(Intent,UserHandle,String,int,BroadcastReceiver,Handler,int,String,Bundle)>",0,"{
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess();
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, rd, initialCode, initialData, initialExtras, receiverPermission, appOp, true, false, user.getIdentifier());
    } catch (RemoteException e) {
    }
}","{
    sendOrderedBroadcastAsUser(intent, user, receiverPermission, appOp, null, resultReceiver, scheduler, initialCode, initialData, initialExtras);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The late implementation of the method sendOrderedBroadcastAsUser is invoking another method with the same name and a different parameter list, which implies that the implementation details are now abstracted or handled within the new form of sendOrderedBroadcastAsUser. This is a dependent API change since it relies on a different overload of sendOrderedBroadcastAsUser.","Considering that the new form of the method is responsible for handling the same functionality as before, it's reasonable to assume that this internal refactoring is intended to be behavior-preserving, and therefore does not, on its own, introduce a compatibility issue. Hence, there is no compatibility issue in this scenario."
639,<android.database.AbstractCursor: boolean moveToPosition(int)>,22,23,<android.database.AbstractCursor: boolean moveToPosition(int)>,<android.database.AbstractCursor: boolean moveToPosition(int)>,0,"{
    // Make sure position isn't past the end of the cursor
    final int count = getCount();
    if (position >= count) {
        mPos = count;
        return false;
    }
    // Make sure position isn't before the beginning of the cursor
    if (position < 0) {
        mPos = -1;
        return false;
    }
    // Check for no-op moves, and skip the rest of the work for them
    if (position == mPos) {
        return true;
    }
    boolean result = onMove(mPos, position);
    if (result == false) {
        mPos = -1;
    } else {
        mPos = position;
        if (mRowIdColumnIndex != -1) {
            mCurrentRowID = Long.valueOf(getLong(mRowIdColumnIndex));
        }
    }
    return result;
}","{
    // Make sure position isn't past the end of the cursor
    final int count = getCount();
    if (position >= count) {
        mPos = count;
        return false;
    }
    // Make sure position isn't before the beginning of the cursor
    if (position < 0) {
        mPos = -1;
        return false;
    }
    // Check for no-op moves, and skip the rest of the work for them
    if (position == mPos) {
        return true;
    }
    boolean result = onMove(mPos, position);
    if (result == false) {
        mPos = -1;
    } else {
        mPos = position;
    }
    return result;
}",1,,,-1,,[@Override],-1,-1,-1,-1,-1,-1,4,0,The only code that has changed is the deletion of the following block:,if (mRowIdColumnIndex != -1) {
641,"<android.webkit.WebResourceResponse: void setStatusCodeAndReasonPhrase(int,String)>",22,23,"<android.webkit.WebResourceResponse: void setStatusCodeAndReasonPhrase(int,String)>","<android.webkit.WebResourceResponse: void setStatusCodeAndReasonPhrase(int,String)>",0,"{
    if (statusCode < 100)
        throw new IllegalArgumentException(""statusCode can't be less than 100."");
    if (statusCode > 599)
        throw new IllegalArgumentException(""statusCode can't be greater than 599."");
    if (statusCode > 299 && statusCode < 400)
        throw new IllegalArgumentException(""statusCode can't be in the [300, 399] range."");
    if (reasonPhrase == null)
        throw new IllegalArgumentException(""reasonPhrase can't be null."");
    if (reasonPhrase.trim().isEmpty())
        throw new IllegalArgumentException(""reasonPhrase can't be empty."");
    for (int i = 0; i < reasonPhrase.length(); i++) {
        int c = reasonPhrase.charAt(i);
        if (c > 0x7F) {
            throw new IllegalArgumentException(""reasonPhrase can't contain non-ASCII characters."");
        }
    }
    mStatusCode = statusCode;
    mReasonPhrase = reasonPhrase;
}","{
    checkImmutable();
    if (statusCode < 100)
        throw new IllegalArgumentException(""statusCode can't be less than 100."");
    if (statusCode > 599)
        throw new IllegalArgumentException(""statusCode can't be greater than 599."");
    if (statusCode > 299 && statusCode < 400)
        throw new IllegalArgumentException(""statusCode can't be in the [300, 399] range."");
    if (reasonPhrase == null)
        throw new IllegalArgumentException(""reasonPhrase can't be null."");
    if (reasonPhrase.trim().isEmpty())
        throw new IllegalArgumentException(""reasonPhrase can't be empty."");
    for (int i = 0; i < reasonPhrase.length(); i++) {
        int c = reasonPhrase.charAt(i);
        if (c > 0x7F) {
            throw new IllegalArgumentException(""reasonPhrase can't contain non-ASCII characters."");
        }
    }
    mStatusCode = statusCode;
    mReasonPhrase = reasonPhrase;
}",1,"/**
 * Sets the resource response's status code and reason phrase.
 *
 * @param statusCode the status code needs to be in the ranges [100, 299], [400, 599].
 * Causing a redirect by specifying a 3xx code is not supported.
 * @param reasonPhrase the phrase describing the status code, for example ""OK"". Must be non-null
 * and not empty.
 */
","/**
 * Sets the resource response's status code and reason phrase.
 *
 * @param statusCode the status code needs to be in the ranges [100, 299], [400, 599].
 * Causing a redirect by specifying a 3xx code is not supported.
 * @param reasonPhrase the phrase describing the status code, for example ""OK"". Must be non-null
 * and not empty.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,The code has introduced a new call to a method `checkImmutable()` without changing any existing return or exception handling statements.,"There is no compatibility issue detected because the new method `checkImmutable()` does not affect the return values or types, nor does it change the exception handling flow of the method based on the given code."
642,"<android.bluetooth.BluetoothAdapter: void closeProfileProxy(int,BluetoothProfile)>",22,23,"<android.bluetooth.BluetoothAdapter: void closeProfileProxy(int,BluetoothProfile)>","<android.bluetooth.BluetoothAdapter: void closeProfileProxy(int,BluetoothProfile)>",0,"{
    if (proxy == null)
        return;
    switch(profile) {
        case BluetoothProfile.HEADSET:
            BluetoothHeadset headset = (BluetoothHeadset) proxy;
            headset.close();
            break;
        case BluetoothProfile.A2DP:
            BluetoothA2dp a2dp = (BluetoothA2dp) proxy;
            a2dp.close();
            break;
        case BluetoothProfile.A2DP_SINK:
            BluetoothA2dpSink a2dpSink = (BluetoothA2dpSink) proxy;
            a2dpSink.close();
            break;
        case BluetoothProfile.AVRCP_CONTROLLER:
            BluetoothAvrcpController avrcp = (BluetoothAvrcpController) proxy;
            avrcp.close();
            break;
        case BluetoothProfile.INPUT_DEVICE:
            BluetoothInputDevice iDev = (BluetoothInputDevice) proxy;
            iDev.close();
            break;
        case BluetoothProfile.PAN:
            BluetoothPan pan = (BluetoothPan) proxy;
            pan.close();
            break;
        case BluetoothProfile.HEALTH:
            BluetoothHealth health = (BluetoothHealth) proxy;
            health.close();
            break;
        case BluetoothProfile.GATT:
            BluetoothGatt gatt = (BluetoothGatt) proxy;
            gatt.close();
            break;
        case BluetoothProfile.GATT_SERVER:
            BluetoothGattServer gattServer = (BluetoothGattServer) proxy;
            gattServer.close();
            break;
        case BluetoothProfile.MAP:
            BluetoothMap map = (BluetoothMap) proxy;
            map.close();
            break;
        case BluetoothProfile.HEADSET_CLIENT:
            BluetoothHeadsetClient headsetClient = (BluetoothHeadsetClient) proxy;
            headsetClient.close();
            break;
    }
}","{
    if (proxy == null)
        return;
    switch(profile) {
        case BluetoothProfile.HEADSET:
            BluetoothHeadset headset = (BluetoothHeadset) proxy;
            headset.close();
            break;
        case BluetoothProfile.A2DP:
            BluetoothA2dp a2dp = (BluetoothA2dp) proxy;
            a2dp.close();
            break;
        case BluetoothProfile.A2DP_SINK:
            BluetoothA2dpSink a2dpSink = (BluetoothA2dpSink) proxy;
            a2dpSink.close();
            break;
        case BluetoothProfile.AVRCP_CONTROLLER:
            BluetoothAvrcpController avrcp = (BluetoothAvrcpController) proxy;
            avrcp.close();
            break;
        case BluetoothProfile.INPUT_DEVICE:
            BluetoothInputDevice iDev = (BluetoothInputDevice) proxy;
            iDev.close();
            break;
        case BluetoothProfile.PAN:
            BluetoothPan pan = (BluetoothPan) proxy;
            pan.close();
            break;
        case BluetoothProfile.HEALTH:
            BluetoothHealth health = (BluetoothHealth) proxy;
            health.close();
            break;
        case BluetoothProfile.GATT:
            BluetoothGatt gatt = (BluetoothGatt) proxy;
            gatt.close();
            break;
        case BluetoothProfile.GATT_SERVER:
            BluetoothGattServer gattServer = (BluetoothGattServer) proxy;
            gattServer.close();
            break;
        case BluetoothProfile.MAP:
            BluetoothMap map = (BluetoothMap) proxy;
            map.close();
            break;
        case BluetoothProfile.HEADSET_CLIENT:
            BluetoothHeadsetClient headsetClient = (BluetoothHeadsetClient) proxy;
            headsetClient.close();
            break;
        case BluetoothProfile.SAP:
            BluetoothSap sap = (BluetoothSap) proxy;
            sap.close();
            break;
    }
}",1,"/**
 * Close the connection of the profile proxy to the Service.
 *
 * <p> Clients should call this when they are no longer using
 * the proxy obtained from {@link #getProfileProxy}.
 * Profile can be one of  {@link BluetoothProfile#HEALTH}, {@link BluetoothProfile#HEADSET} or
 * {@link BluetoothProfile#A2DP}
 *
 * @param profile
 * @param proxy Profile proxy object
 */
","/**
 * Close the connection of the profile proxy to the Service.
 *
 * <p> Clients should call this when they are no longer using
 * the proxy obtained from {@link #getProfileProxy}.
 * Profile can be one of  {@link BluetoothProfile#HEALTH}, {@link BluetoothProfile#HEADSET} or
 * {@link BluetoothProfile#A2DP}
 *
 * @param profile
 * @param proxy Profile proxy object
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"There has been a new `case` block added for `BluetoothProfile.SAP` to the `switch` statement, marking changes in both control dependency and other statements, thus the code change types are 3,4.","There is no Compatibility Issue because the existing execution paths remain unaffected; only new behavior is added for classes that implement `BluetoothSap`. Existing clients who were using previous versions of the API will experience the same behavior as before. Therefore, the API remains compatible for earlier clients, so the CI type is 0."
643,<android.app.Activity: void performResume()>,22,23,<android.app.Activity: void performResume()>,<android.app.Activity: void performResume()>,0,"{
    performRestart();
    mFragments.execPendingActions();
    mLastNonConfigurationInstances = null;
    mCalled = false;
    // mResumed is set by the instrumentation
    mInstrumentation.callActivityOnResume(this);
    if (!mCalled) {
        throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onResume()"");
    }
    // Now really resume, and install the current status bar and menu.
    mCalled = false;
    mFragments.dispatchResume();
    mFragments.execPendingActions();
    onPostResume();
    if (!mCalled) {
        throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onPostResume()"");
    }
}","{
    performRestart();
    mFragments.execPendingActions();
    mLastNonConfigurationInstances = null;
    mCalled = false;
    // mResumed is set by the instrumentation
    mInstrumentation.callActivityOnResume(this);
    if (!mCalled) {
        throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onResume()"");
    }
    // invisible activities must be finished before onResume() completes
    if (!mVisibleFromClient && !mFinished) {
        Log.w(TAG, ""An activity without a UI must call finish() before onResume() completes"");
        if (getApplicationInfo().targetSdkVersion > android.os.Build.VERSION_CODES.LOLLIPOP_MR1) {
            throw new IllegalStateException(""Activity "" + mComponent.toShortString() + "" did not call finish() prior to onResume() completing"");
        }
    }
    // Now really resume, and install the current status bar and menu.
    mCalled = false;
    mFragments.dispatchResume();
    mFragments.execPendingActions();
    onPostResume();
    if (!mCalled) {
        throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onPostResume()"");
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"2,3,4","1,2","There are changes in control dependency, a new 'if' condition checking mVisibleFromClient and mFinished before calling Log.w is introduced. Besides that, a new exception handling statement which throws an IllegalStateException based on the targetSdkVersion has been added. No change has been made to the return statement type since it's a void method, but the new control and exception handling could change the normal flow of the method, so the change type is 2,3,4.","Because of the introduction of a new 'if' condition and the potential to throw a new type of exception (IllegalStateException), there's a possibility this method could either terminate prematurely by throwing an exception where it wouldn't have previously or continue execution due to the added conditional check. Both these alterations could lead to a Compatibility Issue due to potential different behavior, this qualifies for both types 1 (as the flow is interrupted and doesn't reach the end, which conceptually is similar to returning a different value in a void method) and 2."
644,<android.hardware.camera2.marshal.impl.MarshalQueryableString.MarshalerString: String unmarshal(ByteBuffer)>,22,23,<android.hardware.camera2.marshal.impl.MarshalQueryableString.MarshalerString: String unmarshal(ByteBuffer)>,<android.hardware.camera2.marshal.impl.MarshalQueryableString.MarshalerString: String unmarshal(ByteBuffer)>,0,"{
    // save the current position
    buffer.mark();
    boolean foundNull = false;
    int stringLength = 0;
    while (buffer.hasRemaining()) {
        if (buffer.get() == NUL) {
            foundNull = true;
            break;
        }
        stringLength++;
    }
    if (VERBOSE) {
        Log.v(TAG, ""unmarshal - scanned "" + stringLength + "" characters; found null? "" + foundNull);
    }
    if (!foundNull) {
        throw new UnsupportedOperationException(""Strings must be null-terminated"");
    }
    // go back to the previously marked position
    buffer.reset();
    byte[] strBytes = new byte[stringLength + 1];
    // including null character
    buffer.get(strBytes, /*dstOffset*/
    0, stringLength + 1);
    // not including null character
    return new String(strBytes, /*offset*/
    0, stringLength, UTF8_CHARSET);
}","{
    // save the current position
    buffer.mark();
    boolean foundNull = false;
    int stringLength = 0;
    while (buffer.hasRemaining()) {
        if (buffer.get() == NUL) {
            foundNull = true;
            break;
        }
        stringLength++;
    }
    if (DEBUG) {
        Log.v(TAG, ""unmarshal - scanned "" + stringLength + "" characters; found null? "" + foundNull);
    }
    if (!foundNull) {
        throw new UnsupportedOperationException(""Strings must be null-terminated"");
    }
    // go back to the previously marked position
    buffer.reset();
    byte[] strBytes = new byte[stringLength + 1];
    // including null character
    buffer.get(strBytes, /*dstOffset*/
    0, stringLength + 1);
    // not including null character
    return new String(strBytes, /*offset*/
    0, stringLength, UTF8_CHARSET);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,The code change is only in the logging statement where the logging level check was changed from VERBOSE to DEBUG which does not affect the API’s functionality or its return value.,There's no compatibility issue because the change in logging levels doesn't affect program execution in terms of the API outcome or error handling.
645,"<android.widget.TextView: boolean onKeyShortcut(int,KeyEvent)>",22,23,"<android.widget.TextView: boolean onKeyShortcut(int,KeyEvent)>","<android.widget.TextView: boolean onKeyShortcut(int,KeyEvent)>",0,"{
    final int filteredMetaState = event.getMetaState() & ~KeyEvent.META_CTRL_MASK;
    if (KeyEvent.metaStateHasNoModifiers(filteredMetaState)) {
        switch(keyCode) {
            case KeyEvent.KEYCODE_A:
                if (canSelectText()) {
                    return onTextContextMenuItem(ID_SELECT_ALL);
                }
                break;
            case KeyEvent.KEYCODE_X:
                if (canCut()) {
                    return onTextContextMenuItem(ID_CUT);
                }
                break;
            case KeyEvent.KEYCODE_C:
                if (canCopy()) {
                    return onTextContextMenuItem(ID_COPY);
                }
                break;
            case KeyEvent.KEYCODE_V:
                if (canPaste()) {
                    return onTextContextMenuItem(ID_PASTE);
                }
                break;
        }
    }
    return super.onKeyShortcut(keyCode, event);
}","{
    if (event.hasModifiers(KeyEvent.META_CTRL_ON)) {
        // Handle Ctrl-only shortcuts.
        switch(keyCode) {
            case KeyEvent.KEYCODE_A:
                if (canSelectText()) {
                    return onTextContextMenuItem(ID_SELECT_ALL);
                }
                break;
            case KeyEvent.KEYCODE_Z:
                if (canUndo()) {
                    return onTextContextMenuItem(ID_UNDO);
                }
                break;
            case KeyEvent.KEYCODE_X:
                if (canCut()) {
                    return onTextContextMenuItem(ID_CUT);
                }
                break;
            case KeyEvent.KEYCODE_C:
                if (canCopy()) {
                    return onTextContextMenuItem(ID_COPY);
                }
                break;
            case KeyEvent.KEYCODE_V:
                if (canPaste()) {
                    return onTextContextMenuItem(ID_PASTE);
                }
                break;
        }
    } else if (event.hasModifiers(KeyEvent.META_CTRL_ON | KeyEvent.META_SHIFT_ON)) {
        // Handle Ctrl-Shift shortcuts.
        switch(keyCode) {
            case KeyEvent.KEYCODE_Z:
                if (canRedo()) {
                    return onTextContextMenuItem(ID_REDO);
                }
                break;
            case KeyEvent.KEYCODE_V:
                if (canPaste()) {
                    return onTextContextMenuItem(ID_PASTE_AS_PLAIN_TEXT);
                }
        }
    }
    return super.onKeyShortcut(keyCode, event);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"The condition to check modifier keys has changed from checking `KeyEvent.META_CTRL_MASK` to using `event.hasModifiers(KeyEvent.META_CTRL_ON)` and additional handling for `META_CTRL_ON | KeyEvent.META_SHIFT_ON` has been included. The handling of the `KeyEvent.KEYCODE_Z` key code has been added on both situations with different condition checks. Therefore, there is a control dependency change (3) and other statement changes (4), such as the addition of new `if` and `switch` cases.","The changes in modifier key checks and the new case (`KeyEvent.KEYCODE_Z`) introduce different behaviors: the early version does not handle `KeyEvent.KEYCODE_Z` at all, and the late version handles it in two different ways depending on the modifier keys. This means that, depending on the `keyCode` and modifiers, the method can have different return values, causing a compatibility issue of type 1."
646,"<android.app.AlertDialog: int resolveDialogTheme(Context,int)>",22,23,"<android.app.AlertDialog: int resolveDialogTheme(Context,int)>","<android.app.AlertDialog: int resolveDialogTheme(Context,int)>",0,"{
    if (resid == THEME_TRADITIONAL) {
        return com.android.internal.R.style.Theme_Dialog_Alert;
    } else if (resid == THEME_HOLO_DARK) {
        return com.android.internal.R.style.Theme_Holo_Dialog_Alert;
    } else if (resid == THEME_HOLO_LIGHT) {
        return com.android.internal.R.style.Theme_Holo_Light_Dialog_Alert;
    } else if (resid == THEME_DEVICE_DEFAULT_DARK) {
        return com.android.internal.R.style.Theme_DeviceDefault_Dialog_Alert;
    } else if (resid == THEME_DEVICE_DEFAULT_LIGHT) {
        return com.android.internal.R.style.Theme_DeviceDefault_Light_Dialog_Alert;
    } else if (resid >= 0x01000000) {
        // start of real resource IDs.
        return resid;
    } else {
        TypedValue outValue = new TypedValue();
        context.getTheme().resolveAttribute(com.android.internal.R.attr.alertDialogTheme, outValue, true);
        return outValue.resourceId;
    }
}","{
    if (themeResId == THEME_TRADITIONAL) {
        return R.style.Theme_Dialog_Alert;
    } else if (themeResId == THEME_HOLO_DARK) {
        return R.style.Theme_Holo_Dialog_Alert;
    } else if (themeResId == THEME_HOLO_LIGHT) {
        return R.style.Theme_Holo_Light_Dialog_Alert;
    } else if (themeResId == THEME_DEVICE_DEFAULT_DARK) {
        return R.style.Theme_DeviceDefault_Dialog_Alert;
    } else if (themeResId == THEME_DEVICE_DEFAULT_LIGHT) {
        return R.style.Theme_DeviceDefault_Light_Dialog_Alert;
    } else if (themeResId >= 0x01000000) {
        // start of real resource IDs.
        return themeResId;
    } else {
        final TypedValue outValue = new TypedValue();
        context.getTheme().resolveAttribute(R.attr.alertDialogTheme, outValue, true);
        return outValue.resourceId;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"Variable name changed from 'resid' to 'themeResId', and references to resources were updated from 'com.android.internal.R' to 'R', indicating the change in how resources are accessed. The change is an internal reference update not affecting the method's external behavior, so the code change type is 4.","The change does not affect the external behavior of the method; it is an internal reference update that wouldn't cause the method to return different values or throw different exceptions, so there is no Compatibility Issue."
648,<android.hardware.camera2.marshal.impl.MarshalQueryableHighSpeedVideoConfiguration.MarshalerHighSpeedVideoConfiguration: HighSpeedVideoConfiguration unmarshal(ByteBuffer)>,22,23,<android.hardware.camera2.marshal.impl.MarshalQueryableHighSpeedVideoConfiguration.MarshalerHighSpeedVideoConfiguration: HighSpeedVideoConfiguration unmarshal(ByteBuffer)>,<android.hardware.camera2.marshal.impl.MarshalQueryableHighSpeedVideoConfiguration.MarshalerHighSpeedVideoConfiguration: HighSpeedVideoConfiguration unmarshal(ByteBuffer)>,0,"{
    int width = buffer.getInt();
    int height = buffer.getInt();
    int fpsMin = buffer.getInt();
    int fpsMax = buffer.getInt();
    return new HighSpeedVideoConfiguration(width, height, fpsMin, fpsMax);
}","{
    int width = buffer.getInt();
    int height = buffer.getInt();
    int fpsMin = buffer.getInt();
    int fpsMax = buffer.getInt();
    int batchSizeMax = buffer.getInt();
    return new HighSpeedVideoConfiguration(width, height, fpsMin, fpsMax, batchSizeMax);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation has been changed by adding a new getInt call on the buffer (int batchSizeMax = buffer.getInt()) and the constructor call has an additional parameter in the late version. Therefore, the change types are 1 and 5.","The late version of the API potentially returns a different object of HighSpeedVideoConfiguration with an additional parameter, which is batchSizeMax, thus it is a Compatibility Issue of type 1 caused by the potential return of a different value or type."
650,"<android.view.View: boolean awakenScrollBars(int,boolean)>",22,23,"<android.view.View: boolean awakenScrollBars(int,boolean)>","<android.view.View: boolean awakenScrollBars(int,boolean)>",0,"{
    final ScrollabilityCache scrollCache = mScrollCache;
    if (scrollCache == null || !scrollCache.fadeScrollBars) {
        return false;
    }
    if (scrollCache.scrollBar == null) {
        scrollCache.scrollBar = new ScrollBarDrawable();
    }
    if (isHorizontalScrollBarEnabled() || isVerticalScrollBarEnabled()) {
        if (invalidate) {
            // Invalidate to show the scrollbars
            postInvalidateOnAnimation();
        }
        if (scrollCache.state == ScrollabilityCache.OFF) {
            // FIXME: this is copied from WindowManagerService.
            // We should get this value from the system when it
            // is possible to do so.
            final int KEY_REPEAT_FIRST_DELAY = 750;
            startDelay = Math.max(KEY_REPEAT_FIRST_DELAY, startDelay);
        }
        // Tell mScrollCache when we should start fading. This may
        // extend the fade start time if one was already scheduled
        long fadeStartTime = AnimationUtils.currentAnimationTimeMillis() + startDelay;
        scrollCache.fadeStartTime = fadeStartTime;
        scrollCache.state = ScrollabilityCache.ON;
        // Schedule our fader to run, unscheduling any old ones first
        if (mAttachInfo != null) {
            mAttachInfo.mHandler.removeCallbacks(scrollCache);
            mAttachInfo.mHandler.postAtTime(scrollCache, fadeStartTime);
        }
        return true;
    }
    return false;
}","{
    final ScrollabilityCache scrollCache = mScrollCache;
    if (scrollCache == null || !scrollCache.fadeScrollBars) {
        return false;
    }
    if (scrollCache.scrollBar == null) {
        scrollCache.scrollBar = new ScrollBarDrawable();
        scrollCache.scrollBar.setCallback(this);
        scrollCache.scrollBar.setState(getDrawableState());
    }
    if (isHorizontalScrollBarEnabled() || isVerticalScrollBarEnabled()) {
        if (invalidate) {
            // Invalidate to show the scrollbars
            postInvalidateOnAnimation();
        }
        if (scrollCache.state == ScrollabilityCache.OFF) {
            // FIXME: this is copied from WindowManagerService.
            // We should get this value from the system when it
            // is possible to do so.
            final int KEY_REPEAT_FIRST_DELAY = 750;
            startDelay = Math.max(KEY_REPEAT_FIRST_DELAY, startDelay);
        }
        // Tell mScrollCache when we should start fading. This may
        // extend the fade start time if one was already scheduled
        long fadeStartTime = AnimationUtils.currentAnimationTimeMillis() + startDelay;
        scrollCache.fadeStartTime = fadeStartTime;
        scrollCache.state = ScrollabilityCache.ON;
        // Schedule our fader to run, unscheduling any old ones first
        if (mAttachInfo != null) {
            mAttachInfo.mHandler.removeCallbacks(scrollCache);
            mAttachInfo.mHandler.postAtTime(scrollCache, fadeStartTime);
        }
        return true;
    }
    return false;
}",1,"/**
 * <p>
 * Trigger the scrollbars to draw. When invoked this method starts an
 * animation to fade the scrollbars out after a fixed delay. If a subclass
 * provides animated scrolling, the start delay should equal the duration of
 * the scrolling animation.
 * </p>
 *
 * <p>
 * The animation starts only if at least one of the scrollbars is enabled,
 * as specified by {@link #isHorizontalScrollBarEnabled()} and
 * {@link #isVerticalScrollBarEnabled()}. When the animation is started,
 * this method returns true, and false otherwise. If the animation is
 * started, this method calls {@link #invalidate()} if the invalidate parameter
 * is set to true; in that case the caller
 * should not call {@link #invalidate()}.
 * </p>
 *
 * <p>
 * This method should be invoked everytime a subclass directly updates the
 * scroll parameters.
 * </p>
 *
 * @param startDelay the delay, in milliseconds, after which the animation
 * should start; when the delay is 0, the animation starts
 * immediately
 *
 * @param invalidate Wheter this method should call invalidate
 *
 * @return true if the animation is played, false otherwise
 *
 * @see #scrollBy(int, int)
 * @see #scrollTo(int, int)
 * @see #isHorizontalScrollBarEnabled()
 * @see #isVerticalScrollBarEnabled()
 * @see #setHorizontalScrollBarEnabled(boolean)
 * @see #setVerticalScrollBarEnabled(boolean)
 */
","/**
 * <p>
 * Trigger the scrollbars to draw. When invoked this method starts an
 * animation to fade the scrollbars out after a fixed delay. If a subclass
 * provides animated scrolling, the start delay should equal the duration of
 * the scrolling animation.
 * </p>
 *
 * <p>
 * The animation starts only if at least one of the scrollbars is enabled,
 * as specified by {@link #isHorizontalScrollBarEnabled()} and
 * {@link #isVerticalScrollBarEnabled()}. When the animation is started,
 * this method returns true, and false otherwise. If the animation is
 * started, this method calls {@link #invalidate()} if the invalidate parameter
 * is set to true; in that case the caller
 * should not call {@link #invalidate()}.
 * </p>
 *
 * <p>
 * This method should be invoked every time a subclass directly updates the
 * scroll parameters.
 * </p>
 *
 * @param startDelay the delay, in milliseconds, after which the animation
 * should start; when the delay is 0, the animation starts
 * immediately
 *
 * @param invalidate Whether this method should call invalidate
 *
 * @return true if the animation is played, false otherwise
 *
 * @see #scrollBy(int, int)
 * @see #scrollTo(int, int)
 * @see #isHorizontalScrollBarEnabled()
 * @see #isVerticalScrollBarEnabled()
 * @see #setHorizontalScrollBarEnabled(boolean)
 * @see #setVerticalScrollBarEnabled(boolean)
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"New statements have been added to the existing 'if (scrollCache.scrollBar == null)' block: scrollCache.scrollBar.setCallback(this); scrollCache.scrollBar.setState(getDrawableState());. This change does not affect any return statements, exception handling, control dependencies, or rely on any dependent API changes. Thus, the type of code change is 4.","There is no change to the return value or the exceptions thrown by the method. The new method invocations within the 'if' block set properties of the ScrollBarDrawable object, but do not influence the code flow that would lead to returning a different value or throwing a different exception. This means there is no Compatibility Issue, so the compatibility situation is 0."
651,"<android.app.admin.DevicePolicyManager: void setProfileName(ComponentName,String)>",22,23,"<android.app.admin.DevicePolicyManager: void setProfileName(ComponentName,String)>","<android.app.admin.DevicePolicyManager: void setProfileName(ComponentName,String)>",0,"{
    if (mService != null) {
        try {
            mService.setProfileName(who, profileName);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    if (mService != null) {
        try {
            mService.setProfileName(admin, profileName);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}",1,"/**
 * Sets the name of the profile. In the device owner case it sets the name of the user
 * which it is called from. Only a profile owner or device owner can call this. If this is
 * never called by the profile or device owner, the name will be set to default values.
 *
 * @see #isProfileOwnerApp
 * @see #isDeviceOwnerApp
 *
 * @param profileName The name of the profile.
 */
","/**
 * Sets the name of the profile. In the device owner case it sets the name of the user
 * which it is called from. Only a profile owner or device owner can call this. If this is
 * never called by the profile or device owner, the name will be set to default values.
 *
 * @see #isProfileOwnerApp
 * @see #isDeviceOwnerApp
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associate with.
 * @param profileName The name of the profile.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"There is a change in the parameter name passed to the mService.setProfileName method from 'who' to 'admin', which indicates the code change type as 5 (Dependent API changed). However, as long as 'who' and 'admin' are identifiers for the same type and no other information suggests a type or behavioral change, this alteration might just be a renaming without affecting the external API contract.","There is no Compatibility Issue detected between the two versions, as the change is only related to the parameter name within the method implementation, not affecting the method's signature, behavior, or the value returned."
652,"<android.app.ContextImpl: void sendOrderedBroadcast(Intent,String,int,BroadcastReceiver,Handler,int,String,Bundle)>",22,23,"<android.app.ContextImpl: void sendOrderedBroadcast(Intent,String,int,BroadcastReceiver,Handler,int,String,Bundle)>","<android.app.ContextImpl: void sendOrderedBroadcast(Intent,String,int,BroadcastReceiver,Handler,int,String,Bundle)>",0,"{
    warnIfCallingFromSystemProcess();
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess();
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, rd, initialCode, initialData, initialExtras, receiverPermission, appOp, true, false, getUserId());
    } catch (RemoteException e) {
    }
}","{
    sendOrderedBroadcast(intent, receiverPermission, appOp, resultReceiver, scheduler, initialCode, initialData, initialExtras, null);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4,5","1,2","The early implementation has a detailed internal implementation of sending an ordered broadcast, while the late version directly calls 'sendOrderedBroadcast' with a subset of the parameters, indicating a change to a dependent API. Several code changes are present: 'warnIfCallingFromSystemProcess()' call is removed, and the entire block that sets up the 'IIntentReceiver' as well as the try-catch block that performs the broadcast intent has been removed. Additionally, the internals of 'sendOrderedBroadcast' called in the late version are not visible here, which could imply changed or additional behavior from the method it delegates to. Therefore, the change types are 1, 4, and 5.","Given that the implementation has been fundamentally altered to delegate to another method, there is potential for different return behavior even though no explicit return statement is present in either version. This could still result in a different outcome from the method call, leading to a change in the return type or value (category 1). Moreover, the early version potentially suppresses RemoteException, while the late version's behavior in this regard is unclear due to the delegation. This could also represent a difference in exception handling behavior (category 2) if the delegated method has different exception handling compared to the original inline code."
654,<android.transition.Transition: Transition removeTarget(int)>,22,23,<android.transition.Transition: Transition removeTarget(int)>,<android.transition.Transition: Transition removeTarget(int)>,0,"{
    if (targetId > 0) {
        mTargetIds.remove(targetId);
    }
    return this;
}","{
    if (targetId > 0) {
        mTargetIds.remove((Integer) targetId);
    }
    return this;
}",1,"/**
 * Removes the given targetId from the list of ids that this Transition
 * is interested in animating.
 *
 * @param targetId The id of a target view, must be a positive number.
 * @return The Transition from which the targetId is removed.
 * Returning the same object makes it easier to chain calls during
 * construction, such as
 * <code>transitionSet.addTransitions(new Fade()).removeTargetId(someId);</code>
 */
","/**
 * Removes the given targetId from the list of ids that this Transition
 * is interested in animating.
 *
 * @param targetId The id of a target view, must be a positive number.
 * @return The Transition from which the targetId is removed.
 * Returning the same object makes it easier to chain calls during
 * construction, such as
 * <code>transitionSet.addTransitions(new Fade()).removeTargetId(someId);</code>
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change is in the method mTargetIds.remove where the targetId is cast to an Integer before being removed, this is an ""other statement changed"" since no control dependency or exception handling is changed, and no change in the return statement or underlying API dependency occurred, so the code change type is 4.","There is no Compatibility Issue as the cast does not affect the method's behavior from a caller's perspective since Java Integer caching for int values in the range -128 to 127 ensures that this cast will not lead to a different behavior as long as the autoboxing for such values is consistent, which it is in Java. Hence, functionally, there's no change in the behavior of the API, and the CI type is 0."
655,<android.os.Environment: boolean isExternalStorageEmulated(File)>,22,23,<android.os.Environment: boolean isExternalStorageEmulated(File)>,<android.os.Environment: boolean isExternalStorageEmulated(File)>,0,"{
    final StorageVolume volume = getStorageVolume(path);
    if (volume != null) {
        return volume.isEmulated();
    } else {
        throw new IllegalArgumentException(""Failed to find storage device at "" + path);
    }
}","{
    final StorageVolume volume = StorageManager.getStorageVolume(path, UserHandle.myUserId());
    if (volume != null) {
        return volume.isEmulated();
    } else {
        throw new IllegalArgumentException(""Failed to find storage device at "" + path);
    }
}",1,"/**
 * Returns whether the storage device that provides the given path is
 * emulated. If true, data stored on this device will be stored on a portion
 * of the internal storage system.
 *
 * @throws IllegalArgumentException if the path is not a valid storage
 * device.
 */
","/**
 * Returns whether the storage device that provides the given path is
 * emulated. If true, data stored on this device will be stored on a portion
 * of the internal storage system.
 *
 * @throws IllegalArgumentException if the path is not a valid storage
 * device.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent API has changed from getStorageVolume(path) to StorageManager.getStorageVolume(path, UserHandle.myUserId()), including the addition of a new parameter. Therefore, the code change type is 5.","Although there's a change in the dependent API, it doesn't necessarily lead to a CI since the method isExternalStorageEmulated() retains the same behavior, simply relying on an updated method to retrieve the StorageVolume. As there's no change in return values or exception handling in the API itself, there is no Compatibility Issue. Thus, the CI type is 0."
656,<android.widget.TextView: int getCompoundPaddingLeft()>,22,23,<android.widget.TextView: int getCompoundPaddingLeft()>,<android.widget.TextView: int getCompoundPaddingLeft()>,0,"{
    final Drawables dr = mDrawables;
    if (dr == null || dr.mDrawableLeft == null) {
        return mPaddingLeft;
    } else {
        return mPaddingLeft + dr.mDrawablePadding + dr.mDrawableSizeLeft;
    }
}","{
    final Drawables dr = mDrawables;
    if (dr == null || dr.mShowing[Drawables.LEFT] == null) {
        return mPaddingLeft;
    } else {
        return mPaddingLeft + dr.mDrawablePadding + dr.mDrawableSizeLeft;
    }
}",1,"/**
 * Returns the left padding of the view, plus space for the left
 * Drawable if any.
 */
","/**
 * Returns the left padding of the view, plus space for the left
 * Drawable if any.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"There's a change affecting which field is checked within the if statement condition: from `dr.mDrawableLeft` to `dr.mShowing[Drawables.LEFT]` and it's related to array indexing, so the code change type is 4,5.","While the change does modify how it is determined if a drawable is present on the left, assuming the semantics of `mDrawableLeft` and `dr.mShowing[Drawables.LEFT]` are intended to be functionally equivalent (meaning that `dr.mDrawableLeft` has simply been replaced with `dr.mShowing[Drawables.LEFT]` in the new Drawables implementation), there should be no behavioral change to the API as it's an internal change with no effect on the output. Therefore, no compatibility issue should arise."
658,<android.text.style.LocaleSpan: int getSpanTypeId()>,22,23,<android.text.style.LocaleSpan: int getSpanTypeId()>,<android.text.style.LocaleSpan: int getSpanTypeId()>,0,"{
    return TextUtils.LOCALE_SPAN;
}","{
    return getSpanTypeIdInternal();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The implementation of the method has changed to use a different method getSpanTypeIdInternal() instead of a direct return with TextUtils.LOCALE_SPAN. This is a type 5 change, as the dependent API getSpanTypeIdInternal() is assumed to be used instead of a direct reference.","There's no Compatibility Issue as long as getSpanTypeIdInternal() returns the same value as TextUtils.LOCALE_SPAN. The change in the method does not inherently mean there is a change in behavior, the CI type is therefore 0 assuming getSpanTypeIdInternal() is implemented to maintain the same behavior."
659,<android.view.ViewRootImpl.ViewPostImeInputStage: int onProcess(QueuedInputEvent)>,22,23,<android.view.ViewRootImpl.ViewPostImeInputStage: int onProcess(QueuedInputEvent)>,<android.view.ViewRootImpl.ViewPostImeInputStage: int onProcess(QueuedInputEvent)>,0,"{
    if (q.mEvent instanceof KeyEvent) {
        return processKeyEvent(q);
    } else {
        // If delivering a new non-key event, make sure the window is
        // now allowed to start updating.
        handleDispatchDoneAnimating();
        final int source = q.mEvent.getSource();
        if ((source & InputDevice.SOURCE_CLASS_POINTER) != 0) {
            return processPointerEvent(q);
        } else if ((source & InputDevice.SOURCE_CLASS_TRACKBALL) != 0) {
            return processTrackballEvent(q);
        } else {
            return processGenericMotionEvent(q);
        }
    }
}","{
    if (q.mEvent instanceof KeyEvent) {
        return processKeyEvent(q);
    } else {
        // If delivering a new non-key event, make sure the window is
        // now allowed to start updating.
        handleDispatchWindowAnimationStopped();
        final int source = q.mEvent.getSource();
        if ((source & InputDevice.SOURCE_CLASS_POINTER) != 0) {
            return processPointerEvent(q);
        } else if ((source & InputDevice.SOURCE_CLASS_TRACKBALL) != 0) {
            return processTrackballEvent(q);
        } else {
            return processGenericMotionEvent(q);
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The method name within the method body was changed from handleDispatchDoneAnimating() to handleDispatchWindowAnimationStopped(), but it's not directly related to the return value or exceptions thrown. Therefore, it is classified as type 4.","There is no Compatibility Issue found as the changes do not affect the return values or the exceptions thrown by the method. The change in the method name does not lead to different return values/types or exception handlings, thus it's classified as 0."
661,"<android.widget.QuickContactBadge.QueryHandler: void onQueryComplete(int,Object,Cursor)>",22,23,"<android.widget.QuickContactBadge.QueryHandler: void onQueryComplete(int,Object,Cursor)>","<android.widget.QuickContactBadge.QueryHandler: void onQueryComplete(int,Object,Cursor)>",0,"{
    Uri lookupUri = null;
    Uri createUri = null;
    boolean trigger = false;
    Bundle extras = (cookie != null) ? (Bundle) cookie : new Bundle();
    try {
        switch(token) {
            case TOKEN_PHONE_LOOKUP_AND_TRIGGER:
                trigger = true;
                createUri = Uri.fromParts(""tel"", extras.getString(EXTRA_URI_CONTENT), null);
            // $FALL-THROUGH$
            case TOKEN_PHONE_LOOKUP:
                {
                    if (cursor != null && cursor.moveToFirst()) {
                        long contactId = cursor.getLong(PHONE_ID_COLUMN_INDEX);
                        String lookupKey = cursor.getString(PHONE_LOOKUP_STRING_COLUMN_INDEX);
                        lookupUri = Contacts.getLookupUri(contactId, lookupKey);
                    }
                    break;
                }
            case TOKEN_EMAIL_LOOKUP_AND_TRIGGER:
                trigger = true;
                createUri = Uri.fromParts(""mailto"", extras.getString(EXTRA_URI_CONTENT), null);
            // $FALL-THROUGH$
            case TOKEN_EMAIL_LOOKUP:
                {
                    if (cursor != null && cursor.moveToFirst()) {
                        long contactId = cursor.getLong(EMAIL_ID_COLUMN_INDEX);
                        String lookupKey = cursor.getString(EMAIL_LOOKUP_STRING_COLUMN_INDEX);
                        lookupUri = Contacts.getLookupUri(contactId, lookupKey);
                    }
                    break;
                }
        }
    } finally {
        if (cursor != null) {
            cursor.close();
        }
    }
    mContactUri = lookupUri;
    onContactUriChanged();
    if (trigger && lookupUri != null) {
        // Found contact, so trigger QuickContact
        QuickContact.showQuickContact(getContext(), QuickContactBadge.this, lookupUri, QuickContact.MODE_LARGE, mExcludeMimes);
    } else if (createUri != null) {
        // Prompt user to add this person to contacts
        final Intent intent = new Intent(Intents.SHOW_OR_CREATE_CONTACT, createUri);
        if (extras != null) {
            extras.remove(EXTRA_URI_CONTENT);
            intent.putExtras(extras);
        }
        getContext().startActivity(intent);
    }
}","{
    Uri lookupUri = null;
    Uri createUri = null;
    boolean trigger = false;
    Bundle extras = (cookie != null) ? (Bundle) cookie : new Bundle();
    try {
        switch(token) {
            case TOKEN_PHONE_LOOKUP_AND_TRIGGER:
                trigger = true;
                createUri = Uri.fromParts(""tel"", extras.getString(EXTRA_URI_CONTENT), null);
            // $FALL-THROUGH$
            case TOKEN_PHONE_LOOKUP:
                {
                    if (cursor != null && cursor.moveToFirst()) {
                        long contactId = cursor.getLong(PHONE_ID_COLUMN_INDEX);
                        String lookupKey = cursor.getString(PHONE_LOOKUP_STRING_COLUMN_INDEX);
                        lookupUri = Contacts.getLookupUri(contactId, lookupKey);
                    }
                    break;
                }
            case TOKEN_EMAIL_LOOKUP_AND_TRIGGER:
                trigger = true;
                createUri = Uri.fromParts(""mailto"", extras.getString(EXTRA_URI_CONTENT), null);
            // $FALL-THROUGH$
            case TOKEN_EMAIL_LOOKUP:
                {
                    if (cursor != null && cursor.moveToFirst()) {
                        long contactId = cursor.getLong(EMAIL_ID_COLUMN_INDEX);
                        String lookupKey = cursor.getString(EMAIL_LOOKUP_STRING_COLUMN_INDEX);
                        lookupUri = Contacts.getLookupUri(contactId, lookupKey);
                    }
                    break;
                }
        }
    } finally {
        if (cursor != null) {
            cursor.close();
        }
    }
    mContactUri = lookupUri;
    onContactUriChanged();
    if (trigger && mContactUri != null) {
        // Found contact, so trigger QuickContact
        QuickContact.showQuickContact(getContext(), QuickContactBadge.this, mContactUri, mExcludeMimes, mPrioritizedMimeType);
    } else if (createUri != null) {
        // Prompt user to add this person to contacts
        final Intent intent = new Intent(Intents.SHOW_OR_CREATE_CONTACT, createUri);
        if (extras != null) {
            extras.remove(EXTRA_URI_CONTENT);
            intent.putExtras(extras);
        }
        getContext().startActivity(intent);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The only change in the late version is the addition of one more argument to the `QuickContact.showQuickContact` method call, changing from `QuickContact.showQuickContact(getContext(), QuickContactBadge.this, lookupUri, QuickContact.MODE_LARGE, mExcludeMimes)` to `QuickContact.showQuickContact(getContext(), QuickContactBadge.this, mContactUri, mExcludeMimes, mPrioritizedMimeType)`. However, since `mContactUri` has been set to `lookupUri` just before this call and the additional `mPrioritizedMimeType` parameter is a member variable that was already present, this is an Other statement change. The nature of the call stays the same, as it still triggers the QuickContact overlay with the specified contact and does not impact the return value of the method or its behavior in throwing exceptions.","No Compatibility Issue is detected as the change does not affect the method's behavior concerning the return value or exception handling. The method signature remains the same, and control flow remains unchanged. The only alteration is in passing an additional parameter to a method call within the `onQueryComplete` implementation, which would not introduce any compatibility issues for existing callers of `onQueryComplete`."
662,"<android.text.BidiFormatter: String unicodeWrap(String,TextDirectionHeuristic,boolean)>",22,23,"<android.text.BidiFormatter: String unicodeWrap(String,TextDirectionHeuristic,boolean)>","<android.text.BidiFormatter: String unicodeWrap(String,TextDirectionHeuristic,boolean)>",0,"{
    final boolean isRtl = heuristic.isRtl(str, 0, str.length());
    StringBuilder result = new StringBuilder();
    if (getStereoReset() && isolate) {
        result.append(markBefore(str, isRtl ? TextDirectionHeuristics.RTL : TextDirectionHeuristics.LTR));
    }
    if (isRtl != mIsRtlContext) {
        result.append(isRtl ? RLE : LRE);
        result.append(str);
        result.append(PDF);
    } else {
        result.append(str);
    }
    if (isolate) {
        result.append(markAfter(str, isRtl ? TextDirectionHeuristics.RTL : TextDirectionHeuristics.LTR));
    }
    return result.toString();
}","{
    if (str == null)
        return null;
    final boolean isRtl = heuristic.isRtl(str, 0, str.length());
    StringBuilder result = new StringBuilder();
    if (getStereoReset() && isolate) {
        result.append(markBefore(str, isRtl ? TextDirectionHeuristics.RTL : TextDirectionHeuristics.LTR));
    }
    if (isRtl != mIsRtlContext) {
        result.append(isRtl ? RLE : LRE);
        result.append(str);
        result.append(PDF);
    } else {
        result.append(str);
    }
    if (isolate) {
        result.append(markAfter(str, isRtl ? TextDirectionHeuristics.RTL : TextDirectionHeuristics.LTR));
    }
    return result.toString();
}",1,"/**
 * Formats a string of given directionality for use in plain-text output of the context
 * directionality, so an opposite-directionality string is neither garbled nor garbles its
 * surroundings. This makes use of Unicode bidi formatting characters.
 * <p>
 * The algorithm: In case the given directionality doesn't match the context directionality, wraps
 * the string with Unicode bidi formatting characters: RLE+{@code str}+PDF for RTL text, or
 * LRE+{@code str}+PDF for LTR text.
 * <p>
 * If {@code isolate}, directionally isolates the string so that it does not garble its
 * surroundings. Currently, this is done by ""resetting"" the directionality after the string by
 * appending a trailing Unicode bidi mark matching the context directionality (LRM or RLM) when
 * either the overall directionality or the exit directionality of the string is opposite to that
 * of the context. If the formatter was built using {@link Builder#stereoReset(boolean)} and
 * passing ""true"" as an argument, also prepends a Unicode bidi mark matching the context
 * directionality when either the overall directionality or the entry directionality of the
 * string is opposite to that of the context. Note that as opposed to the overall
 * directionality, the entry and exit directionalities are determined from the string itself.
 * <p>
 * Does *not* do HTML-escaping.
 *
 * @param str The input string.
 * @param heuristic The algorithm to be used to estimate the string's overall direction.
 * See {@link TextDirectionHeuristics} for pre-defined heuristics.
 * @param isolate Whether to directionally isolate the string to prevent it from garbling the
 * content around it
 * @return Input string after applying the above processing.
 */
","/**
 * Formats a string of given directionality for use in plain-text output of the context
 * directionality, so an opposite-directionality string is neither garbled nor garbles its
 * surroundings. This makes use of Unicode bidi formatting characters.
 * <p>
 * The algorithm: In case the given directionality doesn't match the context directionality, wraps
 * the string with Unicode bidi formatting characters: RLE+{@code str}+PDF for RTL text, or
 * LRE+{@code str}+PDF for LTR text.
 * <p>
 * If {@code isolate}, directionally isolates the string so that it does not garble its
 * surroundings. Currently, this is done by ""resetting"" the directionality after the string by
 * appending a trailing Unicode bidi mark matching the context directionality (LRM or RLM) when
 * either the overall directionality or the exit directionality of the string is opposite to
 * that of the context. Unless the formatter was built using
 * {@link Builder#stereoReset(boolean)} with a {@code false} argument, also prepends a Unicode
 * bidi mark matching the context directionality when either the overall directionality or the
 * entry directionality of the string is opposite to that of the context. Note that as opposed
 * to the overall directionality, the entry and exit directionalities are determined from the
 * string itself.
 * <p>
 * Does *not* do HTML-escaping.
 *
 * @param str The input string.
 * @param heuristic The algorithm to be used to estimate the string's overall direction.
 * See {@link TextDirectionHeuristics} for pre-defined heuristics.
 * @param isolate Whether to directionally isolate the string to prevent it from garbling the
 * content around it
 * @return Input string after applying the above processing. {@code null} if {@code str} is
 * {@code null}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"A new control statement to check if the input string is null has been added at the beginning of the late implementation. As this is the only change and it is not within an existing control structure, nor does it affect exception handling or return values for non-null inputs, the code change type is 4 (Other statement changed).","The addition of the null check introduces a new early return for null inputs, resulting in a 'null' return value instead of a potential NullPointerException that may have been thrown by heuristic.isRtl(str, 0, str.length()) in the early version. However, in the strict sense, returning 'null' directly for a null input could be considered the expected behavior for a well-behaved API. Therefore, this might not introduce a behavior change that is considered a Compatibility Issue, and we can classify it as 0 (No Compatibility Issue). In the strict interpretation of the instructions, the change does not introduce different return values for non-null inputs or different exception handling; it merely makes the behavior for null inputs explicit."
663,<android.animation.FloatKeyframeSet: float getFloatValue(float)>,22,23,<android.animation.FloatKeyframeSet: float getFloatValue(float)>,<android.animation.FloatKeyframeSet: float getFloatValue(float)>,0,"{
    if (mNumKeyframes == 2) {
        if (firstTime) {
            firstTime = false;
            firstValue = ((FloatKeyframe) mKeyframes.get(0)).getFloatValue();
            lastValue = ((FloatKeyframe) mKeyframes.get(1)).getFloatValue();
            deltaValue = lastValue - firstValue;
        }
        if (mInterpolator != null) {
            fraction = mInterpolator.getInterpolation(fraction);
        }
        if (mEvaluator == null) {
            return firstValue + fraction * deltaValue;
        } else {
            return ((Number) mEvaluator.evaluate(fraction, firstValue, lastValue)).floatValue();
        }
    }
    if (fraction <= 0f) {
        final FloatKeyframe prevKeyframe = (FloatKeyframe) mKeyframes.get(0);
        final FloatKeyframe nextKeyframe = (FloatKeyframe) mKeyframes.get(1);
        float prevValue = prevKeyframe.getFloatValue();
        float nextValue = nextKeyframe.getFloatValue();
        float prevFraction = prevKeyframe.getFraction();
        float nextFraction = nextKeyframe.getFraction();
        final TimeInterpolator interpolator = nextKeyframe.getInterpolator();
        if (interpolator != null) {
            fraction = interpolator.getInterpolation(fraction);
        }
        float intervalFraction = (fraction - prevFraction) / (nextFraction - prevFraction);
        return mEvaluator == null ? prevValue + intervalFraction * (nextValue - prevValue) : ((Number) mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).floatValue();
    } else if (fraction >= 1f) {
        final FloatKeyframe prevKeyframe = (FloatKeyframe) mKeyframes.get(mNumKeyframes - 2);
        final FloatKeyframe nextKeyframe = (FloatKeyframe) mKeyframes.get(mNumKeyframes - 1);
        float prevValue = prevKeyframe.getFloatValue();
        float nextValue = nextKeyframe.getFloatValue();
        float prevFraction = prevKeyframe.getFraction();
        float nextFraction = nextKeyframe.getFraction();
        final TimeInterpolator interpolator = nextKeyframe.getInterpolator();
        if (interpolator != null) {
            fraction = interpolator.getInterpolation(fraction);
        }
        float intervalFraction = (fraction - prevFraction) / (nextFraction - prevFraction);
        return mEvaluator == null ? prevValue + intervalFraction * (nextValue - prevValue) : ((Number) mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).floatValue();
    }
    FloatKeyframe prevKeyframe = (FloatKeyframe) mKeyframes.get(0);
    for (int i = 1; i < mNumKeyframes; ++i) {
        FloatKeyframe nextKeyframe = (FloatKeyframe) mKeyframes.get(i);
        if (fraction < nextKeyframe.getFraction()) {
            final TimeInterpolator interpolator = nextKeyframe.getInterpolator();
            if (interpolator != null) {
                fraction = interpolator.getInterpolation(fraction);
            }
            float intervalFraction = (fraction - prevKeyframe.getFraction()) / (nextKeyframe.getFraction() - prevKeyframe.getFraction());
            float prevValue = prevKeyframe.getFloatValue();
            float nextValue = nextKeyframe.getFloatValue();
            return mEvaluator == null ? prevValue + intervalFraction * (nextValue - prevValue) : ((Number) mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).floatValue();
        }
        prevKeyframe = nextKeyframe;
    }
    // shouldn't get here
    return ((Number) mKeyframes.get(mNumKeyframes - 1).getValue()).floatValue();
}","{
    if (mNumKeyframes == 2) {
        if (firstTime) {
            firstTime = false;
            firstValue = ((FloatKeyframe) mKeyframes.get(0)).getFloatValue();
            lastValue = ((FloatKeyframe) mKeyframes.get(1)).getFloatValue();
            deltaValue = lastValue - firstValue;
        }
        if (mInterpolator != null) {
            fraction = mInterpolator.getInterpolation(fraction);
        }
        if (mEvaluator == null) {
            return firstValue + fraction * deltaValue;
        } else {
            return ((Number) mEvaluator.evaluate(fraction, firstValue, lastValue)).floatValue();
        }
    }
    if (fraction <= 0f) {
        final FloatKeyframe prevKeyframe = (FloatKeyframe) mKeyframes.get(0);
        final FloatKeyframe nextKeyframe = (FloatKeyframe) mKeyframes.get(1);
        float prevValue = prevKeyframe.getFloatValue();
        float nextValue = nextKeyframe.getFloatValue();
        float prevFraction = prevKeyframe.getFraction();
        float nextFraction = nextKeyframe.getFraction();
        final TimeInterpolator interpolator = nextKeyframe.getInterpolator();
        if (interpolator != null) {
            fraction = interpolator.getInterpolation(fraction);
        }
        float intervalFraction = (fraction - prevFraction) / (nextFraction - prevFraction);
        return mEvaluator == null ? prevValue + intervalFraction * (nextValue - prevValue) : ((Number) mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).floatValue();
    } else if (fraction >= 1f) {
        final FloatKeyframe prevKeyframe = (FloatKeyframe) mKeyframes.get(mNumKeyframes - 2);
        final FloatKeyframe nextKeyframe = (FloatKeyframe) mKeyframes.get(mNumKeyframes - 1);
        float prevValue = prevKeyframe.getFloatValue();
        float nextValue = nextKeyframe.getFloatValue();
        float prevFraction = prevKeyframe.getFraction();
        float nextFraction = nextKeyframe.getFraction();
        final TimeInterpolator interpolator = nextKeyframe.getInterpolator();
        if (interpolator != null) {
            fraction = interpolator.getInterpolation(fraction);
        }
        float intervalFraction = (fraction - prevFraction) / (nextFraction - prevFraction);
        return mEvaluator == null ? prevValue + intervalFraction * (nextValue - prevValue) : ((Number) mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).floatValue();
    }
    FloatKeyframe prevKeyframe = (FloatKeyframe) mKeyframes.get(0);
    for (int i = 1; i < mNumKeyframes; ++i) {
        FloatKeyframe nextKeyframe = (FloatKeyframe) mKeyframes.get(i);
        if (fraction < nextKeyframe.getFraction()) {
            final TimeInterpolator interpolator = nextKeyframe.getInterpolator();
            float intervalFraction = (fraction - prevKeyframe.getFraction()) / (nextKeyframe.getFraction() - prevKeyframe.getFraction());
            float prevValue = prevKeyframe.getFloatValue();
            float nextValue = nextKeyframe.getFloatValue();
            // Apply interpolator on the proportional duration.
            if (interpolator != null) {
                intervalFraction = interpolator.getInterpolation(intervalFraction);
            }
            return mEvaluator == null ? prevValue + intervalFraction * (nextValue - prevValue) : ((Number) mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).floatValue();
        }
        prevKeyframe = nextKeyframe;
    }
    // shouldn't get here
    return ((Number) mKeyframes.get(mNumKeyframes - 1).getValue()).floatValue();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
665,<android.speech.tts.TextToSpeech: Voice getVoice()>,22,23,<android.speech.tts.TextToSpeech: Voice getVoice()>,<android.speech.tts.TextToSpeech: Voice getVoice()>,0,"{
    return runAction(new Action<Voice>() {

        @Override
        public Voice run(ITextToSpeechService service) throws RemoteException {
            String voiceName = mParams.getString(Engine.KEY_PARAM_VOICE_NAME, """");
            if (TextUtils.isEmpty(voiceName)) {
                return null;
            }
            List<Voice> voices = service.getVoices();
            if (voices == null) {
                return null;
            }
            for (Voice voice : voices) {
                if (voice.getName().equals(voiceName)) {
                    return voice;
                }
            }
            return null;
        }
    }, null, ""getVoice"");
}","{
    return runAction(new Action<Voice>() {

        @Override
        public Voice run(ITextToSpeechService service) throws RemoteException {
            String voiceName = mParams.getString(Engine.KEY_PARAM_VOICE_NAME, """");
            if (TextUtils.isEmpty(voiceName)) {
                return null;
            }
            return getVoice(service, voiceName);
        }
    }, null, ""getVoice"");
}",1,"/**
 * Returns a Voice instance describing the voice currently being used for synthesis
 * requests sent to the TextToSpeech engine.
 *
 * @return Voice instance used by the client, or {@code null} if not set or on error.
 *
 * @see #getVoices
 * @see #setVoice
 * @see Voice
 */
","/**
 * Returns a Voice instance describing the voice currently being used for synthesis
 * requests sent to the TextToSpeech engine.
 *
 * @return Voice instance used by the client, or {@code null} if not set or on error.
 *
 * @see #getVoices
 * @see #setVoice
 * @see Voice
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The method body of the anonymous new Action<Voice>() has been simplified, and the code responsible for iterating over the List of Voice objects has been replaced with a call to the method getVoice(service, voiceName). This is code change type 4, since the body of a method has changed without affecting control flow, exception handling, or return statements. Additionally, it falls under change type 5 since it's a change in a dependent API where the getVoices() call and the iteration over the List of Voice objects is encapsulated in the new getVoice method.","Since there is a change in the implementation of how the Voice object is retrieved, which includes the use of a different method that is not detailed here, it could potentially lead to a different return value especially if the getVoice method implementation has different logic for retrieving the Voice object. This would be a CI of type 1 caused by potential different return values."
667,"<android.app.FragmentManagerImpl: void moveToState(Fragment,int,int,int,boolean)>",22,23,"<android.app.FragmentManagerImpl: void moveToState(Fragment,int,int,int,boolean)>","<android.app.FragmentManagerImpl: void moveToState(Fragment,int,int,int,boolean)>",0,"{
    if (DEBUG && false)
        Log.v(TAG, ""moveToState: "" + f + "" oldState="" + f.mState + "" newState="" + newState + "" mRemoving="" + f.mRemoving + "" Callers="" + Debug.getCallers(5));
    // Fragments that are not currently added will sit in the onCreate() state.
    if ((!f.mAdded || f.mDetached) && newState > Fragment.CREATED) {
        newState = Fragment.CREATED;
    }
    if (f.mRemoving && newState > f.mState) {
        // While removing a fragment, we can't change it to a higher state.
        newState = f.mState;
    }
    // if it's not already started.
    if (f.mDeferStart && f.mState < Fragment.STARTED && newState > Fragment.STOPPED) {
        newState = Fragment.STOPPED;
    }
    if (f.mState < newState) {
        // being reloaded from the layout.
        if (f.mFromLayout && !f.mInLayout) {
            return;
        }
        if (f.mAnimatingAway != null) {
            // The fragment is currently being animated...  but!  Now we
            // want to move our state back up.  Give up on waiting for the
            // animation, move to whatever the final state should be once
            // the animation is done, and then we can proceed from there.
            f.mAnimatingAway = null;
            moveToState(f, f.mStateAfterAnimating, 0, 0, true);
        }
        switch(f.mState) {
            case Fragment.INITIALIZING:
                if (DEBUG)
                    Log.v(TAG, ""moveto CREATED: "" + f);
                if (f.mSavedFragmentState != null) {
                    f.mSavedViewState = f.mSavedFragmentState.getSparseParcelableArray(FragmentManagerImpl.VIEW_STATE_TAG);
                    f.mTarget = getFragment(f.mSavedFragmentState, FragmentManagerImpl.TARGET_STATE_TAG);
                    if (f.mTarget != null) {
                        f.mTargetRequestCode = f.mSavedFragmentState.getInt(FragmentManagerImpl.TARGET_REQUEST_CODE_STATE_TAG, 0);
                    }
                    f.mUserVisibleHint = f.mSavedFragmentState.getBoolean(FragmentManagerImpl.USER_VISIBLE_HINT_TAG, true);
                    if (!f.mUserVisibleHint) {
                        f.mDeferStart = true;
                        if (newState > Fragment.STOPPED) {
                            newState = Fragment.STOPPED;
                        }
                    }
                }
                f.mActivity = mActivity;
                f.mParentFragment = mParent;
                f.mFragmentManager = mParent != null ? mParent.mChildFragmentManager : mActivity.mFragments;
                f.mCalled = false;
                f.onAttach(mActivity);
                if (!f.mCalled) {
                    throw new SuperNotCalledException(""Fragment "" + f + "" did not call through to super.onAttach()"");
                }
                if (f.mParentFragment == null) {
                    mActivity.onAttachFragment(f);
                }
                if (!f.mRetaining) {
                    f.performCreate(f.mSavedFragmentState);
                }
                f.mRetaining = false;
                if (f.mFromLayout) {
                    // For fragments that are part of the content view
                    // layout, we need to instantiate the view immediately
                    // and the inflater will take care of adding it.
                    f.mView = f.performCreateView(f.getLayoutInflater(f.mSavedFragmentState), null, f.mSavedFragmentState);
                    if (f.mView != null) {
                        f.mView.setSaveFromParentEnabled(false);
                        if (f.mHidden)
                            f.mView.setVisibility(View.GONE);
                        f.onViewCreated(f.mView, f.mSavedFragmentState);
                    }
                }
            case Fragment.CREATED:
                if (newState > Fragment.CREATED) {
                    if (DEBUG)
                        Log.v(TAG, ""moveto ACTIVITY_CREATED: "" + f);
                    if (!f.mFromLayout) {
                        ViewGroup container = null;
                        if (f.mContainerId != 0) {
                            container = (ViewGroup) mContainer.findViewById(f.mContainerId);
                            if (container == null && !f.mRestored) {
                                throwException(new IllegalArgumentException(""No view found for id 0x"" + Integer.toHexString(f.mContainerId) + "" ("" + f.getResources().getResourceName(f.mContainerId) + "") for fragment "" + f));
                            }
                        }
                        f.mContainer = container;
                        f.mView = f.performCreateView(f.getLayoutInflater(f.mSavedFragmentState), container, f.mSavedFragmentState);
                        if (f.mView != null) {
                            f.mView.setSaveFromParentEnabled(false);
                            if (container != null) {
                                Animator anim = loadAnimator(f, transit, true, transitionStyle);
                                if (anim != null) {
                                    anim.setTarget(f.mView);
                                    anim.start();
                                }
                                container.addView(f.mView);
                            }
                            if (f.mHidden)
                                f.mView.setVisibility(View.GONE);
                            f.onViewCreated(f.mView, f.mSavedFragmentState);
                        }
                    }
                    f.performActivityCreated(f.mSavedFragmentState);
                    if (f.mView != null) {
                        f.restoreViewState(f.mSavedFragmentState);
                    }
                    f.mSavedFragmentState = null;
                }
            case Fragment.ACTIVITY_CREATED:
            case Fragment.STOPPED:
                if (newState > Fragment.STOPPED) {
                    if (DEBUG)
                        Log.v(TAG, ""moveto STARTED: "" + f);
                    f.performStart();
                }
            case Fragment.STARTED:
                if (newState > Fragment.STARTED) {
                    if (DEBUG)
                        Log.v(TAG, ""moveto RESUMED: "" + f);
                    f.mResumed = true;
                    f.performResume();
                    // Get rid of this in case we saved it and never needed it.
                    f.mSavedFragmentState = null;
                    f.mSavedViewState = null;
                }
        }
    } else if (f.mState > newState) {
        switch(f.mState) {
            case Fragment.RESUMED:
                if (newState < Fragment.RESUMED) {
                    if (DEBUG)
                        Log.v(TAG, ""movefrom RESUMED: "" + f);
                    f.performPause();
                    f.mResumed = false;
                }
            case Fragment.STARTED:
                if (newState < Fragment.STARTED) {
                    if (DEBUG)
                        Log.v(TAG, ""movefrom STARTED: "" + f);
                    f.performStop();
                }
            case Fragment.STOPPED:
            case Fragment.ACTIVITY_CREATED:
                if (newState < Fragment.ACTIVITY_CREATED) {
                    if (DEBUG)
                        Log.v(TAG, ""movefrom ACTIVITY_CREATED: "" + f);
                    if (f.mView != null) {
                        // done already.
                        if (!mActivity.isFinishing() && f.mSavedViewState == null) {
                            saveFragmentViewState(f);
                        }
                    }
                    f.performDestroyView();
                    if (f.mView != null && f.mContainer != null) {
                        Animator anim = null;
                        if (mCurState > Fragment.INITIALIZING && !mDestroyed) {
                            anim = loadAnimator(f, transit, false, transitionStyle);
                        }
                        if (anim != null) {
                            final ViewGroup container = f.mContainer;
                            final View view = f.mView;
                            final Fragment fragment = f;
                            container.startViewTransition(view);
                            f.mAnimatingAway = anim;
                            f.mStateAfterAnimating = newState;
                            anim.addListener(new AnimatorListenerAdapter() {

                                @Override
                                public void onAnimationEnd(Animator anim) {
                                    container.endViewTransition(view);
                                    if (fragment.mAnimatingAway != null) {
                                        fragment.mAnimatingAway = null;
                                        moveToState(fragment, fragment.mStateAfterAnimating, 0, 0, false);
                                    }
                                }
                            });
                            anim.setTarget(f.mView);
                            anim.start();
                        }
                        f.mContainer.removeView(f.mView);
                    }
                    f.mContainer = null;
                    f.mView = null;
                }
            case Fragment.CREATED:
                if (newState < Fragment.CREATED) {
                    if (mDestroyed) {
                        if (f.mAnimatingAway != null) {
                            // The fragment's containing activity is
                            // being destroyed, but this fragment is
                            // currently animating away.  Stop the
                            // animation right now -- it is not needed,
                            // and we can't wait any more on destroying
                            // the fragment.
                            Animator anim = f.mAnimatingAway;
                            f.mAnimatingAway = null;
                            anim.cancel();
                        }
                    }
                    if (f.mAnimatingAway != null) {
                        // We are waiting for the fragment's view to finish
                        // animating away.  Just make a note of the state
                        // the fragment now should move to once the animation
                        // is done.
                        f.mStateAfterAnimating = newState;
                        newState = Fragment.CREATED;
                    } else {
                        if (DEBUG)
                            Log.v(TAG, ""movefrom CREATED: "" + f);
                        if (!f.mRetaining) {
                            f.performDestroy();
                        }
                        f.mCalled = false;
                        f.onDetach();
                        if (!f.mCalled) {
                            throw new SuperNotCalledException(""Fragment "" + f + "" did not call through to super.onDetach()"");
                        }
                        if (!keepActive) {
                            if (!f.mRetaining) {
                                makeInactive(f);
                            } else {
                                f.mActivity = null;
                                f.mParentFragment = null;
                                f.mFragmentManager = null;
                                f.mChildFragmentManager = null;
                            }
                        }
                    }
                }
        }
    }
    f.mState = newState;
}","{
    if (DEBUG && false)
        Log.v(TAG, ""moveToState: "" + f + "" oldState="" + f.mState + "" newState="" + newState + "" mRemoving="" + f.mRemoving + "" Callers="" + Debug.getCallers(5));
    // Fragments that are not currently added will sit in the onCreate() state.
    if ((!f.mAdded || f.mDetached) && newState > Fragment.CREATED) {
        newState = Fragment.CREATED;
    }
    if (f.mRemoving && newState > f.mState) {
        // While removing a fragment, we can't change it to a higher state.
        newState = f.mState;
    }
    // if it's not already started.
    if (f.mDeferStart && f.mState < Fragment.STARTED && newState > Fragment.STOPPED) {
        newState = Fragment.STOPPED;
    }
    if (f.mState < newState) {
        // being reloaded from the layout.
        if (f.mFromLayout && !f.mInLayout) {
            return;
        }
        if (f.mAnimatingAway != null) {
            // The fragment is currently being animated...  but!  Now we
            // want to move our state back up.  Give up on waiting for the
            // animation, move to whatever the final state should be once
            // the animation is done, and then we can proceed from there.
            f.mAnimatingAway = null;
            moveToState(f, f.mStateAfterAnimating, 0, 0, true);
        }
        switch(f.mState) {
            case Fragment.INITIALIZING:
                if (DEBUG)
                    Log.v(TAG, ""moveto CREATED: "" + f);
                if (f.mSavedFragmentState != null) {
                    f.mSavedViewState = f.mSavedFragmentState.getSparseParcelableArray(FragmentManagerImpl.VIEW_STATE_TAG);
                    f.mTarget = getFragment(f.mSavedFragmentState, FragmentManagerImpl.TARGET_STATE_TAG);
                    if (f.mTarget != null) {
                        f.mTargetRequestCode = f.mSavedFragmentState.getInt(FragmentManagerImpl.TARGET_REQUEST_CODE_STATE_TAG, 0);
                    }
                    f.mUserVisibleHint = f.mSavedFragmentState.getBoolean(FragmentManagerImpl.USER_VISIBLE_HINT_TAG, true);
                    if (!f.mUserVisibleHint) {
                        f.mDeferStart = true;
                        if (newState > Fragment.STOPPED) {
                            newState = Fragment.STOPPED;
                        }
                    }
                }
                f.mHost = mHost;
                f.mParentFragment = mParent;
                f.mFragmentManager = mParent != null ? mParent.mChildFragmentManager : mHost.getFragmentManagerImpl();
                f.mCalled = false;
                f.onAttach(mHost.getContext());
                if (!f.mCalled) {
                    throw new SuperNotCalledException(""Fragment "" + f + "" did not call through to super.onAttach()"");
                }
                if (f.mParentFragment == null) {
                    mHost.onAttachFragment(f);
                }
                if (!f.mRetaining) {
                    f.performCreate(f.mSavedFragmentState);
                }
                f.mRetaining = false;
                if (f.mFromLayout) {
                    // For fragments that are part of the content view
                    // layout, we need to instantiate the view immediately
                    // and the inflater will take care of adding it.
                    f.mView = f.performCreateView(f.getLayoutInflater(f.mSavedFragmentState), null, f.mSavedFragmentState);
                    if (f.mView != null) {
                        f.mView.setSaveFromParentEnabled(false);
                        if (f.mHidden)
                            f.mView.setVisibility(View.GONE);
                        f.onViewCreated(f.mView, f.mSavedFragmentState);
                    }
                }
            case Fragment.CREATED:
                if (newState > Fragment.CREATED) {
                    if (DEBUG)
                        Log.v(TAG, ""moveto ACTIVITY_CREATED: "" + f);
                    if (!f.mFromLayout) {
                        ViewGroup container = null;
                        if (f.mContainerId != 0) {
                            container = (ViewGroup) mContainer.onFindViewById(f.mContainerId);
                            if (container == null && !f.mRestored) {
                                throwException(new IllegalArgumentException(""No view found for id 0x"" + Integer.toHexString(f.mContainerId) + "" ("" + f.getResources().getResourceName(f.mContainerId) + "") for fragment "" + f));
                            }
                        }
                        f.mContainer = container;
                        f.mView = f.performCreateView(f.getLayoutInflater(f.mSavedFragmentState), container, f.mSavedFragmentState);
                        if (f.mView != null) {
                            f.mView.setSaveFromParentEnabled(false);
                            if (container != null) {
                                Animator anim = loadAnimator(f, transit, true, transitionStyle);
                                if (anim != null) {
                                    anim.setTarget(f.mView);
                                    setHWLayerAnimListenerIfAlpha(f.mView, anim);
                                    anim.start();
                                }
                                container.addView(f.mView);
                            }
                            if (f.mHidden)
                                f.mView.setVisibility(View.GONE);
                            f.onViewCreated(f.mView, f.mSavedFragmentState);
                        }
                    }
                    f.performActivityCreated(f.mSavedFragmentState);
                    if (f.mView != null) {
                        f.restoreViewState(f.mSavedFragmentState);
                    }
                    f.mSavedFragmentState = null;
                }
            case Fragment.ACTIVITY_CREATED:
            case Fragment.STOPPED:
                if (newState > Fragment.STOPPED) {
                    if (DEBUG)
                        Log.v(TAG, ""moveto STARTED: "" + f);
                    f.performStart();
                }
            case Fragment.STARTED:
                if (newState > Fragment.STARTED) {
                    if (DEBUG)
                        Log.v(TAG, ""moveto RESUMED: "" + f);
                    f.mResumed = true;
                    f.performResume();
                    // Get rid of this in case we saved it and never needed it.
                    f.mSavedFragmentState = null;
                    f.mSavedViewState = null;
                }
        }
    } else if (f.mState > newState) {
        switch(f.mState) {
            case Fragment.RESUMED:
                if (newState < Fragment.RESUMED) {
                    if (DEBUG)
                        Log.v(TAG, ""movefrom RESUMED: "" + f);
                    f.performPause();
                    f.mResumed = false;
                }
            case Fragment.STARTED:
                if (newState < Fragment.STARTED) {
                    if (DEBUG)
                        Log.v(TAG, ""movefrom STARTED: "" + f);
                    f.performStop();
                }
            case Fragment.STOPPED:
            case Fragment.ACTIVITY_CREATED:
                if (newState < Fragment.ACTIVITY_CREATED) {
                    if (DEBUG)
                        Log.v(TAG, ""movefrom ACTIVITY_CREATED: "" + f);
                    if (f.mView != null) {
                        // done already.
                        if (mHost.onShouldSaveFragmentState(f) && f.mSavedViewState == null) {
                            saveFragmentViewState(f);
                        }
                    }
                    f.performDestroyView();
                    if (f.mView != null && f.mContainer != null) {
                        Animator anim = null;
                        if (mCurState > Fragment.INITIALIZING && !mDestroyed) {
                            anim = loadAnimator(f, transit, false, transitionStyle);
                        }
                        if (anim != null) {
                            final ViewGroup container = f.mContainer;
                            final View view = f.mView;
                            final Fragment fragment = f;
                            container.startViewTransition(view);
                            f.mAnimatingAway = anim;
                            f.mStateAfterAnimating = newState;
                            anim.addListener(new AnimatorListenerAdapter() {

                                @Override
                                public void onAnimationEnd(Animator anim) {
                                    container.endViewTransition(view);
                                    if (fragment.mAnimatingAway != null) {
                                        fragment.mAnimatingAway = null;
                                        moveToState(fragment, fragment.mStateAfterAnimating, 0, 0, false);
                                    }
                                }
                            });
                            anim.setTarget(f.mView);
                            setHWLayerAnimListenerIfAlpha(f.mView, anim);
                            anim.start();
                        }
                        f.mContainer.removeView(f.mView);
                    }
                    f.mContainer = null;
                    f.mView = null;
                }
            case Fragment.CREATED:
                if (newState < Fragment.CREATED) {
                    if (mDestroyed) {
                        if (f.mAnimatingAway != null) {
                            // The fragment's containing activity is
                            // being destroyed, but this fragment is
                            // currently animating away.  Stop the
                            // animation right now -- it is not needed,
                            // and we can't wait any more on destroying
                            // the fragment.
                            Animator anim = f.mAnimatingAway;
                            f.mAnimatingAway = null;
                            anim.cancel();
                        }
                    }
                    if (f.mAnimatingAway != null) {
                        // We are waiting for the fragment's view to finish
                        // animating away.  Just make a note of the state
                        // the fragment now should move to once the animation
                        // is done.
                        f.mStateAfterAnimating = newState;
                        newState = Fragment.CREATED;
                    } else {
                        if (DEBUG)
                            Log.v(TAG, ""movefrom CREATED: "" + f);
                        if (!f.mRetaining) {
                            f.performDestroy();
                        }
                        f.mCalled = false;
                        f.onDetach();
                        if (!f.mCalled) {
                            throw new SuperNotCalledException(""Fragment "" + f + "" did not call through to super.onDetach()"");
                        }
                        if (!keepActive) {
                            if (!f.mRetaining) {
                                makeInactive(f);
                            } else {
                                f.mHost = null;
                                f.mParentFragment = null;
                                f.mFragmentManager = null;
                                f.mChildFragmentManager = null;
                            }
                        }
                    }
                }
        }
    }
    f.mState = newState;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
671,<android.hardware.camera2.CameraManager.CameraManagerGlobal: ICameraService getCameraService()>,22,23,<android.hardware.camera2.CameraManager.CameraManagerGlobal: ICameraService getCameraService()>,<android.hardware.camera2.CameraManager.CameraManagerGlobal: ICameraService getCameraService()>,0,"{
    synchronized (mLock) {
        if (mCameraService == null) {
            Log.i(TAG, ""getCameraService: Reconnecting to camera service"");
            connectCameraServiceLocked();
            if (mCameraService == null) {
                Log.e(TAG, ""Camera service is unavailable"");
            }
        }
        return mCameraService;
    }
}","{
    synchronized (mLock) {
        connectCameraServiceLocked();
        if (mCameraService == null) {
            Log.e(TAG, ""Camera service is unavailable"");
        }
        return mCameraService;
    }
}",1,"/**
 * Return a best-effort ICameraService.
 *
 * <p>This will be null if the camera service is not currently available. If the camera
 * service has died since the last use of the camera service, will try to reconnect to the
 * service.</p>
 */
","/**
 * Return a best-effort ICameraService.
 *
 * <p>This will be null if the camera service is not currently available. If the camera
 * service has died since the last use of the camera service, will try to reconnect to the
 * service.</p>
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The early implementation has an additional condition check for `mCameraService == null` before calling `connectCameraServiceLocked()`, which was removed in the late implementation. Additionally, an informative log statement before attempting to reconnect has been deleted. This falls under control dependency change (3) because the control flow has been altered with the removal of the `if` statement, and it is also an other statement change (4) since a log statement has been removed.","Despite the modified control flow and deleted log message, this does not constitute a Compatibility Issue because the ultimate behavior of returning `mCameraService` remains unmodified. The method will still attempt to connect to the camera service via `connectCameraServiceLocked()` and return the current state of `mCameraService`, which could be null in both versions. This represents no change in the possible return value or exception handling, hence there is no Compatibility Issue (0)."
672,<android.print.PrinterCapabilitiesInfo: String toString()>,22,23,<android.print.PrinterCapabilitiesInfo: String toString()>,<android.print.PrinterCapabilitiesInfo: String toString()>,0,"{
    StringBuilder builder = new StringBuilder();
    builder.append(""PrinterInfo{"");
    builder.append(""minMargins="").append(mMinMargins);
    builder.append("", mediaSizes="").append(mMediaSizes);
    builder.append("", resolutions="").append(mResolutions);
    builder.append("", colorModes="").append(colorModesToString());
    builder.append(""\""}"");
    return builder.toString();
}","{
    StringBuilder builder = new StringBuilder();
    builder.append(""PrinterInfo{"");
    builder.append(""minMargins="").append(mMinMargins);
    builder.append("", mediaSizes="").append(mMediaSizes);
    builder.append("", resolutions="").append(mResolutions);
    builder.append("", colorModes="").append(colorModesToString());
    builder.append("", duplexModes="").append(duplexModesToString());
    builder.append(""\""}"");
    return builder.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"There is an additional "".append()"" method call for the duplexModesToString() in the Late_Implementation which means a new string segment is added to the builder. Therefore, the builder will have an additional string segment before the "".toString()"" method is called, indicating both a Return statement changed and Other statement changed, hence the change type is 1,4.","The returned string from the toString() method will include an additional segment (""duplexModes=..."") in the Late_Version which was not present in the Early_Version. This means the API potentially returns a different value in the Late_Version, so the CI type is 1."
673,<android.widget.NumberPicker: void setMinValue(int)>,22,23,<android.widget.NumberPicker: void setMinValue(int)>,<android.widget.NumberPicker: void setMinValue(int)>,0,"{
    if (mMinValue == minValue) {
        return;
    }
    if (minValue < 0) {
        throw new IllegalArgumentException(""minValue must be >= 0"");
    }
    mMinValue = minValue;
    if (mMinValue > mValue) {
        mValue = mMinValue;
    }
    boolean wrapSelectorWheel = mMaxValue - mMinValue > mSelectorIndices.length;
    setWrapSelectorWheel(wrapSelectorWheel);
    initializeSelectorWheelIndices();
    updateInputTextView();
    tryComputeMaxWidth();
    invalidate();
}","{
    if (mMinValue == minValue) {
        return;
    }
    if (minValue < 0) {
        throw new IllegalArgumentException(""minValue must be >= 0"");
    }
    mMinValue = minValue;
    if (mMinValue > mValue) {
        mValue = mMinValue;
    }
    updateWrapSelectorWheel();
    initializeSelectorWheelIndices();
    updateInputTextView();
    tryComputeMaxWidth();
    invalidate();
}",1,"/**
 * Sets the min value of the picker.
 *
 * @param minValue The min value inclusive.
 *
 * <strong>Note:</strong> The length of the displayed values array
 * set via {@link #setDisplayedValues(String[])} must be equal to the
 * range of selectable numbers which is equal to
 * {@link #getMaxValue()} - {@link #getMinValue()} + 1.
 */
","/**
 * Sets the min value of the picker.
 *
 * @param minValue The min value inclusive.
 *
 * <strong>Note:</strong> The length of the displayed values array
 * set via {@link #setDisplayedValues(String[])} must be equal to the
 * range of selectable numbers which is equal to
 * {@link #getMaxValue()} - {@link #getMinValue()} + 1.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method setWrapSelectorWheel(wrapSelectorWheel) is replaced with updateWrapSelectorWheel(), altering the implementation but not the control flow or the return value. Additionally, the condition for setting the wrapSelectorWheel is removed, indicating a change in Other statement as well as a Dependent API change. The code change types are 4 and 5.","Despite changes to the methods used for checking wrapSelectorWheel and updating it, no return statement or exception handling has been modified. Moreover, these changes do not affect the return type or value, nor do they introduce new exceptions or alter the existing ones. Therefore, there is No Compatibility Issue."
674,"<android.bluetooth.BluetoothSocket: int write(byte[],int,int)>",22,23,"<android.bluetooth.BluetoothSocket: int write(byte[],int,int)>","<android.bluetooth.BluetoothSocket: int write(byte[],int,int)>",0,"{
    if (mSocketOS == null)
        throw new IOException(""write is called on null OutputStream"");
    if (VDBG)
        Log.d(TAG, ""write: "" + mSocketOS + "" length: "" + length);
    mSocketOS.write(b, offset, length);
    // There is no good way to confirm since the entire process is asynchronous anyway
    if (VDBG)
        Log.d(TAG, ""write out: "" + mSocketOS + "" length: "" + length);
    return length;
}","{
    // to the actual message length.
    if (VDBG)
        Log.d(TAG, ""write: "" + mSocketOS + "" length: "" + length);
    if (mType == TYPE_L2CAP) {
        if (length <= mMaxTxPacketSize) {
            mSocketOS.write(b, offset, length);
        } else {
            int tmpOffset = offset;
            int tmpLength = mMaxTxPacketSize;
            int endIndex = offset + length;
            boolean done = false;
            if (DBG)
                Log.w(TAG, ""WARNING: Write buffer larger than L2CAP packet size!\n"" + ""Packet will be divided into SDU packets of size "" + mMaxTxPacketSize);
            do {
                mSocketOS.write(b, tmpOffset, tmpLength);
                tmpOffset += mMaxTxPacketSize;
                if ((tmpOffset + mMaxTxPacketSize) > endIndex) {
                    tmpLength = endIndex - tmpOffset;
                    done = true;
                }
            } while (!done);
        }
    } else {
        mSocketOS.write(b, offset, length);
    }
    // There is no good way to confirm since the entire process is asynchronous anyway
    if (VDBG)
        Log.d(TAG, ""write out: "" + mSocketOS + "" length: "" + length);
    return length;
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"There are changes in the exception handling, control dependency, and other statements. Exception handling has changed because the early version explicitly throws an IOException if `mSocketOS` is null, while in the late version, this check is not present. A new control structure has been introduced to handle the case when `mType` equals `TYPE_L2CAP` that breaks down the write operation if the message length exceeds `mMaxTxPacketSize`, which is a control dependency change. Additionally, there are new log statements and a segment of the code that performs chunked writes, which counts as other statement changes. Thus, the code change types are 1, 3, 4.","There is a compatibility issue due to potentially different return values. In the early version, a fixed length value is always returned, whereas in the late version, the write operation may occur in chunks for TYPE_L2CAP, which could potentially change the behavior of the return if errors or interruptions occur during the chunked writes. As the control flow is different based on the condition of the type of the socket and the message length, it could lead to a scenario where not all data intended is written out before an issue is encountered, which could affect the amount of data reported as written. Therefore, the CI type is 1."
675,<android.widget.CheckedTextView: void setCheckMarkDrawable(int)>,22,23,<android.widget.CheckedTextView: void setCheckMarkDrawable(int)>,<android.widget.CheckedTextView: void setCheckMarkDrawable(int)>,0,"{
    if (resid != 0 && resid == mCheckMarkResource) {
        return;
    }
    mCheckMarkResource = resid;
    Drawable d = null;
    if (mCheckMarkResource != 0) {
        d = getContext().getDrawable(mCheckMarkResource);
    }
    setCheckMarkDrawable(d);
}","{
    if (resId != 0 && resId == mCheckMarkResource) {
        return;
    }
    mCheckMarkResource = resId;
    Drawable d = null;
    if (mCheckMarkResource != 0) {
        d = getContext().getDrawable(mCheckMarkResource);
    }
    setCheckMarkDrawable(d);
}",1,"/**
 * Set the checkmark to a given Drawable, identified by its resourece id. This will be drawn
 * when {@link #isChecked()} is true.
 *
 * @param resid The Drawable to use for the checkmark.
 *
 * @see #setCheckMarkDrawable(Drawable)
 * @see #getCheckMarkDrawable()
 *
 * @attr ref android.R.styleable#CheckedTextView_checkMark
 */
","/**
 * Sets the check mark to the drawable with the specified resource ID.
 * <p>
 * When this view is checked, the drawable's state set will include
 * {@link android.R.attr#state_checked}.
 *
 * @param resId the resource identifier of drawable to use as the check
 * mark
 * @attr ref android.R.styleable#CheckedTextView_checkMark
 * @see #setCheckMarkDrawable(Drawable)
 * @see #getCheckMarkDrawable()
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,There are no changes between the early and late version implementations besides the argument name from 'resid' to 'resId' which doesn't affect the code functionality. Thus the code change type is 0.,"Since no functionality has changed, the API behavior remains unchanged, and there are no Compatibility Issues. Therefore, the CI type is 0."
678,<android.content.IntentFilter: void readFromXml(XmlPullParser)>,22,23,<android.content.IntentFilter: void readFromXml(XmlPullParser)>,<android.content.IntentFilter: void readFromXml(XmlPullParser)>,0,"{
    int outerDepth = parser.getDepth();
    int type;
    while ((type = parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
        if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
            continue;
        }
        String tagName = parser.getName();
        if (tagName.equals(ACTION_STR)) {
            String name = parser.getAttributeValue(null, NAME_STR);
            if (name != null) {
                addAction(name);
            }
        } else if (tagName.equals(CAT_STR)) {
            String name = parser.getAttributeValue(null, NAME_STR);
            if (name != null) {
                addCategory(name);
            }
        } else if (tagName.equals(TYPE_STR)) {
            String name = parser.getAttributeValue(null, NAME_STR);
            if (name != null) {
                try {
                    addDataType(name);
                } catch (MalformedMimeTypeException e) {
                }
            }
        } else if (tagName.equals(SCHEME_STR)) {
            String name = parser.getAttributeValue(null, NAME_STR);
            if (name != null) {
                addDataScheme(name);
            }
        } else if (tagName.equals(SSP_STR)) {
            String ssp = parser.getAttributeValue(null, LITERAL_STR);
            if (ssp != null) {
                addDataSchemeSpecificPart(ssp, PatternMatcher.PATTERN_LITERAL);
            } else if ((ssp = parser.getAttributeValue(null, PREFIX_STR)) != null) {
                addDataSchemeSpecificPart(ssp, PatternMatcher.PATTERN_PREFIX);
            } else if ((ssp = parser.getAttributeValue(null, SGLOB_STR)) != null) {
                addDataSchemeSpecificPart(ssp, PatternMatcher.PATTERN_SIMPLE_GLOB);
            }
        } else if (tagName.equals(AUTH_STR)) {
            String host = parser.getAttributeValue(null, HOST_STR);
            String port = parser.getAttributeValue(null, PORT_STR);
            if (host != null) {
                addDataAuthority(host, port);
            }
        } else if (tagName.equals(PATH_STR)) {
            String path = parser.getAttributeValue(null, LITERAL_STR);
            if (path != null) {
                addDataPath(path, PatternMatcher.PATTERN_LITERAL);
            } else if ((path = parser.getAttributeValue(null, PREFIX_STR)) != null) {
                addDataPath(path, PatternMatcher.PATTERN_PREFIX);
            } else if ((path = parser.getAttributeValue(null, SGLOB_STR)) != null) {
                addDataPath(path, PatternMatcher.PATTERN_SIMPLE_GLOB);
            }
        } else {
            Log.w(""IntentFilter"", ""Unknown tag parsing IntentFilter: "" + tagName);
        }
        XmlUtils.skipCurrentTag(parser);
    }
}","{
    String autoVerify = parser.getAttributeValue(null, AUTO_VERIFY_STR);
    setAutoVerify(TextUtils.isEmpty(autoVerify) ? false : Boolean.getBoolean(autoVerify));
    int outerDepth = parser.getDepth();
    int type;
    while ((type = parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
        if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
            continue;
        }
        String tagName = parser.getName();
        if (tagName.equals(ACTION_STR)) {
            String name = parser.getAttributeValue(null, NAME_STR);
            if (name != null) {
                addAction(name);
            }
        } else if (tagName.equals(CAT_STR)) {
            String name = parser.getAttributeValue(null, NAME_STR);
            if (name != null) {
                addCategory(name);
            }
        } else if (tagName.equals(TYPE_STR)) {
            String name = parser.getAttributeValue(null, NAME_STR);
            if (name != null) {
                try {
                    addDataType(name);
                } catch (MalformedMimeTypeException e) {
                }
            }
        } else if (tagName.equals(SCHEME_STR)) {
            String name = parser.getAttributeValue(null, NAME_STR);
            if (name != null) {
                addDataScheme(name);
            }
        } else if (tagName.equals(SSP_STR)) {
            String ssp = parser.getAttributeValue(null, LITERAL_STR);
            if (ssp != null) {
                addDataSchemeSpecificPart(ssp, PatternMatcher.PATTERN_LITERAL);
            } else if ((ssp = parser.getAttributeValue(null, PREFIX_STR)) != null) {
                addDataSchemeSpecificPart(ssp, PatternMatcher.PATTERN_PREFIX);
            } else if ((ssp = parser.getAttributeValue(null, SGLOB_STR)) != null) {
                addDataSchemeSpecificPart(ssp, PatternMatcher.PATTERN_SIMPLE_GLOB);
            }
        } else if (tagName.equals(AUTH_STR)) {
            String host = parser.getAttributeValue(null, HOST_STR);
            String port = parser.getAttributeValue(null, PORT_STR);
            if (host != null) {
                addDataAuthority(host, port);
            }
        } else if (tagName.equals(PATH_STR)) {
            String path = parser.getAttributeValue(null, LITERAL_STR);
            if (path != null) {
                addDataPath(path, PatternMatcher.PATTERN_LITERAL);
            } else if ((path = parser.getAttributeValue(null, PREFIX_STR)) != null) {
                addDataPath(path, PatternMatcher.PATTERN_PREFIX);
            } else if ((path = parser.getAttributeValue(null, SGLOB_STR)) != null) {
                addDataPath(path, PatternMatcher.PATTERN_SIMPLE_GLOB);
            }
        } else {
            Log.w(""IntentFilter"", ""Unknown tag parsing IntentFilter: "" + tagName);
        }
        XmlUtils.skipCurrentTag(parser);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
679,<android.content.res.TypedArray: Drawable getDrawable(int)>,22,23,<android.content.res.TypedArray: Drawable getDrawable(int)>,<android.content.res.TypedArray: Drawable getDrawable(int)>,0,"{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    final TypedValue value = mValue;
    if (getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, value)) {
        if (value.type == TypedValue.TYPE_ATTRIBUTE) {
            throw new RuntimeException(""Failed to resolve attribute at index "" + index);
        }
        return mResources.loadDrawable(value, value.resourceId, mTheme);
    }
    return null;
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    final TypedValue value = mValue;
    if (getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, value)) {
        if (value.type == TypedValue.TYPE_ATTRIBUTE) {
            throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + index + "": "" + value);
        }
        return mResources.loadDrawable(value, value.resourceId, mTheme);
    }
    return null;
}",1,"/**
 * Retrieve the Drawable for the attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return Drawable for the attribute, or null if not defined.
 */
","/**
 * Retrieve the Drawable for the attribute at <var>index</var>.
 * <p>
 * This method will throw an exception if the attribute is defined but is
 * not a color or drawable resource.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return Drawable for the attribute, or {@code null} if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not a color or drawable resource.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,2,2,"The exception thrown has been changed from RuntimeException to UnsupportedOperationException, therefore, the exception handling statement has changed. This constitutes a change of type 2.","Because the type of exception thrown has been altered, the behavior of the method when encountering an attribute type value will be different, which results in a different exception handling situation. Thus, the potential CI is of type 2."
680,<android.net.NetworkInfo: String toString()>,22,23,<android.net.NetworkInfo: String toString()>,<android.net.NetworkInfo: String toString()>,0,"{
    synchronized (this) {
        StringBuilder builder = new StringBuilder(""["");
        builder.append(""type: "").append(getTypeName()).append(""["").append(getSubtypeName()).append(""], state: "").append(mState).append(""/"").append(mDetailedState).append("", reason: "").append(mReason == null ? ""(unspecified)"" : mReason).append("", extra: "").append(mExtraInfo == null ? ""(none)"" : mExtraInfo).append("", roaming: "").append(mIsRoaming).append("", failover: "").append(mIsFailover).append("", isAvailable: "").append(mIsAvailable).append("", isConnectedToProvisioningNetwork: "").append(mIsConnectedToProvisioningNetwork).append(""]"");
        return builder.toString();
    }
}","{
    synchronized (this) {
        StringBuilder builder = new StringBuilder(""["");
        builder.append(""type: "").append(getTypeName()).append(""["").append(getSubtypeName()).append(""], state: "").append(mState).append(""/"").append(mDetailedState).append("", reason: "").append(mReason == null ? ""(unspecified)"" : mReason).append("", extra: "").append(mExtraInfo == null ? ""(none)"" : mExtraInfo).append("", roaming: "").append(mIsRoaming).append("", failover: "").append(mIsFailover).append("", isAvailable: "").append(mIsAvailable).append(""]"");
        return builder.toString();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"There is a deletion of the statement appending isConnectedToProvisioningNetwork to the StringBuilder object, which is not a return, exception handling, or control dependency change; thus, it's an 'Other statement changed' making the change type 4.","Since the removed part of the string does not affect the method's behavior besides omitting a piece of information, no compatibility issue arises regarding the return value or the exceptions that might be thrown. Therefore, no compatibility issue is predicted in this case."
681,<android.widget.TextView: boolean onPreDraw()>,22,23,<android.widget.TextView: boolean onPreDraw()>,<android.widget.TextView: boolean onPreDraw()>,0,"{
    if (mLayout == null) {
        assumeLayout();
    }
    if (mMovement != null) {
        /* This code also provides auto-scrolling when a cursor is moved using a
             * CursorController (insertion point or selection limits).
             * For selection, ensure start or end is visible depending on controller's state.
             */
        int curs = getSelectionEnd();
        // Do not create the controller if it is not already created.
        if (mEditor != null && mEditor.mSelectionModifierCursorController != null && mEditor.mSelectionModifierCursorController.isSelectionStartDragged()) {
            curs = getSelectionStart();
        }
        /*
             * TODO: This should really only keep the end in view if
             * it already was before the text changed.  I'm not sure
             * of a good way to tell from here if it was.
             */
        if (curs < 0 && (mGravity & Gravity.VERTICAL_GRAVITY_MASK) == Gravity.BOTTOM) {
            curs = mText.length();
        }
        if (curs >= 0) {
            bringPointIntoView(curs);
        }
    } else {
        bringTextIntoView();
    }
    // a screen rotation) since layout is not yet initialized at that point.
    if (mEditor != null && mEditor.mCreatedWithASelection) {
        mEditor.startSelectionActionMode();
        mEditor.mCreatedWithASelection = false;
    }
    // not be set. Do the test here instead.
    if (this instanceof ExtractEditText && hasSelection() && mEditor != null) {
        mEditor.startSelectionActionMode();
    }
    unregisterForPreDraw();
    return true;
}","{
    if (mLayout == null) {
        assumeLayout();
    }
    if (mMovement != null) {
        /* This code also provides auto-scrolling when a cursor is moved using a
             * CursorController (insertion point or selection limits).
             * For selection, ensure start or end is visible depending on controller's state.
             */
        int curs = getSelectionEnd();
        // Do not create the controller if it is not already created.
        if (mEditor != null && mEditor.mSelectionModifierCursorController != null && mEditor.mSelectionModifierCursorController.isSelectionStartDragged()) {
            curs = getSelectionStart();
        }
        /*
             * TODO: This should really only keep the end in view if
             * it already was before the text changed.  I'm not sure
             * of a good way to tell from here if it was.
             */
        if (curs < 0 && (mGravity & Gravity.VERTICAL_GRAVITY_MASK) == Gravity.BOTTOM) {
            curs = mText.length();
        }
        if (curs >= 0) {
            bringPointIntoView(curs);
        }
    } else {
        bringTextIntoView();
    }
    // a screen rotation) since layout is not yet initialized at that point.
    if (mEditor != null && mEditor.mCreatedWithASelection) {
        if (mEditor.extractedTextModeWillBeStarted()) {
            mEditor.checkFieldAndSelectCurrentWord();
        } else {
            mEditor.startSelectionActionMode();
        }
        mEditor.mCreatedWithASelection = false;
    }
    // not be set. Do the test here instead.
    if (isInExtractedMode() && hasSelection() && mEditor != null && mEditor.mTextActionMode == null && isShown() && hasWindowFocus()) {
        mEditor.startSelectionActionMode();
    }
    unregisterForPreDraw();
    return true;
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"There are changes in the if-statement conditions and an additional control dependency related to the extracted text mode. Also, the implementation within an 'if' block has been extended to include an additional condition and method call with 'checkFieldAndSelectCurrentWord', and another 'if' condition seeing a change involving 'isInExtractedMode', 'mEditor.mTextActionMode', 'isShown', and 'hasWindowFocus'. These changes are classified as control dependency change (3) and other statement changed (4).","The conditions in which 'mEditor.startSelectionActionMode()' or the new 'mEditor.checkFieldAndSelectCurrentWord()' are called are modified, but the API would still return the same value (true) and the changes do not affect exception throwing behavior or the return type. Therefore, no compatibility issue is present related to the return type/value or the exceptions being thrown."
683,"<android.widget.Spinner.DialogPopup: void show(int,int)>",22,23,"<android.widget.Spinner.DialogPopup: void show(int,int)>","<android.widget.Spinner.DialogPopup: void show(int,int)>",0,"{
    if (mListAdapter == null) {
        return;
    }
    AlertDialog.Builder builder = new AlertDialog.Builder(getContext());
    if (mPrompt != null) {
        builder.setTitle(mPrompt);
    }
    mPopup = builder.setSingleChoiceItems(mListAdapter, getSelectedItemPosition(), this).create();
    final ListView listView = mPopup.getListView();
    listView.setTextDirection(textDirection);
    listView.setTextAlignment(textAlignment);
    mPopup.show();
}","{
    if (mListAdapter == null) {
        return;
    }
    AlertDialog.Builder builder = new AlertDialog.Builder(getPopupContext());
    if (mPrompt != null) {
        builder.setTitle(mPrompt);
    }
    mPopup = builder.setSingleChoiceItems(mListAdapter, getSelectedItemPosition(), this).create();
    final ListView listView = mPopup.getListView();
    listView.setTextDirection(textDirection);
    listView.setTextAlignment(textAlignment);
    mPopup.show();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method getContext() has changed to getPopupContext() in the AlertDialog.Builder instantiation, so the code change type is 5.","There are no Compatibility Issues detected here because the context change does not affect the behavior of how the popup is shown, nor does it introduce any changes to return values, exception handling, or control flow. Thus, the CI type is 0."
684,"<android.widget.GridLayout.Bounds: void include(GridLayout,View,Spec,Axis,int)>",22,23,"<android.widget.GridLayout.Bounds: void include(GridLayout,View,Spec,Axis,int)>","<android.widget.GridLayout.Bounds: void include(GridLayout,View,Spec,Axis,int)>",0,"{
    this.flexibility &= spec.getFlexibility();
    boolean horizontal = axis.horizontal;
    Alignment alignment = gl.getAlignment(spec.alignment, horizontal);
    // todo test this works correctly when the returned value is UNDEFINED
    int before = alignment.getAlignmentValue(c, size, gl.getLayoutMode());
    include(before, size - before);
}","{
    this.flexibility &= spec.getFlexibility();
    boolean horizontal = axis.horizontal;
    Alignment alignment = spec.getAbsoluteAlignment(axis.horizontal);
    // todo test this works correctly when the returned value is UNDEFINED
    int before = alignment.getAlignmentValue(c, size, gl.getLayoutMode());
    include(before, size - before);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent method getAlignment(spec.alignment, horizontal) has been changed to spec.getAbsoluteAlignment(axis.horizontal), so this is a change to a dependent API, which is of type 5.","Although there is a change to a dependent API, the method signature remains the same, and it's an internal change that does not affect the parameters, return type, or exception handling of the include method itself. Therefore, it does not introduce a compatibility issue, so the CI type is 0."
685,"<android.content.res.TypedArray: int getInteger(int,int)>",22,23,"<android.content.res.TypedArray: int getInteger(int,int)>","<android.content.res.TypedArray: int getInteger(int,int)>",0,"{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA];
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        throw new RuntimeException(""Failed to resolve attribute at index "" + index);
    }
    throw new UnsupportedOperationException(""Can't convert to integer: type=0x"" + Integer.toHexString(type));
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA];
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, value);
        throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + index + "": "" + value);
    }
    throw new UnsupportedOperationException(""Can't convert to integer: type=0x"" + Integer.toHexString(type));
}",1,"/**
 * Retrieve the integer value for the attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute integer value, or defValue if not defined.
 */
","/**
 * Retrieve the integer value for the attribute at <var>index</var>.
 * <p>
 * Unlike {@link #getInt(int, int)}, this method will throw an exception if
 * the attribute is defined but is not an integer.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute integer value, or defValue if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not an integer.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"Exception handling statement changed where a new piece of data (TypedValue value and the result of getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, value)) is now included in the message of the UnsupportedOperationException that is thrown for TYPE_ATTRIBUTE. Additionally, there's an Other statement changed as the creation of a TypedValue object and a call to getValueAt() are added. So the code change type is 2,4.","The change in the exception message and the addition of the call to getValueAt() in the exception handling for TYPE_ATTRIBUTE means that the API could throw a different exception (with added information), so the CI type is 2."
686,<android.text.Annotation: int getSpanTypeId()>,22,23,<android.text.Annotation: int getSpanTypeId()>,<android.text.Annotation: int getSpanTypeId()>,0,"{
    return TextUtils.ANNOTATION;
}","{
    return getSpanTypeIdInternal();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The method call within the return statement has changed from directly returning a constant to calling another method (getSpanTypeIdInternal()), so the code change type is 4,5.","The change from returning a constant to calling a different method could potentially lead to a different return value if the implementation of getSpanTypeIdInternal() differs from simply returning TextUtils.ANNOTATION. Therefore, the CI type is 1."
687,<android.transition.TransitionInflater: Transition inflateTransition(int)>,22,23,<android.transition.TransitionInflater: Transition inflateTransition(int)>,<android.transition.TransitionInflater: Transition inflateTransition(int)>,0,"{
    XmlResourceParser parser = mContext.getResources().getXml(resource);
    try {
        return createTransitionFromXml(parser, Xml.asAttributeSet(parser), null);
    } catch (XmlPullParserException e) {
        InflateException ex = new InflateException(e.getMessage());
        ex.initCause(e);
        throw ex;
    } catch (IOException e) {
        InflateException ex = new InflateException(parser.getPositionDescription() + "": "" + e.getMessage());
        ex.initCause(e);
        throw ex;
    } finally {
        parser.close();
    }
}","{
    // noinspection ResourceType
    XmlResourceParser parser = mContext.getResources().getXml(resource);
    try {
        return createTransitionFromXml(parser, Xml.asAttributeSet(parser), null);
    } catch (XmlPullParserException e) {
        InflateException ex = new InflateException(e.getMessage());
        ex.initCause(e);
        throw ex;
    } catch (IOException e) {
        InflateException ex = new InflateException(parser.getPositionDescription() + "": "" + e.getMessage());
        ex.initCause(e);
        throw ex;
    } finally {
        parser.close();
    }
}",1,"/**
 * Loads a {@link Transition} object from a resource
 *
 * @param resource The resource id of the transition to load
 * @return The loaded Transition object
 * @throws android.content.res.Resources.NotFoundException when the
 * transition cannot be loaded
 */
","/**
 * Loads a {@link Transition} object from a resource
 *
 * @param resource The resource id of the transition to load
 * @return The loaded Transition object
 * @throws android.content.res.Resources.NotFoundException when the
 * transition cannot be loaded
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"There are no changes in the logic of the code or in the control structures between the two versions, as the only observed difference is a comment that was added in the Late_Version.","Since there are no changes in the execution flow between the two versions, there is no possibility of a Compatibility Issue arising from this modification."
689,"<android.content.ContentResolver: AssetFileDescriptor openAssetFileDescriptor(Uri,String,CancellationSignal)>",22,23,"<android.content.ContentResolver: AssetFileDescriptor openAssetFileDescriptor(Uri,String,CancellationSignal)>","<android.content.ContentResolver: AssetFileDescriptor openAssetFileDescriptor(Uri,String,CancellationSignal)>",0,"{
    String scheme = uri.getScheme();
    if (SCHEME_ANDROID_RESOURCE.equals(scheme)) {
        if (!""r"".equals(mode)) {
            throw new FileNotFoundException(""Can't write resources: "" + uri);
        }
        OpenResourceIdResult r = getResourceId(uri);
        try {
            return r.r.openRawResourceFd(r.id);
        } catch (Resources.NotFoundException ex) {
            throw new FileNotFoundException(""Resource does not exist: "" + uri);
        }
    } else if (SCHEME_FILE.equals(scheme)) {
        ParcelFileDescriptor pfd = ParcelFileDescriptor.open(new File(uri.getPath()), ParcelFileDescriptor.parseMode(mode));
        return new AssetFileDescriptor(pfd, 0, -1);
    } else {
        if (""r"".equals(mode)) {
            return openTypedAssetFileDescriptor(uri, ""*/*"", null, cancellationSignal);
        } else {
            IContentProvider unstableProvider = acquireUnstableProvider(uri);
            if (unstableProvider == null) {
                throw new FileNotFoundException(""No content provider: "" + uri);
            }
            IContentProvider stableProvider = null;
            AssetFileDescriptor fd = null;
            try {
                ICancellationSignal remoteCancellationSignal = null;
                if (cancellationSignal != null) {
                    cancellationSignal.throwIfCanceled();
                    remoteCancellationSignal = unstableProvider.createCancellationSignal();
                    cancellationSignal.setRemote(remoteCancellationSignal);
                }
                try {
                    fd = unstableProvider.openAssetFile(mPackageName, uri, mode, remoteCancellationSignal);
                    if (fd == null) {
                        // The provider will be released by the finally{} clause
                        return null;
                    }
                } catch (DeadObjectException e) {
                    // The remote process has died...  but we only hold an unstable
                    // reference though, so we might recover!!!  Let's try!!!!
                    // This is exciting!!1!!1!!!!1
                    unstableProviderDied(unstableProvider);
                    stableProvider = acquireProvider(uri);
                    if (stableProvider == null) {
                        throw new FileNotFoundException(""No content provider: "" + uri);
                    }
                    fd = stableProvider.openAssetFile(mPackageName, uri, mode, remoteCancellationSignal);
                    if (fd == null) {
                        // The provider will be released by the finally{} clause
                        return null;
                    }
                }
                if (stableProvider == null) {
                    stableProvider = acquireProvider(uri);
                }
                releaseUnstableProvider(unstableProvider);
                ParcelFileDescriptor pfd = new ParcelFileDescriptorInner(fd.getParcelFileDescriptor(), stableProvider);
                // Success!  Don't release the provider when exiting, let
                // ParcelFileDescriptorInner do that when it is closed.
                stableProvider = null;
                return new AssetFileDescriptor(pfd, fd.getStartOffset(), fd.getDeclaredLength());
            } catch (RemoteException e) {
                // Whatever, whatever, we'll go away.
                throw new FileNotFoundException(""Failed opening content provider: "" + uri);
            } catch (FileNotFoundException e) {
                throw e;
            } finally {
                if (cancellationSignal != null) {
                    cancellationSignal.setRemote(null);
                }
                if (stableProvider != null) {
                    releaseProvider(stableProvider);
                }
                if (unstableProvider != null) {
                    releaseUnstableProvider(unstableProvider);
                }
            }
        }
    }
}","{
    Preconditions.checkNotNull(uri, ""uri"");
    Preconditions.checkNotNull(mode, ""mode"");
    String scheme = uri.getScheme();
    if (SCHEME_ANDROID_RESOURCE.equals(scheme)) {
        if (!""r"".equals(mode)) {
            throw new FileNotFoundException(""Can't write resources: "" + uri);
        }
        OpenResourceIdResult r = getResourceId(uri);
        try {
            return r.r.openRawResourceFd(r.id);
        } catch (Resources.NotFoundException ex) {
            throw new FileNotFoundException(""Resource does not exist: "" + uri);
        }
    } else if (SCHEME_FILE.equals(scheme)) {
        ParcelFileDescriptor pfd = ParcelFileDescriptor.open(new File(uri.getPath()), ParcelFileDescriptor.parseMode(mode));
        return new AssetFileDescriptor(pfd, 0, -1);
    } else {
        if (""r"".equals(mode)) {
            return openTypedAssetFileDescriptor(uri, ""*/*"", null, cancellationSignal);
        } else {
            IContentProvider unstableProvider = acquireUnstableProvider(uri);
            if (unstableProvider == null) {
                throw new FileNotFoundException(""No content provider: "" + uri);
            }
            IContentProvider stableProvider = null;
            AssetFileDescriptor fd = null;
            try {
                ICancellationSignal remoteCancellationSignal = null;
                if (cancellationSignal != null) {
                    cancellationSignal.throwIfCanceled();
                    remoteCancellationSignal = unstableProvider.createCancellationSignal();
                    cancellationSignal.setRemote(remoteCancellationSignal);
                }
                try {
                    fd = unstableProvider.openAssetFile(mPackageName, uri, mode, remoteCancellationSignal);
                    if (fd == null) {
                        // The provider will be released by the finally{} clause
                        return null;
                    }
                } catch (DeadObjectException e) {
                    // The remote process has died...  but we only hold an unstable
                    // reference though, so we might recover!!!  Let's try!!!!
                    // This is exciting!!1!!1!!!!1
                    unstableProviderDied(unstableProvider);
                    stableProvider = acquireProvider(uri);
                    if (stableProvider == null) {
                        throw new FileNotFoundException(""No content provider: "" + uri);
                    }
                    fd = stableProvider.openAssetFile(mPackageName, uri, mode, remoteCancellationSignal);
                    if (fd == null) {
                        // The provider will be released by the finally{} clause
                        return null;
                    }
                }
                if (stableProvider == null) {
                    stableProvider = acquireProvider(uri);
                }
                releaseUnstableProvider(unstableProvider);
                ParcelFileDescriptor pfd = new ParcelFileDescriptorInner(fd.getParcelFileDescriptor(), stableProvider);
                // Success!  Don't release the provider when exiting, let
                // ParcelFileDescriptorInner do that when it is closed.
                stableProvider = null;
                return new AssetFileDescriptor(pfd, fd.getStartOffset(), fd.getDeclaredLength());
            } catch (RemoteException e) {
                // Whatever, whatever, we'll go away.
                throw new FileNotFoundException(""Failed opening content provider: "" + uri);
            } catch (FileNotFoundException e) {
                throw e;
            } finally {
                if (cancellationSignal != null) {
                    cancellationSignal.setRemote(null);
                }
                if (stableProvider != null) {
                    releaseProvider(stableProvider);
                }
                if (unstableProvider != null) {
                    releaseUnstableProvider(unstableProvider);
                }
            }
        }
    }
}",1,"/**
 * Open a raw file descriptor to access data under a URI.  This
 * interacts with the underlying {@link ContentProvider#openAssetFile}
 * method of the provider associated with the given URI, to retrieve any file stored there.
 *
 * <h5>Accepts the following URI schemes:</h5>
 * <ul>
 * <li>content ({@link #SCHEME_CONTENT})</li>
 * <li>android.resource ({@link #SCHEME_ANDROID_RESOURCE})</li>
 * <li>file ({@link #SCHEME_FILE})</li>
 * </ul>
 * <h5>The android.resource ({@link #SCHEME_ANDROID_RESOURCE}) Scheme</h5>
 * <p>
 * A Uri object can be used to reference a resource in an APK file.  The
 * Uri should be one of the following formats:
 * <ul>
 * <li><code>android.resource://package_name/id_number</code><br/>
 * <code>package_name</code> is your package name as listed in your AndroidManifest.xml.
 * For example <code>com.example.myapp</code><br/>
 * <code>id_number</code> is the int form of the ID.<br/>
 * The easiest way to construct this form is
 * <pre>Uri uri = Uri.parse(""android.resource://com.example.myapp/"" + R.raw.my_resource"");</pre>
 * </li>
 * <li><code>android.resource://package_name/type/name</code><br/>
 * <code>package_name</code> is your package name as listed in your AndroidManifest.xml.
 * For example <code>com.example.myapp</code><br/>
 * <code>type</code> is the string form of the resource type.  For example, <code>raw</code>
 * or <code>drawable</code>.
 * <code>name</code> is the string form of the resource name.  That is, whatever the file
 * name was in your res directory, without the type extension.
 * The easiest way to construct this form is
 * <pre>Uri uri = Uri.parse(""android.resource://com.example.myapp/raw/my_resource"");</pre>
 * </li>
 * </ul>
 *
 * <p>Note that if this function is called for read-only input (mode is ""r"")
 * on a content: URI, it will instead call {@link #openTypedAssetFileDescriptor}
 * for you with a MIME type of ""*&#47;*"".  This allows such callers to benefit
 * from any built-in data conversion that a provider implements.
 *
 * @param uri The desired URI to open.
 * @param mode The file mode to use, as per {@link ContentProvider#openAssetFile
 * ContentProvider.openAssetFile}.
 * @param cancellationSignal A signal to cancel the operation in progress, or null if
 * none. If the operation is canceled, then
 * {@link OperationCanceledException} will be thrown.
 * @return Returns a new ParcelFileDescriptor pointing to the file.  You
 * own this descriptor and are responsible for closing it when done.
 * @throws FileNotFoundException Throws FileNotFoundException of no
 * file exists under the URI or the mode is invalid.
 */
","/**
 * Open a raw file descriptor to access data under a URI.  This
 * interacts with the underlying {@link ContentProvider#openAssetFile}
 * method of the provider associated with the given URI, to retrieve any file stored there.
 *
 * <h5>Accepts the following URI schemes:</h5>
 * <ul>
 * <li>content ({@link #SCHEME_CONTENT})</li>
 * <li>android.resource ({@link #SCHEME_ANDROID_RESOURCE})</li>
 * <li>file ({@link #SCHEME_FILE})</li>
 * </ul>
 * <h5>The android.resource ({@link #SCHEME_ANDROID_RESOURCE}) Scheme</h5>
 * <p>
 * A Uri object can be used to reference a resource in an APK file.  The
 * Uri should be one of the following formats:
 * <ul>
 * <li><code>android.resource://package_name/id_number</code><br/>
 * <code>package_name</code> is your package name as listed in your AndroidManifest.xml.
 * For example <code>com.example.myapp</code><br/>
 * <code>id_number</code> is the int form of the ID.<br/>
 * The easiest way to construct this form is
 * <pre>Uri uri = Uri.parse(""android.resource://com.example.myapp/"" + R.raw.my_resource"");</pre>
 * </li>
 * <li><code>android.resource://package_name/type/name</code><br/>
 * <code>package_name</code> is your package name as listed in your AndroidManifest.xml.
 * For example <code>com.example.myapp</code><br/>
 * <code>type</code> is the string form of the resource type.  For example, <code>raw</code>
 * or <code>drawable</code>.
 * <code>name</code> is the string form of the resource name.  That is, whatever the file
 * name was in your res directory, without the type extension.
 * The easiest way to construct this form is
 * <pre>Uri uri = Uri.parse(""android.resource://com.example.myapp/raw/my_resource"");</pre>
 * </li>
 * </ul>
 *
 * <p>Note that if this function is called for read-only input (mode is ""r"")
 * on a content: URI, it will instead call {@link #openTypedAssetFileDescriptor}
 * for you with a MIME type of ""*&#47;*"".  This allows such callers to benefit
 * from any built-in data conversion that a provider implements.
 *
 * @param uri The desired URI to open.
 * @param mode The file mode to use, as per {@link ContentProvider#openAssetFile
 * ContentProvider.openAssetFile}.
 * @param cancellationSignal A signal to cancel the operation in progress, or null if
 * none. If the operation is canceled, then
 * {@link OperationCanceledException} will be thrown.
 * @return Returns a new ParcelFileDescriptor pointing to the file.  You
 * own this descriptor and are responsible for closing it when done.
 * @throws FileNotFoundException Throws FileNotFoundException of no
 * file exists under the URI or the mode is invalid.
 */
",-1,,[@Nullable],-1,-1,-1,-1,-1,-1,,,,
691,<android.preference.Preference: boolean persistString(String)>,22,23,<android.preference.Preference: boolean persistString(String)>,<android.preference.Preference: boolean persistString(String)>,0,"{
    if (shouldPersist()) {
        // Shouldn't store null
        if (value == getPersistedString(null)) {
            // It's already there, so the same as persisting
            return true;
        }
        SharedPreferences.Editor editor = mPreferenceManager.getEditor();
        editor.putString(mKey, value);
        tryCommit(editor);
        return true;
    }
    return false;
}","{
    if (shouldPersist()) {
        // Shouldn't store null
        if (TextUtils.equals(value, getPersistedString(null))) {
            // It's already there, so the same as persisting
            return true;
        }
        SharedPreferences.Editor editor = mPreferenceManager.getEditor();
        editor.putString(mKey, value);
        tryCommit(editor);
        return true;
    }
    return false;
}",1,"/**
 * Attempts to persist a String to the {@link android.content.SharedPreferences}.
 * <p>
 * This will check if this Preference is persistent, get an editor from
 * the {@link PreferenceManager}, put in the string, and check if we should commit (and
 * commit if so).
 *
 * @param value The value to persist.
 * @return True if the Preference is persistent. (This is not whether the
 * value was persisted, since we may not necessarily commit if there
 * will be a batch commit later.)
 * @see #getPersistedString(String)
 */
","/**
 * Attempts to persist a String to the {@link android.content.SharedPreferences}.
 * <p>
 * This will check if this Preference is persistent, get an editor from
 * the {@link PreferenceManager}, put in the string, and check if we should commit (and
 * commit if so).
 *
 * @param value The value to persist.
 * @return True if the Preference is persistent. (This is not whether the
 * value was persisted, since we may not necessarily commit if there
 * will be a batch commit later.)
 * @see #getPersistedString(String)
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The comparison method changed from `value == getPersistedString(null)` to `TextUtils.equals(value, getPersistedString(null))`. This change doesn't introduce a new control flow or affect the overall logic but ensures proper string comparison, so the code change type is 4.","This change doesn't cause a Compatibility Issue because it improves the string comparison without altering the return value or the exception handling of the method. Both the new and old implementations will return the same values under the same conditions. The change from `==` to `TextUtils.equals` method still returns `true` when both strings are the same, so there is no CI, therefore, CI type is 0."
692,<android.net.http.HttpResponseCache: long maxSize()>,22,23,<android.net.http.HttpResponseCache: long maxSize()>,<android.net.http.HttpResponseCache: long maxSize()>,0,"{
    return delegate.getMaxSize();
}","{
    return delegate.maxSize();
}",1,"/**
 * Returns the maximum number of bytes that this cache should use to store
 * its data.
 */
","/**
 * Returns the maximum number of bytes that this cache should use to store
 * its data.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent API has changed from getMaxSize() to maxSize(), so the code change type is 5.","Despite the change in the method called on the 'delegate' object, there is no indication that the behavior or return type of the API has changed because both methods are likely to serve the same purpose of returning the maximum size of the cache. Without evidence of a change in semantics, we consider that there is no compatibility issue, hence the CI type is 0."
693,"<android.content.ContentProviderClient: Cursor query(Uri,String[],String,String[],String,CancellationSignal)>",22,23,"<android.content.ContentProviderClient: Cursor query(Uri,String[],String,String[],String,CancellationSignal)>","<android.content.ContentProviderClient: Cursor query(Uri,String[],String,String[],String,CancellationSignal)>",0,"{
    beforeRemote();
    try {
        ICancellationSignal remoteCancellationSignal = null;
        if (cancellationSignal != null) {
            cancellationSignal.throwIfCanceled();
            remoteCancellationSignal = mContentProvider.createCancellationSignal();
            cancellationSignal.setRemote(remoteCancellationSignal);
        }
        return mContentProvider.query(mPackageName, url, projection, selection, selectionArgs, sortOrder, remoteCancellationSignal);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}","{
    Preconditions.checkNotNull(url, ""url"");
    beforeRemote();
    try {
        ICancellationSignal remoteCancellationSignal = null;
        if (cancellationSignal != null) {
            cancellationSignal.throwIfCanceled();
            remoteCancellationSignal = mContentProvider.createCancellationSignal();
            cancellationSignal.setRemote(remoteCancellationSignal);
        }
        return mContentProvider.query(mPackageName, url, projection, selection, selectionArgs, sortOrder, remoteCancellationSignal);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}",1,"/**
 * See {@link ContentProvider#query ContentProvider.query}
 */
","/**
 * See {@link ContentProvider#query ContentProvider.query}
 */
",-1,,[@Nullable],-1,-1,-1,-1,-1,-1,4,0,"The code change is the addition of a precondition check (Preconditions.checkNotNull(url, ""url"")) to ensure that the 'url' parameter is not null. This change type is 4 because it is neither a changed return statement, exception handling statement, control dependency change, nor a dependent API change.","There is no Compatibility Issue caused by the code change because if the 'url' is null, both the early and late versions of the API will throw an exception. However, the nature of the exception might be different because in the early version, it would be a NullPointerException due to attempting to operate on a null object further down the call stack, while in the late version it will be a deliberate NullPointerException with a specific message from Preconditions.checkNotNull. This difference does not constitute a Compatibility Issue as per the given rules because it does not lead to different return values or changes in general exception handling flow of the API — it merely makes the error more explicit."
695,"<android.app.admin.DevicePolicyManager: void setScreenCaptureDisabled(ComponentName,boolean)>",22,23,"<android.app.admin.DevicePolicyManager: void setScreenCaptureDisabled(ComponentName,boolean)>","<android.app.admin.DevicePolicyManager: void setScreenCaptureDisabled(ComponentName,boolean)>",0,"{
    if (mService != null) {
        try {
            mService.setScreenCaptureDisabled(admin, UserHandle.myUserId(), disabled);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    if (mService != null) {
        try {
            mService.setScreenCaptureDisabled(admin, disabled);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}",1,"/**
 * Called by a device/profile owner to set whether the screen capture is disabled. Disabling
 * screen capture also prevents the content from being shown on display devices that do not have
 * a secure video output. See {@link android.view.Display#FLAG_SECURE} for more details about
 * secure surfaces and secure displays.
 *
 * <p>The calling device admin must be a device or profile owner. If it is not, a
 * security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param disabled Whether screen capture is disabled or not.
 */
","/**
 * Called by a device/profile owner to set whether the screen capture is disabled. Disabling
 * screen capture also prevents the content from being shown on display devices that do not have
 * a secure video output. See {@link android.view.Display#FLAG_SECURE} for more details about
 * secure surfaces and secure displays.
 *
 * <p>The calling device admin must be a device or profile owner. If it is not, a
 * security exception will be thrown.
 *
 * <p>From version {@link android.os.Build.VERSION_CODES#M} disabling screen capture also
 * blocks assist requests for all activities of the relevant user.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param disabled Whether screen capture is disabled or not.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent API, mService.setScreenCaptureDisabled, is called with different arguments: the UserHandle.myUserId() parameter has been removed in the late version. Therefore, there has been a change in how the dependent API is used, which is a type 5 change.","Despite the change in the dependent API usage, there is no Compatibility Issue caused by this change since the behavior of setScreenCaptureDisabled within the DevicePolicyManager does not directly rely on the user ID being passed in the method call. The user ID was previously taken from the current context of the application, and the updated method likely assumes the same user context implicitly without requiring it as a parameter. Therefore, there is no CI detected, which is type 0."
697,<android.app.ActivityOptions: Bundle toBundle()>,22,23,<android.app.ActivityOptions: Bundle toBundle()>,<android.app.ActivityOptions: Bundle toBundle()>,0,"{
    if (mAnimationType == ANIM_DEFAULT) {
        return null;
    }
    Bundle b = new Bundle();
    if (mPackageName != null) {
        b.putString(KEY_PACKAGE_NAME, mPackageName);
    }
    b.putInt(KEY_ANIM_TYPE, mAnimationType);
    switch(mAnimationType) {
        case ANIM_CUSTOM:
            b.putInt(KEY_ANIM_ENTER_RES_ID, mCustomEnterResId);
            b.putInt(KEY_ANIM_EXIT_RES_ID, mCustomExitResId);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_CUSTOM_IN_PLACE:
            b.putInt(KEY_ANIM_IN_PLACE_RES_ID, mCustomInPlaceResId);
            break;
        case ANIM_SCALE_UP:
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
        case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
        case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
            b.putParcelable(KEY_ANIM_THUMBNAIL, mThumbnail);
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_SCENE_TRANSITION:
            if (mTransitionReceiver != null) {
                b.putParcelable(KEY_TRANSITION_COMPLETE_LISTENER, mTransitionReceiver);
            }
            b.putBoolean(KEY_TRANSITION_IS_RETURNING, mIsReturning);
            b.putStringArrayList(KEY_TRANSITION_SHARED_ELEMENTS, mSharedElementNames);
            b.putParcelable(KEY_RESULT_DATA, mResultData);
            b.putInt(KEY_RESULT_CODE, mResultCode);
            b.putInt(KEY_EXIT_COORDINATOR_INDEX, mExitCoordinatorIndex);
            break;
    }
    return b;
}","{
    if (mAnimationType == ANIM_DEFAULT) {
        return null;
    }
    Bundle b = new Bundle();
    if (mPackageName != null) {
        b.putString(KEY_PACKAGE_NAME, mPackageName);
    }
    b.putInt(KEY_ANIM_TYPE, mAnimationType);
    if (mUsageTimeReport != null) {
        b.putParcelable(KEY_USAGE_TIME_REPORT, mUsageTimeReport);
    }
    switch(mAnimationType) {
        case ANIM_CUSTOM:
            b.putInt(KEY_ANIM_ENTER_RES_ID, mCustomEnterResId);
            b.putInt(KEY_ANIM_EXIT_RES_ID, mCustomExitResId);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_CUSTOM_IN_PLACE:
            b.putInt(KEY_ANIM_IN_PLACE_RES_ID, mCustomInPlaceResId);
            break;
        case ANIM_SCALE_UP:
        case ANIM_CLIP_REVEAL:
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
        case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
        case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
            b.putParcelable(KEY_ANIM_THUMBNAIL, mThumbnail);
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_SCENE_TRANSITION:
            if (mTransitionReceiver != null) {
                b.putParcelable(KEY_TRANSITION_COMPLETE_LISTENER, mTransitionReceiver);
            }
            b.putBoolean(KEY_TRANSITION_IS_RETURNING, mIsReturning);
            b.putStringArrayList(KEY_TRANSITION_SHARED_ELEMENTS, mSharedElementNames);
            b.putParcelable(KEY_RESULT_DATA, mResultData);
            b.putInt(KEY_RESULT_CODE, mResultCode);
            b.putInt(KEY_EXIT_COORDINATOR_INDEX, mExitCoordinatorIndex);
            break;
    }
    return b;
}",1,"/**
 * Returns the created options as a Bundle, which can be passed to
 * {@link android.content.Context#startActivity(android.content.Intent, android.os.Bundle)
 * Context.startActivity(Intent, Bundle)} and related methods.
 * Note that the returned Bundle is still owned by the ActivityOptions
 * object; you must not modify it, but can supply it to the startActivity
 * methods that take an options Bundle.
 */
","/**
 * Returns the created options as a Bundle, which can be passed to
 * {@link android.content.Context#startActivity(android.content.Intent, android.os.Bundle)
 * Context.startActivity(Intent, Bundle)} and related methods.
 * Note that the returned Bundle is still owned by the ActivityOptions
 * object; you must not modify it, but can supply it to the startActivity
 * methods that take an options Bundle.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The code change includes the addition of a new `if` block that adds a Parcelable to the Bundle (`b.putParcelable(KEY_USAGE_TIME_REPORT, mUsageTimeReport);`) and a new case `ANIM_CLIP_REVEAL` in the `switch` statement which results in the same operations as the `ANIM_SCALE_UP` case. This indicates there is a control dependency change (3) and other statement change (4).","There is no Compatibility Issue because the changes are additions that expand functionality. Existing code should not be affected by the addition since the new case falls through to existing code and the new `if` block is conditioned by whether `mUsageTimeReport` is non-null, so it shouldn't affect current behavior when `mUsageTimeReport` is null."
699,<android.app.Fragment: Resources getResources()>,22,23,<android.app.Fragment: Resources getResources()>,<android.app.Fragment: Resources getResources()>,0,"{
    if (mActivity == null) {
        throw new IllegalStateException(""Fragment "" + this + "" not attached to Activity"");
    }
    return mActivity.getResources();
}","{
    if (mHost == null) {
        throw new IllegalStateException(""Fragment "" + this + "" not attached to Activity"");
    }
    return mHost.getContext().getResources();
}",1,"/**
 * Return <code>getActivity().getResources()</code>.
 */
","/**
 * Return <code>getActivity().getResources()</code>.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,5",1,"The implementation has undergone two modifications. Firstly, the condition in the if statement has changed from checking mActivity to checking mHost. Secondly, the return statement now retrieves resources through mHost.getContext().getResources() rather than directly from mActivity.getResources(). These changes mean that the dependent API has also changed, as it now relies on a different object (mHost) to get the context, implying that the code change types are 3 and 5.","These changes can lead to potentially different return values. In the early version, getResources() was invoked directly on mActivity, while in the late version, it is invoked on the context returned by mHost. If mActivity and mHost.getContext() return different Resource instances, the returned value from getResources() would differ. Therefore, a CI is potentially present due to the possibility of returning a different value, and the CI type is 1."
700,"<android.text.SpannableStringBuilder: T[] getSpans(int,int,Class<T>)>",22,23,"<android.text.SpannableStringBuilder: T[] getSpans(int,int,Class<T>)>","<android.text.SpannableStringBuilder: T[] getSpans(int,int,Class<T>)>",0,"{
    if (kind == null)
        return ArrayUtils.emptyArray(kind);
    int spanCount = mSpanCount;
    Object[] spans = mSpans;
    int[] starts = mSpanStarts;
    int[] ends = mSpanEnds;
    int[] flags = mSpanFlags;
    int gapstart = mGapStart;
    int gaplen = mGapLength;
    int count = 0;
    T[] ret = null;
    T ret1 = null;
    for (int i = 0; i < spanCount; i++) {
        int spanStart = starts[i];
        if (spanStart > gapstart) {
            spanStart -= gaplen;
        }
        if (spanStart > queryEnd) {
            continue;
        }
        int spanEnd = ends[i];
        if (spanEnd > gapstart) {
            spanEnd -= gaplen;
        }
        if (spanEnd < queryStart) {
            continue;
        }
        if (spanStart != spanEnd && queryStart != queryEnd) {
            if (spanStart == queryEnd)
                continue;
            if (spanEnd == queryStart)
                continue;
        }
        // Expensive test, should be performed after the previous tests
        if (!kind.isInstance(spans[i]))
            continue;
        if (count == 0) {
            // Safe conversion thanks to the isInstance test above
            ret1 = (T) spans[i];
            count++;
        } else {
            if (count == 1) {
                // Safe conversion, but requires a suppressWarning
                ret = (T[]) Array.newInstance(kind, spanCount - i + 1);
                ret[0] = ret1;
            }
            int prio = flags[i] & SPAN_PRIORITY;
            if (prio != 0) {
                int j;
                for (j = 0; j < count; j++) {
                    int p = getSpanFlags(ret[j]) & SPAN_PRIORITY;
                    if (prio > p) {
                        break;
                    }
                }
                System.arraycopy(ret, j, ret, j + 1, count - j);
                // Safe conversion thanks to the isInstance test above
                ret[j] = (T) spans[i];
                count++;
            } else {
                // Safe conversion thanks to the isInstance test above
                ret[count++] = (T) spans[i];
            }
        }
    }
    if (count == 0) {
        return ArrayUtils.emptyArray(kind);
    }
    if (count == 1) {
        // Safe conversion, but requires a suppressWarning
        ret = (T[]) Array.newInstance(kind, 1);
        ret[0] = ret1;
        return ret;
    }
    if (count == ret.length) {
        return ret;
    }
    // Safe conversion, but requires a suppressWarning
    T[] nret = (T[]) Array.newInstance(kind, count);
    System.arraycopy(ret, 0, nret, 0, count);
    return nret;
}","{
    if (kind == null || mSpanCount == 0)
        return ArrayUtils.emptyArray(kind);
    int count = countSpans(queryStart, queryEnd, kind, treeRoot());
    if (count == 0) {
        return ArrayUtils.emptyArray(kind);
    }
    // Safe conversion, but requires a suppressWarning
    T[] ret = (T[]) Array.newInstance(kind, count);
    getSpansRec(queryStart, queryEnd, kind, treeRoot(), ret, 0);
    return ret;
}",1,"/**
 * Return an array of the spans of the specified type that overlap
 * the specified range of the buffer.  The kind may be Object.class to get
 * a list of all the spans regardless of type.
 */
","/**
 * Return an array of the spans of the specified type that overlap
 * the specified range of the buffer.  The kind may be Object.class to get
 * a list of all the spans regardless of type.
 */
",-1,"[@SuppressWarnings(""unchecked"")]","[@SuppressWarnings(""unchecked"")]",-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The return statements have changed due to the reimplementation of the logic for calculating spans, the introduction of new methods, `countSpans` and `getSpansRec`, and a new check for `mSpanCount == 0`. The control dependencies have changed via the introduction of the `countSpans` and `getSpansRec` methods rather than the explicit loop and if-conditions that existed previously. Dependent API changed since the implementation now relies on new methods, `countSpans` and `getSpansRec`, which weren't present in the early version. Hence, the code change types are 1,3,4,5.","Because the entire implementation of obtaining the spans has been altered and optimized, this can lead to a potentially different return variable in the form of the spans array. The changes in control structures and the restructuring of the code to use helper methods could lead to different results being returned. Despite the optimizations, as long as there’s a possibility of different outcomes due to the changes, we classify it as a CI type 1."
701,<android.text.style.RelativeSizeSpan: int getSpanTypeId()>,22,23,<android.text.style.RelativeSizeSpan: int getSpanTypeId()>,<android.text.style.RelativeSizeSpan: int getSpanTypeId()>,0,"{
    return TextUtils.RELATIVE_SIZE_SPAN;
}","{
    return getSpanTypeIdInternal();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method call inside the return statement has changed from returning a constant to calling getSpanTypeIdInternal(), implying that the dependent API has changed. This is a code change type 5.","Since the specific implementation details of getSpanTypeIdInternal() are not provided, we cannot definitively determine if the behavior will differ. Assuming the internal method correctly maps to the corresponding type ID, this change alone does not necessarily imply a different return value or exception throwing behavior. Therefore, without further evidence of a behavioral change, we classify it as no compatibility issue (0)."
702,"<com.android.server.backup.SystemBackupAgent: void onRestore(BackupDataInput,int,ParcelFileDescriptor)>",22,23,"<com.android.server.backup.SystemBackupAgent: void onRestore(BackupDataInput,int,ParcelFileDescriptor)>","<com.android.server.backup.SystemBackupAgent: void onRestore(BackupDataInput,int,ParcelFileDescriptor)>",0,"{
    // On restore, we also support a previous data schema ""system_files""
    addHelper(""wallpaper"", new WallpaperBackupHelper(SystemBackupAgent.this, new String[] { WALLPAPER_IMAGE, WALLPAPER_INFO }, new String[] { WALLPAPER_IMAGE_KEY, WALLPAPER_INFO_KEY }));
    addHelper(""system_files"", new WallpaperBackupHelper(SystemBackupAgent.this, new String[] { WALLPAPER_IMAGE }, new String[] { WALLPAPER_IMAGE_KEY }));
    addHelper(""recents"", new RecentsBackupHelper(SystemBackupAgent.this));
    try {
        super.onRestore(data, appVersionCode, newState);
        IWallpaperManager wallpaper = (IWallpaperManager) ServiceManager.getService(Context.WALLPAPER_SERVICE);
        if (wallpaper != null) {
            try {
                wallpaper.settingsRestored();
            } catch (RemoteException re) {
                Slog.e(TAG, ""Couldn't restore settings\n"" + re);
            }
        }
    } catch (IOException ex) {
        // If there was a failure, delete everything for the wallpaper, this is too aggressive,
        // but this is hopefully a rare failure.
        Slog.d(TAG, ""restore failed"", ex);
        (new File(WALLPAPER_IMAGE)).delete();
        (new File(WALLPAPER_INFO)).delete();
    }
}","{
    // On restore, we also support a previous data schema ""system_files""
    addHelper(WALLPAPER_HELPER, new WallpaperBackupHelper(this, new String[] { WALLPAPER_IMAGE, WALLPAPER_INFO }, new String[] { WALLPAPER_IMAGE_KEY, WALLPAPER_INFO_KEY }));
    addHelper(""system_files"", new WallpaperBackupHelper(this, new String[] { WALLPAPER_IMAGE }, new String[] { WALLPAPER_IMAGE_KEY }));
    addHelper(SYNC_SETTINGS_HELPER, new AccountSyncSettingsBackupHelper(this));
    addHelper(PREFERRED_HELPER, new PreferredActivityBackupHelper());
    addHelper(NOTIFICATION_HELPER, new NotificationBackupHelper(this));
    try {
        super.onRestore(data, appVersionCode, newState);
        IWallpaperManager wallpaper = (IWallpaperManager) ServiceManager.getService(Context.WALLPAPER_SERVICE);
        if (wallpaper != null) {
            try {
                wallpaper.settingsRestored();
            } catch (RemoteException re) {
                Slog.e(TAG, ""Couldn't restore settings\n"" + re);
            }
        }
    } catch (IOException ex) {
        // If there was a failure, delete everything for the wallpaper, this is too aggressive,
        // but this is hopefully a rare failure.
        Slog.d(TAG, ""restore failed"", ex);
        (new File(WALLPAPER_IMAGE)).delete();
        (new File(WALLPAPER_INFO)).delete();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The changes are in the arguments passed to `addHelper` method calls, where there are new helpers being added that change the behavior of what gets restored. The `SystemBackupAgent.this` reference has also been replaced with `this` in the invocation of `WallpaperBackupHelper`. Additionally, the constants `WALLPAPER_HELPER`, `SYNC_SETTINGS_HELPER`, `PREFERRED_HELPER`, and `NOTIFICATION_HELPER` have replaced string literals, which indicates that there has been a refactoring to use constant variables instead of inline string literals. For this reason, the type of changes is 4 and 5.","There's no change in the behavior of the `onRestore` method that would result in compatibility issues like causing different return values or throwing different exceptions. The try-catch blocks and other method logic remain identical, and the `addHelper` method is called more times with different parameters which doesn't affect the execution flow of `onRestore`. The refactoring and addition of helpers are internal implementation details and do not modify the signature or expected behavior of the `onRestore` method itself. Therefore, there is no compatibility issue, thus the type is 0."
704,<android.view.View: boolean onTouchEvent(MotionEvent)>,22,23,<android.view.View: boolean onTouchEvent(MotionEvent)>,<android.view.View: boolean onTouchEvent(MotionEvent)>,0,"{
    final float x = event.getX();
    final float y = event.getY();
    final int viewFlags = mViewFlags;
    if ((viewFlags & ENABLED_MASK) == DISABLED) {
        if (event.getAction() == MotionEvent.ACTION_UP && (mPrivateFlags & PFLAG_PRESSED) != 0) {
            setPressed(false);
        }
        // events, it just doesn't respond to them.
        return (((viewFlags & CLICKABLE) == CLICKABLE || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE));
    }
    if (mTouchDelegate != null) {
        if (mTouchDelegate.onTouchEvent(event)) {
            return true;
        }
    }
    if (((viewFlags & CLICKABLE) == CLICKABLE || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE)) {
        switch(event.getAction()) {
            case MotionEvent.ACTION_UP:
                boolean prepressed = (mPrivateFlags & PFLAG_PREPRESSED) != 0;
                if ((mPrivateFlags & PFLAG_PRESSED) != 0 || prepressed) {
                    // take focus if we don't have it already and we should in
                    // touch mode.
                    boolean focusTaken = false;
                    if (isFocusable() && isFocusableInTouchMode() && !isFocused()) {
                        focusTaken = requestFocus();
                    }
                    if (prepressed) {
                        // The button is being released before we actually
                        // showed it as pressed.  Make it show the pressed
                        // state now (before scheduling the click) to ensure
                        // the user sees it.
                        setPressed(true, x, y);
                    }
                    if (!mHasPerformedLongPress) {
                        // This is a tap, so remove the longpress check
                        removeLongPressCallback();
                        // Only perform take click actions if we were in the pressed state
                        if (!focusTaken) {
                            // of the view update before click actions start.
                            if (mPerformClick == null) {
                                mPerformClick = new PerformClick();
                            }
                            if (!post(mPerformClick)) {
                                performClick();
                            }
                        }
                    }
                    if (mUnsetPressedState == null) {
                        mUnsetPressedState = new UnsetPressedState();
                    }
                    if (prepressed) {
                        postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration());
                    } else if (!post(mUnsetPressedState)) {
                        // If the post failed, unpress right now
                        mUnsetPressedState.run();
                    }
                    removeTapCallback();
                }
                break;
            case MotionEvent.ACTION_DOWN:
                mHasPerformedLongPress = false;
                if (performButtonActionOnTouchDown(event)) {
                    break;
                }
                // Walk up the hierarchy to determine if we're inside a scrolling container.
                boolean isInScrollingContainer = isInScrollingContainer();
                // a short period in case this is a scroll.
                if (isInScrollingContainer) {
                    mPrivateFlags |= PFLAG_PREPRESSED;
                    if (mPendingCheckForTap == null) {
                        mPendingCheckForTap = new CheckForTap();
                    }
                    mPendingCheckForTap.x = event.getX();
                    mPendingCheckForTap.y = event.getY();
                    postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
                } else {
                    // Not inside a scrolling container, so show the feedback right away
                    setPressed(true, x, y);
                    checkForLongClick(0);
                }
                break;
            case MotionEvent.ACTION_CANCEL:
                setPressed(false);
                removeTapCallback();
                removeLongPressCallback();
                break;
            case MotionEvent.ACTION_MOVE:
                drawableHotspotChanged(x, y);
                // Be lenient about moving outside of buttons
                if (!pointInView(x, y, mTouchSlop)) {
                    // Outside button
                    removeTapCallback();
                    if ((mPrivateFlags & PFLAG_PRESSED) != 0) {
                        // Remove any future long press/tap checks
                        removeLongPressCallback();
                        setPressed(false);
                    }
                }
                break;
        }
        return true;
    }
    return false;
}","{
    final float x = event.getX();
    final float y = event.getY();
    final int viewFlags = mViewFlags;
    final int action = event.getAction();
    if ((viewFlags & ENABLED_MASK) == DISABLED) {
        if (action == MotionEvent.ACTION_UP && (mPrivateFlags & PFLAG_PRESSED) != 0) {
            setPressed(false);
        }
        // events, it just doesn't respond to them.
        return (((viewFlags & CLICKABLE) == CLICKABLE || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags & CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE);
    }
    if (mTouchDelegate != null) {
        if (mTouchDelegate.onTouchEvent(event)) {
            return true;
        }
    }
    if (((viewFlags & CLICKABLE) == CLICKABLE || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags & CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) {
        switch(action) {
            case MotionEvent.ACTION_UP:
                boolean prepressed = (mPrivateFlags & PFLAG_PREPRESSED) != 0;
                if ((mPrivateFlags & PFLAG_PRESSED) != 0 || prepressed) {
                    // take focus if we don't have it already and we should in
                    // touch mode.
                    boolean focusTaken = false;
                    if (isFocusable() && isFocusableInTouchMode() && !isFocused()) {
                        focusTaken = requestFocus();
                    }
                    if (prepressed) {
                        // The button is being released before we actually
                        // showed it as pressed.  Make it show the pressed
                        // state now (before scheduling the click) to ensure
                        // the user sees it.
                        setPressed(true, x, y);
                    }
                    if (!mHasPerformedLongPress && !mIgnoreNextUpEvent) {
                        // This is a tap, so remove the longpress check
                        removeLongPressCallback();
                        // Only perform take click actions if we were in the pressed state
                        if (!focusTaken) {
                            // of the view update before click actions start.
                            if (mPerformClick == null) {
                                mPerformClick = new PerformClick();
                            }
                            if (!post(mPerformClick)) {
                                performClick();
                            }
                        }
                    }
                    if (mUnsetPressedState == null) {
                        mUnsetPressedState = new UnsetPressedState();
                    }
                    if (prepressed) {
                        postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration());
                    } else if (!post(mUnsetPressedState)) {
                        // If the post failed, unpress right now
                        mUnsetPressedState.run();
                    }
                    removeTapCallback();
                }
                mIgnoreNextUpEvent = false;
                break;
            case MotionEvent.ACTION_DOWN:
                mHasPerformedLongPress = false;
                if (performButtonActionOnTouchDown(event)) {
                    break;
                }
                // Walk up the hierarchy to determine if we're inside a scrolling container.
                boolean isInScrollingContainer = isInScrollingContainer();
                // a short period in case this is a scroll.
                if (isInScrollingContainer) {
                    mPrivateFlags |= PFLAG_PREPRESSED;
                    if (mPendingCheckForTap == null) {
                        mPendingCheckForTap = new CheckForTap();
                    }
                    mPendingCheckForTap.x = event.getX();
                    mPendingCheckForTap.y = event.getY();
                    postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
                } else {
                    // Not inside a scrolling container, so show the feedback right away
                    setPressed(true, x, y);
                    checkForLongClick(0);
                }
                break;
            case MotionEvent.ACTION_CANCEL:
                setPressed(false);
                removeTapCallback();
                removeLongPressCallback();
                mInContextButtonPress = false;
                mHasPerformedLongPress = false;
                mIgnoreNextUpEvent = false;
                break;
            case MotionEvent.ACTION_MOVE:
                drawableHotspotChanged(x, y);
                // Be lenient about moving outside of buttons
                if (!pointInView(x, y, mTouchSlop)) {
                    // Outside button
                    removeTapCallback();
                    if ((mPrivateFlags & PFLAG_PRESSED) != 0) {
                        // Remove any future long press/tap checks
                        removeLongPressCallback();
                        setPressed(false);
                    }
                }
                break;
        }
        return true;
    }
    return false;
}",1,"/**
 * Implement this method to handle touch screen motion events.
 * <p>
 * If this method is used to detect click actions, it is recommended that
 * the actions be performed by implementing and calling
 * {@link #performClick()}. This will ensure consistent system behavior,
 * including:
 * <ul>
 * <li>obeying click sound preferences
 * <li>dispatching OnClickListener calls
 * <li>handling {@link AccessibilityNodeInfo#ACTION_CLICK ACTION_CLICK} when
 * accessibility features are enabled
 * </ul>
 *
 * @param event The motion event.
 * @return True if the event was handled, false otherwise.
 */
","/**
 * Implement this method to handle touch screen motion events.
 * <p>
 * If this method is used to detect click actions, it is recommended that
 * the actions be performed by implementing and calling
 * {@link #performClick()}. This will ensure consistent system behavior,
 * including:
 * <ul>
 * <li>obeying click sound preferences
 * <li>dispatching OnClickListener calls
 * <li>handling {@link AccessibilityNodeInfo#ACTION_CLICK ACTION_CLICK} when
 * accessibility features are enabled
 * </ul>
 *
 * @param event The motion event.
 * @return True if the event was handled, false otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
705,"<android.content.res.TypedArray: int getColor(int,int)>",22,23,"<android.content.res.TypedArray: int getColor(int,int)>","<android.content.res.TypedArray: int getColor(int,int)>",0,"{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA];
    } else if (type == TypedValue.TYPE_STRING) {
        final TypedValue value = mValue;
        if (getValueAt(index, value)) {
            ColorStateList csl = mResources.loadColorStateList(value, value.resourceId);
            return csl.getDefaultColor();
        }
        return defValue;
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        throw new RuntimeException(""Failed to resolve attribute at index "" + index);
    }
    throw new UnsupportedOperationException(""Can't convert to color: type=0x"" + Integer.toHexString(type));
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA];
    } else if (type == TypedValue.TYPE_STRING) {
        final TypedValue value = mValue;
        if (getValueAt(index, value)) {
            final ColorStateList csl = mResources.loadColorStateList(value, value.resourceId, mTheme);
            return csl.getDefaultColor();
        }
        return defValue;
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, value);
        throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + index + "": "" + value);
    }
    throw new UnsupportedOperationException(""Can't convert to color: type=0x"" + Integer.toHexString(type));
}",1,"/**
 * Retrieve the color value for the attribute at <var>index</var>.  If
 * the attribute references a color resource holding a complex
 * {@link android.content.res.ColorStateList}, then the default color from
 * the set is returned.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute color value, or defValue if not defined.
 */
","/**
 * Retrieve the color value for the attribute at <var>index</var>.  If
 * the attribute references a color resource holding a complex
 * {@link android.content.res.ColorStateList}, then the default color from
 * the set is returned.
 * <p>
 * This method will throw an exception if the attribute is defined but is
 * not an integer color or color state list.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute color value, or defValue if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not an integer color or color state list.
 */
",-1,,[@ColorInt],-1,-1,-1,-1,-1,-1,"4,5",1,"The late version introduces a new `mTheme` parameter to the `mResources.loadColorStateList` call and changes the exception message of the `TYPE_ATTRIBUTE` block. There are no changes in control flow or the return statements outside exception handling, so the change type is 4,5.","The introduction of the `mTheme` parameter in the `loadColorStateList` call indicates a change in a dependent API call, which can potentially result in different return values (colors) due to theme-based color resolution. Since the dependent API has changed, if the theme changes the color resolution, it might result in a different color being returned for the same method call. Thus, the CI type is 1."
706,<android.app.Notification: String toString()>,22,23,<android.app.Notification: String toString()>,<android.app.Notification: String toString()>,0,"{
    StringBuilder sb = new StringBuilder();
    sb.append(""Notification(pri="");
    sb.append(priority);
    sb.append("" contentView="");
    if (contentView != null) {
        sb.append(contentView.getPackage());
        sb.append(""/0x"");
        sb.append(Integer.toHexString(contentView.getLayoutId()));
    } else {
        sb.append(""null"");
    }
    sb.append("" vibrate="");
    if ((this.defaults & DEFAULT_VIBRATE) != 0) {
        sb.append(""default"");
    } else if (this.vibrate != null) {
        int N = this.vibrate.length - 1;
        sb.append(""["");
        for (int i = 0; i < N; i++) {
            sb.append(this.vibrate[i]);
            sb.append(',');
        }
        if (N != -1) {
            sb.append(this.vibrate[N]);
        }
        sb.append(""]"");
    } else {
        sb.append(""null"");
    }
    sb.append("" sound="");
    if ((this.defaults & DEFAULT_SOUND) != 0) {
        sb.append(""default"");
    } else if (this.sound != null) {
        sb.append(this.sound.toString());
    } else {
        sb.append(""null"");
    }
    sb.append("" defaults=0x"");
    sb.append(Integer.toHexString(this.defaults));
    sb.append("" flags=0x"");
    sb.append(Integer.toHexString(this.flags));
    sb.append(String.format("" color=0x%08x"", this.color));
    if (this.category != null) {
        sb.append("" category="");
        sb.append(this.category);
    }
    if (this.mGroupKey != null) {
        sb.append("" groupKey="");
        sb.append(this.mGroupKey);
    }
    if (this.mSortKey != null) {
        sb.append("" sortKey="");
        sb.append(this.mSortKey);
    }
    if (actions != null) {
        sb.append("" actions="");
        sb.append(actions.length);
    }
    sb.append("" vis="");
    sb.append(visibilityToString(this.visibility));
    if (this.publicVersion != null) {
        sb.append("" publicVersion="");
        sb.append(publicVersion.toString());
    }
    sb.append("")"");
    return sb.toString();
}","{
    StringBuilder sb = new StringBuilder();
    sb.append(""Notification(pri="");
    sb.append(priority);
    sb.append("" contentView="");
    if (contentView != null) {
        sb.append(contentView.getPackage());
        sb.append(""/0x"");
        sb.append(Integer.toHexString(contentView.getLayoutId()));
    } else {
        sb.append(""null"");
    }
    sb.append("" vibrate="");
    if ((this.defaults & DEFAULT_VIBRATE) != 0) {
        sb.append(""default"");
    } else if (this.vibrate != null) {
        int N = this.vibrate.length - 1;
        sb.append(""["");
        for (int i = 0; i < N; i++) {
            sb.append(this.vibrate[i]);
            sb.append(',');
        }
        if (N != -1) {
            sb.append(this.vibrate[N]);
        }
        sb.append(""]"");
    } else {
        sb.append(""null"");
    }
    sb.append("" sound="");
    if ((this.defaults & DEFAULT_SOUND) != 0) {
        sb.append(""default"");
    } else if (this.sound != null) {
        sb.append(this.sound.toString());
    } else {
        sb.append(""null"");
    }
    if (this.tickerText != null) {
        sb.append("" tick"");
    }
    sb.append("" defaults=0x"");
    sb.append(Integer.toHexString(this.defaults));
    sb.append("" flags=0x"");
    sb.append(Integer.toHexString(this.flags));
    sb.append(String.format("" color=0x%08x"", this.color));
    if (this.category != null) {
        sb.append("" category="");
        sb.append(this.category);
    }
    if (this.mGroupKey != null) {
        sb.append("" groupKey="");
        sb.append(this.mGroupKey);
    }
    if (this.mSortKey != null) {
        sb.append("" sortKey="");
        sb.append(this.mSortKey);
    }
    if (actions != null) {
        sb.append("" actions="");
        sb.append(actions.length);
    }
    sb.append("" vis="");
    sb.append(visibilityToString(this.visibility));
    if (this.publicVersion != null) {
        sb.append("" publicVersion="");
        sb.append(publicVersion.toString());
    }
    sb.append("")"");
    return sb.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The method's body now includes code to append "" tick"" to the StringBuilder when this.tickerText is not null. This is the only addition to the code, so the code change type is 4.","Since the method's intent is to return a string representation of the object and the overall structure and behavior of the method have not changed, but only new informational content has been added, there is no Compatibility Issue; the return type is still a String, and the method's contract is adhered to."
707,<android.content.res.ColorStateList: boolean isOpaque()>,22,23,<android.content.res.ColorStateList: boolean isOpaque()>,<android.content.res.ColorStateList: boolean isOpaque()>,0,"{
    final int n = mColors.length;
    for (int i = 0; i < n; i++) {
        if (Color.alpha(mColors[i]) != 0xFF) {
            return false;
        }
    }
    return true;
}","{
    return mIsOpaque;
}",1,"/**
 * Indicates whether this color state list is opaque, which means that every
 * color returned from {@link #getColorForState(int[], int)} has an alpha
 * value of 255.
 *
 * @return True if this color state list is opaque.
 */
","/**
 * Indicates whether this color state list is opaque, which means that every
 * color returned from {@link #getColorForState(int[], int)} has an alpha
 * value of 255.
 *
 * @return True if this color state list is opaque.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The implementation shifted from an explicit calculation using a loop in the early version to a direct return of a precalculated value in the late version (return mIsOpaque;). This involves a change in the method logic (return statement) and the removal of the loop that was previously controlling the flow, which qualifies as 'Other statement changed', so the code change type is 1,4.","The change in the return statement could lead to different behaviors of the API, potentially returning different values when the internal state of 'mIsOpaque' differs from what the calculation in the loop would produce. Hence, the CI type is 1."
708,<android.text.style.EasyEditSpan: int getSpanTypeId()>,22,23,<android.text.style.EasyEditSpan: int getSpanTypeId()>,<android.text.style.EasyEditSpan: int getSpanTypeId()>,0,"{
    return TextUtils.EASY_EDIT_SPAN;
}","{
    return getSpanTypeIdInternal();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The method getSpanTypeId() in the late version calls another method getSpanTypeIdInternal() instead of directly returning a constant. This indicates that the implementation is relying on a different or new internal method, so the change type is 5.","Even though there’s a change in the dependent method, it assumes that getSpanTypeIdInternal() returns the same value as TextUtils.EASY_EDIT_SPAN. Without evidence that the value returned by getSpanTypeIdInternal() is different, we can't confirm that this change leads to a Compatibility Issue. Hence, the CI type is 0."
709,"<android.accounts.AccountManager: Intent newChooseAccountIntent(Account,ArrayList<Account>,String[],boolean,String,String,String[],Bundle)>",22,23,"<android.accounts.AccountManager: Intent newChooseAccountIntent(Account,ArrayList<Account>,String[],boolean,String,String,String[],Bundle)>","<android.accounts.AccountManager: Intent newChooseAccountIntent(Account,ArrayList<Account>,String[],boolean,String,String,String[],Bundle)>",0,"{
    Intent intent = new Intent();
    ComponentName componentName = ComponentName.unflattenFromString(Resources.getSystem().getString(R.string.config_chooseTypeAndAccountActivity));
    intent.setClassName(componentName.getPackageName(), componentName.getClassName());
    intent.putExtra(ChooseTypeAndAccountActivity.EXTRA_ALLOWABLE_ACCOUNTS_ARRAYLIST, allowableAccounts);
    intent.putExtra(ChooseTypeAndAccountActivity.EXTRA_ALLOWABLE_ACCOUNT_TYPES_STRING_ARRAY, allowableAccountTypes);
    intent.putExtra(ChooseTypeAndAccountActivity.EXTRA_ADD_ACCOUNT_OPTIONS_BUNDLE, addAccountOptions);
    intent.putExtra(ChooseTypeAndAccountActivity.EXTRA_SELECTED_ACCOUNT, selectedAccount);
    intent.putExtra(ChooseTypeAndAccountActivity.EXTRA_ALWAYS_PROMPT_FOR_ACCOUNT, alwaysPromptForAccount);
    intent.putExtra(ChooseTypeAndAccountActivity.EXTRA_DESCRIPTION_TEXT_OVERRIDE, descriptionOverrideText);
    intent.putExtra(ChooseTypeAndAccountActivity.EXTRA_ADD_ACCOUNT_AUTH_TOKEN_TYPE_STRING, addAccountAuthTokenType);
    intent.putExtra(ChooseTypeAndAccountActivity.EXTRA_ADD_ACCOUNT_REQUIRED_FEATURES_STRING_ARRAY, addAccountRequiredFeatures);
    return intent;
}","{
    return newChooseAccountIntent(selectedAccount, allowableAccounts, allowableAccountTypes, descriptionOverrideText, addAccountAuthTokenType, addAccountRequiredFeatures, addAccountOptions);
}",1,"/**
 * Returns an intent to an {@link Activity} that prompts the user to choose from a list of
 * accounts.
 * The caller will then typically start the activity by calling
 * <code>startActivityForResult(intent, ...);</code>.
 * <p>
 * On success the activity returns a Bundle with the account name and type specified using
 * keys {@link #KEY_ACCOUNT_NAME} and {@link #KEY_ACCOUNT_TYPE}.
 * <p>
 * The most common case is to call this with one account type, e.g.:
 * <p>
 * <pre>  newChooseAccountIntent(null, null, new String[]{""com.google""}, false, null,
 * null, null, null);</pre>
 * @param selectedAccount if specified, indicates that the {@link Account} is the currently
 * selected one, according to the caller's definition of selected.
 * @param allowableAccounts an optional {@link ArrayList} of accounts that are allowed to be
 * shown. If not specified then this field will not limit the displayed accounts.
 * @param allowableAccountTypes an optional string array of account types. These are used
 * both to filter the shown accounts and to filter the list of account types that are shown
 * when adding an account.
 * @param alwaysPromptForAccount if set the account chooser screen is always shown, otherwise
 * it is only shown when there is more than one account from which to choose
 * @param descriptionOverrideText if non-null this string is used as the description in the
 * accounts chooser screen rather than the default
 * @param addAccountAuthTokenType this string is passed as the {@link #addAccount}
 * authTokenType parameter
 * @param addAccountRequiredFeatures this string array is passed as the {@link #addAccount}
 * requiredFeatures parameter
 * @param addAccountOptions This {@link Bundle} is passed as the {@link #addAccount} options
 * parameter
 * @return an {@link Intent} that can be used to launch the ChooseAccount activity flow.
 */
","/**
 * Deprecated in favor of {@link #newChooseAccountIntent(Account, List, String[], String,
 * String, String[], Bundle)}.
 *
 * Returns an intent to an {@link Activity} that prompts the user to choose from a list of
 * accounts.
 * The caller will then typically start the activity by calling
 * <code>startActivityForResult(intent, ...);</code>.
 * <p>
 * On success the activity returns a Bundle with the account name and type specified using
 * keys {@link #KEY_ACCOUNT_NAME} and {@link #KEY_ACCOUNT_TYPE}.
 * <p>
 * The most common case is to call this with one account type, e.g.:
 * <p>
 * <pre>  newChooseAccountIntent(null, null, new String[]{""com.google""}, false, null,
 * null, null, null);</pre>
 * @param selectedAccount if specified, indicates that the {@link Account} is the currently
 * selected one, according to the caller's definition of selected.
 * @param allowableAccounts an optional {@link List} of accounts that are allowed to be
 * shown. If not specified then this field will not limit the displayed accounts.
 * @param allowableAccountTypes an optional string array of account types. These are used
 * both to filter the shown accounts and to filter the list of account types that are shown
 * when adding an account. If not specified then this field will not limit the displayed
 * account types when adding an account.
 * @param alwaysPromptForAccount boolean that is ignored.
 * @param descriptionOverrideText if non-null this string is used as the description in the
 * accounts chooser screen rather than the default
 * @param addAccountAuthTokenType this string is passed as the {@link #addAccount}
 * authTokenType parameter
 * @param addAccountRequiredFeatures this string array is passed as the {@link #addAccount}
 * requiredFeatures parameter
 * @param addAccountOptions This {@link Bundle} is passed as the {@link #addAccount} options
 * parameter
 * @return an {@link Intent} that can be used to launch the ChooseAccount activity flow.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"1,5",1,"There is a change in the return statement where instead of creating and configuring the Intent instance directly within the method, the newer version delegates this responsibility to another method by calling it and passing the necessary parameters. Therefore, the change involves a different code pattern in the return statement (code change type 1) and also indicates a potential use of a new or modified dependent API (code change type 5).","Delegating to a new or modified method for setting up and returning the Intent can lead to a possibly different return value if the implementation of `newChooseAccountIntent` in the later version behaves differently than the inline code in the earlier version. This constitutes a potential Compatibility Issue caused by different return values (CI type 1). The deprecation annotation does not directly influence the behavior of the method's execution, so it does not contribute to a compatibility issue on its own."
710,<android.view.View: String toString()>,22,23,<android.view.View: String toString()>,<android.view.View: String toString()>,0,"{
    StringBuilder out = new StringBuilder(128);
    out.append(getClass().getName());
    out.append('{');
    out.append(Integer.toHexString(System.identityHashCode(this)));
    out.append(' ');
    switch(mViewFlags & VISIBILITY_MASK) {
        case VISIBLE:
            out.append('V');
            break;
        case INVISIBLE:
            out.append('I');
            break;
        case GONE:
            out.append('G');
            break;
        default:
            out.append('.');
            break;
    }
    out.append((mViewFlags & FOCUSABLE_MASK) == FOCUSABLE ? 'F' : '.');
    out.append((mViewFlags & ENABLED_MASK) == ENABLED ? 'E' : '.');
    out.append((mViewFlags & DRAW_MASK) == WILL_NOT_DRAW ? '.' : 'D');
    out.append((mViewFlags & SCROLLBARS_HORIZONTAL) != 0 ? 'H' : '.');
    out.append((mViewFlags & SCROLLBARS_VERTICAL) != 0 ? 'V' : '.');
    out.append((mViewFlags & CLICKABLE) != 0 ? 'C' : '.');
    out.append((mViewFlags & LONG_CLICKABLE) != 0 ? 'L' : '.');
    out.append(' ');
    out.append((mPrivateFlags & PFLAG_IS_ROOT_NAMESPACE) != 0 ? 'R' : '.');
    out.append((mPrivateFlags & PFLAG_FOCUSED) != 0 ? 'F' : '.');
    out.append((mPrivateFlags & PFLAG_SELECTED) != 0 ? 'S' : '.');
    if ((mPrivateFlags & PFLAG_PREPRESSED) != 0) {
        out.append('p');
    } else {
        out.append((mPrivateFlags & PFLAG_PRESSED) != 0 ? 'P' : '.');
    }
    out.append((mPrivateFlags & PFLAG_HOVERED) != 0 ? 'H' : '.');
    out.append((mPrivateFlags & PFLAG_ACTIVATED) != 0 ? 'A' : '.');
    out.append((mPrivateFlags & PFLAG_INVALIDATED) != 0 ? 'I' : '.');
    out.append((mPrivateFlags & PFLAG_DIRTY_MASK) != 0 ? 'D' : '.');
    out.append(' ');
    out.append(mLeft);
    out.append(',');
    out.append(mTop);
    out.append('-');
    out.append(mRight);
    out.append(',');
    out.append(mBottom);
    final int id = getId();
    if (id != NO_ID) {
        out.append("" #"");
        out.append(Integer.toHexString(id));
        final Resources r = mResources;
        if (Resources.resourceHasPackage(id) && r != null) {
            try {
                String pkgname;
                switch(id & 0xff000000) {
                    case 0x7f000000:
                        pkgname = ""app"";
                        break;
                    case 0x01000000:
                        pkgname = ""android"";
                        break;
                    default:
                        pkgname = r.getResourcePackageName(id);
                        break;
                }
                String typename = r.getResourceTypeName(id);
                String entryname = r.getResourceEntryName(id);
                out.append("" "");
                out.append(pkgname);
                out.append("":"");
                out.append(typename);
                out.append(""/"");
                out.append(entryname);
            } catch (Resources.NotFoundException e) {
            }
        }
    }
    out.append(""}"");
    return out.toString();
}","{
    StringBuilder out = new StringBuilder(128);
    out.append(getClass().getName());
    out.append('{');
    out.append(Integer.toHexString(System.identityHashCode(this)));
    out.append(' ');
    switch(mViewFlags & VISIBILITY_MASK) {
        case VISIBLE:
            out.append('V');
            break;
        case INVISIBLE:
            out.append('I');
            break;
        case GONE:
            out.append('G');
            break;
        default:
            out.append('.');
            break;
    }
    out.append((mViewFlags & FOCUSABLE_MASK) == FOCUSABLE ? 'F' : '.');
    out.append((mViewFlags & ENABLED_MASK) == ENABLED ? 'E' : '.');
    out.append((mViewFlags & DRAW_MASK) == WILL_NOT_DRAW ? '.' : 'D');
    out.append((mViewFlags & SCROLLBARS_HORIZONTAL) != 0 ? 'H' : '.');
    out.append((mViewFlags & SCROLLBARS_VERTICAL) != 0 ? 'V' : '.');
    out.append((mViewFlags & CLICKABLE) != 0 ? 'C' : '.');
    out.append((mViewFlags & LONG_CLICKABLE) != 0 ? 'L' : '.');
    out.append((mViewFlags & CONTEXT_CLICKABLE) != 0 ? 'X' : '.');
    out.append(' ');
    out.append((mPrivateFlags & PFLAG_IS_ROOT_NAMESPACE) != 0 ? 'R' : '.');
    out.append((mPrivateFlags & PFLAG_FOCUSED) != 0 ? 'F' : '.');
    out.append((mPrivateFlags & PFLAG_SELECTED) != 0 ? 'S' : '.');
    if ((mPrivateFlags & PFLAG_PREPRESSED) != 0) {
        out.append('p');
    } else {
        out.append((mPrivateFlags & PFLAG_PRESSED) != 0 ? 'P' : '.');
    }
    out.append((mPrivateFlags & PFLAG_HOVERED) != 0 ? 'H' : '.');
    out.append((mPrivateFlags & PFLAG_ACTIVATED) != 0 ? 'A' : '.');
    out.append((mPrivateFlags & PFLAG_INVALIDATED) != 0 ? 'I' : '.');
    out.append((mPrivateFlags & PFLAG_DIRTY_MASK) != 0 ? 'D' : '.');
    out.append(' ');
    out.append(mLeft);
    out.append(',');
    out.append(mTop);
    out.append('-');
    out.append(mRight);
    out.append(',');
    out.append(mBottom);
    final int id = getId();
    if (id != NO_ID) {
        out.append("" #"");
        out.append(Integer.toHexString(id));
        final Resources r = mResources;
        if (Resources.resourceHasPackage(id) && r != null) {
            try {
                String pkgname;
                switch(id & 0xff000000) {
                    case 0x7f000000:
                        pkgname = ""app"";
                        break;
                    case 0x01000000:
                        pkgname = ""android"";
                        break;
                    default:
                        pkgname = r.getResourcePackageName(id);
                        break;
                }
                String typename = r.getResourceTypeName(id);
                String entryname = r.getResourceEntryName(id);
                out.append("" "");
                out.append(pkgname);
                out.append("":"");
                out.append(typename);
                out.append(""/"");
                out.append(entryname);
            } catch (Resources.NotFoundException e) {
            }
        }
    }
    out.append(""}"");
    return out.toString();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
712,"<android.hardware.camera2.impl.CameraCaptureSessionImpl: int captureBurst(List<CaptureRequest>,CaptureCallback,Handler)>",22,23,"<android.hardware.camera2.impl.CameraCaptureSessionImpl: int captureBurst(List<CaptureRequest>,CaptureCallback,Handler)>","<android.hardware.camera2.impl.CameraCaptureSessionImpl: int captureBurst(List<CaptureRequest>,CaptureCallback,Handler)>",0,"{
    if (requests == null) {
        throw new IllegalArgumentException(""requests must not be null"");
    } else if (requests.isEmpty()) {
        throw new IllegalArgumentException(""requests must have at least one element"");
    }
    checkNotClosed();
    handler = checkHandler(handler, callback);
    if (VERBOSE) {
        CaptureRequest[] requestArray = requests.toArray(new CaptureRequest[0]);
        Log.v(TAG, mIdString + ""captureBurst - requests "" + Arrays.toString(requestArray) + "", callback "" + callback + "" handler "" + handler);
    }
    return addPendingSequence(mDeviceImpl.captureBurst(requests, createCaptureCallbackProxy(handler, callback), mDeviceHandler));
}","{
    if (requests == null) {
        throw new IllegalArgumentException(""Requests must not be null"");
    } else if (requests.isEmpty()) {
        throw new IllegalArgumentException(""Requests must have at least one element"");
    }
    for (CaptureRequest request : requests) {
        if (request.isReprocess()) {
            if (!isReprocessable()) {
                throw new IllegalArgumentException(""This capture session cannot handle "" + ""reprocess requests"");
            } else if (request.getReprocessableSessionId() != mId) {
                throw new IllegalArgumentException(""Capture request was created for another "" + ""session"");
            }
        }
    }
    checkNotClosed();
    handler = checkHandler(handler, callback);
    if (DEBUG) {
        CaptureRequest[] requestArray = requests.toArray(new CaptureRequest[0]);
        Log.v(TAG, mIdString + ""captureBurst - requests "" + Arrays.toString(requestArray) + "", callback "" + callback + "" handler "" + handler);
    }
    return addPendingSequence(mDeviceImpl.captureBurst(requests, createCaptureCallbackProxy(handler, callback), mDeviceHandler));
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,3,4","1,2","There is a new exception handling statement introduced for checking if the requests are reprocess requests, the log level variable changed from VERBOSE to DEBUG, and additional validation logic has been added within the new 'for' loop. These combined constitute changes in exception handling (2), control dependency (3), and other statement changes (4).","The newly added checks for reprocess requests introduce new scenarios where an IllegalArgumentException may be thrown, which is a change in the exception handling that can cause a Compatibility Issue (2). This change also potentially affects the return value of the method if an exception is thrown before reaching the return statement (1)."
713,"<android.content.res.TypedArray: int getInt(int,int)>",22,23,"<android.content.res.TypedArray: int getInt(int,int)>","<android.content.res.TypedArray: int getInt(int,int)>",0,"{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA];
    }
    TypedValue v = mValue;
    if (getValueAt(index, v)) {
        Log.w(Resources.TAG, ""Converting to int: "" + v);
        return XmlUtils.convertValueToInt(v.coerceToString(), defValue);
    }
    Log.w(Resources.TAG, ""getInt of bad type: 0x"" + Integer.toHexString(type));
    return defValue;
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA];
    }
    final TypedValue v = mValue;
    if (getValueAt(index, v)) {
        StrictMode.noteResourceMismatch(v);
        return XmlUtils.convertValueToInt(v.coerceToString(), defValue);
    }
    // We already checked for TYPE_NULL. This should never happen.
    throw new RuntimeException(""getInt of bad type: 0x"" + Integer.toHexString(type));
}",1,"/**
 * Retrieve the integer value for the attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined.
 *
 * @return Attribute int value, or defValue if not defined.
 */
","/**
 * Retrieve the integer value for the attribute at <var>index</var>.
 * <p>
 * If the attribute is not an integer, this method will attempt to coerce
 * it to an integer using {@link Integer#decode(String)}.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * cannot be coerced to an integer.
 *
 * @return Integer value of the attribute, or defValue if the attribute was
 * not defined or could not be coerced to an integer.
 * @throws RuntimeException if the TypedArray has already been recycled.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4","1,2","The log statement was replaced by a strict mode check (""StrictMode.noteResourceMismatch(v);""), and a RuntimeException is thrown instead of logging a warning when the type is not an integer. This constitutes other statement changes (4) and exception handling statement changes (2).","The new strict mode check does not cause a compatibility issue because it does not affect the method's return value. However, the change in exception behavior does lead to a Compatibility Issue: the late version of the method will throw a RuntimeException for non-integer types instead of returning the default value as the early version did. This leads to CI types 1 and 2, as the API now has potentially different return values (returning a value vs. not returning due to an exception) and exception handling."
714,<android.widget.FastScroller: boolean onTouchEvent(MotionEvent)>,22,23,<android.widget.FastScroller: boolean onTouchEvent(MotionEvent)>,<android.widget.FastScroller: boolean onTouchEvent(MotionEvent)>,0,"{
    if (!isEnabled()) {
        return false;
    }
    switch(me.getActionMasked()) {
        case MotionEvent.ACTION_UP:
            {
                if (mPendingDrag >= 0) {
                    // Allow a tap to scroll.
                    beginDrag();
                    final float pos = getPosFromMotionEvent(me.getY());
                    setThumbPos(pos);
                    scrollTo(pos);
                // Will hit the STATE_DRAGGING check below
                }
                if (mState == STATE_DRAGGING) {
                    if (mList != null) {
                        // ViewGroup does the right thing already, but there might
                        // be other classes that don't properly reset on touch-up,
                        // so do this explicitly just in case.
                        mList.requestDisallowInterceptTouchEvent(false);
                        mList.reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                    }
                    setState(STATE_VISIBLE);
                    postAutoHide();
                    return true;
                }
            }
            break;
        case MotionEvent.ACTION_MOVE:
            {
                if (mPendingDrag >= 0 && Math.abs(me.getY() - mInitialTouchY) > mScaledTouchSlop) {
                    beginDrag();
                // Will hit the STATE_DRAGGING check below
                }
                if (mState == STATE_DRAGGING) {
                    // TODO: Ignore jitter.
                    final float pos = getPosFromMotionEvent(me.getY());
                    setThumbPos(pos);
                    // If the previous scrollTo is still pending
                    if (mScrollCompleted) {
                        scrollTo(pos);
                    }
                    return true;
                }
            }
            break;
        case MotionEvent.ACTION_CANCEL:
            {
                cancelPendingDrag();
            }
            break;
    }
    return false;
}","{
    if (!isEnabled()) {
        return false;
    }
    switch(me.getActionMasked()) {
        case MotionEvent.ACTION_DOWN:
            {
                if (isPointInside(me.getX(), me.getY())) {
                    if (!mList.isInScrollingContainer()) {
                        beginDrag();
                        return true;
                    }
                }
            }
            break;
        case MotionEvent.ACTION_UP:
            {
                if (mPendingDrag >= 0) {
                    // Allow a tap to scroll.
                    beginDrag();
                    final float pos = getPosFromMotionEvent(me.getY());
                    setThumbPos(pos);
                    scrollTo(pos);
                // Will hit the STATE_DRAGGING check below
                }
                if (mState == STATE_DRAGGING) {
                    if (mList != null) {
                        // ViewGroup does the right thing already, but there might
                        // be other classes that don't properly reset on touch-up,
                        // so do this explicitly just in case.
                        mList.requestDisallowInterceptTouchEvent(false);
                        mList.reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                    }
                    setState(STATE_VISIBLE);
                    postAutoHide();
                    return true;
                }
            }
            break;
        case MotionEvent.ACTION_MOVE:
            {
                if (mPendingDrag >= 0 && Math.abs(me.getY() - mInitialTouchY) > mScaledTouchSlop) {
                    beginDrag();
                // Will hit the STATE_DRAGGING check below
                }
                if (mState == STATE_DRAGGING) {
                    // TODO: Ignore jitter.
                    final float pos = getPosFromMotionEvent(me.getY());
                    setThumbPos(pos);
                    // If the previous scrollTo is still pending
                    if (mScrollCompleted) {
                        scrollTo(pos);
                    }
                    return true;
                }
            }
            break;
        case MotionEvent.ACTION_CANCEL:
            {
                cancelPendingDrag();
            }
            break;
    }
    return false;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The implementation has been modified to include a new case for MotionEvent.ACTION_DOWN and a new conditional block within this case. Also, the implementation has changed in the ACTION_UP case where a new condition to check 'mList.isInScrollingContainer()' has been introduced. These introduce a change in both control dependencies and other statements, thus the code changes types are 3,4.","Despite the changes in control flow and additional statements within cases, no changes are made to the return values or exception handling related to the onTouchEvent method's signature. Thus, there is no Compatibility Issue with respect to the possibility of the method returning different values or throwing different exceptions as a result of these changes. The behavior of the method in response to touch events has been expanded but not altered in a way that would lead to a CI; therefore, the CI type is 0."
715,"<android.widget.RemoteViews.SetDrawableParameters: void apply(View,ViewGroup,OnClickHandler)>",22,23,"<android.widget.RemoteViews.SetDrawableParameters: void apply(View,ViewGroup,OnClickHandler)>","<android.widget.RemoteViews.SetDrawableParameters: void apply(View,ViewGroup,OnClickHandler)>",0,"{
    final View target = root.findViewById(viewId);
    if (target == null)
        return;
    // Pick the correct drawable to modify for this view
    Drawable targetDrawable = null;
    if (targetBackground) {
        targetDrawable = target.getBackground();
    } else if (target instanceof ImageView) {
        ImageView imageView = (ImageView) target;
        targetDrawable = imageView.getDrawable();
    }
    if (targetDrawable != null) {
        // Perform modifications only if values are set correctly
        if (alpha != -1) {
            targetDrawable.setAlpha(alpha);
        }
        if (filterMode != null) {
            targetDrawable.setColorFilter(colorFilter, filterMode);
        }
        if (level != -1) {
            targetDrawable.setLevel(level);
        }
    }
}","{
    final View target = root.findViewById(viewId);
    if (target == null)
        return;
    // Pick the correct drawable to modify for this view
    Drawable targetDrawable = null;
    if (targetBackground) {
        targetDrawable = target.getBackground();
    } else if (target instanceof ImageView) {
        ImageView imageView = (ImageView) target;
        targetDrawable = imageView.getDrawable();
    }
    if (targetDrawable != null) {
        // Perform modifications only if values are set correctly
        if (alpha != -1) {
            targetDrawable.mutate().setAlpha(alpha);
        }
        if (filterMode != null) {
            targetDrawable.mutate().setColorFilter(colorFilter, filterMode);
        }
        if (level != -1) {
            targetDrawable.mutate().setLevel(level);
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The late version adds multiple calls to the `mutate()` method before calling `setAlpha(alpha)`, `setColorFilter(colorFilter, filterMode)`, and `setLevel(level)` on targetDrawable. This is classified as category 4 (Other statement changed).","These changes will not introduce a Compatibility Issue because the behavior of mutating the Drawable is an internal state change that does not affect the API's return type or value, and does not change exception handling. Moreover, it does not affect the external contract of the `apply` method, which still returns `void`. Therefore, there is no Compatibility Issue."
717,"<android.widget.ArrayAdapter: View getView(int,View,ViewGroup)>",22,23,"<android.widget.ArrayAdapter: View getView(int,View,ViewGroup)>","<android.widget.ArrayAdapter: View getView(int,View,ViewGroup)>",0,"{
    return createViewFromResource(position, convertView, parent, mResource);
}","{
    return createViewFromResource(mInflater, position, convertView, parent, mResource);
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation has changed with an additional parameter being passed to `createViewFromResource()`. Since `mInflater` is passed in late version, the method signature of a dependent API has changed, so the code change type is 5.","There is no Compatibility Issue detected because adding an additional parameter (`mInflater`) which is already a member variable does not inherently affect the behavior of the `getView` API as it is an internal change to how `createViewFromResource` is called. It will presumably handle `mInflater` as it did previously, and there is no evidence from the signature or implementation that this would alter the behavior or contract of the `getView` method."
718,<android.bluetooth.BluetoothDevice: BluetoothSocket createRfcommSocketToServiceRecord(UUID)>,22,23,<android.bluetooth.BluetoothDevice: BluetoothSocket createRfcommSocketToServiceRecord(UUID)>,<android.bluetooth.BluetoothDevice: BluetoothSocket createRfcommSocketToServiceRecord(UUID)>,0,"{
    return new BluetoothSocket(BluetoothSocket.TYPE_RFCOMM, -1, true, true, this, -1, new ParcelUuid(uuid));
}","{
    if (isBluetoothEnabled() == false) {
        Log.e(TAG, ""Bluetooth is not enabled"");
        throw new IOException();
    }
    return new BluetoothSocket(BluetoothSocket.TYPE_RFCOMM, -1, true, true, this, -1, new ParcelUuid(uuid));
}",1,"/**
 * Create an RFCOMM {@link BluetoothSocket} ready to start a secure
 * outgoing connection to this remote device using SDP lookup of uuid.
 * <p>This is designed to be used with {@link
 * BluetoothAdapter#listenUsingRfcommWithServiceRecord} for peer-peer
 * Bluetooth applications.
 * <p>Use {@link BluetoothSocket#connect} to initiate the outgoing
 * connection. This will also perform an SDP lookup of the given uuid to
 * determine which channel to connect to.
 * <p>The remote device will be authenticated and communication on this
 * socket will be encrypted.
 * <p> Use this socket only if an authenticated socket link is possible.
 * Authentication refers to the authentication of the link key to
 * prevent man-in-the-middle type of attacks.
 * For example, for Bluetooth 2.1 devices, if any of the devices does not
 * have an input and output capability or just has the ability to
 * display a numeric key, a secure socket connection is not possible.
 * In such a case, use {#link createInsecureRfcommSocketToServiceRecord}.
 * For more details, refer to the Security Model section 5.2 (vol 3) of
 * Bluetooth Core Specification version 2.1 + EDR.
 * <p>Hint: If you are connecting to a Bluetooth serial board then try
 * using the well-known SPP UUID 00001101-0000-1000-8000-00805F9B34FB.
 * However if you are connecting to an Android peer then please generate
 * your own unique UUID.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
 *
 * @param uuid service record uuid to lookup RFCOMM channel
 * @return a RFCOMM BluetoothServerSocket ready for an outgoing connection
 * @throws IOException on error, for example Bluetooth not available, or
 * insufficient permissions
 */
","/**
 * Create an RFCOMM {@link BluetoothSocket} ready to start a secure
 * outgoing connection to this remote device using SDP lookup of uuid.
 * <p>This is designed to be used with {@link
 * BluetoothAdapter#listenUsingRfcommWithServiceRecord} for peer-peer
 * Bluetooth applications.
 * <p>Use {@link BluetoothSocket#connect} to initiate the outgoing
 * connection. This will also perform an SDP lookup of the given uuid to
 * determine which channel to connect to.
 * <p>The remote device will be authenticated and communication on this
 * socket will be encrypted.
 * <p> Use this socket only if an authenticated socket link is possible.
 * Authentication refers to the authentication of the link key to
 * prevent man-in-the-middle type of attacks.
 * For example, for Bluetooth 2.1 devices, if any of the devices does not
 * have an input and output capability or just has the ability to
 * display a numeric key, a secure socket connection is not possible.
 * In such a case, use {#link createInsecureRfcommSocketToServiceRecord}.
 * For more details, refer to the Security Model section 5.2 (vol 3) of
 * Bluetooth Core Specification version 2.1 + EDR.
 * <p>Hint: If you are connecting to a Bluetooth serial board then try
 * using the well-known SPP UUID 00001101-0000-1000-8000-00805F9B34FB.
 * However if you are connecting to an Android peer then please generate
 * your own unique UUID.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
 *
 * @param uuid service record uuid to lookup RFCOMM channel
 * @return a RFCOMM BluetoothServerSocket ready for an outgoing connection
 * @throws IOException on error, for example Bluetooth not available, or
 * insufficient permissions
 */
",-1,,[@RequiresPermission(Manifest.permission.BLUETOOTH)],-1,-1,-1,-1,-1,-1,"2,3,4",2,"Control dependency change due to the added if statement. Exception handling statement has been introduced with the throw new IOException() statement when Bluetooth is not enabled. There is also an addition of a log statement, so the code change type is 2,3,4.","Since an exception is now thrown if Bluetooth is not enabled, the API can potentially throw a new exception that did not exist in the earlier version, and the CI type is 2."
719,"<android.webkit.WebView: void loadUrl(String,Map<String, String>)>",22,23,"<android.webkit.WebView: void loadUrl(String,Map<String, String>)>","<android.webkit.WebView: void loadUrl(String,Map<String, String>)>",0,"{
    checkThread();
    if (TRACE) {
        StringBuilder headers = new StringBuilder();
        if (additionalHttpHeaders != null) {
            for (Map.Entry<String, String> entry : additionalHttpHeaders.entrySet()) {
                headers.append(entry.getKey() + "":"" + entry.getValue() + ""\n"");
            }
        }
        Log.d(LOGTAG, ""loadUrl(extra headers)="" + url + ""\n"" + headers);
    }
    mProvider.loadUrl(url, additionalHttpHeaders);
}","{
    checkThread();
    mProvider.loadUrl(url, additionalHttpHeaders);
}",1,"/**
 * Loads the given URL with the specified additional HTTP headers.
 *
 * @param url the URL of the resource to load
 * @param additionalHttpHeaders the additional headers to be used in the
 * HTTP request for this URL, specified as a map from name to
 * value. Note that if this map contains any of the headers
 * that are set by default by this WebView, such as those
 * controlling caching, accept types or the User-Agent, their
 * values may be overriden by this WebView's defaults.
 */
","/**
 * Loads the given URL with the specified additional HTTP headers.
 *
 * @param url the URL of the resource to load
 * @param additionalHttpHeaders the additional headers to be used in the
 * HTTP request for this URL, specified as a map from name to
 * value. Note that if this map contains any of the headers
 * that are set by default by this WebView, such as those
 * controlling caching, accept types or the User-Agent, their
 * values may be overriden by this WebView's defaults.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The TRACE condition block has been removed, resulting in the deletion of code related to headers logging. That is an Other statement change (4), not affecting the API's behavior.","Since the removed code is solely for debug logging and has no effect on the actual functionality of the API or the values it returns, there is no Compatibility Issue (0)."
720,<android.app.ApplicationPackageManager: Resources getResourcesForApplication(ApplicationInfo)>,22,23,<android.app.ApplicationPackageManager: Resources getResourcesForApplication(ApplicationInfo)>,<android.app.ApplicationPackageManager: Resources getResourcesForApplication(ApplicationInfo)>,0,"{
    if (app.packageName.equals(""system"")) {
        return mContext.mMainThread.getSystemContext().getResources();
    }
    final boolean sameUid = (app.uid == Process.myUid());
    Resources r = mContext.mMainThread.getTopLevelResources(sameUid ? app.sourceDir : app.publicSourceDir, sameUid ? app.splitSourceDirs : app.splitPublicSourceDirs, app.resourceDirs, app.sharedLibraryFiles, Display.DEFAULT_DISPLAY, null, mContext.mPackageInfo);
    if (r != null) {
        return r;
    }
    throw new NameNotFoundException(""Unable to open "" + app.publicSourceDir);
}","{
    if (app.packageName.equals(""system"")) {
        return mContext.mMainThread.getSystemContext().getResources();
    }
    final boolean sameUid = (app.uid == Process.myUid());
    final Resources r = mContext.mMainThread.getTopLevelResources(sameUid ? app.sourceDir : app.publicSourceDir, sameUid ? app.splitSourceDirs : app.splitPublicSourceDirs, app.resourceDirs, app.sharedLibraryFiles, Display.DEFAULT_DISPLAY, null, mContext.mPackageInfo);
    if (r != null) {
        return r;
    }
    throw new NameNotFoundException(""Unable to open "" + app.publicSourceDir);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,0,0,"The source code between early and late versions appears to be logically identical, with no observable changes related to the behavior of the method. The only difference is the addition of `final` to the declaration of the variable `r`, which does not impact the method's behavior.","Since there is no change in the algorithm or logic of the method, there is no compatibility issue. The method should behave identically in both versions, hence no CI can arise."
722,<android.print.PrinterCapabilitiesInfo: int hashCode()>,22,23,<android.print.PrinterCapabilitiesInfo: int hashCode()>,<android.print.PrinterCapabilitiesInfo: int hashCode()>,0,"{
    final int prime = 31;
    int result = 1;
    result = prime * result + ((mMinMargins == null) ? 0 : mMinMargins.hashCode());
    result = prime * result + ((mMediaSizes == null) ? 0 : mMediaSizes.hashCode());
    result = prime * result + ((mResolutions == null) ? 0 : mResolutions.hashCode());
    result = prime * result + mColorModes;
    result = prime * result + Arrays.hashCode(mDefaults);
    return result;
}","{
    final int prime = 31;
    int result = 1;
    result = prime * result + ((mMinMargins == null) ? 0 : mMinMargins.hashCode());
    result = prime * result + ((mMediaSizes == null) ? 0 : mMediaSizes.hashCode());
    result = prime * result + ((mResolutions == null) ? 0 : mResolutions.hashCode());
    result = prime * result + mColorModes;
    result = prime * result + mDuplexModes;
    result = prime * result + Arrays.hashCode(mDefaults);
    return result;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The hashCode computation now includes an additional member variable `mDuplexModes` in its calculation, which represents a change in the internal implementation of the method not affecting method signature or behaviour from an API consumer perspective. Hence, the code change type is 4 (Other statement changed).","This change does not introduce a compatibility issue. The purpose of the `hashCode()` method is to provide a hash code, and while its internal calculation has changed, the contract of the method is still maintained. It does not change the nature of how this API should be used or the nature of the data it returns beyond the hash computation itself. Callers of the method expect the output to change whenever the internal state changes, which remains true here. Hence, there is no compatibility issue."
723,<android.view.inputmethod.InputMethodManager: void finishInputLocked()>,22,23,<android.view.inputmethod.InputMethodManager: void finishInputLocked()>,<android.view.inputmethod.InputMethodManager: void finishInputLocked()>,0,"{
    mCurRootView = null;
    mNextServedView = null;
    if (mServedView != null) {
        if (DEBUG)
            Log.v(TAG, ""FINISH INPUT: "" + mServedView);
        if (mCurrentTextBoxAttribute != null) {
            try {
                mService.finishInput(mClient);
            } catch (RemoteException e) {
            }
        }
        notifyInputConnectionFinished();
        mServedView = null;
        mCompletions = null;
        mServedConnecting = false;
        clearConnectionLocked();
    }
}","{
    mNextServedView = null;
    if (mServedView != null) {
        if (DEBUG)
            Log.v(TAG, ""FINISH INPUT: "" + mServedView);
        if (mCurrentTextBoxAttribute != null) {
            try {
                mService.finishInput(mClient);
            } catch (RemoteException e) {
            }
        }
        notifyInputConnectionFinished();
        mServedView = null;
        mCompletions = null;
        mServedConnecting = false;
        clearConnectionLocked();
    }
}",1,"/**
 * Disconnect any existing input connection, clearing the served view.
 */
","/**
 * Disconnect any existing input connection, clearing the served view.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The statement ""mCurRootView = null;"" is deleted in the late version, so the code change is of type 4.","Since the deletion of the statement ""mCurRootView = null;"" does not affect the behavior of the returned value or the exceptions thrown by the method, there is no compatibility issue, thus CI type is 0."
724,<android.os.PowerManager: void wakeUp(long)>,22,23,<android.os.PowerManager: void wakeUp(long)>,<android.os.PowerManager: void wakeUp(long)>,0,"{
    try {
        mService.wakeUp(time);
    } catch (RemoteException e) {
    }
}","{
    try {
        mService.wakeUp(time, ""wakeUp"", mContext.getOpPackageName());
    } catch (RemoteException e) {
    }
}",1,"/**
 * Forces the device to wake up from sleep.
 * <p>
 * If the device is currently asleep, wakes it up, otherwise does nothing.
 * This is what happens when the power key is pressed to turn on the screen.
 * </p><p>
 * Requires the {@link android.Manifest.permission#DEVICE_POWER} permission.
 * </p>
 *
 * @param time The time when the request to wake up was issued, in the
 * {@link SystemClock#uptimeMillis()} time base.  This timestamp is used to correctly
 * order the wake up request with other power management functions.  It should be set
 * to the timestamp of the input event that caused the request to wake up.
 *
 * @see #userActivity
 * @see #goToSleep
 *
 * @removed Requires signature permission.
 */
","/**
 * Forces the device to wake up from sleep.
 * <p>
 * If the device is currently asleep, wakes it up, otherwise does nothing.
 * This is what happens when the power key is pressed to turn on the screen.
 * </p><p>
 * Requires the {@link android.Manifest.permission#DEVICE_POWER} permission.
 * </p>
 *
 * @param time The time when the request to wake up was issued, in the
 * {@link SystemClock#uptimeMillis()} time base.  This timestamp is used to correctly
 * order the wake up request with other power management functions.  It should be set
 * to the timestamp of the input event that caused the request to wake up.
 *
 * @see #userActivity
 * @see #goToSleep
 *
 * @removed Requires signature permission.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method call within the try block has been changed to include two additional parameters (""wakeUp"", mContext.getOpPackageName()). This is considered as a change in a dependent API since it's invoking 'mService.wakeUp' with different parameters. Therefore, the code change types are 4 and 5.","The change does not introduce any new behavior that could cause the method to return a different value or throw a different exception. The additional parameters in the wake-up method don't alter the nature of the exception handling nor the return type (void). Thus, there's no compatibility issue based on the given definitions, making the CI type 0."
725,"<android.widget.ArrayAdapter: View getDropDownView(int,View,ViewGroup)>",22,23,"<android.widget.ArrayAdapter: View getDropDownView(int,View,ViewGroup)>","<android.widget.ArrayAdapter: View getDropDownView(int,View,ViewGroup)>",0,"{
    return createViewFromResource(position, convertView, parent, mDropDownResource);
}","{
    final LayoutInflater inflater = mDropDownInflater == null ? mInflater : mDropDownInflater;
    return createViewFromResource(inflater, position, convertView, parent, mDropDownResource);
}",1,"/**
 * {@inheritDoc}
 */
",,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"A new variable 'inflater' is introduced and now explicitly passed to the 'createViewFromResource' method, so the code change type is 4,5.","This change could potentially lead to a different behavior as the view could be inflated using a different LayoutInflater (either mDropDownInflater or mInflater), which might affect the appearance or properties of the returned view. Thus, the CI type is 1."
726,<android.text.style.SubscriptSpan: int getSpanTypeId()>,22,23,<android.text.style.SubscriptSpan: int getSpanTypeId()>,<android.text.style.SubscriptSpan: int getSpanTypeId()>,0,"{
    return TextUtils.SUBSCRIPT_SPAN;
}","{
    return getSpanTypeIdInternal();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation calls a different method (getSpanTypeIdInternal instead of a static reference TextUtils.SUBSCRIPT_SPAN), so the change type is 5 (Dependent API changed).","There is no Compatibility Issue if the internal method getSpanTypeIdInternal always returns the same constant value that TextUtils.SUBSCRIPT_SPAN would return. As long as the return value remains the same and no other behavioral change is introduced, there's no CI."
727,"<android.widget.SimpleAdapter: View getDropDownView(int,View,ViewGroup)>",22,23,"<android.widget.SimpleAdapter: View getDropDownView(int,View,ViewGroup)>","<android.widget.SimpleAdapter: View getDropDownView(int,View,ViewGroup)>",0,"{
    return createViewFromResource(position, convertView, parent, mDropDownResource);
}","{
    final LayoutInflater inflater = mDropDownInflater == null ? mInflater : mDropDownInflater;
    return createViewFromResource(inflater, position, convertView, parent, mDropDownResource);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The difference is in the implementation details where a new local variable `inflater` is introduced and used in the method call `createViewFromResource`. This change involves using a potentially different LayoutInflater instance which is a detail internal to the method implementation and depends on whether mDropDownInflater is null or not. Thus, the change type is 5 since there is a modification in how a dependent method `createViewFromResource` is called.","There is no change in the return type or exception handling, the logic is still returning a View from createViewFromResource but with a possibly different LayoutInflater. This does not change the signature nor the behavior of the method in terms of its public contract, so there is no compatibility issue in terms of different return type or exceptions thrown. Therefore, the CI type is 0."
729,<android.widget.AdapterView: int getPositionForView(View)>,22,23,<android.widget.AdapterView: int getPositionForView(View)>,<android.widget.AdapterView: int getPositionForView(View)>,0,"{
    View listItem = view;
    try {
        View v;
        while (!(v = (View) listItem.getParent()).equals(this)) {
            listItem = v;
        }
    } catch (ClassCastException e) {
        // We made it up to the window without find this list view
        return INVALID_POSITION;
    }
    // Search the children for the list item
    final int childCount = getChildCount();
    for (int i = 0; i < childCount; i++) {
        if (getChildAt(i).equals(listItem)) {
            return mFirstPosition + i;
        }
    }
    // Child not found!
    return INVALID_POSITION;
}","{
    View listItem = view;
    try {
        View v;
        while ((v = (View) listItem.getParent()) != null && !v.equals(this)) {
            listItem = v;
        }
    } catch (ClassCastException e) {
        // We made it up to the window without find this list view
        return INVALID_POSITION;
    }
    if (listItem != null) {
        // Search the children for the list item
        final int childCount = getChildCount();
        for (int i = 0; i < childCount; i++) {
            if (getChildAt(i).equals(listItem)) {
                return mFirstPosition + i;
            }
        }
    }
    // Child not found!
    return INVALID_POSITION;
}",1,"/**
 * Get the position within the adapter's data set for the view, where view is a an adapter item
 * or a descendant of an adapter item.
 *
 * @param view an adapter item, or a descendant of an adapter item. This must be visible in this
 * AdapterView at the time of the call.
 * @return the position within the adapter's data set of the view, or {@link #INVALID_POSITION}
 * if the view does not correspond to a list item (or it is not currently visible).
 */
","/**
 * Get the position within the adapter's data set for the view, where view is a an adapter item
 * or a descendant of an adapter item.
 *
 * @param view an adapter item, or a descendant of an adapter item. This must be visible in this
 * AdapterView at the time of the call.
 * @return the position within the adapter's data set of the view, or {@link #INVALID_POSITION}
 * if the view does not correspond to a list item (or it is not currently visible).
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"The control dependency has changed in the while loop condition, adding a null check for the parent view. Additionally, the late version added an if statement to check if listItem is not null before searching the child views. These changes affect the flow of control in the method, thus the change type is 3.","Since the null check for the parent view has been added, there is a possibility that the loop might terminate earlier, which could lead to a scenario where 'listItem' remains `null` and not proceed with the child search, consequently returning INVALID_POSITION earlier than it would have in the early version. Moreover, adding the null-check condition for 'listItem' before the search could prevent a potential NullPointerException, affecting which value is returned. Therefore, these changes could cause the method to return a different result, making the CI type 1."
730,"<android.content.res.Resources: Drawable loadDrawable(TypedValue,int,Theme)>",22,23,"<android.content.res.Resources: Drawable loadDrawable(TypedValue,int,Theme)>","<android.content.res.Resources: Drawable loadDrawable(TypedValue,int,Theme)>",0,"{
    if (TRACE_FOR_PRELOAD) {
        // Log only framework resources
        if ((id >>> 24) == 0x1) {
            final String name = getResourceName(id);
            if (name != null) {
                Log.d(""PreloadDrawable"", name);
            }
        }
    }
    final boolean isColorDrawable;
    final ArrayMap<String, LongSparseArray<WeakReference<ConstantState>>> caches;
    final long key;
    if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {
        isColorDrawable = true;
        caches = mColorDrawableCache;
        key = value.data;
    } else {
        isColorDrawable = false;
        caches = mDrawableCache;
        key = (((long) value.assetCookie) << 32) | value.data;
    }
    // that was inflated against the specified theme.
    if (!mPreloading) {
        final Drawable cachedDrawable = getCachedDrawable(caches, key, theme);
        if (cachedDrawable != null) {
            return cachedDrawable;
        }
    }
    // Next, check preloaded drawables. These are unthemed but may have
    // themeable attributes.
    final ConstantState cs;
    if (isColorDrawable) {
        cs = sPreloadedColorDrawables.get(key);
    } else {
        cs = sPreloadedDrawables[mConfiguration.getLayoutDirection()].get(key);
    }
    final Drawable dr;
    if (cs != null) {
        final Drawable clonedDr = cs.newDrawable(this);
        if (theme != null) {
            dr = clonedDr.mutate();
            dr.applyTheme(theme);
            dr.clearMutated();
        } else {
            dr = clonedDr;
        }
    } else if (isColorDrawable) {
        dr = new ColorDrawable(value.data);
    } else {
        dr = loadDrawableForCookie(value, id, theme);
    }
    // cache (either preload or themed).
    if (dr != null) {
        dr.setChangingConfigurations(value.changingConfigurations);
        cacheDrawable(value, theme, isColorDrawable, caches, key, dr);
    }
    return dr;
}","{
    if (TRACE_FOR_PRELOAD) {
        // Log only framework resources
        if ((id >>> 24) == 0x1) {
            final String name = getResourceName(id);
            if (name != null) {
                Log.d(""PreloadDrawable"", name);
            }
        }
    }
    final boolean isColorDrawable;
    final DrawableCache caches;
    final long key;
    if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {
        isColorDrawable = true;
        caches = mColorDrawableCache;
        key = value.data;
    } else {
        isColorDrawable = false;
        caches = mDrawableCache;
        key = (((long) value.assetCookie) << 32) | value.data;
    }
    // that was inflated against the specified theme.
    if (!mPreloading) {
        final Drawable cachedDrawable = caches.getInstance(key, theme);
        if (cachedDrawable != null) {
            return cachedDrawable;
        }
    }
    // Next, check preloaded drawables. These may contain unresolved theme
    // attributes.
    final ConstantState cs;
    if (isColorDrawable) {
        cs = sPreloadedColorDrawables.get(key);
    } else {
        cs = sPreloadedDrawables[mConfiguration.getLayoutDirection()].get(key);
    }
    Drawable dr;
    if (cs != null) {
        dr = cs.newDrawable(this);
    } else if (isColorDrawable) {
        dr = new ColorDrawable(value.data);
    } else {
        dr = loadDrawableForCookie(value, id, null);
    }
    // Determine if the drawable has unresolved theme attributes. If it
    // does, we'll need to apply a theme and store it in a theme-specific
    // cache.
    final boolean canApplyTheme = dr != null && dr.canApplyTheme();
    if (canApplyTheme && theme != null) {
        dr = dr.mutate();
        dr.applyTheme(theme);
        dr.clearMutated();
    }
    // cache: preload, not themed, null theme, or theme-specific.
    if (dr != null) {
        dr.setChangingConfigurations(value.changingConfigurations);
        cacheDrawable(value, isColorDrawable, caches, theme, canApplyTheme, key, dr);
    }
    return dr;
}",1,"/*package*/
",,-1,,[@Nullable],-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The return statements are altered due to the changes in cache retrieval and drawable instantiation logic, the implementation of caching and theming of Drawables is updated, and the type of the 'caches' variable has changed from a general `ArrayMap` to the more specific `DrawableCache`. These account for the following changes: return statement change, control dependency change (due to the if conditions being reworked), other statement changed (modification in the logic of theme application and mutation of the Drawable), and dependent API change (as the method signatures for cache retrieval and caching Drawables have been modified). The code has seen changes in the logic and the way caching and theming of Drawables are handled.","The API could potentially return a different Drawable due to changes in how caching and theming are applied, and how the drawables are instantiated which definitely affects the final Drawable returned. If the logic within 'loadDrawableForCookie' or the 'caches' behaviors are in any way modified, this will lead to a Drawable being returned that might have had a different configuration, theme application, or may not even be cached as before. Moreover, the method now respects theme application differently, which is also a behavior-altering change. Therefore, there is a compatibility issue caused by potential different return values."
731,"<android.content.ContentProviderClient: String[] getStreamTypes(Uri,String)>",22,23,"<android.content.ContentProviderClient: String[] getStreamTypes(Uri,String)>","<android.content.ContentProviderClient: String[] getStreamTypes(Uri,String)>",0,"{
    beforeRemote();
    try {
        return mContentProvider.getStreamTypes(url, mimeTypeFilter);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}","{
    Preconditions.checkNotNull(url, ""url"");
    Preconditions.checkNotNull(mimeTypeFilter, ""mimeTypeFilter"");
    beforeRemote();
    try {
        return mContentProvider.getStreamTypes(url, mimeTypeFilter);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}",1,"/**
 * See {@link ContentProvider#getStreamTypes ContentProvider.getStreamTypes}
 */
","/**
 * See {@link ContentProvider#getStreamTypes ContentProvider.getStreamTypes}
 */
",-1,,[@Nullable],-1,-1,-1,-1,-1,-1,4,0,"Additional precondition checks for the parameters `url` and `mimeTypeFilter` have been introduced, which are considered as other statements, so the code change type is 4.","Since the precondition checks will only trigger exceptions if the inputs are null and the API's functionality remains the same if valid parameters are passed, no compatibility issue will be caused by this change in behavior. As the main logic of the method and the exceptions thrown remain unchanged, there is no compatibility issue."
733,"<android.net.http.HttpResponseCache: HttpResponseCache install(File,long)>",22,23,"<android.net.http.HttpResponseCache: HttpResponseCache install(File,long)>","<android.net.http.HttpResponseCache: HttpResponseCache install(File,long)>",0,"{
    ResponseCache installed = ResponseCache.getDefault();
    if (installed instanceof com.android.okhttp.HttpResponseCache) {
        com.android.okhttp.HttpResponseCache installedCache = (com.android.okhttp.HttpResponseCache) installed;
        // don't close and reopen if an equivalent cache is already installed
        if (installedCache.getDirectory().equals(directory) && installedCache.getMaxSize() == maxSize && !installedCache.isClosed()) {
            return new HttpResponseCache(installedCache);
        } else {
            // The HttpResponseCache that owns this object is about to be replaced.
            installedCache.close();
        }
    }
    com.android.okhttp.HttpResponseCache responseCache = new com.android.okhttp.HttpResponseCache(directory, maxSize);
    ResponseCache.setDefault(responseCache);
    return new HttpResponseCache(responseCache);
}","{
    ResponseCache installed = ResponseCache.getDefault();
    if (installed instanceof HttpResponseCache) {
        HttpResponseCache installedResponseCache = (HttpResponseCache) installed;
        // don't close and reopen if an equivalent cache is already installed
        AndroidShimResponseCache trueResponseCache = installedResponseCache.delegate;
        if (trueResponseCache.isEquivalent(directory, maxSize)) {
            return installedResponseCache;
        } else {
            // The HttpResponseCache that owns this object is about to be replaced.
            trueResponseCache.close();
        }
    }
    AndroidShimResponseCache trueResponseCache = AndroidShimResponseCache.create(directory, maxSize);
    HttpResponseCache newResponseCache = new HttpResponseCache(trueResponseCache);
    ResponseCache.setDefault(newResponseCache);
    return newResponseCache;
}",1,"/**
 * Creates a new HTTP response cache and {@link ResponseCache#setDefault
 * sets it} as the system default cache.
 *
 * @param directory the directory to hold cache data.
 * @param maxSize the maximum size of the cache in bytes.
 * @return the newly-installed cache
 * @throws IOException if {@code directory} cannot be used for this cache.
 * Most applications should respond to this exception by logging a
 * warning.
 */
","/**
 * Creates a new HTTP response cache and sets it as the system default cache.
 *
 * @param directory the directory to hold cache data.
 * @param maxSize the maximum size of the cache in bytes.
 * @return the newly-installed cache
 * @throws IOException if {@code directory} cannot be used for this cache.
 * Most applications should respond to this exception by logging a
 * warning.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The implementation change involves modifications to the return statement, changes to control dependencies and other statements, and a dependent API change, therefore, the code change types are 1, 3, 4, and 5. Specifically:","- The other statements include changes like the method call 'isEquivalent' instead of comparing properties directly, and 'create' instead of a new instance creation for 'AndroidShimResponseCache'."
735,"<android.widget.AdapterView: boolean performItemClick(View,int,long)>",22,23,"<android.widget.AdapterView: boolean performItemClick(View,int,long)>","<android.widget.AdapterView: boolean performItemClick(View,int,long)>",0,"{
    if (mOnItemClickListener != null) {
        playSoundEffect(SoundEffectConstants.CLICK);
        mOnItemClickListener.onItemClick(this, view, position, id);
        if (view != null) {
            view.sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);
        }
        return true;
    }
    return false;
}","{
    final boolean result;
    if (mOnItemClickListener != null) {
        playSoundEffect(SoundEffectConstants.CLICK);
        mOnItemClickListener.onItemClick(this, view, position, id);
        result = true;
    } else {
        result = false;
    }
    if (view != null) {
        view.sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);
    }
    return result;
}",1,"/**
 * Call the OnItemClickListener, if it is defined. Performs all normal
 * actions associated with clicking: reporting accessibility event, playing
 * a sound, etc.
 *
 * @param view The view within the AdapterView that was clicked.
 * @param position The position of the view in the adapter.
 * @param id The row id of the item that was clicked.
 * @return True if there was an assigned OnItemClickListener that was
 * called, false otherwise is returned.
 */
","/**
 * Call the OnItemClickListener, if it is defined. Performs all normal
 * actions associated with clicking: reporting accessibility event, playing
 * a sound, etc.
 *
 * @param view The view within the AdapterView that was clicked.
 * @param position The position of the view in the adapter.
 * @param id The row id of the item that was clicked.
 * @return True if there was an assigned OnItemClickListener that was
 * called, false otherwise is returned.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3, 4",0,"The control flow has been restructured by introducing a new variable `result` to store the return value until the return statement. Additionally, the call to `view.sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED)` is executed regardless of whether `mOnItemClickListener` is non-null, which is a change to the other statements outside of control flows (i.e., the statements inside the `if` block stay unchanged). These changes are a combination of control dependency change (3) and other statement change (4).","Although the implementation changes the sequence in which actions are taken and evaluates the click listener's result beforehand, the behavior observed by the API consumer, in terms of the return value and the executed side effects when invoking `performItemClick`, does not change. Therefore, there is no Compatibility Issue because the final outcome (`true` or `false`) remains unchanged, and the accessibility event is sent in both versions regardless of the listener's presence, which does not affect the method's contractual behavior."
736,"<android.widget.Editor.UndoInputFilter: CharSequence filter(CharSequence,int,int,Spanned,int,int)>",22,23,"<android.widget.Editor.UndoInputFilter: CharSequence filter(CharSequence,int,int,Spanned,int,int)>","<android.widget.Editor.UndoInputFilter: CharSequence filter(CharSequence,int,int,Spanned,int,int)>",0,"{
    if (DEBUG_UNDO) {
        Log.d(TAG, ""filter: source="" + source + "" ("" + start + ""-"" + end + "")"");
        Log.d(TAG, ""filter: dest="" + dest + "" ("" + dstart + ""-"" + dend + "")"");
    }
    final UndoManager um = mEditor.mUndoManager;
    if (um.isInUndo()) {
        if (DEBUG_UNDO)
            Log.d(TAG, ""*** skipping, currently performing undo/redo"");
        return null;
    }
    um.beginUpdate(""Edit text"");
    TextModifyOperation op = um.getLastOperation(TextModifyOperation.class, mEditor.mUndoOwner, UndoManager.MERGE_MODE_UNIQUE);
    if (op != null) {
        if (DEBUG_UNDO)
            Log.d(TAG, ""Last op: range=("" + op.mRangeStart + ""-"" + op.mRangeEnd + ""), oldText="" + op.mOldText);
        // See if we can continue modifying this operation.
        if (op.mOldText == null) {
            // completely replacing some or all of the last edit.
            if (start < end && ((dstart >= op.mRangeStart && dend <= op.mRangeEnd) || (dstart == op.mRangeEnd && dend == op.mRangeEnd))) {
                op.mRangeEnd = dstart + (end - start);
                um.endUpdate();
                if (DEBUG_UNDO)
                    Log.d(TAG, ""*** merging with last op, mRangeEnd="" + op.mRangeEnd);
                return null;
            }
        } else {
            // The current operation is a delete...  can we delete more?
            if (start == end && dend == op.mRangeStart - 1) {
                SpannableStringBuilder str;
                if (op.mOldText instanceof SpannableString) {
                    str = (SpannableStringBuilder) op.mOldText;
                } else {
                    str = new SpannableStringBuilder(op.mOldText);
                }
                str.insert(0, dest, dstart, dend);
                op.mRangeStart = dstart;
                op.mOldText = str;
                um.endUpdate();
                if (DEBUG_UNDO)
                    Log.d(TAG, ""*** merging with last op, range=("" + op.mRangeStart + ""-"" + op.mRangeEnd + ""), oldText="" + op.mOldText);
                return null;
            }
        }
        // Couldn't add to the current undo operation, need to start a new
        // undo state for a new undo operation.
        um.commitState(null);
        um.setUndoLabel(""Edit text"");
    }
    // Create a new undo state reflecting the operation being performed.
    op = new TextModifyOperation(mEditor.mUndoOwner);
    op.mRangeStart = dstart;
    if (start < end) {
        op.mRangeEnd = dstart + (end - start);
    } else {
        op.mRangeEnd = dstart;
    }
    if (dstart < dend) {
        op.mOldText = dest.subSequence(dstart, dend);
    }
    if (DEBUG_UNDO)
        Log.d(TAG, ""*** adding new op, range=("" + op.mRangeStart + ""-"" + op.mRangeEnd + ""), oldText="" + op.mOldText);
    um.addOperation(op, UndoManager.MERGE_MODE_NONE);
    um.endUpdate();
    return null;
}","{
    if (DEBUG_UNDO) {
        Log.d(TAG, ""filter: source="" + source + "" ("" + start + ""-"" + end + "") "" + ""dest="" + dest + "" ("" + dstart + ""-"" + dend + "")"");
    }
    // Check to see if this edit should be tracked for undo.
    if (!canUndoEdit(source, start, end, dest, dstart, dend)) {
        return null;
    }
    // Check for and handle IME composition edits.
    if (handleCompositionEdit(source, start, end, dstart)) {
        return null;
    }
    // Handle keyboard edits.
    handleKeyboardEdit(source, start, end, dest, dstart, dend);
    return null;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The change involves the removal of detailed undo operation implementation and replacement with high-level edit handling methods (canUndoEdit, handleCompositionEdit, handleKeyboardEdit), so the change types are 3,4.","While the implementation differs greatly between the two versions, there is no indication that the behavior in terms of the output has changed, as the final action in both versions is to return null. Since this method always returns null and there are no changes in the exceptions thrown, there's no Compatibility Issue."
737,<android.os.Environment: File getExternalStorageDirectory()>,22,23,<android.os.Environment: File getExternalStorageDirectory()>,<android.os.Environment: File getExternalStorageDirectory()>,0,"{
    throwIfUserRequired();
    return sCurrentUser.getExternalDirsForApp()[0];
}","{
    throwIfUserRequired();
    return sCurrentUser.getExternalDirs()[0];
}",1,"/**
 * Return the primary external storage directory. This directory may not
 * currently be accessible if it has been mounted by the user on their
 * computer, has been removed from the device, or some other problem has
 * happened. You can determine its current state with
 * {@link #getExternalStorageState()}.
 * <p>
 * <em>Note: don't be confused by the word ""external"" here. This directory
 * can better be thought as media/shared storage. It is a filesystem that
 * can hold a relatively large amount of data and that is shared across all
 * applications (does not enforce permissions). Traditionally this is an SD
 * card, but it may also be implemented as built-in storage in a device that
 * is distinct from the protected internal storage and can be mounted as a
 * filesystem on a computer.</em>
 * <p>
 * On devices with multiple users (as described by {@link UserManager}),
 * each user has their own isolated external storage. Applications only have
 * access to the external storage for the user they're running as.
 * <p>
 * In devices with multiple ""external"" storage directories, this directory
 * represents the ""primary"" external storage that the user will interact
 * with. Access to secondary storage is available through
 * <p>
 * Applications should not directly use this top-level directory, in order
 * to avoid polluting the user's root namespace. Any files that are private
 * to the application should be placed in a directory returned by
 * {@link android.content.Context#getExternalFilesDir
 * Context.getExternalFilesDir}, which the system will take care of deleting
 * if the application is uninstalled. Other shared files should be placed in
 * one of the directories returned by
 * {@link #getExternalStoragePublicDirectory}.
 * <p>
 * Writing to this path requires the
 * {@link android.Manifest.permission#WRITE_EXTERNAL_STORAGE} permission,
 * and starting in read access requires the
 * {@link android.Manifest.permission#READ_EXTERNAL_STORAGE} permission,
 * which is automatically granted if you hold the write permission.
 * <p>
 * Starting in {@link android.os.Build.VERSION_CODES#KITKAT}, if your
 * application only needs to store internal data, consider using
 * {@link Context#getExternalFilesDir(String)} or
 * {@link Context#getExternalCacheDir()}, which require no permissions to
 * read or write.
 * <p>
 * This path may change between platform versions, so applications should
 * only persist relative paths.
 * <p>
 * Here is an example of typical code to monitor the state of external
 * storage:
 * <p>
 * {@sample
 * development/samples/ApiDemos/src/com/example/android/apis/content/ExternalStorage.java
 * monitor_storage}
 *
 * @see #getExternalStorageState()
 * @see #isExternalStorageRemovable()
 */
","/**
 * Return the primary external storage directory. This directory may not
 * currently be accessible if it has been mounted by the user on their
 * computer, has been removed from the device, or some other problem has
 * happened. You can determine its current state with
 * {@link #getExternalStorageState()}.
 * <p>
 * <em>Note: don't be confused by the word ""external"" here. This directory
 * can better be thought as media/shared storage. It is a filesystem that
 * can hold a relatively large amount of data and that is shared across all
 * applications (does not enforce permissions). Traditionally this is an SD
 * card, but it may also be implemented as built-in storage in a device that
 * is distinct from the protected internal storage and can be mounted as a
 * filesystem on a computer.</em>
 * <p>
 * On devices with multiple users (as described by {@link UserManager}),
 * each user has their own isolated external storage. Applications only have
 * access to the external storage for the user they're running as.
 * <p>
 * In devices with multiple ""external"" storage directories, this directory
 * represents the ""primary"" external storage that the user will interact
 * with. Access to secondary storage is available through
 * <p>
 * Applications should not directly use this top-level directory, in order
 * to avoid polluting the user's root namespace. Any files that are private
 * to the application should be placed in a directory returned by
 * {@link android.content.Context#getExternalFilesDir
 * Context.getExternalFilesDir}, which the system will take care of deleting
 * if the application is uninstalled. Other shared files should be placed in
 * one of the directories returned by
 * {@link #getExternalStoragePublicDirectory}.
 * <p>
 * Writing to this path requires the
 * {@link android.Manifest.permission#WRITE_EXTERNAL_STORAGE} permission,
 * and starting in read access requires the
 * {@link android.Manifest.permission#READ_EXTERNAL_STORAGE} permission,
 * which is automatically granted if you hold the write permission.
 * <p>
 * Starting in {@link android.os.Build.VERSION_CODES#KITKAT}, if your
 * application only needs to store internal data, consider using
 * {@link Context#getExternalFilesDir(String)} or
 * {@link Context#getExternalCacheDir()}, which require no permissions to
 * read or write.
 * <p>
 * This path may change between platform versions, so applications should
 * only persist relative paths.
 * <p>
 * Here is an example of typical code to monitor the state of external
 * storage:
 * <p>
 * {@sample
 * development/samples/ApiDemos/src/com/example/android/apis/content/ExternalStorage.java
 * monitor_storage}
 *
 * @see #getExternalStorageState()
 * @see #isExternalStorageRemovable()
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",5,"The method called in the return statement has changed from getExternalDirsForApp() to getExternalDirs(), indicating a change in the dependent API, so the code change type is 1,5.","The dependent API used in the return statement has changed which means the returned File object could potentially be different if the behavior of getExternalDirs() is different from getExternalDirsForApp(). Thus, there is a Compatibility Issue caused by potential different return values or types, and the CI type is 5."
738,"<android.accounts.AccountManager: String getUserData(Account,String)>",22,23,"<android.accounts.AccountManager: String getUserData(Account,String)>","<android.accounts.AccountManager: String getUserData(Account,String)>",0,"{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    if (key == null)
        throw new IllegalArgumentException(""key is null"");
    try {
        return mService.getUserData(account, key);
    } catch (RemoteException e) {
        // will never happen
        throw new RuntimeException(e);
    }
}","{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    if (key == null)
        throw new IllegalArgumentException(""key is null"");
    try {
        return mService.getUserData(account, key);
    } catch (RemoteException e) {
        // won't ever happen
        throw new RuntimeException(e);
    }
}",1,"/**
 * Gets the user data named by ""key"" associated with the account.
 * This is intended for authenticators and related code to store
 * arbitrary metadata along with accounts.  The meaning of the keys
 * and values is up to the authenticator for the account.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#AUTHENTICATE_ACCOUNTS}
 * and to have the same UID as the account's authenticator.
 *
 * @param account The account to query for user data
 * @return The user data, null if the account or key doesn't exist
 */
","/**
 * Gets the user data named by ""key"" associated with the account.
 * This is intended for authenticators and related code to store
 * arbitrary metadata along with accounts.  The meaning of the keys
 * and values is up to the authenticator for the account.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>This method requires the caller to have a signature match with the
 * authenticator that owns the specified account.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * AUTHENTICATE_ACCOUNTS permission is needed for those platforms. See docs
 * for this function in API level 22.
 *
 * @param account The account to query for user data
 * @return The user data, null if the account or key doesn't exist
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"There is no functional change between the early and late versions of the code. The only difference is in a comment, which does not affect the execution of the code.","Since there are no changes in the functionality of the code, there is no Compatibility Issue."
739,"<android.app.admin.DevicePolicyManager: void setPasswordMinimumNonLetter(ComponentName,int)>",22,23,"<android.app.admin.DevicePolicyManager: void setPasswordMinimumNonLetter(ComponentName,int)>","<android.app.admin.DevicePolicyManager: void setPasswordMinimumNonLetter(ComponentName,int)>",0,"{
    if (mService != null) {
        try {
            mService.setPasswordMinimumNonLetter(admin, length, UserHandle.myUserId());
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    if (mService != null) {
        try {
            mService.setPasswordMinimumNonLetter(admin, length);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}",1,"/**
 * Called by an application that is administering the device to set the
 * minimum number of non-letter characters (numerical digits or symbols)
 * required in the password. After setting this, the user will not be able
 * to enter a new password that is not at least as restrictive as what has
 * been set. Note that the current password will remain until the user has
 * set a new one, so the change does not take place immediately. To prompt
 * the user for a new password, use {@link #ACTION_SET_NEW_PASSWORD} after
 * setting this value. This constraint is only imposed if the administrator
 * has also requested {@link #PASSWORD_QUALITY_COMPLEX} with
 * {@link #setPasswordQuality}. The default value is 0.
 * <p>
 * The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call
 * this method; if it has not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated
 * with.
 * @param length The new desired minimum number of letters required in the
 * password. A value of 0 means there is no restriction.
 */
","/**
 * Called by an application that is administering the device to set the
 * minimum number of non-letter characters (numerical digits or symbols)
 * required in the password. After setting this, the user will not be able
 * to enter a new password that is not at least as restrictive as what has
 * been set. Note that the current password will remain until the user has
 * set a new one, so the change does not take place immediately. To prompt
 * the user for a new password, use {@link #ACTION_SET_NEW_PASSWORD} after
 * setting this value. This constraint is only imposed if the administrator
 * has also requested {@link #PASSWORD_QUALITY_COMPLEX} with
 * {@link #setPasswordQuality}. The default value is 0.
 * <p>
 * The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call
 * this method; if it has not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated
 * with.
 * @param length The new desired minimum number of letters required in the
 * password. A value of 0 means there is no restriction.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method `setPasswordMinimumNonLetter` in the late implementation no longer takes the third parameter `UserHandle.myUserId()`. This indicates a change in the dependent API used within the method, so the code change is classified as type 4 and 5.","Even though the method signature for `setPasswordMinimumNonLetter` is changed in the service being called, there is no direct change in the behavior of the `setPasswordMinimumNonLetter` method itself from the perspective of the clients using the DevicePolicyManager API. The exception handling and return behavior are unchanged. Therefore, there is no compatibility issue in terms of changing behavior from the client's standpoint; hence, the CI type is 0."
741,<android.content.res.TypedArray: CharSequence getText(int)>,22,23,<android.content.res.TypedArray: CharSequence getText(int)>,<android.content.res.TypedArray: CharSequence getText(int)>,0,"{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return null;
    } else if (type == TypedValue.TYPE_STRING) {
        return loadStringValueAt(index);
    }
    TypedValue v = mValue;
    if (getValueAt(index, v)) {
        Log.w(Resources.TAG, ""Converting to string: "" + v);
        return v.coerceToString();
    }
    Log.w(Resources.TAG, ""getString of bad type: 0x"" + Integer.toHexString(type));
    return null;
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return null;
    } else if (type == TypedValue.TYPE_STRING) {
        return loadStringValueAt(index);
    }
    final TypedValue v = mValue;
    if (getValueAt(index, v)) {
        return v.coerceToString();
    }
    // We already checked for TYPE_NULL. This should never happen.
    throw new RuntimeException(""getText of bad type: 0x"" + Integer.toHexString(type));
}",1,"/**
 * Retrieve the styled string value for the attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return CharSequence holding string data.  May be styled.  Returns
 * null if the attribute is not defined.
 */
","/**
 * Retrieves the styled string value for the attribute at <var>index</var>.
 * <p>
 * If the attribute is not a string, this method will attempt to coerce
 * it to a string.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return CharSequence holding string data. May be styled. Returns
 * {@code null} if the attribute is not defined or could not be
 * coerced to a string.
 * @throws RuntimeException if the TypedArray has already been recycled.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"The early version of the method included Log warnings for unexpected type situations and returned null, while the late version has replaced this behavior with a RuntimeException for the same issues, which is a change in exception handling statement and classified as type 2, 4 (Other statement changed).","Previously, when the method encountered a bad type that was neither NULL nor STRING, it generated a warning and returned null. In the updated version, encountering a bad type now results in the throwing of a RuntimeException. This is an exception handling change that leads to potential different exception handlings and is classified as CI type 2."
743,<android.widget.ActivityChooserModel.PersistHistoryAsyncTask: Void doInBackground(Object)>,22,23,<android.widget.ActivityChooserModel.PersistHistoryAsyncTask: Void doInBackground(Object)>,<android.widget.ActivityChooserModel.PersistHistoryAsyncTask: Void doInBackground(Object)>,0,"{
    List<HistoricalRecord> historicalRecords = (List<HistoricalRecord>) args[0];
    String hostoryFileName = (String) args[1];
    FileOutputStream fos = null;
    try {
        fos = mContext.openFileOutput(hostoryFileName, Context.MODE_PRIVATE);
    } catch (FileNotFoundException fnfe) {
        Log.e(LOG_TAG, ""Error writing historical recrod file: "" + hostoryFileName, fnfe);
        return null;
    }
    XmlSerializer serializer = Xml.newSerializer();
    try {
        serializer.setOutput(fos, null);
        serializer.startDocument(""UTF-8"", true);
        serializer.startTag(null, TAG_HISTORICAL_RECORDS);
        final int recordCount = historicalRecords.size();
        for (int i = 0; i < recordCount; i++) {
            HistoricalRecord record = historicalRecords.remove(0);
            serializer.startTag(null, TAG_HISTORICAL_RECORD);
            serializer.attribute(null, ATTRIBUTE_ACTIVITY, record.activity.flattenToString());
            serializer.attribute(null, ATTRIBUTE_TIME, String.valueOf(record.time));
            serializer.attribute(null, ATTRIBUTE_WEIGHT, String.valueOf(record.weight));
            serializer.endTag(null, TAG_HISTORICAL_RECORD);
            if (DEBUG) {
                Log.i(LOG_TAG, ""Wrote "" + record.toString());
            }
        }
        serializer.endTag(null, TAG_HISTORICAL_RECORDS);
        serializer.endDocument();
        if (DEBUG) {
            Log.i(LOG_TAG, ""Wrote "" + recordCount + "" historical records."");
        }
    } catch (IllegalArgumentException iae) {
        Log.e(LOG_TAG, ""Error writing historical recrod file: "" + mHistoryFileName, iae);
    } catch (IllegalStateException ise) {
        Log.e(LOG_TAG, ""Error writing historical recrod file: "" + mHistoryFileName, ise);
    } catch (IOException ioe) {
        Log.e(LOG_TAG, ""Error writing historical recrod file: "" + mHistoryFileName, ioe);
    } finally {
        mCanReadHistoricalData = true;
        if (fos != null) {
            try {
                fos.close();
            } catch (IOException e) {
            /* ignore */
            }
        }
    }
    return null;
}","{
    List<HistoricalRecord> historicalRecords = (List<HistoricalRecord>) args[0];
    String hostoryFileName = (String) args[1];
    FileOutputStream fos = null;
    try {
        fos = mContext.openFileOutput(hostoryFileName, Context.MODE_PRIVATE);
    } catch (FileNotFoundException fnfe) {
        Log.e(LOG_TAG, ""Error writing historical recrod file: "" + hostoryFileName, fnfe);
        return null;
    }
    XmlSerializer serializer = Xml.newSerializer();
    try {
        serializer.setOutput(fos, null);
        serializer.startDocument(StandardCharsets.UTF_8.name(), true);
        serializer.startTag(null, TAG_HISTORICAL_RECORDS);
        final int recordCount = historicalRecords.size();
        for (int i = 0; i < recordCount; i++) {
            HistoricalRecord record = historicalRecords.remove(0);
            serializer.startTag(null, TAG_HISTORICAL_RECORD);
            serializer.attribute(null, ATTRIBUTE_ACTIVITY, record.activity.flattenToString());
            serializer.attribute(null, ATTRIBUTE_TIME, String.valueOf(record.time));
            serializer.attribute(null, ATTRIBUTE_WEIGHT, String.valueOf(record.weight));
            serializer.endTag(null, TAG_HISTORICAL_RECORD);
            if (DEBUG) {
                Log.i(LOG_TAG, ""Wrote "" + record.toString());
            }
        }
        serializer.endTag(null, TAG_HISTORICAL_RECORDS);
        serializer.endDocument();
        if (DEBUG) {
            Log.i(LOG_TAG, ""Wrote "" + recordCount + "" historical records."");
        }
    } catch (IllegalArgumentException iae) {
        Log.e(LOG_TAG, ""Error writing historical recrod file: "" + mHistoryFileName, iae);
    } catch (IllegalStateException ise) {
        Log.e(LOG_TAG, ""Error writing historical recrod file: "" + mHistoryFileName, ise);
    } catch (IOException ioe) {
        Log.e(LOG_TAG, ""Error writing historical recrod file: "" + mHistoryFileName, ioe);
    } finally {
        mCanReadHistoricalData = true;
        if (fos != null) {
            try {
                fos.close();
            } catch (IOException e) {
            /* ignore */
            }
        }
    }
    return null;
}",1,,,-1,"[@Override, @SuppressWarnings(""unchecked"")]","[@Override, @SuppressWarnings(""unchecked"")]",-1,-1,-1,-1,-1,-1,4,0,"The code has changed the parameter in the `startDocument` method call from ""UTF-8"" to `StandardCharsets.UTF_8.name()`, so the change type is ""Other statement changed"" or 4. ","The actual value used as the encoding in `startDocument` remains ""UTF-8"", just the way of expressing it has changed (from a string literal to the equivalent call to `StandardCharsets.UTF_8.name()`). This does not affect the API's behavior; thus, we can classify the change as ""No Compatibility Issue"" or 0."
745,"<android.hardware.camera2.params.StreamConfigurationMap: long getOutputStallDuration(int,Size)>",22,23,"<android.hardware.camera2.params.StreamConfigurationMap: long getOutputStallDuration(int,Size)>","<android.hardware.camera2.params.StreamConfigurationMap: long getOutputStallDuration(int,Size)>",0,"{
    checkArgumentFormatSupported(format, /*output*/
    true);
    return getInternalFormatDuration(imageFormatToInternal(format), size, DURATION_STALL);
}","{
    checkArgumentFormatSupported(format, /*output*/
    true);
    return getInternalFormatDuration(imageFormatToInternal(format), imageFormatToDataspace(format), size, DURATION_STALL);
}",1,"/**
 * Get the stall duration for the format/size combination (in nanoseconds).
 *
 * <p>{@code format} should be one of the ones returned by {@link #getOutputFormats()}.</p>
 * <p>{@code size} should be one of the ones returned by
 * {@link #getOutputSizes(int)}.</p>
 *
 * <p>
 * A stall duration is how much extra time would get added to the normal minimum frame duration
 * for a repeating request that has streams with non-zero stall.
 *
 * <p>For example, consider JPEG captures which have the following characteristics:
 *
 * <ul>
 * <li>JPEG streams act like processed YUV streams in requests for which they are not included;
 * in requests in which they are directly referenced, they act as JPEG streams.
 * This is because supporting a JPEG stream requires the underlying YUV data to always be ready
 * for use by a JPEG encoder, but the encoder will only be used (and impact frame duration) on
 * requests that actually reference a JPEG stream.
 * <li>The JPEG processor can run concurrently to the rest of the camera pipeline, but cannot
 * process more than 1 capture at a time.
 * </ul>
 *
 * <p>In other words, using a repeating YUV request would result in a steady frame rate
 * (let's say it's 30 FPS). If a single JPEG request is submitted periodically,
 * the frame rate will stay at 30 FPS (as long as we wait for the previous JPEG to return each
 * time). If we try to submit a repeating YUV + JPEG request, then the frame rate will drop from
 * 30 FPS.</p>
 *
 * <p>In general, submitting a new request with a non-0 stall time stream will <em>not</em> cause a
 * frame rate drop unless there are still outstanding buffers for that stream from previous
 * requests.</p>
 *
 * <p>Submitting a repeating request with streams (call this {@code S}) is the same as setting
 * the minimum frame duration from the normal minimum frame duration corresponding to {@code S},
 * added with the maximum stall duration for {@code S}.</p>
 *
 * <p>If interleaving requests with and without a stall duration, a request will stall by the
 * maximum of the remaining times for each can-stall stream with outstanding buffers.</p>
 *
 * <p>This means that a stalling request will not have an exposure start until the stall has
 * completed.</p>
 *
 * <p>This should correspond to the stall duration when only that stream is active, with all
 * processing (typically in {@code android.*.mode}) set to {@code FAST} or {@code OFF}.
 * Setting any of the processing modes to {@code HIGH_QUALITY} effectively results in an
 * indeterminate stall duration for all streams in a request (the regular stall calculation
 * rules are ignored).</p>
 *
 * <p>The following formats may always have a stall duration:
 * <ul>
 * <li>{@link ImageFormat#JPEG JPEG}
 * <li>{@link ImageFormat#RAW_SENSOR RAW16}
 * </ul>
 * </p>
 *
 * <p>The following formats will never have a stall duration:
 * <ul>
 * <li>{@link ImageFormat#YUV_420_888 YUV_420_888}
 * <li>{@link #isOutputSupportedFor(Class) Implementation-Defined}
 * </ul></p>
 *
 * <p>
 * All other formats may or may not have an allowed stall duration on a per-capability basis;
 * refer to {@link CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES
 * android.request.availableCapabilities} for more details.</p>
 * </p>
 *
 * <p>See {@link CaptureRequest#SENSOR_FRAME_DURATION android.sensor.frameDuration}
 * for more information about calculating the max frame rate (absent stalls).</p>
 *
 * @param format an image format from {@link ImageFormat} or {@link PixelFormat}
 * @param size an output-compatible size
 * @return a stall duration {@code >=} 0 in nanoseconds
 *
 * @throws IllegalArgumentException if {@code format} or {@code size} was not supported
 * @throws NullPointerException if {@code size} was {@code null}
 *
 * @see CaptureRequest#SENSOR_FRAME_DURATION
 * @see ImageFormat
 * @see PixelFormat
 */
","/**
 * Get the stall duration for the format/size combination (in nanoseconds).
 *
 * <p>{@code format} should be one of the ones returned by {@link #getOutputFormats()}.</p>
 * <p>{@code size} should be one of the ones returned by
 * {@link #getOutputSizes(int)}.</p>
 *
 * <p>
 * A stall duration is how much extra time would get added to the normal minimum frame duration
 * for a repeating request that has streams with non-zero stall.
 *
 * <p>For example, consider JPEG captures which have the following characteristics:
 *
 * <ul>
 * <li>JPEG streams act like processed YUV streams in requests for which they are not included;
 * in requests in which they are directly referenced, they act as JPEG streams.
 * This is because supporting a JPEG stream requires the underlying YUV data to always be ready
 * for use by a JPEG encoder, but the encoder will only be used (and impact frame duration) on
 * requests that actually reference a JPEG stream.
 * <li>The JPEG processor can run concurrently to the rest of the camera pipeline, but cannot
 * process more than 1 capture at a time.
 * </ul>
 *
 * <p>In other words, using a repeating YUV request would result in a steady frame rate
 * (let's say it's 30 FPS). If a single JPEG request is submitted periodically,
 * the frame rate will stay at 30 FPS (as long as we wait for the previous JPEG to return each
 * time). If we try to submit a repeating YUV + JPEG request, then the frame rate will drop from
 * 30 FPS.</p>
 *
 * <p>In general, submitting a new request with a non-0 stall time stream will <em>not</em> cause a
 * frame rate drop unless there are still outstanding buffers for that stream from previous
 * requests.</p>
 *
 * <p>Submitting a repeating request with streams (call this {@code S}) is the same as setting
 * the minimum frame duration from the normal minimum frame duration corresponding to {@code S},
 * added with the maximum stall duration for {@code S}.</p>
 *
 * <p>If interleaving requests with and without a stall duration, a request will stall by the
 * maximum of the remaining times for each can-stall stream with outstanding buffers.</p>
 *
 * <p>This means that a stalling request will not have an exposure start until the stall has
 * completed.</p>
 *
 * <p>This should correspond to the stall duration when only that stream is active, with all
 * processing (typically in {@code android.*.mode}) set to {@code FAST} or {@code OFF}.
 * Setting any of the processing modes to {@code HIGH_QUALITY} effectively results in an
 * indeterminate stall duration for all streams in a request (the regular stall calculation
 * rules are ignored).</p>
 *
 * <p>The following formats may always have a stall duration:
 * <ul>
 * <li>{@link ImageFormat#JPEG JPEG}
 * <li>{@link ImageFormat#RAW_SENSOR RAW16}
 * </ul>
 * </p>
 *
 * <p>The following formats will never have a stall duration:
 * <ul>
 * <li>{@link ImageFormat#YUV_420_888 YUV_420_888}
 * <li>{@link #isOutputSupportedFor(Class) Implementation-Defined}
 * </ul></p>
 *
 * <p>
 * All other formats may or may not have an allowed stall duration on a per-capability basis;
 * refer to {@link CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES
 * android.request.availableCapabilities} for more details.</p>
 * </p>
 *
 * <p>See {@link CaptureRequest#SENSOR_FRAME_DURATION android.sensor.frameDuration}
 * for more information about calculating the max frame rate (absent stalls).</p>
 *
 * @param format an image format from {@link ImageFormat} or {@link PixelFormat}
 * @param size an output-compatible size
 * @return a stall duration {@code >=} 0 in nanoseconds
 *
 * @throws IllegalArgumentException if {@code format} or {@code size} was not supported
 * @throws NullPointerException if {@code size} was {@code null}
 *
 * @see CaptureRequest#SENSOR_FRAME_DURATION
 * @see ImageFormat
 * @see PixelFormat
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The method call to getInternalFormatDuration() has been modified with an additional parameter (imageFormatToDataspace(format)), indicating a change in the dependent API. The change type is 4,5.","The additional parameter in the method call potentially alters the return value of the API, because the behavior of getInternalFormatDuration() could change with different inputs. Thus, a CI may arise due to the possibility of different return values, and the CI type is 1."
750,<android.hardware.camera2.params.StreamConfigurationMap: int imageFormatToInternal(int)>,22,23,<android.hardware.camera2.params.StreamConfigurationMap: int imageFormatToInternal(int)>,<android.hardware.camera2.params.StreamConfigurationMap: int imageFormatToInternal(int)>,0,"{
    switch(format) {
        case ImageFormat.JPEG:
            return HAL_PIXEL_FORMAT_BLOB;
        case HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED:
            throw new IllegalArgumentException(""IMPLEMENTATION_DEFINED is not allowed via public API"");
        default:
            return format;
    }
}","{
    switch(format) {
        case ImageFormat.JPEG:
        case ImageFormat.DEPTH_POINT_CLOUD:
            return HAL_PIXEL_FORMAT_BLOB;
        case ImageFormat.DEPTH16:
            return HAL_PIXEL_FORMAT_Y16;
        default:
            return format;
    }
}",1,"/**
 * Convert a public format compatible with {@code ImageFormat} to an internal format
 * from {@code graphics.h}.
 *
 * <p>In particular these formats are converted:
 * <ul>
 * <li>ImageFormat.JPEG => HAL_PIXEL_FORMAT_BLOB
 * </ul>
 * </p>
 *
 * <p>Passing in an implementation-defined format here will fail (it's not a public format);
 * as will passing in an internal format which has a different public format equivalent.
 * See {@link #checkArgumentFormat} for more details about a legal public format.</p>
 *
 * <p>All other formats are returned as-is, no invalid check is performed.</p>
 *
 * <p>This function is the dual of {@link #imageFormatToPublic}.</p>
 *
 * @param format public image format from {@link ImageFormat} or {@link PixelFormat}
 * @return the converted image formats
 *
 * @see ImageFormat
 * @see PixelFormat
 *
 * @throws IllegalArgumentException
 * if {@code format} was {@code HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED}
 */
","/**
 * Convert a public format compatible with {@code ImageFormat} to an internal format
 * from {@code graphics.h}.
 *
 * <p>In particular these formats are converted:
 * <ul>
 * <li>ImageFormat.JPEG => HAL_PIXEL_FORMAT_BLOB
 * <li>ImageFormat.DEPTH_POINT_CLOUD => HAL_PIXEL_FORMAT_BLOB
 * <li>ImageFormat.DEPTH16 => HAL_PIXEL_FORMAT_Y16
 * </ul>
 * </p>
 *
 * <p>Passing in an internal format which has a different public format equivalent will fail.
 * See {@link #checkArgumentFormat} for more details about a legal public format.</p>
 *
 * <p>All other formats are returned as-is, no invalid check is performed.</p>
 *
 * <p>This function is the dual of {@link #imageFormatToPublic}.</p>
 *
 * @param format public image format from {@link ImageFormat} or {@link PixelFormat}
 * @return the converted image formats
 *
 * @see ImageFormat
 * @see PixelFormat
 *
 * @throws IllegalArgumentException
 * if {@code format} was {@code HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The switch statement has been modified with additional cases for ImageFormat.DEPTH_POINT_CLOUD and ImageFormat.DEPTH16, which affects control dependency(changes under control statements). Also, the return value has changed for these cases, constituting a change in the return statement as well. Thus, the code change types are 1 and 3.","The addition of new case statements for ImageFormat.DEPTH_POINT_CLOUD and ImageFormat.DEPTH16 changes the return values for these formats. Therefore, since the API can return different values for the same input in the two versions, this leads to a potential Compatibility Issue. The CI type is 1 due to different potential return values."
751,<android.widget.TabHost.LabelIndicatorStrategy: View createIndicatorView()>,22,23,<android.widget.TabHost.LabelIndicatorStrategy: View createIndicatorView()>,<android.widget.TabHost.LabelIndicatorStrategy: View createIndicatorView()>,0,"{
    final Context context = getContext();
    LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    View tabIndicator = inflater.inflate(mTabLayoutId, // tab widget is the parent
    mTabWidget, // no inflate params
    false);
    final TextView tv = (TextView) tabIndicator.findViewById(R.id.title);
    tv.setText(mLabel);
    if (context.getApplicationInfo().targetSdkVersion <= Build.VERSION_CODES.DONUT) {
        // Donut apps get old color scheme
        tabIndicator.setBackgroundResource(R.drawable.tab_indicator_v4);
        tv.setTextColor(context.getResources().getColorStateList(R.color.tab_indicator_text_v4));
    }
    return tabIndicator;
}","{
    final Context context = getContext();
    LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    View tabIndicator = inflater.inflate(mTabLayoutId, // tab widget is the parent
    mTabWidget, // no inflate params
    false);
    final TextView tv = (TextView) tabIndicator.findViewById(R.id.title);
    tv.setText(mLabel);
    if (context.getApplicationInfo().targetSdkVersion <= Build.VERSION_CODES.DONUT) {
        // Donut apps get old color scheme
        tabIndicator.setBackgroundResource(R.drawable.tab_indicator_v4);
        tv.setTextColor(context.getColorStateList(R.color.tab_indicator_text_v4));
    }
    return tabIndicator;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The change is related to how the color state list is retrieved: from using `getResources().getColorStateList()` in the early version to using `context.getColorStateList()` in the late version. While the result of this change would affect the appearance of the TextView (tv.setTextColor), it's internal to the method and doesn't modify the method signature or return type. Thus, the code change is in category 4 (Other statement changed) and 5 (Dependent API changed).","There is no Compatibility Issue here as the TextView's color state is set internally within the method, and the return type and value (`tabIndicator`) remain unchanged. This means that, from the perspective of the API user, the method behaves the same way and returns the View as expected, making the change backward compatible. Hence, the CI type is 0 (No Compatibility Issue)."
753,"<android.content.ContentResolver: Bundle call(Uri,String,String,Bundle)>",22,23,"<android.content.ContentResolver: Bundle call(Uri,String,String,Bundle)>","<android.content.ContentResolver: Bundle call(Uri,String,String,Bundle)>",0,"{
    if (uri == null) {
        throw new NullPointerException(""uri == null"");
    }
    if (method == null) {
        throw new NullPointerException(""method == null"");
    }
    IContentProvider provider = acquireProvider(uri);
    if (provider == null) {
        throw new IllegalArgumentException(""Unknown URI "" + uri);
    }
    try {
        return provider.call(mPackageName, method, arg, extras);
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        releaseProvider(provider);
    }
}","{
    Preconditions.checkNotNull(uri, ""uri"");
    Preconditions.checkNotNull(method, ""method"");
    IContentProvider provider = acquireProvider(uri);
    if (provider == null) {
        throw new IllegalArgumentException(""Unknown URI "" + uri);
    }
    try {
        return provider.call(mPackageName, method, arg, extras);
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        releaseProvider(provider);
    }
}",1,"/**
 * Call a provider-defined method.  This can be used to implement
 * read or write interfaces which are cheaper than using a Cursor and/or
 * do not fit into the traditional table model.
 *
 * @param method provider-defined method name to call.  Opaque to
 * framework, but must be non-null.
 * @param arg provider-defined String argument.  May be null.
 * @param extras provider-defined Bundle argument.  May be null.
 * @return a result Bundle, possibly null.  Will be null if the ContentProvider
 * does not implement call.
 * @throws NullPointerException if uri or method is null
 * @throws IllegalArgumentException if uri is not known
 */
","/**
 * Call a provider-defined method.  This can be used to implement
 * read or write interfaces which are cheaper than using a Cursor and/or
 * do not fit into the traditional table model.
 *
 * @param method provider-defined method name to call.  Opaque to
 * framework, but must be non-null.
 * @param arg provider-defined String argument.  May be null.
 * @param extras provider-defined Bundle argument.  May be null.
 * @return a result Bundle, possibly null.  Will be null if the ContentProvider
 * does not implement call.
 * @throws NullPointerException if uri or method is null
 * @throws IllegalArgumentException if uri is not known
 */
",-1,,[@Nullable],-1,-1,-1,-1,-1,-1,4,0,"There are changes from direct null checks and throwing NullPointerException to using Preconditions.checkNotNull() method calls for argument validation, so the code change type is 4.","There is no Compatibility Issue as the Preconditions.checkNotNull() will throw the same exception as the original null checks if the inputs are null. The behavior of the method remains the same, hence there are no potential different return values or exception handlings that would cause a CI."
754,<android.os.StrictMode: void readAndHandleBinderCallViolations(Parcel)>,22,23,<android.os.StrictMode: void readAndHandleBinderCallViolations(Parcel)>,<android.os.StrictMode: void readAndHandleBinderCallViolations(Parcel)>,0,"{
    // Our own stack trace to append
    StringWriter sw = new StringWriter();
    PrintWriter pw = new FastPrintWriter(sw, false, 256);
    new LogStackTrace().printStackTrace(pw);
    pw.flush();
    String ourStack = sw.toString();
    int policyMask = getThreadPolicyMask();
    boolean currentlyGathering = (policyMask & PENALTY_GATHER) != 0;
    int numViolations = p.readInt();
    for (int i = 0; i < numViolations; ++i) {
        if (LOG_V)
            Log.d(TAG, ""strict mode violation stacks read from binder call.  i="" + i);
        ViolationInfo info = new ViolationInfo(p, !currentlyGathering);
        if (info.crashInfo.stackTrace != null && info.crashInfo.stackTrace.length() > 10000) {
            String front = info.crashInfo.stackTrace.substring(256);
            // First, drain the remaining violations from the parcel.
            while (i < numViolations) {
                info = new ViolationInfo(p, !currentlyGathering);
                i++;
            }
            // Next clear out all gathered violations.
            clearGatheredViolations();
            // Now report the problem.
            Slog.wtfStack(TAG, ""Stack is too large: numViolations="" + numViolations + "" policy=#"" + Integer.toHexString(policyMask) + "" front="" + front);
            return;
        }
        info.crashInfo.stackTrace += ""# via Binder call with stack:\n"" + ourStack;
        BlockGuard.Policy policy = BlockGuard.getThreadPolicy();
        if (policy instanceof AndroidBlockGuardPolicy) {
            ((AndroidBlockGuardPolicy) policy).handleViolationWithTimingAttempt(info);
        }
    }
}","{
    // Our own stack trace to append
    StringWriter sw = new StringWriter();
    PrintWriter pw = new FastPrintWriter(sw, false, 256);
    new LogStackTrace().printStackTrace(pw);
    pw.flush();
    String ourStack = sw.toString();
    int policyMask = getThreadPolicyMask();
    boolean currentlyGathering = (policyMask & PENALTY_GATHER) != 0;
    int numViolations = p.readInt();
    for (int i = 0; i < numViolations; ++i) {
        if (LOG_V)
            Log.d(TAG, ""strict mode violation stacks read from binder call.  i="" + i);
        ViolationInfo info = new ViolationInfo(p, !currentlyGathering);
        if (info.crashInfo.stackTrace != null && info.crashInfo.stackTrace.length() > 30000) {
            String front = info.crashInfo.stackTrace.substring(256);
            // First, drain the remaining violations from the parcel.
            while (i < numViolations) {
                info = new ViolationInfo(p, !currentlyGathering);
                i++;
            }
            // Next clear out all gathered violations.
            clearGatheredViolations();
            // Now report the problem.
            Slog.wtfStack(TAG, ""Stack is too large: numViolations="" + numViolations + "" policy=#"" + Integer.toHexString(policyMask) + "" front="" + front);
            return;
        }
        info.crashInfo.stackTrace += ""# via Binder call with stack:\n"" + ourStack;
        BlockGuard.Policy policy = BlockGuard.getThreadPolicy();
        if (policy instanceof AndroidBlockGuardPolicy) {
            ((AndroidBlockGuardPolicy) policy).handleViolationWithTimingAttempt(info);
        }
    }
}",1,"/* package */
","/* package */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change in the code is the threshold value from `10000` to `30000` in the if condition checking the stack trace length. This is classified as an ""Other statement changed"", which is 4.","This change in threshold doesn't lead to a different behavior in terms of API contract, as it merely changes an internal detail about when a stack trace is considered too large. It does not affect the return value type or an exception that the method may throw. Thus, there are no Compatibility Issues based on the given information, so it's 0."
755,<android.database.DatabaseUtils: String getHexCollationKey(String)>,22,23,<android.database.DatabaseUtils: String getHexCollationKey(String)>,<android.database.DatabaseUtils: String getHexCollationKey(String)>,0,"{
    byte[] arr = getCollationKeyInBytes(name);
    char[] keys = Hex.encodeHex(arr);
    return new String(keys, 0, getKeyLen(arr) * 2);
}","{
    byte[] arr = getCollationKeyInBytes(name);
    char[] keys = encodeHex(arr);
    return new String(keys, 0, getKeyLen(arr) * 2);
}",1,"/**
 * return the collation key in hex format
 * @param name
 * @return the collation key in hex format
 */
","/**
 * return the collation key in hex format
 * @param name
 * @return the collation key in hex format
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation changed from Hex.encodeHex(arr) to encodeHex(arr), which appears to be a method call change but likely refers to an internal method or static import change. Since there is no clear evidence that a different method is actually being called (it could be a refactoring to use a static import rather than specifying the class Hex), this is considered an Other statement changed. Additionally, it's also classified as Dependent API changed because the encodeHex method might belong to a different class or context in the late version.","No Compatibility Issue should arise because the return type and value remain unchanged as long as the encodeHex method returns the same result in both versions. We cannot deduce from the given information that the behavior of encodeHex has changed, hence by default, it is assumed not to introduce a compatibility issue."
757,<android.content.res.TypedArray: String getString(int)>,22,23,<android.content.res.TypedArray: String getString(int)>,<android.content.res.TypedArray: String getString(int)>,0,"{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return null;
    } else if (type == TypedValue.TYPE_STRING) {
        return loadStringValueAt(index).toString();
    }
    TypedValue v = mValue;
    if (getValueAt(index, v)) {
        Log.w(Resources.TAG, ""Converting to string: "" + v);
        CharSequence cs = v.coerceToString();
        return cs != null ? cs.toString() : null;
    }
    Log.w(Resources.TAG, ""getString of bad type: 0x"" + Integer.toHexString(type));
    return null;
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return null;
    } else if (type == TypedValue.TYPE_STRING) {
        return loadStringValueAt(index).toString();
    }
    final TypedValue v = mValue;
    if (getValueAt(index, v)) {
        final CharSequence cs = v.coerceToString();
        return cs != null ? cs.toString() : null;
    }
    // We already checked for TYPE_NULL. This should never happen.
    throw new RuntimeException(""getString of bad type: 0x"" + Integer.toHexString(type));
}",1,"/**
 * Retrieve the string value for the attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return String holding string data.  Any styling information is
 * removed.  Returns null if the attribute is not defined.
 */
","/**
 * Retrieves the string value for the attribute at <var>index</var>.
 * <p>
 * If the attribute is not a string, this method will attempt to coerce
 * it to a string.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return String holding string data. Any styling information is removed.
 * Returns {@code null} if the attribute is not defined or could
 * not be coerced to a string.
 * @throws RuntimeException if the TypedArray has already been recycled.
 */
",-1,,[@Nullable],-1,-1,-1,-1,-1,-1,"2,4",2,"An exception handling statement has been changed; a logging statement has been replaced by a throw statement which changes the method's exception behavior. The 'final' modifier has also been added to variables 'v' and 'cs' inside the method body, which is an 'Other statement changed', so the change type is 2,4.","The method in the late version will throw a RuntimeException where it would have previously just logged a warning and returned null. This is a significant change in behavior that can potentially cause a Compatibility Issue due to different exception handling, so the CI type is 2."
758,"<android.os.ParcelFileDescriptor: ParcelFileDescriptor open(File,int,Handler,OnCloseListener)>",22,23,"<android.os.ParcelFileDescriptor: ParcelFileDescriptor open(File,int,Handler,OnCloseListener)>","<android.os.ParcelFileDescriptor: ParcelFileDescriptor open(File,int,Handler,OnCloseListener)>",0,"{
    if (handler == null) {
        throw new IllegalArgumentException(""Handler must not be null"");
    }
    if (listener == null) {
        throw new IllegalArgumentException(""Listener must not be null"");
    }
    final FileDescriptor fd = openInternal(file, mode);
    if (fd == null)
        return null;
    final FileDescriptor[] comm = createCommSocketPair();
    final ParcelFileDescriptor pfd = new ParcelFileDescriptor(fd, comm[0]);
    // Kick off thread to watch for status updates
    IoUtils.setBlocking(comm[1], true);
    final ListenerBridge bridge = new ListenerBridge(comm[1], handler.getLooper(), listener);
    bridge.start();
    return pfd;
}","{
    if (handler == null) {
        throw new IllegalArgumentException(""Handler must not be null"");
    }
    if (listener == null) {
        throw new IllegalArgumentException(""Listener must not be null"");
    }
    final FileDescriptor fd = openInternal(file, mode);
    if (fd == null)
        return null;
    final FileDescriptor[] comm = createCommSocketPair();
    final ParcelFileDescriptor pfd = new ParcelFileDescriptor(fd, comm[0]);
    final MessageQueue queue = handler.getLooper().getQueue();
    queue.addOnFileDescriptorEventListener(comm[1], OnFileDescriptorEventListener.EVENT_INPUT, new OnFileDescriptorEventListener() {

        @Override
        public int onFileDescriptorEvents(FileDescriptor fd, int events) {
            Status status = null;
            if ((events & OnFileDescriptorEventListener.EVENT_INPUT) != 0) {
                final byte[] buf = new byte[MAX_STATUS];
                status = readCommStatus(fd, buf);
            } else if ((events & OnFileDescriptorEventListener.EVENT_ERROR) != 0) {
                status = new Status(Status.DEAD);
            }
            if (status != null) {
                queue.removeOnFileDescriptorEventListener(fd);
                IoUtils.closeQuietly(fd);
                listener.onClose(status.asIOException());
                return 0;
            }
            return EVENT_INPUT;
        }
    });
    return pfd;
}",1,"/**
 * Create a new ParcelFileDescriptor accessing a given file.
 *
 * @param file The file to be opened.
 * @param mode The desired access mode, must be one of
 * {@link #MODE_READ_ONLY}, {@link #MODE_WRITE_ONLY}, or
 * {@link #MODE_READ_WRITE}; may also be any combination of
 * {@link #MODE_CREATE}, {@link #MODE_TRUNCATE},
 * {@link #MODE_WORLD_READABLE}, and
 * {@link #MODE_WORLD_WRITEABLE}.
 * @param handler to call listener from; must not be null.
 * @param listener to be invoked when the returned descriptor has been
 * closed; must not be null.
 * @return a new ParcelFileDescriptor pointing to the given file.
 * @throws FileNotFoundException if the given file does not exist or can not
 * be opened with the requested mode.
 * @see #parseMode(String)
 */
","/**
 * Create a new ParcelFileDescriptor accessing a given file.
 *
 * @param file The file to be opened.
 * @param mode The desired access mode, must be one of
 * {@link #MODE_READ_ONLY}, {@link #MODE_WRITE_ONLY}, or
 * {@link #MODE_READ_WRITE}; may also be any combination of
 * {@link #MODE_CREATE}, {@link #MODE_TRUNCATE},
 * {@link #MODE_WORLD_READABLE}, and
 * {@link #MODE_WORLD_WRITEABLE}.
 * @param handler to call listener from; must not be null.
 * @param listener to be invoked when the returned descriptor has been
 * closed; must not be null.
 * @return a new ParcelFileDescriptor pointing to the given file.
 * @throws FileNotFoundException if the given file does not exist or can not
 * be opened with the requested mode.
 * @see #parseMode(String)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,4","1,2","Exception handling statement has been simplified by removing the separate IoUtils.setBlocking and ListenerBridge codes, and replaced with the addition of an anonymous OnFileDescriptorEventListener within the handler.getLooper().getQueue().addOnFileDescriptorEventListener method. This significant refactor of the exception handling and the thread set-up logic implies a change type of 2,3,4.","The late version introduces a new way to handle file descriptor events, which could potentially affect both the exceptions thrown and the return value. If an IOException occurs during event handling, it could affect the behavior of the caller. The API in the late version does not use a separate thread to listen for close events but instead registers an event listener with the MessageQueue, which changes how and when the OnCloseListener is called. It might lead to the late version not throwing expected exceptions and instead invoking the OnCloseListener callback in a way the early version didn't, which constitutes a CI type of 1,2."
759,<android.widget.SimpleMonthView: boolean onTouchEvent(MotionEvent)>,22,23,<android.widget.SimpleMonthView: boolean onTouchEvent(MotionEvent)>,<android.widget.SimpleMonthView: boolean onTouchEvent(MotionEvent)>,0,"{
    switch(event.getAction()) {
        case MotionEvent.ACTION_UP:
            final int day = getDayFromLocation(event.getX(), event.getY());
            if (day >= 0) {
                onDayClick(day);
            }
            break;
    }
    return true;
}","{
    final int x = (int) (event.getX() + 0.5f);
    final int y = (int) (event.getY() + 0.5f);
    final int action = event.getAction();
    switch(action) {
        case MotionEvent.ACTION_DOWN:
        case MotionEvent.ACTION_MOVE:
            final int touchedItem = getDayAtLocation(x, y);
            if (mTouchedItem != touchedItem) {
                mTouchedItem = touchedItem;
                invalidate();
            }
            if (action == MotionEvent.ACTION_DOWN && touchedItem < 0) {
                // Touch something that's not an item, reject event.
                return false;
            }
            break;
        case MotionEvent.ACTION_UP:
            final int clickedDay = getDayAtLocation(x, y);
            onDayClicked(clickedDay);
        // Fall through.
        case MotionEvent.ACTION_CANCEL:
            // Reset touched day on stream end.
            mTouchedItem = -1;
            invalidate();
            break;
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,"The method's implementation has been modified extensively, including changes to the switch statement (adding new cases), the addition of variables (x, y, action), and alteration of the logic in the ACTION_UP case. It also newly handles the ACTION_DOWN and ACTION_MOVE actions and introduces an early return false statement under a certain condition; so, the code change type is 1,3,4.","Since an early return false statement is introduced when the touched item is below 0 during an ACTION_DOWN event, which was not present in the early version, this can cause the method to return a different value; hence CI type is 1."
760,"<android.widget.PopupWindow: void showAsDropDown(View,int,int,int)>",22,23,"<android.widget.PopupWindow: void showAsDropDown(View,int,int,int)>","<android.widget.PopupWindow: void showAsDropDown(View,int,int,int)>",0,"{
    if (isShowing() || mContentView == null) {
        return;
    }
    registerForScrollChanged(anchor, xoff, yoff, gravity);
    mIsShowing = true;
    mIsDropdown = true;
    WindowManager.LayoutParams p = createPopupLayout(anchor.getWindowToken());
    preparePopup(p);
    updateAboveAnchor(findDropDownPosition(anchor, p, xoff, yoff, gravity));
    if (mHeightMode < 0)
        p.height = mLastHeight = mHeightMode;
    if (mWidthMode < 0)
        p.width = mLastWidth = mWidthMode;
    p.windowAnimations = computeAnimationResource();
    invokePopup(p);
}","{
    if (isShowing() || mContentView == null) {
        return;
    }
    TransitionManager.endTransitions(mDecorView);
    registerForScrollChanged(anchor, xoff, yoff, gravity);
    mIsShowing = true;
    mIsDropdown = true;
    final WindowManager.LayoutParams p = createPopupLayoutParams(anchor.getWindowToken());
    preparePopup(p);
    final boolean aboveAnchor = findDropDownPosition(anchor, p, xoff, yoff, gravity);
    updateAboveAnchor(aboveAnchor);
    invokePopup(p);
}",1,"/**
 * <p>Display the content view in a popup window anchored to the bottom-left
 * corner of the anchor view offset by the specified x and y coordinates.
 * If there is not enough room on screen to show
 * the popup in its entirety, this method tries to find a parent scroll
 * view to scroll. If no parent scroll view can be scrolled, the bottom-left
 * corner of the popup is pinned at the top left corner of the anchor view.</p>
 * <p>If the view later scrolls to move <code>anchor</code> to a different
 * location, the popup will be moved correspondingly.</p>
 *
 * @param anchor the view on which to pin the popup window
 * @param xoff A horizontal offset from the anchor in pixels
 * @param yoff A vertical offset from the anchor in pixels
 * @param gravity Alignment of the popup relative to the anchor
 *
 * @see #dismiss()
 */
","/**
 * Displays the content view in a popup window anchored to the corner of
 * another view. The window is positioned according to the specified
 * gravity and offset by the specified x and y coordinates.
 * <p>
 * If there is not enough room on screen to show the popup in its entirety,
 * this method tries to find a parent scroll view to scroll. If no parent
 * view can be scrolled, the specified vertical gravity will be ignored and
 * the popup will anchor itself such that it is visible.
 * <p>
 * If the view later scrolls to move <code>anchor</code> to a different
 * location, the popup will be moved correspondingly.
 *
 * @param anchor the view on which to pin the popup window
 * @param xoff A horizontal offset from the anchor in pixels
 * @param yoff A vertical offset from the anchor in pixels
 * @param gravity Alignment of the popup relative to the anchor
 *
 * @see #dismiss()
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,The implementations changed as follows: ,"- There is a new method call `TransitionManager.endTransitions(mDecorView)` before `registerForScrollChanged(anchor, xoff, yoff, gravity)`."
761,<android.text.style.URLSpan: void onClick(View)>,22,23,<android.text.style.URLSpan: void onClick(View)>,<android.text.style.URLSpan: void onClick(View)>,0,"{
    Uri uri = Uri.parse(getURL());
    Context context = widget.getContext();
    Intent intent = new Intent(Intent.ACTION_VIEW, uri);
    intent.putExtra(Browser.EXTRA_APPLICATION_ID, context.getPackageName());
    context.startActivity(intent);
}","{
    Uri uri = Uri.parse(getURL());
    Context context = widget.getContext();
    Intent intent = new Intent(Intent.ACTION_VIEW, uri);
    intent.putExtra(Browser.EXTRA_APPLICATION_ID, context.getPackageName());
    try {
        context.startActivity(intent);
    } catch (ActivityNotFoundException e) {
        Log.w(""URLSpan"", ""Actvity was not found for intent, "" + intent.toString());
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,3",2,"An exception handling statement for ActivityNotFoundException has been added and encloses the context.startActivity(intent) method call. Furthermore, inside the exception handling block, a new log statement has been introduced. Therefore, the code change type is 2 for exception handling statement changed and 3 for control dependency change due to addition of the try-catch block.","The addition of a try-catch block for ActivityNotFoundException represents a CI due to potential difference in exception handling. Previously, if the activity was not found, the exception would not have been caught, likely resulting in a crash or throwing up to the caller. With the late version, the exception is caught and handled internally by logging a warning. Therefore, the API in the late version may handle exceptions differently (e.g., no crashes or propagated exceptions when an activity is not found), leading to the CI being type 2."
762,<android.widget.TextView: int getCompoundPaddingBottom()>,22,23,<android.widget.TextView: int getCompoundPaddingBottom()>,<android.widget.TextView: int getCompoundPaddingBottom()>,0,"{
    final Drawables dr = mDrawables;
    if (dr == null || dr.mDrawableBottom == null) {
        return mPaddingBottom;
    } else {
        return mPaddingBottom + dr.mDrawablePadding + dr.mDrawableSizeBottom;
    }
}","{
    final Drawables dr = mDrawables;
    if (dr == null || dr.mShowing[Drawables.BOTTOM] == null) {
        return mPaddingBottom;
    } else {
        return mPaddingBottom + dr.mDrawablePadding + dr.mDrawableSizeBottom;
    }
}",1,"/**
 * Returns the bottom padding of the view, plus space for the bottom
 * Drawable if any.
 */
","/**
 * Returns the bottom padding of the view, plus space for the bottom
 * Drawable if any.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,There is a change in the field being accessed; from dr.mDrawableBottom to dr.mShowing[Drawables.BOTTOM]. This is an example of the code change type 4 (Other statement changed) and code change type 5 (Dependent API changed).,"There is no Compatibility Issue because the logic of the method has not changed. It still returns the same type of value, merely using a different field of the Drawables object to check the condition. The way the padding is calculated remains unchanged."
763,"<android.hardware.camera2.legacy.ParameterUtils: ZoomData convertScalerCropRegion(Rect,Rect,Size,Parameters)>",22,23,"<android.hardware.camera2.legacy.ParameterUtils: ZoomData convertScalerCropRegion(Rect,Rect,Size,Parameters)>","<android.hardware.camera2.legacy.ParameterUtils: ZoomData convertScalerCropRegion(Rect,Rect,Size,Parameters)>",0,"{
    Rect activeArraySizeOnly = new Rect(/*left*/
    0, /*top*/
    0, activeArraySize.width(), activeArraySize.height());
    Rect userCropRegion = cropRegion;
    if (userCropRegion == null) {
        userCropRegion = activeArraySizeOnly;
    }
    if (VERBOSE) {
        Log.v(TAG, ""convertScalerCropRegion - user crop region was "" + userCropRegion);
    }
    final Rect reportedCropRegion = new Rect();
    final Rect previewCropRegion = new Rect();
    final int zoomIdx = ParameterUtils.getClosestAvailableZoomCrop(params, activeArraySizeOnly, previewSize, userCropRegion, /*out*/
    reportedCropRegion, /*out*/
    previewCropRegion);
    if (VERBOSE) {
        Log.v(TAG, ""convertScalerCropRegion - zoom calculated to: "" + ""zoomIndex = "" + zoomIdx + "", reported crop region = "" + reportedCropRegion + "", preview crop region = "" + previewCropRegion);
    }
    return new ZoomData(zoomIdx, previewCropRegion, reportedCropRegion);
}","{
    Rect activeArraySizeOnly = new Rect(/*left*/
    0, /*top*/
    0, activeArraySize.width(), activeArraySize.height());
    Rect userCropRegion = cropRegion;
    if (userCropRegion == null) {
        userCropRegion = activeArraySizeOnly;
    }
    if (DEBUG) {
        Log.v(TAG, ""convertScalerCropRegion - user crop region was "" + userCropRegion);
    }
    final Rect reportedCropRegion = new Rect();
    final Rect previewCropRegion = new Rect();
    final int zoomIdx = ParameterUtils.getClosestAvailableZoomCrop(params, activeArraySizeOnly, previewSize, userCropRegion, /*out*/
    reportedCropRegion, /*out*/
    previewCropRegion);
    if (DEBUG) {
        Log.v(TAG, ""convertScalerCropRegion - zoom calculated to: "" + ""zoomIndex = "" + zoomIdx + "", reported crop region = "" + reportedCropRegion + "", preview crop region = "" + previewCropRegion);
    }
    return new ZoomData(zoomIdx, previewCropRegion, reportedCropRegion);
}",1,"/**
 * Convert the user-specified crop region into zoom data; which can be used
 * to set the parameters to a specific zoom index, or to report back to the user what the
 * actual zoom was, or for other calculations requiring the current preview crop region.
 *
 * <p>None of the parameters are mutated.</p>
 *
 * @param activeArraySize active array size of the sensor (e.g. max jpeg size)
 * @param cropRegion the user-specified crop region
 * @param previewSize the current preview size (in pixels)
 * @param params the current camera parameters (not mutated)
 *
 * @return the zoom index, and the effective/reported crop regions (relative to active array)
 */
","/**
 * Convert the user-specified crop region into zoom data; which can be used
 * to set the parameters to a specific zoom index, or to report back to the user what the
 * actual zoom was, or for other calculations requiring the current preview crop region.
 *
 * <p>None of the parameters are mutated.</p>
 *
 * @param activeArraySize active array size of the sensor (e.g. max jpeg size)
 * @param cropRegion the user-specified crop region
 * @param previewSize the current preview size (in pixels)
 * @param params the current camera parameters (not mutated)
 *
 * @return the zoom index, and the effective/reported crop regions (relative to active array)
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change is in the logging section where the conditional `if (VERBOSE)` is replaced with `if (DEBUG)`. This is not affecting the behavior of the method as it is merely a debug log level change. Therefore, the type of code change is 4.","There is no Compatibility Issue in the behavior of this method since the debug log statements do not affect the logic or output of the method; they are only for logging purposes. Therefore, no CI arises from this change."
764,"<android.widget.TabWidget: void measureHorizontal(int,int)>",22,23,"<android.widget.TabWidget: void measureHorizontal(int,int)>","<android.widget.TabWidget: void measureHorizontal(int,int)>",0,"{
    if (MeasureSpec.getMode(widthMeasureSpec) == MeasureSpec.UNSPECIFIED) {
        super.measureHorizontal(widthMeasureSpec, heightMeasureSpec);
        return;
    }
    // First, measure with no constraint
    final int unspecifiedWidth = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);
    mImposedTabsHeight = -1;
    super.measureHorizontal(unspecifiedWidth, heightMeasureSpec);
    int extraWidth = getMeasuredWidth() - MeasureSpec.getSize(widthMeasureSpec);
    if (extraWidth > 0) {
        final int count = getChildCount();
        int childCount = 0;
        for (int i = 0; i < count; i++) {
            final View child = getChildAt(i);
            if (child.getVisibility() == GONE)
                continue;
            childCount++;
        }
        if (childCount > 0) {
            if (mImposedTabWidths == null || mImposedTabWidths.length != count) {
                mImposedTabWidths = new int[count];
            }
            for (int i = 0; i < count; i++) {
                final View child = getChildAt(i);
                if (child.getVisibility() == GONE)
                    continue;
                final int childWidth = child.getMeasuredWidth();
                final int delta = extraWidth / childCount;
                final int newWidth = Math.max(0, childWidth - delta);
                mImposedTabWidths[i] = newWidth;
                // Make sure the extra width is evenly distributed, no int division remainder
                // delta may have been clamped
                extraWidth -= childWidth - newWidth;
                childCount--;
                mImposedTabsHeight = Math.max(mImposedTabsHeight, child.getMeasuredHeight());
            }
        }
    }
    // Measure again, this time with imposed tab widths and respecting initial spec request
    super.measureHorizontal(widthMeasureSpec, heightMeasureSpec);
}","{
    if (MeasureSpec.getMode(widthMeasureSpec) == MeasureSpec.UNSPECIFIED) {
        super.measureHorizontal(widthMeasureSpec, heightMeasureSpec);
        return;
    }
    // First, measure with no constraint
    final int width = MeasureSpec.getSize(widthMeasureSpec);
    final int unspecifiedWidth = MeasureSpec.makeSafeMeasureSpec(width, MeasureSpec.UNSPECIFIED);
    mImposedTabsHeight = -1;
    super.measureHorizontal(unspecifiedWidth, heightMeasureSpec);
    int extraWidth = getMeasuredWidth() - width;
    if (extraWidth > 0) {
        final int count = getChildCount();
        int childCount = 0;
        for (int i = 0; i < count; i++) {
            final View child = getChildAt(i);
            if (child.getVisibility() == GONE)
                continue;
            childCount++;
        }
        if (childCount > 0) {
            if (mImposedTabWidths == null || mImposedTabWidths.length != count) {
                mImposedTabWidths = new int[count];
            }
            for (int i = 0; i < count; i++) {
                final View child = getChildAt(i);
                if (child.getVisibility() == GONE)
                    continue;
                final int childWidth = child.getMeasuredWidth();
                final int delta = extraWidth / childCount;
                final int newWidth = Math.max(0, childWidth - delta);
                mImposedTabWidths[i] = newWidth;
                // Make sure the extra width is evenly distributed, no int division remainder
                // delta may have been clamped
                extraWidth -= childWidth - newWidth;
                childCount--;
                mImposedTabsHeight = Math.max(mImposedTabsHeight, child.getMeasuredHeight());
            }
        }
    }
    // Measure again, this time with imposed tab widths and respecting initial spec request
    super.measureHorizontal(widthMeasureSpec, heightMeasureSpec);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The way to measure `unspecifiedWidth` has been changed from `MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED)` to `MeasureSpec.makeSafeMeasureSpec(width, MeasureSpec.UNSPECIFIED)`. This implies that the late version introduces a new utility method (`makeSafeMeasureSpec`) that takes into account the already determined `width` when constructing the `MeasureSpec`. This constitutes a change in a dependent API (5) and also falls under other statement change category due to the alteration of the utility method (4).","Although the method used to create `unspecifiedWidth` has been changed, the fundamental behavior of the method seems to remain intact; it is measuring with no constraint, hence the intention seems to be the same. Therefore, without further details on how `makeSafeMeasureSpec` fundamentally changes the measuring process (assuming it still allows for an unconstrained measure), it doesn't necessarily indicate a compatibility issue. Thus, the prediction does not point towards any compatibility issue (0)."
765,"<android.content.res.TypedArray: int getDimensionPixelSize(int,int)>",22,23,"<android.content.res.TypedArray: int getDimensionPixelSize(int,int)>","<android.content.res.TypedArray: int getDimensionPixelSize(int,int)>",0,"{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimensionPixelSize(data[index + AssetManager.STYLE_DATA], mMetrics);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        throw new RuntimeException(""Failed to resolve attribute at index "" + index);
    }
    throw new UnsupportedOperationException(""Can't convert to dimension: type=0x"" + Integer.toHexString(type));
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimensionPixelSize(data[index + AssetManager.STYLE_DATA], mMetrics);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, value);
        throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + index + "": "" + value);
    }
    throw new UnsupportedOperationException(""Can't convert to dimension: type=0x"" + Integer.toHexString(type));
}",1,"/**
 * Retrieve a dimensional unit attribute at <var>index</var> for use
 * as a size in raw pixels.  This is the same as
 * {@link #getDimension}, except the returned value is converted to
 * integer pixels for use as a size.  A size conversion involves
 * rounding the base value, and ensuring that a non-zero base value
 * is at least one pixel in size.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric and truncated to integer pixels, or defValue if not defined.
 *
 * @see #getDimension
 * @see #getDimensionPixelOffset
 */
","/**
 * Retrieve a dimensional unit attribute at <var>index</var> for use
 * as a size in raw pixels.  This is the same as
 * {@link #getDimension}, except the returned value is converted to
 * integer pixels for use as a size.  A size conversion involves
 * rounding the base value, and ensuring that a non-zero base value
 * is at least one pixel in size.
 * <p>
 * This method will throw an exception if the attribute is defined but is
 * not a dimension.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric and truncated to integer pixels, or defValue if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not a dimension.
 *
 * @see #getDimension
 * @see #getDimensionPixelOffset
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change is in the string message passed to the UnsupportedOperationException thrown when the type is TypedValue.TYPE_ATTRIBUTE. This updated message now includes the TypedValue content as part of the exception message, so the code change type is 4.","There is no Compatibility Issue that will arise from just changing the exception message content; the behavior of the method in terms of data processing and return values remains unchanged, so the CI type is 0."
766,"<android.content.ContentProviderClient: ParcelFileDescriptor openFile(Uri,String,CancellationSignal)>",22,23,"<android.content.ContentProviderClient: ParcelFileDescriptor openFile(Uri,String,CancellationSignal)>","<android.content.ContentProviderClient: ParcelFileDescriptor openFile(Uri,String,CancellationSignal)>",0,"{
    beforeRemote();
    try {
        ICancellationSignal remoteSignal = null;
        if (signal != null) {
            signal.throwIfCanceled();
            remoteSignal = mContentProvider.createCancellationSignal();
            signal.setRemote(remoteSignal);
        }
        return mContentProvider.openFile(mPackageName, url, mode, remoteSignal, null);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}","{
    Preconditions.checkNotNull(url, ""url"");
    Preconditions.checkNotNull(mode, ""mode"");
    beforeRemote();
    try {
        ICancellationSignal remoteSignal = null;
        if (signal != null) {
            signal.throwIfCanceled();
            remoteSignal = mContentProvider.createCancellationSignal();
            signal.setRemote(remoteSignal);
        }
        return mContentProvider.openFile(mPackageName, url, mode, remoteSignal, null);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}",1,"/**
 * See {@link ContentProvider#openFile ContentProvider.openFile}.  Note that
 * this <em>does not</em>
 * take care of non-content: URIs such as file:.  It is strongly recommended
 * you use the {@link ContentResolver#openFileDescriptor
 * ContentResolver.openFileDescriptor} API instead.
 */
","/**
 * See {@link ContentProvider#openFile ContentProvider.openFile}.  Note that
 * this <em>does not</em>
 * take care of non-content: URIs such as file:.  It is strongly recommended
 * you use the {@link ContentResolver#openFileDescriptor
 * ContentResolver.openFileDescriptor} API instead.
 */
",-1,,[@Nullable],-1,-1,-1,-1,-1,-1,4,0,"The change involves the addition of two null checks on the parameters 'url' and 'mode' using Preconditions.checkNotNull before the main logic, so the code change type is 4.","Since the added null checks will throw a NullPointerException if 'url' or 'mode' is null and these exceptions will be thrown before any other logic occurs—a behavior change—it seems to suggest a CI. However, if we consider the practical use of the API, passing a null 'url' or 'mode' would have resulted in an error anyway in the subsequent call to mContentProvider.openFile. The added checks make the failure explicit and happen earlier, but they do not represent a behavioral change that would impact the correct operation of a well-formed call to the method. This means there is no Compatibility Issue because the contract of the method already implied these values could not be null. The annotations, in this case, do not signal a change in the API contract since they are clarifications rather than changes in behavior."
767,"<android.view.ViewGroup: ActionMode startActionModeForChild(View,Callback)>",22,23,"<android.view.ViewGroup: ActionMode startActionModeForChild(View,Callback)>","<android.view.ViewGroup: ActionMode startActionModeForChild(View,Callback)>",0,"{
    return mParent != null ? mParent.startActionModeForChild(originalView, callback) : null;
}","{
    if ((mGroupFlags & FLAG_START_ACTION_MODE_FOR_CHILD_IS_TYPED) == 0) {
        // This is the original call.
        try {
            mGroupFlags |= FLAG_START_ACTION_MODE_FOR_CHILD_IS_NOT_TYPED;
            return startActionModeForChild(originalView, callback, ActionMode.TYPE_PRIMARY);
        } finally {
            mGroupFlags &= ~FLAG_START_ACTION_MODE_FOR_CHILD_IS_NOT_TYPED;
        }
    } else {
        // We are being called from the new method with type.
        return SENTINEL_ACTION_MODE;
    }
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,,[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,"The early implementation directly returns a value from a ternary operation, which is a simple delegation method call or null based on a condition. In the late implementation, there is a change in control dependency with the addition of an `if` statement containing bitwise operations and an inner `try-finally` block. Furthermore, a constant `SENTINEL_ACTION_MODE` is returned under a new condition. New control structures have been added, the return value is conditionally different, and an additional constant is used in the late implementation. Thus, the change type is 1,3, and 4.","There's a compatibility issue here because the new implementation potentially returns different values based on new conditions (`FLAG_START_ACTION_MODE_FOR_CHILD_IS_TYPED`), uses a new method call with an additional parameter (`startActionModeForChild(originalView, callback, ActionMode.TYPE_PRIMARY)`), and has a different default return value (`SENTINEL_ACTION_MODE` instead of `null`). Therefore, the late version may behave differently from the early version when the method is invoked, which is why the CI type is 1."
768,"<android.content.ContentResolver: int delete(Uri,String,String[])>",22,23,"<android.content.ContentResolver: int delete(Uri,String,String[])>","<android.content.ContentResolver: int delete(Uri,String,String[])>",0,"{
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        throw new IllegalArgumentException(""Unknown URL "" + url);
    }
    try {
        long startTime = SystemClock.uptimeMillis();
        int rowsDeleted = provider.delete(mPackageName, url, where, selectionArgs);
        long durationMillis = SystemClock.uptimeMillis() - startTime;
        maybeLogUpdateToEventLog(durationMillis, url, ""delete"", where);
        return rowsDeleted;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return -1;
    } finally {
        releaseProvider(provider);
    }
}","{
    Preconditions.checkNotNull(url, ""url"");
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        throw new IllegalArgumentException(""Unknown URL "" + url);
    }
    try {
        long startTime = SystemClock.uptimeMillis();
        int rowsDeleted = provider.delete(mPackageName, url, where, selectionArgs);
        long durationMillis = SystemClock.uptimeMillis() - startTime;
        maybeLogUpdateToEventLog(durationMillis, url, ""delete"", where);
        return rowsDeleted;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return -1;
    } finally {
        releaseProvider(provider);
    }
}",1,"/**
 * Deletes row(s) specified by a content URI.
 *
 * If the content provider supports transactions, the deletion will be atomic.
 *
 * @param url The URL of the row to delete.
 * @param where A filter to apply to rows before deleting, formatted as an SQL WHERE clause
 * (excluding the WHERE itself).
 * @return The number of rows deleted.
 */
","/**
 * Deletes row(s) specified by a content URI.
 *
 * If the content provider supports transactions, the deletion will be atomic.
 *
 * @param url The URL of the row to delete.
 * @param where A filter to apply to rows before deleting, formatted as an SQL WHERE clause
 * (excluding the WHERE itself).
 * @return The number of rows deleted.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"An additional statement, Preconditions.checkNotNull(url, ""url"");, is introduced before acquiring the provider. Since this is just a check and doesn't modify behavior (other than potentially throwing a NullPointerException which would have happened anyway if url were null), the code change type is 4.","There is no Compatibility Issue because the newly introduced check for null URL would have resulted in a NullPointerException being thrown by the subsequent acquireProvider(url) call anyhow if 'url' were null. Therefore, the catch block for RemoteException is unchanged, and the return paths remain the same as previously."
769,"<android.content.pm.PackageInstaller: void uninstall(String,IntentSender)>",22,23,"<android.content.pm.PackageInstaller: void uninstall(String,IntentSender)>","<android.content.pm.PackageInstaller: void uninstall(String,IntentSender)>",0,"{
    try {
        mInstaller.uninstall(packageName, 0, statusReceiver, mUserId);
    } catch (RemoteException e) {
        throw e.rethrowAsRuntimeException();
    }
}","{
    try {
        mInstaller.uninstall(packageName, mInstallerPackageName, 0, statusReceiver, mUserId);
    } catch (RemoteException e) {
        throw e.rethrowAsRuntimeException();
    }
}",1,"/**
 * Uninstall the given package, removing it completely from the device. This
 * method is only available to the current ""installer of record"" for the
 * package.
 */
","/**
 * Uninstall the given package, removing it completely from the device. This
 * method is only available to the current ""installer of record"" for the
 * package.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The code change here is that a new parameter (`mInstallerPackageName`) is introduced to the `uninstall` method call. This alteration represents both an 'Other statement changed' due to the modification of the method call and a 'Dependent API changed' because the signature of the called API (`mInstaller.uninstall`) has changed. This is a code change type 4,5.","While the method call has changed, this alteration itself does not result in a compatibility issue. The `uninstall` is a void method and doesn't return any value, and the exception handling remains unchanged, so the code changes do not induce any change in the return value or the exceptions thrown. Therefore, the potential for CI is 0."
770,"<android.app.backup.BackupAgent.BackupServiceBinder: void doFullBackup(ParcelFileDescriptor,int,IBackupManager)>",22,23,"<android.app.backup.BackupAgent.BackupServiceBinder: void doFullBackup(ParcelFileDescriptor,int,IBackupManager)>","<android.app.backup.BackupAgent.BackupServiceBinder: void doFullBackup(ParcelFileDescriptor,int,IBackupManager)>",0,"{
    // Ensure that we're running with the app's normal permission level
    long ident = Binder.clearCallingIdentity();
    if (DEBUG)
        Log.v(TAG, ""doFullBackup() invoked"");
    // Ensure that any SharedPreferences writes have landed *before*
    // we potentially try to back up the underlying files directly.
    waitForSharedPrefs();
    try {
        BackupAgent.this.onFullBackup(new FullBackupDataOutput(data));
    } catch (IOException ex) {
        Log.d(TAG, ""onBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", ex);
        throw new RuntimeException(ex);
    } catch (RuntimeException ex) {
        Log.d(TAG, ""onBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", ex);
        throw ex;
    } finally {
        // ... and then again after, as in the doBackup() case
        waitForSharedPrefs();
        // forthcoming from this agent.
        try {
            FileOutputStream out = new FileOutputStream(data.getFileDescriptor());
            byte[] buf = new byte[4];
            out.write(buf);
        } catch (IOException e) {
            Log.e(TAG, ""Unable to finalize backup stream!"");
        }
        Binder.restoreCallingIdentity(ident);
        try {
            callbackBinder.opComplete(token);
        } catch (RemoteException e) {
        // we'll time out anyway, so we're safe
        }
    }
}","{
    // Ensure that we're running with the app's normal permission level
    long ident = Binder.clearCallingIdentity();
    if (DEBUG)
        Log.v(TAG, ""doFullBackup() invoked"");
    // Ensure that any SharedPreferences writes have landed *before*
    // we potentially try to back up the underlying files directly.
    waitForSharedPrefs();
    try {
        BackupAgent.this.onFullBackup(new FullBackupDataOutput(data));
    } catch (IOException ex) {
        Log.d(TAG, ""onFullBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", ex);
        throw new RuntimeException(ex);
    } catch (RuntimeException ex) {
        Log.d(TAG, ""onFullBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", ex);
        throw ex;
    } finally {
        // ... and then again after, as in the doBackup() case
        waitForSharedPrefs();
        // forthcoming from this agent.
        try {
            FileOutputStream out = new FileOutputStream(data.getFileDescriptor());
            byte[] buf = new byte[4];
            out.write(buf);
        } catch (IOException e) {
            Log.e(TAG, ""Unable to finalize backup stream!"");
        }
        Binder.restoreCallingIdentity(ident);
        try {
            callbackBinder.opComplete(token, 0);
        } catch (RemoteException e) {
        // we'll time out anyway, so we're safe
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The content within Log statements has changed, fixing incorrect method names in the strings, which counts as ""other statement changed"" (code change type 4). Additionally, the call to `callbackBinder.opComplete(token)` has been modified to include an extra parameter `0` in `callbackBinder.opComplete(token, 0)`, which counts as ""dependent API changed"" (code change type 5).","The changes made will not lead to different return values or exception handlings. The modification in Log statements is simply a text change for logging purposes and does not affect the method's behavior. The change in the `callbackBinder.opComplete(token, 0)` method call from `callbackBinder.opComplete(token)` by passing a new argument `0` appears to be a change to the dependent API's call pattern. However, this would typically be expected to be handled internally by the `opComplete()` method itself to provide backward compatibility or to implement an overloaded method pattern. Therefore, the change does not necessarily cause a Compatibility Issue; hence it is classified as no compatibility issue (CI type 0)."
771,<android.bluetooth.BluetoothSocket: int bindListen()>,22,23,<android.bluetooth.BluetoothSocket: int bindListen()>,<android.bluetooth.BluetoothSocket: int bindListen()>,0,"{
    int ret;
    if (mSocketState == SocketState.CLOSED)
        return EBADFD;
    IBluetooth bluetoothProxy = BluetoothAdapter.getDefaultAdapter().getBluetoothService(null);
    if (bluetoothProxy == null) {
        Log.e(TAG, ""bindListen fail, reason: bluetooth is off"");
        return -1;
    }
    try {
        mPfd = bluetoothProxy.createSocketChannel(mType, mServiceName, mUuid, mPort, getSecurityFlags());
    } catch (RemoteException e) {
        Log.e(TAG, Log.getStackTraceString(new Throwable()));
        return -1;
    }
    // read out port number
    try {
        synchronized (this) {
            if (DBG)
                Log.d(TAG, ""bindListen(), SocketState: "" + mSocketState + "", mPfd: "" + mPfd);
            if (mSocketState != SocketState.INIT)
                return EBADFD;
            if (mPfd == null)
                return -1;
            FileDescriptor fd = mPfd.getFileDescriptor();
            if (DBG)
                Log.d(TAG, ""bindListen(), new LocalSocket "");
            mSocket = new LocalSocket(fd);
            if (DBG)
                Log.d(TAG, ""bindListen(), new LocalSocket.getInputStream() "");
            mSocketIS = mSocket.getInputStream();
            mSocketOS = mSocket.getOutputStream();
        }
        if (DBG)
            Log.d(TAG, ""bindListen(), readInt mSocketIS: "" + mSocketIS);
        int channel = readInt(mSocketIS);
        synchronized (this) {
            if (mSocketState == SocketState.INIT)
                mSocketState = SocketState.LISTENING;
        }
        if (DBG)
            Log.d(TAG, ""channel: "" + channel);
        if (mPort == -1) {
            mPort = channel;
        }
        // else ASSERT(mPort == channel)
        ret = 0;
    } catch (IOException e) {
        if (mPfd != null) {
            try {
                mPfd.close();
            } catch (IOException e1) {
                Log.e(TAG, ""bindListen, close mPfd: "" + e1);
            }
            mPfd = null;
        }
        Log.e(TAG, ""bindListen, fail to get port number, exception: "" + e);
        return -1;
    }
    return ret;
}","{
    int ret;
    if (mSocketState == SocketState.CLOSED)
        return EBADFD;
    IBluetooth bluetoothProxy = BluetoothAdapter.getDefaultAdapter().getBluetoothService(null);
    if (bluetoothProxy == null) {
        Log.e(TAG, ""bindListen fail, reason: bluetooth is off"");
        return -1;
    }
    try {
        mPfd = bluetoothProxy.createSocketChannel(mType, mServiceName, mUuid, mPort, getSecurityFlags());
    } catch (RemoteException e) {
        Log.e(TAG, Log.getStackTraceString(new Throwable()));
        return -1;
    }
    // read out port number
    try {
        synchronized (this) {
            if (DBG)
                Log.d(TAG, ""bindListen(), SocketState: "" + mSocketState + "", mPfd: "" + mPfd);
            if (mSocketState != SocketState.INIT)
                return EBADFD;
            if (mPfd == null)
                return -1;
            FileDescriptor fd = mPfd.getFileDescriptor();
            if (DBG)
                Log.d(TAG, ""bindListen(), new LocalSocket "");
            mSocket = new LocalSocket(fd);
            if (DBG)
                Log.d(TAG, ""bindListen(), new LocalSocket.getInputStream() "");
            mSocketIS = mSocket.getInputStream();
            mSocketOS = mSocket.getOutputStream();
        }
        if (DBG)
            Log.d(TAG, ""bindListen(), readInt mSocketIS: "" + mSocketIS);
        int channel = readInt(mSocketIS);
        synchronized (this) {
            if (mSocketState == SocketState.INIT)
                mSocketState = SocketState.LISTENING;
        }
        if (DBG)
            Log.d(TAG, ""channel: "" + channel);
        if (mPort <= -1) {
            mPort = channel;
        }
        // else ASSERT(mPort == channel)
        ret = 0;
    } catch (IOException e) {
        if (mPfd != null) {
            try {
                mPfd.close();
            } catch (IOException e1) {
                Log.e(TAG, ""bindListen, close mPfd: "" + e1);
            }
            mPfd = null;
        }
        Log.e(TAG, ""bindListen, fail to get port number, exception: "" + e);
        return -1;
    }
    return ret;
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The condition in the if statement has changed from 'if (mPort == -1)' to 'if (mPort <= -1)'. This is a control dependency change, classified as 3.","The change in the condition does not lead to a different return value or different exception handling, because both the early and late conditions are checking if mPort is an invalid value (previously exactly -1, now less than or equal to -1). The outcome where mPort is assigned the value of channel or not is the same logic in a typical usage scenario where mPort would be expected to be initialized to -1 before binding. Therefore, there's no compatibility issue."
774,<android.bluetooth.BluetoothAdapter: boolean enable()>,22,23,<android.bluetooth.BluetoothAdapter: boolean enable()>,<android.bluetooth.BluetoothAdapter: boolean enable()>,0,"{
    if (isEnabled() == true) {
        if (DBG)
            Log.d(TAG, ""enable(): BT is already enabled..!"");
        return true;
    }
    try {
        return mManagerService.enable();
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}","{
    int state = STATE_OFF;
    if (isEnabled() == true) {
        if (DBG)
            Log.d(TAG, ""enable(): BT is already enabled..!"");
        return true;
    }
    // Use service interface to get the exact state
    if (mService != null) {
        try {
            state = mService.getState();
        } catch (RemoteException e) {
            Log.e(TAG, """", e);
        }
    }
    if (state == BluetoothAdapter.STATE_BLE_ON) {
        Log.e(TAG, ""BT is in BLE_ON State"");
        notifyUserAction(true);
        return true;
    }
    try {
        return mManagerService.enable();
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}",1,"/**
 * Turn on the local Bluetooth adapter&mdash;do not use without explicit
 * user action to turn on Bluetooth.
 * <p>This powers on the underlying Bluetooth hardware, and starts all
 * Bluetooth system services.
 * <p class=""caution""><strong>Bluetooth should never be enabled without
 * direct user consent</strong>. If you want to turn on Bluetooth in order
 * to create a wireless connection, you should use the {@link
 * #ACTION_REQUEST_ENABLE} Intent, which will raise a dialog that requests
 * user permission to turn on Bluetooth. The {@link #enable()} method is
 * provided only for applications that include a user interface for changing
 * system settings, such as a ""power manager"" app.</p>
 * <p>This is an asynchronous call: it will return immediately, and
 * clients should listen for {@link #ACTION_STATE_CHANGED}
 * to be notified of subsequent adapter state changes. If this call returns
 * true, then the adapter state will immediately transition from {@link
 * #STATE_OFF} to {@link #STATE_TURNING_ON}, and some time
 * later transition to either {@link #STATE_OFF} or {@link
 * #STATE_ON}. If this call returns false then there was an
 * immediate problem that will prevent the adapter from being turned on -
 * such as Airplane mode, or the adapter is already turned on.
 * <p>Requires the {@link android.Manifest.permission#BLUETOOTH_ADMIN}
 * permission
 *
 * @return true to indicate adapter startup has begun, or false on
 * immediate error
 */
","/**
 * Turn on the local Bluetooth adapter&mdash;do not use without explicit
 * user action to turn on Bluetooth.
 * <p>This powers on the underlying Bluetooth hardware, and starts all
 * Bluetooth system services.
 * <p class=""caution""><strong>Bluetooth should never be enabled without
 * direct user consent</strong>. If you want to turn on Bluetooth in order
 * to create a wireless connection, you should use the {@link
 * #ACTION_REQUEST_ENABLE} Intent, which will raise a dialog that requests
 * user permission to turn on Bluetooth. The {@link #enable()} method is
 * provided only for applications that include a user interface for changing
 * system settings, such as a ""power manager"" app.</p>
 * <p>This is an asynchronous call: it will return immediately, and
 * clients should listen for {@link #ACTION_STATE_CHANGED}
 * to be notified of subsequent adapter state changes. If this call returns
 * true, then the adapter state will immediately transition from {@link
 * #STATE_OFF} to {@link #STATE_TURNING_ON}, and some time
 * later transition to either {@link #STATE_OFF} or {@link
 * #STATE_ON}. If this call returns false then there was an
 * immediate problem that will prevent the adapter from being turned on -
 * such as Airplane mode, or the adapter is already turned on.
 * <p>Requires the {@link android.Manifest.permission#BLUETOOTH_ADMIN}
 * permission
 *
 * @return true to indicate adapter startup has begun, or false on
 * immediate error
 */
",-1,,[@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)],-1,-1,-1,-1,-1,-1,"1,4",1,"The late version of the implementation introduces an additional block of code that checks the state of the BluetoothAdapter and potentially returns true based on the state. Additionally, a new variable 'state' is introduced, and an API (mService.getState()) is invoked which was not present in the early version. The variable 'state' is initialized with STATE_OFF, which does not change the default control flow but does affect the value that may be returned. These changes relate to the return statement and other changes in the implementation that are not related to exception handling or control dependency. Therefore, the change types are 1, and 4.","The additional check for `if (state == BluetoothAdapter.STATE_BLE_ON)` introduces a scenario where the method could return a different value (true instead of false) than it would have in the previous version if the state is `STATE_BLE_ON`. These changes can cause the API to potentially return a different value, so the CI type is 1."
775,<android.app.ContextImpl: Context createDisplayContext(Display)>,22,23,<android.app.ContextImpl: Context createDisplayContext(Display)>,<android.app.ContextImpl: Context createDisplayContext(Display)>,0,"{
    if (display == null) {
        throw new IllegalArgumentException(""display must not be null"");
    }
    return new ContextImpl(this, mMainThread, mPackageInfo, mActivityToken, mUser, mRestricted, display, mOverrideConfiguration);
}","{
    if (display == null) {
        throw new IllegalArgumentException(""display must not be null"");
    }
    return new ContextImpl(this, mMainThread, mPackageInfo, mActivityToken, mUser, mRestricted, display, null, Display.INVALID_DISPLAY);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"The constructor's parameters for ContextImpl have been modified, a null value and Display.INVALID_DISPLAY are provided as new arguments. The code change type is 4,5 due to the changes in the constructor call which is a dependent API.","The context that is being created is going to be initialized with different values compared to the early version due to the changes in the constructor call. This means the returned ContextImpl instance could behave differently, which causes a CI type of 1."
776,<android.app.Notification.Builder: Builder setSmallIcon(int)>,22,23,<android.app.Notification.Builder: Builder setSmallIcon(int)>,<android.app.Notification.Builder: Builder setSmallIcon(int)>,0,"{
    mSmallIcon = icon;
    return this;
}","{
    return setSmallIcon(icon != 0 ? Icon.createWithResource(mContext, icon) : null);
}",1,"/**
 * Set the small icon resource, which will be used to represent the notification in the
 * status bar.
 *
 * The platform template for the expanded view will draw this icon in the left, unless a
 * {@link #setLargeIcon(Bitmap) large icon} has also been specified, in which case the small
 * icon will be moved to the right-hand side.
 *
 * @param icon
 * A resource ID in the application's package of the drawable to use.
 * @see Notification#icon
 */
","/**
 * Set the small icon resource, which will be used to represent the notification in the
 * status bar.
 *
 * The platform template for the expanded view will draw this icon in the left, unless a
 * {@link #setLargeIcon(Bitmap) large icon} has also been specified, in which case the small
 * icon will be moved to the right-hand side.
 *
 * @param icon
 * A resource ID in the application's package of the drawable to use.
 * @see Notification#icon
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation of the function has been changed from directly setting mSmallIcon to invoking setSmallIcon with different parameters, which implies that there's a dependency on another API that potentially has changed (Icon.createWithResource). Therefore, the code change is of type 1,5.","Since the parameter passed to setSmallIcon is changed in the late version, it could potentially return 'this' with different 'mSmallIcon' value, so the CI type is 1."
778,"<android.widget.TextView: boolean onKeyPreIme(int,KeyEvent)>",22,23,"<android.widget.TextView: boolean onKeyPreIme(int,KeyEvent)>","<android.widget.TextView: boolean onKeyPreIme(int,KeyEvent)>",0,"{
    if (keyCode == KeyEvent.KEYCODE_BACK) {
        boolean isInSelectionMode = mEditor != null && mEditor.mSelectionActionMode != null;
        if (isInSelectionMode) {
            if (event.getAction() == KeyEvent.ACTION_DOWN && event.getRepeatCount() == 0) {
                KeyEvent.DispatcherState state = getKeyDispatcherState();
                if (state != null) {
                    state.startTracking(event, this);
                }
                return true;
            } else if (event.getAction() == KeyEvent.ACTION_UP) {
                KeyEvent.DispatcherState state = getKeyDispatcherState();
                if (state != null) {
                    state.handleUpEvent(event);
                }
                if (event.isTracking() && !event.isCanceled()) {
                    stopSelectionActionMode();
                    return true;
                }
            }
        }
    }
    return super.onKeyPreIme(keyCode, event);
}","{
    // InputMethodService#mExtractEditText.maybeHandleBackInTextActionMode(event).
    if (keyCode == KeyEvent.KEYCODE_BACK && handleBackInTextActionModeIfNeeded(event)) {
        return true;
    }
    return super.onKeyPreIme(keyCode, event);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,"The early version has a detailed implementation with several control structures and checks in place, which has been replaced with a single method call in the late version (handleBackInTextActionModeIfNeeded(event)). There is also a deletion of a check for the action of the event, use of a DispatcherState, and calls to methods on the state and editor objects. This comprises changes in return statements, control dependencies, and other statements, so the code change types are 1,3,4.","Since there is a significant restructuring in how the back key event is handled, including the removal of condition checks and a new method call which could result in different behavior, there is a potential for the API to return different results. This change could result in a different return value when the back key is pressed, and hence there is a compatibility issue of type 1."
779,"<android.app.ContextImpl: void removeStickyBroadcastAsUser(Intent,UserHandle)>",22,23,"<android.app.ContextImpl: void removeStickyBroadcastAsUser(Intent,UserHandle)>","<android.app.ContextImpl: void removeStickyBroadcastAsUser(Intent,UserHandle)>",0,"{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    if (resolvedType != null) {
        intent = new Intent(intent);
        intent.setDataAndType(intent.getData(), resolvedType);
    }
    try {
        intent.prepareToLeaveProcess();
        ActivityManagerNative.getDefault().unbroadcastIntent(mMainThread.getApplicationThread(), intent, user.getIdentifier());
    } catch (RemoteException e) {
    }
}","{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    if (resolvedType != null) {
        intent = new Intent(intent);
        intent.setDataAndType(intent.getData(), resolvedType);
    }
    try {
        intent.prepareToLeaveProcess();
        ActivityManagerNative.getDefault().unbroadcastIntent(mMainThread.getApplicationThread(), intent, user.getIdentifier());
    } catch (RemoteException e) {
        throw new RuntimeException(""Failure from system"", e);
    }
}",1,,,-1,[@Override],"[@Override, @Deprecated]",-1,-1,-1,-1,-1,-1,"2,4",2,"The catch block has been changed by adding a throw new RuntimeException(""Failure from system"", e), which alters the exception handling behavior, and a @Deprecated annotation has been added, but the addition of an annotation does not affect the runtime behavior. Thus, the code change type is 2,4.","A RuntimeException will be thrown in the new version where it was not thrown before in case of RemoteException, therefore, the CI type is 2 due to the potential different exception handling behavior."
780,<android.hardware.camera2.params.TonemapCurve: int hashCode()>,22,23,<android.hardware.camera2.params.TonemapCurve: int hashCode()>,<android.hardware.camera2.params.TonemapCurve: int hashCode()>,0,"{
    if (mHashCalculated) {
        // Avoid re-calculating hash. Data is immutable so this is both legal and faster.
        return mHashCode;
    }
    mHashCode = HashCodeHelpers.hashCode(mRed, mGreen, mBlue);
    mHashCalculated = true;
    return mHashCode;
}","{
    if (mHashCalculated) {
        // Avoid re-calculating hash. Data is immutable so this is both legal and faster.
        return mHashCode;
    }
    mHashCode = HashCodeHelpers.hashCodeGeneric(mRed, mGreen, mBlue);
    mHashCalculated = true;
    return mHashCode;
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The method used to calculate the hash code has changed from HashCodeHelpers.hashCode() to HashCodeHelpers.hashCodeGeneric(). This is a change to a dependent API, so the change type is 4,5.","Despite the change in the method used to calculate the hash code, the modification doesn't affect the behavior of the hashCode() method from the perspective of the calling code. It still computes a hash code based on the same object state without introducing any change to its contract or producing a different outcome in the context of this API's usage. Hence, this doesn't introduce a Compatibility Issue, so the CI type is 0."
781,"<android.content.ContentProviderClient: int bulkInsert(Uri,ContentValues[])>",22,23,"<android.content.ContentProviderClient: int bulkInsert(Uri,ContentValues[])>","<android.content.ContentProviderClient: int bulkInsert(Uri,ContentValues[])>",0,"{
    beforeRemote();
    try {
        return mContentProvider.bulkInsert(mPackageName, url, initialValues);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}","{
    Preconditions.checkNotNull(url, ""url"");
    Preconditions.checkNotNull(initialValues, ""initialValues"");
    beforeRemote();
    try {
        return mContentProvider.bulkInsert(mPackageName, url, initialValues);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}",1,"/**
 * See {@link ContentProvider#bulkInsert ContentProvider.bulkInsert}
 */
","/**
 * See {@link ContentProvider#bulkInsert ContentProvider.bulkInsert}
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"There are two new precondition checks (Preconditions.checkNotNull) for the parameters in the late version, which are considered Other statement changed (type 4).","Since the newly added precondition checks do not alter the return value or the exceptions thrown (the same exceptions would be thrown if 'url' or 'initialValues' were null), they do not cause a Compatibility Issue. They serve as input validation and will simply fail fast if the input is invalid, which isn't different behavior in terms of API contract. Thus, the CI type is 0."
782,<android.print.PrintAttributes: void enforceValidColorMode(int)>,22,23,<android.print.PrintAttributes: void enforceValidColorMode(int)>,<android.print.PrintAttributes: void enforceValidColorMode(int)>,0,"{
    if ((colorMode & VALID_COLOR_MODES) == 0 && Integer.bitCount(colorMode) == 1) {
        throw new IllegalArgumentException(""invalid color mode: "" + colorMode);
    }
}","{
    if ((colorMode & VALID_COLOR_MODES) == 0 || Integer.bitCount(colorMode) != 1) {
        throw new IllegalArgumentException(""invalid color mode: "" + colorMode);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,2,"The condition of the 'if' statement has changed from using an 'AND' operator to an 'OR' operator, which is considered a control dependency change, so the code change type is 3.","Because of the change from 'AND' to 'OR' in the if condition, the conditions under which the IllegalArgumentException is thrown have changed. This could lead to a different exception being thrown under some values of colorMode, and CI type is 2."
783,<android.net.ConnectivityManager: void reportBadNetwork(Network)>,22,23,<android.net.ConnectivityManager: void reportBadNetwork(Network)>,<android.net.ConnectivityManager: void reportBadNetwork(Network)>,0,"{
    try {
        mService.reportBadNetwork(network);
    } catch (RemoteException e) {
    }
}","{
    try {
        // One of these will be ignored because it matches system's current state.
        // The other will trigger the necessary reevaluation.
        mService.reportNetworkConnectivity(network, true);
        mService.reportNetworkConnectivity(network, false);
    } catch (RemoteException e) {
    }
}",1,"/**
 * Report a problem network to the framework.  This provides a hint to the system
 * that there might be connectivity problems on this network and may cause
 * the framework to re-evaluate network connectivity and/or switch to another
 * network.
 *
 * @param network The {@link Network} the application was attempting to use
 * or {@code null} to indicate the current default network.
 */
","/**
 * Report a problem network to the framework.  This provides a hint to the system
 * that there might be connectivity problems on this network and may cause
 * the framework to re-evaluate network connectivity and/or switch to another
 * network.
 *
 * @param network The {@link Network} the application was attempting to use
 * or {@code null} to indicate the current default network.
 * @deprecated Use {@link #reportNetworkConnectivity} which allows reporting both
 * working and non-working connectivity.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The body of the try block is significantly changed with different method calls: from mService.reportBadNetwork(network) to two calls, mService.reportNetworkConnectivity(network, true) and mService.reportNetworkConnectivity(network, false), indicating both an ""Other statement changed"" (method call expression is different) and a ""Dependent API changed"" due to the change from one API call to another (also considering the arguments). Additionally, the semantic meaning of the new method calls can influence the return value (even though it's void, the behavior is changed) making it a ""Return statement changed"" as well. Hence the change type is 1,4,5.","Although the method's return type is void, the behavior is altered because of the change in method calls. The new implementation calls a method with different parameters, which will lead to different network connectivity reports compared to the old implementation. This change can lead to different side effects and interactions with the system, thus the API change can potentially lead to different behavior from the client's perspective, causing a Compatibility Issue of type 1."
785,"<android.widget.CursorAdapter: View getDropDownView(int,View,ViewGroup)>",22,23,"<android.widget.CursorAdapter: View getDropDownView(int,View,ViewGroup)>","<android.widget.CursorAdapter: View getDropDownView(int,View,ViewGroup)>",0,"{
    if (mDataValid) {
        mCursor.moveToPosition(position);
        View v;
        if (convertView == null) {
            v = newDropDownView(mContext, mCursor, parent);
        } else {
            v = convertView;
        }
        bindView(v, mContext, mCursor);
        return v;
    } else {
        return null;
    }
}","{
    if (mDataValid) {
        final Context context = mDropDownContext == null ? mContext : mDropDownContext;
        mCursor.moveToPosition(position);
        final View v;
        if (convertView == null) {
            v = newDropDownView(context, mCursor, parent);
        } else {
            v = convertView;
        }
        bindView(v, context, mCursor);
        return v;
    } else {
        return null;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The code introduces a new variable `context`, which is assigned depending on whether `mDropDownContext` is null or not; the rest of the implementation remains unchanged. As a result, the `newDropDownView` and `bindView` calls now use this new `context` variable instead of directly using `mContext`. The change type is 4 as it involves the introduction of a new local variable and a minor change in how an existing method is called.","Even though the source of the context parameter for `newDropDownView` and `bindView` functions has changed, both are supposed to work with a `Context` object. Given that `mDropDownContext` is meant to be a valid context for drop-down views, it should not alter the correct functioning of these methods. Therefore, this change does not represent a Compatibility Issue, as it doesn't affect the behavior of the method in a way that would lead to different return values or exceptions under the same conditions."
786,<android.widget.DatePicker.AbstractDatePickerDelegate: void setCurrentLocale(Locale)>,22,23,<android.widget.DatePicker.AbstractDatePickerDelegate: void setCurrentLocale(Locale)>,<android.widget.DatePicker.AbstractDatePickerDelegate: void setCurrentLocale(Locale)>,0,"{
    if (locale.equals(mCurrentLocale)) {
        return;
    }
    mCurrentLocale = locale;
}","{
    if (!locale.equals(mCurrentLocale)) {
        mCurrentLocale = locale;
        onLocaleChanged(locale);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The control dependency has been inverted and an additional method call (onLocaleChanged(locale)) has been introduced in the if statement. There is no change in return statement or exception handling, so the code change type is 3,4.","There is no Compatibility Issue because the outcome of setting the `mCurrentLocale` remains consistent between versions. The difference is in the side effects (the call to `onLocaleChanged(locale)`), which does not affect the direct output of the method since it is a void method and this additional method call does not influence the variables being returned or the exceptions being thrown."
787,"<android.content.res.TypedArray: int getDimensionPixelOffset(int,int)>",22,23,"<android.content.res.TypedArray: int getDimensionPixelOffset(int,int)>","<android.content.res.TypedArray: int getDimensionPixelOffset(int,int)>",0,"{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimensionPixelOffset(data[index + AssetManager.STYLE_DATA], mMetrics);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        throw new RuntimeException(""Failed to resolve attribute at index "" + index);
    }
    throw new UnsupportedOperationException(""Can't convert to dimension: type=0x"" + Integer.toHexString(type));
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimensionPixelOffset(data[index + AssetManager.STYLE_DATA], mMetrics);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, value);
        throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + index + "": "" + value);
    }
    throw new UnsupportedOperationException(""Can't convert to dimension: type=0x"" + Integer.toHexString(type));
}",1,"/**
 * Retrieve a dimensional unit attribute at <var>index</var> for use
 * as an offset in raw pixels.  This is the same as
 * {@link #getDimension}, except the returned value is converted to
 * integer pixels for you.  An offset conversion involves simply
 * truncating the base value to an integer.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric and truncated to integer pixels, or defValue if not defined.
 *
 * @see #getDimension
 * @see #getDimensionPixelSize
 */
","/**
 * Retrieve a dimensional unit attribute at <var>index</var> for use
 * as an offset in raw pixels.  This is the same as
 * {@link #getDimension}, except the returned value is converted to
 * integer pixels for you.  An offset conversion involves simply
 * truncating the base value to an integer.
 * <p>
 * This method will throw an exception if the attribute is defined but is
 * not a dimension.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric and truncated to integer pixels, or defValue if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not an integer.
 *
 * @see #getDimension
 * @see #getDimensionPixelSize
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The exception handling statement has changed for TypedValue.TYPE_ATTRIBUTE with a new message that includes additional information about the value, so the change types are 1,4.","As the new exception message now includes the value which was not previously included this results in a change of the exception being thrown. Therefore, the API could throw a different exception message, so the CI type is 1."
788,<android.widget.TextView: boolean verifyDrawable(Drawable)>,22,23,<android.widget.TextView: boolean verifyDrawable(Drawable)>,<android.widget.TextView: boolean verifyDrawable(Drawable)>,0,"{
    final boolean verified = super.verifyDrawable(who);
    if (!verified && mDrawables != null) {
        return who == mDrawables.mDrawableLeft || who == mDrawables.mDrawableTop || who == mDrawables.mDrawableRight || who == mDrawables.mDrawableBottom || who == mDrawables.mDrawableStart || who == mDrawables.mDrawableEnd;
    }
    return verified;
}","{
    final boolean verified = super.verifyDrawable(who);
    if (!verified && mDrawables != null) {
        for (Drawable dr : mDrawables.mShowing) {
            if (who == dr) {
                return true;
            }
        }
    }
    return verified;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,The logic to verify drawables has been changed from a long condition to a for-loop over an array. This is a control dependency change (3) and also another statement change (4) as the structure of the verification check is different.,"The late version of the `verifyDrawable` method introduces a for-loop that iterates over a potentially different set of drawables compared to the early version, which could lead to the method returning `true` for different drawables than before. This means that the API potentially returns different values in the new version, which is a Compatibility Issue of type 1."
789,<android.widget.Editor.InsertionHandleView: boolean onTouchEvent(MotionEvent)>,22,23,<android.widget.Editor.InsertionHandleView: boolean onTouchEvent(MotionEvent)>,<android.widget.Editor.InsertionHandleView: boolean onTouchEvent(MotionEvent)>,0,"{
    final boolean result = super.onTouchEvent(ev);
    switch(ev.getActionMasked()) {
        case MotionEvent.ACTION_DOWN:
            mDownPositionX = ev.getRawX();
            mDownPositionY = ev.getRawY();
            break;
        case MotionEvent.ACTION_UP:
            if (!offsetHasBeenChanged()) {
                final float deltaX = mDownPositionX - ev.getRawX();
                final float deltaY = mDownPositionY - ev.getRawY();
                final float distanceSquared = deltaX * deltaX + deltaY * deltaY;
                final ViewConfiguration viewConfiguration = ViewConfiguration.get(mTextView.getContext());
                final int touchSlop = viewConfiguration.getScaledTouchSlop();
                if (distanceSquared < touchSlop * touchSlop) {
                    if (mActionPopupWindow != null && mActionPopupWindow.isShowing()) {
                        // Tapping on the handle dismisses the displayed action popup
                        mActionPopupWindow.hide();
                    } else {
                        showWithActionPopup();
                    }
                }
            }
            hideAfterDelay();
            break;
        case MotionEvent.ACTION_CANCEL:
            hideAfterDelay();
            break;
        default:
            break;
    }
    return result;
}","{
    final boolean result = super.onTouchEvent(ev);
    switch(ev.getActionMasked()) {
        case MotionEvent.ACTION_DOWN:
            mDownPositionX = ev.getRawX();
            mDownPositionY = ev.getRawY();
            break;
        case MotionEvent.ACTION_UP:
            if (!offsetHasBeenChanged()) {
                final float deltaX = mDownPositionX - ev.getRawX();
                final float deltaY = mDownPositionY - ev.getRawY();
                final float distanceSquared = deltaX * deltaX + deltaY * deltaY;
                final ViewConfiguration viewConfiguration = ViewConfiguration.get(mTextView.getContext());
                final int touchSlop = viewConfiguration.getScaledTouchSlop();
                if (distanceSquared < touchSlop * touchSlop) {
                    // Tapping on the handle toggles the insertion action mode.
                    if (mTextActionMode != null) {
                        mTextActionMode.finish();
                    } else {
                        startInsertionActionMode();
                    }
                }
            } else {
                if (mTextActionMode != null) {
                    mTextActionMode.invalidateContentRect();
                }
            }
            hideAfterDelay();
            break;
        case MotionEvent.ACTION_CANCEL:
            hideAfterDelay();
            break;
        default:
            break;
    }
    return result;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The implementation change is located inside the ACTION_UP case, where different methods are called in response to certain conditions (e.g., calling startInsertionActionMode() instead of showing/hiding an action popup window). This change is not about return statements or exception handling but rather the internal behavior upon ACTION_UP. Hence, the change type is 3 (Control dependency change) and 4 (Other statement changed).","Although there is a significant behavior change, this behavior does not affect the return value of the onTouchEvent method or the exceptions it might throw. The return value remains the value of the variable 'result,' which is set at the beginning of the method and is not affected by the changes. Therefore, there is no Compatibility Issue regarding return values or exception handling, and the CI type is 0."
790,<android.print.PrinterCapabilitiesInfo: boolean equals(Object)>,22,23,<android.print.PrinterCapabilitiesInfo: boolean equals(Object)>,<android.print.PrinterCapabilitiesInfo: boolean equals(Object)>,0,"{
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    PrinterCapabilitiesInfo other = (PrinterCapabilitiesInfo) obj;
    if (mMinMargins == null) {
        if (other.mMinMargins != null) {
            return false;
        }
    } else if (!mMinMargins.equals(other.mMinMargins)) {
        return false;
    }
    if (mMediaSizes == null) {
        if (other.mMediaSizes != null) {
            return false;
        }
    } else if (!mMediaSizes.equals(other.mMediaSizes)) {
        return false;
    }
    if (mResolutions == null) {
        if (other.mResolutions != null) {
            return false;
        }
    } else if (!mResolutions.equals(other.mResolutions)) {
        return false;
    }
    if (mColorModes != other.mColorModes) {
        return false;
    }
    if (!Arrays.equals(mDefaults, other.mDefaults)) {
        return false;
    }
    return true;
}","{
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    PrinterCapabilitiesInfo other = (PrinterCapabilitiesInfo) obj;
    if (mMinMargins == null) {
        if (other.mMinMargins != null) {
            return false;
        }
    } else if (!mMinMargins.equals(other.mMinMargins)) {
        return false;
    }
    if (mMediaSizes == null) {
        if (other.mMediaSizes != null) {
            return false;
        }
    } else if (!mMediaSizes.equals(other.mMediaSizes)) {
        return false;
    }
    if (mResolutions == null) {
        if (other.mResolutions != null) {
            return false;
        }
    } else if (!mResolutions.equals(other.mResolutions)) {
        return false;
    }
    if (mColorModes != other.mColorModes) {
        return false;
    }
    if (mDuplexModes != other.mDuplexModes) {
        return false;
    }
    if (!Arrays.equals(mDefaults, other.mDefaults)) {
        return false;
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The implementation in the late version has an additional check for 'mDuplexModes != other.mDuplexModes'. This is an addition of a new field check, which represents a change in other statements, so the code change type is 4.","However, this change does not lead to a Compatibility Issue. The method is designed to compare the current `PrinterCapabilitiesInfo` object with another one. The newly added check for 'mDuplexModes' ensures that it also considers the duplex printing capabilities as part of the equality comparison. This modification adheres to the logical correctness of the `equals` method contract and won't lead to unexpected behavior for existing code since it is an internal logic improvement. Existing code that compares `PrinterCapabilitiesInfo` objects will continue to function correctly; objects that were considered equal in the past may no longer be equal, but this is consistent with the updated state of the objects."
791,<android.transition.PatternPathMotion: void setPatternPath(Path)>,22,23,<android.transition.PatternPathMotion: void setPatternPath(Path)>,<android.transition.PatternPathMotion: void setPatternPath(Path)>,0,"{
    PathMeasure pathMeasure = new PathMeasure(patternPath, false);
    float length = pathMeasure.getLength();
    float[] pos = new float[2];
    pathMeasure.getPosTan(length, pos, null);
    float endX = pos[0];
    float endY = pos[1];
    pathMeasure.getPosTan(0, pos, null);
    float startX = pos[0];
    float startY = pos[1];
    if (startX == endX && startY == endY) {
        throw new IllegalArgumentException(""pattern must not end at the starting point"");
    }
    mTempMatrix.setTranslate(-startX, -startY);
    float dx = endX - startX;
    float dy = endY - startY;
    float distance = distance(dx, dy);
    float scale = 1 / distance;
    mTempMatrix.postScale(scale, scale);
    double angle = Math.atan2(dy, dx);
    mTempMatrix.postRotate((float) Math.toDegrees(-angle));
    patternPath.transform(mTempMatrix, mPatternPath);
    mOriginalPatternPath = patternPath;
}","{
    PathMeasure pathMeasure = new PathMeasure(patternPath, false);
    float length = pathMeasure.getLength();
    float[] pos = new float[2];
    pathMeasure.getPosTan(length, pos, null);
    float endX = pos[0];
    float endY = pos[1];
    pathMeasure.getPosTan(0, pos, null);
    float startX = pos[0];
    float startY = pos[1];
    if (startX == endX && startY == endY) {
        throw new IllegalArgumentException(""pattern must not end at the starting point"");
    }
    mTempMatrix.setTranslate(-startX, -startY);
    float dx = endX - startX;
    float dy = endY - startY;
    float distance = (float) Math.hypot(dx, dy);
    float scale = 1 / distance;
    mTempMatrix.postScale(scale, scale);
    double angle = Math.atan2(dy, dx);
    mTempMatrix.postRotate((float) Math.toDegrees(-angle));
    patternPath.transform(mTempMatrix, mPatternPath);
    mOriginalPatternPath = patternPath;
}",1,"/**
 * Sets the Path defining a pattern of motion between two coordinates.
 * The pattern will be translated, rotated, and scaled to fit between the start and end points.
 * The pattern must not be empty and must have the end point differ from the start point.
 *
 * @param patternPath A Path to be used as a pattern for two-dimensional motion.
 * @attr ref android.R.styleable#PatternPathMotion_patternPathData
 */
","/**
 * Sets the Path defining a pattern of motion between two coordinates.
 * The pattern will be translated, rotated, and scaled to fit between the start and end points.
 * The pattern must not be empty and must have the end point differ from the start point.
 *
 * @param patternPath A Path to be used as a pattern for two-dimensional motion.
 * @attr ref android.R.styleable#PatternPathMotion_patternPathData
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change in the implementation is the replacement of the custom distance calculation with the standard library function Math.hypot(), which does not affect the logic as it calculates the same value. Thus, the code change is an other statement change, which is type 4.","Since Math.hypot(dx, dy) computes the same hypotenuse length as the original manual calculation of distance, just in a more concise way, there is no compatibility issue, as the behavior of the method has not changed. It results in no CI, type 0."
792,"<android.app.LoadedApk.ReceiverDispatcher.InnerReceiver: void performReceive(Intent,int,String,Bundle,boolean,boolean,int)>",22,23,"<android.app.LoadedApk.ReceiverDispatcher.InnerReceiver: void performReceive(Intent,int,String,Bundle,boolean,boolean,int)>","<android.app.LoadedApk.ReceiverDispatcher.InnerReceiver: void performReceive(Intent,int,String,Bundle,boolean,boolean,int)>",0,"{
    LoadedApk.ReceiverDispatcher rd = mDispatcher.get();
    if (ActivityThread.DEBUG_BROADCAST) {
        int seq = intent.getIntExtra(""seq"", -1);
        Slog.i(ActivityThread.TAG, ""Receiving broadcast "" + intent.getAction() + "" seq="" + seq + "" to "" + (rd != null ? rd.mReceiver : null));
    }
    if (rd != null) {
        rd.performReceive(intent, resultCode, data, extras, ordered, sticky, sendingUser);
    } else {
        // behalf so that the system's broadcast sequence can continue.
        if (ActivityThread.DEBUG_BROADCAST)
            Slog.i(ActivityThread.TAG, ""Finishing broadcast to unregistered receiver"");
        IActivityManager mgr = ActivityManagerNative.getDefault();
        try {
            if (extras != null) {
                extras.setAllowFds(false);
            }
            mgr.finishReceiver(this, resultCode, data, extras, false);
        } catch (RemoteException e) {
            Slog.w(ActivityThread.TAG, ""Couldn't finish broadcast to unregistered receiver"");
        }
    }
}","{
    LoadedApk.ReceiverDispatcher rd = mDispatcher.get();
    if (ActivityThread.DEBUG_BROADCAST) {
        int seq = intent.getIntExtra(""seq"", -1);
        Slog.i(ActivityThread.TAG, ""Receiving broadcast "" + intent.getAction() + "" seq="" + seq + "" to "" + (rd != null ? rd.mReceiver : null));
    }
    if (rd != null) {
        rd.performReceive(intent, resultCode, data, extras, ordered, sticky, sendingUser);
    } else {
        // behalf so that the system's broadcast sequence can continue.
        if (ActivityThread.DEBUG_BROADCAST)
            Slog.i(ActivityThread.TAG, ""Finishing broadcast to unregistered receiver"");
        IActivityManager mgr = ActivityManagerNative.getDefault();
        try {
            if (extras != null) {
                extras.setAllowFds(false);
            }
            mgr.finishReceiver(this, resultCode, data, extras, false, intent.getFlags());
        } catch (RemoteException e) {
            Slog.w(ActivityThread.TAG, ""Couldn't finish broadcast to unregistered receiver"");
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method `mgr.finishReceiver` was modified by adding an additional argument (`intent.getFlags()`), but since this method call occurs within an exception handling (catch) block and the change is not affecting the return value directly nor changing exception handling mechanism for this method, the change type is only 4.",There is no Compatibility Issue because this change does not affect the return value or the exception thrown by the API method `performReceive`. It is an internal change to a method call that does not directly lead to a different API behavior observed by the caller.
794,<android.widget.AbsListView: boolean onGenericMotionEvent(MotionEvent)>,22,23,<android.widget.AbsListView: boolean onGenericMotionEvent(MotionEvent)>,<android.widget.AbsListView: boolean onGenericMotionEvent(MotionEvent)>,0,"{
    if ((event.getSource() & InputDevice.SOURCE_CLASS_POINTER) != 0) {
        switch(event.getAction()) {
            case MotionEvent.ACTION_SCROLL:
                {
                    if (mTouchMode == TOUCH_MODE_REST) {
                        final float vscroll = event.getAxisValue(MotionEvent.AXIS_VSCROLL);
                        if (vscroll != 0) {
                            final int delta = (int) (vscroll * getVerticalScrollFactor());
                            if (!trackMotionScroll(delta, delta)) {
                                return true;
                            }
                        }
                    }
                }
        }
    }
    return super.onGenericMotionEvent(event);
}","{
    if ((event.getSource() & InputDevice.SOURCE_CLASS_POINTER) != 0) {
        switch(event.getAction()) {
            case MotionEvent.ACTION_SCROLL:
                if (mTouchMode == TOUCH_MODE_REST) {
                    final float vscroll = event.getAxisValue(MotionEvent.AXIS_VSCROLL);
                    if (vscroll != 0) {
                        final int delta = (int) (vscroll * getVerticalScrollFactor());
                        if (!trackMotionScroll(delta, delta)) {
                            return true;
                        }
                    }
                }
                break;
            case MotionEvent.ACTION_BUTTON_PRESS:
                int actionButton = event.getActionButton();
                if ((actionButton == MotionEvent.BUTTON_STYLUS_PRIMARY || actionButton == MotionEvent.BUTTON_SECONDARY) && (mTouchMode == TOUCH_MODE_DOWN || mTouchMode == TOUCH_MODE_TAP)) {
                    if (performStylusButtonPressAction(event)) {
                        removeCallbacks(mPendingCheckForLongPress);
                        removeCallbacks(mPendingCheckForTap);
                    }
                }
                break;
        }
    }
    return super.onGenericMotionEvent(event);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,"The late version adds a new case in the switch statement (MotionEvent.ACTION_BUTTON_PRESS) and associated logic, which constitutes a control dependency change (3), as well as an 'Other statement changed' (4). Additionally, this affects the return statement because depending on the value of `event.getAction()`, a different branch may execute, potentially causing the method to return a different value, which makes it a 'Return statement changed' (1).","The new case for MotionEvent.ACTION_BUTTON_PRESS in the switch statement, which has its own return logic, could result in a different return value when such an event is processed. Therefore, there is a Compatibility Issue due to potential different return values (1)."
795,"<android.app.NotificationManager: void notify(String,int,Notification)>",22,23,"<android.app.NotificationManager: void notify(String,int,Notification)>","<android.app.NotificationManager: void notify(String,int,Notification)>",0,"{
    int[] idOut = new int[1];
    INotificationManager service = getService();
    String pkg = mContext.getPackageName();
    if (notification.sound != null) {
        notification.sound = notification.sound.getCanonicalUri();
        if (StrictMode.vmFileUriExposureEnabled()) {
            notification.sound.checkFileUriExposed(""Notification.sound"");
        }
    }
    if (localLOGV)
        Log.v(TAG, pkg + "": notify("" + id + "", "" + notification + "")"");
    Notification stripped = notification.clone();
    Builder.stripForDelivery(stripped);
    try {
        service.enqueueNotificationWithTag(pkg, mContext.getOpPackageName(), tag, id, stripped, idOut, UserHandle.myUserId());
        if (id != idOut[0]) {
            Log.w(TAG, ""notify: id corrupted: sent "" + id + "", got back "" + idOut[0]);
        }
    } catch (RemoteException e) {
    }
}","{
    int[] idOut = new int[1];
    INotificationManager service = getService();
    String pkg = mContext.getPackageName();
    if (notification.sound != null) {
        notification.sound = notification.sound.getCanonicalUri();
        if (StrictMode.vmFileUriExposureEnabled()) {
            notification.sound.checkFileUriExposed(""Notification.sound"");
        }
    }
    fixLegacySmallIcon(notification, pkg);
    if (mContext.getApplicationInfo().targetSdkVersion > Build.VERSION_CODES.LOLLIPOP_MR1) {
        if (notification.getSmallIcon() == null) {
            throw new IllegalArgumentException(""Invalid notification (no valid small icon): "" + notification);
        }
    }
    if (localLOGV)
        Log.v(TAG, pkg + "": notify("" + id + "", "" + notification + "")"");
    Notification stripped = notification.clone();
    Builder.stripForDelivery(stripped);
    try {
        service.enqueueNotificationWithTag(pkg, mContext.getOpPackageName(), tag, id, stripped, idOut, UserHandle.myUserId());
        if (id != idOut[0]) {
            Log.w(TAG, ""notify: id corrupted: sent "" + id + "", got back "" + idOut[0]);
        }
    } catch (RemoteException e) {
    }
}",1,"/**
 * Post a notification to be shown in the status bar. If a notification with
 * the same tag and id has already been posted by your application and has not yet been
 * canceled, it will be replaced by the updated information.
 *
 * @param tag A string identifier for this notification.  May be {@code null}.
 * @param id An identifier for this notification.  The pair (tag, id) must be unique
 * within your application.
 * @param notification A {@link Notification} object describing what to
 * show the user. Must not be null.
 */
","/**
 * Post a notification to be shown in the status bar. If a notification with
 * the same tag and id has already been posted by your application and has not yet been
 * canceled, it will be replaced by the updated information.
 *
 * @param tag A string identifier for this notification.  May be {@code null}.
 * @param id An identifier for this notification.  The pair (tag, id) must be unique
 * within your application.
 * @param notification A {@link Notification} object describing what to
 * show the user. Must not be null.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,4","1,2","A new check for 'notification.getSmallIcon()' and a new method call 'fixLegacySmallIcon(notification, pkg)' have been introduced, which are changes in exception handling statement and other statements. Additionally, there's a control dependency change since the new check is under an 'if' statement checking 'targetSdkVersion', so the change type is 2,3,4.","The API now throws a new IllegalArgumentException if the 'notification.getSmallIcon()' returns null for apps targeting higher than 'LOLLIPOP_MR1'. Therefore, there is a Compatibility Issue due to the potential for throwing a different exception than in the previous version. Also, since the execution of 'fixLegacySmallIcon' method can potentially alter the state or outcome of the 'notification' object, it might lead to a different return value of 'notification' being passed to 'service.enqueueNotificationWithTag'. Hence, the potential Compatibility Issue types are 1 (different return values) and 2 (different exception handlings)."
797,"<android.view.Choreographer: void doCallbacks(int,long)>",22,23,"<android.view.Choreographer: void doCallbacks(int,long)>","<android.view.Choreographer: void doCallbacks(int,long)>",0,"{
    CallbackRecord callbacks;
    synchronized (mLock) {
        // We use ""now"" to determine when callbacks become due because it's possible
        // for earlier processing phases in a frame to post callbacks that should run
        // in a following phase, such as an input event that causes an animation to start.
        final long now = SystemClock.uptimeMillis();
        callbacks = mCallbackQueues[callbackType].extractDueCallbacksLocked(now);
        if (callbacks == null) {
            return;
        }
        mCallbacksRunning = true;
    }
    try {
        for (CallbackRecord c = callbacks; c != null; c = c.next) {
            if (DEBUG) {
                Log.d(TAG, ""RunCallback: type="" + callbackType + "", action="" + c.action + "", token="" + c.token + "", latencyMillis="" + (SystemClock.uptimeMillis() - c.dueTime));
            }
            c.run(frameTimeNanos);
        }
    } finally {
        synchronized (mLock) {
            mCallbacksRunning = false;
            do {
                final CallbackRecord next = callbacks.next;
                recycleCallbackLocked(callbacks);
                callbacks = next;
            } while (callbacks != null);
        }
    }
}","{
    CallbackRecord callbacks;
    synchronized (mLock) {
        // We use ""now"" to determine when callbacks become due because it's possible
        // for earlier processing phases in a frame to post callbacks that should run
        // in a following phase, such as an input event that causes an animation to start.
        final long now = System.nanoTime();
        callbacks = mCallbackQueues[callbackType].extractDueCallbacksLocked(now / TimeUtils.NANOS_PER_MS);
        if (callbacks == null) {
            return;
        }
        mCallbacksRunning = true;
        // safe by ensuring the commit time is always at least one frame behind.
        if (callbackType == Choreographer.CALLBACK_COMMIT) {
            final long jitterNanos = now - frameTimeNanos;
            Trace.traceCounter(Trace.TRACE_TAG_VIEW, ""jitterNanos"", (int) jitterNanos);
            if (jitterNanos >= 2 * mFrameIntervalNanos) {
                final long lastFrameOffset = jitterNanos % mFrameIntervalNanos + mFrameIntervalNanos;
                if (DEBUG_JANK) {
                    Log.d(TAG, ""Commit callback delayed by "" + (jitterNanos * 0.000001f) + "" ms which is more than twice the frame interval of "" + (mFrameIntervalNanos * 0.000001f) + "" ms!  "" + ""Setting frame time to "" + (lastFrameOffset * 0.000001f) + "" ms in the past."");
                    mDebugPrintNextFrameTimeDelta = true;
                }
                frameTimeNanos = now - lastFrameOffset;
                mLastFrameTimeNanos = frameTimeNanos;
            }
        }
    }
    try {
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, CALLBACK_TRACE_TITLES[callbackType]);
        for (CallbackRecord c = callbacks; c != null; c = c.next) {
            if (DEBUG_FRAMES) {
                Log.d(TAG, ""RunCallback: type="" + callbackType + "", action="" + c.action + "", token="" + c.token + "", latencyMillis="" + (SystemClock.uptimeMillis() - c.dueTime));
            }
            c.run(frameTimeNanos);
        }
    } finally {
        synchronized (mLock) {
            mCallbacksRunning = false;
            do {
                final CallbackRecord next = callbacks.next;
                recycleCallbackLocked(callbacks);
                callbacks = next;
            } while (callbacks != null);
        }
        Trace.traceEnd(Trace.TRACE_TAG_VIEW);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,The code change involves several different aspects:,"- Trace.traceBegin() and Trace.traceEnd() are added for debugging, which doesn't affect the API's behavior, hence it is categorized as 4."
798,"<android.widget.SimpleMonthView.MonthViewTouchHelper: boolean onPerformActionForVirtualView(int,int,Bundle)>",22,23,"<android.widget.SimpleMonthView.MonthViewTouchHelper: boolean onPerformActionForVirtualView(int,int,Bundle)>","<android.widget.SimpleMonthView.MonthViewTouchHelper: boolean onPerformActionForVirtualView(int,int,Bundle)>",0,"{
    switch(action) {
        case AccessibilityNodeInfo.ACTION_CLICK:
            onDayClick(virtualViewId);
            return true;
    }
    return false;
}","{
    switch(action) {
        case AccessibilityNodeInfo.ACTION_CLICK:
            return onDayClicked(virtualViewId);
    }
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"The method invocation within the 'case AccessibilityNodeInfo.ACTION_CLICK' has changed from 'onDayClick()' to 'onDayClicked()' and it directly affects the return statement, so the code change types are 1,3. The method name change indicates a potential change in behavior or semantics.","Since the earlier version calls 'onDayClick(virtualViewId)' and the later version calls 'onDayClicked(virtualViewId)' and directly returns its result, if the implementation of 'onDayClicked' is different from 'onDayClick', it could potentially lead to different return values. Thus, the CI type is 1."
799,"<android.accounts.AbstractAccountAuthenticator.Transport: void getAuthTokenLabel(IAccountAuthenticatorResponse,String)>",22,23,"<android.accounts.AbstractAccountAuthenticator.Transport: void getAuthTokenLabel(IAccountAuthenticatorResponse,String)>","<android.accounts.AbstractAccountAuthenticator.Transport: void getAuthTokenLabel(IAccountAuthenticatorResponse,String)>",0,"{
    if (Log.isLoggable(TAG, Log.VERBOSE)) {
        Log.v(TAG, ""getAuthTokenLabel: authTokenType "" + authTokenType);
    }
    checkBinderPermission();
    try {
        Bundle result = new Bundle();
        result.putString(AccountManager.KEY_AUTH_TOKEN_LABEL, AbstractAccountAuthenticator.this.getAuthTokenLabel(authTokenType));
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            // force it to be unparcelled
            result.keySet();
            Log.v(TAG, ""getAuthTokenLabel: result "" + AccountManager.sanitizeResult(result));
        }
        response.onResult(result);
    } catch (Exception e) {
        handleException(response, ""getAuthTokenLabel"", authTokenType, e);
    }
}","{
    if (Log.isLoggable(TAG, Log.VERBOSE)) {
        Log.v(TAG, ""getAuthTokenLabel: authTokenType "" + authTokenType);
    }
    checkBinderPermission();
    try {
        Bundle result = new Bundle();
        result.putString(AccountManager.KEY_AUTH_TOKEN_LABEL, AbstractAccountAuthenticator.this.getAuthTokenLabel(authTokenType));
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            if (result != null) {
                // force it to be unparcelled
                result.keySet();
            }
            Log.v(TAG, ""getAuthTokenLabel: result "" + AccountManager.sanitizeResult(result));
        }
        response.onResult(result);
    } catch (Exception e) {
        handleException(response, ""getAuthTokenLabel"", authTokenType, e);
    }
}",1,,,-1,,[@Override],-1,-1,-1,-1,-1,-1,4,0,"A new condition `if (result != null)` was added before `result.keySet()`; however, the `result` will never be `null` at this point since it is directly initialized before the new condition is checked. This change is categorized as 4 (Other statement changed).","There is no Compatibility Issue because the additional `null` check has no effect on the actual behavior of the method—`result` is already guaranteed to be non-null, and hence the API would not behave any differently in terms of returning values or throwing exceptions. The change is only an unnecessary null check."
800,<android.text.style.AlignmentSpan.Standard: int getSpanTypeId()>,22,23,<android.text.style.AlignmentSpan.Standard: int getSpanTypeId()>,<android.text.style.AlignmentSpan.Standard: int getSpanTypeId()>,0,"{
    return TextUtils.ALIGNMENT_SPAN;
}","{
    return getSpanTypeIdInternal();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation changed from directly returning a constant (TextUtils.ALIGNMENT_SPAN) to calling another method (getSpanTypeIdInternal()), which is a dependent API change. Hence the code change type is 5.","There is no compatibility issue as long as the internal method getSpanTypeIdInternal() returns the same value as TextUtils.ALIGNMENT_SPAN constant. Assuming that getSpanTypeIdInternal() is designed to maintain backward compatibility and return the same value, the CI type is 0. However, without knowing the implementation details of getSpanTypeIdInternal(), it cannot be guaranteed with certainty."
801,<android.app.ContextImpl: void sendBroadcast(Intent)>,22,23,<android.app.ContextImpl: void sendBroadcast(Intent)>,<android.app.ContextImpl: void sendBroadcast(Intent)>,0,"{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess();
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, false, false, getUserId());
    } catch (RemoteException e) {
    }
}","{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess();
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, false, getUserId());
    } catch (RemoteException e) {
        throw new RuntimeException(""Failure from system"", e);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,4",2,"The type of change is exception handling changed, as the new implementation adds a throw statement inside the catch block. Additionally, other statements changed as a parameter passed to broadcastIntent has been modified from 'false' to 'null'; however, this might be a permissible change if 'null' is handled similarly to 'false' in the receiving method. Thus, there is a potential change in the way exceptions are handled, type 2, and a minor change in other statements, type 4.","The introduction of a throw statement within the catch block results in a new RuntimeException being thrown instead of the exception being swallowed. This change can lead to a different exception handling behavior when a RemoteException is caught, which constitutes a change in CI, type 2."
802,"<android.transition.Slide: Animator onAppear(ViewGroup,View,TransitionValues,TransitionValues)>",22,23,"<android.transition.Slide: Animator onAppear(ViewGroup,View,TransitionValues,TransitionValues)>","<android.transition.Slide: Animator onAppear(ViewGroup,View,TransitionValues,TransitionValues)>",0,"{
    if (endValues == null) {
        return null;
    }
    int[] position = (int[]) endValues.values.get(PROPNAME_SCREEN_POSITION);
    float endX = view.getTranslationX();
    float endY = view.getTranslationY();
    float startX = mSlideCalculator.getGoneX(sceneRoot, view);
    float startY = mSlideCalculator.getGoneY(sceneRoot, view);
    return TranslationAnimationCreator.createAnimation(view, endValues, position[0], position[1], startX, startY, endX, endY, sDecelerate);
}","{
    if (endValues == null) {
        return null;
    }
    int[] position = (int[]) endValues.values.get(PROPNAME_SCREEN_POSITION);
    float endX = view.getTranslationX();
    float endY = view.getTranslationY();
    float startX = mSlideCalculator.getGoneX(sceneRoot, view);
    float startY = mSlideCalculator.getGoneY(sceneRoot, view);
    return TranslationAnimationCreator.createAnimation(view, endValues, position[0], position[1], startX, startY, endX, endY, sDecelerate, this);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"There is an additional parameter 'this' in the call to the method createAnimation() in the late version, so it is an instance of change types 1,5.","The additional parameter in the method createAnimation() call could potentially change the behavior of the returned Animator, and therefore there is a potential different return value. Hence, the CI type is 1."
806,<android.app.Activity: void onBackPressed()>,22,23,<android.app.Activity: void onBackPressed()>,<android.app.Activity: void onBackPressed()>,0,"{
    if (mActionBar != null && mActionBar.collapseActionView()) {
        return;
    }
    if (!mFragments.popBackStackImmediate()) {
        finishAfterTransition();
    }
}","{
    if (mActionBar != null && mActionBar.collapseActionView()) {
        return;
    }
    if (!mFragments.getFragmentManager().popBackStackImmediate()) {
        finishAfterTransition();
    }
}",1,"/**
 * Called when the activity has detected the user's press of the back
 * key.  The default implementation simply finishes the current activity,
 * but you can override this to do whatever you want.
 */
","/**
 * Called when the activity has detected the user's press of the back
 * key.  The default implementation simply finishes the current activity,
 * but you can override this to do whatever you want.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"Only the method call has changed from mFragments.popBackStackImmediate() to mFragments.getFragmentManager().popBackStackImmediate(), which means that the dependent API has changed. So the code change type is 5.","There is no Compatibility Issue, provided that getFragmentManager().popBackStackImmediate() has the same behavior as the directly called popBackStackImmediate() method from the earlier version. We assume that the abstraction of getting the FragmentManager before calling popBackStackImmediate() does not alter the behavior of the API's execution concerning return values or exception handling unless otherwise noted about the behavior of these APIs. Thus, the CI type is 0."
807,<android.app.Activity: void setActionBar(Toolbar)>,22,23,<android.app.Activity: void setActionBar(Toolbar)>,<android.app.Activity: void setActionBar(Toolbar)>,0,"{
    if (getActionBar() instanceof WindowDecorActionBar) {
        throw new IllegalStateException(""This Activity already has an action bar supplied "" + ""by the window decor. Do not request Window.FEATURE_ACTION_BAR and set "" + ""android:windowActionBar to false in your theme to use a Toolbar instead."");
    }
    ToolbarActionBar tbab = new ToolbarActionBar(toolbar, getTitle(), this);
    mActionBar = tbab;
    mWindow.setCallback(tbab.getWrappedWindowCallback());
    mActionBar.invalidateOptionsMenu();
}","{
    if (getActionBar() instanceof WindowDecorActionBar) {
        throw new IllegalStateException(""This Activity already has an action bar supplied "" + ""by the window decor. Do not request Window.FEATURE_ACTION_BAR and set "" + ""android:windowActionBar to false in your theme to use a Toolbar instead."");
    }
    // Clear out the MenuInflater to make sure that it is valid for the new Action Bar
    mMenuInflater = null;
    ToolbarActionBar tbab = new ToolbarActionBar(toolbar, getTitle(), this);
    mActionBar = tbab;
    mWindow.setCallback(tbab.getWrappedWindowCallback());
    mActionBar.invalidateOptionsMenu();
}",1,"/**
 * Set a {@link android.widget.Toolbar Toolbar} to act as the {@link ActionBar} for this
 * Activity window.
 *
 * <p>When set to a non-null value the {@link #getActionBar()} method will return
 * an {@link ActionBar} object that can be used to control the given toolbar as if it were
 * a traditional window decor action bar. The toolbar's menu will be populated with the
 * Activity's options menu and the navigation button will be wired through the standard
 * {@link android.R.id#home home} menu select action.</p>
 *
 * <p>In order to use a Toolbar within the Activity's window content the application
 * must not request the window feature {@link Window#FEATURE_ACTION_BAR FEATURE_ACTION_BAR}.</p>
 *
 * @param toolbar Toolbar to set as the Activity's action bar
 */
","/**
 * Set a {@link android.widget.Toolbar Toolbar} to act as the {@link ActionBar} for this
 * Activity window.
 *
 * <p>When set to a non-null value the {@link #getActionBar()} method will return
 * an {@link ActionBar} object that can be used to control the given toolbar as if it were
 * a traditional window decor action bar. The toolbar's menu will be populated with the
 * Activity's options menu and the navigation button will be wired through the standard
 * {@link android.R.id#home home} menu select action.</p>
 *
 * <p>In order to use a Toolbar within the Activity's window content the application
 * must not request the window feature {@link Window#FEATURE_ACTION_BAR FEATURE_ACTION_BAR}.</p>
 *
 * @param toolbar Toolbar to set as the Activity's action bar
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"There is a new statement introduced (mMenuInflater = null;) which does not affect the control flow or the return type/value of the method, so the code change type is 4.","The addition of mMenuInflater = null; does not directly affect the behavior of setActionBar(Toolbar) in terms of its observable actions (such as returning a different value or throwing a new exception). This change simply ensures that the MenuInflater associated with the Activity is reset, which should be an internal detail with no visible impact on the method’s contract or side-effects. Therefore, there should be no Compatibility Issue, and the CI type is 0."
811,<android.app.ContextImpl: void removeStickyBroadcast(Intent)>,22,23,<android.app.ContextImpl: void removeStickyBroadcast(Intent)>,<android.app.ContextImpl: void removeStickyBroadcast(Intent)>,0,"{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    if (resolvedType != null) {
        intent = new Intent(intent);
        intent.setDataAndType(intent.getData(), resolvedType);
    }
    try {
        intent.prepareToLeaveProcess();
        ActivityManagerNative.getDefault().unbroadcastIntent(mMainThread.getApplicationThread(), intent, getUserId());
    } catch (RemoteException e) {
    }
}","{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    if (resolvedType != null) {
        intent = new Intent(intent);
        intent.setDataAndType(intent.getData(), resolvedType);
    }
    try {
        intent.prepareToLeaveProcess();
        ActivityManagerNative.getDefault().unbroadcastIntent(mMainThread.getApplicationThread(), intent, getUserId());
    } catch (RemoteException e) {
        throw new RuntimeException(""Failure from system"", e);
    }
}",1,,,-1,[@Override],"[@Override, @Deprecated]",-1,-1,-1,-1,-1,-1,2,2,"The change is in the exception handling statement; the late version introduces a new throw statement inside the catch block ('throw new RuntimeException(""Failure from system"", e)'), so the code change type is 2.","The newly introduced throw statement in the catch block constitutes a change in the exception handling behavior which could cause the method to throw an unchecked RuntimeException where it previously would not have thrown any exception. This is a potential Compatibility Issue due to a change in the exception handling, and the CI type is 2."
813,<android.content.res.ColorStateList: String toString()>,22,23,<android.content.res.ColorStateList: String toString()>,<android.content.res.ColorStateList: String toString()>,0,"{
    return ""ColorStateList{"" + ""mStateSpecs="" + Arrays.deepToString(mStateSpecs) + ""mColors="" + Arrays.toString(mColors) + ""mDefaultColor="" + mDefaultColor + '}';
}","{
    return ""ColorStateList{"" + ""mThemeAttrs="" + Arrays.deepToString(mThemeAttrs) + ""mChangingConfigurations="" + mChangingConfigurations + ""mStateSpecs="" + Arrays.deepToString(mStateSpecs) + ""mColors="" + Arrays.toString(mColors) + ""mDefaultColor="" + mDefaultColor + '}';
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The string that is returned has additional information in the late version (it includes ""mThemeAttrs="" and ""mChangingConfigurations=""). There is no change in control flow, exception handling, or dependent APIs. Therefore, the change falls under ""Other statement changed"" (4) because the body of the String being returned has extra concatenations, and ""Return statement changed"" (1) as the output of the return statement has been modified.","The new return statement adds additional information about the state of the ColorStateList to the toString result. This means the late version of the API potentially returns a different value from the early version. Thus, the CI type is 1."
814,<android.widget.NumberPicker: void setMaxValue(int)>,22,23,<android.widget.NumberPicker: void setMaxValue(int)>,<android.widget.NumberPicker: void setMaxValue(int)>,0,"{
    if (mMaxValue == maxValue) {
        return;
    }
    if (maxValue < 0) {
        throw new IllegalArgumentException(""maxValue must be >= 0"");
    }
    mMaxValue = maxValue;
    if (mMaxValue < mValue) {
        mValue = mMaxValue;
    }
    boolean wrapSelectorWheel = mMaxValue - mMinValue > mSelectorIndices.length;
    setWrapSelectorWheel(wrapSelectorWheel);
    initializeSelectorWheelIndices();
    updateInputTextView();
    tryComputeMaxWidth();
    invalidate();
}","{
    if (mMaxValue == maxValue) {
        return;
    }
    if (maxValue < 0) {
        throw new IllegalArgumentException(""maxValue must be >= 0"");
    }
    mMaxValue = maxValue;
    if (mMaxValue < mValue) {
        mValue = mMaxValue;
    }
    updateWrapSelectorWheel();
    initializeSelectorWheelIndices();
    updateInputTextView();
    tryComputeMaxWidth();
    invalidate();
}",1,"/**
 * Sets the max value of the picker.
 *
 * @param maxValue The max value inclusive.
 *
 * <strong>Note:</strong> The length of the displayed values array
 * set via {@link #setDisplayedValues(String[])} must be equal to the
 * range of selectable numbers which is equal to
 * {@link #getMaxValue()} - {@link #getMinValue()} + 1.
 */
","/**
 * Sets the max value of the picker.
 *
 * @param maxValue The max value inclusive.
 *
 * <strong>Note:</strong> The length of the displayed values array
 * set via {@link #setDisplayedValues(String[])} must be equal to the
 * range of selectable numbers which is equal to
 * {@link #getMaxValue()} - {@link #getMinValue()} + 1.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The code change is that the updateWrapSelectorWheel() method is called instead of setting wrapSelectorWheel boolean and calling setWrapSelectorWheel(wrapSelectorWheel) method, so the change type is 5 (Dependent API changed).","There is no new exception handling or different return type/value introduced because of this change. The change should be internal, assuming that the behavior of updateWrapSelectorWheel internally ensures the same state as the previous implementation. Therefore, there should be no Compatibility Issue, and the CI type is 0."
815,"<android.app.ApplicationPackageManager: List<ProviderInfo> queryContentProviders(String,int,int)>",22,23,"<android.app.ApplicationPackageManager: List<ProviderInfo> queryContentProviders(String,int,int)>","<android.app.ApplicationPackageManager: List<ProviderInfo> queryContentProviders(String,int,int)>",0,"{
    try {
        return mPM.queryContentProviders(processName, uid, flags);
    } catch (RemoteException e) {
        throw new RuntimeException(""Package manager has died"", e);
    }
}","{
    try {
        ParceledListSlice<ProviderInfo> slice = mPM.queryContentProviders(processName, uid, flags);
        return slice != null ? slice.getList() : null;
    } catch (RemoteException e) {
        throw new RuntimeException(""Package manager has died"", e);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,"The return statement was changed to include additional logic and unwrap a `ParceledListSlice<ProviderInfo>` to obtain the list. Additionally, there is a new variable declaration (`ParceledListSlice<ProviderInfo> slice`). The late version also includes a null check to handle the case where `slice` is null, which is a control dependency change, and the return type might be different because of this null check (i.e., the method now may return null). Altogether, the relevant change types are 1 (return statement changed), 3 (control dependency changed), and 4 (other statement changed).","The change introduces a new way of obtaining the list from `ParceledListSlice<ProviderInfo>` and adds a null check, which can potentially change the returned value. Previous version directly returns the result from `mPM.queryContentProviders()`, now the late version may return null if `slice` is null. A client expecting a non-null list from previous versions might now receive null, so there is a CI caused by potentially different return values, which is of type 1."
816,"<android.widget.RadialTimePickerView.RadialPickerTouchHelper: int getVirtualViewAt(float,float)>",22,23,"<android.widget.RadialTimePickerView.RadialPickerTouchHelper: int getVirtualViewAt(float,float)>","<android.widget.RadialTimePickerView.RadialPickerTouchHelper: int getVirtualViewAt(float,float)>",0,"{
    final int id;
    // Calling getDegreesXY() has side-effects, so we need to cache the
    // current inner circle value and restore after the call.
    final boolean wasOnInnerCircle = mIsOnInnerCircle;
    final int degrees = getDegreesFromXY(x, y);
    final boolean isOnInnerCircle = mIsOnInnerCircle;
    mIsOnInnerCircle = wasOnInnerCircle;
    if (degrees != -1) {
        final int snapDegrees = snapOnly30s(degrees, 0) % 360;
        if (mShowHours) {
            final int hour24 = getHourForDegrees(snapDegrees, isOnInnerCircle);
            final int hour = mIs24HourMode ? hour24 : hour24To12(hour24);
            id = makeId(TYPE_HOUR, hour);
        } else {
            final int current = getCurrentMinute();
            final int touched = getMinuteForDegrees(degrees);
            final int snapped = getMinuteForDegrees(snapDegrees);
            // If the touched minute is closer to the current minute
            // than it is to the snapped minute, return current.
            final int minute;
            if (Math.abs(current - touched) < Math.abs(snapped - touched)) {
                minute = current;
            } else {
                minute = snapped;
            }
            id = makeId(TYPE_MINUTE, minute);
        }
    } else {
        id = INVALID_ID;
    }
    return id;
}","{
    final int id;
    final int degrees = getDegreesFromXY(x, y, true);
    if (degrees != -1) {
        final int snapDegrees = snapOnly30s(degrees, 0) % 360;
        if (mShowHours) {
            final boolean isOnInnerCircle = getInnerCircleFromXY(x, y);
            final int hour24 = getHourForDegrees(snapDegrees, isOnInnerCircle);
            final int hour = mIs24HourMode ? hour24 : hour24To12(hour24);
            id = makeId(TYPE_HOUR, hour);
        } else {
            final int current = getCurrentMinute();
            final int touched = getMinuteForDegrees(degrees);
            final int snapped = getMinuteForDegrees(snapDegrees);
            // If the touched minute is closer to the current minute
            // than it is to the snapped minute, return current.
            final int currentOffset = getCircularDiff(current, touched, MINUTES_IN_CIRCLE);
            final int snappedOffset = getCircularDiff(snapped, touched, MINUTES_IN_CIRCLE);
            final int minute;
            if (currentOffset < snappedOffset) {
                minute = current;
            } else {
                minute = snapped;
            }
            id = makeId(TYPE_MINUTE, minute);
        }
    } else {
        id = INVALID_ID;
    }
    return id;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4,5",1,"The late version of the implementation has removed the wasOnInnerCircle and isOnInnerCircle variables and instead calculates isOnInnerCircle inside the if (mShowHours) block. The calculation of minute has also been refactored from simple subtraction to a getCircularDiff method. These both account for changes in other statements and control dependencies. Additionally, the call to getDegreesFromXY now has an additional boolean parameter. Such a change in the method call's parameter indicates that the dependent API getDegreesFromXY has changed, which can have an impact on the behavior of getVirtualViewAt.","The removal of wasOnInnerCircle and isOnInnerCircle, and the subsequent change in determining isOnInnerCircle affect how the method behaves when determining if the user is touching the inner circle. The changed logic for calculating minute using getCircularDiff method also affects the control dependency on how minute is computed which could cause a different return value. The addition of a boolean parameter to the getDegreesFromXY indicates the method it depends on has likely changed functionality or expected behavior. All these factors potentially alter the returned id value which leads to a CI of type 1."
817,<android.os.StrictMode: void setVmPolicy(VmPolicy)>,22,23,<android.os.StrictMode: void setVmPolicy(VmPolicy)>,<android.os.StrictMode: void setVmPolicy(VmPolicy)>,0,"{
    synchronized (StrictMode.class) {
        sVmPolicy = policy;
        sVmPolicyMask = policy.mask;
        setCloseGuardEnabled(vmClosableObjectLeaksEnabled());
        Looper looper = Looper.getMainLooper();
        if (looper != null) {
            MessageQueue mq = looper.mQueue;
            if (policy.classInstanceLimit.size() == 0 || (sVmPolicyMask & VM_PENALTY_MASK) == 0) {
                mq.removeIdleHandler(sProcessIdleHandler);
                sIsIdlerRegistered = false;
            } else if (!sIsIdlerRegistered) {
                mq.addIdleHandler(sProcessIdleHandler);
                sIsIdlerRegistered = true;
            }
        }
    }
}","{
    synchronized (StrictMode.class) {
        sVmPolicy = policy;
        sVmPolicyMask = policy.mask;
        setCloseGuardEnabled(vmClosableObjectLeaksEnabled());
        Looper looper = Looper.getMainLooper();
        if (looper != null) {
            MessageQueue mq = looper.mQueue;
            if (policy.classInstanceLimit.size() == 0 || (sVmPolicyMask & VM_PENALTY_MASK) == 0) {
                mq.removeIdleHandler(sProcessIdleHandler);
                sIsIdlerRegistered = false;
            } else if (!sIsIdlerRegistered) {
                mq.addIdleHandler(sProcessIdleHandler);
                sIsIdlerRegistered = true;
            }
        }
        int networkPolicy = NETWORK_POLICY_ACCEPT;
        if ((sVmPolicyMask & DETECT_VM_CLEARTEXT_NETWORK) != 0) {
            if ((sVmPolicyMask & PENALTY_DEATH) != 0 || (sVmPolicyMask & PENALTY_DEATH_ON_CLEARTEXT_NETWORK) != 0) {
                networkPolicy = NETWORK_POLICY_REJECT;
            } else {
                networkPolicy = NETWORK_POLICY_LOG;
            }
        }
        final INetworkManagementService netd = INetworkManagementService.Stub.asInterface(ServiceManager.getService(Context.NETWORKMANAGEMENT_SERVICE));
        if (netd != null) {
            try {
                netd.setUidCleartextNetworkPolicy(android.os.Process.myUid(), networkPolicy);
            } catch (RemoteException ignored) {
            }
        } else if (networkPolicy != NETWORK_POLICY_ACCEPT) {
            Log.w(TAG, ""Dropping requested network policy due to missing service!"");
        }
    }
}",1,"/**
 * Sets the policy for what actions in the VM process (on any
 * thread) should be detected, as well as the penalty if such
 * actions occur.
 *
 * @param policy the policy to put into place
 */
","/**
 * Sets the policy for what actions in the VM process (on any
 * thread) should be detected, as well as the penalty if such
 * actions occur.
 *
 * @param policy the policy to put into place
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"Control dependency and other statements have been added concerning setting network policies at the end of the late version of the method. New variables, conditionals, and a service call to `INetworkManagementService` have been introduced in the late implementation, thus the relevant change types are 3 and 4.","The late implementation version introduces additional behaviour related to setting up network policy that can affect the VM policy's enforcement. This particular change does not introduce a new return statement or exception handling in relation to the existing functionality but does add new functionality that influences the overall system behaviour, which can potentially cause a Compatibility Issue in the enactment of the VM policy, so the CI type is 1."
818,<android.widget.Editor.HandleView: void updateDrawable()>,22,23,<android.widget.Editor.HandleView: void updateDrawable()>,<android.widget.Editor.HandleView: void updateDrawable()>,0,"{
    final int offset = getCurrentCursorOffset();
    final boolean isRtlCharAtOffset = mTextView.getLayout().isRtlCharAt(offset);
    mDrawable = isRtlCharAtOffset ? mDrawableRtl : mDrawableLtr;
    mHotspotX = getHotspotX(mDrawable, isRtlCharAtOffset);
    mHorizontalGravity = getHorizontalGravity(isRtlCharAtOffset);
}","{
    if (mIsDragging) {
        // Don't update drawable during dragging.
        return;
    }
    final int offset = getCurrentCursorOffset();
    final boolean isRtlCharAtOffset = mTextView.getLayout().isRtlCharAt(offset);
    final Drawable oldDrawable = mDrawable;
    mDrawable = isRtlCharAtOffset ? mDrawableRtl : mDrawableLtr;
    mHotspotX = getHotspotX(mDrawable, isRtlCharAtOffset);
    mHorizontalGravity = getHorizontalGravity(isRtlCharAtOffset);
    final Layout layout = mTextView.getLayout();
    if (layout != null && oldDrawable != mDrawable && isShowing()) {
        // Update popup window position.
        mPositionX = (int) (layout.getPrimaryHorizontal(offset) - 0.5f - mHotspotX - getHorizontalOffset() + getCursorOffset());
        mPositionX += mTextView.viewportToContentHorizontalOffset();
        mPositionHasChanged = true;
        updatePosition(mLastParentX, mLastParentY, false, false);
        postInvalidate();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The late version includes a new control statement 'if (mIsDragging)' with a return statement inside it, and adds some new statements at the end of the method which may alter the 'mDrawable' value and update the view position. These are changes in control dependency and other statements which were not present in the early version. Hence the code change type is 1,3.","The addition of the 'if' control statement could potentially lead to a non-execution of the rest of the method if 'mIsDragging' is true. As a result, the drawable might not get updated when it would have been in the early version, which can lead to a different behavior (returning early without updating the drawable) and thus, CI type is 1."
819,<android.animation.ValueAnimator: boolean doAnimationFrame(long)>,22,23,<android.animation.ValueAnimator: boolean doAnimationFrame(long)>,<android.animation.ValueAnimator: boolean doAnimationFrame(long)>,0,"{
    if (mPlayingState == STOPPED) {
        mPlayingState = RUNNING;
        if (mSeekFraction < 0) {
            mStartTime = frameTime;
        } else {
            long seekTime = (long) (mDuration * mSeekFraction);
            mStartTime = frameTime - seekTime;
            mSeekFraction = -1;
        }
    }
    if (mPaused) {
        if (mPauseTime < 0) {
            mPauseTime = frameTime;
        }
        return false;
    } else if (mResumed) {
        mResumed = false;
        if (mPauseTime > 0) {
            // Offset by the duration that the animation was paused
            mStartTime += (frameTime - mPauseTime);
        }
    }
    // The frame time might be before the start time during the first frame of
    // an animation.  The ""current time"" must always be on or after the start
    // time to avoid animating frames at negative time intervals.  In practice, this
    // is very rare and only happens when seeking backwards.
    final long currentTime = Math.max(frameTime, mStartTime);
    return animationFrame(currentTime);
}","{
    if (mPlayingState == STOPPED) {
        mPlayingState = RUNNING;
        if (mSeekFraction < 0) {
            mStartTime = frameTime;
        } else {
            long seekTime = (long) (mDuration * mSeekFraction);
            mStartTime = frameTime - seekTime;
            mSeekFraction = -1;
        }
        // allow start time to be compensated for jank
        mStartTimeCommitted = false;
    }
    if (mPaused) {
        if (mPauseTime < 0) {
            mPauseTime = frameTime;
        }
        return false;
    } else if (mResumed) {
        mResumed = false;
        if (mPauseTime > 0) {
            // Offset by the duration that the animation was paused
            mStartTime += (frameTime - mPauseTime);
            // allow start time to be compensated for jank
            mStartTimeCommitted = false;
        }
    }
    // The frame time might be before the start time during the first frame of
    // an animation.  The ""current time"" must always be on or after the start
    // time to avoid animating frames at negative time intervals.  In practice, this
    // is very rare and only happens when seeking backwards.
    final long currentTime = Math.max(frameTime, mStartTime);
    return animationFrame(currentTime);
}",1,"/**
 * Processes a frame of the animation, adjusting the start time if needed.
 *
 * @param frameTime The frame time.
 * @return true if the animation has ended.
 */
","/**
 * Processes a frame of the animation, adjusting the start time if needed.
 *
 * @param frameTime The frame time.
 * @return true if the animation has ended.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change in the method implementation is the addition of a statement to set `mStartTimeCommitted` to `false`, which is considered as ""Other statement changed"". ","The new statement that assigns a value to `mStartTimeCommitted` does not affect any return statements or exception handling mechanism within the method. The method's return behavior remains based on the `animationFrame(currentTime)` call, and exception handling has not been modified. Hence, there are no Compatibility Issues as the change has no impact on the method's output or potential exceptions thrown."
821,<android.bluetooth.BluetoothAdapter: boolean isOffloadedFilteringSupported()>,22,23,<android.bluetooth.BluetoothAdapter: boolean isOffloadedFilteringSupported()>,<android.bluetooth.BluetoothAdapter: boolean isOffloadedFilteringSupported()>,0,"{
    if (getState() != STATE_ON)
        return false;
    try {
        return mService.isOffloadedFilteringSupported();
    } catch (RemoteException e) {
        Log.e(TAG, ""failed to get isOffloadedFilteringSupported, error: "", e);
    }
    return false;
}","{
    if (!getLeAccess())
        return false;
    try {
        return mService.isOffloadedFilteringSupported();
    } catch (RemoteException e) {
        Log.e(TAG, ""failed to get isOffloadedFilteringSupported, error: "", e);
    }
    return false;
}",1,"/**
 * Return true if offloaded filters are supported
 *
 * @return true if chipset supports on-chip filtering
 */
","/**
 * Return true if offloaded filters are supported
 *
 * @return true if chipset supports on-chip filtering
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,5",1,"The control dependency has changed - it went from checking if the state is STATE_ON to checking getLeAccess(). The dependent API changed from getState() to getLeAccess(), so the code change includes types 3 and 5.","The change in the control dependency may lead to different return values because the condition for returning false has changed from the Bluetooth adapter state being on to whether LE access is available. Hence, it could potentially cause the API to return different values, thus the CI type is 1."
822,"<android.app.admin.DevicePolicyManager: void setPasswordMinimumUpperCase(ComponentName,int)>",22,23,"<android.app.admin.DevicePolicyManager: void setPasswordMinimumUpperCase(ComponentName,int)>","<android.app.admin.DevicePolicyManager: void setPasswordMinimumUpperCase(ComponentName,int)>",0,"{
    if (mService != null) {
        try {
            mService.setPasswordMinimumUpperCase(admin, length, UserHandle.myUserId());
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    if (mService != null) {
        try {
            mService.setPasswordMinimumUpperCase(admin, length);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}",1,"/**
 * Called by an application that is administering the device to set the
 * minimum number of upper case letters required in the password. After
 * setting this, the user will not be able to enter a new password that is
 * not at least as restrictive as what has been set. Note that the current
 * password will remain until the user has set a new one, so the change does
 * not take place immediately. To prompt the user for a new password, use
 * {@link #ACTION_SET_NEW_PASSWORD} after setting this value. This
 * constraint is only imposed if the administrator has also requested
 * {@link #PASSWORD_QUALITY_COMPLEX} with {@link #setPasswordQuality}. The
 * default value is 0.
 * <p>
 * The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call
 * this method; if it has not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated
 * with.
 * @param length The new desired minimum number of upper case letters
 * required in the password. A value of 0 means there is no
 * restriction.
 */
","/**
 * Called by an application that is administering the device to set the
 * minimum number of upper case letters required in the password. After
 * setting this, the user will not be able to enter a new password that is
 * not at least as restrictive as what has been set. Note that the current
 * password will remain until the user has set a new one, so the change does
 * not take place immediately. To prompt the user for a new password, use
 * {@link #ACTION_SET_NEW_PASSWORD} after setting this value. This
 * constraint is only imposed if the administrator has also requested
 * {@link #PASSWORD_QUALITY_COMPLEX} with {@link #setPasswordQuality}. The
 * default value is 0.
 * <p>
 * The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call
 * this method; if it has not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated
 * with.
 * @param length The new desired minimum number of upper case letters
 * required in the password. A value of 0 means there is no
 * restriction.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent API setPasswordMinimumUpperCase invoked by the method has changed its signature — it no longer requires the UserHandle.myUserId() parameter. This is classified as a dependent API change, so the code change type is 5.","The removal of UserHandle.myUserId() as a parameter in the internal call to mService.setPasswordMinimumUpperCase() does not constitute a compatibility issue by itself since it's an implementation detail from the perspective of the method's callers. The method's signature has not changed, and there's no evidence in the change presented here that this would lead to different behaviors observable to callers, such as different return types/values or exceptions being thrown. Thus, there's no compatibility issue introduced, so the CI type is 0."
823,<android.service.voice.VoiceInteractionSession: Request removeRequest(IBinder)>,22,23,<android.service.voice.VoiceInteractionSession: Request removeRequest(IBinder)>,<android.service.voice.VoiceInteractionSession: Request removeRequest(IBinder)>,0,"{
    synchronized (this) {
        Request req = mActiveRequests.get(reqInterface);
        if (req != null) {
            mActiveRequests.remove(req);
        }
        return req;
    }
}","{
    synchronized (this) {
        return mActiveRequests.remove(reqInterface);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,1,1,"The late version combines the retrieval and removal of the request object into one line using `mActiveRequests.remove(reqInterface)` instead of first getting the object and then removing it if it isn't null as in the early version. Therefore, the return statement has changed, which is indicated by change type 1.","The early version returns null if the `req` object is not in the `mActiveRequests`, while the late version will return the result of the `remove` method directly, which could be different if the `reqInterface` being removed is not present in the map. This could cause a change in the return value, specifically when `reqInterface` is not present, as it would return `null` in the early version, but potentially a default value or exception in the late version depending on the `remove` method's implementation. Thus, the CI type is 1."
824,<android.app.LoaderManagerImpl: void destroyLoader(int)>,22,23,<android.app.LoaderManagerImpl: void destroyLoader(int)>,<android.app.LoaderManagerImpl: void destroyLoader(int)>,0,"{
    if (mCreatingLoader) {
        throw new IllegalStateException(""Called while creating a loader"");
    }
    if (DEBUG)
        Log.v(TAG, ""destroyLoader in "" + this + "" of "" + id);
    int idx = mLoaders.indexOfKey(id);
    if (idx >= 0) {
        LoaderInfo info = mLoaders.valueAt(idx);
        mLoaders.removeAt(idx);
        info.destroy();
    }
    idx = mInactiveLoaders.indexOfKey(id);
    if (idx >= 0) {
        LoaderInfo info = mInactiveLoaders.valueAt(idx);
        mInactiveLoaders.removeAt(idx);
        info.destroy();
    }
    if (mActivity != null && !hasRunningLoaders()) {
        mActivity.mFragments.startPendingDeferredFragments();
    }
}","{
    if (mCreatingLoader) {
        throw new IllegalStateException(""Called while creating a loader"");
    }
    if (DEBUG)
        Log.v(TAG, ""destroyLoader in "" + this + "" of "" + id);
    int idx = mLoaders.indexOfKey(id);
    if (idx >= 0) {
        LoaderInfo info = mLoaders.valueAt(idx);
        mLoaders.removeAt(idx);
        info.destroy();
    }
    idx = mInactiveLoaders.indexOfKey(id);
    if (idx >= 0) {
        LoaderInfo info = mInactiveLoaders.valueAt(idx);
        mInactiveLoaders.removeAt(idx);
        info.destroy();
    }
    if (mHost != null && !hasRunningLoaders()) {
        mHost.mFragmentManager.startPendingDeferredFragments();
    }
}",1,"/**
 * Rip down, tear apart, shred to pieces a current Loader ID.  After returning
 * from this function, any Loader objects associated with this ID are
 * destroyed.  Any data associated with them is destroyed.  You better not
 * be using it when you do this.
 * @param id Identifier of the Loader to be destroyed.
 */
","/**
 * Rip down, tear apart, shred to pieces a current Loader ID.  After returning
 * from this function, any Loader objects associated with this ID are
 * destroyed.  Any data associated with them is destroyed.  You better not
 * be using it when you do this.
 * @param id Identifier of the Loader to be destroyed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change in the code is the replacement of `mActivity` with `mHost`. This reflects an update to the internal API where the fragment management is probably being migrated from the Activity (`mActivity`) to a more generalized Host (`mHost`), hence the type is 4.","There are no changes that affect the behavior exposed to the user of the API. The method's signature remains the same, and no new return statements or exception throwing have been introduced. Therefore, there is no compatibility issue - the API should behave the same from a caller's perspective."
825,<android.text.SpannableStringBuilder: int getSpanEnd(Object)>,22,23,<android.text.SpannableStringBuilder: int getSpanEnd(Object)>,<android.text.SpannableStringBuilder: int getSpanEnd(Object)>,0,"{
    int count = mSpanCount;
    Object[] spans = mSpans;
    for (int i = count - 1; i >= 0; i--) {
        if (spans[i] == what) {
            int where = mSpanEnds[i];
            if (where > mGapStart)
                where -= mGapLength;
            return where;
        }
    }
    return -1;
}","{
    if (mIndexOfSpan == null)
        return -1;
    Integer i = mIndexOfSpan.get(what);
    return i == null ? -1 : resolveGap(mSpanEnds[i]);
}",1,"/**
 * Return the buffer offset of the end of the specified
 * markup object, or -1 if it is not attached to this buffer.
 */
","/**
 * Return the buffer offset of the end of the specified
 * markup object, or -1 if it is not attached to this buffer.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The method implementation changed significantly. New control structures (if-statement) were introduced. It uses a hashmap (mIndexOfSpan) instead of an array to find the index, and has a new method call (resolveGap). Thus, there are changes in return statements, control dependency, other statements, and dependent APIs due to resolveGap being a new method, the change types are 1,3,4,5.","The method's logic has been substantially altered to use a hashmap for finding span index, and a different calculation of the span end possibly resulting in different return values. This would cause the method to potentially return different values, therefore, the CI type is 1."
830,<android.app.ActivityManager: boolean isInLockTaskMode()>,22,23,<android.app.ActivityManager: boolean isInLockTaskMode()>,<android.app.ActivityManager: boolean isInLockTaskMode()>,0,"{
    try {
        return ActivityManagerNative.getDefault().isInLockTaskMode();
    } catch (RemoteException e) {
        return false;
    }
}","{
    return getLockTaskModeState() != LOCK_TASK_MODE_NONE;
}",1,"/**
 * Return whether currently in lock task mode.  When in this mode
 * no new tasks can be created or switched to.
 *
 * @see Activity#startLockTask()
 */
","/**
 * Return whether currently in lock task mode.  When in this mode
 * no new tasks can be created or switched to.
 *
 * @see Activity#startLockTask()
 *
 * @deprecated Use {@link #getLockTaskModeState} instead.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation of the method has completely changed. The early version calls a method on the ActivityManagerNative class to check if it is in lock task mode, which returns a boolean. The late version uses the getLockTaskModeState() method to obtain an int state and compares it with LOCK_TASK_MODE_NONE, thus the method now depends on the implementation of getLockTaskModeState() which could be considered a Dependent API change. Therefore, the code change types are 1 and 5.","Since the late version of the method uses a different approach to determine if the app is in lock task mode, it could potentially return a different value than the early version. The change in the logic to determine the lock task mode status constitutes a return statement change that could lead to a different result. Hence, the CI type is 1."
831,"<android.content.res.TypedArray: float getDimension(int,float)>",22,23,"<android.content.res.TypedArray: float getDimension(int,float)>","<android.content.res.TypedArray: float getDimension(int,float)>",0,"{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimension(data[index + AssetManager.STYLE_DATA], mMetrics);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        throw new RuntimeException(""Failed to resolve attribute at index "" + index);
    }
    throw new UnsupportedOperationException(""Can't convert to dimension: type=0x"" + Integer.toHexString(type));
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimension(data[index + AssetManager.STYLE_DATA], mMetrics);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, value);
        throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + index + "": "" + value);
    }
    throw new UnsupportedOperationException(""Can't convert to dimension: type=0x"" + Integer.toHexString(type));
}",1,"/**
 * Retrieve a dimensional unit attribute at <var>index</var>.  Unit
 * conversions are based on the current {@link DisplayMetrics}
 * associated with the resources this {@link TypedArray} object
 * came from.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric, or defValue if not defined.
 *
 * @see #getDimensionPixelOffset
 * @see #getDimensionPixelSize
 */
","/**
 * Retrieve a dimensional unit attribute at <var>index</var>. Unit
 * conversions are based on the current {@link DisplayMetrics}
 * associated with the resources this {@link TypedArray} object
 * came from.
 * <p>
 * This method will throw an exception if the attribute is defined but is
 * not a dimension.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric, or defValue if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not an integer.
 *
 * @see #getDimensionPixelOffset
 * @see #getDimensionPixelSize
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"There is a new call to getValueAt() method inside the 'else if' block for TYPE_ATTRIBUTE, which modifies the content of the message inside the thrown UnsupportedOperationException, so the code change type is 4.","Though there is an additional method call, this does not lead to a Compatibility Issue since it just adds more details to the thrown exception's message without altering the program's flow compared to the early version. The type of exception thrown for TYPE_ATTRIBUTE remains the same, it's simply more descriptive in the late version. Thus, there is no CI."
832,"<android.app.ContextImpl: boolean startInstrumentation(ComponentName,String,Bundle)>",22,23,"<android.app.ContextImpl: boolean startInstrumentation(ComponentName,String,Bundle)>","<android.app.ContextImpl: boolean startInstrumentation(ComponentName,String,Bundle)>",0,"{
    try {
        if (arguments != null) {
            arguments.setAllowFds(false);
        }
        return ActivityManagerNative.getDefault().startInstrumentation(className, profileFile, 0, arguments, null, null, getUserId(), null);
    } catch (RemoteException e) {
    // System has crashed, nothing we can do.
    }
    return false;
}","{
    try {
        if (arguments != null) {
            arguments.setAllowFds(false);
        }
        return ActivityManagerNative.getDefault().startInstrumentation(className, profileFile, 0, arguments, null, null, getUserId(), null);
    } catch (RemoteException e) {
        throw new RuntimeException(""Failure from system"", e);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement changed between the versions. In the early version, the catch block for RemoteException is empty, while in the late version, it throws a new RuntimeException. This is a change type 2.","Because the new code throws a RuntimeException instead of silently failing, the behavior of the API in terms of exception handling has changed, which may affect clients that call this method expecting no exception to be thrown. Therefore, the CI type is 2."
834,"<android.widget.AbsSeekBar: boolean onKeyDown(int,KeyEvent)>",22,23,"<android.widget.AbsSeekBar: boolean onKeyDown(int,KeyEvent)>","<android.widget.AbsSeekBar: boolean onKeyDown(int,KeyEvent)>",0,"{
    if (isEnabled()) {
        int progress = getProgress();
        switch(keyCode) {
            case KeyEvent.KEYCODE_DPAD_LEFT:
                if (progress <= 0)
                    break;
                setProgress(progress - mKeyProgressIncrement, true);
                onKeyChange();
                return true;
            case KeyEvent.KEYCODE_DPAD_RIGHT:
                if (progress >= getMax())
                    break;
                setProgress(progress + mKeyProgressIncrement, true);
                onKeyChange();
                return true;
        }
    }
    return super.onKeyDown(keyCode, event);
}","{
    if (isEnabled()) {
        int increment = mKeyProgressIncrement;
        switch(keyCode) {
            case KeyEvent.KEYCODE_DPAD_LEFT:
                increment = -increment;
            // fallthrough
            case KeyEvent.KEYCODE_DPAD_RIGHT:
                increment = isLayoutRtl() ? -increment : increment;
                // Let progress bar handle clamping values.
                if (setProgress(getProgress() + increment, true)) {
                    onKeyChange();
                    return true;
                }
                break;
        }
    }
    return super.onKeyDown(keyCode, event);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",0,The following changes have been made in the late version of the implementation:,- Logical condition added: `increment = isLayoutRtl() ? -increment : increment;` that takes into account layout direction.
835,<android.content.ContentResolver: void unregisterContentObserver(ContentObserver)>,22,23,<android.content.ContentResolver: void unregisterContentObserver(ContentObserver)>,<android.content.ContentResolver: void unregisterContentObserver(ContentObserver)>,0,"{
    try {
        IContentObserver contentObserver = observer.releaseContentObserver();
        if (contentObserver != null) {
            getContentService().unregisterContentObserver(contentObserver);
        }
    } catch (RemoteException e) {
    }
}","{
    Preconditions.checkNotNull(observer, ""observer"");
    try {
        IContentObserver contentObserver = observer.releaseContentObserver();
        if (contentObserver != null) {
            getContentService().unregisterContentObserver(contentObserver);
        }
    } catch (RemoteException e) {
    }
}",1,"/**
 * Unregisters a change observer.
 *
 * @param observer The previously registered observer that is no longer needed.
 * @see #registerContentObserver
 */
","/**
 * Unregisters a change observer.
 *
 * @param observer The previously registered observer that is no longer needed.
 * @see #registerContentObserver
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"An additional statement, `Preconditions.checkNotNull(observer, ""observer"")`, is added in the first line of the method, which checks if the `observer` is not null before proceeding. This change is of type 4: Other statement changed.","There is no Compatibility Issue here since the added precondition check does not alter the behavior of the API in terms of return values or exception handling. Existing correct usage of the method (with a non-null observer) will behave the same way. Incorrect usage that previously would have potentially resulted in a NullPointerException due to a null observer will now throw a deliberate, clear exception. So the change is safe and does not introduce a Compatibility Issue."
836,<android.content.IntentFilter: int matchDataAuthority(Uri)>,22,23,<android.content.IntentFilter: int matchDataAuthority(Uri)>,<android.content.IntentFilter: int matchDataAuthority(Uri)>,0,"{
    if (mDataAuthorities == null) {
        return NO_MATCH_DATA;
    }
    final int numDataAuthorities = mDataAuthorities.size();
    for (int i = 0; i < numDataAuthorities; i++) {
        final AuthorityEntry ae = mDataAuthorities.get(i);
        int match = ae.match(data);
        if (match >= 0) {
            return match;
        }
    }
    return NO_MATCH_DATA;
}","{
    if (mDataAuthorities == null || data == null) {
        return NO_MATCH_DATA;
    }
    final int numDataAuthorities = mDataAuthorities.size();
    for (int i = 0; i < numDataAuthorities; i++) {
        final AuthorityEntry ae = mDataAuthorities.get(i);
        int match = ae.match(data);
        if (match >= 0) {
            return match;
        }
    }
    return NO_MATCH_DATA;
}",1,"/**
 * Match this intent filter against the given Intent data.  This ignores
 * the data scheme -- unlike {@link #matchData}, the authority will match
 * regardless of whether there is a matching scheme.
 *
 * @param data The data whose authority is being looked for.
 *
 * @return Returns either {@link #MATCH_CATEGORY_HOST},
 * {@link #MATCH_CATEGORY_PORT}, {@link #NO_MATCH_DATA}.
 */
","/**
 * Match this intent filter against the given Intent data.  This ignores
 * the data scheme -- unlike {@link #matchData}, the authority will match
 * regardless of whether there is a matching scheme.
 *
 * @param data The data whose authority is being looked for.
 *
 * @return Returns either {@link #MATCH_CATEGORY_HOST},
 * {@link #MATCH_CATEGORY_PORT}, {@link #NO_MATCH_DATA}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"An additional condition `data == null` was added to an if-statement. This is a control dependency change, marked as 3.","The change in the if-statement condition could result in a different return value when `data` is null – instead of proceeding to match the data against the authorities, it will now return `NO_MATCH_DATA` early. Hence, this change can potentially cause a different return value, leading to a compatibility issue of type 1."
837,<android.bluetooth.le.ScanSettings.Builder: ScanSettings build()>,22,23,<android.bluetooth.le.ScanSettings.Builder: ScanSettings build()>,<android.bluetooth.le.ScanSettings.Builder: ScanSettings build()>,0,"{
    return new ScanSettings(mScanMode, mCallbackType, mScanResultType, mReportDelayMillis);
}","{
    return new ScanSettings(mScanMode, mCallbackType, mScanResultType, mReportDelayMillis, mMatchMode, mNumOfMatchesPerFilter);
}",1,"/**
 * Build {@link ScanSettings}.
 */
","/**
 * Build {@link ScanSettings}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The constructor for ScanSettings has changed, additional parameters (mMatchMode, mNumOfMatchesPerFilter) are included in the late version. This results in a change in the return statement since different parameters are passed. Therefore, the code change type is 1,5.","The return value is different between versions because the late version includes additional parameters in the constructor of ScanSettings, which could change the behavior and state of the returned ScanSettings object. Consequently, the CI type is 1."
838,<android.widget.OverScroller.SplineOverScroller: boolean continueWhenFinished()>,22,23,<android.widget.OverScroller.SplineOverScroller: boolean continueWhenFinished()>,<android.widget.OverScroller.SplineOverScroller: boolean continueWhenFinished()>,0,"{
    switch(mState) {
        case SPLINE:
            // Duration from start to null velocity
            if (mDuration < mSplineDuration) {
                // If the animation was clamped, we reached the edge
                mStart = mFinal;
                // TODO Better compute speed when edge was reached
                mVelocity = (int) mCurrVelocity;
                mDeceleration = getDeceleration(mVelocity);
                mStartTime += mDuration;
                onEdgeReached();
            } else {
                // Normal stop, no need to continue
                return false;
            }
            break;
        case BALLISTIC:
            mStartTime += mDuration;
            startSpringback(mFinal, mStart, 0);
            break;
        case CUBIC:
            return false;
    }
    update();
    return true;
}","{
    switch(mState) {
        case SPLINE:
            // Duration from start to null velocity
            if (mDuration < mSplineDuration) {
                // If the animation was clamped, we reached the edge
                mCurrentPosition = mStart = mFinal;
                // TODO Better compute speed when edge was reached
                mVelocity = (int) mCurrVelocity;
                mDeceleration = getDeceleration(mVelocity);
                mStartTime += mDuration;
                onEdgeReached();
            } else {
                // Normal stop, no need to continue
                return false;
            }
            break;
        case BALLISTIC:
            mStartTime += mDuration;
            startSpringback(mFinal, mStart, 0);
            break;
        case CUBIC:
            return false;
    }
    update();
    return true;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change in the code is the addition of `mCurrentPosition = mStart = mFinal;` in the `SPLINE` case of the switch statement. This is an assignment change and does not affect the return statements or exception handling code, so the change type is 4 (""Other statement changed"").","The change in assignment does not alter the method's control flow or externally observable behavior regarding its return value or the exceptions it might throw. Therefore, the addition of the `mCurrentPosition` assignment should not cause a compatibility issue, so the CI type is 0 (""No Compatibility Issue"")."
839,<android.webkit.WebView: PrintDocumentAdapter createPrintDocumentAdapter(String)>,22,23,<android.webkit.WebView: PrintDocumentAdapter createPrintDocumentAdapter(String)>,<android.webkit.WebView: PrintDocumentAdapter createPrintDocumentAdapter(String)>,0,"{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, ""createPrintDocumentAdapter"");
    return mProvider.createPrintDocumentAdapter(documentName);
}","{
    checkThread();
    return mProvider.createPrintDocumentAdapter(documentName);
}",1,"/**
 * Creates a PrintDocumentAdapter that provides the content of this Webview for printing.
 *
 * The adapter works by converting the Webview contents to a PDF stream. The Webview cannot
 * be drawn during the conversion process - any such draws are undefined. It is recommended
 * to use a dedicated off screen Webview for the printing. If necessary, an application may
 * temporarily hide a visible WebView by using a custom PrintDocumentAdapter instance
 * wrapped around the object returned and observing the onStart and onFinish methods. See
 * {@link android.print.PrintDocumentAdapter} for more information.
 *
 * @param documentName  The user-facing name of the printed document. See
 * {@link android.print.PrintDocumentInfo}
 */
","/**
 * Creates a PrintDocumentAdapter that provides the content of this Webview for printing.
 *
 * The adapter works by converting the Webview contents to a PDF stream. The Webview cannot
 * be drawn during the conversion process - any such draws are undefined. It is recommended
 * to use a dedicated off screen Webview for the printing. If necessary, an application may
 * temporarily hide a visible WebView by using a custom PrintDocumentAdapter instance
 * wrapped around the object returned and observing the onStart and onFinish methods. See
 * {@link android.print.PrintDocumentAdapter} for more information.
 *
 * @param documentName  The user-facing name of the printed document. See
 * {@link android.print.PrintDocumentInfo}
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change is the removal of a logging statement (Log.d(LOGTAG, ""createPrintDocumentAdapter"")). Because logging does not affect the actual operation or outcome of the method, the change type is 4 (Other statement changed).","There is no Compatibility Issue since the removal of a log statement does not affect the method's behavior in terms of return values, thrown exceptions, or control flow. Therefore, there is no change in the API's potential behavior."
841,"<android.hardware.camera2.utils.ArrayUtils: List<Integer> convertStringListToIntList(List<String>,String[],int[])>",22,23,"<android.hardware.camera2.utils.ArrayUtils: List<Integer> convertStringListToIntList(List<String>,String[],int[])>","<android.hardware.camera2.utils.ArrayUtils: List<Integer> convertStringListToIntList(List<String>,String[],int[])>",0,"{
    if (list == null) {
        return null;
    }
    List<Integer> convertedList = new ArrayList<>(list.size());
    for (String str : list) {
        int strIndex = getArrayIndex(convertFrom, str);
        // Guard against unexpected values
        if (strIndex < 0) {
            if (VERBOSE)
                Log.v(TAG, ""Ignoring invalid value "" + str);
            continue;
        }
        // Ignore values we can't map into (intentional)
        if (strIndex < convertTo.length) {
            convertedList.add(convertTo[strIndex]);
        }
    }
    return convertedList;
}","{
    if (list == null) {
        return null;
    }
    List<Integer> convertedList = new ArrayList<>(list.size());
    for (String str : list) {
        int strIndex = getArrayIndex(convertFrom, str);
        // Guard against unexpected values
        if (strIndex < 0) {
            if (DEBUG)
                Log.v(TAG, ""Ignoring invalid value "" + str);
            continue;
        }
        // Ignore values we can't map into (intentional)
        if (strIndex < convertTo.length) {
            convertedList.add(convertTo[strIndex]);
        }
    }
    return convertedList;
}",1,"/**
 * Create an {@code List<Integer>} from the {@code List<>} by using {@code convertFrom} and
 * {@code convertTo} as a one-to-one map (via the index).
 *
 * <p>Strings not appearing in {@code convertFrom} are ignored (with a logged warning);
 * strings appearing in {@code convertFrom} but not {@code convertTo} are silently
 * dropped.</p>
 *
 * @param list Source list of strings
 * @param convertFrom Conversion list of strings
 * @param convertTo Conversion list of ints
 * @return A list of ints where the values correspond to the ones in {@code convertTo}
 * or {@code null} if {@code list} was {@code null}
 */
","/**
 * Create an {@code List<Integer>} from the {@code List<>} by using {@code convertFrom} and
 * {@code convertTo} as a one-to-one map (via the index).
 *
 * <p>Strings not appearing in {@code convertFrom} are ignored (with a logged warning);
 * strings appearing in {@code convertFrom} but not {@code convertTo} are silently
 * dropped.</p>
 *
 * @param list Source list of strings
 * @param convertFrom Conversion list of strings
 * @param convertTo Conversion list of ints
 * @return A list of ints where the values correspond to the ones in {@code convertTo}
 * or {@code null} if {@code list} was {@code null}
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The constant `VERBOSE` is changed to `DEBUG`. This is only a change in log-level check and does not affect the behavior of the method, so the code change type is 4.","Since the change does not affect the return value or exception handling of the method—only the verbosity of logging—there is no compatibility issue, hence the CI type is 0."
842,"<android.hardware.camera2.legacy.LegacyFocusStateMapper: void processRequestTriggers(CaptureRequest,Parameters)>",22,23,"<android.hardware.camera2.legacy.LegacyFocusStateMapper: void processRequestTriggers(CaptureRequest,Parameters)>","<android.hardware.camera2.legacy.LegacyFocusStateMapper: void processRequestTriggers(CaptureRequest,Parameters)>",0,"{
    checkNotNull(captureRequest, ""captureRequest must not be null"");
    /*
         * control.afTrigger
         */
    int afTrigger = ParamsUtils.getOrDefault(captureRequest, CONTROL_AF_TRIGGER, CONTROL_AF_TRIGGER_IDLE);
    final String afMode = parameters.getFocusMode();
    if (!Objects.equals(mAfModePrevious, afMode)) {
        if (VERBOSE) {
            Log.v(TAG, ""processRequestTriggers - AF mode switched from "" + mAfModePrevious + "" to "" + afMode);
        }
        synchronized (mLock) {
            ++mAfRun;
            mAfState = CONTROL_AF_STATE_INACTIVE;
        }
        mCamera.cancelAutoFocus();
    }
    mAfModePrevious = afMode;
    // Passive AF Scanning
    {
        final int currentAfRun;
        synchronized (mLock) {
            currentAfRun = mAfRun;
        }
        Camera.AutoFocusMoveCallback afMoveCallback = new Camera.AutoFocusMoveCallback() {

            @Override
            public void onAutoFocusMoving(boolean start, Camera camera) {
                synchronized (mLock) {
                    int latestAfRun = mAfRun;
                    if (VERBOSE) {
                        Log.v(TAG, ""onAutoFocusMoving - start "" + start + "" latest AF run "" + latestAfRun + "", last AF run "" + currentAfRun);
                    }
                    if (currentAfRun != latestAfRun) {
                        Log.d(TAG, ""onAutoFocusMoving - ignoring move callbacks from old af run"" + currentAfRun);
                        return;
                    }
                    int newAfState = start ? CONTROL_AF_STATE_PASSIVE_SCAN : CONTROL_AF_STATE_PASSIVE_FOCUSED;
                    switch(afMode) {
                        case Parameters.FOCUS_MODE_CONTINUOUS_PICTURE:
                        case Parameters.FOCUS_MODE_CONTINUOUS_VIDEO:
                            break;
                        // This callback should never be sent in any other AF mode
                        default:
                            Log.w(TAG, ""onAutoFocus - got unexpected onAutoFocus in mode "" + afMode);
                    }
                    mAfState = newAfState;
                }
            }
        };
        // Only set move callback if we can call autofocus.
        switch(afMode) {
            case Parameters.FOCUS_MODE_AUTO:
            case Parameters.FOCUS_MODE_MACRO:
            case Parameters.FOCUS_MODE_CONTINUOUS_PICTURE:
            case Parameters.FOCUS_MODE_CONTINUOUS_VIDEO:
                mCamera.setAutoFocusMoveCallback(afMoveCallback);
        }
    }
    // AF Locking
    switch(afTrigger) {
        case CONTROL_AF_TRIGGER_START:
            int afStateAfterStart;
            switch(afMode) {
                case Parameters.FOCUS_MODE_AUTO:
                case Parameters.FOCUS_MODE_MACRO:
                    afStateAfterStart = CONTROL_AF_STATE_ACTIVE_SCAN;
                    break;
                case Parameters.FOCUS_MODE_CONTINUOUS_PICTURE:
                case Parameters.FOCUS_MODE_CONTINUOUS_VIDEO:
                    afStateAfterStart = CONTROL_AF_STATE_PASSIVE_SCAN;
                    break;
                default:
                    // EDOF, INFINITY
                    afStateAfterStart = CONTROL_AF_STATE_INACTIVE;
            }
            final int currentAfRun;
            synchronized (mLock) {
                currentAfRun = ++mAfRun;
                mAfState = afStateAfterStart;
            }
            if (VERBOSE) {
                Log.v(TAG, ""processRequestTriggers - got AF_TRIGGER_START, "" + ""new AF run is "" + currentAfRun);
            }
            // Avoid calling autofocus unless we are in a state that supports calling this.
            if (afStateAfterStart == CONTROL_AF_STATE_INACTIVE) {
                break;
            }
            mCamera.autoFocus(new Camera.AutoFocusCallback() {

                @Override
                public void onAutoFocus(boolean success, Camera camera) {
                    synchronized (mLock) {
                        int latestAfRun = mAfRun;
                        if (VERBOSE) {
                            Log.v(TAG, ""onAutoFocus - success "" + success + "" latest AF run "" + latestAfRun + "", last AF run "" + currentAfRun);
                        }
                        // Ignore old auto-focus results, since another trigger was requested
                        if (latestAfRun != currentAfRun) {
                            Log.d(TAG, String.format(""onAutoFocus - ignoring AF callback "" + ""(old run %d, new run %d)"", currentAfRun, latestAfRun));
                            return;
                        }
                        int newAfState = success ? CONTROL_AF_STATE_FOCUSED_LOCKED : CONTROL_AF_STATE_NOT_FOCUSED_LOCKED;
                        switch(afMode) {
                            case Parameters.FOCUS_MODE_AUTO:
                            case Parameters.FOCUS_MODE_CONTINUOUS_PICTURE:
                            case Parameters.FOCUS_MODE_CONTINUOUS_VIDEO:
                            case Parameters.FOCUS_MODE_MACRO:
                                break;
                            // This callback should never be sent in any other AF mode
                            default:
                                Log.w(TAG, ""onAutoFocus - got unexpected onAutoFocus in mode "" + afMode);
                        }
                        mAfState = newAfState;
                    }
                }
            });
            break;
        case CONTROL_AF_TRIGGER_CANCEL:
            synchronized (mLock) {
                int updatedAfRun;
                synchronized (mLock) {
                    updatedAfRun = ++mAfRun;
                    mAfState = CONTROL_AF_STATE_INACTIVE;
                }
                mCamera.cancelAutoFocus();
                if (VERBOSE) {
                    Log.v(TAG, ""processRequestTriggers - got AF_TRIGGER_CANCEL, "" + ""new AF run is "" + updatedAfRun);
                }
            }
            break;
        case CONTROL_AF_TRIGGER_IDLE:
            // No action necessary. The callbacks will handle transitions.
            break;
        default:
            Log.w(TAG, ""processRequestTriggers - ignoring unknown control.afTrigger = "" + afTrigger);
    }
}","{
    checkNotNull(captureRequest, ""captureRequest must not be null"");
    /*
         * control.afTrigger
         */
    int afTrigger = ParamsUtils.getOrDefault(captureRequest, CONTROL_AF_TRIGGER, CONTROL_AF_TRIGGER_IDLE);
    final String afMode = parameters.getFocusMode();
    if (!Objects.equals(mAfModePrevious, afMode)) {
        if (DEBUG) {
            Log.v(TAG, ""processRequestTriggers - AF mode switched from "" + mAfModePrevious + "" to "" + afMode);
        }
        synchronized (mLock) {
            ++mAfRun;
            mAfState = CONTROL_AF_STATE_INACTIVE;
        }
        mCamera.cancelAutoFocus();
    }
    mAfModePrevious = afMode;
    // Passive AF Scanning
    {
        final int currentAfRun;
        synchronized (mLock) {
            currentAfRun = mAfRun;
        }
        Camera.AutoFocusMoveCallback afMoveCallback = new Camera.AutoFocusMoveCallback() {

            @Override
            public void onAutoFocusMoving(boolean start, Camera camera) {
                synchronized (mLock) {
                    int latestAfRun = mAfRun;
                    if (DEBUG) {
                        Log.v(TAG, ""onAutoFocusMoving - start "" + start + "" latest AF run "" + latestAfRun + "", last AF run "" + currentAfRun);
                    }
                    if (currentAfRun != latestAfRun) {
                        Log.d(TAG, ""onAutoFocusMoving - ignoring move callbacks from old af run"" + currentAfRun);
                        return;
                    }
                    int newAfState = start ? CONTROL_AF_STATE_PASSIVE_SCAN : CONTROL_AF_STATE_PASSIVE_FOCUSED;
                    switch(afMode) {
                        case Parameters.FOCUS_MODE_CONTINUOUS_PICTURE:
                        case Parameters.FOCUS_MODE_CONTINUOUS_VIDEO:
                            break;
                        // This callback should never be sent in any other AF mode
                        default:
                            Log.w(TAG, ""onAutoFocus - got unexpected onAutoFocus in mode "" + afMode);
                    }
                    mAfState = newAfState;
                }
            }
        };
        // Only set move callback if we can call autofocus.
        switch(afMode) {
            case Parameters.FOCUS_MODE_AUTO:
            case Parameters.FOCUS_MODE_MACRO:
            case Parameters.FOCUS_MODE_CONTINUOUS_PICTURE:
            case Parameters.FOCUS_MODE_CONTINUOUS_VIDEO:
                mCamera.setAutoFocusMoveCallback(afMoveCallback);
        }
    }
    // AF Locking
    switch(afTrigger) {
        case CONTROL_AF_TRIGGER_START:
            int afStateAfterStart;
            switch(afMode) {
                case Parameters.FOCUS_MODE_AUTO:
                case Parameters.FOCUS_MODE_MACRO:
                    afStateAfterStart = CONTROL_AF_STATE_ACTIVE_SCAN;
                    break;
                case Parameters.FOCUS_MODE_CONTINUOUS_PICTURE:
                case Parameters.FOCUS_MODE_CONTINUOUS_VIDEO:
                    afStateAfterStart = CONTROL_AF_STATE_PASSIVE_SCAN;
                    break;
                default:
                    // EDOF, INFINITY
                    afStateAfterStart = CONTROL_AF_STATE_INACTIVE;
            }
            final int currentAfRun;
            synchronized (mLock) {
                currentAfRun = ++mAfRun;
                mAfState = afStateAfterStart;
            }
            if (DEBUG) {
                Log.v(TAG, ""processRequestTriggers - got AF_TRIGGER_START, "" + ""new AF run is "" + currentAfRun);
            }
            // Avoid calling autofocus unless we are in a state that supports calling this.
            if (afStateAfterStart == CONTROL_AF_STATE_INACTIVE) {
                break;
            }
            mCamera.autoFocus(new Camera.AutoFocusCallback() {

                @Override
                public void onAutoFocus(boolean success, Camera camera) {
                    synchronized (mLock) {
                        int latestAfRun = mAfRun;
                        if (DEBUG) {
                            Log.v(TAG, ""onAutoFocus - success "" + success + "" latest AF run "" + latestAfRun + "", last AF run "" + currentAfRun);
                        }
                        // Ignore old auto-focus results, since another trigger was requested
                        if (latestAfRun != currentAfRun) {
                            Log.d(TAG, String.format(""onAutoFocus - ignoring AF callback "" + ""(old run %d, new run %d)"", currentAfRun, latestAfRun));
                            return;
                        }
                        int newAfState = success ? CONTROL_AF_STATE_FOCUSED_LOCKED : CONTROL_AF_STATE_NOT_FOCUSED_LOCKED;
                        switch(afMode) {
                            case Parameters.FOCUS_MODE_AUTO:
                            case Parameters.FOCUS_MODE_CONTINUOUS_PICTURE:
                            case Parameters.FOCUS_MODE_CONTINUOUS_VIDEO:
                            case Parameters.FOCUS_MODE_MACRO:
                                break;
                            // This callback should never be sent in any other AF mode
                            default:
                                Log.w(TAG, ""onAutoFocus - got unexpected onAutoFocus in mode "" + afMode);
                        }
                        mAfState = newAfState;
                    }
                }
            });
            break;
        case CONTROL_AF_TRIGGER_CANCEL:
            synchronized (mLock) {
                int updatedAfRun;
                synchronized (mLock) {
                    updatedAfRun = ++mAfRun;
                    mAfState = CONTROL_AF_STATE_INACTIVE;
                }
                mCamera.cancelAutoFocus();
                if (DEBUG) {
                    Log.v(TAG, ""processRequestTriggers - got AF_TRIGGER_CANCEL, "" + ""new AF run is "" + updatedAfRun);
                }
            }
            break;
        case CONTROL_AF_TRIGGER_IDLE:
            // No action necessary. The callbacks will handle transitions.
            break;
        default:
            Log.w(TAG, ""processRequestTriggers - ignoring unknown control.afTrigger = "" + afTrigger);
    }
}",1,"/**
 * Process the AF triggers from the request as a camera1 autofocus routine.
 *
 * <p>This method should be called after the parameters are {@link LegacyRequestMapper mapped}
 * with the request.</p>
 *
 * <p>Callbacks are processed in the background, and the next call to {@link #mapResultTriggers}
 * will have the latest AF state as reflected by the camera1 callbacks.</p>
 *
 * <p>None of the arguments will be mutated.</p>
 *
 * @param captureRequest a non-{@code null} request
 * @param parameters a non-{@code null} parameters corresponding to this request (read-only)
 */
","/**
 * Process the AF triggers from the request as a camera1 autofocus routine.
 *
 * <p>This method should be called after the parameters are {@link LegacyRequestMapper mapped}
 * with the request.</p>
 *
 * <p>Callbacks are processed in the background, and the next call to {@link #mapResultTriggers}
 * will have the latest AF state as reflected by the camera1 callbacks.</p>
 *
 * <p>None of the arguments will be mutated.</p>
 *
 * @param captureRequest a non-{@code null} request
 * @param parameters a non-{@code null} parameters corresponding to this request (read-only)
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
843,<android.content.ContentResolver: ContentProviderClient acquireUnstableContentProviderClient(String)>,22,23,<android.content.ContentResolver: ContentProviderClient acquireUnstableContentProviderClient(String)>,<android.content.ContentResolver: ContentProviderClient acquireUnstableContentProviderClient(String)>,0,"{
    IContentProvider provider = acquireUnstableProvider(name);
    if (provider != null) {
        return new ContentProviderClient(this, provider, false);
    }
    return null;
}","{
    Preconditions.checkNotNull(name, ""name"");
    IContentProvider provider = acquireUnstableProvider(name);
    if (provider != null) {
        return new ContentProviderClient(this, provider, false);
    }
    return null;
}",1,"/**
 * Like {@link #acquireContentProviderClient(String)}, but for use when you do
 * not trust the stability of the target content provider.  This turns off
 * the mechanism in the platform clean up processes that are dependent on
 * a content provider if that content provider's process goes away.  Normally
 * you can safely assume that once you have acquired a provider, you can freely
 * use it as needed and it won't disappear, even if your process is in the
 * background.  If using this method, you need to take care to deal with any
 * failures when communicating with the provider, and be sure to close it
 * so that it can be re-opened later.  In particular, catching a
 * {@link android.os.DeadObjectException} from the calls there will let you
 * know that the content provider has gone away; at that point the current
 * ContentProviderClient object is invalid, and you should release it.  You
 * can acquire a new one if you would like to try to restart the provider
 * and perform new operations on it.
 */
","/**
 * Like {@link #acquireContentProviderClient(String)}, but for use when you do
 * not trust the stability of the target content provider.  This turns off
 * the mechanism in the platform clean up processes that are dependent on
 * a content provider if that content provider's process goes away.  Normally
 * you can safely assume that once you have acquired a provider, you can freely
 * use it as needed and it won't disappear, even if your process is in the
 * background.  If using this method, you need to take care to deal with any
 * failures when communicating with the provider, and be sure to close it
 * so that it can be re-opened later.  In particular, catching a
 * {@link android.os.DeadObjectException} from the calls there will let you
 * know that the content provider has gone away; at that point the current
 * ContentProviderClient object is invalid, and you should release it.  You
 * can acquire a new one if you would like to try to restart the provider
 * and perform new operations on it.
 */
",-1,,[@Nullable],-1,-1,-1,-1,-1,-1,4,0,"The addition of Preconditions.checkNotNull(name, ""name""); introduces a check to verify that the 'name' parameter is not null, which is a type of ""other statement changed"". This added check does not impact the control flow nor does it change the type or set of values that the method could return, as a NullPointerException would be thrown either way if 'name' were null in both versions.","There is no Compatibility Issue detected because the method behavior does not change in a way that affects the return value or exception handling of the method from an API consumer perspective; if 'name' was null, in the early version, it would have led to a NullPointerException during the execution of acquireUnstableProvider(name) anyway, and in the late version, it is explicitly being checked."
845,<android.app.Notification.Builder: Builder setLargeIcon(Bitmap)>,22,23,<android.app.Notification.Builder: Builder setLargeIcon(Bitmap)>,<android.app.Notification.Builder: Builder setLargeIcon(Bitmap)>,0,"{
    mLargeIcon = icon;
    return this;
}","{
    return setLargeIcon(b != null ? Icon.createWithBitmap(b) : null);
}",1,"/**
 * Add a large icon to the notification (and the ticker on some devices).
 *
 * In the platform template, this image will be shown on the left of the notification view
 * in place of the {@link #setSmallIcon(int) small icon} (which will move to the right side).
 *
 * @see Notification#largeIcon
 */
","/**
 * Add a large icon to the notification content view.
 *
 * In the platform template, this image will be shown on the left of the notification view
 * in place of the {@link #setSmallIcon(Icon) small icon} (which will be placed in a small
 * badge atop the large icon).
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method implementation has changed from directly assigning a Bitmap to mLargeIcon to using a conditional expression that creates an Icon object with the Bitmap if it is not null, or sets it to null otherwise. This introduces a dependency on the Icon.createWithBitmap method, which is a different API, so the change type is 1,5.","Given that the way the large icon is set has been fundamentally modified (from setting a Bitmap directly to using an Icon) and relies on the behavior of Icon.createWithBitmap(b), the API will potentially return different objects (the Builder with different state). Therefore, the CI type is 1."
846,<android.net.ConnectivityManager: boolean setProcessDefaultNetwork(Network)>,22,23,<android.net.ConnectivityManager: boolean setProcessDefaultNetwork(Network)>,<android.net.ConnectivityManager: boolean setProcessDefaultNetwork(Network)>,0,"{
    int netId = (network == null) ? NETID_UNSET : network.netId;
    if (netId == NetworkUtils.getNetworkBoundToProcess()) {
        return true;
    }
    if (NetworkUtils.bindProcessToNetwork(netId)) {
        // Set HTTP proxy system properties to match network.
        // TODO: Deprecate this static method and replace it with a non-static version.
        Proxy.setHttpProxySystemProperty(getInstance().getDefaultProxy());
        // Must flush DNS cache as new network may have different DNS resolutions.
        InetAddress.clearDnsCache();
        // Must flush socket pool as idle sockets will be bound to previous network and may
        // cause subsequent fetches to be performed on old network.
        NetworkEventDispatcher.getInstance().onNetworkConfigurationChanged();
        return true;
    } else {
        return false;
    }
}","{
    int netId = (network == null) ? NETID_UNSET : network.netId;
    if (netId == NetworkUtils.getBoundNetworkForProcess()) {
        return true;
    }
    if (NetworkUtils.bindProcessToNetwork(netId)) {
        // TODO: Deprecate this static method and replace it with a non-static version.
        try {
            Proxy.setHttpProxySystemProperty(getInstance().getDefaultProxy());
        } catch (SecurityException e) {
            // The process doesn't have ACCESS_NETWORK_STATE, so we can't fetch the proxy.
            Log.e(TAG, ""Can't set proxy properties"", e);
        }
        // Must flush DNS cache as new network may have different DNS resolutions.
        InetAddress.clearDnsCache();
        // Must flush socket pool as idle sockets will be bound to previous network and may
        // cause subsequent fetches to be performed on old network.
        NetworkEventDispatcher.getInstance().onNetworkConfigurationChanged();
        return true;
    } else {
        return false;
    }
}",1,"/**
 * Binds the current process to {@code network}.  All Sockets created in the future
 * (and not explicitly bound via a bound SocketFactory from
 * {@link Network#getSocketFactory() Network.getSocketFactory()}) will be bound to
 * {@code network}.  All host name resolutions will be limited to {@code network} as well.
 * Note that if {@code network} ever disconnects, all Sockets created in this way will cease to
 * work and all host name resolutions will fail.  This is by design so an application doesn't
 * accidentally use Sockets it thinks are still bound to a particular {@link Network}.
 * To clear binding pass {@code null} for {@code network}.  Using individually bound
 * Sockets created by Network.getSocketFactory().createSocket() and
 * performing network-specific host name resolutions via
 * {@link Network#getAllByName Network.getAllByName} is preferred to calling
 * {@code setProcessDefaultNetwork}.
 *
 * @param network The {@link Network} to bind the current process to, or {@code null} to clear
 * the current binding.
 * @return {@code true} on success, {@code false} if the {@link Network} is no longer valid.
 */
","/**
 * Binds the current process to {@code network}.  All Sockets created in the future
 * (and not explicitly bound via a bound SocketFactory from
 * {@link Network#getSocketFactory() Network.getSocketFactory()}) will be bound to
 * {@code network}.  All host name resolutions will be limited to {@code network} as well.
 * Note that if {@code network} ever disconnects, all Sockets created in this way will cease to
 * work and all host name resolutions will fail.  This is by design so an application doesn't
 * accidentally use Sockets it thinks are still bound to a particular {@link Network}.
 * To clear binding pass {@code null} for {@code network}.  Using individually bound
 * Sockets created by Network.getSocketFactory().createSocket() and
 * performing network-specific host name resolutions via
 * {@link Network#getAllByName Network.getAllByName} is preferred to calling
 * {@code setProcessDefaultNetwork}.
 *
 * @param network The {@link Network} to bind the current process to, or {@code null} to clear
 * the current binding.
 * @return {@code true} on success, {@code false} if the {@link Network} is no longer valid.
 * @deprecated This function can throw {@link IllegalStateException}.  Use
 * {@link #bindProcessToNetwork} instead.  {@code bindProcessToNetwork}
 * is a direct replacement.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,5",2,"The call within the if condition changed from `getNetworkBoundToProcess()` to `getBoundNetworkForProcess()`, there is an addition of a try-catch block around the call to `Proxy.setHttpProxySystemProperty(getInstance().getDefaultProxy())`, and there's handling for a new `SecurityException`. Therefore change types are 2 (Exception handling statement changed), 3 (Control dependency changed), and 5 (Dependent API changed).","The introduction of the try-catch block for `SecurityException` when setting proxy system property can lead to exception handling change (CI type 2) because the newer version may catch and log a `SecurityException` instead of potentially propagating it in the previous version. There is no change to the return value, so CI type 1 isn't applicable."
847,<android.bluetooth.BluetoothAdapter: BluetoothLeAdvertiser getBluetoothLeAdvertiser()>,22,23,<android.bluetooth.BluetoothAdapter: BluetoothLeAdvertiser getBluetoothLeAdvertiser()>,<android.bluetooth.BluetoothAdapter: BluetoothLeAdvertiser getBluetoothLeAdvertiser()>,0,"{
    if (getState() != STATE_ON) {
        return null;
    }
    if (!isMultipleAdvertisementSupported() && !isPeripheralModeSupported()) {
        Log.e(TAG, ""bluetooth le advertising not supported"");
        return null;
    }
    synchronized (mLock) {
        if (sBluetoothLeAdvertiser == null) {
            sBluetoothLeAdvertiser = new BluetoothLeAdvertiser(mManagerService);
        }
    }
    return sBluetoothLeAdvertiser;
}","{
    if (!getLeAccess())
        return null;
    if (!isMultipleAdvertisementSupported() && !isPeripheralModeSupported()) {
        Log.e(TAG, ""Bluetooth LE advertising not supported"");
        return null;
    }
    synchronized (mLock) {
        if (sBluetoothLeAdvertiser == null) {
            sBluetoothLeAdvertiser = new BluetoothLeAdvertiser(mManagerService);
        }
    }
    return sBluetoothLeAdvertiser;
}",1,"/**
 * Returns a {@link BluetoothLeAdvertiser} object for Bluetooth LE Advertising operations.
 * Will return null if Bluetooth is turned off or if Bluetooth LE Advertising is not
 * supported on this device.
 * <p>
 * Use {@link #isMultipleAdvertisementSupported()} to check whether LE Advertising is supported
 * on this device before calling this method.
 */
","/**
 * Returns a {@link BluetoothLeAdvertiser} object for Bluetooth LE Advertising operations.
 * Will return null if Bluetooth is turned off or if Bluetooth LE Advertising is not
 * supported on this device.
 * <p>
 * Use {@link #isMultipleAdvertisementSupported()} to check whether LE Advertising is supported
 * on this device before calling this method.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,5",1,"The control dependency check has been changed from checking the specific Bluetooth state (getState() != STATE_ON) to a more general access check (getLeAccess()). Besides, a dependent API getLeAccess() is also used which was not present in the early version. This accounts for both a control dependency change and a change in the dependent API, so the code change types are 3 and 5.","The change in the control dependency means that the conditions under which the API returns null have changed, potentially leading to a situation where the method might return a different value than before (null or a BluetoothLeAdvertiser instance), causing a compatibility issue due to potential different return values, hence, the CI type is 1."
849,"<android.app.TimePickerDialog: int resolveDialogTheme(Context,int)>",22,23,"<android.app.TimePickerDialog: int resolveDialogTheme(Context,int)>","<android.app.TimePickerDialog: int resolveDialogTheme(Context,int)>",0,"{
    if (resid == 0) {
        final TypedValue outValue = new TypedValue();
        context.getTheme().resolveAttribute(R.attr.timePickerDialogTheme, outValue, true);
        return outValue.resourceId;
    } else {
        return resid;
    }
}","{
    if (resId == 0) {
        final TypedValue outValue = new TypedValue();
        context.getTheme().resolveAttribute(R.attr.timePickerDialogTheme, outValue, true);
        return outValue.resourceId;
    } else {
        return resId;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change is in the capitalization of the variable name from 'resid' to 'resId'. This is just a change in the naming convention and does not affect the functionality of the method. The actual behavior of the code remains the same, so the code change type is 4.","There is no Compatibility Issue because the change does not affect the method behavior. The same value is returned regardless of the variable's name change. Thus, no different return values or types and no different exception handlings would arise from this change."
850,<android.webkit.WebView: Picture capturePicture()>,22,23,<android.webkit.WebView: Picture capturePicture()>,<android.webkit.WebView: Picture capturePicture()>,0,"{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, ""capturePicture"");
    return mProvider.capturePicture();
}","{
    checkThread();
    return mProvider.capturePicture();
}",1,"/**
 * Gets a new picture that captures the current contents of this WebView.
 * The picture is of the entire document being displayed, and is not
 * limited to the area currently displayed by this WebView. Also, the
 * picture is a static copy and is unaffected by later changes to the
 * content being displayed.
 * <p>
 * Note that due to internal changes, for API levels between
 * {@link android.os.Build.VERSION_CODES#HONEYCOMB} and
 * {@link android.os.Build.VERSION_CODES#ICE_CREAM_SANDWICH} inclusive, the
 * picture does not include fixed position elements or scrollable divs.
 * <p>
 * Note that from {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1} the returned picture
 * should only be drawn into bitmap-backed Canvas - using any other type of Canvas will involve
 * additional conversion at a cost in memory and performance. Also the
 * {@link android.graphics.Picture#createFromStream} and
 * {@link android.graphics.Picture#writeToStream} methods are not supported on the
 * returned object.
 *
 * @deprecated Use {@link #onDraw} to obtain a bitmap snapshot of the WebView, or
 * {@link #saveWebArchive} to save the content to a file.
 *
 * @return a picture that captures the current contents of this WebView
 */
","/**
 * Gets a new picture that captures the current contents of this WebView.
 * The picture is of the entire document being displayed, and is not
 * limited to the area currently displayed by this WebView. Also, the
 * picture is a static copy and is unaffected by later changes to the
 * content being displayed.
 * <p>
 * Note that due to internal changes, for API levels between
 * {@link android.os.Build.VERSION_CODES#HONEYCOMB} and
 * {@link android.os.Build.VERSION_CODES#ICE_CREAM_SANDWICH} inclusive, the
 * picture does not include fixed position elements or scrollable divs.
 * <p>
 * Note that from {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1} the returned picture
 * should only be drawn into bitmap-backed Canvas - using any other type of Canvas will involve
 * additional conversion at a cost in memory and performance. Also the
 * {@link android.graphics.Picture#createFromStream} and
 * {@link android.graphics.Picture#writeToStream} methods are not supported on the
 * returned object.
 *
 * @deprecated Use {@link #onDraw} to obtain a bitmap snapshot of the WebView, or
 * {@link #saveWebArchive} to save the content to a file.
 *
 * @return a picture that captures the current contents of this WebView
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,4,0,"An if statement with a logging instruction has been removed, so the code change type is 4 (Other statement changed).","The deletion of the debug log will not affect the external behavior of the API or its return value or the exceptions thrown. Therefore, no Compatibility Issue will arise, so the CI type is 0 (No Compatibility Issue)."
851,"<android.content.ContentResolver: ContentProviderResult[] applyBatch(String,ArrayList<ContentProviderOperation>)>",22,23,"<android.content.ContentResolver: ContentProviderResult[] applyBatch(String,ArrayList<ContentProviderOperation>)>","<android.content.ContentResolver: ContentProviderResult[] applyBatch(String,ArrayList<ContentProviderOperation>)>",0,"{
    ContentProviderClient provider = acquireContentProviderClient(authority);
    if (provider == null) {
        throw new IllegalArgumentException(""Unknown authority "" + authority);
    }
    try {
        return provider.applyBatch(operations);
    } finally {
        provider.release();
    }
}","{
    Preconditions.checkNotNull(authority, ""authority"");
    Preconditions.checkNotNull(operations, ""operations"");
    ContentProviderClient provider = acquireContentProviderClient(authority);
    if (provider == null) {
        throw new IllegalArgumentException(""Unknown authority "" + authority);
    }
    try {
        return provider.applyBatch(operations);
    } finally {
        provider.release();
    }
}",1,"/**
 * Applies each of the {@link ContentProviderOperation} objects and returns an array
 * of their results. Passes through OperationApplicationException, which may be thrown
 * by the call to {@link ContentProviderOperation#apply}.
 * If all the applications succeed then a {@link ContentProviderResult} array with the
 * same number of elements as the operations will be returned. It is implementation-specific
 * how many, if any, operations will have been successfully applied if a call to
 * apply results in a {@link OperationApplicationException}.
 * @param authority the authority of the ContentProvider to which this batch should be applied
 * @param operations the operations to apply
 * @return the results of the applications
 * @throws OperationApplicationException thrown if an application fails.
 * See {@link ContentProviderOperation#apply} for more information.
 * @throws RemoteException thrown if a RemoteException is encountered while attempting
 * to communicate with a remote provider.
 */
","/**
 * Applies each of the {@link ContentProviderOperation} objects and returns an array
 * of their results. Passes through OperationApplicationException, which may be thrown
 * by the call to {@link ContentProviderOperation#apply}.
 * If all the applications succeed then a {@link ContentProviderResult} array with the
 * same number of elements as the operations will be returned. It is implementation-specific
 * how many, if any, operations will have been successfully applied if a call to
 * apply results in a {@link OperationApplicationException}.
 * @param authority the authority of the ContentProvider to which this batch should be applied
 * @param operations the operations to apply
 * @return the results of the applications
 * @throws OperationApplicationException thrown if an application fails.
 * See {@link ContentProviderOperation#apply} for more information.
 * @throws RemoteException thrown if a RemoteException is encountered while attempting
 * to communicate with a remote provider.
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,4,0,"The late implementation introduces two Preconditions.checkNotNull() calls before it starts interacting with the ContentProviderClient, so the change type is 4.","The addition of Preconditions.checkNotNull() for 'authority' and 'operations' do not introduce a compatibility issue, because they merely enforce that non-null parameters are passed to the method. The behavior of the method after checking the inputs remains unchanged, as the same IllegalArgumentException is thrown for a null 'authority', and the underlying operations involving the 'provider' remain the same. Therefore, there is no Compatibility Issue."
854,"<android.hardware.camera2.impl.CameraCaptureSessionImpl: int setRepeatingBurst(List<CaptureRequest>,CaptureCallback,Handler)>",22,23,"<android.hardware.camera2.impl.CameraCaptureSessionImpl: int setRepeatingBurst(List<CaptureRequest>,CaptureCallback,Handler)>","<android.hardware.camera2.impl.CameraCaptureSessionImpl: int setRepeatingBurst(List<CaptureRequest>,CaptureCallback,Handler)>",0,"{
    if (requests == null) {
        throw new IllegalArgumentException(""requests must not be null"");
    } else if (requests.isEmpty()) {
        throw new IllegalArgumentException(""requests must have at least one element"");
    }
    checkNotClosed();
    handler = checkHandler(handler, callback);
    if (VERBOSE) {
        CaptureRequest[] requestArray = requests.toArray(new CaptureRequest[0]);
        Log.v(TAG, mIdString + ""setRepeatingBurst - requests "" + Arrays.toString(requestArray) + "", callback "" + callback + "" handler"" + """" + handler);
    }
    return addPendingSequence(mDeviceImpl.setRepeatingBurst(requests, createCaptureCallbackProxy(handler, callback), mDeviceHandler));
}","{
    if (requests == null) {
        throw new IllegalArgumentException(""requests must not be null"");
    } else if (requests.isEmpty()) {
        throw new IllegalArgumentException(""requests must have at least one element"");
    }
    for (CaptureRequest r : requests) {
        if (r.isReprocess()) {
            throw new IllegalArgumentException(""repeating reprocess burst requests are not "" + ""supported"");
        }
    }
    checkNotClosed();
    handler = checkHandler(handler, callback);
    if (DEBUG) {
        CaptureRequest[] requestArray = requests.toArray(new CaptureRequest[0]);
        Log.v(TAG, mIdString + ""setRepeatingBurst - requests "" + Arrays.toString(requestArray) + "", callback "" + callback + "" handler"" + """" + handler);
    }
    return addPendingSequence(mDeviceImpl.setRepeatingBurst(requests, createCaptureCallbackProxy(handler, callback), mDeviceHandler));
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,2,3","1,2","A new for-loop along with an exception handling statement has been added before the checkNotClosed() call, and the VERBOSE constant in the if condition has changed to DEBUG, a change in the control dependency and in exception handling. Therefore, the code change type is 1,2,3.","The added for-loop and corresponding throw statement will introduce a new condition that could throw an IllegalArgumentException if any of the capture requests is a reprocess, which is a change in the exception handling behaviour. Moreover, a return statement's condition has been modified from VERBOSE to DEBUG, which affects when the log message is printed and is indirectly related to the output shown to the user or logs but it doesn't affect the API's functional return behavior; hence, it won't cause a CI based on return values or types. Therefore, the CI type is 1,2."
856,"<android.widget.PopupWindow: void update(int,int,int,int,boolean)>",22,23,"<android.widget.PopupWindow: void update(int,int,int,int,boolean)>","<android.widget.PopupWindow: void update(int,int,int,int,boolean)>",0,"{
    if (width != -1) {
        mLastWidth = width;
        setWidth(width);
    }
    if (height != -1) {
        mLastHeight = height;
        setHeight(height);
    }
    if (!isShowing() || mContentView == null) {
        return;
    }
    WindowManager.LayoutParams p = (WindowManager.LayoutParams) mPopupView.getLayoutParams();
    boolean update = force;
    final int finalWidth = mWidthMode < 0 ? mWidthMode : mLastWidth;
    if (width != -1 && p.width != finalWidth) {
        p.width = mLastWidth = finalWidth;
        update = true;
    }
    final int finalHeight = mHeightMode < 0 ? mHeightMode : mLastHeight;
    if (height != -1 && p.height != finalHeight) {
        p.height = mLastHeight = finalHeight;
        update = true;
    }
    if (p.x != x) {
        p.x = x;
        update = true;
    }
    if (p.y != y) {
        p.y = y;
        update = true;
    }
    final int newAnim = computeAnimationResource();
    if (newAnim != p.windowAnimations) {
        p.windowAnimations = newAnim;
        update = true;
    }
    final int newFlags = computeFlags(p.flags);
    if (newFlags != p.flags) {
        p.flags = newFlags;
        update = true;
    }
    if (update) {
        setLayoutDirectionFromAnchor();
        mWindowManager.updateViewLayout(mPopupView, p);
    }
}","{
    if (width >= 0) {
        mLastWidth = width;
        setWidth(width);
    }
    if (height >= 0) {
        mLastHeight = height;
        setHeight(height);
    }
    if (!isShowing() || mContentView == null) {
        return;
    }
    final WindowManager.LayoutParams p = (WindowManager.LayoutParams) mDecorView.getLayoutParams();
    boolean update = force;
    final int finalWidth = mWidthMode < 0 ? mWidthMode : mLastWidth;
    if (width != -1 && p.width != finalWidth) {
        p.width = mLastWidth = finalWidth;
        update = true;
    }
    final int finalHeight = mHeightMode < 0 ? mHeightMode : mLastHeight;
    if (height != -1 && p.height != finalHeight) {
        p.height = mLastHeight = finalHeight;
        update = true;
    }
    if (p.x != x) {
        p.x = x;
        update = true;
    }
    if (p.y != y) {
        p.y = y;
        update = true;
    }
    final int newAnim = computeAnimationResource();
    if (newAnim != p.windowAnimations) {
        p.windowAnimations = newAnim;
        update = true;
    }
    final int newFlags = computeFlags(p.flags);
    if (newFlags != p.flags) {
        p.flags = newFlags;
        update = true;
    }
    if (update) {
        setLayoutDirectionFromAnchor();
        mWindowManager.updateViewLayout(mDecorView, p);
    }
}",1,"/**
 * <p>Updates the position and the dimension of the popup window. Width and
 * height can be set to -1 to update location only.  Calling this function
 * also updates the window with the current popup state as
 * described for {@link #update()}.</p>
 *
 * @param x the new x location
 * @param y the new y location
 * @param width the new width, can be -1 to ignore
 * @param height the new height, can be -1 to ignore
 * @param force reposition the window even if the specified position
 * already seems to correspond to the LayoutParams
 */
","/**
 * Updates the position and the dimension of the popup window.
 * <p>
 * Width and height can be set to -1 to update location only. Calling this
 * function also updates the window with the current popup state as
 * described for {@link #update()}.
 *
 * @param x the new x location
 * @param y the new y location
 * @param width the new width, must be >= 0 or -1 to ignore
 * @param height the new height, must be >= 0 or -1 to ignore
 * @param force {@code true} to reposition the window even if the specified
 * position already seems to correspond to the LayoutParams,
 * {@code false} to only reposition if needed
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The conditional checks for width and height have been modified from checking for not equals to -1 to greater than or equal to 0, and a variable has been renamed from mPopupView to mDecorView. Therefore, the code change type includes control dependency change (3) and another other statement changed (4).","There is no Compatibility Issue detected because the updated conditional checks do not change the values that could be returned by the method nor the exceptions that could be thrown. The method's return type is void, so there's no concern about return values, and there are no exceptions thrown by the method itself. The renaming of the variable is an internal change and does not affect the method's input parameters or output, hence it does not lead to a Compatibility Issue."
857,"<android.app.admin.DevicePolicyManager: void setPasswordMinimumNumeric(ComponentName,int)>",22,23,"<android.app.admin.DevicePolicyManager: void setPasswordMinimumNumeric(ComponentName,int)>","<android.app.admin.DevicePolicyManager: void setPasswordMinimumNumeric(ComponentName,int)>",0,"{
    if (mService != null) {
        try {
            mService.setPasswordMinimumNumeric(admin, length, UserHandle.myUserId());
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    if (mService != null) {
        try {
            mService.setPasswordMinimumNumeric(admin, length);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}",1,"/**
 * Called by an application that is administering the device to set the
 * minimum number of numerical digits required in the password. After
 * setting this, the user will not be able to enter a new password that is
 * not at least as restrictive as what has been set. Note that the current
 * password will remain until the user has set a new one, so the change does
 * not take place immediately. To prompt the user for a new password, use
 * {@link #ACTION_SET_NEW_PASSWORD} after setting this value. This
 * constraint is only imposed if the administrator has also requested
 * {@link #PASSWORD_QUALITY_COMPLEX} with {@link #setPasswordQuality}. The
 * default value is 1.
 * <p>
 * The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call
 * this method; if it has not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated
 * with.
 * @param length The new desired minimum number of numerical digits required
 * in the password. A value of 0 means there is no restriction.
 */
","/**
 * Called by an application that is administering the device to set the
 * minimum number of numerical digits required in the password. After
 * setting this, the user will not be able to enter a new password that is
 * not at least as restrictive as what has been set. Note that the current
 * password will remain until the user has set a new one, so the change does
 * not take place immediately. To prompt the user for a new password, use
 * {@link #ACTION_SET_NEW_PASSWORD} after setting this value. This
 * constraint is only imposed if the administrator has also requested
 * {@link #PASSWORD_QUALITY_COMPLEX} with {@link #setPasswordQuality}. The
 * default value is 1.
 * <p>
 * The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call
 * this method; if it has not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated
 * with.
 * @param length The new desired minimum number of numerical digits required
 * in the password. A value of 0 means there is no restriction.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,2,"The method called within the try block has changed from mService.setPasswordMinimumNumeric(admin, length, UserHandle.myUserId()) to mService.setPasswordMinimumNumeric(admin, length). The difference is the removal of the last parameter. This indicates a change in the dependent API, so the code change falls under category 5.","While there's no direct change to return types or exception handling in the given method, the altered method call to mService.setPasswordMinimumNumeric by removing a parameter could result in a difference in behavior when the method is invoked, leading to a potential Compatibility Issue. Since we cannot see an internal behavior change resulting directly in different returns or exceptions thrown within this method's implementation, the best fit is a potential Compatibility Issue due to the dependent API changed, which is classified as 2."
858,<android.content.res.Resources: int getColor(int)>,22,23,<android.content.res.Resources: int getColor(int)>,<android.content.res.Resources: int getColor(int)>,0,"{
    TypedValue value;
    synchronized (mAccessLock) {
        value = mTmpValue;
        if (value == null) {
            value = new TypedValue();
        }
        getValue(id, value, true);
        if (value.type >= TypedValue.TYPE_FIRST_INT && value.type <= TypedValue.TYPE_LAST_INT) {
            mTmpValue = value;
            return value.data;
        } else if (value.type != TypedValue.TYPE_STRING) {
            throw new NotFoundException(""Resource ID #0x"" + Integer.toHexString(id) + "" type #0x"" + Integer.toHexString(value.type) + "" is not valid"");
        }
        mTmpValue = null;
    }
    ColorStateList csl = loadColorStateList(value, id);
    synchronized (mAccessLock) {
        if (mTmpValue == null) {
            mTmpValue = value;
        }
    }
    return csl.getDefaultColor();
}","{
    return getColor(id, null);
}",1,"/**
 * Return a color integer associated with a particular resource ID.
 * If the resource holds a complex
 * {@link android.content.res.ColorStateList}, then the default color from
 * the set is returned.
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @return Returns a single color value in the form 0xAARRGGBB.
 */
","/**
 * Returns a color integer associated with a particular resource ID. If the
 * resource holds a complex {@link ColorStateList}, then the default color
 * from the set is returned.
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does
 * not exist.
 *
 * @return A single color value in the form 0xAARRGGBB.
 * @deprecated Use {@link #getColor(int, Theme)} instead.
 */
",-1,,"[@ColorInt, @Deprecated]",-1,-1,-1,-1,-1,-1,"1,5",1,"The method implementation has substantially changed from a block of code handling resource value analysis and conversion to a single method call of getColor(int, Theme). Additionally, the late version depends on the behavior of this newly called method, so the code change types are 1 and 5.","Since the method now delegates to a different method potentially with different logic, this substantially alters the behavior of the method, potentially returning a different value. The CI is thus of type 1."
860,"<android.hardware.camera2.marshal.impl.MarshalQueryableParcelable.MarshalerParcelable: void marshal(T,ByteBuffer)>",22,23,"<android.hardware.camera2.marshal.impl.MarshalQueryableParcelable.MarshalerParcelable: void marshal(T,ByteBuffer)>","<android.hardware.camera2.marshal.impl.MarshalQueryableParcelable.MarshalerParcelable: void marshal(T,ByteBuffer)>",0,"{
    if (VERBOSE) {
        Log.v(TAG, ""marshal "" + value);
    }
    Parcel parcel = Parcel.obtain();
    byte[] parcelContents;
    try {
        value.writeToParcel(parcel, /*flags*/
        0);
        if (parcel.hasFileDescriptors()) {
            throw new UnsupportedOperationException(""Parcelable "" + value + "" must not have file descriptors"");
        }
        parcelContents = parcel.marshall();
    } finally {
        parcel.recycle();
    }
    if (parcelContents.length == 0) {
        throw new AssertionError(""No data marshaled for "" + value);
    }
    buffer.put(parcelContents);
}","{
    if (DEBUG) {
        Log.v(TAG, ""marshal "" + value);
    }
    Parcel parcel = Parcel.obtain();
    byte[] parcelContents;
    try {
        value.writeToParcel(parcel, /*flags*/
        0);
        if (parcel.hasFileDescriptors()) {
            throw new UnsupportedOperationException(""Parcelable "" + value + "" must not have file descriptors"");
        }
        parcelContents = parcel.marshall();
    } finally {
        parcel.recycle();
    }
    if (parcelContents.length == 0) {
        throw new AssertionError(""No data marshaled for "" + value);
    }
    buffer.put(parcelContents);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The conditional log statement has altered from checking VERBOSE to DEBUG, but this doesn't affect how the function operates with respect to marshaling the data. Therefore, the change type is 4, which is Other statement changed.",This change won't cause any Compatibility Issues as it only impacts logging and doesn't affect the API's behavior.
861,"<android.widget.SimpleMonthView.MonthViewTouchHelper: void onPopulateNodeForVirtualView(int,AccessibilityNodeInfo)>",22,23,"<android.widget.SimpleMonthView.MonthViewTouchHelper: void onPopulateNodeForVirtualView(int,AccessibilityNodeInfo)>","<android.widget.SimpleMonthView.MonthViewTouchHelper: void onPopulateNodeForVirtualView(int,AccessibilityNodeInfo)>",0,"{
    getItemBounds(virtualViewId, mTempRect);
    node.setContentDescription(getItemDescription(virtualViewId));
    node.setBoundsInParent(mTempRect);
    node.addAction(AccessibilityNodeInfo.ACTION_CLICK);
    if (virtualViewId == mSelectedDay) {
        node.setSelected(true);
    }
}","{
    final boolean hasBounds = getBoundsForDay(virtualViewId, mTempRect);
    if (!hasBounds) {
        // The day is invalid, kill the node.
        mTempRect.setEmpty();
        node.setContentDescription("""");
        node.setBoundsInParent(mTempRect);
        node.setVisibleToUser(false);
        return;
    }
    node.setText(getDayText(virtualViewId));
    node.setContentDescription(getDayDescription(virtualViewId));
    node.setBoundsInParent(mTempRect);
    final boolean isDayEnabled = isDayEnabled(virtualViewId);
    if (isDayEnabled) {
        node.addAction(AccessibilityAction.ACTION_CLICK);
    }
    node.setEnabled(isDayEnabled);
    if (virtualViewId == mActivatedDay) {
        // TODO: This should use activated once that's supported.
        node.setChecked(true);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"There are multiple changes. First, the method getItemBounds() was replaced with getBoundsForDay() and conditional check on the result of this method is added before continuing, which is a control dependency change. Additionally, the text-setting method has changed from node.setContentDescription() to node.setText() and node.setContentDescription(), and method calls node.setVisibleToUser() and node.setEnabled() have been added. Additionally, 'node.setSelected(true)' has been changed to 'node.setChecked(true)' and the condition 'virtualViewId == mSelectedDay' was changed to 'virtualViewId == mActivatedDay' which means a different field is now considered for setting the node state. These together indicate changes to return statements, control dependencies, other statements, and dependent API methods. Therefore, the change type is 1,3,4,5.","The changes in the implementation potentially affect the behavior of the method, which could result in different nodes being populated or not populated at all (e.g., setVisibleToUser(false) and early return from the method if hasBounds is false). Additionally, changes in the AccessibilityNodeInfo properties being set (setText(), setContentDescription(), setChecked()) could also lead to different return values. Thus the CI type is 1."
862,"<android.app.admin.DevicePolicyManager: boolean installKeyPair(ComponentName,PrivateKey,Certificate,String)>",22,23,"<android.app.admin.DevicePolicyManager: boolean installKeyPair(ComponentName,PrivateKey,Certificate,String)>","<android.app.admin.DevicePolicyManager: boolean installKeyPair(ComponentName,PrivateKey,Certificate,String)>",0,"{
    try {
        final byte[] pemCert = Credentials.convertToPem(cert);
        return mService.installKeyPair(who, privKey.getEncoded(), pemCert, alias);
    } catch (CertificateException e) {
        Log.w(TAG, ""Error encoding certificate"", e);
    } catch (IOException e) {
        Log.w(TAG, ""Error writing certificate"", e);
    } catch (RemoteException e) {
        Log.w(TAG, ""Failed talking with device policy service"", e);
    }
    return false;
}","{
    try {
        final byte[] pemCert = Credentials.convertToPem(cert);
        final byte[] pkcs8Key = KeyFactory.getInstance(privKey.getAlgorithm()).getKeySpec(privKey, PKCS8EncodedKeySpec.class).getEncoded();
        return mService.installKeyPair(admin, pkcs8Key, pemCert, alias);
    } catch (RemoteException e) {
        Log.w(TAG, ""Failed talking with device policy service"", e);
    } catch (NoSuchAlgorithmException | InvalidKeySpecException e) {
        Log.w(TAG, ""Failed to obtain private key material"", e);
    } catch (CertificateException | IOException e) {
        Log.w(TAG, ""Could not pem-encode certificate"", e);
    }
    return false;
}",1,"/**
 * Called by a device or profile owner to install a certificate and private key pair. The
 * keypair will be visible to all apps within the profile.
 *
 * @param who Which {@link DeviceAdminReceiver} this request is associated with.
 * @param privKey The private key to install.
 * @param cert The certificate to install.
 * @param alias The private key alias under which to install the certificate. If a certificate
 * with that alias already exists, it will be overwritten.
 * @return {@code true} if the keys were installed, {@code false} otherwise.
 */
","/**
 * Called by a device or profile owner to install a certificate and private key pair. The
 * keypair will be visible to all apps within the profile.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or
 * {@code null} if calling from a delegated certificate installer.
 * @param privKey The private key to install.
 * @param cert The certificate to install.
 * @param alias The private key alias under which to install the certificate. If a certificate
 * with that alias already exists, it will be overwritten.
 * @return {@code true} if the keys were installed, {@code false} otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,4,5","1,2","The method's internal implementation has been changed to include a new way of encoding the private key (`final byte[] pkcs8Key = ...`) before calling the `installKeyPair` method. Moreover, the exception handling has been modified: some catch blocks have been combined, and others have been separated, changing the flow of exception handling. Additionally, the catch clause for `CertificateException` and `IOException` has been merged. Finally, the parameter passed to `mService.installKeyPair` has been changed from `who` to `admin` and `privKey.getEncoded()` to `pkcs8Key`. Therefore, the change types are 2,3 (the flow of the code has changed due to exception handling and a new try block content), 4 (other modifications that do not match the prior categories), and 5 (there's a change in the method call to `mService.installKeyPair`, this counts as a dependent API change because the internal implementation now uses different parameters).","The difference in encoding the private key and changes in exception handling might lead to a different return value or exception thrown, so the CI types are 1 and 2. Specifically, the use of a different key encoding mechanism can result in the method failing in scenarios where it previously succeeded (or vice versa), leading to a different return value. Furthermore, changes in the exception catch blocks mean different exceptions or messages might propagate upwards in versions where they did not previously, resulting in a potential behavioral difference when exceptions are thrown."
865,<android.app.ContextImpl: Context createConfigurationContext(Configuration)>,22,23,<android.app.ContextImpl: Context createConfigurationContext(Configuration)>,<android.app.ContextImpl: Context createConfigurationContext(Configuration)>,0,"{
    if (overrideConfiguration == null) {
        throw new IllegalArgumentException(""overrideConfiguration must not be null"");
    }
    return new ContextImpl(this, mMainThread, mPackageInfo, mActivityToken, mUser, mRestricted, mDisplay, overrideConfiguration);
}","{
    if (overrideConfiguration == null) {
        throw new IllegalArgumentException(""overrideConfiguration must not be null"");
    }
    return new ContextImpl(this, mMainThread, mPackageInfo, mActivityToken, mUser, mRestricted, mDisplay, overrideConfiguration, Display.INVALID_DISPLAY);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"There is an additional argument (Display.INVALID_DISPLAY) passed to the constructor of ContextImpl in the late implementation which is a change in the method invocation, so the code change type is 4.","The change is an additional constant argument added to the new object creation expression and does not affect the return type, the exceptions thrown by the method, or the control flow. As such, it should not cause any compatibility issues based on the information provided, so the CI type is 0."
866,"<android.gesture.GestureUtils: float[] temporalSampling(GestureStroke,int)>",22,23,"<android.gesture.GestureUtils: float[] temporalSampling(GestureStroke,int)>","<android.gesture.GestureUtils: float[] temporalSampling(GestureStroke,int)>",0,"{
    final float increment = stroke.length / (numPoints - 1);
    int vectorLength = numPoints * 2;
    float[] vector = new float[vectorLength];
    float distanceSoFar = 0;
    float[] pts = stroke.points;
    float lstPointX = pts[0];
    float lstPointY = pts[1];
    int index = 0;
    float currentPointX = Float.MIN_VALUE;
    float currentPointY = Float.MIN_VALUE;
    vector[index] = lstPointX;
    index++;
    vector[index] = lstPointY;
    index++;
    int i = 0;
    int count = pts.length / 2;
    while (i < count) {
        if (currentPointX == Float.MIN_VALUE) {
            i++;
            if (i >= count) {
                break;
            }
            currentPointX = pts[i * 2];
            currentPointY = pts[i * 2 + 1];
        }
        float deltaX = currentPointX - lstPointX;
        float deltaY = currentPointY - lstPointY;
        float distance = (float) Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        if (distanceSoFar + distance >= increment) {
            float ratio = (increment - distanceSoFar) / distance;
            float nx = lstPointX + ratio * deltaX;
            float ny = lstPointY + ratio * deltaY;
            vector[index] = nx;
            index++;
            vector[index] = ny;
            index++;
            lstPointX = nx;
            lstPointY = ny;
            distanceSoFar = 0;
        } else {
            lstPointX = currentPointX;
            lstPointY = currentPointY;
            currentPointX = Float.MIN_VALUE;
            currentPointY = Float.MIN_VALUE;
            distanceSoFar += distance;
        }
    }
    for (i = index; i < vectorLength; i += 2) {
        vector[i] = lstPointX;
        vector[i + 1] = lstPointY;
    }
    return vector;
}","{
    final float increment = stroke.length / (numPoints - 1);
    int vectorLength = numPoints * 2;
    float[] vector = new float[vectorLength];
    float distanceSoFar = 0;
    float[] pts = stroke.points;
    float lstPointX = pts[0];
    float lstPointY = pts[1];
    int index = 0;
    float currentPointX = Float.MIN_VALUE;
    float currentPointY = Float.MIN_VALUE;
    vector[index] = lstPointX;
    index++;
    vector[index] = lstPointY;
    index++;
    int i = 0;
    int count = pts.length / 2;
    while (i < count) {
        if (currentPointX == Float.MIN_VALUE) {
            i++;
            if (i >= count) {
                break;
            }
            currentPointX = pts[i * 2];
            currentPointY = pts[i * 2 + 1];
        }
        float deltaX = currentPointX - lstPointX;
        float deltaY = currentPointY - lstPointY;
        float distance = (float) Math.hypot(deltaX, deltaY);
        if (distanceSoFar + distance >= increment) {
            float ratio = (increment - distanceSoFar) / distance;
            float nx = lstPointX + ratio * deltaX;
            float ny = lstPointY + ratio * deltaY;
            vector[index] = nx;
            index++;
            vector[index] = ny;
            index++;
            lstPointX = nx;
            lstPointY = ny;
            distanceSoFar = 0;
        } else {
            lstPointX = currentPointX;
            lstPointY = currentPointY;
            currentPointX = Float.MIN_VALUE;
            currentPointY = Float.MIN_VALUE;
            distanceSoFar += distance;
        }
    }
    for (i = index; i < vectorLength; i += 2) {
        vector[i] = lstPointX;
        vector[i + 1] = lstPointY;
    }
    return vector;
}",1,"/**
 * Samples a stroke temporally into a given number of evenly-distributed
 * points.
 *
 * @param stroke the gesture stroke to be sampled
 * @param numPoints the number of points
 * @return the sampled points in the form of [x1, y1, x2, y2, ..., xn, yn]
 */
","/**
 * Samples a stroke temporally into a given number of evenly-distributed
 * points.
 *
 * @param stroke the gesture stroke to be sampled
 * @param numPoints the number of points
 * @return the sampled points in the form of [x1, y1, x2, y2, ..., xn, yn]
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"There is one method change within the implementation, where Math.sqrt(deltaX * deltaX + deltaY * deltaY) has been replaced with Math.hypot(deltaX, deltaY). This change falls under the category of 'Other statement changed'.","There is no Compatibility Issue, as the Math.hypot method is functionally equivalent to the computation of the square root of the sum of the squares of deltaX and deltaY. It is more precise and avoids intermediate overflow or underflow, but the output remains conceptually the same, hence no difference in the behavior of the API."
867,<android.app.FragmentManagerImpl: void makeInactive(Fragment)>,22,23,<android.app.FragmentManagerImpl: void makeInactive(Fragment)>,<android.app.FragmentManagerImpl: void makeInactive(Fragment)>,0,"{
    if (f.mIndex < 0) {
        return;
    }
    if (DEBUG)
        Log.v(TAG, ""Freeing fragment index "" + f);
    mActive.set(f.mIndex, null);
    if (mAvailIndices == null) {
        mAvailIndices = new ArrayList<Integer>();
    }
    mAvailIndices.add(f.mIndex);
    mActivity.invalidateFragment(f.mWho);
    f.initState();
}","{
    if (f.mIndex < 0) {
        return;
    }
    if (DEBUG)
        Log.v(TAG, ""Freeing fragment index "" + f);
    mActive.set(f.mIndex, null);
    if (mAvailIndices == null) {
        mAvailIndices = new ArrayList<Integer>();
    }
    mAvailIndices.add(f.mIndex);
    mHost.inactivateFragment(f.mWho);
    f.initState();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method call mActivity.invalidateFragment(f.mWho) has changed to mHost.inactivateFragment(f.mWho), which reflects a change in the dependent API, so the code change type is 5.","Since only the method being called has changed without altering the external behavior of the method, there is no change to what this API returns or exception it throws. Thus, this should not introduce a compatibility issue, and the CI type is 0."
868,"<android.widget.AbsListView: void onInitializeAccessibilityNodeInfoForItem(View,int,AccessibilityNodeInfo)>",22,23,"<android.widget.AbsListView: void onInitializeAccessibilityNodeInfoForItem(View,int,AccessibilityNodeInfo)>","<android.widget.AbsListView: void onInitializeAccessibilityNodeInfoForItem(View,int,AccessibilityNodeInfo)>",0,"{
    final ListAdapter adapter = getAdapter();
    if (position == INVALID_POSITION || adapter == null) {
        // The item doesn't exist, so there's not much we can do here.
        return;
    }
    if (!isEnabled() || !adapter.isEnabled(position)) {
        info.setEnabled(false);
        return;
    }
    if (position == getSelectedItemPosition()) {
        info.setSelected(true);
        info.addAction(AccessibilityNodeInfo.ACTION_CLEAR_SELECTION);
    } else {
        info.addAction(AccessibilityNodeInfo.ACTION_SELECT);
    }
    if (isClickable()) {
        info.addAction(AccessibilityNodeInfo.ACTION_CLICK);
        info.setClickable(true);
    }
    if (isLongClickable()) {
        info.addAction(AccessibilityNodeInfo.ACTION_LONG_CLICK);
        info.setLongClickable(true);
    }
}","{
    final ListAdapter adapter = getAdapter();
    if (position == INVALID_POSITION || adapter == null) {
        // The item doesn't exist, so there's not much we can do here.
        return;
    }
    if (!isEnabled() || !adapter.isEnabled(position)) {
        info.setEnabled(false);
        return;
    }
    if (position == getSelectedItemPosition()) {
        info.setSelected(true);
        info.addAction(AccessibilityAction.ACTION_CLEAR_SELECTION);
    } else {
        info.addAction(AccessibilityAction.ACTION_SELECT);
    }
    if (isClickable()) {
        info.addAction(AccessibilityAction.ACTION_CLICK);
        info.setClickable(true);
    }
    if (isLongClickable()) {
        info.addAction(AccessibilityAction.ACTION_LONG_CLICK);
        info.setLongClickable(true);
    }
}",1,"/**
 * Initializes an {@link AccessibilityNodeInfo} with information about a
 * particular item in the list.
 *
 * @param view View representing the list item.
 * @param position Position of the list item within the adapter.
 * @param info Node info to populate.
 */
","/**
 * Initializes an {@link AccessibilityNodeInfo} with information about a
 * particular item in the list.
 *
 * @param view View representing the list item.
 * @param position Position of the list item within the adapter.
 * @param info Node info to populate.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The changes involve replacing `AccessibilityNodeInfo.ACTION_*` constants with `AccessibilityAction.ACTION_*`. This is a reflection of dependent API changes, so the change type is 5.","There's no compatibility issue due to the change in the constant values because the `AccessibilityAction.ACTION_*` constants correspond to the `AccessibilityNodeInfo.ACTION_*` constants, so the behavior of the method should remain the same. Therefore, there is no CI."
869,"<android.app.Activity: boolean onKeyShortcut(int,KeyEvent)>",22,23,"<android.app.Activity: boolean onKeyShortcut(int,KeyEvent)>","<android.app.Activity: boolean onKeyShortcut(int,KeyEvent)>",0,"{
    return false;
}","{
    // Let the Action Bar have a chance at handling the shortcut.
    ActionBar actionBar = getActionBar();
    return (actionBar != null && actionBar.onKeyShortcut(keyCode, event));
}",1,"/**
 * Called when a key shortcut event is not handled by any of the views in the Activity.
 * Override this method to implement global key shortcuts for the Activity.
 * Key shortcuts can also be implemented by setting the
 * {@link MenuItem#setShortcut(char, char) shortcut} property of menu items.
 *
 * @param keyCode The value in event.getKeyCode().
 * @param event Description of the key event.
 * @return True if the key shortcut was handled.
 */
","/**
 * Called when a key shortcut event is not handled by any of the views in the Activity.
 * Override this method to implement global key shortcuts for the Activity.
 * Key shortcuts can also be implemented by setting the
 * {@link MenuItem#setShortcut(char, char) shortcut} property of menu items.
 *
 * @param keyCode The value in event.getKeyCode().
 * @param event Description of the key event.
 * @return True if the key shortcut was handled.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The late version of the method has a new set of statements: creating an ActionBar object and using a conditional check to return a value based on the result of actionBar.onKeyShortcut(keyCode, event), which is a dependent API changed. This constitutes return statement changes, statement changes that are not about control dependencies, and changes involving another API, so the change type is classified as 1,4,5.","In the early version, the method always returns false, but in the late version, it returns the result of the ActionBar's onKeyShortcut method if the actionBar is not null. This could potentially return a different value compared to the early version, leading to a different behavior, so the CI type is 1."
872,<android.service.wallpaper.WallpaperService.Engine: void attach(IWallpaperEngineWrapper)>,22,23,<android.service.wallpaper.WallpaperService.Engine: void attach(IWallpaperEngineWrapper)>,<android.service.wallpaper.WallpaperService.Engine: void attach(IWallpaperEngineWrapper)>,0,"{
    if (DEBUG)
        Log.v(TAG, ""attach: "" + this + "" wrapper="" + wrapper);
    if (mDestroyed) {
        return;
    }
    mIWallpaperEngine = wrapper;
    mCaller = wrapper.mCaller;
    mConnection = wrapper.mConnection;
    mWindowToken = wrapper.mWindowToken;
    mSurfaceHolder.setSizeFromLayout();
    mInitializing = true;
    mSession = WindowManagerGlobal.getWindowSession();
    mWindow.setSession(mSession);
    mDisplayManager = (DisplayManager) getSystemService(Context.DISPLAY_SERVICE);
    mDisplayManager.registerDisplayListener(mDisplayListener, mCaller.getHandler());
    mDisplay = mDisplayManager.getDisplay(Display.DEFAULT_DISPLAY);
    if (DEBUG)
        Log.v(TAG, ""onCreate(): "" + this);
    onCreate(mSurfaceHolder);
    mInitializing = false;
    mReportedVisible = false;
    updateSurface(false, false, false);
}","{
    if (DEBUG)
        Log.v(TAG, ""attach: "" + this + "" wrapper="" + wrapper);
    if (mDestroyed) {
        return;
    }
    mIWallpaperEngine = wrapper;
    mCaller = wrapper.mCaller;
    mConnection = wrapper.mConnection;
    mWindowToken = wrapper.mWindowToken;
    mSurfaceHolder.setSizeFromLayout();
    mInitializing = true;
    mSession = WindowManagerGlobal.getWindowSession();
    mWindow.setSession(mSession);
    mLayout.packageName = getPackageName();
    mDisplayManager = (DisplayManager) getSystemService(Context.DISPLAY_SERVICE);
    mDisplayManager.registerDisplayListener(mDisplayListener, mCaller.getHandler());
    mDisplay = mDisplayManager.getDisplay(Display.DEFAULT_DISPLAY);
    mDisplayState = mDisplay.getState();
    if (DEBUG)
        Log.v(TAG, ""onCreate(): "" + this);
    onCreate(mSurfaceHolder);
    mInitializing = false;
    mReportedVisible = false;
    updateSurface(false, false, false);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The following new statement has been introduced in the late version: `mLayout.packageName = getPackageName();` and `mDisplayState = mDisplay.getState();`, which are assignments that do not impact return values or exception handlings. Therefore, the code change type is 4.","Since the late implementation does not alter any existing return statements, exception handling statements or the control flow of the method, and the new assignments do not impact the behavior observed by the caller in terms of different return values or types, and it does not introduce new exception handlings, there is no compatibility issue. Hence, the CI type is 0."
873,"<android.net.ConnectivityManager: int stopUsingNetworkFeature(int,String)>",22,23,"<android.net.ConnectivityManager: int stopUsingNetworkFeature(int,String)>","<android.net.ConnectivityManager: int stopUsingNetworkFeature(int,String)>",0,"{
    NetworkCapabilities netCap = networkCapabilitiesForFeature(networkType, feature);
    if (netCap == null) {
        Log.d(TAG, ""Can't satisfy stopUsingNetworkFeature for "" + networkType + "", "" + feature);
        return -1;
    }
    if (removeRequestForFeature(netCap)) {
        Log.d(TAG, ""stopUsingNetworkFeature for "" + networkType + "", "" + feature);
    }
    return 1;
}","{
    checkLegacyRoutingApiAccess();
    NetworkCapabilities netCap = networkCapabilitiesForFeature(networkType, feature);
    if (netCap == null) {
        Log.d(TAG, ""Can't satisfy stopUsingNetworkFeature for "" + networkType + "", "" + feature);
        return -1;
    }
    if (removeRequestForFeature(netCap)) {
        Log.d(TAG, ""stopUsingNetworkFeature for "" + networkType + "", "" + feature);
    }
    return 1;
}",1,"/**
 * Tells the underlying networking system that the caller is finished
 * using the named feature. The interpretation of {@code feature}
 * is completely up to each networking implementation.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#CHANGE_NETWORK_STATE}.
 * @param networkType specifies which network the request pertains to
 * @param feature the name of the feature that is no longer needed
 * @return an integer value representing the outcome of the request.
 * The interpretation of this value is specific to each networking
 * implementation+feature combination, except that the value {@code -1}
 * always indicates failure.
 *
 * @deprecated Deprecated in favor of the cleaner {@link #requestNetwork} api.
 */
","/**
 * Tells the underlying networking system that the caller is finished
 * using the named feature. The interpretation of {@code feature}
 * is completely up to each networking implementation.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#CHANGE_NETWORK_STATE}.
 * @param networkType specifies which network the request pertains to
 * @param feature the name of the feature that is no longer needed
 * @return an integer value representing the outcome of the request.
 * The interpretation of this value is specific to each networking
 * implementation+feature combination, except that the value {@code -1}
 * always indicates failure.
 *
 * @deprecated Deprecated in favor of the cleaner {@link #unregisterNetworkCallback} API.
 * In {@link VERSION_CODES#M}, and above, this method is unsupported and will
 * throw {@code UnsupportedOperationException} if called.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"A new method call (checkLegacyRoutingApiAccess()) has been added, which does not directly change the return value or exception handling. Therefore, the code change type is 4.","Because the method checkLegacyRoutingApiAccess() is called at the beginning and does not affect the output or the exception handling of the method stopUsingNetworkFeature(int, String), there is no compatibility issue."
874,"<android.accounts.AccountManager: Account[] getAccountsByTypeForPackage(String,String)>",22,23,"<android.accounts.AccountManager: Account[] getAccountsByTypeForPackage(String,String)>","<android.accounts.AccountManager: Account[] getAccountsByTypeForPackage(String,String)>",0,"{
    try {
        return mService.getAccountsByTypeForPackage(type, packageName);
    } catch (RemoteException re) {
        // possible security exception
        throw new RuntimeException(re);
    }
}","{
    try {
        return mService.getAccountsByTypeForPackage(type, packageName, mContext.getOpPackageName());
    } catch (RemoteException re) {
        // won't ever happen
        throw new RuntimeException(re);
    }
}",1,"/**
 * Returns the accounts visible to the specified package, in an environment where some apps
 * are not authorized to view all accounts. This method can only be called by system apps.
 * @param type The type of accounts to return, null to retrieve all accounts
 * @param packageName The package name of the app for which the accounts are to be returned
 * @return An array of {@link Account}, one per matching account.  Empty
 * (never null) if no accounts of the specified type have been added.
 */
","/**
 * Returns the accounts visible to the specified package, in an environment where some apps
 * are not authorized to view all accounts. This method can only be called by system apps.
 * @param type The type of accounts to return, null to retrieve all accounts
 * @param packageName The package name of the app for which the accounts are to be returned
 * @return An array of {@link Account}, one per matching account.  Empty
 * (never null) if no accounts of the specified type have been added.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"There is an additional parameter passed to the mService.getAccountsByTypeForPackage in the late version, which is mContext.getOpPackageName(), but the structure of exception handling remains the same, so the change type is 4 for the additional parameter passed to the method call, and 5 for a change in the dependent API being called.","There is no change that would lead to different return values or exception handling. The addition of a context-specific package name as a parameter is an internal change to how the method fetches accounts and it does not affect the external contract of the method. Therefore, no Compatibility Issue can be concluded from this change and the CI type is 0."
875,<android.widget.Editor.HandleView: boolean onTouchEvent(MotionEvent)>,22,23,<android.widget.Editor.HandleView: boolean onTouchEvent(MotionEvent)>,<android.widget.Editor.HandleView: boolean onTouchEvent(MotionEvent)>,0,"{
    switch(ev.getActionMasked()) {
        case MotionEvent.ACTION_DOWN:
            {
                startTouchUpFilter(getCurrentCursorOffset());
                mTouchToWindowOffsetX = ev.getRawX() - mPositionX;
                mTouchToWindowOffsetY = ev.getRawY() - mPositionY;
                final PositionListener positionListener = getPositionListener();
                mLastParentX = positionListener.getPositionX();
                mLastParentY = positionListener.getPositionY();
                mIsDragging = true;
                break;
            }
        case MotionEvent.ACTION_MOVE:
            {
                final float rawX = ev.getRawX();
                final float rawY = ev.getRawY();
                // Vertical hysteresis: vertical down movement tends to snap to ideal offset
                final float previousVerticalOffset = mTouchToWindowOffsetY - mLastParentY;
                final float currentVerticalOffset = rawY - mPositionY - mLastParentY;
                float newVerticalOffset;
                if (previousVerticalOffset < mIdealVerticalOffset) {
                    newVerticalOffset = Math.min(currentVerticalOffset, mIdealVerticalOffset);
                    newVerticalOffset = Math.max(newVerticalOffset, previousVerticalOffset);
                } else {
                    newVerticalOffset = Math.max(currentVerticalOffset, mIdealVerticalOffset);
                    newVerticalOffset = Math.min(newVerticalOffset, previousVerticalOffset);
                }
                mTouchToWindowOffsetY = newVerticalOffset + mLastParentY;
                final float newPosX = rawX - mTouchToWindowOffsetX + mHotspotX;
                final float newPosY = rawY - mTouchToWindowOffsetY + mTouchOffsetY;
                updatePosition(newPosX, newPosY);
                break;
            }
        case MotionEvent.ACTION_UP:
            filterOnTouchUp();
            mIsDragging = false;
            break;
        case MotionEvent.ACTION_CANCEL:
            mIsDragging = false;
            break;
    }
    return true;
}","{
    updateFloatingToolbarVisibility(ev);
    switch(ev.getActionMasked()) {
        case MotionEvent.ACTION_DOWN:
            {
                startTouchUpFilter(getCurrentCursorOffset());
                mTouchToWindowOffsetX = ev.getRawX() - mPositionX;
                mTouchToWindowOffsetY = ev.getRawY() - mPositionY;
                final PositionListener positionListener = getPositionListener();
                mLastParentX = positionListener.getPositionX();
                mLastParentY = positionListener.getPositionY();
                mIsDragging = true;
                mPreviousLineTouched = UNSET_LINE;
                break;
            }
        case MotionEvent.ACTION_MOVE:
            {
                final float rawX = ev.getRawX();
                final float rawY = ev.getRawY();
                // Vertical hysteresis: vertical down movement tends to snap to ideal offset
                final float previousVerticalOffset = mTouchToWindowOffsetY - mLastParentY;
                final float currentVerticalOffset = rawY - mPositionY - mLastParentY;
                float newVerticalOffset;
                if (previousVerticalOffset < mIdealVerticalOffset) {
                    newVerticalOffset = Math.min(currentVerticalOffset, mIdealVerticalOffset);
                    newVerticalOffset = Math.max(newVerticalOffset, previousVerticalOffset);
                } else {
                    newVerticalOffset = Math.max(currentVerticalOffset, mIdealVerticalOffset);
                    newVerticalOffset = Math.min(newVerticalOffset, previousVerticalOffset);
                }
                mTouchToWindowOffsetY = newVerticalOffset + mLastParentY;
                final float newPosX = rawX - mTouchToWindowOffsetX + mHotspotX + getHorizontalOffset();
                final float newPosY = rawY - mTouchToWindowOffsetY + mTouchOffsetY;
                updatePosition(newPosX, newPosY);
                break;
            }
        case MotionEvent.ACTION_UP:
            filterOnTouchUp();
            mIsDragging = false;
            updateDrawable();
            break;
        case MotionEvent.ACTION_CANCEL:
            mIsDragging = false;
            updateDrawable();
            break;
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The late version introduces a new method call `updateFloatingToolbarVisibility(ev)` at the beginning and `updateDrawable()` at the end of both `ACTION_UP` and `ACTION_CANCEL` cases. It also adds the assignment `mPreviousLineTouched = UNSET_LINE;` during the `ACTION_DOWN` case, and it modifies the computation of `newPosX` by adding `getHorizontalOffset()`. These represent a control dependency change for the overall method flow and other statement changes that don't alter return values directly or modify exception handling since the method consistently returns `true` in both versions and does not include any exception handling code, so the code change type is 3,4.","Although there are code changes, they do not affect the return value of the method, which remains a constant `true` in both versions, nor do they introduce any new exceptions or change how existing exceptions might be handled. Therefore, these changes do not lead to a Compatibility Issue, and the CI type is 0."
876,"<android.content.ContentResolver: AssetFileDescriptor openTypedAssetFileDescriptor(Uri,String,Bundle,CancellationSignal)>",22,23,"<android.content.ContentResolver: AssetFileDescriptor openTypedAssetFileDescriptor(Uri,String,Bundle,CancellationSignal)>","<android.content.ContentResolver: AssetFileDescriptor openTypedAssetFileDescriptor(Uri,String,Bundle,CancellationSignal)>",0,"{
    IContentProvider unstableProvider = acquireUnstableProvider(uri);
    if (unstableProvider == null) {
        throw new FileNotFoundException(""No content provider: "" + uri);
    }
    IContentProvider stableProvider = null;
    AssetFileDescriptor fd = null;
    try {
        ICancellationSignal remoteCancellationSignal = null;
        if (cancellationSignal != null) {
            cancellationSignal.throwIfCanceled();
            remoteCancellationSignal = unstableProvider.createCancellationSignal();
            cancellationSignal.setRemote(remoteCancellationSignal);
        }
        try {
            fd = unstableProvider.openTypedAssetFile(mPackageName, uri, mimeType, opts, remoteCancellationSignal);
            if (fd == null) {
                // The provider will be released by the finally{} clause
                return null;
            }
        } catch (DeadObjectException e) {
            // The remote process has died...  but we only hold an unstable
            // reference though, so we might recover!!!  Let's try!!!!
            // This is exciting!!1!!1!!!!1
            unstableProviderDied(unstableProvider);
            stableProvider = acquireProvider(uri);
            if (stableProvider == null) {
                throw new FileNotFoundException(""No content provider: "" + uri);
            }
            fd = stableProvider.openTypedAssetFile(mPackageName, uri, mimeType, opts, remoteCancellationSignal);
            if (fd == null) {
                // The provider will be released by the finally{} clause
                return null;
            }
        }
        if (stableProvider == null) {
            stableProvider = acquireProvider(uri);
        }
        releaseUnstableProvider(unstableProvider);
        ParcelFileDescriptor pfd = new ParcelFileDescriptorInner(fd.getParcelFileDescriptor(), stableProvider);
        // Success!  Don't release the provider when exiting, let
        // ParcelFileDescriptorInner do that when it is closed.
        stableProvider = null;
        return new AssetFileDescriptor(pfd, fd.getStartOffset(), fd.getDeclaredLength());
    } catch (RemoteException e) {
        // Whatever, whatever, we'll go away.
        throw new FileNotFoundException(""Failed opening content provider: "" + uri);
    } catch (FileNotFoundException e) {
        throw e;
    } finally {
        if (cancellationSignal != null) {
            cancellationSignal.setRemote(null);
        }
        if (stableProvider != null) {
            releaseProvider(stableProvider);
        }
        if (unstableProvider != null) {
            releaseUnstableProvider(unstableProvider);
        }
    }
}","{
    Preconditions.checkNotNull(uri, ""uri"");
    Preconditions.checkNotNull(mimeType, ""mimeType"");
    IContentProvider unstableProvider = acquireUnstableProvider(uri);
    if (unstableProvider == null) {
        throw new FileNotFoundException(""No content provider: "" + uri);
    }
    IContentProvider stableProvider = null;
    AssetFileDescriptor fd = null;
    try {
        ICancellationSignal remoteCancellationSignal = null;
        if (cancellationSignal != null) {
            cancellationSignal.throwIfCanceled();
            remoteCancellationSignal = unstableProvider.createCancellationSignal();
            cancellationSignal.setRemote(remoteCancellationSignal);
        }
        try {
            fd = unstableProvider.openTypedAssetFile(mPackageName, uri, mimeType, opts, remoteCancellationSignal);
            if (fd == null) {
                // The provider will be released by the finally{} clause
                return null;
            }
        } catch (DeadObjectException e) {
            // The remote process has died...  but we only hold an unstable
            // reference though, so we might recover!!!  Let's try!!!!
            // This is exciting!!1!!1!!!!1
            unstableProviderDied(unstableProvider);
            stableProvider = acquireProvider(uri);
            if (stableProvider == null) {
                throw new FileNotFoundException(""No content provider: "" + uri);
            }
            fd = stableProvider.openTypedAssetFile(mPackageName, uri, mimeType, opts, remoteCancellationSignal);
            if (fd == null) {
                // The provider will be released by the finally{} clause
                return null;
            }
        }
        if (stableProvider == null) {
            stableProvider = acquireProvider(uri);
        }
        releaseUnstableProvider(unstableProvider);
        ParcelFileDescriptor pfd = new ParcelFileDescriptorInner(fd.getParcelFileDescriptor(), stableProvider);
        // Success!  Don't release the provider when exiting, let
        // ParcelFileDescriptorInner do that when it is closed.
        stableProvider = null;
        return new AssetFileDescriptor(pfd, fd.getStartOffset(), fd.getDeclaredLength());
    } catch (RemoteException e) {
        // Whatever, whatever, we'll go away.
        throw new FileNotFoundException(""Failed opening content provider: "" + uri);
    } catch (FileNotFoundException e) {
        throw e;
    } finally {
        if (cancellationSignal != null) {
            cancellationSignal.setRemote(null);
        }
        if (stableProvider != null) {
            releaseProvider(stableProvider);
        }
        if (unstableProvider != null) {
            releaseUnstableProvider(unstableProvider);
        }
    }
}",1,"/**
 * Open a raw file descriptor to access (potentially type transformed)
 * data from a ""content:"" URI.  This interacts with the underlying
 * {@link ContentProvider#openTypedAssetFile} method of the provider
 * associated with the given URI, to retrieve retrieve any appropriate
 * data stream for the data stored there.
 *
 * <p>Unlike {@link #openAssetFileDescriptor}, this function only works
 * with ""content:"" URIs, because content providers are the only facility
 * with an associated MIME type to ensure that the returned data stream
 * is of the desired type.
 *
 * <p>All text/* streams are encoded in UTF-8.
 *
 * @param uri The desired URI to open.
 * @param mimeType The desired MIME type of the returned data.  This can
 * be a pattern such as *&#47;*, which will allow the content provider to
 * select a type, though there is no way for you to determine what type
 * it is returning.
 * @param opts Additional provider-dependent options.
 * @param cancellationSignal A signal to cancel the operation in progress,
 * or null if none. If the operation is canceled, then
 * {@link OperationCanceledException} will be thrown.
 * @return Returns a new ParcelFileDescriptor from which you can read the
 * data stream from the provider.  Note that this may be a pipe, meaning
 * you can't seek in it.  The only seek you should do is if the
 * AssetFileDescriptor contains an offset, to move to that offset before
 * reading.  You own this descriptor and are responsible for closing it when done.
 * @throws FileNotFoundException Throws FileNotFoundException of no
 * data of the desired type exists under the URI.
 */
","/**
 * Open a raw file descriptor to access (potentially type transformed)
 * data from a ""content:"" URI.  This interacts with the underlying
 * {@link ContentProvider#openTypedAssetFile} method of the provider
 * associated with the given URI, to retrieve retrieve any appropriate
 * data stream for the data stored there.
 *
 * <p>Unlike {@link #openAssetFileDescriptor}, this function only works
 * with ""content:"" URIs, because content providers are the only facility
 * with an associated MIME type to ensure that the returned data stream
 * is of the desired type.
 *
 * <p>All text/* streams are encoded in UTF-8.
 *
 * @param uri The desired URI to open.
 * @param mimeType The desired MIME type of the returned data.  This can
 * be a pattern such as *&#47;*, which will allow the content provider to
 * select a type, though there is no way for you to determine what type
 * it is returning.
 * @param opts Additional provider-dependent options.
 * @param cancellationSignal A signal to cancel the operation in progress,
 * or null if none. If the operation is canceled, then
 * {@link OperationCanceledException} will be thrown.
 * @return Returns a new ParcelFileDescriptor from which you can read the
 * data stream from the provider.  Note that this may be a pipe, meaning
 * you can't seek in it.  The only seek you should do is if the
 * AssetFileDescriptor contains an offset, to move to that offset before
 * reading.  You own this descriptor and are responsible for closing it when done.
 * @throws FileNotFoundException Throws FileNotFoundException of no
 * data of the desired type exists under the URI.
 */
",-1,,[@Nullable],-1,-1,-1,-1,-1,-1,,,,
877,<android.preference.SeekBarVolumizer.Receiver: void setListening(boolean)>,22,23,<android.preference.SeekBarVolumizer.Receiver: void setListening(boolean)>,<android.preference.SeekBarVolumizer.Receiver: void setListening(boolean)>,0,"{
    if (mListening == listening)
        return;
    mListening = listening;
    if (listening) {
        final IntentFilter filter = new IntentFilter(AudioManager.VOLUME_CHANGED_ACTION);
        filter.addAction(AudioManager.INTERNAL_RINGER_MODE_CHANGED_ACTION);
        mContext.registerReceiver(this, filter);
    } else {
        mContext.unregisterReceiver(this);
    }
}","{
    if (mListening == listening)
        return;
    mListening = listening;
    if (listening) {
        final IntentFilter filter = new IntentFilter(AudioManager.VOLUME_CHANGED_ACTION);
        filter.addAction(AudioManager.INTERNAL_RINGER_MODE_CHANGED_ACTION);
        filter.addAction(NotificationManager.ACTION_INTERRUPTION_FILTER_CHANGED);
        mContext.registerReceiver(this, filter);
    } else {
        mContext.unregisterReceiver(this);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"An additional action is added to the intent filter within the control structure, which falls under ""other statement changed,"" so the change type is 4.","The added action to the intent filter does not affect the return value or the exceptions thrown by the method, it simply extends the kinds of intents that the receiver is listening for. Thus, the change will not introduce a compatibility issue, and the CI type is 0."
878,<android.app.WallpaperManager: void setBitmap(Bitmap)>,22,23,<android.app.WallpaperManager: void setBitmap(Bitmap)>,<android.app.WallpaperManager: void setBitmap(Bitmap)>,0,"{
    if (sGlobals.mService == null) {
        Log.w(TAG, ""WallpaperService not running"");
        return;
    }
    try {
        ParcelFileDescriptor fd = sGlobals.mService.setWallpaper(null);
        if (fd == null) {
            return;
        }
        FileOutputStream fos = null;
        try {
            fos = new ParcelFileDescriptor.AutoCloseOutputStream(fd);
            bitmap.compress(Bitmap.CompressFormat.PNG, 90, fos);
        } finally {
            if (fos != null) {
                fos.close();
            }
        }
    } catch (RemoteException e) {
    // Ignore
    }
}","{
    if (sGlobals.mService == null) {
        Log.w(TAG, ""WallpaperService not running"");
        return;
    }
    try {
        ParcelFileDescriptor fd = sGlobals.mService.setWallpaper(null, mContext.getOpPackageName());
        if (fd == null) {
            return;
        }
        FileOutputStream fos = null;
        try {
            fos = new ParcelFileDescriptor.AutoCloseOutputStream(fd);
            bitmap.compress(Bitmap.CompressFormat.PNG, 90, fos);
        } finally {
            if (fos != null) {
                fos.close();
            }
        }
    } catch (RemoteException e) {
    // Ignore
    }
}",1,"/**
 * Change the current system wallpaper to a bitmap.  The given bitmap is
 * converted to a PNG and stored as the wallpaper.  On success, the intent
 * {@link Intent#ACTION_WALLPAPER_CHANGED} is broadcast.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#SET_WALLPAPER}.
 *
 * @param bitmap The bitmap to save.
 *
 * @throws IOException If an error occurs reverting to the built-in
 * wallpaper.
 */
","/**
 * Change the current system wallpaper to a bitmap.  The given bitmap is
 * converted to a PNG and stored as the wallpaper.  On success, the intent
 * {@link Intent#ACTION_WALLPAPER_CHANGED} is broadcast.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#SET_WALLPAPER}.
 *
 * @param bitmap The bitmap to save.
 *
 * @throws IOException If an error occurs reverting to the built-in
 * wallpaper.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The change is in the call to sGlobals.mService.setWallpaper, where in the late version, an additional parameter mContext.getOpPackageName() is passed. This modification falls under the category of 'Other statement changed' since it's neither a return statement, exception handling statement nor a control dependency change. It is also a 'Dependent API changed' since the method setWallpaper from sGlobals.mService has a change in its parameters. The categories are 4,5.","Despite the code change, there's no Compatibility Issue detected as the changes do not alter the method's behavior from the perspective of the caller. The additional parameter is internally used and does not affect the values returned by the method nor the exceptions it may throw, assuming that the mContext.getOpPackageName() is not null or does not introduce a new exception path itself. Since no CI is detected, the prediction is 0."
879,<android.text.SpannableStringBuilder: void removeSpan(Object)>,22,23,<android.text.SpannableStringBuilder: void removeSpan(Object)>,<android.text.SpannableStringBuilder: void removeSpan(Object)>,0,"{
    for (int i = mSpanCount - 1; i >= 0; i--) {
        if (mSpans[i] == what) {
            removeSpan(i);
            return;
        }
    }
}","{
    if (mIndexOfSpan == null)
        return;
    Integer i = mIndexOfSpan.remove(what);
    if (i != null) {
        removeSpan(i.intValue());
    }
}",1,"/**
 * Remove the specified markup object from the buffer.
 */
","/**
 * Remove the specified markup object from the buffer.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",0,"The implementation has been changed to use a map (mIndexOfSpan) for span removal, which changes both the method's logic and its internal data structure. There is also a change in the control dependency of the function as it now checks for the map's existence before proceeding, so the change type is 3,4,5.","Although the implementation of the method has changed significantly, both versions achieve the same goal - the removal of a span from the SpannableStringBuilder. Since the outcome of both implementations should be the same (i.e., the removal of the specified span if it exists), there should be no Compatibility Issue, so the CI type is 0."
881,"<android.app.ContextImpl: Context createPackageContextAsUser(String,int,UserHandle)>",22,23,"<android.app.ContextImpl: Context createPackageContextAsUser(String,int,UserHandle)>","<android.app.ContextImpl: Context createPackageContextAsUser(String,int,UserHandle)>",0,"{
    final boolean restricted = (flags & CONTEXT_RESTRICTED) == CONTEXT_RESTRICTED;
    if (packageName.equals(""system"") || packageName.equals(""android"")) {
        return new ContextImpl(this, mMainThread, mPackageInfo, mActivityToken, user, restricted, mDisplay, mOverrideConfiguration);
    }
    LoadedApk pi = mMainThread.getPackageInfo(packageName, mResources.getCompatibilityInfo(), flags | CONTEXT_REGISTER_PACKAGE, user.getIdentifier());
    if (pi != null) {
        ContextImpl c = new ContextImpl(this, mMainThread, pi, mActivityToken, user, restricted, mDisplay, mOverrideConfiguration);
        if (c.mResources != null) {
            return c;
        }
    }
    // Should be a better exception.
    throw new PackageManager.NameNotFoundException(""Application package "" + packageName + "" not found"");
}","{
    final boolean restricted = (flags & CONTEXT_RESTRICTED) == CONTEXT_RESTRICTED;
    if (packageName.equals(""system"") || packageName.equals(""android"")) {
        return new ContextImpl(this, mMainThread, mPackageInfo, mActivityToken, user, restricted, mDisplay, null, Display.INVALID_DISPLAY);
    }
    LoadedApk pi = mMainThread.getPackageInfo(packageName, mResources.getCompatibilityInfo(), flags | CONTEXT_REGISTER_PACKAGE, user.getIdentifier());
    if (pi != null) {
        ContextImpl c = new ContextImpl(this, mMainThread, pi, mActivityToken, user, restricted, mDisplay, null, Display.INVALID_DISPLAY);
        if (c.mResources != null) {
            return c;
        }
    }
    // Should be a better exception.
    throw new PackageManager.NameNotFoundException(""Application package "" + packageName + "" not found"");
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The instantiation of `ContextImpl` has changed in parameters passed to its constructor, where `mOverrideConfiguration` is replaced with `null` and a new parameter `Display.INVALID_DISPLAY` is added to the end. Thus, the change type is 4.","Despite the parameter changes in the constructor of `ContextImpl`, this does not necessarily lead to a Compatibility Issue because from the perspective of the method's return type and exception handling, both are unchanged. The method's contract, in terms of the return type `Context` and the method signature, remains the same, and thus the API behaves compatibly with the previous version."
882,"<android.hardware.camera2.marshal.impl.MarshalQueryableEnum: boolean isTypeMappingSupported(TypeReference<T>,int)>",22,23,"<android.hardware.camera2.marshal.impl.MarshalQueryableEnum: boolean isTypeMappingSupported(TypeReference<T>,int)>","<android.hardware.camera2.marshal.impl.MarshalQueryableEnum: boolean isTypeMappingSupported(TypeReference<T>,int)>",0,"{
    if (nativeType == TYPE_INT32 || nativeType == TYPE_BYTE) {
        if (managedType.getType() instanceof Class<?>) {
            Class<?> typeClass = (Class<?>) managedType.getType();
            if (typeClass.isEnum()) {
                if (VERBOSE) {
                    Log.v(TAG, ""possible enum detected for "" + typeClass);
                }
                // The enum must not take extra arguments
                try {
                    // match a class like: ""public enum Fruits { Apple, Orange; }""
                    typeClass.getDeclaredConstructor(String.class, int.class);
                    return true;
                } catch (NoSuchMethodException e) {
                    // Skip: custom enum with a special constructor e.g. Foo(T), but need Foo()
                    Log.e(TAG, ""Can't marshal class "" + typeClass + ""; no default constructor"");
                } catch (SecurityException e) {
                    // Skip: wouldn't be able to touch the enum anyway
                    Log.e(TAG, ""Can't marshal class "" + typeClass + ""; not accessible"");
                }
            }
        }
    }
    return false;
}","{
    if (nativeType == TYPE_INT32 || nativeType == TYPE_BYTE) {
        if (managedType.getType() instanceof Class<?>) {
            Class<?> typeClass = (Class<?>) managedType.getType();
            if (typeClass.isEnum()) {
                if (DEBUG) {
                    Log.v(TAG, ""possible enum detected for "" + typeClass);
                }
                // The enum must not take extra arguments
                try {
                    // match a class like: ""public enum Fruits { Apple, Orange; }""
                    typeClass.getDeclaredConstructor(String.class, int.class);
                    return true;
                } catch (NoSuchMethodException e) {
                    // Skip: custom enum with a special constructor e.g. Foo(T), but need Foo()
                    Log.e(TAG, ""Can't marshal class "" + typeClass + ""; no default constructor"");
                } catch (SecurityException e) {
                    // Skip: wouldn't be able to touch the enum anyway
                    Log.e(TAG, ""Can't marshal class "" + typeClass + ""; not accessible"");
                }
            }
        }
    }
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The only change is the logging level check from VERBOSE to DEBUG (if (VERBOSE) to if (DEBUG)), which is just a logging detail and does not affect the logic or output of the method; thus, it is classified as ""Other statement changed"" (4).","There is no change in behavior of the method, as the logic returns or exception handling has not been affected by the change of logging level. The output and possible exceptions thrown remain the same; therefore, there is no Compatibility Issue."
883,<android.view.ViewRootImpl.ViewRootHandler: void handleMessage(Message)>,22,23,<android.view.ViewRootImpl.ViewRootHandler: void handleMessage(Message)>,<android.view.ViewRootImpl.ViewRootHandler: void handleMessage(Message)>,0,"{
    switch(msg.what) {
        case MSG_INVALIDATE:
            ((View) msg.obj).invalidate();
            break;
        case MSG_INVALIDATE_RECT:
            final View.AttachInfo.InvalidateInfo info = (View.AttachInfo.InvalidateInfo) msg.obj;
            info.target.invalidate(info.left, info.top, info.right, info.bottom);
            info.recycle();
            break;
        case MSG_PROCESS_INPUT_EVENTS:
            mProcessInputEventsScheduled = false;
            doProcessInputEvents();
            break;
        case MSG_DISPATCH_APP_VISIBILITY:
            handleAppVisibility(msg.arg1 != 0);
            break;
        case MSG_DISPATCH_GET_NEW_SURFACE:
            handleGetNewSurface();
            break;
        case MSG_RESIZED:
            {
                // Recycled in the fall through...
                SomeArgs args = (SomeArgs) msg.obj;
                if (mWinFrame.equals(args.arg1) && mPendingOverscanInsets.equals(args.arg5) && mPendingContentInsets.equals(args.arg2) && mPendingStableInsets.equals(args.arg6) && mPendingVisibleInsets.equals(args.arg3) && args.arg4 == null) {
                    break;
                }
            }
        // fall through...
        case MSG_RESIZED_REPORT:
            if (mAdded) {
                SomeArgs args = (SomeArgs) msg.obj;
                Configuration config = (Configuration) args.arg4;
                if (config != null) {
                    updateConfiguration(config, false);
                }
                mWinFrame.set((Rect) args.arg1);
                mPendingOverscanInsets.set((Rect) args.arg5);
                mPendingContentInsets.set((Rect) args.arg2);
                mPendingStableInsets.set((Rect) args.arg6);
                mPendingVisibleInsets.set((Rect) args.arg3);
                args.recycle();
                if (msg.what == MSG_RESIZED_REPORT) {
                    mReportNextDraw = true;
                }
                if (mView != null) {
                    forceLayout(mView);
                }
                requestLayout();
            }
            break;
        case MSG_WINDOW_MOVED:
            if (mAdded) {
                final int w = mWinFrame.width();
                final int h = mWinFrame.height();
                final int l = msg.arg1;
                final int t = msg.arg2;
                mWinFrame.left = l;
                mWinFrame.right = l + w;
                mWinFrame.top = t;
                mWinFrame.bottom = t + h;
                if (mView != null) {
                    forceLayout(mView);
                }
                requestLayout();
            }
            break;
        case MSG_WINDOW_FOCUS_CHANGED:
            {
                if (mAdded) {
                    boolean hasWindowFocus = msg.arg1 != 0;
                    mAttachInfo.mHasWindowFocus = hasWindowFocus;
                    profileRendering(hasWindowFocus);
                    if (hasWindowFocus) {
                        boolean inTouchMode = msg.arg2 != 0;
                        ensureTouchModeLocally(inTouchMode);
                        if (mAttachInfo.mHardwareRenderer != null && mSurface.isValid()) {
                            mFullRedrawNeeded = true;
                            try {
                                final WindowManager.LayoutParams lp = mWindowAttributes;
                                final Rect surfaceInsets = lp != null ? lp.surfaceInsets : null;
                                mAttachInfo.mHardwareRenderer.initializeIfNeeded(mWidth, mHeight, mSurface, surfaceInsets);
                            } catch (OutOfResourcesException e) {
                                Log.e(TAG, ""OutOfResourcesException locking surface"", e);
                                try {
                                    if (!mWindowSession.outOfMemory(mWindow)) {
                                        Slog.w(TAG, ""No processes killed for memory; killing self"");
                                        Process.killProcess(Process.myPid());
                                    }
                                } catch (RemoteException ex) {
                                }
                                // Retry in a bit.
                                sendMessageDelayed(obtainMessage(msg.what, msg.arg1, msg.arg2), 500);
                                return;
                            }
                        }
                    }
                    mLastWasImTarget = WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
                    InputMethodManager imm = InputMethodManager.peekInstance();
                    if (mView != null) {
                        if (hasWindowFocus && imm != null && mLastWasImTarget && !isInLocalFocusMode()) {
                            imm.startGettingWindowFocus(mView);
                        }
                        mAttachInfo.mKeyDispatchState.reset();
                        mView.dispatchWindowFocusChanged(hasWindowFocus);
                        mAttachInfo.mTreeObserver.dispatchOnWindowFocusChange(hasWindowFocus);
                    }
                    // so all of the view state is set up correctly.
                    if (hasWindowFocus) {
                        if (imm != null && mLastWasImTarget && !isInLocalFocusMode()) {
                            imm.onWindowFocus(mView, mView.findFocus(), mWindowAttributes.softInputMode, !mHasHadWindowFocus, mWindowAttributes.flags);
                        }
                        // Clear the forward bit.  We can just do this directly, since
                        // the window manager doesn't care about it.
                        mWindowAttributes.softInputMode &= ~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
                        ((WindowManager.LayoutParams) mView.getLayoutParams()).softInputMode &= ~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
                        mHasHadWindowFocus = true;
                    }
                    if (mView != null && mAccessibilityManager.isEnabled()) {
                        if (hasWindowFocus) {
                            mView.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);
                        }
                    }
                }
            }
            break;
        case MSG_DIE:
            doDie();
            break;
        case MSG_DISPATCH_INPUT_EVENT:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                InputEvent event = (InputEvent) args.arg1;
                InputEventReceiver receiver = (InputEventReceiver) args.arg2;
                enqueueInputEvent(event, receiver, 0, true);
                args.recycle();
            }
            break;
        case MSG_SYNTHESIZE_INPUT_EVENT:
            {
                InputEvent event = (InputEvent) msg.obj;
                enqueueInputEvent(event, null, QueuedInputEvent.FLAG_UNHANDLED, true);
            }
            break;
        case MSG_DISPATCH_KEY_FROM_IME:
            {
                if (LOCAL_LOGV)
                    Log.v(TAG, ""Dispatching key "" + msg.obj + "" from IME to "" + mView);
                KeyEvent event = (KeyEvent) msg.obj;
                if ((event.getFlags() & KeyEvent.FLAG_FROM_SYSTEM) != 0) {
                    // The IME is trying to say this event is from the
                    // system!  Bad bad bad!
                    // noinspection UnusedAssignment
                    event = KeyEvent.changeFlags(event, event.getFlags() & ~KeyEvent.FLAG_FROM_SYSTEM);
                }
                enqueueInputEvent(event, null, QueuedInputEvent.FLAG_DELIVER_POST_IME, true);
            }
            break;
        case MSG_FINISH_INPUT_CONNECTION:
            {
                InputMethodManager imm = InputMethodManager.peekInstance();
                if (imm != null) {
                    imm.reportFinishInputConnection((InputConnection) msg.obj);
                }
            }
            break;
        case MSG_CHECK_FOCUS:
            {
                InputMethodManager imm = InputMethodManager.peekInstance();
                if (imm != null) {
                    imm.checkFocus();
                }
            }
            break;
        case MSG_CLOSE_SYSTEM_DIALOGS:
            {
                if (mView != null) {
                    mView.onCloseSystemDialogs((String) msg.obj);
                }
            }
            break;
        case MSG_DISPATCH_DRAG_EVENT:
        case MSG_DISPATCH_DRAG_LOCATION_EVENT:
            {
                DragEvent event = (DragEvent) msg.obj;
                // only present when this app called startDrag()
                event.mLocalState = mLocalDragState;
                handleDragEvent(event);
            }
            break;
        case MSG_DISPATCH_SYSTEM_UI_VISIBILITY:
            {
                handleDispatchSystemUiVisibilityChanged((SystemUiVisibilityInfo) msg.obj);
            }
            break;
        case MSG_UPDATE_CONFIGURATION:
            {
                Configuration config = (Configuration) msg.obj;
                if (config.isOtherSeqNewer(mLastConfiguration)) {
                    config = mLastConfiguration;
                }
                updateConfiguration(config, false);
            }
            break;
        case MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST:
            {
                setAccessibilityFocus(null, null);
            }
            break;
        case MSG_DISPATCH_DONE_ANIMATING:
            {
                handleDispatchDoneAnimating();
            }
            break;
        case MSG_INVALIDATE_WORLD:
            {
                if (mView != null) {
                    invalidateWorld(mView);
                }
            }
            break;
        case MSG_DISPATCH_WINDOW_SHOWN:
            {
                handleDispatchWindowShown();
            }
    }
}","{
    switch(msg.what) {
        case MSG_INVALIDATE:
            ((View) msg.obj).invalidate();
            break;
        case MSG_INVALIDATE_RECT:
            final View.AttachInfo.InvalidateInfo info = (View.AttachInfo.InvalidateInfo) msg.obj;
            info.target.invalidate(info.left, info.top, info.right, info.bottom);
            info.recycle();
            break;
        case MSG_PROCESS_INPUT_EVENTS:
            mProcessInputEventsScheduled = false;
            doProcessInputEvents();
            break;
        case MSG_DISPATCH_APP_VISIBILITY:
            handleAppVisibility(msg.arg1 != 0);
            break;
        case MSG_DISPATCH_GET_NEW_SURFACE:
            handleGetNewSurface();
            break;
        case MSG_RESIZED:
            {
                // Recycled in the fall through...
                SomeArgs args = (SomeArgs) msg.obj;
                if (mWinFrame.equals(args.arg1) && mPendingOverscanInsets.equals(args.arg5) && mPendingContentInsets.equals(args.arg2) && mPendingStableInsets.equals(args.arg6) && mPendingVisibleInsets.equals(args.arg3) && mPendingOutsets.equals(args.arg7) && args.arg4 == null) {
                    break;
                }
            }
        // fall through...
        case MSG_RESIZED_REPORT:
            if (mAdded) {
                SomeArgs args = (SomeArgs) msg.obj;
                Configuration config = (Configuration) args.arg4;
                if (config != null) {
                    updateConfiguration(config, false);
                }
                mWinFrame.set((Rect) args.arg1);
                mPendingOverscanInsets.set((Rect) args.arg5);
                mPendingContentInsets.set((Rect) args.arg2);
                mPendingStableInsets.set((Rect) args.arg6);
                mPendingVisibleInsets.set((Rect) args.arg3);
                mPendingOutsets.set((Rect) args.arg7);
                args.recycle();
                if (msg.what == MSG_RESIZED_REPORT) {
                    mReportNextDraw = true;
                }
                if (mView != null) {
                    forceLayout(mView);
                }
                requestLayout();
            }
            break;
        case MSG_WINDOW_MOVED:
            if (mAdded) {
                final int w = mWinFrame.width();
                final int h = mWinFrame.height();
                final int l = msg.arg1;
                final int t = msg.arg2;
                mWinFrame.left = l;
                mWinFrame.right = l + w;
                mWinFrame.top = t;
                mWinFrame.bottom = t + h;
                if (mView != null) {
                    forceLayout(mView);
                }
                requestLayout();
            }
            break;
        case MSG_WINDOW_FOCUS_CHANGED:
            {
                if (mAdded) {
                    boolean hasWindowFocus = msg.arg1 != 0;
                    mAttachInfo.mHasWindowFocus = hasWindowFocus;
                    profileRendering(hasWindowFocus);
                    if (hasWindowFocus) {
                        boolean inTouchMode = msg.arg2 != 0;
                        ensureTouchModeLocally(inTouchMode);
                        if (mAttachInfo.mHardwareRenderer != null && mSurface.isValid()) {
                            mFullRedrawNeeded = true;
                            try {
                                final WindowManager.LayoutParams lp = mWindowAttributes;
                                final Rect surfaceInsets = lp != null ? lp.surfaceInsets : null;
                                mAttachInfo.mHardwareRenderer.initializeIfNeeded(mWidth, mHeight, mAttachInfo, mSurface, surfaceInsets);
                            } catch (OutOfResourcesException e) {
                                Log.e(TAG, ""OutOfResourcesException locking surface"", e);
                                try {
                                    if (!mWindowSession.outOfMemory(mWindow)) {
                                        Slog.w(TAG, ""No processes killed for memory; killing self"");
                                        Process.killProcess(Process.myPid());
                                    }
                                } catch (RemoteException ex) {
                                }
                                // Retry in a bit.
                                sendMessageDelayed(obtainMessage(msg.what, msg.arg1, msg.arg2), 500);
                                return;
                            }
                        }
                    }
                    mLastWasImTarget = WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
                    InputMethodManager imm = InputMethodManager.peekInstance();
                    if (imm != null && mLastWasImTarget && !isInLocalFocusMode()) {
                        imm.onPreWindowFocus(mView, hasWindowFocus);
                    }
                    if (mView != null) {
                        mAttachInfo.mKeyDispatchState.reset();
                        mView.dispatchWindowFocusChanged(hasWindowFocus);
                        mAttachInfo.mTreeObserver.dispatchOnWindowFocusChange(hasWindowFocus);
                    }
                    // so all of the view state is set up correctly.
                    if (hasWindowFocus) {
                        if (imm != null && mLastWasImTarget && !isInLocalFocusMode()) {
                            imm.onPostWindowFocus(mView, mView.findFocus(), mWindowAttributes.softInputMode, !mHasHadWindowFocus, mWindowAttributes.flags);
                        }
                        // Clear the forward bit.  We can just do this directly, since
                        // the window manager doesn't care about it.
                        mWindowAttributes.softInputMode &= ~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
                        ((WindowManager.LayoutParams) mView.getLayoutParams()).softInputMode &= ~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
                        mHasHadWindowFocus = true;
                    }
                    if (mView != null && mAccessibilityManager.isEnabled()) {
                        if (hasWindowFocus) {
                            mView.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);
                        }
                    }
                }
            }
            break;
        case MSG_DIE:
            doDie();
            break;
        case MSG_DISPATCH_INPUT_EVENT:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                InputEvent event = (InputEvent) args.arg1;
                InputEventReceiver receiver = (InputEventReceiver) args.arg2;
                enqueueInputEvent(event, receiver, 0, true);
                args.recycle();
            }
            break;
        case MSG_SYNTHESIZE_INPUT_EVENT:
            {
                InputEvent event = (InputEvent) msg.obj;
                enqueueInputEvent(event, null, QueuedInputEvent.FLAG_UNHANDLED, true);
            }
            break;
        case MSG_DISPATCH_KEY_FROM_IME:
            {
                if (LOCAL_LOGV)
                    Log.v(TAG, ""Dispatching key "" + msg.obj + "" from IME to "" + mView);
                KeyEvent event = (KeyEvent) msg.obj;
                if ((event.getFlags() & KeyEvent.FLAG_FROM_SYSTEM) != 0) {
                    // The IME is trying to say this event is from the
                    // system!  Bad bad bad!
                    // noinspection UnusedAssignment
                    event = KeyEvent.changeFlags(event, event.getFlags() & ~KeyEvent.FLAG_FROM_SYSTEM);
                }
                enqueueInputEvent(event, null, QueuedInputEvent.FLAG_DELIVER_POST_IME, true);
            }
            break;
        case MSG_FINISH_INPUT_CONNECTION:
            {
                InputMethodManager imm = InputMethodManager.peekInstance();
                if (imm != null) {
                    imm.reportFinishInputConnection((InputConnection) msg.obj);
                }
            }
            break;
        case MSG_CHECK_FOCUS:
            {
                InputMethodManager imm = InputMethodManager.peekInstance();
                if (imm != null) {
                    imm.checkFocus();
                }
            }
            break;
        case MSG_CLOSE_SYSTEM_DIALOGS:
            {
                if (mView != null) {
                    mView.onCloseSystemDialogs((String) msg.obj);
                }
            }
            break;
        case MSG_DISPATCH_DRAG_EVENT:
        case MSG_DISPATCH_DRAG_LOCATION_EVENT:
            {
                DragEvent event = (DragEvent) msg.obj;
                // only present when this app called startDrag()
                event.mLocalState = mLocalDragState;
                handleDragEvent(event);
            }
            break;
        case MSG_DISPATCH_SYSTEM_UI_VISIBILITY:
            {
                handleDispatchSystemUiVisibilityChanged((SystemUiVisibilityInfo) msg.obj);
            }
            break;
        case MSG_UPDATE_CONFIGURATION:
            {
                Configuration config = (Configuration) msg.obj;
                if (config.isOtherSeqNewer(mLastConfiguration)) {
                    config = mLastConfiguration;
                }
                updateConfiguration(config, false);
            }
            break;
        case MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST:
            {
                setAccessibilityFocus(null, null);
            }
            break;
        case MSG_DISPATCH_WINDOW_ANIMATION_STARTED:
            {
                int remainingFrameCount = msg.arg1;
                handleDispatchWindowAnimationStarted(remainingFrameCount);
            }
            break;
        case MSG_DISPATCH_WINDOW_ANIMATION_STOPPED:
            {
                handleDispatchWindowAnimationStopped();
            }
            break;
        case MSG_INVALIDATE_WORLD:
            {
                if (mView != null) {
                    invalidateWorld(mView);
                }
            }
            break;
        case MSG_DISPATCH_WINDOW_SHOWN:
            {
                handleDispatchWindowShown();
            }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
885,<android.app.ActivityTransitionCoordinator: void moveSharedElementsToOverlay()>,22,23,<android.app.ActivityTransitionCoordinator: void moveSharedElementsToOverlay()>,<android.app.ActivityTransitionCoordinator: void moveSharedElementsToOverlay()>,0,"{
    if (mWindow == null || !mWindow.getSharedElementsUseOverlay()) {
        return;
    }
    setSharedElementMatrices();
    int numSharedElements = mSharedElements.size();
    ViewGroup decor = getDecor();
    if (decor != null) {
        boolean moveWithParent = moveSharedElementWithParent();
        for (int i = 0; i < numSharedElements; i++) {
            View view = mSharedElements.get(i);
            GhostView.addGhost(view, decor);
            ViewGroup parent = (ViewGroup) view.getParent();
            if (moveWithParent && !isInTransitionGroup(parent, decor)) {
                GhostViewListeners listener = new GhostViewListeners(view, parent, decor);
                parent.getViewTreeObserver().addOnPreDrawListener(listener);
                mGhostViewListeners.add(listener);
            }
        }
    }
}","{
    if (mWindow == null || !mWindow.getSharedElementsUseOverlay()) {
        return;
    }
    setSharedElementMatrices();
    int numSharedElements = mSharedElements.size();
    ViewGroup decor = getDecor();
    if (decor != null) {
        boolean moveWithParent = moveSharedElementWithParent();
        Matrix tempMatrix = new Matrix();
        for (int i = 0; i < numSharedElements; i++) {
            View view = mSharedElements.get(i);
            tempMatrix.reset();
            mSharedElementParentMatrices.get(i).invert(tempMatrix);
            GhostView.addGhost(view, decor, tempMatrix);
            ViewGroup parent = (ViewGroup) view.getParent();
            if (moveWithParent && !isInTransitionGroup(parent, decor)) {
                GhostViewListeners listener = new GhostViewListeners(view, parent, decor);
                parent.getViewTreeObserver().addOnPreDrawListener(listener);
                mGhostViewListeners.add(listener);
            }
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"A new local variable Matrix tempMatrix and a statement tempMatrix.reset() are introduced, and a parameter is added to the call of GhostView.addGhost(view, decor, tempMatrix) method, so the change types are 3 and 4.","The modification including the creation of Matrix tempMatrix, calling tempMatrix.reset(), and updating the parameters passed to GhostView.addGhost() does not change the behavior in terms of different return values or exception handlings for this method, so there is no compatibility issue. The method's return type is void and the exceptions it may throw have not been altered."
886,"<android.app.ActivityView.ActivityViewSurfaceTextureListener: void onSurfaceTextureAvailable(SurfaceTexture,int,int)>",22,23,"<android.app.ActivityView.ActivityViewSurfaceTextureListener: void onSurfaceTextureAvailable(SurfaceTexture,int,int)>","<android.app.ActivityView.ActivityViewSurfaceTextureListener: void onSurfaceTextureAvailable(SurfaceTexture,int,int)>",0,"{
    if (mActivityContainer == null) {
        return;
    }
    if (DEBUG)
        Log.d(TAG, ""onSurfaceTextureAvailable: width="" + width + "" height="" + height);
    mWidth = width;
    mHeight = height;
    attachToSurfaceWhenReady();
}","{
    if (mActivityContainer == null) {
        return;
    }
    if (DEBUG)
        Log.d(TAG, ""onSurfaceTextureAvailable: width="" + width + "" height="" + height);
    mWidth = width;
    mHeight = height;
    attachToSurfaceWhenReady();
    if (mActivityViewCallback != null) {
        mActivityViewCallback.onSurfaceAvailable(ActivityView.this);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"A new if statement and a call to mActivityViewCallback.onSurfaceAvailable are added to the method body, without affecting existing return or exception statements, so the change types are 3 and 4.","The newly added statements do not change the return value or throw exceptions that would affect external callers in a way that indicates a compatibility issue. They just provide an additional callback notification. Thus, there is no compatibility issue, and the CI type is 0."
888,"<android.webkit.WebView: boolean showFindDialog(String,boolean)>",22,23,"<android.webkit.WebView: boolean showFindDialog(String,boolean)>","<android.webkit.WebView: boolean showFindDialog(String,boolean)>",0,"{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, ""showFindDialog"");
    return mProvider.showFindDialog(text, showIme);
}","{
    checkThread();
    return mProvider.showFindDialog(text, showIme);
}",1,"/**
 * Starts an ActionMode for finding text in this WebView.  Only works if this
 * WebView is attached to the view system.
 *
 * @param text if non-null, will be the initial text to search for.
 * Otherwise, the last String searched for in this WebView will
 * be used to start.
 * @param showIme if true, show the IME, assuming the user will begin typing.
 * If false and text is non-null, perform a find all.
 * @return true if the find dialog is shown, false otherwise
 * @deprecated This method does not work reliably on all Android versions;
 * implementing a custom find dialog using WebView.findAllAsync()
 * provides a more robust solution.
 */
","/**
 * Starts an ActionMode for finding text in this WebView.  Only works if this
 * WebView is attached to the view system.
 *
 * @param text if non-null, will be the initial text to search for.
 * Otherwise, the last String searched for in this WebView will
 * be used to start.
 * @param showIme if true, show the IME, assuming the user will begin typing.
 * If false and text is non-null, perform a find all.
 * @return true if the find dialog is shown, false otherwise
 * @deprecated This method does not work reliably on all Android versions;
 * implementing a custom find dialog using WebView.findAllAsync()
 * provides a more robust solution.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,4,0,"The only change between the two versions is the removal of a logging statement (Log.d(LOGTAG, ""showFindDialog"")), so the code change type is 4.","Since the removed logging statement does not affect the execution flow or outcomes of the method, it does not introduce a Compatibility Issue. Therefore, there is no CI."
889,<android.hardware.camera2.marshal.impl.MarshalQueryableArray.MarshalerArray: T unmarshal(ByteBuffer)>,22,23,<android.hardware.camera2.marshal.impl.MarshalQueryableArray.MarshalerArray: T unmarshal(ByteBuffer)>,<android.hardware.camera2.marshal.impl.MarshalQueryableArray.MarshalerArray: T unmarshal(ByteBuffer)>,0,"{
    Object array;
    int elementSize = mComponentMarshaler.getNativeSize();
    if (elementSize != Marshaler.NATIVE_SIZE_DYNAMIC) {
        int remaining = buffer.remaining();
        int arraySize = remaining / elementSize;
        if (remaining % elementSize != 0) {
            throw new UnsupportedOperationException(""Arrays for "" + mTypeReference + "" must be packed tighly into a multiple of "" + elementSize + ""; but there are "" + (remaining % elementSize) + "" left over bytes"");
        }
        if (VERBOSE) {
            Log.v(TAG, String.format(""Attempting to unpack array (count = %d, element size = %d, bytes "" + ""remaining = %d) for type %s"", arraySize, elementSize, remaining, mClass));
        }
        array = Array.newInstance(mComponentClass, arraySize);
        for (int i = 0; i < arraySize; ++i) {
            Object elem = mComponentMarshaler.unmarshal(buffer);
            Array.set(array, i, elem);
        }
    } else {
        // Dynamic size, use an array list.
        ArrayList<Object> arrayList = new ArrayList<Object>();
        // Assumes array is packed tightly; no unused bytes allowed
        while (buffer.hasRemaining()) {
            Object elem = mComponentMarshaler.unmarshal(buffer);
            arrayList.add(elem);
        }
        int arraySize = arrayList.size();
        array = copyListToArray(arrayList, Array.newInstance(mComponentClass, arraySize));
    }
    if (buffer.remaining() != 0) {
        Log.e(TAG, ""Trailing bytes ("" + buffer.remaining() + "") left over after unpacking "" + mClass);
    }
    return mClass.cast(array);
}","{
    Object array;
    int elementSize = mComponentMarshaler.getNativeSize();
    if (elementSize != Marshaler.NATIVE_SIZE_DYNAMIC) {
        int remaining = buffer.remaining();
        int arraySize = remaining / elementSize;
        if (remaining % elementSize != 0) {
            throw new UnsupportedOperationException(""Arrays for "" + mTypeReference + "" must be packed tighly into a multiple of "" + elementSize + ""; but there are "" + (remaining % elementSize) + "" left over bytes"");
        }
        if (DEBUG) {
            Log.v(TAG, String.format(""Attempting to unpack array (count = %d, element size = %d, bytes "" + ""remaining = %d) for type %s"", arraySize, elementSize, remaining, mClass));
        }
        array = Array.newInstance(mComponentClass, arraySize);
        for (int i = 0; i < arraySize; ++i) {
            Object elem = mComponentMarshaler.unmarshal(buffer);
            Array.set(array, i, elem);
        }
    } else {
        // Dynamic size, use an array list.
        ArrayList<Object> arrayList = new ArrayList<Object>();
        // Assumes array is packed tightly; no unused bytes allowed
        while (buffer.hasRemaining()) {
            Object elem = mComponentMarshaler.unmarshal(buffer);
            arrayList.add(elem);
        }
        int arraySize = arrayList.size();
        array = copyListToArray(arrayList, Array.newInstance(mComponentClass, arraySize));
    }
    if (buffer.remaining() != 0) {
        Log.e(TAG, ""Trailing bytes ("" + buffer.remaining() + "") left over after unpacking "" + mClass);
    }
    return mClass.cast(array);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The change is a modification from VERBOSE to DEBUG in the logging condition check. It doesn't affect the return type, control flow, or exception throwing behavior.","There is no Compatibility Issue because changes in logging verbosity alone would not affect the external behavior or output of the method; it only alters the internal logging detail, which does not affect the API's contract with the caller."
890,<android.view.Display: float getRefreshRate()>,22,23,<android.view.Display: float getRefreshRate()>,<android.view.Display: float getRefreshRate()>,0,"{
    synchronized (this) {
        updateDisplayInfoLocked();
        return mDisplayInfo.refreshRate;
    }
}","{
    synchronized (this) {
        updateDisplayInfoLocked();
        return mDisplayInfo.getMode().getRefreshRate();
    }
}",1,"/**
 * Gets the refresh rate of this display in frames per second.
 */
","/**
 * Gets the refresh rate of this display in frames per second.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent API being used inside the return statement has changed from directly accessing `mDisplayInfo.refreshRate` to the method `mDisplayInfo.getMode().getRefreshRate()`. Therefore, the code change type is 5.","There is no Compatibility Issue because the change is a direct replacement of one method call with another that is intended to provide the same data (the refresh rate of the display), and there is no alteration in the return type or thrown exceptions. It is assumed that the new method call is functionally equivalent and respects the contract of the previous implementation."
891,"<android.app.ContextImpl: void sendBroadcast(Intent,String)>",22,23,"<android.app.ContextImpl: void sendBroadcast(Intent,String)>","<android.app.ContextImpl: void sendBroadcast(Intent,String)>",0,"{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess();
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermission, AppOpsManager.OP_NONE, false, false, getUserId());
    } catch (RemoteException e) {
    }
}","{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess();
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, AppOpsManager.OP_NONE, null, false, false, getUserId());
    } catch (RemoteException e) {
        throw new RuntimeException(""Failure from system"", e);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,2,4","1,2","The method invocation 'ActivityManagerNative.getDefault().broadcastIntent()' has an extra parameter 'null' introduced and the variable 'receiverPermissions' is used instead of 'receiverPermission'. Additionally, the empty catch block has been replaced with a throw statement, throwing a new RuntimeException. These changes correspond to Other statement changed (4) as well as Exception handling statement changed (2) and Return statement changed (1) since the method now can throw an exception where it previously did not.","The addition of the throw statement inside the catch block introduces a potential Compatibility Issue due to different exception handling (2). Moreover, the change in the method parameters for 'broadcastIntent()' could potentially result in different behavior (other than an exception) from this method, possibly changing the control flow and resulting in a different return when this API method is used, leading to another Compatibility Issue (1)."
898,<android.widget.GridView: boolean arrowScroll(int)>,22,23,<android.widget.GridView: boolean arrowScroll(int)>,<android.widget.GridView: boolean arrowScroll(int)>,0,"{
    final int selectedPosition = mSelectedPosition;
    final int numColumns = mNumColumns;
    int startOfRowPos;
    int endOfRowPos;
    boolean moved = false;
    if (!mStackFromBottom) {
        startOfRowPos = (selectedPosition / numColumns) * numColumns;
        endOfRowPos = Math.min(startOfRowPos + numColumns - 1, mItemCount - 1);
    } else {
        final int invertedSelection = mItemCount - 1 - selectedPosition;
        endOfRowPos = mItemCount - 1 - (invertedSelection / numColumns) * numColumns;
        startOfRowPos = Math.max(0, endOfRowPos - numColumns + 1);
    }
    switch(direction) {
        case FOCUS_UP:
            if (startOfRowPos > 0) {
                mLayoutMode = LAYOUT_MOVE_SELECTION;
                setSelectionInt(Math.max(0, selectedPosition - numColumns));
                moved = true;
            }
            break;
        case FOCUS_DOWN:
            if (endOfRowPos < mItemCount - 1) {
                mLayoutMode = LAYOUT_MOVE_SELECTION;
                setSelectionInt(Math.min(selectedPosition + numColumns, mItemCount - 1));
                moved = true;
            }
            break;
        case FOCUS_LEFT:
            if (selectedPosition > startOfRowPos) {
                mLayoutMode = LAYOUT_MOVE_SELECTION;
                setSelectionInt(Math.max(0, selectedPosition - 1));
                moved = true;
            }
            break;
        case FOCUS_RIGHT:
            if (selectedPosition < endOfRowPos) {
                mLayoutMode = LAYOUT_MOVE_SELECTION;
                setSelectionInt(Math.min(selectedPosition + 1, mItemCount - 1));
                moved = true;
            }
            break;
    }
    if (moved) {
        playSoundEffect(SoundEffectConstants.getContantForFocusDirection(direction));
        invokeOnItemScrollListener();
    }
    if (moved) {
        awakenScrollBars();
    }
    return moved;
}","{
    final int selectedPosition = mSelectedPosition;
    final int numColumns = mNumColumns;
    int startOfRowPos;
    int endOfRowPos;
    boolean moved = false;
    if (!mStackFromBottom) {
        startOfRowPos = (selectedPosition / numColumns) * numColumns;
        endOfRowPos = Math.min(startOfRowPos + numColumns - 1, mItemCount - 1);
    } else {
        final int invertedSelection = mItemCount - 1 - selectedPosition;
        endOfRowPos = mItemCount - 1 - (invertedSelection / numColumns) * numColumns;
        startOfRowPos = Math.max(0, endOfRowPos - numColumns + 1);
    }
    switch(direction) {
        case FOCUS_UP:
            if (startOfRowPos > 0) {
                mLayoutMode = LAYOUT_MOVE_SELECTION;
                setSelectionInt(Math.max(0, selectedPosition - numColumns));
                moved = true;
            }
            break;
        case FOCUS_DOWN:
            if (endOfRowPos < mItemCount - 1) {
                mLayoutMode = LAYOUT_MOVE_SELECTION;
                setSelectionInt(Math.min(selectedPosition + numColumns, mItemCount - 1));
                moved = true;
            }
            break;
    }
    final boolean isLayoutRtl = isLayoutRtl();
    if (selectedPosition > startOfRowPos && ((direction == FOCUS_LEFT && !isLayoutRtl) || (direction == FOCUS_RIGHT && isLayoutRtl))) {
        mLayoutMode = LAYOUT_MOVE_SELECTION;
        setSelectionInt(Math.max(0, selectedPosition - 1));
        moved = true;
    } else if (selectedPosition < endOfRowPos && ((direction == FOCUS_LEFT && isLayoutRtl) || (direction == FOCUS_RIGHT && !isLayoutRtl))) {
        mLayoutMode = LAYOUT_MOVE_SELECTION;
        setSelectionInt(Math.min(selectedPosition + 1, mItemCount - 1));
        moved = true;
    }
    if (moved) {
        playSoundEffect(SoundEffectConstants.getContantForFocusDirection(direction));
        invokeOnItemScrollListener();
    }
    if (moved) {
        awakenScrollBars();
    }
    return moved;
}",1,"/**
 * Scrolls to the next or previous item, horizontally or vertically.
 *
 * @param direction either {@link View#FOCUS_LEFT}, {@link View#FOCUS_RIGHT},
 * {@link View#FOCUS_UP} or {@link View#FOCUS_DOWN}
 *
 * @return whether selection was moved
 */
","/**
 * Scrolls to the next or previous item, horizontally or vertically.
 *
 * @param direction either {@link View#FOCUS_LEFT}, {@link View#FOCUS_RIGHT},
 * {@link View#FOCUS_UP} or {@link View#FOCUS_DOWN}
 *
 * @return whether selection was moved
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The control dependency within the 'switch' cases for FOCUS_LEFT and FOCUS_RIGHT has been modified to include an additional check based on the layout direction (isLayoutRtl()), thus making the condition within these cases more complex. So, the change type is 3.","Despite the control dependency change, the overall behavior of the method is not impacted in a way that would cause a different return type or throw a different exception. Although the added check for layout direction introduces new control flow, it still adheres to the method's contract and intention by considering the appropriate movement based on the layout's text direction. Therefore, this does not constitute a compatibility issue."
902,<android.app.ContextImpl: String[] databaseList()>,22,23,<android.app.ContextImpl: String[] databaseList()>,<android.app.ContextImpl: String[] databaseList()>,0,"{
    final String[] list = getDatabasesDir().list();
    return (list != null) ? list : EMPTY_FILE_LIST;
}","{
    final String[] list = getDatabasesDir().list();
    return (list != null) ? list : EMPTY_STRING_ARRAY;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The return statement has been altered to use a different empty array constant (from EMPTY_FILE_LIST to EMPTY_STRING_ARRAY), representing a value change, and it is considered an ""other statement change"" as it is a change in the used object. Therefore, the code change types are 1 and 4.","The difference between returning EMPTY_FILE_LIST and EMPTY_STRING_ARRAY could impact the behavior of methods that rely on the returned value since the returned array might be expected to adhere to certain content or length properties. Due to this change in the return value, it is classified as CI type 1."
904,"<android.accounts.AbstractAccountAuthenticator: Bundle addAccountFromCredentials(AccountAuthenticatorResponse,Account,Bundle)>",22,23,"<android.accounts.AbstractAccountAuthenticator: Bundle addAccountFromCredentials(AccountAuthenticatorResponse,Account,Bundle)>","<android.accounts.AbstractAccountAuthenticator: Bundle addAccountFromCredentials(AccountAuthenticatorResponse,Account,Bundle)>",0,"{
    new Thread(new Runnable() {

        public void run() {
            Bundle result = new Bundle();
            result.putBoolean(AccountManager.KEY_BOOLEAN_RESULT, false);
            response.onResult(result);
        }
    }).start();
    return null;
}","{
    new Thread(new Runnable() {

        @Override
        public void run() {
            Bundle result = new Bundle();
            result.putBoolean(AccountManager.KEY_BOOLEAN_RESULT, false);
            response.onResult(result);
        }
    }).start();
    return null;
}",1,"/**
 * Creates an account based on credentials provided by the authenticator instance of another
 * user on the device, who has chosen to share the account with this user.
 * @param response to send the result back to the AccountManager, will never be null
 * @param account the account to clone, will never be null
 * @param accountCredentials the Bundle containing the required credentials to create the
 * account. Contents of the Bundle are only meaningful to the authenticator. This Bundle is
 * provided by {@link #getAccountCredentialsForCloning(AccountAuthenticatorResponse, Account)}.
 * @return a Bundle result or null if the result is to be returned via the response.
 * @throws NetworkErrorException
 * @see {@link #getAccountCredentialsForCloning(AccountAuthenticatorResponse, Account)}
 */
","/**
 * Creates an account based on credentials provided by the authenticator instance of another
 * user on the device, who has chosen to share the account with this user.
 * @param response to send the result back to the AccountManager, will never be null
 * @param account the account to clone, will never be null
 * @param accountCredentials the Bundle containing the required credentials to create the
 * account. Contents of the Bundle are only meaningful to the authenticator. This Bundle is
 * provided by {@link #getAccountCredentialsForCloning(AccountAuthenticatorResponse, Account)}.
 * @return a Bundle result or null if the result is to be returned via the response.
 * @throws NetworkErrorException
 * @see {@link #getAccountCredentialsForCloning(AccountAuthenticatorResponse, Account)}
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,The only change in the late implementation is the addition of the @Override annotation. There are no changes in the actual execution code or return values.,"Since there are no functional code changes, there is no compatibility issue between these two versions."
905,<android.bluetooth.le.BluetoothLeAdvertiser: void stopAdvertising(AdvertiseCallback)>,22,23,<android.bluetooth.le.BluetoothLeAdvertiser: void stopAdvertising(AdvertiseCallback)>,<android.bluetooth.le.BluetoothLeAdvertiser: void stopAdvertising(AdvertiseCallback)>,0,"{
    synchronized (mLeAdvertisers) {
        BluetoothLeUtils.checkAdapterStateOn(mBluetoothAdapter);
        if (callback == null) {
            throw new IllegalArgumentException(""callback cannot be null"");
        }
        AdvertiseCallbackWrapper wrapper = mLeAdvertisers.get(callback);
        if (wrapper == null)
            return;
        wrapper.stopAdvertising();
    }
}","{
    synchronized (mLeAdvertisers) {
        if (callback == null) {
            throw new IllegalArgumentException(""callback cannot be null"");
        }
        AdvertiseCallbackWrapper wrapper = mLeAdvertisers.get(callback);
        if (wrapper == null)
            return;
        wrapper.stopAdvertising();
    }
}",1,"/**
 * Stop Bluetooth LE advertising. The {@code callback} must be the same one use in
 * {@link BluetoothLeAdvertiser#startAdvertising}.
 * <p>
 * Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN} permission.
 *
 * @param callback {@link AdvertiseCallback} identifies the advertising instance to stop.
 */
","/**
 * Stop Bluetooth LE advertising. The {@code callback} must be the same one use in
 * {@link BluetoothLeAdvertiser#startAdvertising}.
 * <p>
 * Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN} permission.
 *
 * @param callback {@link AdvertiseCallback} identifies the advertising instance to stop.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The statement `BluetoothLeUtils.checkAdapterStateOn(mBluetoothAdapter);` has been removed in the late version. This is the only change, and it's not related to return statements, exception handling, or control dependencies, so the change type is 4.","The removal of `BluetoothLeUtils.checkAdapterStateOn(mBluetoothAdapter);` does not lead to a Compatibility Issue, because it does not affect the behaviour of the method regarding what it returns or the exceptions it may throw. It seems to be a change related to an internal check within the method, which does not have an external impact on its contract or side-effects as visible to the caller. Hence, no Compatibility Issue is detected."
907,"<android.widget.RemoteViews.TextViewDrawableAction: void apply(View,ViewGroup,OnClickHandler)>",22,23,"<android.widget.RemoteViews.TextViewDrawableAction: void apply(View,ViewGroup,OnClickHandler)>","<android.widget.RemoteViews.TextViewDrawableAction: void apply(View,ViewGroup,OnClickHandler)>",0,"{
    final TextView target = (TextView) root.findViewById(viewId);
    if (target == null)
        return;
    if (isRelative) {
        target.setCompoundDrawablesRelativeWithIntrinsicBounds(d1, d2, d3, d4);
    } else {
        target.setCompoundDrawablesWithIntrinsicBounds(d1, d2, d3, d4);
    }
}","{
    final TextView target = (TextView) root.findViewById(viewId);
    if (target == null)
        return;
    if (useIcons) {
        final Context ctx = target.getContext();
        final Drawable id1 = i1 == null ? null : i1.loadDrawable(ctx);
        final Drawable id2 = i2 == null ? null : i2.loadDrawable(ctx);
        final Drawable id3 = i3 == null ? null : i3.loadDrawable(ctx);
        final Drawable id4 = i4 == null ? null : i4.loadDrawable(ctx);
        if (isRelative) {
            target.setCompoundDrawablesRelativeWithIntrinsicBounds(id1, id2, id3, id4);
        } else {
            target.setCompoundDrawablesWithIntrinsicBounds(id1, id2, id3, id4);
        }
    } else {
        if (isRelative) {
            target.setCompoundDrawablesRelativeWithIntrinsicBounds(d1, d2, d3, d4);
        } else {
            target.setCompoundDrawablesWithIntrinsicBounds(d1, d2, d3, d4);
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The late version introduces new variables and a branch conditional to check 'useIcons' before applying the drawable resources. The applied drawables are conditionally loaded from Icon objects, so the code change types are 3 and 4 (control dependency change and other statement changed).","There is no CI because the outcome of the method, which is applying the Drawable to the TextView, remains effectively the same. The introduction of a new condition simply changes the source of the Drawables (either direct Drawable references or loaded from Icon objects), but the method's behavior of setting these Drawables to a TextView does not change in a way that would cause a different value to be returned, nor does it change exception handling behavior."
909,"<android.inputmethodservice.InputMethodService: boolean doMovementKey(int,KeyEvent,int)>",22,23,"<android.inputmethodservice.InputMethodService: boolean doMovementKey(int,KeyEvent,int)>","<android.inputmethodservice.InputMethodService: boolean doMovementKey(int,KeyEvent,int)>",0,"{
    final ExtractEditText eet = mExtractEditText;
    if (isExtractViewShown() && isInputViewShown() && eet != null) {
        // If we are in fullscreen mode, the cursor will move around
        // the extract edit text, but should NOT cause focus to move
        // to other fields.
        MovementMethod movement = eet.getMovementMethod();
        Layout layout = eet.getLayout();
        if (movement != null && layout != null) {
            // cursor will properly move in our own word wrapping.
            if (count == MOVEMENT_DOWN) {
                if (movement.onKeyDown(eet, (Spannable) eet.getText(), keyCode, event)) {
                    reportExtractedMovement(keyCode, 1);
                    return true;
                }
            } else if (count == MOVEMENT_UP) {
                if (movement.onKeyUp(eet, (Spannable) eet.getText(), keyCode, event)) {
                    return true;
                }
            } else {
                if (movement.onKeyOther(eet, (Spannable) eet.getText(), event)) {
                    reportExtractedMovement(keyCode, count);
                } else {
                    KeyEvent down = KeyEvent.changeAction(event, KeyEvent.ACTION_DOWN);
                    if (movement.onKeyDown(eet, (Spannable) eet.getText(), keyCode, down)) {
                        KeyEvent up = KeyEvent.changeAction(event, KeyEvent.ACTION_UP);
                        movement.onKeyUp(eet, (Spannable) eet.getText(), keyCode, up);
                        while (--count > 0) {
                            movement.onKeyDown(eet, (Spannable) eet.getText(), keyCode, down);
                            movement.onKeyUp(eet, (Spannable) eet.getText(), keyCode, up);
                        }
                        reportExtractedMovement(keyCode, count);
                    }
                }
            }
        }
        // we never allow DPAD navigation to the application.
        switch(keyCode) {
            case KeyEvent.KEYCODE_DPAD_LEFT:
            case KeyEvent.KEYCODE_DPAD_RIGHT:
            case KeyEvent.KEYCODE_DPAD_UP:
            case KeyEvent.KEYCODE_DPAD_DOWN:
                return true;
        }
    }
    return false;
}","{
    final ExtractEditText eet = getExtractEditTextIfVisible();
    if (eet != null) {
        // If we are in fullscreen mode, the cursor will move around
        // the extract edit text, but should NOT cause focus to move
        // to other fields.
        MovementMethod movement = eet.getMovementMethod();
        Layout layout = eet.getLayout();
        if (movement != null && layout != null) {
            // cursor will properly move in our own word wrapping.
            if (count == MOVEMENT_DOWN) {
                if (movement.onKeyDown(eet, (Spannable) eet.getText(), keyCode, event)) {
                    reportExtractedMovement(keyCode, 1);
                    return true;
                }
            } else if (count == MOVEMENT_UP) {
                if (movement.onKeyUp(eet, (Spannable) eet.getText(), keyCode, event)) {
                    return true;
                }
            } else {
                if (movement.onKeyOther(eet, (Spannable) eet.getText(), event)) {
                    reportExtractedMovement(keyCode, count);
                } else {
                    KeyEvent down = KeyEvent.changeAction(event, KeyEvent.ACTION_DOWN);
                    if (movement.onKeyDown(eet, (Spannable) eet.getText(), keyCode, down)) {
                        KeyEvent up = KeyEvent.changeAction(event, KeyEvent.ACTION_UP);
                        movement.onKeyUp(eet, (Spannable) eet.getText(), keyCode, up);
                        while (--count > 0) {
                            movement.onKeyDown(eet, (Spannable) eet.getText(), keyCode, down);
                            movement.onKeyUp(eet, (Spannable) eet.getText(), keyCode, up);
                        }
                        reportExtractedMovement(keyCode, count);
                    }
                }
            }
        }
        // we never allow DPAD navigation to the application.
        switch(keyCode) {
            case KeyEvent.KEYCODE_DPAD_LEFT:
            case KeyEvent.KEYCODE_DPAD_RIGHT:
            case KeyEvent.KEYCODE_DPAD_UP:
            case KeyEvent.KEYCODE_DPAD_DOWN:
                return true;
        }
    }
    return false;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,5",0,"The method `getExtractEditTextIfVisible()` has replaced parts of the condition (`isExtractViewShown() && isInputViewShown()` and `mExtractEditText != null`), which implies a Dependent API change (5), and there is also a change in the control dependency as the conditions are evaluated within the new method now (3).","However, despite these changes, the method's logic remains functionally equivalent. The behavior of the method will continue to return the same results under the same conditions because the new method `getExtractEditTextIfVisible()` is designed to encapsulate the checks that were previously performed in-line. Therefore, no Compatibility Issue is expected to arise from these changes (0)."
911,<android.os.Environment: boolean isExternalStorageRemovable()>,22,23,<android.os.Environment: boolean isExternalStorageRemovable()>,<android.os.Environment: boolean isExternalStorageRemovable()>,0,"{
    if (isStorageDisabled())
        return false;
    final File externalDir = sCurrentUser.getExternalDirsForApp()[0];
    return isExternalStorageRemovable(externalDir);
}","{
    if (isStorageDisabled())
        return false;
    final File externalDir = sCurrentUser.getExternalDirs()[0];
    return isExternalStorageRemovable(externalDir);
}",1,"/**
 * Returns whether the primary ""external"" storage device is removable.
 *
 * @return true if the storage device can be removed (such as an SD card),
 * or false if the storage device is built in and cannot be
 * physically removed.
 */
","/**
 * Returns whether the primary ""external"" storage device is removable.
 *
 * @return true if the storage device can be removed (such as an SD card),
 * or false if the storage device is built in and cannot be
 * physically removed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method name has been changed from getExternalDirsForApp() to getExternalDirs(), which indicates a dependent API has been changed, so the code change type is 5.","Assuming that the new method getExternalDirs() continues to return the appropriate external directory as the previous method getExternalDirsForApp() did, there would not be a compatibility issue in terms of the behavior of this method. Both methods are intended to return an array of File objects pointing to external directories. The condition before and the return statement itself remain unchanged. So, even though there's a change in the called method name, it does not necessarily cause a compatibility issue based on the information given, and thus the CI type is 0."
912,"<android.hardware.camera2.impl.CameraCaptureSessionImpl: int setRepeatingRequest(CaptureRequest,CaptureCallback,Handler)>",22,23,"<android.hardware.camera2.impl.CameraCaptureSessionImpl: int setRepeatingRequest(CaptureRequest,CaptureCallback,Handler)>","<android.hardware.camera2.impl.CameraCaptureSessionImpl: int setRepeatingRequest(CaptureRequest,CaptureCallback,Handler)>",0,"{
    if (request == null) {
        throw new IllegalArgumentException(""request must not be null"");
    }
    checkNotClosed();
    handler = checkHandler(handler, callback);
    if (VERBOSE) {
        Log.v(TAG, mIdString + ""setRepeatingRequest - request "" + request + "", callback "" + callback + "" handler"" + "" "" + handler);
    }
    return addPendingSequence(mDeviceImpl.setRepeatingRequest(request, createCaptureCallbackProxy(handler, callback), mDeviceHandler));
}","{
    if (request == null) {
        throw new IllegalArgumentException(""request must not be null"");
    } else if (request.isReprocess()) {
        throw new IllegalArgumentException(""repeating reprocess requests are not supported"");
    }
    checkNotClosed();
    handler = checkHandler(handler, callback);
    if (DEBUG) {
        Log.v(TAG, mIdString + ""setRepeatingRequest - request "" + request + "", callback "" + callback + "" handler"" + "" "" + handler);
    }
    return addPendingSequence(mDeviceImpl.setRepeatingRequest(request, createCaptureCallbackProxy(handler, callback), mDeviceHandler));
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,4",2,"The new else if block checking for request.isReprocess() introduces a new exception handling statement, which is not present in the early version. Moreover, the condition within the if debug log statement changed from VERBOSE to DEBUG. Thus, the code change types include 2 for the new exception and 4 for the change in the logging condition.","The introduced exception handling for reprocess requests can lead to a new type of `IllegalArgumentException`, generating a different exception behaviour compared to the early version. Therefore, the CI type is 2."
913,<android.app.Dialog: ActionMode onWindowStartingActionMode(Callback)>,22,23,<android.app.Dialog: ActionMode onWindowStartingActionMode(Callback)>,<android.app.Dialog: ActionMode onWindowStartingActionMode(Callback)>,0,"{
    if (mActionBar != null) {
        return mActionBar.startActionMode(callback);
    }
    return null;
}","{
    if (mActionBar != null && mActionModeTypeStarting == ActionMode.TYPE_PRIMARY) {
        return mActionBar.startActionMode(callback);
    }
    return null;
}",1,,"/**
 * {@inheritDoc}
 */
",-1,,[@Override],-1,-1,-1,-1,-1,-1,3,0,"The control dependency has changed due to the introduction of an additional check for mActionModeTypeStarting == ActionMode.TYPE_PRIMARY in the if condition, so the code change type is 3.","Despite the change in control dependency, there are no changes in the type or value of what is returned by the method. Both versions return either the result of mActionBar.startActionMode(callback) or null, depending on the conditions. Because the method's return values remain the same regardless of the additional check, there's no Compatibility Issue in terms of different return values or types. Since there are no changes in exception handling between the two versions, there's also no Compatibility Issue in terms of different exception handlings. Therefore, the CI type is 0."
916,<android.service.notification.NotificationListenerService: int getCurrentInterruptionFilter()>,22,23,<android.service.notification.NotificationListenerService: int getCurrentInterruptionFilter()>,<android.service.notification.NotificationListenerService: int getCurrentInterruptionFilter()>,0,"{
    if (!isBound())
        return 0;
    try {
        return getNotificationInterface().getInterruptionFilterFromListener(mWrapper);
    } catch (android.os.RemoteException ex) {
        Log.v(TAG, ""Unable to contact notification manager"", ex);
        return 0;
    }
}","{
    if (!isBound())
        return INTERRUPTION_FILTER_UNKNOWN;
    try {
        return getNotificationInterface().getInterruptionFilterFromListener(mWrapper);
    } catch (android.os.RemoteException ex) {
        Log.v(TAG, ""Unable to contact notification manager"", ex);
        return INTERRUPTION_FILTER_UNKNOWN;
    }
}",1,"/**
 * Gets the current notification interruption filter active on the host.
 *
 * <p>
 * The interruption filter defines which notifications are allowed to interrupt the user
 * (e.g. via sound &amp; vibration) and is applied globally. Listeners can find out whether
 * a specific notification matched the interruption filter via
 * {@link Ranking#matchesInterruptionFilter()}.
 * <p>
 * The current filter may differ from the previously requested filter if the notification host
 * does not support or refuses to apply the requested filter, or if another component changed
 * the filter in the meantime.
 * <p>
 * Listen for updates using {@link #onInterruptionFilterChanged(int)}.
 *
 * @return One of the INTERRUPTION_FILTER_ constants, or 0 on errors.
 */
","/**
 * Gets the current notification interruption filter active on the host.
 *
 * <p>
 * The interruption filter defines which notifications are allowed to interrupt the user
 * (e.g. via sound &amp; vibration) and is applied globally. Listeners can find out whether
 * a specific notification matched the interruption filter via
 * {@link Ranking#matchesInterruptionFilter()}.
 * <p>
 * The current filter may differ from the previously requested filter if the notification host
 * does not support or refuses to apply the requested filter, or if another component changed
 * the filter in the meantime.
 * <p>
 * Listen for updates using {@link #onInterruptionFilterChanged(int)}.
 *
 * @return One of the INTERRUPTION_FILTER_ constants, or INTERRUPTION_FILTER_UNKNOWN when
 * unavailable.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"In both the early and late versions, the ""return 0;"" statements have been changed to ""return INTERRUPTION_FILTER_UNKNOWN;"". Therefore, the change type is 1.","By changing the value returned from 0 to INTERRUPTION_FILTER_UNKNOWN inside both the initial 'if' condition check and the 'catch' block, the API will potentially return different integer values than before, which could lead to different behavior. Thus, the CI type is 1."
917,<android.view.InputDevice: String toString()>,22,23,<android.view.InputDevice: String toString()>,<android.view.InputDevice: String toString()>,0,"{
    StringBuilder description = new StringBuilder();
    description.append(""Input Device "").append(mId).append("": "").append(mName).append(""\n"");
    description.append(""  Descriptor: "").append(mDescriptor).append(""\n"");
    description.append(""  Generation: "").append(mGeneration).append(""\n"");
    description.append(""  Location: "").append(mIsExternal ? ""external"" : ""built-in"").append(""\n"");
    description.append(""  Keyboard Type: "");
    switch(mKeyboardType) {
        case KEYBOARD_TYPE_NONE:
            description.append(""none"");
            break;
        case KEYBOARD_TYPE_NON_ALPHABETIC:
            description.append(""non-alphabetic"");
            break;
        case KEYBOARD_TYPE_ALPHABETIC:
            description.append(""alphabetic"");
            break;
    }
    description.append(""\n"");
    description.append(""  Has Vibrator: "").append(mHasVibrator).append(""\n"");
    description.append(""  Sources: 0x"").append(Integer.toHexString(mSources)).append("" ("");
    appendSourceDescriptionIfApplicable(description, SOURCE_KEYBOARD, ""keyboard"");
    appendSourceDescriptionIfApplicable(description, SOURCE_DPAD, ""dpad"");
    appendSourceDescriptionIfApplicable(description, SOURCE_TOUCHSCREEN, ""touchscreen"");
    appendSourceDescriptionIfApplicable(description, SOURCE_MOUSE, ""mouse"");
    appendSourceDescriptionIfApplicable(description, SOURCE_STYLUS, ""stylus"");
    appendSourceDescriptionIfApplicable(description, SOURCE_TRACKBALL, ""trackball"");
    appendSourceDescriptionIfApplicable(description, SOURCE_TOUCHPAD, ""touchpad"");
    appendSourceDescriptionIfApplicable(description, SOURCE_JOYSTICK, ""joystick"");
    appendSourceDescriptionIfApplicable(description, SOURCE_GAMEPAD, ""gamepad"");
    description.append("" )\n"");
    final int numAxes = mMotionRanges.size();
    for (int i = 0; i < numAxes; i++) {
        MotionRange range = mMotionRanges.get(i);
        description.append(""    "").append(MotionEvent.axisToString(range.mAxis));
        description.append("": source=0x"").append(Integer.toHexString(range.mSource));
        description.append("" min="").append(range.mMin);
        description.append("" max="").append(range.mMax);
        description.append("" flat="").append(range.mFlat);
        description.append("" fuzz="").append(range.mFuzz);
        description.append("" resolution="").append(range.mResolution);
        description.append(""\n"");
    }
    return description.toString();
}","{
    StringBuilder description = new StringBuilder();
    description.append(""Input Device "").append(mId).append("": "").append(mName).append(""\n"");
    description.append(""  Descriptor: "").append(mDescriptor).append(""\n"");
    description.append(""  Generation: "").append(mGeneration).append(""\n"");
    description.append(""  Location: "").append(mIsExternal ? ""external"" : ""built-in"").append(""\n"");
    description.append(""  Keyboard Type: "");
    switch(mKeyboardType) {
        case KEYBOARD_TYPE_NONE:
            description.append(""none"");
            break;
        case KEYBOARD_TYPE_NON_ALPHABETIC:
            description.append(""non-alphabetic"");
            break;
        case KEYBOARD_TYPE_ALPHABETIC:
            description.append(""alphabetic"");
            break;
    }
    description.append(""\n"");
    description.append(""  Has Vibrator: "").append(mHasVibrator).append(""\n"");
    description.append(""  Has mic: "").append(mHasMicrophone).append(""\n"");
    description.append(""  Sources: 0x"").append(Integer.toHexString(mSources)).append("" ("");
    appendSourceDescriptionIfApplicable(description, SOURCE_KEYBOARD, ""keyboard"");
    appendSourceDescriptionIfApplicable(description, SOURCE_DPAD, ""dpad"");
    appendSourceDescriptionIfApplicable(description, SOURCE_TOUCHSCREEN, ""touchscreen"");
    appendSourceDescriptionIfApplicable(description, SOURCE_MOUSE, ""mouse"");
    appendSourceDescriptionIfApplicable(description, SOURCE_STYLUS, ""stylus"");
    appendSourceDescriptionIfApplicable(description, SOURCE_TRACKBALL, ""trackball"");
    appendSourceDescriptionIfApplicable(description, SOURCE_TOUCHPAD, ""touchpad"");
    appendSourceDescriptionIfApplicable(description, SOURCE_JOYSTICK, ""joystick"");
    appendSourceDescriptionIfApplicable(description, SOURCE_GAMEPAD, ""gamepad"");
    description.append("" )\n"");
    final int numAxes = mMotionRanges.size();
    for (int i = 0; i < numAxes; i++) {
        MotionRange range = mMotionRanges.get(i);
        description.append(""    "").append(MotionEvent.axisToString(range.mAxis));
        description.append("": source=0x"").append(Integer.toHexString(range.mSource));
        description.append("" min="").append(range.mMin);
        description.append("" max="").append(range.mMax);
        description.append("" flat="").append(range.mFlat);
        description.append("" fuzz="").append(range.mFuzz);
        description.append("" resolution="").append(range.mResolution);
        description.append(""\n"");
    }
    return description.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
918,<android.hardware.camera2.legacy.LegacyCameraDevice: int configureOutputs(List<Surface>)>,22,23,<android.hardware.camera2.legacy.LegacyCameraDevice: int configureOutputs(List<Surface>)>,<android.hardware.camera2.legacy.LegacyCameraDevice: int configureOutputs(List<Surface>)>,0,"{
    List<Pair<Surface, Size>> sizedSurfaces = new ArrayList<>();
    if (outputs != null) {
        for (Surface output : outputs) {
            if (output == null) {
                Log.e(TAG, ""configureOutputs - null outputs are not allowed"");
                return BAD_VALUE;
            }
            StreamConfigurationMap streamConfigurations = mStaticCharacteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);
            // Validate surface size and format.
            try {
                Size s = getSurfaceSize(output);
                int surfaceType = detectSurfaceType(output);
                boolean flexibleConsumer = isFlexibleConsumer(output);
                Size[] sizes = streamConfigurations.getOutputSizes(surfaceType);
                if (sizes == null) {
                    // WAR: Override default format to IMPLEMENTATION_DEFINED for b/9487482
                    if ((surfaceType >= LegacyMetadataMapper.HAL_PIXEL_FORMAT_RGBA_8888 && surfaceType <= LegacyMetadataMapper.HAL_PIXEL_FORMAT_BGRA_8888)) {
                        // YUV_420_888 is always present in LEGACY for all
                        // IMPLEMENTATION_DEFINED output sizes, and is publicly visible in the
                        // API (i.e. {@code #getOutputSizes} works here).
                        sizes = streamConfigurations.getOutputSizes(ImageFormat.YUV_420_888);
                    } else if (surfaceType == LegacyMetadataMapper.HAL_PIXEL_FORMAT_BLOB) {
                        sizes = streamConfigurations.getOutputSizes(ImageFormat.JPEG);
                    }
                }
                if (!ArrayUtils.contains(sizes, s)) {
                    if (flexibleConsumer && (s = findClosestSize(s, sizes)) != null) {
                        sizedSurfaces.add(new Pair<>(output, s));
                    } else {
                        String reason = (sizes == null) ? ""format is invalid."" : (""size not in valid set: "" + Arrays.toString(sizes));
                        Log.e(TAG, String.format(""Surface with size (w=%d, h=%d) and format "" + ""0x%x is not valid, %s"", s.getWidth(), s.getHeight(), surfaceType, reason));
                        return BAD_VALUE;
                    }
                } else {
                    sizedSurfaces.add(new Pair<>(output, s));
                }
            } catch (BufferQueueAbandonedException e) {
                Log.e(TAG, ""Surface bufferqueue is abandoned, cannot configure as output: "", e);
                return BAD_VALUE;
            }
        }
    }
    boolean success = false;
    if (mDeviceState.setConfiguring()) {
        mRequestThreadManager.configure(sizedSurfaces);
        success = mDeviceState.setIdle();
    }
    if (success) {
        mConfiguredSurfaces = outputs != null ? new ArrayList<>(outputs) : null;
    } else {
        return CameraBinderDecorator.INVALID_OPERATION;
    }
    return CameraBinderDecorator.NO_ERROR;
}","{
    List<Pair<Surface, Size>> sizedSurfaces = new ArrayList<>();
    if (outputs != null) {
        for (Surface output : outputs) {
            if (output == null) {
                Log.e(TAG, ""configureOutputs - null outputs are not allowed"");
                return BAD_VALUE;
            }
            if (!output.isValid()) {
                Log.e(TAG, ""configureOutputs - invalid output surfaces are not allowed"");
                return BAD_VALUE;
            }
            StreamConfigurationMap streamConfigurations = mStaticCharacteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);
            // Validate surface size and format.
            try {
                Size s = getSurfaceSize(output);
                int surfaceType = detectSurfaceType(output);
                boolean flexibleConsumer = isFlexibleConsumer(output);
                Size[] sizes = streamConfigurations.getOutputSizes(surfaceType);
                if (sizes == null) {
                    // WAR: Override default format to IMPLEMENTATION_DEFINED for b/9487482
                    if ((surfaceType >= LegacyMetadataMapper.HAL_PIXEL_FORMAT_RGBA_8888 && surfaceType <= LegacyMetadataMapper.HAL_PIXEL_FORMAT_BGRA_8888)) {
                        // YUV_420_888 is always present in LEGACY for all
                        // IMPLEMENTATION_DEFINED output sizes, and is publicly visible in the
                        // API (i.e. {@code #getOutputSizes} works here).
                        sizes = streamConfigurations.getOutputSizes(ImageFormat.YUV_420_888);
                    } else if (surfaceType == LegacyMetadataMapper.HAL_PIXEL_FORMAT_BLOB) {
                        sizes = streamConfigurations.getOutputSizes(ImageFormat.JPEG);
                    }
                }
                if (!ArrayUtils.contains(sizes, s)) {
                    if (flexibleConsumer && (s = findClosestSize(s, sizes)) != null) {
                        sizedSurfaces.add(new Pair<>(output, s));
                    } else {
                        String reason = (sizes == null) ? ""format is invalid."" : (""size not in valid set: "" + Arrays.toString(sizes));
                        Log.e(TAG, String.format(""Surface with size (w=%d, h=%d) and format "" + ""0x%x is not valid, %s"", s.getWidth(), s.getHeight(), surfaceType, reason));
                        return BAD_VALUE;
                    }
                } else {
                    sizedSurfaces.add(new Pair<>(output, s));
                }
                // Lock down the size before configuration
                setSurfaceDimens(output, s.getWidth(), s.getHeight());
            } catch (BufferQueueAbandonedException e) {
                Log.e(TAG, ""Surface bufferqueue is abandoned, cannot configure as output: "", e);
                return BAD_VALUE;
            }
        }
    }
    boolean success = false;
    if (mDeviceState.setConfiguring()) {
        mRequestThreadManager.configure(sizedSurfaces);
        success = mDeviceState.setIdle();
    }
    if (success) {
        mConfiguredSurfaces = outputs != null ? new ArrayList<>(outputs) : null;
    } else {
        return CameraBinderDecorator.INVALID_OPERATION;
    }
    return CameraBinderDecorator.NO_ERROR;
}",1,"/**
 * Configure the device with a set of output surfaces.
 *
 * <p>Using empty or {@code null} {@code outputs} is the same as unconfiguring.</p>
 *
 * <p>Every surface in {@code outputs} must be non-{@code null}.</p>
 *
 * @param outputs a list of surfaces to set.
 * @return an error code for this binder operation, or {@link NO_ERROR}
 * on success.
 */
","/**
 * Configure the device with a set of output surfaces.
 *
 * <p>Using empty or {@code null} {@code outputs} is the same as unconfiguring.</p>
 *
 * <p>Every surface in {@code outputs} must be non-{@code null}.</p>
 *
 * @param outputs a list of surfaces to set.
 * @return an error code for this binder operation, or {@link NO_ERROR}
 * on success.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
919,"<android.accounts.AbstractAccountAuthenticator: Bundle getAccountCredentialsForCloning(AccountAuthenticatorResponse,Account)>",22,23,"<android.accounts.AbstractAccountAuthenticator: Bundle getAccountCredentialsForCloning(AccountAuthenticatorResponse,Account)>","<android.accounts.AbstractAccountAuthenticator: Bundle getAccountCredentialsForCloning(AccountAuthenticatorResponse,Account)>",0,"{
    new Thread(new Runnable() {

        public void run() {
            Bundle result = new Bundle();
            result.putBoolean(AccountManager.KEY_BOOLEAN_RESULT, false);
            response.onResult(result);
        }
    }).start();
    return null;
}","{
    new Thread(new Runnable() {

        @Override
        public void run() {
            Bundle result = new Bundle();
            result.putBoolean(AccountManager.KEY_BOOLEAN_RESULT, false);
            response.onResult(result);
        }
    }).start();
    return null;
}",1,"/**
 * Returns a Bundle that contains whatever is required to clone the account on a different
 * user. The Bundle is passed to the authenticator instance in the target user via
 * {@link #addAccountFromCredentials(AccountAuthenticatorResponse, Account, Bundle)}.
 * The default implementation returns null, indicating that cloning is not supported.
 * @param response to send the result back to the AccountManager, will never be null
 * @param account the account to clone, will never be null
 * @return a Bundle result or null if the result is to be returned via the response.
 * @throws NetworkErrorException
 * @see {@link #addAccountFromCredentials(AccountAuthenticatorResponse, Account, Bundle)}
 */
","/**
 * Returns a Bundle that contains whatever is required to clone the account on a different
 * user. The Bundle is passed to the authenticator instance in the target user via
 * {@link #addAccountFromCredentials(AccountAuthenticatorResponse, Account, Bundle)}.
 * The default implementation returns null, indicating that cloning is not supported.
 * @param response to send the result back to the AccountManager, will never be null
 * @param account the account to clone, will never be null
 * @return a Bundle result or null if the result is to be returned via the response.
 * @throws NetworkErrorException
 * @see {@link #addAccountFromCredentials(AccountAuthenticatorResponse, Account, Bundle)}
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,The code has not changed between the early and late version except for the addition of the `@Override` annotation in the anonymous inner class for the `Runnable.run()` method. This change has no impact on the behavior of the method being analyzed.,"There is no compatibility issue because the behavior of the API has not been altered between the two provided versions. The change is purely syntactical to explicitly indicate that a method is being overridden, and does not affect the method's functionality or the return type."
920,<android.hardware.camera2.impl.CameraDeviceImpl: void close()>,22,23,<android.hardware.camera2.impl.CameraDeviceImpl: void close()>,<android.hardware.camera2.impl.CameraDeviceImpl: void close()>,0,"{
    synchronized (mInterfaceLock) {
        try {
            if (mRemoteDevice != null) {
                mRemoteDevice.disconnect();
            }
        } catch (CameraRuntimeException e) {
            Log.e(TAG, ""Exception while closing: "", e.asChecked());
        } catch (RemoteException e) {
        // impossible
        }
        // or a close after a startup error (no remote device but in error state)
        if (mRemoteDevice != null || mInError) {
            mDeviceHandler.post(mCallOnClosed);
        }
        mRemoteDevice = null;
        mInError = false;
    }
}","{
    synchronized (mInterfaceLock) {
        if (mClosing.getAndSet(true)) {
            return;
        }
        try {
            if (mRemoteDevice != null) {
                mRemoteDevice.disconnect();
            }
        } catch (CameraRuntimeException e) {
            Log.e(TAG, ""Exception while closing: "", e.asChecked());
        } catch (RemoteException e) {
        // impossible
        }
        // or a close after a startup error (no remote device but in error state)
        if (mRemoteDevice != null || mInError) {
            mDeviceHandler.post(mCallOnClosed);
        }
        mRemoteDevice = null;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"The late version adds a control flow statement (if (mClosing.getAndSet(true))) that includes a returning early from the method, and also removes the assignment of false to the mInError variable, so the code change type is 1,3.","The additional early return statement and removal of the mInError = false assignment could lead to the API having different side effects or return behavior (returning early without executing the rest of the code or not resetting the mInError state), so the CI type is 1."
921,"<android.text.SpannableStringBuilder: SpannableStringBuilder replace(int,int,CharSequence,int,int)>",22,23,"<android.text.SpannableStringBuilder: SpannableStringBuilder replace(int,int,CharSequence,int,int)>","<android.text.SpannableStringBuilder: SpannableStringBuilder replace(int,int,CharSequence,int,int)>",0,"{
    checkRange(""replace"", start, end);
    int filtercount = mFilters.length;
    for (int i = 0; i < filtercount; i++) {
        CharSequence repl = mFilters[i].filter(tb, tbstart, tbend, this, start, end);
        if (repl != null) {
            tb = repl;
            tbstart = 0;
            tbend = repl.length();
        }
    }
    final int origLen = end - start;
    final int newLen = tbend - tbstart;
    if (origLen == 0 && newLen == 0 && !hasNonExclusiveExclusiveSpanAt(tb, tbstart)) {
        // Early exit so that the text watchers do not get notified
        return this;
    }
    TextWatcher[] textWatchers = getSpans(start, start + origLen, TextWatcher.class);
    sendBeforeTextChanged(textWatchers, start, origLen, newLen);
    // Try to keep the cursor / selection at the same relative position during
    // a text replacement. If replaced or replacement text length is zero, this
    // is already taken care of.
    boolean adjustSelection = origLen != 0 && newLen != 0;
    int selectionStart = 0;
    int selectionEnd = 0;
    if (adjustSelection) {
        selectionStart = Selection.getSelectionStart(this);
        selectionEnd = Selection.getSelectionEnd(this);
    }
    change(start, end, tb, tbstart, tbend);
    if (adjustSelection) {
        if (selectionStart > start && selectionStart < end) {
            final int offset = (selectionStart - start) * newLen / origLen;
            selectionStart = start + offset;
            setSpan(false, Selection.SELECTION_START, selectionStart, selectionStart, Spanned.SPAN_POINT_POINT);
        }
        if (selectionEnd > start && selectionEnd < end) {
            final int offset = (selectionEnd - start) * newLen / origLen;
            selectionEnd = start + offset;
            setSpan(false, Selection.SELECTION_END, selectionEnd, selectionEnd, Spanned.SPAN_POINT_POINT);
        }
    }
    sendTextChanged(textWatchers, start, origLen, newLen);
    sendAfterTextChanged(textWatchers);
    // Span watchers need to be called after text watchers, which may update the layout
    sendToSpanWatchers(start, end, newLen - origLen);
    return this;
}","{
    checkRange(""replace"", start, end);
    int filtercount = mFilters.length;
    for (int i = 0; i < filtercount; i++) {
        CharSequence repl = mFilters[i].filter(tb, tbstart, tbend, this, start, end);
        if (repl != null) {
            tb = repl;
            tbstart = 0;
            tbend = repl.length();
        }
    }
    final int origLen = end - start;
    final int newLen = tbend - tbstart;
    if (origLen == 0 && newLen == 0 && !hasNonExclusiveExclusiveSpanAt(tb, tbstart)) {
        // Early exit so that the text watchers do not get notified
        return this;
    }
    TextWatcher[] textWatchers = getSpans(start, start + origLen, TextWatcher.class);
    sendBeforeTextChanged(textWatchers, start, origLen, newLen);
    // Try to keep the cursor / selection at the same relative position during
    // a text replacement. If replaced or replacement text length is zero, this
    // is already taken care of.
    boolean adjustSelection = origLen != 0 && newLen != 0;
    int selectionStart = 0;
    int selectionEnd = 0;
    if (adjustSelection) {
        selectionStart = Selection.getSelectionStart(this);
        selectionEnd = Selection.getSelectionEnd(this);
    }
    change(start, end, tb, tbstart, tbend);
    if (adjustSelection) {
        boolean changed = false;
        if (selectionStart > start && selectionStart < end) {
            final int offset = (selectionStart - start) * newLen / origLen;
            selectionStart = start + offset;
            changed = true;
            setSpan(false, Selection.SELECTION_START, selectionStart, selectionStart, Spanned.SPAN_POINT_POINT);
        }
        if (selectionEnd > start && selectionEnd < end) {
            final int offset = (selectionEnd - start) * newLen / origLen;
            selectionEnd = start + offset;
            changed = true;
            setSpan(false, Selection.SELECTION_END, selectionEnd, selectionEnd, Spanned.SPAN_POINT_POINT);
        }
        if (changed) {
            restoreInvariants();
        }
    }
    sendTextChanged(textWatchers, start, origLen, newLen);
    sendAfterTextChanged(textWatchers);
    // Span watchers need to be called after text watchers, which may update the layout
    sendToSpanWatchers(start, end, newLen - origLen);
    return this;
}",1,"// Documentation from interface
","// Documentation from interface
",-1,,,-1,-1,-1,-1,-1,-1,,,,
922,<android.widget.CompoundButton: void setButtonDrawable(int)>,22,23,<android.widget.CompoundButton: void setButtonDrawable(int)>,<android.widget.CompoundButton: void setButtonDrawable(int)>,0,"{
    if (resid != 0 && resid == mButtonResource) {
        return;
    }
    mButtonResource = resid;
    Drawable d = null;
    if (mButtonResource != 0) {
        d = getContext().getDrawable(mButtonResource);
    }
    setButtonDrawable(d);
}","{
    final Drawable d;
    if (resId != 0) {
        d = getContext().getDrawable(resId);
    } else {
        d = null;
    }
    setButtonDrawable(d);
}",1,"/**
 * Set the button graphic to a given Drawable, identified by its resource
 * id.
 *
 * @param resid the resource id of the drawable to use as the button
 * graphic
 */
","/**
 * Sets a drawable as the compound button image given its resource
 * identifier.
 *
 * @param resId the resource identifier of the drawable
 * @attr ref android.R.styleable#CompoundButton_button
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"Although the implementations have been refactored, the logic remains the same. In both versions, if `resid` (or `resId`) is not zero, `getContext().getDrawable()` is called with that id, and the result is passed to `setButtonDrawable()`. The refactoring in the late version simplifies the check and avoids the unnecessary comparison `resid == mButtonResource`, but it does not change the method's behavior since this comparison was redundant for setting the drawable. Therefore, there is no functional change in how the method works.","As the behavior of the method does not change (the outcome for any given input remains the same before and after the change), no compatibility issue arises."
924,<android.text.style.BackgroundColorSpan: int getSpanTypeId()>,22,23,<android.text.style.BackgroundColorSpan: int getSpanTypeId()>,<android.text.style.BackgroundColorSpan: int getSpanTypeId()>,0,"{
    return TextUtils.BACKGROUND_COLOR_SPAN;
}","{
    return getSpanTypeIdInternal();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from a direct return of a constant to a call to getSpanTypeIdInternal() function, so the code change type is 1,5.","Since the return statement now calls a different method, it may potentially return a different value depending on the implementation of getSpanTypeIdInternal(), which causes the CI type to be 1."
925,<android.view.ScaleGestureDetector: float getScaleFactor()>,22,23,<android.view.ScaleGestureDetector: float getScaleFactor()>,<android.view.ScaleGestureDetector: float getScaleFactor()>,0,"{
    if (inDoubleTapMode()) {
        // Drag is moving up; the further away from the gesture
        // start, the smaller the span should be, the closer,
        // the larger the span, and therefore the larger the scale
        final boolean scaleUp = (mEventBeforeOrAboveStartingGestureEvent && (mCurrSpan < mPrevSpan)) || (!mEventBeforeOrAboveStartingGestureEvent && (mCurrSpan > mPrevSpan));
        final float spanDiff = (Math.abs(1 - (mCurrSpan / mPrevSpan)) * SCALE_FACTOR);
        return mPrevSpan <= 0 ? 1 : scaleUp ? (1 + spanDiff) : (1 - spanDiff);
    }
    return mPrevSpan > 0 ? mCurrSpan / mPrevSpan : 1;
}","{
    if (inAnchoredScaleMode()) {
        // Drag is moving up; the further away from the gesture
        // start, the smaller the span should be, the closer,
        // the larger the span, and therefore the larger the scale
        final boolean scaleUp = (mEventBeforeOrAboveStartingGestureEvent && (mCurrSpan < mPrevSpan)) || (!mEventBeforeOrAboveStartingGestureEvent && (mCurrSpan > mPrevSpan));
        final float spanDiff = (Math.abs(1 - (mCurrSpan / mPrevSpan)) * SCALE_FACTOR);
        return mPrevSpan <= 0 ? 1 : scaleUp ? (1 + spanDiff) : (1 - spanDiff);
    }
    return mPrevSpan > 0 ? mCurrSpan / mPrevSpan : 1;
}",1,"/**
 * Return the scaling factor from the previous scale event to the current
 * event. This value is defined as
 * ({@link #getCurrentSpan()} / {@link #getPreviousSpan()}).
 *
 * @return The current scaling factor.
 */
","/**
 * Return the scaling factor from the previous scale event to the current
 * event. This value is defined as
 * ({@link #getCurrentSpan()} / {@link #getPreviousSpan()}).
 *
 * @return The current scaling factor.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The condition in the if statement has changed from inDoubleTapMode() to inAnchoredScaleMode(), which falls under the control dependency change, so the code change type is 3.","Since the calculations inside the if condition and outside remain unchanged and only the condition itself has been modified, this change will not affect the return value as long as the new condition inAnchoredScaleMode() is semantically equivalent to the old one inDoubleTapMode() within the context of this method. However, without additional context on whether the semantics of these conditions are meant to be equivalent, it is safe to assume there is no Compatibility Issue, since the output is not directly affected by this condition change alone. Thus, the CI type is 0."
928,<android.text.style.TypefaceSpan: int getSpanTypeId()>,22,23,<android.text.style.TypefaceSpan: int getSpanTypeId()>,<android.text.style.TypefaceSpan: int getSpanTypeId()>,0,"{
    return TextUtils.TYPEFACE_SPAN;
}","{
    return getSpanTypeIdInternal();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation has changed from returning a constant value to calling a new method getSpanTypeIdInternal(), which is considered as the method call change. Hence, the code change type is 1,5 since the method that the return statement is dependent on has changed.","The change from a constant return value to a possibly different value, depending on the behavior of getSpanTypeIdInternal(), could lead to the API returning a different value. Therefore, the CI type is 1."
932,"<android.content.ContentProviderProxy: ParcelFileDescriptor openFile(String,Uri,String,ICancellationSignal,IBinder)>",22,23,"<android.content.ContentProviderProxy: ParcelFileDescriptor openFile(String,Uri,String,ICancellationSignal,IBinder)>","<android.content.ContentProviderProxy: ParcelFileDescriptor openFile(String,Uri,String,ICancellationSignal,IBinder)>",0,"{
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    try {
        data.writeInterfaceToken(IContentProvider.descriptor);
        data.writeString(callingPkg);
        url.writeToParcel(data, 0);
        data.writeString(mode);
        data.writeStrongBinder(signal != null ? signal.asBinder() : null);
        data.writeStrongBinder(token);
        mRemote.transact(IContentProvider.OPEN_FILE_TRANSACTION, data, reply, 0);
        DatabaseUtils.readExceptionWithFileNotFoundExceptionFromParcel(reply);
        int has = reply.readInt();
        ParcelFileDescriptor fd = has != 0 ? reply.readFileDescriptor() : null;
        return fd;
    } finally {
        data.recycle();
        reply.recycle();
    }
}","{
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    try {
        data.writeInterfaceToken(IContentProvider.descriptor);
        data.writeString(callingPkg);
        url.writeToParcel(data, 0);
        data.writeString(mode);
        data.writeStrongBinder(signal != null ? signal.asBinder() : null);
        data.writeStrongBinder(token);
        mRemote.transact(IContentProvider.OPEN_FILE_TRANSACTION, data, reply, 0);
        DatabaseUtils.readExceptionWithFileNotFoundExceptionFromParcel(reply);
        int has = reply.readInt();
        ParcelFileDescriptor fd = has != 0 ? ParcelFileDescriptor.CREATOR.createFromParcel(reply) : null;
        return fd;
    } finally {
        data.recycle();
        reply.recycle();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The method used to read the ParcelFileDescriptor from the reply Parcel has changed from `reply.readFileDescriptor()` to `ParcelFileDescriptor.CREATOR.createFromParcel(reply)`, which is an alternate API for deserialization. Also, there's no control structure, exception handling, or dependent API involved in this change, so the change only involves a return statement (other API usage) and thus the code change types are 1 and 4.","The replacement of `readFileDescriptor()` method with `CREATOR.createFromParcel()` for creating `ParcelFileDescriptor` could potentially return different results or throw different exceptions implicitly if the actual behavior of deserialization has changed internally. This means that the API may potentially return a different value or throw a different exception (implicitly if `createFromParcel` behaves differently in error cases), which leads to a CI type of 1."
935,"<android.view.View: int resolveSizeAndState(int,int,int)>",22,23,"<android.view.View: int resolveSizeAndState(int,int,int)>","<android.view.View: int resolveSizeAndState(int,int,int)>",0,"{
    int result = size;
    int specMode = MeasureSpec.getMode(measureSpec);
    int specSize = MeasureSpec.getSize(measureSpec);
    switch(specMode) {
        case MeasureSpec.UNSPECIFIED:
            result = size;
            break;
        case MeasureSpec.AT_MOST:
            if (specSize < size) {
                result = specSize | MEASURED_STATE_TOO_SMALL;
            } else {
                result = size;
            }
            break;
        case MeasureSpec.EXACTLY:
            result = specSize;
            break;
    }
    return result | (childMeasuredState & MEASURED_STATE_MASK);
}","{
    final int specMode = MeasureSpec.getMode(measureSpec);
    final int specSize = MeasureSpec.getSize(measureSpec);
    final int result;
    switch(specMode) {
        case MeasureSpec.AT_MOST:
            if (specSize < size) {
                result = specSize | MEASURED_STATE_TOO_SMALL;
            } else {
                result = size;
            }
            break;
        case MeasureSpec.EXACTLY:
            result = specSize;
            break;
        case MeasureSpec.UNSPECIFIED:
        default:
            result = size;
    }
    return result | (childMeasuredState & MEASURED_STATE_MASK);
}",1,"/**
 * Utility to reconcile a desired size and state, with constraints imposed
 * by a MeasureSpec.  Will take the desired size, unless a different size
 * is imposed by the constraints.  The returned value is a compound integer,
 * with the resolved size in the {@link #MEASURED_SIZE_MASK} bits and
 * optionally the bit {@link #MEASURED_STATE_TOO_SMALL} set if the resulting
 * size is smaller than the size the view wants to be.
 *
 * @param size How big the view wants to be
 * @param measureSpec Constraints imposed by the parent
 * @return Size information bit mask as defined by
 * {@link #MEASURED_SIZE_MASK} and {@link #MEASURED_STATE_TOO_SMALL}.
 */
","/**
 * Utility to reconcile a desired size and state, with constraints imposed
 * by a MeasureSpec. Will take the desired size, unless a different size
 * is imposed by the constraints. The returned value is a compound integer,
 * with the resolved size in the {@link #MEASURED_SIZE_MASK} bits and
 * optionally the bit {@link #MEASURED_STATE_TOO_SMALL} set if the
 * resulting size is smaller than the size the view wants to be.
 *
 * @param size How big the view wants to be.
 * @param measureSpec Constraints imposed by the parent.
 * @param childMeasuredState Size information bit mask for the view's
 * children.
 * @return Size information bit mask as defined by
 * {@link #MEASURED_SIZE_MASK} and
 * {@link #MEASURED_STATE_TOO_SMALL}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,The changes between the early and late implementation of this method include reordering the cases within the switch statement and changing the variable 'result' from being initialized at the beginning and then reassigned to being initialized within the switch statement cases.,#CI_description
936,<android.text.style.ScaleXSpan: int getSpanTypeId()>,22,23,<android.text.style.ScaleXSpan: int getSpanTypeId()>,<android.text.style.ScaleXSpan: int getSpanTypeId()>,0,"{
    return TextUtils.SCALE_X_SPAN;
}","{
    return getSpanTypeIdInternal();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method body changed from directly returning a constant (TextUtils.SCALE_X_SPAN) to calling another method (getSpanTypeIdInternal()), so the code change type is 5.","There is no compatibility issue as long as the getSpanTypeIdInternal() method returns the same constant value previously returned directly. Since there's no change in the return value/type indicated by this change, no CI exists."
937,<android.app.Fragment: LoaderManager getLoaderManager()>,22,23,<android.app.Fragment: LoaderManager getLoaderManager()>,<android.app.Fragment: LoaderManager getLoaderManager()>,0,"{
    if (mLoaderManager != null) {
        return mLoaderManager;
    }
    if (mActivity == null) {
        throw new IllegalStateException(""Fragment "" + this + "" not attached to Activity"");
    }
    mCheckedForLoaderManager = true;
    mLoaderManager = mActivity.getLoaderManager(mWho, mLoadersStarted, true);
    return mLoaderManager;
}","{
    if (mLoaderManager != null) {
        return mLoaderManager;
    }
    if (mHost == null) {
        throw new IllegalStateException(""Fragment "" + this + "" not attached to Activity"");
    }
    mCheckedForLoaderManager = true;
    mLoaderManager = mHost.getLoaderManager(mWho, mLoadersStarted, true);
    return mLoaderManager;
}",1,"/**
 * Return the LoaderManager for this fragment, creating it if needed.
 */
","/**
 * Return the LoaderManager for this fragment, creating it if needed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The statement mActivity.getLoaderManager(mWho, mLoadersStarted, true) has been changed to mHost.getLoaderManager(mWho, mLoadersStarted, true) and the exception throw condition has changed from checking if 'mActivity' is null to checking if 'mHost' is null, so the change types are 4 and 5.","However, these changes do not cause a CI because the method's behavior, in terms of exception throwing and return values, remains consistent with how it behaved in the early version. The change is about internal implementation details and does not affect the API's external behavior."
938,<android.widget.DatePickerCalendarDelegate: boolean isEnabled()>,22,23,<android.widget.DatePickerCalendarDelegate: boolean isEnabled()>,<android.widget.DatePickerCalendarDelegate: boolean isEnabled()>,0,"{
    return mIsEnabled;
}","{
    return mContainer.isEnabled();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The source of the return value has shifted from a direct field access (mIsEnabled) to a method call (mContainer.isEnabled()), and the method that's being called (isEnabled()) on mContainer could potentially behave differently than the direct field access. So the code change type is 1,5.","Since the method call (mContainer.isEnabled()) could potentially return a different value than the direct field access (mIsEnabled), there is a possibility for the API to return a different variable. Therefore, the CI type is 1."
939,<android.app.Fragment: void performStop()>,22,23,<android.app.Fragment: void performStop()>,<android.app.Fragment: void performStop()>,0,"{
    if (mChildFragmentManager != null) {
        mChildFragmentManager.dispatchStop();
    }
    mCalled = false;
    onStop();
    if (!mCalled) {
        throw new SuperNotCalledException(""Fragment "" + this + "" did not call through to super.onStop()"");
    }
    if (mLoadersStarted) {
        mLoadersStarted = false;
        if (!mCheckedForLoaderManager) {
            mCheckedForLoaderManager = true;
            mLoaderManager = mActivity.getLoaderManager(mWho, mLoadersStarted, false);
        }
        if (mLoaderManager != null) {
            if (mActivity == null || !mActivity.mChangingConfigurations) {
                mLoaderManager.doStop();
            } else {
                mLoaderManager.doRetain();
            }
        }
    }
}","{
    if (mChildFragmentManager != null) {
        mChildFragmentManager.dispatchStop();
    }
    mCalled = false;
    onStop();
    if (!mCalled) {
        throw new SuperNotCalledException(""Fragment "" + this + "" did not call through to super.onStop()"");
    }
    if (mLoadersStarted) {
        mLoadersStarted = false;
        if (!mCheckedForLoaderManager) {
            mCheckedForLoaderManager = true;
            mLoaderManager = mHost.getLoaderManager(mWho, mLoadersStarted, false);
        }
        if (mLoaderManager != null) {
            if (mRetaining) {
                mLoaderManager.doRetain();
            } else {
                mLoaderManager.doStop();
            }
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,5",0,"The condition in the if statement has changed from checking if mActivity is null or mActivity.mChangingConfigurations to just checking if mRetaining is true. Also, the way of getting the LoaderManager has changed from calling `mActivity.getLoaderManager()` to `mHost.getLoaderManager()`. Thus, both control dependency and dependent API changes have occurred, which indicates a change type of 3,5.","Despite the changes in control dependency and the dependent API, these changes do not seem to directly affect the return value or the exceptions thrown by this method because the overall behavior and sequence of actions remain consistent. The different conditions for whether to call `doRetain()` or `doStop()` on `mLoaderManager` are an internal behavior decision that does not affect the API's output or exception-throwing behavior for the callers of `performStop()`. Thus, there is no Compatibility Issue, which means the CI type is 0."
940,<android.app.Fragment: boolean isAdded()>,22,23,<android.app.Fragment: boolean isAdded()>,<android.app.Fragment: boolean isAdded()>,0,"{
    return mActivity != null && mAdded;
}","{
    return mHost != null && mAdded;
}",1,"/**
 * Return true if the fragment is currently added to its activity.
 */
","/**
 * Return true if the fragment is currently added to its activity.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The field used in the condition has changed from `mActivity` to `mHost`, so the code change type is 4.","There's no Compatibility Issue here because the conceptual check remains the same - the method is intended to ensure that the Fragment is currently added to an activity. If the developers have simply refactored the code such that `mActivity` has been replaced by `mHost` to represent the fragment's association with its hosting environment without changing the semantics of the condition, then this change would not introduce a different behavior in how `isAdded()` works. Hence, the change is internal and does not affect the API contract."
941,<android.hardware.camera2.impl.CameraCaptureSessionImpl.IdleDrainListener: void onDrained()>,22,23,<android.hardware.camera2.impl.CameraCaptureSessionImpl.IdleDrainListener: void onDrained()>,<android.hardware.camera2.impl.CameraCaptureSessionImpl.IdleDrainListener: void onDrained()>,0,"{
    if (VERBOSE)
        Log.v(TAG, mIdString + ""onIdleDrained"");
    // without causing a deadlock
    synchronized (mDeviceImpl.mInterfaceLock) {
        synchronized (CameraCaptureSessionImpl.this) {
            /*
                 * The device is now IDLE, and has settled. It will not transition to
                 * ACTIVE or BUSY again by itself.
                 *
                 * It's now safe to unconfigure the outputs and after it's done invoke #onClosed.
                 *
                 * This operation is idempotent; a session will not be closed twice.
                 */
            if (VERBOSE)
                Log.v(TAG, mIdString + ""Session drain complete, skip unconfigure: "" + mSkipUnconfigure);
            // Fast path: A new capture session has replaced this one; don't unconfigure.
            if (mSkipUnconfigure) {
                mStateCallback.onClosed(CameraCaptureSessionImpl.this);
                return;
            }
            // Slow path: #close was called explicitly on this session; unconfigure first
            mUnconfigureDrainer.taskStarted();
            try {
                mDeviceImpl.configureOutputsChecked(// begin transition to unconfigured
                null);
            } catch (CameraAccessException e) {
                // OK: do not throw checked exceptions.
                Log.e(TAG, mIdString + ""Exception while configuring outputs: "", e);
            // TODO: call onError instead of onClosed if this happens
            } catch (IllegalStateException e) {
                // Camera is already closed, so go straight to the close callback
                if (VERBOSE)
                    Log.v(TAG, mIdString + ""Camera was already closed or busy, skipping unconfigure"");
                mUnconfigureDrainer.taskFinished();
            }
            mUnconfigureDrainer.beginDrain();
        }
    }
}","{
    if (DEBUG)
        Log.v(TAG, mIdString + ""onIdleDrained"");
    // without causing a deadlock
    synchronized (mDeviceImpl.mInterfaceLock) {
        synchronized (CameraCaptureSessionImpl.this) {
            /*
                 * The device is now IDLE, and has settled. It will not transition to
                 * ACTIVE or BUSY again by itself.
                 *
                 * It's now safe to unconfigure the outputs.
                 *
                 * This operation is idempotent; a session will not be closed twice.
                 */
            if (DEBUG)
                Log.v(TAG, mIdString + ""Session drain complete, skip unconfigure: "" + mSkipUnconfigure);
            // as we won't get state updates any more anyway.
            if (mSkipUnconfigure) {
                return;
            }
            // everything is idle.
            try {
                // begin transition to unconfigured
                mDeviceImpl.configureStreamsChecked(/*inputConfig*/
                null, /*outputs*/
                null, /*isConstrainedHighSpeed*/
                false);
            } catch (CameraAccessException e) {
                // OK: do not throw checked exceptions.
                Log.e(TAG, mIdString + ""Exception while unconfiguring outputs: "", e);
            // TODO: call onError instead of onClosed if this happens
            } catch (IllegalStateException e) {
                // Camera is already closed, so nothing left to do
                if (DEBUG)
                    Log.v(TAG, mIdString + ""Camera was already closed or busy, skipping unconfigure"");
            }
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,2,3,4,5","1,2","The early version implementation contains more complex logic with conditions that include output configurations, logging flags, and explicit state callbacks. A return statement has been deleted after `mStateCallback.onClosed(CameraCaptureSessionImpl.this);`, and exception handling logic has changed. There is also a call to `mUnconfigureDrainer.taskStarted();` and `mUnconfigureDrainer.beginDrain();` in the early version, which does not exist in the late version. The method `configureStreamsChecked` is also now used instead of `configureOutputsChecked`, and it includes additional parameters. There is a change in log level condition (`VERBOSE` to `DEBUG`). Furthermore, for the `IllegalStateException`, the late version removed `mUnconfigureDrainer.taskFinished();`. So the change type is 1,2,3,4,5.","These changes introduce the potential for different return values through the change of internal control flow due to the removal of the `mStateCallback.onClosed(CameraCaptureSessionImpl.this);` call and no longer performing the unconfigure drain tasks. Exception handling logic also changed: in the early version, an `IllegalStateException` will finish the `mUnconfigureDrainer` task, but in the late version, it doesn't, which can affect the state of the system differently when an `IllegalStateException` is caught. So the CI type is 1,2."
942,<android.app.admin.DevicePolicyManager: void removeActiveAdmin(ComponentName)>,22,23,<android.app.admin.DevicePolicyManager: void removeActiveAdmin(ComponentName)>,<android.app.admin.DevicePolicyManager: void removeActiveAdmin(ComponentName)>,0,"{
    if (mService != null) {
        try {
            mService.removeActiveAdmin(who, UserHandle.myUserId());
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    if (mService != null) {
        try {
            mService.removeActiveAdmin(admin, UserHandle.myUserId());
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}",1,"/**
 * Remove a current administration component.  This can only be called
 * by the application that owns the administration component; if you
 * try to remove someone else's component, a security exception will be
 * thrown.
 */
","/**
 * Remove a current administration component.  This can only be called
 * by the application that owns the administration component; if you
 * try to remove someone else's component, a security exception will be
 * thrown.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The name of the parameter in the call to mService.removeActiveAdmin has changed from 'who' to 'admin', but since it's just a rename of a variable and not a change in the method signature or behavior, the change type is 5 (Dependent API Changed).",There's no Compatibility Issue as the parameter rename should not affect the method's outward behavior; it's an internal change with no impact on the method contract or functionality provided that 'who' and 'admin' are effectively the same.
944,<android.content.ContentResolver: Uri canonicalize(Uri)>,22,23,<android.content.ContentResolver: Uri canonicalize(Uri)>,<android.content.ContentResolver: Uri canonicalize(Uri)>,0,"{
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        return null;
    }
    try {
        return provider.canonicalize(mPackageName, url);
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        releaseProvider(provider);
    }
}","{
    Preconditions.checkNotNull(url, ""url"");
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        return null;
    }
    try {
        return provider.canonicalize(mPackageName, url);
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        releaseProvider(provider);
    }
}",1,"/**
 * Transform the given <var>url</var> to a canonical representation of
 * its referenced resource, which can be used across devices, persisted,
 * backed up and restored, etc.  The returned Uri is still a fully capable
 * Uri for use with its content provider, allowing you to do all of the
 * same content provider operations as with the original Uri --
 * {@link #query}, {@link #openInputStream(android.net.Uri)}, etc.  The
 * only difference in behavior between the original and new Uris is that
 * the content provider may need to do some additional work at each call
 * using it to resolve it to the correct resource, especially if the
 * canonical Uri has been moved to a different environment.
 *
 * <p>If you are moving a canonical Uri between environments, you should
 * perform another call to {@link #canonicalize} with that original Uri to
 * re-canonicalize it for the current environment.  Alternatively, you may
 * want to use {@link #uncanonicalize} to transform it to a non-canonical
 * Uri that works only in the current environment but potentially more
 * efficiently than the canonical representation.</p>
 *
 * @param url The {@link Uri} that is to be transformed to a canonical
 * representation.  Like all resolver calls, the input can be either
 * a non-canonical or canonical Uri.
 *
 * @return Returns the official canonical representation of <var>url</var>,
 * or null if the content provider does not support a canonical representation
 * of the given Uri.  Many providers may not support canonicalization of some
 * or all of their Uris.
 *
 * @see #uncanonicalize
 */
","/**
 * Transform the given <var>url</var> to a canonical representation of
 * its referenced resource, which can be used across devices, persisted,
 * backed up and restored, etc.  The returned Uri is still a fully capable
 * Uri for use with its content provider, allowing you to do all of the
 * same content provider operations as with the original Uri --
 * {@link #query}, {@link #openInputStream(android.net.Uri)}, etc.  The
 * only difference in behavior between the original and new Uris is that
 * the content provider may need to do some additional work at each call
 * using it to resolve it to the correct resource, especially if the
 * canonical Uri has been moved to a different environment.
 *
 * <p>If you are moving a canonical Uri between environments, you should
 * perform another call to {@link #canonicalize} with that original Uri to
 * re-canonicalize it for the current environment.  Alternatively, you may
 * want to use {@link #uncanonicalize} to transform it to a non-canonical
 * Uri that works only in the current environment but potentially more
 * efficiently than the canonical representation.</p>
 *
 * @param url The {@link Uri} that is to be transformed to a canonical
 * representation.  Like all resolver calls, the input can be either
 * a non-canonical or canonical Uri.
 *
 * @return Returns the official canonical representation of <var>url</var>,
 * or null if the content provider does not support a canonical representation
 * of the given Uri.  Many providers may not support canonicalization of some
 * or all of their Uris.
 *
 * @see #uncanonicalize
 */
",-1,,[@Nullable],-1,-1,-1,-1,-1,-1,4,0,"There is an addition of Preconditions.checkNotNull(url, ""url"") in the late version of the implementation. This is a form of argument validation, which counts as an 'Other statement changed'. As this is the only change and it does not affect the return value or the possible exceptions thrown by the method, the code change type is 4.","The addition of Preconditions.checkNotNull(url, ""url"") will not cause a Compatibility Issue as it simply enforces a check that the 'url' parameter is not null. If the argument 'url' is indeed null, the early version would acquireProvider with a null value, which could lead to unspecified behavior or an exception, while the late version will explicitly throw a NullPointerException. Since both outcomes are related to invalid input (null 'url'), and it is a usual practice to validate method arguments, it does not qualify as a change that would cause a CI in the expected functionality of the API. Therefore, we consider this change to have No Compatibility Issue."
945,<android.text.style.AbsoluteSizeSpan: int getSpanTypeId()>,22,23,<android.text.style.AbsoluteSizeSpan: int getSpanTypeId()>,<android.text.style.AbsoluteSizeSpan: int getSpanTypeId()>,0,"{
    return TextUtils.ABSOLUTE_SIZE_SPAN;
}","{
    return getSpanTypeIdInternal();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method now calls getSpanTypeIdInternal() instead of directly returning a constant value, but since there is no information regarding the implementation of getSpanTypeIdInternal(), it is considered a change in the dependent API, so the code change type is 5.","Assuming the return value from getSpanTypeIdInternal() is consistent with the early version's TextUtils.ABSOLUTE_SIZE_SPAN, there is no indication that the change would lead to a compatibility issue. Therefore, there is no compatibility issue detected, and the CI type is 0."
949,"<android.gesture.GestureUtils: float computeStraightness(float[],float)>",22,23,"<android.gesture.GestureUtils: float computeStraightness(float[],float)>","<android.gesture.GestureUtils: float computeStraightness(float[],float)>",0,"{
    float dx = points[2] - points[0];
    float dy = points[3] - points[1];
    return (float) Math.sqrt(dx * dx + dy * dy) / totalLen;
}","{
    float dx = points[2] - points[0];
    float dy = points[3] - points[1];
    return (float) Math.hypot(dx, dy) / totalLen;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change is from using Math.sqrt(dx * dx + dy * dy) to using Math.hypot(dx, dy), so it's an ""Other statement changed"". While this is a refactoring to use a more precise and clean method for calculating the hypotenuse, it does not change the behavior as far as the API contract is concerned, it is just more accurate and possibly handles edge cases (like overflow) better.","There is no Compatibility Issue as the change from Math.sqrt(dx * dx + dy * dy) to Math.hypot(dx, dy) does not affect the return type or the exception handling. The result of the calculation is intended to be the same, so the end behavior of the API remains consistent."
951,<android.view.View: void setBackgroundDrawable(Drawable)>,22,23,<android.view.View: void setBackgroundDrawable(Drawable)>,<android.view.View: void setBackgroundDrawable(Drawable)>,0,"{
    computeOpaqueFlags();
    if (background == mBackground) {
        return;
    }
    boolean requestLayout = false;
    mBackgroundResource = 0;
    /*
         * Regardless of whether we're setting a new background or not, we want
         * to clear the previous drawable.
         */
    if (mBackground != null) {
        mBackground.setCallback(null);
        unscheduleDrawable(mBackground);
    }
    if (background != null) {
        Rect padding = sThreadLocal.get();
        if (padding == null) {
            padding = new Rect();
            sThreadLocal.set(padding);
        }
        resetResolvedDrawablesInternal();
        background.setLayoutDirection(getLayoutDirection());
        if (background.getPadding(padding)) {
            resetResolvedPaddingInternal();
            switch(background.getLayoutDirection()) {
                case LAYOUT_DIRECTION_RTL:
                    mUserPaddingLeftInitial = padding.right;
                    mUserPaddingRightInitial = padding.left;
                    internalSetPadding(padding.right, padding.top, padding.left, padding.bottom);
                    break;
                case LAYOUT_DIRECTION_LTR:
                default:
                    mUserPaddingLeftInitial = padding.left;
                    mUserPaddingRightInitial = padding.right;
                    internalSetPadding(padding.left, padding.top, padding.right, padding.bottom);
            }
            mLeftPaddingDefined = false;
            mRightPaddingDefined = false;
        }
        // if it has a different minimum size, we should layout again
        if (mBackground == null || mBackground.getMinimumHeight() != background.getMinimumHeight() || mBackground.getMinimumWidth() != background.getMinimumWidth()) {
            requestLayout = true;
        }
        background.setCallback(this);
        if (background.isStateful()) {
            background.setState(getDrawableState());
        }
        background.setVisible(getVisibility() == VISIBLE, false);
        mBackground = background;
        applyBackgroundTint();
        if ((mPrivateFlags & PFLAG_SKIP_DRAW) != 0) {
            mPrivateFlags &= ~PFLAG_SKIP_DRAW;
            mPrivateFlags |= PFLAG_ONLY_DRAWS_BACKGROUND;
            requestLayout = true;
        }
    } else {
        /* Remove the background */
        mBackground = null;
        if ((mPrivateFlags & PFLAG_ONLY_DRAWS_BACKGROUND) != 0) {
            /*
                 * This view ONLY drew the background before and we're removing
                 * the background, so now it won't draw anything
                 * (hence we SKIP_DRAW)
                 */
            mPrivateFlags &= ~PFLAG_ONLY_DRAWS_BACKGROUND;
            mPrivateFlags |= PFLAG_SKIP_DRAW;
        }
        /*
             * When the background is set, we try to apply its padding to this
             * View. When the background is removed, we don't touch this View's
             * padding. This is noted in the Javadocs. Hence, we don't need to
             * requestLayout(), the invalidate() below is sufficient.
             */
        // The old background's minimum size could have affected this
        // View's layout, so let's requestLayout
        requestLayout = true;
    }
    computeOpaqueFlags();
    if (requestLayout) {
        requestLayout();
    }
    mBackgroundSizeChanged = true;
    invalidate(true);
}","{
    computeOpaqueFlags();
    if (background == mBackground) {
        return;
    }
    boolean requestLayout = false;
    mBackgroundResource = 0;
    /*
         * Regardless of whether we're setting a new background or not, we want
         * to clear the previous drawable.
         */
    if (mBackground != null) {
        mBackground.setCallback(null);
        unscheduleDrawable(mBackground);
    }
    if (background != null) {
        Rect padding = sThreadLocal.get();
        if (padding == null) {
            padding = new Rect();
            sThreadLocal.set(padding);
        }
        resetResolvedDrawablesInternal();
        background.setLayoutDirection(getLayoutDirection());
        if (background.getPadding(padding)) {
            resetResolvedPaddingInternal();
            switch(background.getLayoutDirection()) {
                case LAYOUT_DIRECTION_RTL:
                    mUserPaddingLeftInitial = padding.right;
                    mUserPaddingRightInitial = padding.left;
                    internalSetPadding(padding.right, padding.top, padding.left, padding.bottom);
                    break;
                case LAYOUT_DIRECTION_LTR:
                default:
                    mUserPaddingLeftInitial = padding.left;
                    mUserPaddingRightInitial = padding.right;
                    internalSetPadding(padding.left, padding.top, padding.right, padding.bottom);
            }
            mLeftPaddingDefined = false;
            mRightPaddingDefined = false;
        }
        // if it has a different minimum size, we should layout again
        if (mBackground == null || mBackground.getMinimumHeight() != background.getMinimumHeight() || mBackground.getMinimumWidth() != background.getMinimumWidth()) {
            requestLayout = true;
        }
        background.setCallback(this);
        if (background.isStateful()) {
            background.setState(getDrawableState());
        }
        background.setVisible(getVisibility() == VISIBLE, false);
        mBackground = background;
        applyBackgroundTint();
        if ((mPrivateFlags & PFLAG_SKIP_DRAW) != 0) {
            mPrivateFlags &= ~PFLAG_SKIP_DRAW;
            requestLayout = true;
        }
    } else {
        /* Remove the background */
        mBackground = null;
        if ((mViewFlags & WILL_NOT_DRAW) != 0 && (mForegroundInfo == null || mForegroundInfo.mDrawable == null)) {
            mPrivateFlags |= PFLAG_SKIP_DRAW;
        }
        /*
             * When the background is set, we try to apply its padding to this
             * View. When the background is removed, we don't touch this View's
             * padding. This is noted in the Javadocs. Hence, we don't need to
             * requestLayout(), the invalidate() below is sufficient.
             */
        // The old background's minimum size could have affected this
        // View's layout, so let's requestLayout
        requestLayout = true;
    }
    computeOpaqueFlags();
    if (requestLayout) {
        requestLayout();
    }
    mBackgroundSizeChanged = true;
    invalidate(true);
}",1,"/**
 * @deprecated use {@link #setBackground(Drawable)} instead
 */
","/**
 * @deprecated use {@link #setBackground(Drawable)} instead
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,,,,
953,<android.text.format.DateFormat: DateFormat getDateFormat(Context)>,22,23,<android.text.format.DateFormat: DateFormat getDateFormat(Context)>,<android.text.format.DateFormat: DateFormat getDateFormat(Context)>,0,"{
    String value = Settings.System.getString(context.getContentResolver(), Settings.System.DATE_FORMAT);
    return getDateFormatForSetting(context, value);
}","{
    return java.text.DateFormat.getDateInstance(java.text.DateFormat.SHORT);
}",1,"/**
 * Returns a {@link java.text.DateFormat} object that can format the date
 * in short form (such as 12/31/1999) according
 * to the current locale and the user's date-order preference.
 * @param context the application context
 * @return the {@link java.text.DateFormat} object that properly formats the date.
 */
","/**
 * Returns a {@link java.text.DateFormat} object that can format the date
 * in short form according to the current locale.
 *
 * @param context the application context
 * @return the {@link java.text.DateFormat} object that properly formats the date.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The early implementation retrieves the date format string from the system settings and then calls getDateFormatForSetting(context, value) based on that value. The late implementation directly returns a new DateFormat instance using getDateInstance(java.text.DateFormat.SHORT) without retrieving any settings. This constitutes both a Return statement changed and a Dependent API changed, so the code change type is 1,5.","The late implementation no longer depends on system settings which can lead to a different format being returned compared to the early version that did depend on system settings; this is a Compatibility Issue caused by potential different return values, so the CI type is 1."
954,<android.hardware.camera2.marshal.impl.MarshalQueryableParcelable.MarshalerParcelable: int calculateMarshalSize(T)>,22,23,<android.hardware.camera2.marshal.impl.MarshalQueryableParcelable.MarshalerParcelable: int calculateMarshalSize(T)>,<android.hardware.camera2.marshal.impl.MarshalQueryableParcelable.MarshalerParcelable: int calculateMarshalSize(T)>,0,"{
    Parcel parcel = Parcel.obtain();
    try {
        value.writeToParcel(parcel, /*flags*/
        0);
        int length = parcel.marshall().length;
        if (VERBOSE) {
            Log.v(TAG, ""calculateMarshalSize, length when parceling "" + value + "" is "" + length);
        }
        return length;
    } finally {
        parcel.recycle();
    }
}","{
    Parcel parcel = Parcel.obtain();
    try {
        value.writeToParcel(parcel, /*flags*/
        0);
        int length = parcel.marshall().length;
        if (DEBUG) {
            Log.v(TAG, ""calculateMarshalSize, length when parceling "" + value + "" is "" + length);
        }
        return length;
    } finally {
        parcel.recycle();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"There is a change in the log level check condition from VERBOSE to DEBUG. This is a logging level change and does not affect the actual functionality of the method, so the code change type is 4 (Other statement changed).","The functionality of the method, including returned values and exceptions that may be thrown, remains consistent between versions. Therefore, there are no compatibility issues caused by this change, and the CI type is 0 (No Compatibility Issue)."
955,"<android.view.LayoutInflater: View createView(String,String,AttributeSet)>",22,23,"<android.view.LayoutInflater: View createView(String,String,AttributeSet)>","<android.view.LayoutInflater: View createView(String,String,AttributeSet)>",0,"{
    Constructor<? extends View> constructor = sConstructorMap.get(name);
    Class<? extends View> clazz = null;
    try {
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, name);
        if (constructor == null) {
            // Class not found in the cache, see if it's real, and try to add it
            clazz = mContext.getClassLoader().loadClass(prefix != null ? (prefix + name) : name).asSubclass(View.class);
            if (mFilter != null && clazz != null) {
                boolean allowed = mFilter.onLoadClass(clazz);
                if (!allowed) {
                    failNotAllowed(name, prefix, attrs);
                }
            }
            constructor = clazz.getConstructor(mConstructorSignature);
            sConstructorMap.put(name, constructor);
        } else {
            // If we have a filter, apply it to cached constructor
            if (mFilter != null) {
                // Have we seen this name before?
                Boolean allowedState = mFilterMap.get(name);
                if (allowedState == null) {
                    // New class -- remember whether it is allowed
                    clazz = mContext.getClassLoader().loadClass(prefix != null ? (prefix + name) : name).asSubclass(View.class);
                    boolean allowed = clazz != null && mFilter.onLoadClass(clazz);
                    mFilterMap.put(name, allowed);
                    if (!allowed) {
                        failNotAllowed(name, prefix, attrs);
                    }
                } else if (allowedState.equals(Boolean.FALSE)) {
                    failNotAllowed(name, prefix, attrs);
                }
            }
        }
        Object[] args = mConstructorArgs;
        args[1] = attrs;
        constructor.setAccessible(true);
        final View view = constructor.newInstance(args);
        if (view instanceof ViewStub) {
            // Use the same context when inflating ViewStub later.
            final ViewStub viewStub = (ViewStub) view;
            viewStub.setLayoutInflater(cloneInContext((Context) args[0]));
        }
        return view;
    } catch (NoSuchMethodException e) {
        InflateException ie = new InflateException(attrs.getPositionDescription() + "": Error inflating class "" + (prefix != null ? (prefix + name) : name));
        ie.initCause(e);
        throw ie;
    } catch (ClassCastException e) {
        // If loaded class is not a View subclass
        InflateException ie = new InflateException(attrs.getPositionDescription() + "": Class is not a View "" + (prefix != null ? (prefix + name) : name));
        ie.initCause(e);
        throw ie;
    } catch (ClassNotFoundException e) {
        // If loadClass fails, we should propagate the exception.
        throw e;
    } catch (Exception e) {
        InflateException ie = new InflateException(attrs.getPositionDescription() + "": Error inflating class "" + (clazz == null ? ""<unknown>"" : clazz.getName()));
        ie.initCause(e);
        throw ie;
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_VIEW);
    }
}","{
    Constructor<? extends View> constructor = sConstructorMap.get(name);
    Class<? extends View> clazz = null;
    try {
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, name);
        if (constructor == null) {
            // Class not found in the cache, see if it's real, and try to add it
            clazz = mContext.getClassLoader().loadClass(prefix != null ? (prefix + name) : name).asSubclass(View.class);
            if (mFilter != null && clazz != null) {
                boolean allowed = mFilter.onLoadClass(clazz);
                if (!allowed) {
                    failNotAllowed(name, prefix, attrs);
                }
            }
            constructor = clazz.getConstructor(mConstructorSignature);
            constructor.setAccessible(true);
            sConstructorMap.put(name, constructor);
        } else {
            // If we have a filter, apply it to cached constructor
            if (mFilter != null) {
                // Have we seen this name before?
                Boolean allowedState = mFilterMap.get(name);
                if (allowedState == null) {
                    // New class -- remember whether it is allowed
                    clazz = mContext.getClassLoader().loadClass(prefix != null ? (prefix + name) : name).asSubclass(View.class);
                    boolean allowed = clazz != null && mFilter.onLoadClass(clazz);
                    mFilterMap.put(name, allowed);
                    if (!allowed) {
                        failNotAllowed(name, prefix, attrs);
                    }
                } else if (allowedState.equals(Boolean.FALSE)) {
                    failNotAllowed(name, prefix, attrs);
                }
            }
        }
        Object[] args = mConstructorArgs;
        args[1] = attrs;
        final View view = constructor.newInstance(args);
        if (view instanceof ViewStub) {
            // Use the same context when inflating ViewStub later.
            final ViewStub viewStub = (ViewStub) view;
            viewStub.setLayoutInflater(cloneInContext((Context) args[0]));
        }
        return view;
    } catch (NoSuchMethodException e) {
        InflateException ie = new InflateException(attrs.getPositionDescription() + "": Error inflating class "" + (prefix != null ? (prefix + name) : name));
        ie.initCause(e);
        throw ie;
    } catch (ClassCastException e) {
        // If loaded class is not a View subclass
        InflateException ie = new InflateException(attrs.getPositionDescription() + "": Class is not a View "" + (prefix != null ? (prefix + name) : name));
        ie.initCause(e);
        throw ie;
    } catch (ClassNotFoundException e) {
        // If loadClass fails, we should propagate the exception.
        throw e;
    } catch (Exception e) {
        InflateException ie = new InflateException(attrs.getPositionDescription() + "": Error inflating class "" + (clazz == null ? ""<unknown>"" : clazz.getName()));
        ie.initCause(e);
        throw ie;
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_VIEW);
    }
}",1,"/**
 * Low-level function for instantiating a view by name. This attempts to
 * instantiate a view class of the given <var>name</var> found in this
 * LayoutInflater's ClassLoader.
 *
 * <p>
 * There are two things that can happen in an error case: either the
 * exception describing the error will be thrown, or a null will be
 * returned. You must deal with both possibilities -- the former will happen
 * the first time createView() is called for a class of a particular name,
 * the latter every time there-after for that class name.
 *
 * @param name The full name of the class to be instantiated.
 * @param attrs The XML attributes supplied for this instance.
 *
 * @return View The newly instantiated view, or null.
 */
","/**
 * Low-level function for instantiating a view by name. This attempts to
 * instantiate a view class of the given <var>name</var> found in this
 * LayoutInflater's ClassLoader.
 *
 * <p>
 * There are two things that can happen in an error case: either the
 * exception describing the error will be thrown, or a null will be
 * returned. You must deal with both possibilities -- the former will happen
 * the first time createView() is called for a class of a particular name,
 * the latter every time there-after for that class name.
 *
 * @param name The full name of the class to be instantiated.
 * @param attrs The XML attributes supplied for this instance.
 *
 * @return View The newly instantiated view, or null.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
956,"<android.app.ContextImpl: void sendBroadcast(Intent,String,int)>",22,23,"<android.app.ContextImpl: void sendBroadcast(Intent,String,int)>","<android.app.ContextImpl: void sendBroadcast(Intent,String,int)>",0,"{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess();
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermission, appOp, false, false, getUserId());
    } catch (RemoteException e) {
    }
}","{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess();
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, appOp, null, false, false, getUserId());
    } catch (RemoteException e) {
        throw new RuntimeException(""Failure from system"", e);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4","1,2","There is a change in the normal statement where the ""receiverPermission"" string is converted into a string array ""receiverPermissions"". Additionally, a new exception handling has been introduced by throwing a new RuntimeException in the late version. Therefore, the change types are 1,4.","The change to the ""receiverPermissions"" variable being passed to broadcastIntent() could lead to a different behaviour, potentially returning a different result due to changes in what is broadcasted and to whom is a CI type 1. Moreover, the new exception handling statement changes the API's potential behaviour because it now throws a RuntimeException where previously it did nothing on a RemoteException which is a CI type 2."
957,<android.view.inputmethod.InputMethodManager.H: void handleMessage(Message)>,22,23,<android.view.inputmethod.InputMethodManager.H: void handleMessage(Message)>,<android.view.inputmethod.InputMethodManager.H: void handleMessage(Message)>,0,"{
    switch(msg.what) {
        case MSG_DUMP:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                try {
                    doDump((FileDescriptor) args.arg1, (PrintWriter) args.arg2, (String[]) args.arg3);
                } catch (RuntimeException e) {
                    ((PrintWriter) args.arg2).println(""Exception: "" + e);
                }
                synchronized (args.arg4) {
                    ((CountDownLatch) args.arg4).countDown();
                }
                args.recycle();
                return;
            }
        case MSG_BIND:
            {
                final InputBindResult res = (InputBindResult) msg.obj;
                if (DEBUG) {
                    Log.i(TAG, ""handleMessage: MSG_BIND "" + res.sequence + "","" + res.id);
                }
                synchronized (mH) {
                    if (mBindSequence < 0 || mBindSequence != res.sequence) {
                        Log.w(TAG, ""Ignoring onBind: cur seq="" + mBindSequence + "", given seq="" + res.sequence);
                        if (res.channel != null && res.channel != mCurChannel) {
                            res.channel.dispose();
                        }
                        return;
                    }
                    mRequestUpdateCursorAnchorInfoMonitorMode = REQUEST_UPDATE_CURSOR_ANCHOR_INFO_NONE;
                    setInputChannelLocked(res.channel);
                    mCurMethod = res.method;
                    mCurId = res.id;
                    mBindSequence = res.sequence;
                }
                startInputInner(null, 0, 0, 0);
                return;
            }
        case MSG_UNBIND:
            {
                final int sequence = msg.arg1;
                if (DEBUG) {
                    Log.i(TAG, ""handleMessage: MSG_UNBIND "" + sequence);
                }
                boolean startInput = false;
                synchronized (mH) {
                    if (mBindSequence == sequence) {
                        if (false) {
                            // XXX the server has already unbound!
                            if (mCurMethod != null && mCurrentTextBoxAttribute != null) {
                                try {
                                    mCurMethod.finishInput();
                                } catch (RemoteException e) {
                                    Log.w(TAG, ""IME died: "" + mCurId, e);
                                }
                            }
                        }
                        clearBindingLocked();
                        // we would like to re-connect to the next input method.
                        if (mServedView != null && mServedView.isFocused()) {
                            mServedConnecting = true;
                        }
                        if (mActive) {
                            startInput = true;
                        }
                    }
                }
                if (startInput) {
                    startInputInner(null, 0, 0, 0);
                }
                return;
            }
        case MSG_SET_ACTIVE:
            {
                final boolean active = msg.arg1 != 0;
                if (DEBUG) {
                    Log.i(TAG, ""handleMessage: MSG_SET_ACTIVE "" + active + "", was "" + mActive);
                }
                synchronized (mH) {
                    mActive = active;
                    mFullscreenMode = false;
                    if (!active) {
                        // Some other client has starting using the IME, so note
                        // that this happened and make sure our own editor's
                        // state is reset.
                        mHasBeenInactive = true;
                        try {
                            // Note that finishComposingText() is allowed to run
                            // even when we are not active.
                            mIInputContext.finishComposingText();
                        } catch (RemoteException e) {
                        }
                        // handling this message.
                        if (mServedView != null && mServedView.hasWindowFocus()) {
                            // mServedInputConnection.finishComposingText.
                            if (checkFocusNoStartInput(mHasBeenInactive, false)) {
                                startInputInner(null, 0, 0, 0);
                            }
                        }
                    }
                }
                return;
            }
        case MSG_SEND_INPUT_EVENT:
            {
                sendInputEventAndReportResultOnMainLooper((PendingEvent) msg.obj);
                return;
            }
        case MSG_TIMEOUT_INPUT_EVENT:
            {
                finishedInputEvent(msg.arg1, false, true);
                return;
            }
        case MSG_FLUSH_INPUT_EVENT:
            {
                finishedInputEvent(msg.arg1, false, false);
                return;
            }
        case MSG_SET_USER_ACTION_NOTIFICATION_SEQUENCE_NUMBER:
            {
                synchronized (mH) {
                    mNextUserActionNotificationSequenceNumber = msg.arg1;
                }
            }
    }
}","{
    switch(msg.what) {
        case MSG_DUMP:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                try {
                    doDump((FileDescriptor) args.arg1, (PrintWriter) args.arg2, (String[]) args.arg3);
                } catch (RuntimeException e) {
                    ((PrintWriter) args.arg2).println(""Exception: "" + e);
                }
                synchronized (args.arg4) {
                    ((CountDownLatch) args.arg4).countDown();
                }
                args.recycle();
                return;
            }
        case MSG_BIND:
            {
                final InputBindResult res = (InputBindResult) msg.obj;
                if (DEBUG) {
                    Log.i(TAG, ""handleMessage: MSG_BIND "" + res.sequence + "","" + res.id);
                }
                synchronized (mH) {
                    if (mBindSequence < 0 || mBindSequence != res.sequence) {
                        Log.w(TAG, ""Ignoring onBind: cur seq="" + mBindSequence + "", given seq="" + res.sequence);
                        if (res.channel != null && res.channel != mCurChannel) {
                            res.channel.dispose();
                        }
                        return;
                    }
                    mRequestUpdateCursorAnchorInfoMonitorMode = REQUEST_UPDATE_CURSOR_ANCHOR_INFO_NONE;
                    setInputChannelLocked(res.channel);
                    mCurMethod = res.method;
                    mCurId = res.id;
                    mBindSequence = res.sequence;
                }
                startInputInner(null, 0, 0, 0);
                return;
            }
        case MSG_UNBIND:
            {
                final int sequence = msg.arg1;
                if (DEBUG) {
                    Log.i(TAG, ""handleMessage: MSG_UNBIND "" + sequence);
                }
                boolean startInput = false;
                synchronized (mH) {
                    if (mBindSequence == sequence) {
                        if (false) {
                            // XXX the server has already unbound!
                            if (mCurMethod != null && mCurrentTextBoxAttribute != null) {
                                try {
                                    mCurMethod.finishInput();
                                } catch (RemoteException e) {
                                    Log.w(TAG, ""IME died: "" + mCurId, e);
                                }
                            }
                        }
                        clearBindingLocked();
                        // we would like to re-connect to the next input method.
                        if (mServedView != null && mServedView.isFocused()) {
                            mServedConnecting = true;
                        }
                        if (mActive) {
                            startInput = true;
                        }
                    }
                }
                if (startInput) {
                    startInputInner(null, 0, 0, 0);
                }
                return;
            }
        case MSG_SET_ACTIVE:
            {
                final boolean active = msg.arg1 != 0;
                if (DEBUG) {
                    Log.i(TAG, ""handleMessage: MSG_SET_ACTIVE "" + active + "", was "" + mActive);
                }
                synchronized (mH) {
                    mActive = active;
                    mFullscreenMode = false;
                    if (!active) {
                        // Some other client has starting using the IME, so note
                        // that this happened and make sure our own editor's
                        // state is reset.
                        mHasBeenInactive = true;
                        try {
                            // Note that finishComposingText() is allowed to run
                            // even when we are not active.
                            mIInputContext.finishComposingText();
                        } catch (RemoteException e) {
                        }
                    }
                    // handling this message.
                    if (mServedView != null && mServedView.hasWindowFocus()) {
                        // mServedInputConnection.finishComposingText.
                        if (checkFocusNoStartInput(mHasBeenInactive, false)) {
                            startInputInner(null, 0, 0, 0);
                        }
                    }
                }
                return;
            }
        case MSG_SEND_INPUT_EVENT:
            {
                sendInputEventAndReportResultOnMainLooper((PendingEvent) msg.obj);
                return;
            }
        case MSG_TIMEOUT_INPUT_EVENT:
            {
                finishedInputEvent(msg.arg1, false, true);
                return;
            }
        case MSG_FLUSH_INPUT_EVENT:
            {
                finishedInputEvent(msg.arg1, false, false);
                return;
            }
        case MSG_SET_USER_ACTION_NOTIFICATION_SEQUENCE_NUMBER:
            {
                synchronized (mH) {
                    mNextUserActionNotificationSequenceNumber = msg.arg1;
                }
            }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
958,"<android.app.admin.DevicePolicyManager: void setPasswordQuality(ComponentName,int)>",22,23,"<android.app.admin.DevicePolicyManager: void setPasswordQuality(ComponentName,int)>","<android.app.admin.DevicePolicyManager: void setPasswordQuality(ComponentName,int)>",0,"{
    if (mService != null) {
        try {
            mService.setPasswordQuality(admin, quality, UserHandle.myUserId());
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    if (mService != null) {
        try {
            mService.setPasswordQuality(admin, quality);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}",1,"/**
 * Called by an application that is administering the device to set the
 * password restrictions it is imposing.  After setting this, the user
 * will not be able to enter a new password that is not at least as
 * restrictive as what has been set.  Note that the current password
 * will remain until the user has set a new one, so the change does not
 * take place immediately.  To prompt the user for a new password, use
 * {@link #ACTION_SET_NEW_PASSWORD} after setting this value.
 *
 * <p>Quality constants are ordered so that higher values are more restrictive;
 * thus the highest requested quality constant (between the policy set here,
 * the user's preference, and any other considerations) is the one that
 * is in effect.
 *
 * <p>The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call
 * this method; if it has not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param quality The new desired quality.  One of
 * {@link #PASSWORD_QUALITY_UNSPECIFIED}, {@link #PASSWORD_QUALITY_SOMETHING},
 * {@link #PASSWORD_QUALITY_NUMERIC}, {@link #PASSWORD_QUALITY_NUMERIC_COMPLEX},
 * {@link #PASSWORD_QUALITY_ALPHABETIC}, {@link #PASSWORD_QUALITY_ALPHANUMERIC}
 * or {@link #PASSWORD_QUALITY_COMPLEX}.
 */
","/**
 * Called by an application that is administering the device to set the
 * password restrictions it is imposing.  After setting this, the user
 * will not be able to enter a new password that is not at least as
 * restrictive as what has been set.  Note that the current password
 * will remain until the user has set a new one, so the change does not
 * take place immediately.  To prompt the user for a new password, use
 * {@link #ACTION_SET_NEW_PASSWORD} after setting this value.
 *
 * <p>Quality constants are ordered so that higher values are more restrictive;
 * thus the highest requested quality constant (between the policy set here,
 * the user's preference, and any other considerations) is the one that
 * is in effect.
 *
 * <p>The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call
 * this method; if it has not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param quality The new desired quality.  One of
 * {@link #PASSWORD_QUALITY_UNSPECIFIED}, {@link #PASSWORD_QUALITY_SOMETHING},
 * {@link #PASSWORD_QUALITY_NUMERIC}, {@link #PASSWORD_QUALITY_NUMERIC_COMPLEX},
 * {@link #PASSWORD_QUALITY_ALPHABETIC}, {@link #PASSWORD_QUALITY_ALPHANUMERIC}
 * or {@link #PASSWORD_QUALITY_COMPLEX}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method call within the try block has changed between versions, removing the UserHandle.myUserId() parameter from the setPasswordQuality method call, so the change type is 5.","This change should not cause a compatibility issue, because the API's behavior from the caller's perspective remains the same, as it neither alters return values nor exception handling. The API's implementation change is internal to how it interacts with the mService, and the removal of the UserHandle.myUserId() parameter is likely handled within the updated setPasswordQuality method itself. Thus, the CI type is 0."
959,"<android.app.LoaderManagerImpl.LoaderInfo: void callOnLoadFinished(Loader<Object>,Object)>",22,23,"<android.app.LoaderManagerImpl.LoaderInfo: void callOnLoadFinished(Loader<Object>,Object)>","<android.app.LoaderManagerImpl.LoaderInfo: void callOnLoadFinished(Loader<Object>,Object)>",0,"{
    if (mCallbacks != null) {
        String lastBecause = null;
        if (mActivity != null) {
            lastBecause = mActivity.mFragments.mNoTransactionsBecause;
            mActivity.mFragments.mNoTransactionsBecause = ""onLoadFinished"";
        }
        try {
            if (DEBUG)
                Log.v(TAG, ""  onLoadFinished in "" + loader + "": "" + loader.dataToString(data));
            mCallbacks.onLoadFinished(loader, data);
        } finally {
            if (mActivity != null) {
                mActivity.mFragments.mNoTransactionsBecause = lastBecause;
            }
        }
        mDeliveredData = true;
    }
}","{
    if (mCallbacks != null) {
        String lastBecause = null;
        if (mHost != null) {
            lastBecause = mHost.mFragmentManager.mNoTransactionsBecause;
            mHost.mFragmentManager.mNoTransactionsBecause = ""onLoadFinished"";
        }
        try {
            if (DEBUG)
                Log.v(TAG, ""  onLoadFinished in "" + loader + "": "" + loader.dataToString(data));
            mCallbacks.onLoadFinished(loader, data);
        } finally {
            if (mHost != null) {
                mHost.mFragmentManager.mNoTransactionsBecause = lastBecause;
            }
        }
        mDeliveredData = true;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The change is about the variable used to temporarily store the 'mNoTransactionsBecause' state; it switches from 'mActivity.mFragments' to 'mHost.mFragmentManager'. The control flow and functionality of the method seem to remain the same. However, this means the dependent API that is used to get the 'mNoTransactionsBecause' has changed, which indicates a change type of 4,5.","Although there is a change in the dependent API, there doesn't seem to be a change that could lead to a different return value or throw a different exception, because the control flow and the ultimate actions performed remain the same. As a result, there is no compatibility issue, so the CI type is 0."
960,"<android.hardware.camera2.impl.CameraDeviceImpl: void createCaptureSession(List<Surface>,StateCallback,Handler)>",22,23,"<android.hardware.camera2.impl.CameraDeviceImpl: void createCaptureSession(List<Surface>,StateCallback,Handler)>","<android.hardware.camera2.impl.CameraDeviceImpl: void createCaptureSession(List<Surface>,StateCallback,Handler)>",0,"{
    synchronized (mInterfaceLock) {
        if (DEBUG) {
            Log.d(TAG, ""createCaptureSession"");
        }
        checkIfCameraClosedOrInError();
        // After this call completes, the session is not allowed to call into CameraDeviceImpl
        if (mCurrentSession != null) {
            mCurrentSession.replaceSessionClose();
        }
        // TODO: dont block for this
        boolean configureSuccess = true;
        CameraAccessException pendingException = null;
        try {
            // and then block until IDLE
            configureSuccess = configureOutputsChecked(outputs);
        } catch (CameraAccessException e) {
            configureSuccess = false;
            pendingException = e;
            if (DEBUG) {
                Log.v(TAG, ""createCaptureSession - failed with exception "", e);
            }
        }
        // Fire onConfigured if configureOutputs succeeded, fire onConfigureFailed otherwise.
        CameraCaptureSessionImpl newSession = new CameraCaptureSessionImpl(mNextSessionId++, outputs, callback, handler, this, mDeviceHandler, configureSuccess);
        // TODO: wait until current session closes, then create the new session
        mCurrentSession = newSession;
        if (pendingException != null) {
            throw pendingException;
        }
        mSessionStateCallback = mCurrentSession.getDeviceStateCallback();
    }
}","{
    List<OutputConfiguration> outConfigurations = new ArrayList<>(outputs.size());
    for (Surface surface : outputs) {
        outConfigurations.add(new OutputConfiguration(surface));
    }
    createCaptureSessionInternal(null, outConfigurations, callback, handler, /*isConstrainedHighSpeed*/
    false);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The entire method implementation changed from a verbose procedure to a simpler invocation of createCaptureSessionInternal. This modification includes a deletion of a return statement and changes in other lines. Since the creation of the OutputConfiguration list and the call to a different method (createCaptureSessionInternal) could potentially result in a different behavior, the API's return type or values may change (even though the signature return type is 'void', internal flow and returned exceptions can be different due to this change), the code change type is 1,4.","The changes significantly alter the method's control flow and can potentially affect the exceptions thrown and the overall behavior (even though the behavior might manifest through other methods' behavior and callbacks rather than direct returns), therefore, the CI type is 1."
961,<android.content.ContentResolver: ContentProviderClient acquireContentProviderClient(Uri)>,22,23,<android.content.ContentResolver: ContentProviderClient acquireContentProviderClient(Uri)>,<android.content.ContentResolver: ContentProviderClient acquireContentProviderClient(Uri)>,0,"{
    IContentProvider provider = acquireProvider(uri);
    if (provider != null) {
        return new ContentProviderClient(this, provider, true);
    }
    return null;
}","{
    Preconditions.checkNotNull(uri, ""uri"");
    IContentProvider provider = acquireProvider(uri);
    if (provider != null) {
        return new ContentProviderClient(this, provider, true);
    }
    return null;
}",1,"/**
 * Returns a {@link ContentProviderClient} that is associated with the {@link ContentProvider}
 * that services the content at uri, starting the provider if necessary. Returns
 * null if there is no provider associated wih the uri. The caller must indicate that they are
 * done with the provider by calling {@link ContentProviderClient#release} which will allow
 * the system to release the provider it it determines that there is no other reason for
 * keeping it active.
 * @param uri specifies which provider should be acquired
 * @return a {@link ContentProviderClient} that is associated with the {@link ContentProvider}
 * that services the content at uri or null if there isn't one.
 */
","/**
 * Returns a {@link ContentProviderClient} that is associated with the {@link ContentProvider}
 * that services the content at uri, starting the provider if necessary. Returns
 * null if there is no provider associated wih the uri. The caller must indicate that they are
 * done with the provider by calling {@link ContentProviderClient#release} which will allow
 * the system to release the provider it it determines that there is no other reason for
 * keeping it active.
 * @param uri specifies which provider should be acquired
 * @return a {@link ContentProviderClient} that is associated with the {@link ContentProvider}
 * that services the content at uri or null if there isn't one.
 */
",-1,,[@Nullable],-1,-1,-1,-1,-1,-1,4,0,"The late version adds a precondition check (Preconditions.checkNotNull(uri, ""uri"")) to ensure that the 'uri' argument is not null, which is a change of type 4.","While the added precondition check could potentially throw a NullPointerException if a null 'uri' is passed, it aligns with the expected behavior of the method to ensure a non-null argument and thus no compatibility issue arises from this change. The method's behavior remains the same when a non-null 'uri' is passed in both versions, hence CI is 0."
962,<android.app.DownloadManager: Uri getUriForDownloadedFile(long)>,22,23,<android.app.DownloadManager: Uri getUriForDownloadedFile(long)>,<android.app.DownloadManager: Uri getUriForDownloadedFile(long)>,0,"{
    // to check if the file is in cache, get its destination from the database
    Query query = new Query().setFilterById(id);
    Cursor cursor = null;
    try {
        cursor = query(query);
        if (cursor == null) {
            return null;
        }
        if (cursor.moveToFirst()) {
            int status = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_STATUS));
            if (DownloadManager.STATUS_SUCCESSFUL == status) {
                int indx = cursor.getColumnIndexOrThrow(Downloads.Impl.COLUMN_DESTINATION);
                int destination = cursor.getInt(indx);
                // should also check for that destination.
                if (destination == Downloads.Impl.DESTINATION_CACHE_PARTITION || destination == Downloads.Impl.DESTINATION_SYSTEMCACHE_PARTITION || destination == Downloads.Impl.DESTINATION_CACHE_PARTITION_NOROAMING || destination == Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE) {
                    // return private uri
                    return ContentUris.withAppendedId(Downloads.Impl.CONTENT_URI, id);
                } else {
                    // return public uri
                    String path = cursor.getString(cursor.getColumnIndexOrThrow(COLUMN_LOCAL_FILENAME));
                    return Uri.fromFile(new File(path));
                }
            }
        }
    } finally {
        if (cursor != null) {
            cursor.close();
        }
    }
    // downloaded file not found or its status is not 'successfully completed'
    return null;
}","{
    // to check if the file is in cache, get its destination from the database
    Query query = new Query().setFilterById(id);
    Cursor cursor = null;
    try {
        cursor = query(query);
        if (cursor == null) {
            return null;
        }
        if (cursor.moveToFirst()) {
            int status = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_STATUS));
            if (DownloadManager.STATUS_SUCCESSFUL == status) {
                return ContentUris.withAppendedId(Downloads.Impl.CONTENT_URI, id);
            }
        }
    } finally {
        if (cursor != null) {
            cursor.close();
        }
    }
    // downloaded file not found or its status is not 'successfully completed'
    return null;
}",1,"/**
 * Returns the {@link Uri} of the given downloaded file id, if the file is
 * downloaded successfully. Otherwise, null is returned.
 * <p>
 * If the specified downloaded file is in external storage (for example, /sdcard dir),
 * then it is assumed to be safe for anyone to read and the returned {@link Uri} corresponds
 * to the filepath on sdcard.
 *
 * @param id the id of the downloaded file.
 * @return the {@link Uri} of the given downloaded file id, if download was successful. null
 * otherwise.
 */
","/**
 * Returns the {@link Uri} of the given downloaded file id, if the file is
 * downloaded successfully. Otherwise, null is returned.
 *
 * @param id the id of the downloaded file.
 * @return the {@link Uri} of the given downloaded file id, if download was
 * successful. null otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The condition checking the destination of the downloaded file and creating a public URI from the file path have been removed. This has led to a change in the control dependency as well as the return statement, which now always returns a Content URI if the status is successful, regardless of the destination. Therefore, the code change types are 1,3.","Since the control flow has been simplified to no longer account for the destination of the download and always returns a Content URI, this constitutes a change that can lead to a different return value in the late version. This is a potential CI as clients that rely on a public URI will now receive a Content URI instead. The CI type is 1."
963,<android.app.AlertDialog.Builder: AlertDialog show()>,22,23,<android.app.AlertDialog.Builder: AlertDialog show()>,<android.app.AlertDialog.Builder: AlertDialog show()>,0,"{
    AlertDialog dialog = create();
    dialog.show();
    return dialog;
}","{
    final AlertDialog dialog = create();
    dialog.show();
    return dialog;
}",1,"/**
 * Creates a {@link AlertDialog} with the arguments supplied to this builder and
 * {@link Dialog#show()}'s the dialog.
 */
","/**
 * Creates an {@link AlertDialog} with the arguments supplied to this
 * builder and immediately displays the dialog.
 * <p>
 * Calling this method is functionally identical to:
 * <pre>
 * AlertDialog dialog = builder.create();
 * dialog.show();
 * </pre>
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"The only change between the early and late versions is the addition of the 'final' keyword to the local variable 'dialog', which does not affect the behavior of the method. Thus, there is no change in terms of behavior or returned value.","Since the 'final' keyword only restricts the reassignment of the 'dialog' variable and doesn't affect the method's behavior or output, there is no compatibility issue between the two versions."
965,<android.printservice.PrintService.ServiceHandler: void handleMessage(Message)>,22,23,<android.printservice.PrintService.ServiceHandler: void handleMessage(Message)>,<android.printservice.PrintService.ServiceHandler: void handleMessage(Message)>,0,"{
    final int action = message.what;
    switch(action) {
        case MSG_CREATE_PRINTER_DISCOVERY_SESSION:
            {
                if (DEBUG) {
                    Log.i(LOG_TAG, ""MSG_CREATE_PRINTER_DISCOVERY_SESSION "" + getPackageName());
                }
                PrinterDiscoverySession session = onCreatePrinterDiscoverySession();
                if (session == null) {
                    throw new NullPointerException(""session cannot be null"");
                }
                if (session.getId() == mLastSessionId) {
                    throw new IllegalStateException(""cannot reuse session instances"");
                }
                mDiscoverySession = session;
                mLastSessionId = session.getId();
                session.setObserver(mClient);
            }
            break;
        case MSG_DESTROY_PRINTER_DISCOVERY_SESSION:
            {
                if (DEBUG) {
                    Log.i(LOG_TAG, ""MSG_DESTROY_PRINTER_DISCOVERY_SESSION "" + getPackageName());
                }
                if (mDiscoverySession != null) {
                    mDiscoverySession.destroy();
                    mDiscoverySession = null;
                }
            }
            break;
        case MSG_START_PRINTER_DISCOVERY:
            {
                if (DEBUG) {
                    Log.i(LOG_TAG, ""MSG_START_PRINTER_DISCOVERY "" + getPackageName());
                }
                if (mDiscoverySession != null) {
                    List<PrinterId> priorityList = (ArrayList<PrinterId>) message.obj;
                    mDiscoverySession.startPrinterDiscovery(priorityList);
                }
            }
            break;
        case MSG_STOP_PRINTER_DISCOVERY:
            {
                if (DEBUG) {
                    Log.i(LOG_TAG, ""MSG_STOP_PRINTER_DISCOVERY "" + getPackageName());
                }
                if (mDiscoverySession != null) {
                    mDiscoverySession.stopPrinterDiscovery();
                }
            }
            break;
        case MSG_VALIDATE_PRINTERS:
            {
                if (DEBUG) {
                    Log.i(LOG_TAG, ""MSG_VALIDATE_PRINTERS "" + getPackageName());
                }
                if (mDiscoverySession != null) {
                    List<PrinterId> printerIds = (List<PrinterId>) message.obj;
                    mDiscoverySession.validatePrinters(printerIds);
                }
            }
            break;
        case MSG_START_PRINTER_STATE_TRACKING:
            {
                if (DEBUG) {
                    Log.i(LOG_TAG, ""MSG_START_PRINTER_STATE_TRACKING "" + getPackageName());
                }
                if (mDiscoverySession != null) {
                    PrinterId printerId = (PrinterId) message.obj;
                    mDiscoverySession.startPrinterStateTracking(printerId);
                }
            }
            break;
        case MSG_STOP_PRINTER_STATE_TRACKING:
            {
                if (DEBUG) {
                    Log.i(LOG_TAG, ""MSG_STOP_PRINTER_STATE_TRACKING "" + getPackageName());
                }
                if (mDiscoverySession != null) {
                    PrinterId printerId = (PrinterId) message.obj;
                    mDiscoverySession.stopPrinterStateTracking(printerId);
                }
            }
            break;
        case MSG_ON_REQUEST_CANCEL_PRINTJOB:
            {
                if (DEBUG) {
                    Log.i(LOG_TAG, ""MSG_ON_REQUEST_CANCEL_PRINTJOB "" + getPackageName());
                }
                PrintJobInfo printJobInfo = (PrintJobInfo) message.obj;
                onRequestCancelPrintJob(new PrintJob(printJobInfo, mClient));
            }
            break;
        case MSG_ON_PRINTJOB_QUEUED:
            {
                if (DEBUG) {
                    Log.i(LOG_TAG, ""MSG_ON_PRINTJOB_QUEUED "" + getPackageName());
                }
                PrintJobInfo printJobInfo = (PrintJobInfo) message.obj;
                if (DEBUG) {
                    Log.i(LOG_TAG, ""Queued: "" + printJobInfo);
                }
                onPrintJobQueued(new PrintJob(printJobInfo, mClient));
            }
            break;
        case MSG_SET_CLEINT:
            {
                if (DEBUG) {
                    Log.i(LOG_TAG, ""MSG_SET_CLEINT "" + getPackageName());
                }
                mClient = (IPrintServiceClient) message.obj;
                if (mClient != null) {
                    onConnected();
                } else {
                    onDisconnected();
                }
            }
            break;
        default:
            {
                throw new IllegalArgumentException(""Unknown message: "" + action);
            }
    }
}","{
    final int action = message.what;
    switch(action) {
        case MSG_CREATE_PRINTER_DISCOVERY_SESSION:
            {
                if (DEBUG) {
                    Log.i(LOG_TAG, ""MSG_CREATE_PRINTER_DISCOVERY_SESSION "" + getPackageName());
                }
                PrinterDiscoverySession session = onCreatePrinterDiscoverySession();
                if (session == null) {
                    throw new NullPointerException(""session cannot be null"");
                }
                if (session.getId() == mLastSessionId) {
                    throw new IllegalStateException(""cannot reuse session instances"");
                }
                mDiscoverySession = session;
                mLastSessionId = session.getId();
                session.setObserver(mClient);
            }
            break;
        case MSG_DESTROY_PRINTER_DISCOVERY_SESSION:
            {
                if (DEBUG) {
                    Log.i(LOG_TAG, ""MSG_DESTROY_PRINTER_DISCOVERY_SESSION "" + getPackageName());
                }
                if (mDiscoverySession != null) {
                    mDiscoverySession.destroy();
                    mDiscoverySession = null;
                }
            }
            break;
        case MSG_START_PRINTER_DISCOVERY:
            {
                if (DEBUG) {
                    Log.i(LOG_TAG, ""MSG_START_PRINTER_DISCOVERY "" + getPackageName());
                }
                if (mDiscoverySession != null) {
                    List<PrinterId> priorityList = (ArrayList<PrinterId>) message.obj;
                    mDiscoverySession.startPrinterDiscovery(priorityList);
                }
            }
            break;
        case MSG_STOP_PRINTER_DISCOVERY:
            {
                if (DEBUG) {
                    Log.i(LOG_TAG, ""MSG_STOP_PRINTER_DISCOVERY "" + getPackageName());
                }
                if (mDiscoverySession != null) {
                    mDiscoverySession.stopPrinterDiscovery();
                }
            }
            break;
        case MSG_VALIDATE_PRINTERS:
            {
                if (DEBUG) {
                    Log.i(LOG_TAG, ""MSG_VALIDATE_PRINTERS "" + getPackageName());
                }
                if (mDiscoverySession != null) {
                    List<PrinterId> printerIds = (List<PrinterId>) message.obj;
                    mDiscoverySession.validatePrinters(printerIds);
                }
            }
            break;
        case MSG_START_PRINTER_STATE_TRACKING:
            {
                if (DEBUG) {
                    Log.i(LOG_TAG, ""MSG_START_PRINTER_STATE_TRACKING "" + getPackageName());
                }
                if (mDiscoverySession != null) {
                    PrinterId printerId = (PrinterId) message.obj;
                    mDiscoverySession.startPrinterStateTracking(printerId);
                }
            }
            break;
        case MSG_STOP_PRINTER_STATE_TRACKING:
            {
                if (DEBUG) {
                    Log.i(LOG_TAG, ""MSG_STOP_PRINTER_STATE_TRACKING "" + getPackageName());
                }
                if (mDiscoverySession != null) {
                    PrinterId printerId = (PrinterId) message.obj;
                    mDiscoverySession.stopPrinterStateTracking(printerId);
                }
            }
            break;
        case MSG_ON_REQUEST_CANCEL_PRINTJOB:
            {
                if (DEBUG) {
                    Log.i(LOG_TAG, ""MSG_ON_REQUEST_CANCEL_PRINTJOB "" + getPackageName());
                }
                PrintJobInfo printJobInfo = (PrintJobInfo) message.obj;
                onRequestCancelPrintJob(new PrintJob(printJobInfo, mClient));
            }
            break;
        case MSG_ON_PRINTJOB_QUEUED:
            {
                if (DEBUG) {
                    Log.i(LOG_TAG, ""MSG_ON_PRINTJOB_QUEUED "" + getPackageName());
                }
                PrintJobInfo printJobInfo = (PrintJobInfo) message.obj;
                if (DEBUG) {
                    Log.i(LOG_TAG, ""Queued: "" + printJobInfo);
                }
                onPrintJobQueued(new PrintJob(printJobInfo, mClient));
            }
            break;
        case MSG_SET_CLIENT:
            {
                if (DEBUG) {
                    Log.i(LOG_TAG, ""MSG_SET_CLIENT "" + getPackageName());
                }
                mClient = (IPrintServiceClient) message.obj;
                if (mClient != null) {
                    onConnected();
                } else {
                    onDisconnected();
                }
            }
            break;
        default:
            {
                throw new IllegalArgumentException(""Unknown message: "" + action);
            }
    }
}",1,,,-1,"[@Override, @SuppressWarnings(""unchecked"")]","[@Override, @SuppressWarnings(""unchecked"")]",-1,-1,-1,-1,-1,-1,,,,
966,"<android.view.View: void setFlags(int,int)>",22,23,"<android.view.View: void setFlags(int,int)>","<android.view.View: void setFlags(int,int)>",0,"{
    final boolean accessibilityEnabled = AccessibilityManager.getInstance(mContext).isEnabled();
    final boolean oldIncludeForAccessibility = accessibilityEnabled && includeForAccessibility();
    int old = mViewFlags;
    mViewFlags = (mViewFlags & ~mask) | (flags & mask);
    int changed = mViewFlags ^ old;
    if (changed == 0) {
        return;
    }
    int privateFlags = mPrivateFlags;
    /* Check if the FOCUSABLE bit has changed */
    if (((changed & FOCUSABLE_MASK) != 0) && ((privateFlags & PFLAG_HAS_BOUNDS) != 0)) {
        if (((old & FOCUSABLE_MASK) == FOCUSABLE) && ((privateFlags & PFLAG_FOCUSED) != 0)) {
            /* Give up focus if we are no longer focusable */
            clearFocus();
        } else if (((old & FOCUSABLE_MASK) == NOT_FOCUSABLE) && ((privateFlags & PFLAG_FOCUSED) == 0)) {
            /*
                 * Tell the view system that we are now available to take focus
                 * if no one else already has it.
                 */
            if (mParent != null)
                mParent.focusableViewAvailable(this);
        }
    }
    final int newVisibility = flags & VISIBILITY_MASK;
    if (newVisibility == VISIBLE) {
        if ((changed & VISIBILITY_MASK) != 0) {
            /*
                 * If this view is becoming visible, invalidate it in case it changed while
                 * it was not visible. Marking it drawn ensures that the invalidation will
                 * go through.
                 */
            mPrivateFlags |= PFLAG_DRAWN;
            invalidate(true);
            needGlobalAttributesUpdate(true);
            // the root view try to give this focus if nothing else does.
            if ((mParent != null) && (mBottom > mTop) && (mRight > mLeft)) {
                mParent.focusableViewAvailable(this);
            }
        }
    }
    /* Check if the GONE bit has changed */
    if ((changed & GONE) != 0) {
        needGlobalAttributesUpdate(false);
        requestLayout();
        if (((mViewFlags & VISIBILITY_MASK) == GONE)) {
            if (hasFocus())
                clearFocus();
            clearAccessibilityFocus();
            destroyDrawingCache();
            if (mParent instanceof View) {
                // GONE views noop invalidation, so invalidate the parent
                ((View) mParent).invalidate(true);
            }
            // Mark the view drawn to ensure that it gets invalidated properly the next
            // time it is visible and gets invalidated
            mPrivateFlags |= PFLAG_DRAWN;
        }
        if (mAttachInfo != null) {
            mAttachInfo.mViewVisibilityChanged = true;
        }
    }
    /* Check if the VISIBLE bit has changed */
    if ((changed & INVISIBLE) != 0) {
        needGlobalAttributesUpdate(false);
        /*
             * If this view is becoming invisible, set the DRAWN flag so that
             * the next invalidate() will not be skipped.
             */
        mPrivateFlags |= PFLAG_DRAWN;
        if (((mViewFlags & VISIBILITY_MASK) == INVISIBLE)) {
            // root view becoming invisible shouldn't clear focus and accessibility focus
            if (getRootView() != this) {
                if (hasFocus())
                    clearFocus();
                clearAccessibilityFocus();
            }
        }
        if (mAttachInfo != null) {
            mAttachInfo.mViewVisibilityChanged = true;
        }
    }
    if ((changed & VISIBILITY_MASK) != 0) {
        // If the view is invisible, cleanup its display list to free up resources
        if (newVisibility != VISIBLE && mAttachInfo != null) {
            cleanupDraw();
        }
        if (mParent instanceof ViewGroup) {
            ((ViewGroup) mParent).onChildVisibilityChanged(this, (changed & VISIBILITY_MASK), newVisibility);
            ((View) mParent).invalidate(true);
        } else if (mParent != null) {
            mParent.invalidateChild(this, null);
        }
        dispatchVisibilityChanged(this, newVisibility);
        notifySubtreeAccessibilityStateChangedIfNeeded();
    }
    if ((changed & WILL_NOT_CACHE_DRAWING) != 0) {
        destroyDrawingCache();
    }
    if ((changed & DRAWING_CACHE_ENABLED) != 0) {
        destroyDrawingCache();
        mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
        invalidateParentCaches();
    }
    if ((changed & DRAWING_CACHE_QUALITY_MASK) != 0) {
        destroyDrawingCache();
        mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
    }
    if ((changed & DRAW_MASK) != 0) {
        if ((mViewFlags & WILL_NOT_DRAW) != 0) {
            if (mBackground != null) {
                mPrivateFlags &= ~PFLAG_SKIP_DRAW;
                mPrivateFlags |= PFLAG_ONLY_DRAWS_BACKGROUND;
            } else {
                mPrivateFlags |= PFLAG_SKIP_DRAW;
            }
        } else {
            mPrivateFlags &= ~PFLAG_SKIP_DRAW;
        }
        requestLayout();
        invalidate(true);
    }
    if ((changed & KEEP_SCREEN_ON) != 0) {
        if (mParent != null && mAttachInfo != null && !mAttachInfo.mRecomputeGlobalAttributes) {
            mParent.recomputeViewAttributes(this);
        }
    }
    if (accessibilityEnabled) {
        if ((changed & FOCUSABLE_MASK) != 0 || (changed & VISIBILITY_MASK) != 0 || (changed & CLICKABLE) != 0 || (changed & LONG_CLICKABLE) != 0) {
            if (oldIncludeForAccessibility != includeForAccessibility()) {
                notifySubtreeAccessibilityStateChangedIfNeeded();
            } else {
                notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_UNDEFINED);
            }
        } else if ((changed & ENABLED_MASK) != 0) {
            notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_UNDEFINED);
        }
    }
}","{
    final boolean accessibilityEnabled = AccessibilityManager.getInstance(mContext).isEnabled();
    final boolean oldIncludeForAccessibility = accessibilityEnabled && includeForAccessibility();
    int old = mViewFlags;
    mViewFlags = (mViewFlags & ~mask) | (flags & mask);
    int changed = mViewFlags ^ old;
    if (changed == 0) {
        return;
    }
    int privateFlags = mPrivateFlags;
    /* Check if the FOCUSABLE bit has changed */
    if (((changed & FOCUSABLE_MASK) != 0) && ((privateFlags & PFLAG_HAS_BOUNDS) != 0)) {
        if (((old & FOCUSABLE_MASK) == FOCUSABLE) && ((privateFlags & PFLAG_FOCUSED) != 0)) {
            /* Give up focus if we are no longer focusable */
            clearFocus();
        } else if (((old & FOCUSABLE_MASK) == NOT_FOCUSABLE) && ((privateFlags & PFLAG_FOCUSED) == 0)) {
            /*
                 * Tell the view system that we are now available to take focus
                 * if no one else already has it.
                 */
            if (mParent != null)
                mParent.focusableViewAvailable(this);
        }
    }
    final int newVisibility = flags & VISIBILITY_MASK;
    if (newVisibility == VISIBLE) {
        if ((changed & VISIBILITY_MASK) != 0) {
            /*
                 * If this view is becoming visible, invalidate it in case it changed while
                 * it was not visible. Marking it drawn ensures that the invalidation will
                 * go through.
                 */
            mPrivateFlags |= PFLAG_DRAWN;
            invalidate(true);
            needGlobalAttributesUpdate(true);
            // the root view try to give this focus if nothing else does.
            if ((mParent != null) && (mBottom > mTop) && (mRight > mLeft)) {
                mParent.focusableViewAvailable(this);
            }
        }
    }
    /* Check if the GONE bit has changed */
    if ((changed & GONE) != 0) {
        needGlobalAttributesUpdate(false);
        requestLayout();
        if (((mViewFlags & VISIBILITY_MASK) == GONE)) {
            if (hasFocus())
                clearFocus();
            clearAccessibilityFocus();
            destroyDrawingCache();
            if (mParent instanceof View) {
                // GONE views noop invalidation, so invalidate the parent
                ((View) mParent).invalidate(true);
            }
            // Mark the view drawn to ensure that it gets invalidated properly the next
            // time it is visible and gets invalidated
            mPrivateFlags |= PFLAG_DRAWN;
        }
        if (mAttachInfo != null) {
            mAttachInfo.mViewVisibilityChanged = true;
        }
    }
    /* Check if the VISIBLE bit has changed */
    if ((changed & INVISIBLE) != 0) {
        needGlobalAttributesUpdate(false);
        /*
             * If this view is becoming invisible, set the DRAWN flag so that
             * the next invalidate() will not be skipped.
             */
        mPrivateFlags |= PFLAG_DRAWN;
        if (((mViewFlags & VISIBILITY_MASK) == INVISIBLE)) {
            // root view becoming invisible shouldn't clear focus and accessibility focus
            if (getRootView() != this) {
                if (hasFocus())
                    clearFocus();
                clearAccessibilityFocus();
            }
        }
        if (mAttachInfo != null) {
            mAttachInfo.mViewVisibilityChanged = true;
        }
    }
    if ((changed & VISIBILITY_MASK) != 0) {
        // If the view is invisible, cleanup its display list to free up resources
        if (newVisibility != VISIBLE && mAttachInfo != null) {
            cleanupDraw();
        }
        if (mParent instanceof ViewGroup) {
            ((ViewGroup) mParent).onChildVisibilityChanged(this, (changed & VISIBILITY_MASK), newVisibility);
            ((View) mParent).invalidate(true);
        } else if (mParent != null) {
            mParent.invalidateChild(this, null);
        }
        if (mAttachInfo != null) {
            dispatchVisibilityChanged(this, newVisibility);
            notifySubtreeAccessibilityStateChangedIfNeeded();
        }
    }
    if ((changed & WILL_NOT_CACHE_DRAWING) != 0) {
        destroyDrawingCache();
    }
    if ((changed & DRAWING_CACHE_ENABLED) != 0) {
        destroyDrawingCache();
        mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
        invalidateParentCaches();
    }
    if ((changed & DRAWING_CACHE_QUALITY_MASK) != 0) {
        destroyDrawingCache();
        mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
    }
    if ((changed & DRAW_MASK) != 0) {
        if ((mViewFlags & WILL_NOT_DRAW) != 0) {
            if (mBackground != null || (mForegroundInfo != null && mForegroundInfo.mDrawable != null)) {
                mPrivateFlags &= ~PFLAG_SKIP_DRAW;
            } else {
                mPrivateFlags |= PFLAG_SKIP_DRAW;
            }
        } else {
            mPrivateFlags &= ~PFLAG_SKIP_DRAW;
        }
        requestLayout();
        invalidate(true);
    }
    if ((changed & KEEP_SCREEN_ON) != 0) {
        if (mParent != null && mAttachInfo != null && !mAttachInfo.mRecomputeGlobalAttributes) {
            mParent.recomputeViewAttributes(this);
        }
    }
    if (accessibilityEnabled) {
        if ((changed & FOCUSABLE_MASK) != 0 || (changed & VISIBILITY_MASK) != 0 || (changed & CLICKABLE) != 0 || (changed & LONG_CLICKABLE) != 0 || (changed & CONTEXT_CLICKABLE) != 0) {
            if (oldIncludeForAccessibility != includeForAccessibility()) {
                notifySubtreeAccessibilityStateChangedIfNeeded();
            } else {
                notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_UNDEFINED);
            }
        } else if ((changed & ENABLED_MASK) != 0) {
            notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_UNDEFINED);
        }
    }
}",1,"/**
 * Set flags controlling behavior of this view.
 *
 * @param flags Constant indicating the value which should be set
 * @param mask Constant indicating the bit range that should be changed
 */
","/**
 * Set flags controlling behavior of this view.
 *
 * @param flags Constant indicating the value which should be set
 * @param mask Constant indicating the bit range that should be changed
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
967,<android.animation.ValueAnimator: ValueAnimator clone()>,22,23,<android.animation.ValueAnimator: ValueAnimator clone()>,<android.animation.ValueAnimator: ValueAnimator clone()>,0,"{
    final ValueAnimator anim = (ValueAnimator) super.clone();
    if (mUpdateListeners != null) {
        anim.mUpdateListeners = new ArrayList<AnimatorUpdateListener>(mUpdateListeners);
    }
    anim.mSeekFraction = -1;
    anim.mPlayingBackwards = false;
    anim.mReversing = false;
    anim.mCurrentIteration = 0;
    anim.mInitialized = false;
    anim.mPlayingState = STOPPED;
    anim.mStartedDelay = false;
    PropertyValuesHolder[] oldValues = mValues;
    if (oldValues != null) {
        int numValues = oldValues.length;
        anim.mValues = new PropertyValuesHolder[numValues];
        anim.mValuesMap = new HashMap<String, PropertyValuesHolder>(numValues);
        for (int i = 0; i < numValues; ++i) {
            PropertyValuesHolder newValuesHolder = oldValues[i].clone();
            anim.mValues[i] = newValuesHolder;
            anim.mValuesMap.put(newValuesHolder.getPropertyName(), newValuesHolder);
        }
    }
    return anim;
}","{
    final ValueAnimator anim = (ValueAnimator) super.clone();
    if (mUpdateListeners != null) {
        anim.mUpdateListeners = new ArrayList<AnimatorUpdateListener>(mUpdateListeners);
    }
    anim.mSeekFraction = -1;
    anim.mPlayingBackwards = false;
    anim.mReversing = false;
    anim.mCurrentIteration = 0;
    anim.mInitialized = false;
    anim.mPlayingState = STOPPED;
    anim.mStartedDelay = false;
    anim.mStarted = false;
    anim.mRunning = false;
    anim.mPaused = false;
    anim.mResumed = false;
    anim.mStartListenersCalled = false;
    anim.mStartTime = 0;
    anim.mStartTimeCommitted = false;
    anim.mPauseTime = 0;
    anim.mCurrentFraction = 0;
    anim.mDelayStartTime = 0;
    PropertyValuesHolder[] oldValues = mValues;
    if (oldValues != null) {
        int numValues = oldValues.length;
        anim.mValues = new PropertyValuesHolder[numValues];
        anim.mValuesMap = new HashMap<String, PropertyValuesHolder>(numValues);
        for (int i = 0; i < numValues; ++i) {
            PropertyValuesHolder newValuesHolder = oldValues[i].clone();
            anim.mValues[i] = newValuesHolder;
            anim.mValuesMap.put(newValuesHolder.getPropertyName(), newValuesHolder);
        }
    }
    return anim;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"There are additional assignments to the cloned object's fields that do not exist in the early version, which falls under ""Other statement changed."" The assignments to `anim.mStarted`, `anim.mRunning`, `anim.mPaused`, `anim.mResumed`, `anim.mStartListenersCalled`, `anim.mStartTime`, `anim.mStartTimeCommitted`, `anim.mPauseTime`, `anim.mCurrentFraction`, and `anim.mDelayStartTime` are newly introduced in the late version.","There is no change to the return value, the structure of control dependencies, or the exception handling mechanism. All the new assignments are to the fields of the cloned object and would be part of the expected state initialization of a newly cloned ValueAnimator instance. These changes ensure that the cloned object has all its state variables properly initialized, but they do not represent a behavioral change in terms of the API's contract. Therefore, there is no compatibility issue."
968,<android.widget.TextView: void onRestoreInstanceState(Parcelable)>,22,23,<android.widget.TextView: void onRestoreInstanceState(Parcelable)>,<android.widget.TextView: void onRestoreInstanceState(Parcelable)>,0,"{
    if (!(state instanceof SavedState)) {
        super.onRestoreInstanceState(state);
        return;
    }
    SavedState ss = (SavedState) state;
    super.onRestoreInstanceState(ss.getSuperState());
    // XXX restore buffer type too, as well as lots of other stuff
    if (ss.text != null) {
        setText(ss.text);
    }
    if (ss.selStart >= 0 && ss.selEnd >= 0) {
        if (mText instanceof Spannable) {
            int len = mText.length();
            if (ss.selStart > len || ss.selEnd > len) {
                String restored = """";
                if (ss.text != null) {
                    restored = ""(restored) "";
                }
                Log.e(LOG_TAG, ""Saved cursor position "" + ss.selStart + ""/"" + ss.selEnd + "" out of range for "" + restored + ""text "" + mText);
            } else {
                Selection.setSelection((Spannable) mText, ss.selStart, ss.selEnd);
                if (ss.frozenWithFocus) {
                    createEditorIfNeeded();
                    mEditor.mFrozenWithFocus = true;
                }
            }
        }
    }
    if (ss.error != null) {
        final CharSequence error = ss.error;
        // Display the error later, after the first layout pass
        post(new Runnable() {

            public void run() {
                setError(error);
            }
        });
    }
}","{
    if (!(state instanceof SavedState)) {
        super.onRestoreInstanceState(state);
        return;
    }
    SavedState ss = (SavedState) state;
    super.onRestoreInstanceState(ss.getSuperState());
    // XXX restore buffer type too, as well as lots of other stuff
    if (ss.text != null) {
        setText(ss.text);
    }
    if (ss.selStart >= 0 && ss.selEnd >= 0) {
        if (mText instanceof Spannable) {
            int len = mText.length();
            if (ss.selStart > len || ss.selEnd > len) {
                String restored = """";
                if (ss.text != null) {
                    restored = ""(restored) "";
                }
                Log.e(LOG_TAG, ""Saved cursor position "" + ss.selStart + ""/"" + ss.selEnd + "" out of range for "" + restored + ""text "" + mText);
            } else {
                Selection.setSelection((Spannable) mText, ss.selStart, ss.selEnd);
                if (ss.frozenWithFocus) {
                    createEditorIfNeeded();
                    mEditor.mFrozenWithFocus = true;
                }
            }
        }
    }
    if (ss.error != null) {
        final CharSequence error = ss.error;
        // Display the error later, after the first layout pass
        post(new Runnable() {

            public void run() {
                if (mEditor == null || !mEditor.mErrorWasChanged) {
                    setError(error);
                }
            }
        });
    }
    if (ss.editorState != null) {
        createEditorIfNeeded();
        mEditor.restoreInstanceState(ss.editorState);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",0,"The changes include a control flow addition (if-condition) and other statements (createEditorIfNeeded and mEditor.restoreInstanceState). The change type is 1,3,4.","Even though there are changes in the implementation details, none of these changes involve a different return type or value, neither do they involve a change in thrown exceptions. Therefore, there is no CI in terms of return type/value or exception handling. The control flow and other changes do not impact the externally observable behavior in terms of the method signature's contract."
969,<android.view.accessibility.AccessibilityRecord: AccessibilityNodeInfo getSource()>,22,23,<android.view.accessibility.AccessibilityRecord: AccessibilityNodeInfo getSource()>,<android.view.accessibility.AccessibilityRecord: AccessibilityNodeInfo getSource()>,0,"{
    enforceSealed();
    if (mConnectionId == UNDEFINED || mSourceWindowId == UNDEFINED || AccessibilityNodeInfo.getAccessibilityViewId(mSourceNodeId) == UNDEFINED) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mSourceWindowId, mSourceNodeId, false, GET_SOURCE_PREFETCH_FLAGS);
}","{
    enforceSealed();
    if (mSourceNode != null) {
        return AccessibilityNodeInfo.obtain(mSourceNode);
    }
    return null;
}",1,"/**
 * Gets the {@link AccessibilityNodeInfo} of the event source.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the received info
 * by calling {@link AccessibilityNodeInfo#recycle() AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 * @return The info of the source.
 */
","/**
 * Gets the {@link AccessibilityNodeInfo} of the event source.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the received info
 * by calling {@link AccessibilityNodeInfo#recycle() AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 * @return The info of the source.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The logic for obtaining the source `AccessibilityNodeInfo` has changed significantly. The late version is using a direct check on `mSourceNode` and creating a new `AccessibilityNodeInfo` with `obtain(mSourceNode)` if it's not null. In contrast, the early version is using a more complex mechanism involving a connection ID and source node ID, along with a check for undefined IDs and a call to `AccessibilityInteractionClient.getInstance().findAccessibilityNodeInfoByAccessibilityId()` if IDs are defined. This indicates a dependent API change and a returned statement change.","Given that the means by which `AccessibilityNodeInfo` is acquired have been altered, this could result in a different `AccessibilityNodeInfo` object being returned. If `mSourceNode` is not null in the late version, a new object is returned directly instead of using the client to find it, introducing potential for different behavior, hence a Compatibility Issue due to potential different return values."
970,<android.widget.SearchView: CharSequence getQueryHint()>,22,23,<android.widget.SearchView: CharSequence getQueryHint()>,<android.widget.SearchView: CharSequence getQueryHint()>,0,"{
    if (mQueryHint != null) {
        return mQueryHint;
    } else if (mSearchable != null) {
        CharSequence hint = null;
        int hintId = mSearchable.getHintId();
        if (hintId != 0) {
            hint = getContext().getString(hintId);
        }
        return hint;
    }
    return null;
}","{
    final CharSequence hint;
    if (mQueryHint != null) {
        hint = mQueryHint;
    } else if (mSearchable != null && mSearchable.getHintId() != 0) {
        hint = getContext().getText(mSearchable.getHintId());
    } else {
        hint = mDefaultQueryHint;
    }
    return hint;
}",1,"/**
 * Gets the hint text to display in the query text field.
 * @return the query hint text, if specified, null otherwise.
 *
 * @attr ref android.R.styleable#SearchView_queryHint
 */
","/**
 * Returns the hint text that will be displayed in the query text field.
 * <p>
 * The displayed query hint is chosen in the following order:
 * <ol>
 * <li>Non-null value set with {@link #setQueryHint(CharSequence)}
 * <li>Value specified in XML using
 * {@link android.R.styleable#SearchView_queryHint android:queryHint}
 * <li>Valid string resource ID exposed by the {@link SearchableInfo} via
 * {@link SearchableInfo#getHintId()}
 * <li>Default hint provided by the theme against which the view was
 * inflated
 * </ol>
 *
 * @return the displayed query hint text, or {@code null} if none set
 * @attr ref android.R.styleable#SearchView_queryHint
 */
",-1,,[@Nullable],-1,-1,-1,-1,-1,-1,"1,3,4",1,"The control dependency inside the `else if` block has changed, as well as the method used to retrieve the string resource from getContext().getString(hintId) to getContext().getText(). Additionally, a new variable `hint` is used to store the result before returning it, and a new pathway for the case `mDefaultQueryHint` is introduced. The code control dependency change type is 3, and there are other changes regarding the assignments and method calls which are marked as type 4. Therefore, the code changes are of type 1, 3, and 4.","The introduction of a new path (mDefaultQueryHint) potentially changes the value returned by the method and the switch from getString to getText can affect the returned value because getText can return styled text (CharSequence) while getString only returns a string (String), which may affect apps that depend on the unstyled text. Thus, the CI type is 1."
971,<android.app.Notification.Action: Action clone()>,22,23,<android.app.Notification.Action: Action clone()>,<android.app.Notification.Action: Action clone()>,0,"{
    return new Action(icon, title, // safe to alias
    actionIntent, new Bundle(mExtras), getRemoteInputs());
}","{
    return new Action(getIcon(), title, // safe to alias
    actionIntent, new Bundle(mExtras), getRemoteInputs());
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,The code change involves switching from direct field access 'icon' to a method call 'getIcon()'. This indicates a dependent API change for accessing the icon of the Action.,"There is no Compatibility Issue since the change from a field to a getter method does not alter the behavior or output assuming that 'getIcon()' method is simply returning the 'icon' field's value without any modification. Thus the action's icon remains the same, and clients using the 'clone()' method will receive an Action with the same icon as before."
972,<android.text.style.ForegroundColorSpan: int getSpanTypeId()>,22,23,<android.text.style.ForegroundColorSpan: int getSpanTypeId()>,<android.text.style.ForegroundColorSpan: int getSpanTypeId()>,0,"{
    return TextUtils.FOREGROUND_COLOR_SPAN;
}","{
    return getSpanTypeIdInternal();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The early version returns a constant value directly, while the late version returns the result of a method call (getSpanTypeIdInternal()), and since we don't have the implementation of getSpanTypeIdInternal(), it's assumed to be a dependent API that could return a different result than the constant, hence the code change type is 1,5.","With the change of implementation to call a different method (getSpanTypeIdInternal()), it's possible that the new method could return a different value from the constant used in the early version, resulting in a potential different return value. Therefore, the CI type is 1."
975,"<android.hardware.camera2.legacy.LegacyMetadataMapper: CameraCharacteristics createCharacteristics(String,CameraInfo)>",22,23,"<android.hardware.camera2.legacy.LegacyMetadataMapper: CameraCharacteristics createCharacteristics(String,CameraInfo)>","<android.hardware.camera2.legacy.LegacyMetadataMapper: CameraCharacteristics createCharacteristics(String,CameraInfo)>",0,"{
    checkNotNull(parameters, ""parameters must not be null"");
    checkNotNull(info, ""info must not be null"");
    checkNotNull(info.info, ""info.info must not be null"");
    CameraMetadataNative m = new CameraMetadataNative();
    mapCharacteristicsFromInfo(m, info.info);
    Camera.Parameters params = Camera.getEmptyParameters();
    params.unflatten(parameters);
    mapCharacteristicsFromParameters(m, params);
    if (VERBOSE) {
        Log.v(TAG, ""createCharacteristics metadata:"");
        Log.v(TAG, ""--------------------------------------------------- (start)"");
        m.dumpToLog();
        Log.v(TAG, ""--------------------------------------------------- (end)"");
    }
    return new CameraCharacteristics(m);
}","{
    checkNotNull(parameters, ""parameters must not be null"");
    checkNotNull(info, ""info must not be null"");
    checkNotNull(info.info, ""info.info must not be null"");
    CameraMetadataNative m = new CameraMetadataNative();
    mapCharacteristicsFromInfo(m, info.info);
    Camera.Parameters params = Camera.getEmptyParameters();
    params.unflatten(parameters);
    mapCharacteristicsFromParameters(m, params);
    if (DEBUG) {
        Log.v(TAG, ""createCharacteristics metadata:"");
        Log.v(TAG, ""--------------------------------------------------- (start)"");
        m.dumpToLog();
        Log.v(TAG, ""--------------------------------------------------- (end)"");
    }
    return new CameraCharacteristics(m);
}",1,"/**
 * Create characteristics for a legacy device by mapping the {@code parameters}
 * and {@code info}
 *
 * @param parameters A string parseable by {@link Camera.Parameters#unflatten}
 * @param info Camera info with camera facing direction and angle of orientation
 * @return static camera characteristics for a camera device
 *
 * @throws NullPointerException if any of the args were {@code null}
 */
","/**
 * Create characteristics for a legacy device by mapping the {@code parameters}
 * and {@code info}
 *
 * @param parameters A string parseable by {@link Camera.Parameters#unflatten}
 * @param info Camera info with camera facing direction and angle of orientation
 * @return static camera characteristics for a camera device
 *
 * @throws NullPointerException if any of the args were {@code null}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"There is a change in the control dependency, as the constant used in the if statement has changed from VERBOSE to DEBUG, and there are changes inside the logging block, which are not affecting the control flow or return value when the flag is set to true. Therefore, the change types are 3 and 4.","The code changes are related to the debug logging and are gated behind a flag that should not affect the normal operation of the API; hence, no Compatibility Issue should arise from these changes, and the CI type is 0."
976,"<android.transition.PatternPathMotion: Path getPath(float,float,float,float)>",22,23,"<android.transition.PatternPathMotion: Path getPath(float,float,float,float)>","<android.transition.PatternPathMotion: Path getPath(float,float,float,float)>",0,"{
    float dx = endX - startX;
    float dy = endY - startY;
    float length = distance(dx, dy);
    double angle = Math.atan2(dy, dx);
    mTempMatrix.setScale(length, length);
    mTempMatrix.postRotate((float) Math.toDegrees(angle));
    mTempMatrix.postTranslate(startX, startY);
    Path path = new Path();
    mPatternPath.transform(mTempMatrix, path);
    return path;
}","{
    double dx = endX - startX;
    double dy = endY - startY;
    float length = (float) Math.hypot(dx, dy);
    double angle = Math.atan2(dy, dx);
    mTempMatrix.setScale(length, length);
    mTempMatrix.postRotate((float) Math.toDegrees(angle));
    mTempMatrix.postTranslate(startX, startY);
    Path path = new Path();
    mPatternPath.transform(mTempMatrix, path);
    return path;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The local variables 'dx' and 'dy' types have been changed from float to double, and the method for calculating 'length' has changed from using a custom 'distance' method to using 'Math.hypot'. The return value type remains the same (Path), and it's generated by the same series of operations on the Path object. Therefore, even though the internal calculation method has changed, it doesn't affect the API contract, and the change type is 4.","Although there are changes in local variable types and the way 'length' is calculated, these are internal implementation details, and they don't result in a different return type or value for the Path object from the API's perspective. The returns are based on the same input coordinates, just with refined internal precision. Also, there is no change regarding how exceptions are thrown. Therefore, there is no Compatibility Issue, so the CI type is 0."
977,<android.hardware.camera2.impl.CameraCaptureSessionImpl.AbortDrainListener: void onDrained()>,22,23,<android.hardware.camera2.impl.CameraCaptureSessionImpl.AbortDrainListener: void onDrained()>,<android.hardware.camera2.impl.CameraCaptureSessionImpl.AbortDrainListener: void onDrained()>,0,"{
    if (VERBOSE)
        Log.v(TAG, mIdString + ""onAbortDrained"");
    synchronized (CameraCaptureSessionImpl.this) {
        /*
                 * Any queued aborts have now completed.
                 *
                 * It's now safe to wait to receive the final ""IDLE"" event, as the camera device
                 * will no longer again transition to ""ACTIVE"" by itself.
                 *
                 * If the camera is already ""IDLE"", then the drain immediately finishes.
                 */
        mIdleDrainer.beginDrain();
    }
}","{
    if (DEBUG)
        Log.v(TAG, mIdString + ""onAbortDrained"");
    synchronized (CameraCaptureSessionImpl.this) {
        // as we won't get state updates any more anyway.
        if (mSkipUnconfigure) {
            return;
        }
        mIdleDrainer.beginDrain();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"The condition for logging has changed from VERBOSE to DEBUG, and a new 'if' statement is added with a return statement inside it (if (mSkipUnconfigure) { return; }), so the changes are return statement and control dependency, which entails code change type 1,3.","The new 'if' condition with a return statement can cause the method to exit early without calling mIdleDrainer.beginDrain(), leading to a potential difference in behavior. This is a compatibility issue due to a potential different return value, which is type 1."
979,<android.animation.IntKeyframeSet: int getIntValue(float)>,22,23,<android.animation.IntKeyframeSet: int getIntValue(float)>,<android.animation.IntKeyframeSet: int getIntValue(float)>,0,"{
    if (mNumKeyframes == 2) {
        if (firstTime) {
            firstTime = false;
            firstValue = ((IntKeyframe) mKeyframes.get(0)).getIntValue();
            lastValue = ((IntKeyframe) mKeyframes.get(1)).getIntValue();
            deltaValue = lastValue - firstValue;
        }
        if (mInterpolator != null) {
            fraction = mInterpolator.getInterpolation(fraction);
        }
        if (mEvaluator == null) {
            return firstValue + (int) (fraction * deltaValue);
        } else {
            return ((Number) mEvaluator.evaluate(fraction, firstValue, lastValue)).intValue();
        }
    }
    if (fraction <= 0f) {
        final IntKeyframe prevKeyframe = (IntKeyframe) mKeyframes.get(0);
        final IntKeyframe nextKeyframe = (IntKeyframe) mKeyframes.get(1);
        int prevValue = prevKeyframe.getIntValue();
        int nextValue = nextKeyframe.getIntValue();
        float prevFraction = prevKeyframe.getFraction();
        float nextFraction = nextKeyframe.getFraction();
        final TimeInterpolator interpolator = nextKeyframe.getInterpolator();
        if (interpolator != null) {
            fraction = interpolator.getInterpolation(fraction);
        }
        float intervalFraction = (fraction - prevFraction) / (nextFraction - prevFraction);
        return mEvaluator == null ? prevValue + (int) (intervalFraction * (nextValue - prevValue)) : ((Number) mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).intValue();
    } else if (fraction >= 1f) {
        final IntKeyframe prevKeyframe = (IntKeyframe) mKeyframes.get(mNumKeyframes - 2);
        final IntKeyframe nextKeyframe = (IntKeyframe) mKeyframes.get(mNumKeyframes - 1);
        int prevValue = prevKeyframe.getIntValue();
        int nextValue = nextKeyframe.getIntValue();
        float prevFraction = prevKeyframe.getFraction();
        float nextFraction = nextKeyframe.getFraction();
        final TimeInterpolator interpolator = nextKeyframe.getInterpolator();
        if (interpolator != null) {
            fraction = interpolator.getInterpolation(fraction);
        }
        float intervalFraction = (fraction - prevFraction) / (nextFraction - prevFraction);
        return mEvaluator == null ? prevValue + (int) (intervalFraction * (nextValue - prevValue)) : ((Number) mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).intValue();
    }
    IntKeyframe prevKeyframe = (IntKeyframe) mKeyframes.get(0);
    for (int i = 1; i < mNumKeyframes; ++i) {
        IntKeyframe nextKeyframe = (IntKeyframe) mKeyframes.get(i);
        if (fraction < nextKeyframe.getFraction()) {
            final TimeInterpolator interpolator = nextKeyframe.getInterpolator();
            if (interpolator != null) {
                fraction = interpolator.getInterpolation(fraction);
            }
            float intervalFraction = (fraction - prevKeyframe.getFraction()) / (nextKeyframe.getFraction() - prevKeyframe.getFraction());
            int prevValue = prevKeyframe.getIntValue();
            int nextValue = nextKeyframe.getIntValue();
            return mEvaluator == null ? prevValue + (int) (intervalFraction * (nextValue - prevValue)) : ((Number) mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).intValue();
        }
        prevKeyframe = nextKeyframe;
    }
    // shouldn't get here
    return ((Number) mKeyframes.get(mNumKeyframes - 1).getValue()).intValue();
}","{
    if (mNumKeyframes == 2) {
        if (firstTime) {
            firstTime = false;
            firstValue = ((IntKeyframe) mKeyframes.get(0)).getIntValue();
            lastValue = ((IntKeyframe) mKeyframes.get(1)).getIntValue();
            deltaValue = lastValue - firstValue;
        }
        if (mInterpolator != null) {
            fraction = mInterpolator.getInterpolation(fraction);
        }
        if (mEvaluator == null) {
            return firstValue + (int) (fraction * deltaValue);
        } else {
            return ((Number) mEvaluator.evaluate(fraction, firstValue, lastValue)).intValue();
        }
    }
    if (fraction <= 0f) {
        final IntKeyframe prevKeyframe = (IntKeyframe) mKeyframes.get(0);
        final IntKeyframe nextKeyframe = (IntKeyframe) mKeyframes.get(1);
        int prevValue = prevKeyframe.getIntValue();
        int nextValue = nextKeyframe.getIntValue();
        float prevFraction = prevKeyframe.getFraction();
        float nextFraction = nextKeyframe.getFraction();
        final TimeInterpolator interpolator = nextKeyframe.getInterpolator();
        if (interpolator != null) {
            fraction = interpolator.getInterpolation(fraction);
        }
        float intervalFraction = (fraction - prevFraction) / (nextFraction - prevFraction);
        return mEvaluator == null ? prevValue + (int) (intervalFraction * (nextValue - prevValue)) : ((Number) mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).intValue();
    } else if (fraction >= 1f) {
        final IntKeyframe prevKeyframe = (IntKeyframe) mKeyframes.get(mNumKeyframes - 2);
        final IntKeyframe nextKeyframe = (IntKeyframe) mKeyframes.get(mNumKeyframes - 1);
        int prevValue = prevKeyframe.getIntValue();
        int nextValue = nextKeyframe.getIntValue();
        float prevFraction = prevKeyframe.getFraction();
        float nextFraction = nextKeyframe.getFraction();
        final TimeInterpolator interpolator = nextKeyframe.getInterpolator();
        if (interpolator != null) {
            fraction = interpolator.getInterpolation(fraction);
        }
        float intervalFraction = (fraction - prevFraction) / (nextFraction - prevFraction);
        return mEvaluator == null ? prevValue + (int) (intervalFraction * (nextValue - prevValue)) : ((Number) mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).intValue();
    }
    IntKeyframe prevKeyframe = (IntKeyframe) mKeyframes.get(0);
    for (int i = 1; i < mNumKeyframes; ++i) {
        IntKeyframe nextKeyframe = (IntKeyframe) mKeyframes.get(i);
        if (fraction < nextKeyframe.getFraction()) {
            final TimeInterpolator interpolator = nextKeyframe.getInterpolator();
            float intervalFraction = (fraction - prevKeyframe.getFraction()) / (nextKeyframe.getFraction() - prevKeyframe.getFraction());
            int prevValue = prevKeyframe.getIntValue();
            int nextValue = nextKeyframe.getIntValue();
            // Apply interpolator on the proportional duration.
            if (interpolator != null) {
                intervalFraction = interpolator.getInterpolation(intervalFraction);
            }
            return mEvaluator == null ? prevValue + (int) (intervalFraction * (nextValue - prevValue)) : ((Number) mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).intValue();
        }
        prevKeyframe = nextKeyframe;
    }
    // shouldn't get here
    return ((Number) mKeyframes.get(mNumKeyframes - 1).getValue()).intValue();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
981,<android.widget.DatePickerCalendarDelegate: CalendarView getCalendarView()>,22,23,<android.widget.DatePickerCalendarDelegate: CalendarView getCalendarView()>,<android.widget.DatePickerCalendarDelegate: CalendarView getCalendarView()>,0,"{
    throw new UnsupportedOperationException(""CalendarView does not exists for the new DatePicker"");
}","{
    throw new UnsupportedOperationException(""Not supported by calendar-mode DatePicker"");
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The change in the implementation is the update of the exception message text. Since the exception type remains the same and only the message has changed, the change type is 4.","The exception thrown is still an UnsupportedOperationException in both versions, and changing the exception message does not alter the behavior in terms of how the API should be used or handled by the calling code. Therefore, there is no Compatibility Issue, so the CI type is 0."
982,"<android.content.res.TypedArray: boolean getBoolean(int,boolean)>",22,23,"<android.content.res.TypedArray: boolean getBoolean(int,boolean)>","<android.content.res.TypedArray: boolean getBoolean(int,boolean)>",0,"{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA] != 0;
    }
    TypedValue v = mValue;
    if (getValueAt(index, v)) {
        Log.w(Resources.TAG, ""Converting to boolean: "" + v);
        return XmlUtils.convertValueToBoolean(v.coerceToString(), defValue);
    }
    Log.w(Resources.TAG, ""getBoolean of bad type: 0x"" + Integer.toHexString(type));
    return defValue;
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA] != 0;
    }
    final TypedValue v = mValue;
    if (getValueAt(index, v)) {
        StrictMode.noteResourceMismatch(v);
        return XmlUtils.convertValueToBoolean(v.coerceToString(), defValue);
    }
    // We already checked for TYPE_NULL. This should never happen.
    throw new RuntimeException(""getBoolean of bad type: 0x"" + Integer.toHexString(type));
}",1,"/**
 * Retrieve the boolean value for the attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined.
 *
 * @return Attribute boolean value, or defValue if not defined.
 */
","/**
 * Retrieve the boolean value for the attribute at <var>index</var>.
 * <p>
 * If the attribute is an integer value, this method will return whether
 * it is equal to zero. If the attribute is not a boolean or integer value,
 * this method will attempt to coerce it to an integer using
 * {@link Integer#decode(String)} and return whether it is equal to zero.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * cannot be coerced to an integer.
 *
 * @return Boolean value of the attribute, or defValue if the attribute was
 * not defined or could not be coerced to an integer.
 * @throws RuntimeException if the TypedArray has already been recycled.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4,5","1,2","There has been a change in exception handling statements, and a call to `StrictMode.noteResourceMismatch(v)` has been added. Also, `Log.w` is replaced with throwing a `RuntimeException`, which represents a change in both exception handling and other statement types, so the code change type is 2, 4, 5.","The introduction of a new `throw` statement in the last part of the method constitutes a change in exception behavior. In the early version, a warning is logged and a default value returned; in the late version, a `RuntimeException` is thrown, potentially leading to different behavior in the client code. Also, the new call to `StrictMode.noteResourceMismatch(v)` may affect the state used by `StrictMode`, potentially leading to different behavior based on `StrictMode` configuration, so the CI type is 1, 2."
983,"<android.app.FragmentManagerImpl: boolean popBackStackImmediate(int,int)>",22,23,"<android.app.FragmentManagerImpl: boolean popBackStackImmediate(int,int)>","<android.app.FragmentManagerImpl: boolean popBackStackImmediate(int,int)>",0,"{
    checkStateLoss();
    executePendingTransactions();
    if (id < 0) {
        throw new IllegalArgumentException(""Bad id: "" + id);
    }
    return popBackStackState(mActivity.mHandler, null, id, flags);
}","{
    checkStateLoss();
    executePendingTransactions();
    if (id < 0) {
        throw new IllegalArgumentException(""Bad id: "" + id);
    }
    return popBackStackState(mHost.getHandler(), null, id, flags);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"There's a change in the dependent API from mActivity.mHandler to mHost.getHandler(). This is a change in the way how the handler is retrieved, so the code change type is 5.","Despite the changes in the way the handler is retrieved (dependent API change), there is no indication that the behavior of popBackStackState will be different as the parameters passed to it remain the same. Hence, there should be no Compatibility Issue, and the type is 0."
984,"<android.accounts.AbstractAccountAuthenticator.Transport: void getAuthToken(IAccountAuthenticatorResponse,Account,String,Bundle)>",22,23,"<android.accounts.AbstractAccountAuthenticator.Transport: void getAuthToken(IAccountAuthenticatorResponse,Account,String,Bundle)>","<android.accounts.AbstractAccountAuthenticator.Transport: void getAuthToken(IAccountAuthenticatorResponse,Account,String,Bundle)>",0,"{
    if (Log.isLoggable(TAG, Log.VERBOSE)) {
        Log.v(TAG, ""getAuthToken: "" + account + "", authTokenType "" + authTokenType);
    }
    checkBinderPermission();
    try {
        final Bundle result = AbstractAccountAuthenticator.this.getAuthToken(new AccountAuthenticatorResponse(response), account, authTokenType, loginOptions);
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            // force it to be unparcelled
            result.keySet();
            Log.v(TAG, ""getAuthToken: result "" + AccountManager.sanitizeResult(result));
        }
        if (result != null) {
            response.onResult(result);
        }
    } catch (Exception e) {
        handleException(response, ""getAuthToken"", account.toString() + "","" + authTokenType, e);
    }
}","{
    if (Log.isLoggable(TAG, Log.VERBOSE)) {
        Log.v(TAG, ""getAuthToken: "" + account + "", authTokenType "" + authTokenType);
    }
    checkBinderPermission();
    try {
        final Bundle result = AbstractAccountAuthenticator.this.getAuthToken(new AccountAuthenticatorResponse(response), account, authTokenType, loginOptions);
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            if (result != null) {
                // force it to be unparcelled
                result.keySet();
            }
            Log.v(TAG, ""getAuthToken: result "" + AccountManager.sanitizeResult(result));
        }
        if (result != null) {
            response.onResult(result);
        }
    } catch (Exception e) {
        handleException(response, ""getAuthToken"", account.toString() + "","" + authTokenType, e);
    }
}",1,,,-1,,[@Override],-1,-1,-1,-1,-1,-1,4,0,"The change is limited to the reordering of the operation to log the message and the check to ensure `result` is not null, which does not affect the logic or output of the method. So it is an 'Other statement changed'.","This change does not introduce any compatibility issue, as it will neither cause different return values nor exception handlings. The behavior of the method remains the same in terms of its observable effects from an API user standpoint."
985,<android.view.ScaleGestureDetector: void setQuickScaleEnabled(boolean)>,22,23,<android.view.ScaleGestureDetector: void setQuickScaleEnabled(boolean)>,<android.view.ScaleGestureDetector: void setQuickScaleEnabled(boolean)>,0,"{
    mQuickScaleEnabled = scales;
    if (mQuickScaleEnabled && mGestureDetector == null) {
        GestureDetector.SimpleOnGestureListener gestureListener = new GestureDetector.SimpleOnGestureListener() {

            @Override
            public boolean onDoubleTap(MotionEvent e) {
                // Double tap: start watching for a swipe
                mDoubleTapEvent = e;
                mDoubleTapMode = DOUBLE_TAP_MODE_IN_PROGRESS;
                return true;
            }
        };
        mGestureDetector = new GestureDetector(mContext, gestureListener, mHandler);
    }
}","{
    mQuickScaleEnabled = scales;
    if (mQuickScaleEnabled && mGestureDetector == null) {
        GestureDetector.SimpleOnGestureListener gestureListener = new GestureDetector.SimpleOnGestureListener() {

            @Override
            public boolean onDoubleTap(MotionEvent e) {
                // Double tap: start watching for a swipe
                mAnchoredScaleStartX = e.getX();
                mAnchoredScaleStartY = e.getY();
                mAnchoredScaleMode = ANCHORED_SCALE_MODE_DOUBLE_TAP;
                return true;
            }
        };
        mGestureDetector = new GestureDetector(mContext, gestureListener, mHandler);
    }
}",1,"/**
 * Set whether the associated {@link OnScaleGestureListener} should receive onScale callbacks
 * when the user performs a doubleTap followed by a swipe. Note that this is enabled by default
 * if the app targets API 19 and newer.
 * @param scales true to enable quick scaling, false to disable
 */
","/**
 * Set whether the associated {@link OnScaleGestureListener} should receive onScale callbacks
 * when the user performs a doubleTap followed by a swipe. Note that this is enabled by default
 * if the app targets API 19 and newer.
 * @param scales true to enable quick scaling, false to disable
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The internal implementation of the anonymous GestureDetector.SimpleOnGestureListener's onDoubleTap method was changed. In the new implementation, the variables mAnchoredScaleStartX, mAnchoredScaleStartY, and mAnchoredScaleMode have been assigned, replacing the assignment of mDoubleTapEvent and mDoubleTapMode.","Despite the internal changes to the onDoubleTap method implementation, there is no change to the method signature or its external behavior related to the setQuickScaleEnabled method. The method still returns void and no new exceptions are thrown. There is an internal change that does not affect the outward contract of the setQuickScaleEnabled method, so there is no Compatibility Issue."
986,<android.view.accessibility.AccessibilityEvent: String toString()>,22,23,<android.view.accessibility.AccessibilityEvent: String toString()>,<android.view.accessibility.AccessibilityEvent: String toString()>,0,"{
    StringBuilder builder = new StringBuilder();
    builder.append(""EventType: "").append(eventTypeToString(mEventType));
    builder.append(""; EventTime: "").append(mEventTime);
    builder.append(""; PackageName: "").append(mPackageName);
    builder.append(""; MovementGranularity: "").append(mMovementGranularity);
    builder.append(""; Action: "").append(mAction);
    builder.append(super.toString());
    if (DEBUG) {
        builder.append(""\n"");
        builder.append(""; ContentChangeTypes: "").append(mContentChangeTypes);
        builder.append(""; sourceWindowId: "").append(mSourceWindowId);
        builder.append(""; mSourceNodeId: "").append(mSourceNodeId);
        for (int i = 0; i < getRecordCount(); i++) {
            final AccessibilityRecord record = getRecord(i);
            builder.append(""  Record "");
            builder.append(i);
            builder.append("":"");
            builder.append("" [ ClassName: "" + record.mClassName);
            builder.append(""; Text: "" + record.mText);
            builder.append(""; ContentDescription: "" + record.mContentDescription);
            builder.append(""; ItemCount: "" + record.mItemCount);
            builder.append(""; CurrentItemIndex: "" + record.mCurrentItemIndex);
            builder.append(""; IsEnabled: "" + record.isEnabled());
            builder.append(""; IsPassword: "" + record.isPassword());
            builder.append(""; IsChecked: "" + record.isChecked());
            builder.append(""; IsFullScreen: "" + record.isFullScreen());
            builder.append(""; Scrollable: "" + record.isScrollable());
            builder.append(""; BeforeText: "" + record.mBeforeText);
            builder.append(""; FromIndex: "" + record.mFromIndex);
            builder.append(""; ToIndex: "" + record.mToIndex);
            builder.append(""; ScrollX: "" + record.mScrollX);
            builder.append(""; ScrollY: "" + record.mScrollY);
            builder.append(""; AddedCount: "" + record.mAddedCount);
            builder.append(""; RemovedCount: "" + record.mRemovedCount);
            builder.append(""; ParcelableData: "" + record.mParcelableData);
            builder.append("" ]"");
            builder.append(""\n"");
        }
    } else {
        builder.append(""; recordCount: "").append(getRecordCount());
    }
    return builder.toString();
}","{
    StringBuilder builder = new StringBuilder();
    builder.append(""EventType: "").append(eventTypeToString(mEventType));
    builder.append(""; EventTime: "").append(mEventTime);
    builder.append(""; PackageName: "").append(mPackageName);
    builder.append(""; MovementGranularity: "").append(mMovementGranularity);
    builder.append(""; Action: "").append(mAction);
    builder.append(super.toString());
    if (DEBUG) {
        builder.append(""\n"");
        builder.append(""; ContentChangeTypes: "").append(mContentChangeTypes);
        builder.append(""; sourceWindowId: "").append(mSourceWindowId);
        if (mSourceNode != null) {
            builder.append(""; mSourceNodeId: "").append(mSourceNode.getSourceNodeId());
        }
        for (int i = 0; i < getRecordCount(); i++) {
            final AccessibilityRecord record = getRecord(i);
            builder.append(""  Record "");
            builder.append(i);
            builder.append("":"");
            builder.append("" [ ClassName: "" + record.mClassName);
            builder.append(""; Text: "" + record.mText);
            builder.append(""; ContentDescription: "" + record.mContentDescription);
            builder.append(""; ItemCount: "" + record.mItemCount);
            builder.append(""; CurrentItemIndex: "" + record.mCurrentItemIndex);
            builder.append(""; IsEnabled: "" + record.isEnabled());
            builder.append(""; IsPassword: "" + record.isPassword());
            builder.append(""; IsChecked: "" + record.isChecked());
            builder.append(""; IsFullScreen: "" + record.isFullScreen());
            builder.append(""; Scrollable: "" + record.isScrollable());
            builder.append(""; BeforeText: "" + record.mBeforeText);
            builder.append(""; FromIndex: "" + record.mFromIndex);
            builder.append(""; ToIndex: "" + record.mToIndex);
            builder.append(""; ScrollX: "" + record.mScrollX);
            builder.append(""; ScrollY: "" + record.mScrollY);
            builder.append(""; AddedCount: "" + record.mAddedCount);
            builder.append(""; RemovedCount: "" + record.mRemovedCount);
            builder.append(""; ParcelableData: "" + record.mParcelableData);
            builder.append("" ]"");
            builder.append(""\n"");
        }
    } else {
        builder.append(""; recordCount: "").append(getRecordCount());
    }
    return builder.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The change occurred in a control dependency branch (`if (DEBUG) {...}`), where the line `builder.append(""; mSourceNodeId: "").append(mSourceNodeId);` was replaced by a conditional statement `if (mSourceNode != null) { builder.append(""; mSourceNodeId: "").append(mSourceNode.getSourceNodeId()); }`. This replacement adds an additional null check before appending the source node ID. The other statement changed is the way the `mSourceNodeId` is fetched; previously, `mSourceNodeId` was used directly, now it is retrieved using a method `getSourceNodeId()` on the `mSourceNode` object. Therefore, there is both a control dependency change and other statement change.","No Compatibility Issue is detected since the observed changes are happening only under a condition controlled by the debug flag (`DEBUG`). It means the behavior is identical when 'DEBUG' is false, which it generally is in production and normal use cases. The extra null check and use of a different API within the `if (DEBUG)` block won't affect the public contract or the return value of the method for the end-users."
987,<android.appwidget.AppWidgetHost.Callbacks: void providersChanged()>,22,23,<android.appwidget.AppWidgetHost.Callbacks: void providersChanged()>,<android.appwidget.AppWidgetHost.Callbacks: void providersChanged()>,0,"{
    mHandler.obtainMessage(HANDLE_PROVIDERS_CHANGED).sendToTarget();
}","{
    Handler handler = mWeakHandler.get();
    if (handler == null) {
        return;
    }
    handler.obtainMessage(HANDLE_PROVIDERS_CHANGED).sendToTarget();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"A new control statement (if) has been introduced, and there's a new initialization of local variable 'handler', so the code change types are 3 and 4.","The late implementation introduces a new control structure that returns early if 'handler' is null. This change means that in a situation where 'handler' is null, the method in the early version would try to use it and likely throw an exception, while the late version method does nothing. Given this, there is a change in behavior introduced, which could cause a CI due to potentially different return behavior. Therefore, the CI type is 1."
988,<android.hardware.camera2.params.StreamConfigurationMap: boolean equals(Object)>,22,23,<android.hardware.camera2.params.StreamConfigurationMap: boolean equals(Object)>,<android.hardware.camera2.params.StreamConfigurationMap: boolean equals(Object)>,0,"{
    if (obj == null) {
        return false;
    }
    if (this == obj) {
        return true;
    }
    if (obj instanceof StreamConfigurationMap) {
        final StreamConfigurationMap other = (StreamConfigurationMap) obj;
        // XX: do we care about order?
        return Arrays.equals(mConfigurations, other.mConfigurations) && Arrays.equals(mMinFrameDurations, other.mMinFrameDurations) && Arrays.equals(mStallDurations, other.mStallDurations) && Arrays.equals(mHighSpeedVideoConfigurations, other.mHighSpeedVideoConfigurations);
    }
    return false;
}","{
    if (obj == null) {
        return false;
    }
    if (this == obj) {
        return true;
    }
    if (obj instanceof StreamConfigurationMap) {
        final StreamConfigurationMap other = (StreamConfigurationMap) obj;
        // XX: do we care about order?
        return Arrays.equals(mConfigurations, other.mConfigurations) && Arrays.equals(mMinFrameDurations, other.mMinFrameDurations) && Arrays.equals(mStallDurations, other.mStallDurations) && Arrays.equals(mDepthConfigurations, other.mDepthConfigurations) && Arrays.equals(mHighSpeedVideoConfigurations, other.mHighSpeedVideoConfigurations);
    }
    return false;
}",1,"/**
 * Check if this {@link StreamConfigurationMap} is equal to another
 * {@link StreamConfigurationMap}.
 *
 * <p>Two vectors are only equal if and only if each of the respective elements is equal.</p>
 *
 * @return {@code true} if the objects were equal, {@code false} otherwise
 */
","/**
 * Check if this {@link StreamConfigurationMap} is equal to another
 * {@link StreamConfigurationMap}.
 *
 * <p>Two vectors are only equal if and only if each of the respective elements is equal.</p>
 *
 * @return {@code true} if the objects were equal, {@code false} otherwise
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"An additional Arrays.equals comparison check (mDepthConfigurations, other.mDepthConfigurations) is introduced, so there's a change in an 'other statement', it's a change within the conditional check, not a control dependency change itself, making this a type 1 (return statement changed) and 4 (other statement changed).","The introduction of an additional condition `Arrays.equals(mDepthConfigurations, other.mDepthConfigurations)` can change the result of the equality check, potentially leading to the method returning a different value (true or false). Hence, this represents a compatibility issue of type 1."
990,<android.app.ActivityOptions: void update(ActivityOptions)>,22,23,<android.app.ActivityOptions: void update(ActivityOptions)>,<android.app.ActivityOptions: void update(ActivityOptions)>,0,"{
    if (otherOptions.mPackageName != null) {
        mPackageName = otherOptions.mPackageName;
    }
    mTransitionReceiver = null;
    mSharedElementNames = null;
    mIsReturning = false;
    mResultData = null;
    mResultCode = 0;
    mExitCoordinatorIndex = 0;
    mAnimationType = otherOptions.mAnimationType;
    switch(otherOptions.mAnimationType) {
        case ANIM_CUSTOM:
            mCustomEnterResId = otherOptions.mCustomEnterResId;
            mCustomExitResId = otherOptions.mCustomExitResId;
            mThumbnail = null;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = otherOptions.mAnimationStartedListener;
            break;
        case ANIM_CUSTOM_IN_PLACE:
            mCustomInPlaceResId = otherOptions.mCustomInPlaceResId;
            break;
        case ANIM_SCALE_UP:
            mStartX = otherOptions.mStartX;
            mStartY = otherOptions.mStartY;
            mWidth = otherOptions.mWidth;
            mHeight = otherOptions.mHeight;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = null;
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
        case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
        case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
            mThumbnail = otherOptions.mThumbnail;
            mStartX = otherOptions.mStartX;
            mStartY = otherOptions.mStartY;
            mWidth = otherOptions.mWidth;
            mHeight = otherOptions.mHeight;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = otherOptions.mAnimationStartedListener;
            break;
        case ANIM_SCENE_TRANSITION:
            mTransitionReceiver = otherOptions.mTransitionReceiver;
            mSharedElementNames = otherOptions.mSharedElementNames;
            mIsReturning = otherOptions.mIsReturning;
            mThumbnail = null;
            mAnimationStartedListener = null;
            mResultData = otherOptions.mResultData;
            mResultCode = otherOptions.mResultCode;
            mExitCoordinatorIndex = otherOptions.mExitCoordinatorIndex;
            break;
    }
}","{
    if (otherOptions.mPackageName != null) {
        mPackageName = otherOptions.mPackageName;
    }
    mUsageTimeReport = otherOptions.mUsageTimeReport;
    mTransitionReceiver = null;
    mSharedElementNames = null;
    mIsReturning = false;
    mResultData = null;
    mResultCode = 0;
    mExitCoordinatorIndex = 0;
    mAnimationType = otherOptions.mAnimationType;
    switch(otherOptions.mAnimationType) {
        case ANIM_CUSTOM:
            mCustomEnterResId = otherOptions.mCustomEnterResId;
            mCustomExitResId = otherOptions.mCustomExitResId;
            mThumbnail = null;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = otherOptions.mAnimationStartedListener;
            break;
        case ANIM_CUSTOM_IN_PLACE:
            mCustomInPlaceResId = otherOptions.mCustomInPlaceResId;
            break;
        case ANIM_SCALE_UP:
            mStartX = otherOptions.mStartX;
            mStartY = otherOptions.mStartY;
            mWidth = otherOptions.mWidth;
            mHeight = otherOptions.mHeight;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = null;
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
        case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
        case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
            mThumbnail = otherOptions.mThumbnail;
            mStartX = otherOptions.mStartX;
            mStartY = otherOptions.mStartY;
            mWidth = otherOptions.mWidth;
            mHeight = otherOptions.mHeight;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = otherOptions.mAnimationStartedListener;
            break;
        case ANIM_SCENE_TRANSITION:
            mTransitionReceiver = otherOptions.mTransitionReceiver;
            mSharedElementNames = otherOptions.mSharedElementNames;
            mIsReturning = otherOptions.mIsReturning;
            mThumbnail = null;
            mAnimationStartedListener = null;
            mResultData = otherOptions.mResultData;
            mResultCode = otherOptions.mResultCode;
            mExitCoordinatorIndex = otherOptions.mExitCoordinatorIndex;
            break;
    }
}",1,"/**
 * Update the current values in this ActivityOptions from those supplied
 * in <var>otherOptions</var>.  Any values
 * defined in <var>otherOptions</var> replace those in the base options.
 */
","/**
 * Update the current values in this ActivityOptions from those supplied
 * in <var>otherOptions</var>.  Any values
 * defined in <var>otherOptions</var> replace those in the base options.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
991,<android.app.admin.DevicePolicyManager: void uninstallAllUserCaCerts(ComponentName)>,22,23,<android.app.admin.DevicePolicyManager: void uninstallAllUserCaCerts(ComponentName)>,<android.app.admin.DevicePolicyManager: void uninstallAllUserCaCerts(ComponentName)>,0,"{
    if (mService != null) {
        for (String alias : new TrustedCertificateStore().userAliases()) {
            try {
                mService.uninstallCaCert(admin, alias);
            } catch (RemoteException re) {
                Log.w(TAG, ""Failed talking with device policy service"", re);
            }
        }
    }
}","{
    if (mService != null) {
        try {
            mService.uninstallCaCerts(admin, new TrustedCertificateStore().userAliases().toArray(new String[0]));
        } catch (RemoteException re) {
            Log.w(TAG, ""Failed talking with device policy service"", re);
        }
    }
}",1,"/**
 * Uninstalls all custom trusted CA certificates from the profile. Certificates installed by
 * means other than device policy will also be removed, except for system CA certificates.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 */
","/**
 * Uninstalls all custom trusted CA certificates from the profile. Certificates installed by
 * means other than device policy will also be removed, except for system CA certificates.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or
 * {@code null} if calling from a delegated certificate installer.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",0,"The method call uninstallCaCert() in a loop is changed to uninstallCaCerts() with all user aliases in one go, which impacts a dependent API, so the code change type is 1,5. This change also involves a conversion from a Collection to an array which is passed to the new method call.","Although the implementation changed significantly to use a batch operation instead of individual removals, there is no indication that the new method behaves differently in terms of the outcome if the operation is successful. It should not introduce a compatibility issue as far as the purpose of the method is to remove all user-installed CA certificates, and failure still results in a logged warning without affecting the method's return type or throwing an exception. Hence, the CI type is 0."
994,"<android.accounts.AbstractAccountAuthenticator.Transport: void addAccount(IAccountAuthenticatorResponse,String,String,String[],Bundle)>",22,23,"<android.accounts.AbstractAccountAuthenticator.Transport: void addAccount(IAccountAuthenticatorResponse,String,String,String[],Bundle)>","<android.accounts.AbstractAccountAuthenticator.Transport: void addAccount(IAccountAuthenticatorResponse,String,String,String[],Bundle)>",0,"{
    if (Log.isLoggable(TAG, Log.VERBOSE)) {
        Log.v(TAG, ""addAccount: accountType "" + accountType + "", authTokenType "" + authTokenType + "", features "" + (features == null ? ""[]"" : Arrays.toString(features)));
    }
    checkBinderPermission();
    try {
        final Bundle result = AbstractAccountAuthenticator.this.addAccount(new AccountAuthenticatorResponse(response), accountType, authTokenType, features, options);
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            // force it to be unparcelled
            result.keySet();
            Log.v(TAG, ""addAccount: result "" + AccountManager.sanitizeResult(result));
        }
        if (result != null) {
            response.onResult(result);
        }
    } catch (Exception e) {
        handleException(response, ""addAccount"", accountType, e);
    }
}","{
    if (Log.isLoggable(TAG, Log.VERBOSE)) {
        Log.v(TAG, ""addAccount: accountType "" + accountType + "", authTokenType "" + authTokenType + "", features "" + (features == null ? ""[]"" : Arrays.toString(features)));
    }
    checkBinderPermission();
    try {
        final Bundle result = AbstractAccountAuthenticator.this.addAccount(new AccountAuthenticatorResponse(response), accountType, authTokenType, features, options);
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            if (result != null) {
                // force it to be unparcelled
                result.keySet();
            }
            Log.v(TAG, ""addAccount: result "" + AccountManager.sanitizeResult(result));
        }
        if (result != null) {
            response.onResult(result);
        }
    } catch (Exception e) {
        handleException(response, ""addAccount"", accountType, e);
    }
}",1,,,-1,,[@Override],-1,-1,-1,-1,-1,-1,4,0,"The only code change is the relocation of the null check for `result` from outside to inside the `if (Log.isLoggable(TAG, Log.VERBOSE)) { ... }` block. This change does not alter the behavior of the method in terms of logic or flow, but only affects when the null check for logging purposes happens. So, the change type is 4.","This adjustment does not affect the method's functionality in terms of what it returns or what exceptions it may throw. Thus, there is no Compatibility Issue, and the CI type is 0."
995,<android.text.style.SuperscriptSpan: int getSpanTypeId()>,22,23,<android.text.style.SuperscriptSpan: int getSpanTypeId()>,<android.text.style.SuperscriptSpan: int getSpanTypeId()>,0,"{
    return TextUtils.SUPERSCRIPT_SPAN;
}","{
    return getSpanTypeIdInternal();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The implementation of the method has been changed from directly returning a constant value to calling another method to obtain the return value. Thus, there is an 'Other statement changed' as well as 'Dependent API changed' because the implementation now depends on the internal behavior of `getSpanTypeIdInternal()` which is a different API.","The change in the return statement indicates that the method now potentially returns a different value, depending on the implementation of 'getSpanTypeIdInternal()'. This constitutes a 'Compatibility Issue caused by potential different return values or types'."
997,<android.os.Parcel: Parcelable[] readParcelableArray(ClassLoader)>,22,23,<android.os.Parcel: Parcelable[] readParcelableArray(ClassLoader)>,<android.os.Parcel: Parcelable[] readParcelableArray(ClassLoader)>,0,"{
    int N = readInt();
    if (N < 0) {
        return null;
    }
    Parcelable[] p = new Parcelable[N];
    for (int i = 0; i < N; i++) {
        p[i] = (Parcelable) readParcelable(loader);
    }
    return p;
}","{
    int N = readInt();
    if (N < 0) {
        return null;
    }
    Parcelable[] p = new Parcelable[N];
    for (int i = 0; i < N; i++) {
        p[i] = readParcelable(loader);
    }
    return p;
}",1,"/**
 * Read and return a new Parcelable array from the parcel.
 * The given class loader will be used to load any enclosed
 * Parcelables.
 * @return the Parcelable array, or null if the array is null
 */
","/**
 * Read and return a new Parcelable array from the parcel.
 * The given class loader will be used to load any enclosed
 * Parcelables.
 * @return the Parcelable array, or null if the array is null
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The type casting for `readParcelable(loader)` from `(Parcelable) readParcelable(loader)` to `readParcelable(loader)` has been removed. Since the `readParcelable` method is expected to return a `Parcelable` object and the array is already declared as `Parcelable[]`, removing the explicit cast does not change the behavior as casting is redundant. Therefore, the change is of type 4, Other statement changed.","There is no compatibility issue since the removal of the redundant cast does not affect how the method behaves, and will not cause it to return different values or throw different exceptions. It is an internal code quality improvement. Thus, no compatibility issue arises, corresponding to 0."
998,"<android.os.storage.IMountServiceListener.Stub.Proxy: void onStorageStateChanged(String,String,String)>",22,23,"<android.os.storage.IMountServiceListener.Stub.Proxy: void onStorageStateChanged(String,String,String)>","<android.os.storage.IMountServiceListener.Stub.Proxy: void onStorageStateChanged(String,String,String)>",0,"{
    Parcel _data = Parcel.obtain();
    Parcel _reply = Parcel.obtain();
    try {
        _data.writeInterfaceToken(DESCRIPTOR);
        _data.writeString(path);
        _data.writeString(oldState);
        _data.writeString(newState);
        mRemote.transact(Stub.TRANSACTION_onStorageStateChanged, _data, _reply, 0);
        _reply.readException();
    } finally {
        _reply.recycle();
        _data.recycle();
    }
}","{
    Parcel _data = Parcel.obtain();
    Parcel _reply = Parcel.obtain();
    try {
        _data.writeInterfaceToken(DESCRIPTOR);
        _data.writeString(path);
        _data.writeString(oldState);
        _data.writeString(newState);
        mRemote.transact(Stub.TRANSACTION_onStorageStateChanged, _data, _reply, android.os.IBinder.FLAG_ONEWAY);
        _reply.readException();
    } finally {
        _reply.recycle();
        _data.recycle();
    }
}",1,"/**
 * Storage state has changed.
 *
 * @param path The volume mount path.
 * @param oldState The old state of the volume.
 * @param newState The new state of the volume. Note: State is one
 * of the values returned by
 * Environment.getExternalStorageState()
 */
","/**
 * Storage state has changed.
 *
 * @param path The volume mount path.
 * @param oldState The old state of the volume.
 * @param newState The new state of the volume. Note: State is one
 * of the values returned by
 * Environment.getExternalStorageState()
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change in the implementation is the flag used in the transact method, from 0 to android.os.IBinder.FLAG_ONEWAY. This is an alteration of a flag argument passed to a method, thus it is categorized as an ""Other statement changed"".","The change from a synchronous transact call (using 0 flag) to an asynchronous one-way call (using FLAG_ONEWAY) does not affect what the method returns nor does it affect exception handling since it is related to how the IPC mechanism works underneath. As such, this change does not cause a behavior difference from the API user's perspective, retaining compatibility with the previous implementation, so no Compatibility Issue arises."
999,<android.app.Fragment: void instantiateChildFragmentManager()>,22,23,<android.app.Fragment: void instantiateChildFragmentManager()>,<android.app.Fragment: void instantiateChildFragmentManager()>,0,"{
    mChildFragmentManager = new FragmentManagerImpl();
    mChildFragmentManager.attachActivity(mActivity, new FragmentContainer() {

        @Override
        public View findViewById(int id) {
            if (mView == null) {
                throw new IllegalStateException(""Fragment does not have a view"");
            }
            return mView.findViewById(id);
        }

        @Override
        public boolean hasView() {
            return (mView != null);
        }
    }, this);
}","{
    mChildFragmentManager = new FragmentManagerImpl();
    mChildFragmentManager.attachController(mHost, new FragmentContainer() {

        @Override
        @Nullable
        public View onFindViewById(int id) {
            if (mView == null) {
                throw new IllegalStateException(""Fragment does not have a view"");
            }
            return mView.findViewById(id);
        }

        @Override
        public boolean onHasView() {
            return (mView != null);
        }
    }, this);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method names inside the new FragmentContainer have changed from findViewById to onFindViewById and from hasView to onHasView, and the method attachActivity has been replaced by attachController. This means the code change type is 4,5 representing an Other statement and a Dependent API changed.","There is no Compatibility Issue as the behavior of the method instantiateChildFragmentManager() has not been altered in a way that would lead to a different return type or throw a different exception. The internal implementation changes do not affect the external behavior of instantiateChildFragmentManager(), as the method does not return any value nor does it throw any exceptions. The changes are internal refactorings which are intended to preserve the original behavior."
1000,<android.app.AlertDialog.Builder: AlertDialog create()>,22,23,<android.app.AlertDialog.Builder: AlertDialog create()>,<android.app.AlertDialog.Builder: AlertDialog create()>,0,"{
    final AlertDialog dialog = new AlertDialog(P.mContext, mTheme, false);
    P.apply(dialog.mAlert);
    dialog.setCancelable(P.mCancelable);
    if (P.mCancelable) {
        dialog.setCanceledOnTouchOutside(true);
    }
    dialog.setOnCancelListener(P.mOnCancelListener);
    dialog.setOnDismissListener(P.mOnDismissListener);
    if (P.mOnKeyListener != null) {
        dialog.setOnKeyListener(P.mOnKeyListener);
    }
    return dialog;
}","{
    // Context has already been wrapped with the appropriate theme.
    final AlertDialog dialog = new AlertDialog(P.mContext, 0, false);
    P.apply(dialog.mAlert);
    dialog.setCancelable(P.mCancelable);
    if (P.mCancelable) {
        dialog.setCanceledOnTouchOutside(true);
    }
    dialog.setOnCancelListener(P.mOnCancelListener);
    dialog.setOnDismissListener(P.mOnDismissListener);
    if (P.mOnKeyListener != null) {
        dialog.setOnKeyListener(P.mOnKeyListener);
    }
    return dialog;
}",1,"/**
 * Creates a {@link AlertDialog} with the arguments supplied to this builder. It does not
 * {@link Dialog#show()} the dialog. This allows the user to do any extra processing
 * before displaying the dialog. Use {@link #show()} if you don't have any other processing
 * to do and want this to be created and displayed.
 */
","/**
 * Creates an {@link AlertDialog} with the arguments supplied to this
 * builder.
 * <p>
 * Calling this method does not display the dialog. If no additional
 * processing is needed, {@link #show()} may be called instead to both
 * create and display the dialog.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The constructor of AlertDialog has changed its second parameter from mTheme to 0. No other parts of the code have changed. Thus, the change is 'Other statement changed' and the code change type is 4.","Since the change does not affect the control flow or the method's signature and there's no indication that the change in the theme parameter to AlertDialog's constructor would result in a different return value or throw an exception under conditions that didn't previously, there is no Compatibility Issue. Hence, the CI type is 0."
1001,"<android.content.ContentProviderClient: Bundle call(String,String,Bundle)>",22,23,"<android.content.ContentProviderClient: Bundle call(String,String,Bundle)>","<android.content.ContentProviderClient: Bundle call(String,String,Bundle)>",0,"{
    beforeRemote();
    try {
        return mContentProvider.call(mPackageName, method, arg, extras);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}","{
    Preconditions.checkNotNull(method, ""method"");
    beforeRemote();
    try {
        return mContentProvider.call(mPackageName, method, arg, extras);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}",1,"/**
 * See {@link ContentProvider#call(String, String, Bundle)}
 */
","/**
 * See {@link ContentProvider#call(String, String, Bundle)}
 */
",-1,,[@Nullable],-1,-1,-1,-1,-1,-1,4,0,"The change is the introduction of Preconditions.checkNotNull(method, ""method"") statement before the actual logic of the method starts. This is an assertion to check if the 'method' parameter is not null. It is a precondition check and falls under the category of 'Other statement changed'.","The addition of a precondition check does not change the behavior of the API from the perspective of the caller as long as the precondition is met. If 'method' is null, both the early and late versions would likely result in an exception, though the early version may not throw immediately. The same return values and exceptions would be propagated in case of valid (non-null) 'method' parameter. Therefore, there is no Compatibility Issue detected with the provided change information."
1002,<android.view.accessibility.AccessibilityNodeInfo: void addAction(AccessibilityAction)>,22,23,<android.view.accessibility.AccessibilityNodeInfo: void addAction(AccessibilityAction)>,<android.view.accessibility.AccessibilityNodeInfo: void addAction(AccessibilityAction)>,0,"{
    enforceNotSealed();
    if (action == null) {
        return;
    }
    if (mActions == null) {
        mActions = new ArrayList<AccessibilityAction>();
    }
    mActions.remove(action);
    mActions.add(action);
}","{
    enforceNotSealed();
    addActionUnchecked(action);
}",1,"/**
 * Adds an action that can be performed on the node.
 * <p>
 * To add a standard action use the static constants on {@link AccessibilityAction}.
 * To add a custom action create a new {@link AccessibilityAction} by passing in a
 * resource id from your application as the action id and an optional label that
 * describes the action. To override one of the standard actions use as the action
 * id of a standard action id such as {@link #ACTION_CLICK} and an optional label that
 * describes the action.
 * </p>
 * <p>
 * <strong>Note:</strong> Cannot be called from an
 * {@link android.accessibilityservice.AccessibilityService}.
 * This class is made immutable before being delivered to an AccessibilityService.
 * </p>
 *
 * @param action The action.
 *
 * @throws IllegalStateException If called from an AccessibilityService.
 */
","/**
 * Adds an action that can be performed on the node.
 * <p>
 * To add a standard action use the static constants on {@link AccessibilityAction}.
 * To add a custom action create a new {@link AccessibilityAction} by passing in a
 * resource id from your application as the action id and an optional label that
 * describes the action. To override one of the standard actions use as the action
 * id of a standard action id such as {@link #ACTION_CLICK} and an optional label that
 * describes the action.
 * </p>
 * <p>
 * <strong>Note:</strong> Cannot be called from an
 * {@link android.accessibilityservice.AccessibilityService}.
 * This class is made immutable before being delivered to an AccessibilityService.
 * </p>
 *
 * @param action The action.
 *
 * @throws IllegalStateException If called from an AccessibilityService.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The early version's implementation has an explicit check for null, a creation of an ArrayList if mActions is null, removal and addition to the mActions list. The late version has encapsulated this logic within the addActionUnchecked method. Since there are no details available about the changes inside the addActionUnchecked method itself, this is classified as a code change type 5.","Since the behavior of addActionUnchecked is not provided we cannot determine if there are potential Compatibility Issues. However, based on the provided information, it seems like the code change is merely a refactoring to use a helper method which suggests that the external behavior of the API is intended to remain the same. Therefore, it is classified as no Compatibility Issue (0)."
1003,"<android.app.backup.BackupAgent.BackupServiceBinder: void doRestoreFile(ParcelFileDescriptor,long,int,String,String,long,long,int,IBackupManager)>",22,23,"<android.app.backup.BackupAgent.BackupServiceBinder: void doRestoreFile(ParcelFileDescriptor,long,int,String,String,long,long,int,IBackupManager)>","<android.app.backup.BackupAgent.BackupServiceBinder: void doRestoreFile(ParcelFileDescriptor,long,int,String,String,long,long,int,IBackupManager)>",0,"{
    long ident = Binder.clearCallingIdentity();
    try {
        BackupAgent.this.onRestoreFile(data, size, type, domain, path, mode, mtime);
    } catch (IOException e) {
        throw new RuntimeException(e);
    } finally {
        // Ensure that any side-effect SharedPreferences writes have landed
        waitForSharedPrefs();
        Binder.restoreCallingIdentity(ident);
        try {
            callbackBinder.opComplete(token);
        } catch (RemoteException e) {
        // we'll time out anyway, so we're safe
        }
    }
}","{
    long ident = Binder.clearCallingIdentity();
    try {
        BackupAgent.this.onRestoreFile(data, size, type, domain, path, mode, mtime);
    } catch (IOException e) {
        Log.d(TAG, ""onRestoreFile ("" + BackupAgent.this.getClass().getName() + "") threw"", e);
        throw new RuntimeException(e);
    } finally {
        // Ensure that any side-effect SharedPreferences writes have landed
        waitForSharedPrefs();
        Binder.restoreCallingIdentity(ident);
        try {
            callbackBinder.opComplete(token, 0);
        } catch (RemoteException e) {
        // we'll time out anyway, so we're safe
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The method signature has not changed, and the sequence of calls and exception handling within the method remains the same. However, there is an additional log statement added when an IOException is caught, and there's a change in the `callbackBinder.opComplete(token)` call, with an additional parameter `0` being passed in the late version. So the code change type is 4.","These changes do not affect the control flow or the returned results of the method calls in any existing code paths, as the added log message is for debugging purposes and does not change the behavior from the caller’s perspective, and the additional parameter in the `callbackBinder.opComplete(token, 0)` method call does not change the response from the method as no return value or exception behavior has changed. Therefore, there is no compatibility issue, so the CI type is 0."
1004,<android.widget.TextView: Drawable[] getCompoundDrawablesRelative()>,22,23,<android.widget.TextView: Drawable[] getCompoundDrawablesRelative()>,<android.widget.TextView: Drawable[] getCompoundDrawablesRelative()>,0,"{
    final Drawables dr = mDrawables;
    if (dr != null) {
        return new Drawable[] { dr.mDrawableStart, dr.mDrawableTop, dr.mDrawableEnd, dr.mDrawableBottom };
    } else {
        return new Drawable[] { null, null, null, null };
    }
}","{
    final Drawables dr = mDrawables;
    if (dr != null) {
        return new Drawable[] { dr.mDrawableStart, dr.mShowing[Drawables.TOP], dr.mDrawableEnd, dr.mShowing[Drawables.BOTTOM] };
    } else {
        return new Drawable[] { null, null, null, null };
    }
}",1,"/**
 * Returns drawables for the start, top, end, and bottom borders.
 *
 * @attr ref android.R.styleable#TextView_drawableStart
 * @attr ref android.R.styleable#TextView_drawableTop
 * @attr ref android.R.styleable#TextView_drawableEnd
 * @attr ref android.R.styleable#TextView_drawableBottom
 */
","/**
 * Returns drawables for the start, top, end, and bottom borders.
 *
 * @attr ref android.R.styleable#TextView_drawableStart
 * @attr ref android.R.styleable#TextView_drawableTop
 * @attr ref android.R.styleable#TextView_drawableEnd
 * @attr ref android.R.styleable#TextView_drawableBottom
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed to access array indices from 'dr.mShowing' instead of directly accessing `dr.mDrawableTop` and `dr.mDrawableBottom`, thus the code change type is 1,5.","This change in the return statement will make the API potentially return different Drawable objects for the top and bottom Drawables retrieved from the `dr.mShowing` array instead of the direct member variables, and so the CI type is 1."
1005,<android.content.res.Resources: String getString(int)>,22,23,<android.content.res.Resources: String getString(int)>,<android.content.res.Resources: String getString(int)>,0,"{
    CharSequence res = getText(id);
    if (res != null) {
        return res.toString();
    }
    throw new NotFoundException(""String resource ID #0x"" + Integer.toHexString(id));
}","{
    final CharSequence res = getText(id);
    if (res != null) {
        return res.toString();
    }
    throw new NotFoundException(""String resource ID #0x"" + Integer.toHexString(id));
}",1,"/**
 * Return the string value associated with a particular resource ID.  It
 * will be stripped of any styled text information.
 * {@more}
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @return String The string data associated with the resource,
 * stripped of styled text information.
 */
","/**
 * Return the string value associated with a particular resource ID.  It
 * will be stripped of any styled text information.
 * {@more}
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @return String The string data associated with the resource,
 * stripped of styled text information.
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,4,0,"The code change is only adding the final modifier to the res variable declaration. This change does not alter the control flow, the exception handling, the return statement, or depend on any changed external APIs. Hence, the change type is 4.","The addition of the final modifier to a local variable declaration does not cause any change in behavior externally, so there is no compatibility issue arising from this change."
