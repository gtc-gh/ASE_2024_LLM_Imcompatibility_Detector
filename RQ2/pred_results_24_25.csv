Number,Signature,Early_Version,Late_Version,Early_Signature,Late_Signature,Diff_Signature,Early_Implementation,Late_Implementation,Diff_Implementation,Early_Comment,Late_Comment,Diff_Comment,Early_Annotation,Late_Annotation,Diff_Annotation,Early_Callback,Late_Callback,Diff_Callback,GT_CI_ControlFlow,GT_CI_Type,pred_change,pred_CI,change_description,CI_description
0,<android.service.notification.ZenModeConfig.ScheduleInfo: String toString()>,24,25,<android.service.notification.ZenModeConfig.ScheduleInfo: String toString()>,<android.service.notification.ZenModeConfig.ScheduleInfo: String toString()>,0,"{
    return ""ScheduleInfo{"" + ""days="" + Arrays.toString(days) + "", startHour="" + startHour + "", startMinute="" + startMinute + "", endHour="" + endHour + "", endMinute="" + endMinute + "", exitAtAlarm="" + exitAtAlarm + "", nextAlarm="" + nextAlarm + '}';
}","{
    return ""ScheduleInfo{"" + ""days="" + Arrays.toString(days) + "", startHour="" + startHour + "", startMinute="" + startMinute + "", endHour="" + endHour + "", endMinute="" + endMinute + "", exitAtAlarm="" + exitAtAlarm + "", nextAlarm="" + ts(nextAlarm) + '}';
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The change consists of formatting the representation of the `nextAlarm` field with a new method `ts(nextAlarm)`, which is a string formatting change and does not affect the logic of the code, so the code change type is 4.","There is no compatibility issue because the change is purely in the string format and does not affect the functionality or the logic of the code. It only affects how the `nextAlarm` is represented in the string, which does not lead to a different return value in terms of the behavior from an API usage perspective; it's still a string being returned."
2,<android.widget.GridLayout: LayoutParams generateLayoutParams(LayoutParams)>,24,25,<android.widget.GridLayout: LayoutParams generateLayoutParams(LayoutParams)>,<android.widget.GridLayout: LayoutParams generateLayoutParams(LayoutParams)>,0,"{
    if (lp instanceof LayoutParams) {
        return new LayoutParams((LayoutParams) lp);
    } else if (lp instanceof MarginLayoutParams) {
        return new LayoutParams((MarginLayoutParams) lp);
    } else {
        return new LayoutParams(lp);
    }
}","{
    if (sPreserveMarginParamsInLayoutParamConversion) {
        if (lp instanceof LayoutParams) {
            return new LayoutParams((LayoutParams) lp);
        } else if (lp instanceof MarginLayoutParams) {
            return new LayoutParams((MarginLayoutParams) lp);
        }
    }
    return new LayoutParams(lp);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"The addition of the static boolean check `sPreserveMarginParamsInLayoutParamConversion` in the late version modifies the control flow and adds a control dependency that did not exist in the early version. Furthermore, the lack of an else branch in the late version implies a change in the control flow as well - all three conditions have been put under the if condition which checks `sPreserveMarginParamsInLayoutParamConversion`. This can be classified as both control dependency change (3) and other statement changed (4) because it changes the behavior of how the parameter conversion is handled.","Because the late implementation introduces an additional control dependency with `sPreserveMarginParamsInLayoutParamConversion`, and the final return outside of the control structure will always execute if this new condition evaluates to false, result in an always new LayoutParams(lp) irrespective of lp's type, it creates a potential compatibility issue (CI) by potentially returning different values or types. Thus, the CI type is 1."
3,<android.service.quicksettings.TileService.H: void handleMessage(Message)>,24,25,<android.service.quicksettings.TileService.H: void handleMessage(Message)>,<android.service.quicksettings.TileService.H: void handleMessage(Message)>,0,"{
    switch(msg.what) {
        case MSG_TILE_ADDED:
            TileService.this.onTileAdded();
            break;
        case MSG_TILE_REMOVED:
            if (mListening) {
                mListening = false;
                TileService.this.onStopListening();
            }
            TileService.this.onTileRemoved();
            break;
        case MSG_STOP_LISTENING:
            if (mListening) {
                mListening = false;
                TileService.this.onStopListening();
            }
            break;
        case MSG_START_LISTENING:
            if (!mListening) {
                mListening = true;
                TileService.this.onStartListening();
            }
            break;
        case MSG_TILE_CLICKED:
            mToken = (IBinder) msg.obj;
            TileService.this.onClick();
            break;
        case MSG_UNLOCK_COMPLETE:
            if (mUnlockRunnable != null) {
                mUnlockRunnable.run();
            }
            break;
        case MSG_START_SUCCESS:
            try {
                mService.onStartSuccessful(mTile);
            } catch (RemoteException e) {
            }
            break;
    }
}","{
    switch(msg.what) {
        case MSG_TILE_ADDED:
            TileService.this.onTileAdded();
            break;
        case MSG_TILE_REMOVED:
            if (mListening) {
                mListening = false;
                TileService.this.onStopListening();
            }
            TileService.this.onTileRemoved();
            break;
        case MSG_STOP_LISTENING:
            if (mListening) {
                mListening = false;
                TileService.this.onStopListening();
            }
            break;
        case MSG_START_LISTENING:
            if (!mListening) {
                mListening = true;
                TileService.this.onStartListening();
            }
            break;
        case MSG_TILE_CLICKED:
            mToken = (IBinder) msg.obj;
            TileService.this.onClick();
            break;
        case MSG_UNLOCK_COMPLETE:
            if (mUnlockRunnable != null) {
                mUnlockRunnable.run();
            }
            break;
        case MSG_START_SUCCESS:
            try {
                mService.onStartSuccessful(mTileToken);
            } catch (RemoteException e) {
            }
            break;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"There is a modification in the dependent method's parameter from mTile to mTileToken in the case MSG_START_SUCCESS, and it is a change in the dependent API as there is no definition provided whether mTileToken is equivalent to mTile or not. So, the code change type is 4,5.","As there is no change to the return statements, exception handling, or the control flow within this API, and since we don't have the details about the changes in the dependent API or how the mTileToken and mTile are related (they could potentially represent the same data), we do not have enough information to determine if this necessarily leads to a Compatibility Issue. Thus, the CI type is 0."
5,"<android.nfc.NfcAdapter: void setNdefPushMessageCallback(CreateNdefMessageCallback,Activity,Activity)>",24,25,"<android.nfc.NfcAdapter: void setNdefPushMessageCallback(CreateNdefMessageCallback,Activity,Activity)>","<android.nfc.NfcAdapter: void setNdefPushMessageCallback(CreateNdefMessageCallback,Activity,Activity)>",0,"{
    int targetSdkVersion = getSdkVersion();
    try {
        if (activity == null) {
            throw new NullPointerException(""activity cannot be null"");
        }
        mNfcActivityManager.setNdefPushMessageCallback(activity, callback, 0);
        for (Activity a : activities) {
            if (a == null) {
                throw new NullPointerException(""activities cannot contain null"");
            }
            mNfcActivityManager.setNdefPushMessageCallback(a, callback, 0);
        }
    } catch (IllegalStateException e) {
        if (targetSdkVersion < android.os.Build.VERSION_CODES.JELLY_BEAN) {
            // Less strict on old applications - just log the error
            Log.e(TAG, ""Cannot call API with Activity that has already "" + ""been destroyed"", e);
        } else {
            // Prevent new applications from making this mistake, re-throw
            throw (e);
        }
    }
}","{
    synchronized (NfcAdapter.class) {
        if (!sHasNfcFeature) {
            throw new UnsupportedOperationException();
        }
    }
    int targetSdkVersion = getSdkVersion();
    try {
        if (activity == null) {
            throw new NullPointerException(""activity cannot be null"");
        }
        mNfcActivityManager.setNdefPushMessageCallback(activity, callback, 0);
        for (Activity a : activities) {
            if (a == null) {
                throw new NullPointerException(""activities cannot contain null"");
            }
            mNfcActivityManager.setNdefPushMessageCallback(a, callback, 0);
        }
    } catch (IllegalStateException e) {
        if (targetSdkVersion < android.os.Build.VERSION_CODES.JELLY_BEAN) {
            // Less strict on old applications - just log the error
            Log.e(TAG, ""Cannot call API with Activity that has already "" + ""been destroyed"", e);
        } else {
            // Prevent new applications from making this mistake, re-throw
            throw (e);
        }
    }
}",1,"/**
 * Set a callback that dynamically generates NDEF messages to send using Android Beam (TM).
 *
 * <p>This method may be called at any time before {@link Activity#onDestroy},
 * but the NDEF message callback can only occur when the
 * specified activity(s) are in resumed (foreground) state. The recommended
 * approach is to call this method during your Activity's
 * {@link Activity#onCreate} - see sample
 * code below. This method does not immediately perform any I/O or blocking work,
 * so is safe to call on your main thread.
 *
 * <p>Only one NDEF message can be pushed by the currently resumed activity.
 * If both {@link #setNdefPushMessage} and
 * {@link #setNdefPushMessageCallback} are set, then
 * the callback will take priority.
 *
 * <p>If neither {@link #setNdefPushMessage} or
 * {@link #setNdefPushMessageCallback} have been called for your activity, then
 * the Android OS may choose to send a default NDEF message on your behalf,
 * such as a URI for your application.
 *
 * <p>If {@link #setNdefPushMessage} is called with a null NDEF message,
 * and/or {@link #setNdefPushMessageCallback} is called with a null callback,
 * then NDEF push will be completely disabled for the specified activity(s).
 * This also disables any default NDEF message the Android OS would have
 * otherwise sent on your behalf for those activity(s).
 *
 * <p>If you want to prevent the Android OS from sending default NDEF
 * messages completely (for all activities), you can include a
 * {@code <meta-data>} element inside the {@code <application>}
 * element of your AndroidManifest.xml file, like this:
 * <pre>
 * &lt;application ...>
 * &lt;meta-data android:name=""android.nfc.disable_beam_default""
 * android:value=""true"" />
 * &lt;/application></pre>
 *
 * <p>The API allows for multiple activities to be specified at a time,
 * but it is strongly recommended to just register one at a time,
 * and to do so during the activity's {@link Activity#onCreate}. For example:
 * <pre>
 * protected void onCreate(Bundle savedInstanceState) {
 * super.onCreate(savedInstanceState);
 * NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
 * if (nfcAdapter == null) return;  // NFC not available on this device
 * nfcAdapter.setNdefPushMessageCallback(callback, this);
 * }</pre>
 * And that is it. Only one call per activity is necessary. The Android
 * OS will automatically release its references to the callback and the
 * Activity object when it is destroyed if you follow this pattern.
 *
 * <p class=""note"">Do not pass in an Activity that has already been through
 * {@link Activity#onDestroy}. This is guaranteed if you call this API
 * during {@link Activity#onCreate}.
 * <p class=""note"">For sending large content such as pictures and songs,
 * consider using {@link #setBeamPushUris}, which switches to alternate transports
 * such as Bluetooth to achieve a fast transfer rate.
 * <p class=""note"">Requires the {@link android.Manifest.permission#NFC} permission.
 *
 * @param callback callback, or null to disable
 * @param activity activity for which the NDEF message will be pushed
 * @param activities optional additional activities, however we strongly recommend
 * to only register one at a time, and to do so in that activity's
 * {@link Activity#onCreate}
 */
","/**
 * Set a callback that dynamically generates NDEF messages to send using Android Beam (TM).
 *
 * <p>This method may be called at any time before {@link Activity#onDestroy},
 * but the NDEF message callback can only occur when the
 * specified activity(s) are in resumed (foreground) state. The recommended
 * approach is to call this method during your Activity's
 * {@link Activity#onCreate} - see sample
 * code below. This method does not immediately perform any I/O or blocking work,
 * so is safe to call on your main thread.
 *
 * <p>Only one NDEF message can be pushed by the currently resumed activity.
 * If both {@link #setNdefPushMessage} and
 * {@link #setNdefPushMessageCallback} are set, then
 * the callback will take priority.
 *
 * <p>If neither {@link #setNdefPushMessage} or
 * {@link #setNdefPushMessageCallback} have been called for your activity, then
 * the Android OS may choose to send a default NDEF message on your behalf,
 * such as a URI for your application.
 *
 * <p>If {@link #setNdefPushMessage} is called with a null NDEF message,
 * and/or {@link #setNdefPushMessageCallback} is called with a null callback,
 * then NDEF push will be completely disabled for the specified activity(s).
 * This also disables any default NDEF message the Android OS would have
 * otherwise sent on your behalf for those activity(s).
 *
 * <p>If you want to prevent the Android OS from sending default NDEF
 * messages completely (for all activities), you can include a
 * {@code <meta-data>} element inside the {@code <application>}
 * element of your AndroidManifest.xml file, like this:
 * <pre>
 * &lt;application ...>
 * &lt;meta-data android:name=""android.nfc.disable_beam_default""
 * android:value=""true"" />
 * &lt;/application></pre>
 *
 * <p>The API allows for multiple activities to be specified at a time,
 * but it is strongly recommended to just register one at a time,
 * and to do so during the activity's {@link Activity#onCreate}. For example:
 * <pre>
 * protected void onCreate(Bundle savedInstanceState) {
 * super.onCreate(savedInstanceState);
 * NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
 * if (nfcAdapter == null) return;  // NFC not available on this device
 * nfcAdapter.setNdefPushMessageCallback(callback, this);
 * }</pre>
 * And that is it. Only one call per activity is necessary. The Android
 * OS will automatically release its references to the callback and the
 * Activity object when it is destroyed if you follow this pattern.
 *
 * <p class=""note"">Do not pass in an Activity that has already been through
 * {@link Activity#onDestroy}. This is guaranteed if you call this API
 * during {@link Activity#onCreate}.
 * <p class=""note"">For sending large content such as pictures and songs,
 * consider using {@link #setBeamPushUris}, which switches to alternate transports
 * such as Bluetooth to achieve a fast transfer rate.
 * <p class=""note"">Requires the {@link android.Manifest.permission#NFC} permission.
 *
 * @param callback callback, or null to disable
 * @param activity activity for which the NDEF message will be pushed
 * @param activities optional additional activities, however we strongly recommend
 * to only register one at a time, and to do so in that activity's
 * {@link Activity#onCreate}
 * @throws UnsupportedOperationException if FEATURE_NFC is unavailable.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",2,"A synchronized block that includes a check for NFC feature support has been added. This is a change in control dependency (3) as it introduces a new conditional block that can potentially affect the flow of the method. Additionally, it throws a new exception, UnsupportedOperationException, if the NFC feature is not present, thus it is also classified as other statements change (4).","This change can potentially lead to a different exception being thrown (UnsupportedOperationException) if the NFC feature is not available on the device, impacting how the method behaves. Consequently, the CI type is 2, since it's a change in the way exceptions may be handled."
7,"<android.app.WallpaperManager: int setStream(InputStream,Rect,boolean,int)>",24,25,"<android.app.WallpaperManager: int setStream(InputStream,Rect,boolean,int)>","<android.app.WallpaperManager: int setStream(InputStream,Rect,boolean,int)>",0,"{
    validateRect(visibleCropHint);
    if (sGlobals.mService == null) {
        Log.w(TAG, ""WallpaperService not running"");
        throw new RuntimeException(new DeadSystemException());
    }
    final Bundle result = new Bundle();
    final WallpaperSetCompletion completion = new WallpaperSetCompletion();
    try {
        ParcelFileDescriptor fd = sGlobals.mService.setWallpaper(null, mContext.getOpPackageName(), visibleCropHint, allowBackup, result, which, completion);
        if (fd != null) {
            FileOutputStream fos = null;
            try {
                fos = new ParcelFileDescriptor.AutoCloseOutputStream(fd);
                copyStreamToWallpaperFile(bitmapData, fos);
                fos.close();
                completion.waitForCompletion();
            } finally {
                IoUtils.closeQuietly(fos);
            }
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
    return result.getInt(EXTRA_NEW_WALLPAPER_ID, 0);
}","{
    validateRect(visibleCropHint);
    if (sGlobals.mService == null) {
        Log.w(TAG, ""WallpaperService not running"");
        throw new RuntimeException(new DeadSystemException());
    }
    final Bundle result = new Bundle();
    final WallpaperSetCompletion completion = new WallpaperSetCompletion();
    try {
        ParcelFileDescriptor fd = sGlobals.mService.setWallpaper(null, mContext.getOpPackageName(), visibleCropHint, allowBackup, result, which, completion, UserHandle.myUserId());
        if (fd != null) {
            FileOutputStream fos = null;
            try {
                fos = new ParcelFileDescriptor.AutoCloseOutputStream(fd);
                copyStreamToWallpaperFile(bitmapData, fos);
                fos.close();
                completion.waitForCompletion();
            } finally {
                IoUtils.closeQuietly(fos);
            }
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
    return result.getInt(EXTRA_NEW_WALLPAPER_ID, 0);
}",1,"/**
 * Version of {@link #setStream(InputStream, Rect, boolean)} that allows the caller
 * to specify which of the supported wallpaper categories to set.
 *
 * @param bitmapData A stream containing the raw data to install as a wallpaper.  This
 * data can be in any format handled by {@link BitmapRegionDecoder}.
 * @param visibleCropHint The rectangular subregion of the streamed image that should be
 * displayed as wallpaper.  Passing {@code null} for this parameter means that
 * the full image should be displayed if possible given the image's and device's
 * aspect ratios, etc.
 * @param allowBackup {@code true} if the OS is permitted to back up this wallpaper
 * image for restore to a future device; {@code false} otherwise.
 * @param which Flags indicating which wallpaper(s) to configure with the new imagery.
 * @return An integer ID assigned to the newly active wallpaper; or zero on failure.
 *
 * @see #getWallpaperId(int)
 * @see #FLAG_LOCK
 * @see #FLAG_SYSTEM
 *
 * @throws IOException
 */
","/**
 * Version of {@link #setStream(InputStream, Rect, boolean)} that allows the caller
 * to specify which of the supported wallpaper categories to set.
 *
 * @param bitmapData A stream containing the raw data to install as a wallpaper.  This
 * data can be in any format handled by {@link BitmapRegionDecoder}.
 * @param visibleCropHint The rectangular subregion of the streamed image that should be
 * displayed as wallpaper.  Passing {@code null} for this parameter means that
 * the full image should be displayed if possible given the image's and device's
 * aspect ratios, etc.
 * @param allowBackup {@code true} if the OS is permitted to back up this wallpaper
 * image for restore to a future device; {@code false} otherwise.
 * @param which Flags indicating which wallpaper(s) to configure with the new imagery.
 * @return An integer ID assigned to the newly active wallpaper; or zero on failure.
 *
 * @see #getWallpaperId(int)
 * @see #FLAG_LOCK
 * @see #FLAG_SYSTEM
 *
 * @throws IOException
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The change is in a method call to sGlobals.mService.setWallpaper(), where an additional argument (`UserHandle.myUserId()`) is added in the late implementation. Therefore, the change is of type 5 which indicates that a Dependent API has changed.","There is no Compatibility Issue detected because there is no change in return statements, exception handling, or control dependency that could affect the behavior of the setStream(...) method from the user perspective. The additional parameter appears to be an internal detail of how setWallpaper(...) is called and should not affect the outcome of calling setStream(...), assuming that the method handles this additional value correctly internally. Thus, no CI is detected (type 0)."
9,"<android.app.WallpaperManager: int setBitmap(Bitmap,Rect,boolean,int)>",24,25,"<android.app.WallpaperManager: int setBitmap(Bitmap,Rect,boolean,int)>","<android.app.WallpaperManager: int setBitmap(Bitmap,Rect,boolean,int)>",0,"{
    validateRect(visibleCropHint);
    if (sGlobals.mService == null) {
        Log.w(TAG, ""WallpaperService not running"");
        throw new RuntimeException(new DeadSystemException());
    }
    final Bundle result = new Bundle();
    final WallpaperSetCompletion completion = new WallpaperSetCompletion();
    try {
        ParcelFileDescriptor fd = sGlobals.mService.setWallpaper(null, mContext.getOpPackageName(), visibleCropHint, allowBackup, result, which, completion);
        if (fd != null) {
            FileOutputStream fos = null;
            try {
                fos = new ParcelFileDescriptor.AutoCloseOutputStream(fd);
                fullImage.compress(Bitmap.CompressFormat.PNG, 90, fos);
                fos.close();
                completion.waitForCompletion();
            } finally {
                IoUtils.closeQuietly(fos);
            }
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
    return result.getInt(EXTRA_NEW_WALLPAPER_ID, 0);
}","{
    return setBitmap(fullImage, visibleCropHint, allowBackup, which, UserHandle.myUserId());
}",1,"/**
 * Version of {@link #setBitmap(Bitmap, Rect, boolean)} that allows the caller
 * to specify which of the supported wallpaper categories to set.
 *
 * @param fullImage A bitmap that will supply the wallpaper imagery.
 * @param visibleCropHint The rectangular subregion of {@code fullImage} that should be
 * displayed as wallpaper.  Passing {@code null} for this parameter means that
 * the full image should be displayed if possible given the image's and device's
 * aspect ratios, etc.
 * @param allowBackup {@code true} if the OS is permitted to back up this wallpaper
 * image for restore to a future device; {@code false} otherwise.
 * @param which Flags indicating which wallpaper(s) to configure with the new imagery.
 *
 * @see #FLAG_LOCK
 * @see #FLAG_SYSTEM
 *
 * @return An integer ID assigned to the newly active wallpaper; or zero on failure.
 *
 * @throws IOException
 */
","/**
 * Version of {@link #setBitmap(Bitmap, Rect, boolean)} that allows the caller
 * to specify which of the supported wallpaper categories to set.
 *
 * @param fullImage A bitmap that will supply the wallpaper imagery.
 * @param visibleCropHint The rectangular subregion of {@code fullImage} that should be
 * displayed as wallpaper.  Passing {@code null} for this parameter means that
 * the full image should be displayed if possible given the image's and device's
 * aspect ratios, etc.
 * @param allowBackup {@code true} if the OS is permitted to back up this wallpaper
 * image for restore to a future device; {@code false} otherwise.
 * @param which Flags indicating which wallpaper(s) to configure with the new imagery.
 *
 * @see #FLAG_LOCK
 * @see #FLAG_SYSTEM
 *
 * @return An integer ID assigned to the newly active wallpaper; or zero on failure.
 *
 * @throws IOException
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The early version of code directly implemented the logic of setting the bitmap, while the late version delegates this task to another method within the same class. As the internal implementation of the method setBitmap(Bitmap, Rect, boolean, int, int) is not provided, we assume that the internal operations have changed. Additionally, there is a change in the method called (from inlined code to a single method call), so the change types are 1 and 5.","The compatibility issue arises because the return value now depends on another overloaded method, setBitmap(Bitmap, Rect, boolean, int, int), which could have a different implementation, potentially leading to different return values. Since the actual implementation of the delegated method is not provided, it's assumed there could be different behavior, so the CI type is 1."
11,<android.widget.DatePickerCalendarDelegate: void onLocaleChanged(Locale)>,24,25,<android.widget.DatePickerCalendarDelegate: void onLocaleChanged(Locale)>,<android.widget.DatePickerCalendarDelegate: void onLocaleChanged(Locale)>,0,"{
    final TextView headerYear = mHeaderYear;
    if (headerYear == null) {
        // again later after everything has been set up.
        return;
    }
    // Update the date formatter.
    final String datePattern = DateFormat.getBestDateTimePattern(locale, ""EMMMd"");
    mMonthDayFormat = new SimpleDateFormat(datePattern, locale);
    mMonthDayFormat.setContext(DisplayContext.CAPITALIZATION_FOR_STANDALONE);
    mYearFormat = new SimpleDateFormat(""y"", locale);
    // Update the header text.
    onCurrentDateChanged(false);
}","{
    final TextView headerYear = mHeaderYear;
    if (headerYear == null) {
        // again later after everything has been set up.
        return;
    }
    // Update the date formatter.
    final String datePattern = DateFormat.getBestDateTimePattern(locale, ""EMMMd"");
    mMonthDayFormat = new SimpleDateFormat(datePattern, locale);
    mMonthDayFormat.setContext(DisplayContext.CAPITALIZATION_FOR_STANDALONE);
    mYearFormat = new SimpleDateFormat(""y"", locale);
    // Clear out the lazily-initialized accessibility event formatter.
    mAccessibilityEventFormat = null;
    // Update the header text.
    onCurrentDateChanged(false);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"A new statement `mAccessibilityEventFormat = null;` is added in the late version which is not a return, exception handling, or control dependency change, so the code change type is 4.","This addition of setting `mAccessibilityEventFormat` to null doesn't affect the return value nor does it involve any exception handling. Thus, there is no compatibility issue, and the CI type is 0."
12,"<android.accessibilityservice.AccessibilityService: boolean dispatchGesture(GestureDescription,GestureResultCallback,Handler)>",24,25,"<android.accessibilityservice.AccessibilityService: boolean dispatchGesture(GestureDescription,GestureResultCallback,Handler)>","<android.accessibilityservice.AccessibilityService: boolean dispatchGesture(GestureDescription,GestureResultCallback,Handler)>",0,"{
    final IAccessibilityServiceConnection connection = AccessibilityInteractionClient.getInstance().getConnection(mConnectionId);
    if (connection == null) {
        return false;
    }
    List<MotionEvent> events = MotionEventGenerator.getMotionEventsFromGestureDescription(gesture, 100);
    try {
        synchronized (mLock) {
            mGestureStatusCallbackSequence++;
            if (callback != null) {
                if (mGestureStatusCallbackInfos == null) {
                    mGestureStatusCallbackInfos = new SparseArray<>();
                }
                GestureResultCallbackInfo callbackInfo = new GestureResultCallbackInfo(gesture, callback, handler);
                mGestureStatusCallbackInfos.put(mGestureStatusCallbackSequence, callbackInfo);
            }
            connection.sendMotionEvents(mGestureStatusCallbackSequence, new ParceledListSlice<>(events));
        }
    } catch (RemoteException re) {
        throw new RuntimeException(re);
    }
    return true;
}","{
    final IAccessibilityServiceConnection connection = AccessibilityInteractionClient.getInstance().getConnection(mConnectionId);
    if (connection == null) {
        return false;
    }
    List<GestureDescription.GestureStep> steps = MotionEventGenerator.getGestureStepsFromGestureDescription(gesture, 100);
    try {
        synchronized (mLock) {
            mGestureStatusCallbackSequence++;
            if (callback != null) {
                if (mGestureStatusCallbackInfos == null) {
                    mGestureStatusCallbackInfos = new SparseArray<>();
                }
                GestureResultCallbackInfo callbackInfo = new GestureResultCallbackInfo(gesture, callback, handler);
                mGestureStatusCallbackInfos.put(mGestureStatusCallbackSequence, callbackInfo);
            }
            connection.sendGesture(mGestureStatusCallbackSequence, new ParceledListSlice<>(steps));
        }
    } catch (RemoteException re) {
        throw new RuntimeException(re);
    }
    return true;
}",1,"/**
 * Dispatch a gesture to the touch screen. Any gestures currently in progress, whether from
 * the user, this service, or another service, will be cancelled.
 * <p>
 * The gesture will be dispatched as if it were performed directly on the screen by a user, so
 * the events may be affected by features such as magnification and explore by touch.
 * </p>
 * <p>
 * <strong>Note:</strong> In order to dispatch gestures, your service
 * must declare the capability by setting the
 * {@link android.R.styleable#AccessibilityService_canPerformGestures}
 * property in its meta-data. For more information, see
 * {@link #SERVICE_META_DATA}.
 * </p>
 *
 * @param gesture The gesture to dispatch
 * @param callback The object to call back when the status of the gesture is known. If
 * {@code null}, no status is reported.
 * @param handler The handler on which to call back the {@code callback} object. If
 * {@code null}, the object is called back on the service's main thread.
 *
 * @return {@code true} if the gesture is dispatched, {@code false} if not.
 */
","/**
 * Dispatch a gesture to the touch screen. Any gestures currently in progress, whether from
 * the user, this service, or another service, will be cancelled.
 * <p>
 * The gesture will be dispatched as if it were performed directly on the screen by a user, so
 * the events may be affected by features such as magnification and explore by touch.
 * </p>
 * <p>
 * <strong>Note:</strong> In order to dispatch gestures, your service
 * must declare the capability by setting the
 * {@link android.R.styleable#AccessibilityService_canPerformGestures}
 * property in its meta-data. For more information, see
 * {@link #SERVICE_META_DATA}.
 * </p>
 *
 * @param gesture The gesture to dispatch
 * @param callback The object to call back when the status of the gesture is known. If
 * {@code null}, no status is reported.
 * @param handler The handler on which to call back the {@code callback} object. If
 * {@code null}, the object is called back on the service's main thread.
 *
 * @return {@code true} if the gesture is dispatched, {@code false} if not.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The code change includes changing the method from ""sendMotionEvents"" to ""sendGesture"", and the type of data sent has changed from a list of ""MotionEvent"" to a list of ""GestureDescription.GestureStep"". The variable 'events' was changed to 'steps' and the data it contains is different. These changes indicate different other statement changes and dependent API change, so the code change types are 4,5.","Despite the change in the method and data types used, it does not necessarily result in a potential difference in return value or exception handling since the high-level behavior remains the same: dispatching a gesture. This change adapts the way the gesture information is packaged but does not inherently modify the method contract or expected outcomes. Therefore, there are no Compatibility Issues in the return values or exception handling, so the CI type is 0."
13,<android.nfc.NfcAdapter: boolean isNdefPushEnabled()>,24,25,<android.nfc.NfcAdapter: boolean isNdefPushEnabled()>,<android.nfc.NfcAdapter: boolean isNdefPushEnabled()>,0,"{
    try {
        return sService.isNdefPushEnabled();
    } catch (RemoteException e) {
        attemptDeadServiceRecovery(e);
        return false;
    }
}","{
    synchronized (NfcAdapter.class) {
        if (!sHasNfcFeature) {
            throw new UnsupportedOperationException();
        }
    }
    try {
        return sService.isNdefPushEnabled();
    } catch (RemoteException e) {
        attemptDeadServiceRecovery(e);
        return false;
    }
}",1,"/**
 * Return true if the NDEF Push (Android Beam) feature is enabled.
 * <p>This function will return true only if both NFC is enabled, and the
 * NDEF Push feature is enabled.
 * <p>Note that if NFC is enabled but NDEF Push is disabled then this
 * device can still <i>receive</i> NDEF messages, it just cannot send them.
 * <p>Applications cannot directly toggle the NDEF Push feature, but they
 * can request Settings UI allowing the user to toggle NDEF Push using
 * <code>startActivity(new Intent(Settings.ACTION_NFCSHARING_SETTINGS))</code>
 * <p>Example usage in an Activity that requires NDEF Push:
 * <p><pre>
 * protected void onResume() {
 * super.onResume();
 * if (!nfcAdapter.isEnabled()) {
 * startActivity(new Intent(Settings.ACTION_NFC_SETTINGS));
 * } else if (!nfcAdapter.isNdefPushEnabled()) {
 * startActivity(new Intent(Settings.ACTION_NFCSHARING_SETTINGS));
 * }
 * }</pre>
 *
 * @see android.provider.Settings#ACTION_NFCSHARING_SETTINGS
 * @return true if NDEF Push feature is enabled
 */
","/**
 * Return true if the NDEF Push (Android Beam) feature is enabled.
 * <p>This function will return true only if both NFC is enabled, and the
 * NDEF Push feature is enabled.
 * <p>Note that if NFC is enabled but NDEF Push is disabled then this
 * device can still <i>receive</i> NDEF messages, it just cannot send them.
 * <p>Applications cannot directly toggle the NDEF Push feature, but they
 * can request Settings UI allowing the user to toggle NDEF Push using
 * <code>startActivity(new Intent(Settings.ACTION_NFCSHARING_SETTINGS))</code>
 * <p>Example usage in an Activity that requires NDEF Push:
 * <p><pre>
 * protected void onResume() {
 * super.onResume();
 * if (!nfcAdapter.isEnabled()) {
 * startActivity(new Intent(Settings.ACTION_NFC_SETTINGS));
 * } else if (!nfcAdapter.isNdefPushEnabled()) {
 * startActivity(new Intent(Settings.ACTION_NFCSHARING_SETTINGS));
 * }
 * }</pre>
 *
 * @see android.provider.Settings#ACTION_NFCSHARING_SETTINGS
 * @return true if NDEF Push feature is enabled
 * @throws UnsupportedOperationException if FEATURE_NFC is unavailable.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The addition of a synchronized block to check the NFC feature availability (`if (!sHasNfcFeature)`) is classified as 3 (control dependency changed) because it introduces a new control structure that could affect the flow of the method. A new exception (`UnsupportedOperationException`) is also being thrown if the condition is satisfied, but this does not affect the existing behavior when NFC is supported because it is merely a precondition check. The rest of the code remains the same. There is no change in the existing control flow related to how the method returns values or throws exceptions once it is past the new check, hence it's also classified as 4 (other statement changed) due to the addition of a new checking mechanism.","There is no Compatibility Issue because the added check only throws a new exception in a case that would have previously not been functional (when NFC is not supported on the device). It could be argued that the new exception represents a different behavior, but it's enforcing an existing contract where NFC functionality should not be expected on devices without NFC support. Clients using this method on such devices would be impacted, but the change aligns with standard practice to fail fast for unsupported operations. Since it does not affect existing, valid use cases, it does not constitute a compatibility issue in the typical use of this API."
15,<android.nfc.NfcAdapter: void disableReaderMode(Activity)>,24,25,<android.nfc.NfcAdapter: void disableReaderMode(Activity)>,<android.nfc.NfcAdapter: void disableReaderMode(Activity)>,0,"{
    mNfcActivityManager.disableReaderMode(activity);
}","{
    synchronized (NfcAdapter.class) {
        if (!sHasNfcFeature) {
            throw new UnsupportedOperationException();
        }
    }
    mNfcActivityManager.disableReaderMode(activity);
}",1,"/**
 * Restore the NFC adapter to normal mode of operation: supporting
 * peer-to-peer (Android Beam), card emulation, and polling for
 * all supported tag technologies.
 *
 * @param activity the Activity that currently has reader mode enabled
 */
","/**
 * Restore the NFC adapter to normal mode of operation: supporting
 * peer-to-peer (Android Beam), card emulation, and polling for
 * all supported tag technologies.
 *
 * @param activity the Activity that currently has reader mode enabled
 * @throws UnsupportedOperationException if FEATURE_NFC is unavailable.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",2,"The code change includes addition of a synchronized block and exception throw statement (throw new UnsupportedOperationException()), so the change type is 3,4.","The late version throws a new exception (UnsupportedOperationException) if the condition is met, which is a change in exception handling from the early version. Thus, the CI type is 2."
16,"<android.nfc.NfcAdapter: void enableReaderMode(Activity,ReaderCallback,int,Bundle)>",24,25,"<android.nfc.NfcAdapter: void enableReaderMode(Activity,ReaderCallback,int,Bundle)>","<android.nfc.NfcAdapter: void enableReaderMode(Activity,ReaderCallback,int,Bundle)>",0,"{
    mNfcActivityManager.enableReaderMode(activity, callback, flags, extras);
}","{
    synchronized (NfcAdapter.class) {
        if (!sHasNfcFeature) {
            throw new UnsupportedOperationException();
        }
    }
    mNfcActivityManager.enableReaderMode(activity, callback, flags, extras);
}",1,"/**
 * Limit the NFC controller to reader mode while this Activity is in the foreground.
 *
 * <p>In this mode the NFC controller will only act as an NFC tag reader/writer,
 * thus disabling any peer-to-peer (Android Beam) and card-emulation modes of
 * the NFC adapter on this device.
 *
 * <p>Use {@link #FLAG_READER_SKIP_NDEF_CHECK} to prevent the platform from
 * performing any NDEF checks in reader mode. Note that this will prevent the
 * {@link Ndef} tag technology from being enumerated on the tag, and that
 * NDEF-based tag dispatch will not be functional.
 *
 * <p>For interacting with tags that are emulated on another Android device
 * using Android's host-based card-emulation, the recommended flags are
 * {@link #FLAG_READER_NFC_A} and {@link #FLAG_READER_SKIP_NDEF_CHECK}.
 *
 * @param activity the Activity that requests the adapter to be in reader mode
 * @param callback the callback to be called when a tag is discovered
 * @param flags Flags indicating poll technologies and other optional parameters
 * @param extras Additional extras for configuring reader mode.
 */
","/**
 * Limit the NFC controller to reader mode while this Activity is in the foreground.
 *
 * <p>In this mode the NFC controller will only act as an NFC tag reader/writer,
 * thus disabling any peer-to-peer (Android Beam) and card-emulation modes of
 * the NFC adapter on this device.
 *
 * <p>Use {@link #FLAG_READER_SKIP_NDEF_CHECK} to prevent the platform from
 * performing any NDEF checks in reader mode. Note that this will prevent the
 * {@link Ndef} tag technology from being enumerated on the tag, and that
 * NDEF-based tag dispatch will not be functional.
 *
 * <p>For interacting with tags that are emulated on another Android device
 * using Android's host-based card-emulation, the recommended flags are
 * {@link #FLAG_READER_NFC_A} and {@link #FLAG_READER_SKIP_NDEF_CHECK}.
 *
 * @param activity the Activity that requests the adapter to be in reader mode
 * @param callback the callback to be called when a tag is discovered
 * @param flags Flags indicating poll technologies and other optional parameters
 * @param extras Additional extras for configuring reader mode.
 * @throws UnsupportedOperationException if FEATURE_NFC is unavailable.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,There is both a control dependency change and an exception handling statement change. The control dependency is the addition of a synchronized block and a condition check to see if NFC feature is available. The exception handling change is the addition of the throw statement inside the new synchronized block.,"Because of the added throw statement for checking if NFC feature is present, the late version of the API may throw a new exception (UnsupportedOperationException) that the early version did not. Therefore, there is a Compatibility Issue caused by potential different exception handlings."
17,<android.service.quicksettings.TileService: IBinder onBind(Intent)>,24,25,<android.service.quicksettings.TileService: IBinder onBind(Intent)>,<android.service.quicksettings.TileService: IBinder onBind(Intent)>,0,"{
    mService = IQSService.Stub.asInterface(intent.getIBinderExtra(EXTRA_SERVICE));
    try {
        ComponentName component = intent.getParcelableExtra(EXTRA_COMPONENT);
        mTile = mService.getTile(component);
    } catch (RemoteException e) {
        throw new RuntimeException(""Unable to reach IQSService"", e);
    }
    if (mTile != null) {
        mTile.setService(mService);
        mHandler.sendEmptyMessage(H.MSG_START_SUCCESS);
    }
    return new IQSTileService.Stub() {

        @Override
        public void onTileRemoved() throws RemoteException {
            mHandler.sendEmptyMessage(H.MSG_TILE_REMOVED);
        }

        @Override
        public void onTileAdded() throws RemoteException {
            mHandler.sendEmptyMessage(H.MSG_TILE_ADDED);
        }

        @Override
        public void onStopListening() throws RemoteException {
            mHandler.sendEmptyMessage(H.MSG_STOP_LISTENING);
        }

        @Override
        public void onStartListening() throws RemoteException {
            mHandler.sendEmptyMessage(H.MSG_START_LISTENING);
        }

        @Override
        public void onClick(IBinder wtoken) throws RemoteException {
            mHandler.obtainMessage(H.MSG_TILE_CLICKED, wtoken).sendToTarget();
        }

        @Override
        public void onUnlockComplete() throws RemoteException {
            mHandler.sendEmptyMessage(H.MSG_UNLOCK_COMPLETE);
        }
    };
}","{
    mService = IQSService.Stub.asInterface(intent.getIBinderExtra(EXTRA_SERVICE));
    mTileToken = intent.getIBinderExtra(EXTRA_TOKEN);
    try {
        mTile = mService.getTile(mTileToken);
    } catch (RemoteException e) {
        throw new RuntimeException(""Unable to reach IQSService"", e);
    }
    if (mTile != null) {
        mTile.setService(mService, mTileToken);
        mHandler.sendEmptyMessage(H.MSG_START_SUCCESS);
    }
    return new IQSTileService.Stub() {

        @Override
        public void onTileRemoved() throws RemoteException {
            mHandler.sendEmptyMessage(H.MSG_TILE_REMOVED);
        }

        @Override
        public void onTileAdded() throws RemoteException {
            mHandler.sendEmptyMessage(H.MSG_TILE_ADDED);
        }

        @Override
        public void onStopListening() throws RemoteException {
            mHandler.sendEmptyMessage(H.MSG_STOP_LISTENING);
        }

        @Override
        public void onStartListening() throws RemoteException {
            mHandler.sendEmptyMessage(H.MSG_START_LISTENING);
        }

        @Override
        public void onClick(IBinder wtoken) throws RemoteException {
            mHandler.obtainMessage(H.MSG_TILE_CLICKED, wtoken).sendToTarget();
        }

        @Override
        public void onUnlockComplete() throws RemoteException {
            mHandler.sendEmptyMessage(H.MSG_UNLOCK_COMPLETE);
        }
    };
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The code changes involve the way the tile service is accessed; a new local variable `mTileToken` is used to get the tile from `mService` and then it's used to set the service on the tile object through `mTile.setService(mService, mTileToken);` instead of just `mTile.setService(mService);`. This means that a dependent API `setService()` is now being invoked with an additional parameter `mTileToken`. Additionally, the component name is replaced with the `mTileToken` to obtain `mTile`. However, these modifications do not alter the `onBind(Intent)` method's control flow nor its return type; thus, they are not CI related to return values or exception handlings.","There is no Compatibility Issue since the `onBind(Intent)` method's return type and any exception it may throw remain consistent between the two versions. The return type is still an `IBinder` and the exception thrown in case of a `RemoteException` is still a `RuntimeException`. The inner workings of the method execution have changed, but they do not affect the method's contract with its callers."
18,"<android.view.Choreographer: void doFrame(long,int)>",24,25,"<android.view.Choreographer: void doFrame(long,int)>","<android.view.Choreographer: void doFrame(long,int)>",0,"{
    final long startNanos;
    synchronized (mLock) {
        if (!mFrameScheduled) {
            // no work to do
            return;
        }
        if (DEBUG_JANK && mDebugPrintNextFrameTimeDelta) {
            mDebugPrintNextFrameTimeDelta = false;
            Log.d(TAG, ""Frame time delta: "" + ((frameTimeNanos - mLastFrameTimeNanos) * 0.000001f) + "" ms"");
        }
        long intendedFrameTimeNanos = frameTimeNanos;
        startNanos = System.nanoTime();
        final long jitterNanos = startNanos - frameTimeNanos;
        if (jitterNanos >= mFrameIntervalNanos) {
            final long skippedFrames = jitterNanos / mFrameIntervalNanos;
            if (skippedFrames >= SKIPPED_FRAME_WARNING_LIMIT) {
                Log.i(TAG, ""Skipped "" + skippedFrames + "" frames!  "" + ""The application may be doing too much work on its main thread."");
            }
            final long lastFrameOffset = jitterNanos % mFrameIntervalNanos;
            if (DEBUG_JANK) {
                Log.d(TAG, ""Missed vsync by "" + (jitterNanos * 0.000001f) + "" ms "" + ""which is more than the frame interval of "" + (mFrameIntervalNanos * 0.000001f) + "" ms!  "" + ""Skipping "" + skippedFrames + "" frames and setting frame "" + ""time to "" + (lastFrameOffset * 0.000001f) + "" ms in the past."");
            }
            frameTimeNanos = startNanos - lastFrameOffset;
        }
        if (frameTimeNanos < mLastFrameTimeNanos) {
            if (DEBUG_JANK) {
                Log.d(TAG, ""Frame time appears to be going backwards.  May be due to a "" + ""previously skipped frame.  Waiting for next vsync."");
            }
            scheduleVsyncLocked();
            return;
        }
        mFrameInfo.setVsync(intendedFrameTimeNanos, frameTimeNanos);
        mFrameScheduled = false;
        mLastFrameTimeNanos = frameTimeNanos;
    }
    try {
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, ""Choreographer#doFrame"");
        mFrameInfo.markInputHandlingStart();
        doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos);
        mFrameInfo.markAnimationsStart();
        doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);
        mFrameInfo.markPerformTraversalsStart();
        doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);
        doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos);
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_VIEW);
    }
    if (DEBUG_FRAMES) {
        final long endNanos = System.nanoTime();
        Log.d(TAG, ""Frame "" + frame + "": Finished, took "" + (endNanos - startNanos) * 0.000001f + "" ms, latency "" + (startNanos - frameTimeNanos) * 0.000001f + "" ms."");
    }
}","{
    final long startNanos;
    synchronized (mLock) {
        if (!mFrameScheduled) {
            // no work to do
            return;
        }
        if (DEBUG_JANK && mDebugPrintNextFrameTimeDelta) {
            mDebugPrintNextFrameTimeDelta = false;
            Log.d(TAG, ""Frame time delta: "" + ((frameTimeNanos - mLastFrameTimeNanos) * 0.000001f) + "" ms"");
        }
        long intendedFrameTimeNanos = frameTimeNanos;
        startNanos = System.nanoTime();
        final long jitterNanos = startNanos - frameTimeNanos;
        if (jitterNanos >= mFrameIntervalNanos) {
            final long skippedFrames = jitterNanos / mFrameIntervalNanos;
            if (skippedFrames >= SKIPPED_FRAME_WARNING_LIMIT) {
                Log.i(TAG, ""Skipped "" + skippedFrames + "" frames!  "" + ""The application may be doing too much work on its main thread."");
            }
            final long lastFrameOffset = jitterNanos % mFrameIntervalNanos;
            if (DEBUG_JANK) {
                Log.d(TAG, ""Missed vsync by "" + (jitterNanos * 0.000001f) + "" ms "" + ""which is more than the frame interval of "" + (mFrameIntervalNanos * 0.000001f) + "" ms!  "" + ""Skipping "" + skippedFrames + "" frames and setting frame "" + ""time to "" + (lastFrameOffset * 0.000001f) + "" ms in the past."");
            }
            frameTimeNanos = startNanos - lastFrameOffset;
        }
        if (frameTimeNanos < mLastFrameTimeNanos) {
            if (DEBUG_JANK) {
                Log.d(TAG, ""Frame time appears to be going backwards.  May be due to a "" + ""previously skipped frame.  Waiting for next vsync."");
            }
            scheduleVsyncLocked();
            return;
        }
        mFrameInfo.setVsync(intendedFrameTimeNanos, frameTimeNanos);
        mFrameScheduled = false;
        mLastFrameTimeNanos = frameTimeNanos;
    }
    try {
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, ""Choreographer#doFrame"");
        AnimationUtils.lockAnimationClock(frameTimeNanos / TimeUtils.NANOS_PER_MS);
        mFrameInfo.markInputHandlingStart();
        doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos);
        mFrameInfo.markAnimationsStart();
        doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);
        mFrameInfo.markPerformTraversalsStart();
        doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);
        doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos);
    } finally {
        AnimationUtils.unlockAnimationClock();
        Trace.traceEnd(Trace.TRACE_TAG_VIEW);
    }
    if (DEBUG_FRAMES) {
        final long endNanos = System.nanoTime();
        Log.d(TAG, ""Frame "" + frame + "": Finished, took "" + (endNanos - startNanos) * 0.000001f + "" ms, latency "" + (startNanos - frameTimeNanos) * 0.000001f + "" ms."");
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
19,<android.net.NetworkRequest: String toString()>,24,25,<android.net.NetworkRequest: String toString()>,<android.net.NetworkRequest: String toString()>,0,"{
    return ""NetworkRequest [ id="" + requestId + "", legacyType="" + legacyType + "", "" + networkCapabilities.toString() + "" ]"";
}","{
    return ""NetworkRequest [ "" + type + "" id="" + requestId + (legacyType != ConnectivityManager.TYPE_NONE ? "", legacyType="" + legacyType : """") + "", "" + networkCapabilities.toString() + "" ]"";
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement has changed to include the type and a conditional expression related to legacyType, so the change type is 1.","The addition of the type and conditional expression for legacyType in the return statement means the method potentially returns a different value. Therefore, there is a Compatibility Issue of type 1 due to potential different return values."
20,<android.app.ContextImpl: File[] getExternalCacheDirs()>,24,25,<android.app.ContextImpl: File[] getExternalCacheDirs()>,<android.app.ContextImpl: File[] getExternalCacheDirs()>,0,"{
    synchronized (mSync) {
        if (mExternalCacheDirs == null) {
            mExternalCacheDirs = Environment.buildExternalStorageAppCacheDirs(getPackageName());
        }
        // Create dirs if needed
        return ensureExternalDirsExistOrFilter(mExternalCacheDirs);
    }
}","{
    synchronized (mSync) {
        File[] dirs = Environment.buildExternalStorageAppCacheDirs(getPackageName());
        return ensureExternalDirsExistOrFilter(dirs);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The late version no longer checks if mExternalCacheDirs is null before building the external cache directories, always building new directories and assigning them to a local variable before filtering and returning them. The late version modifies the method's internal state handling in comparison to the early version, leading to changes in control dependency and other statements.","The absence of a Compatibility Issue is because the final output of the method—external cache directories after filtering—remains unaffected by these changes. Both versions result in returning filtered external cache directories, hence no different behavior is exposed to the caller. The method ensures the creation of external directories and the presence of any changes in-between versions does not alter the contract of the method regarding its return value."
21,<android.net.NetworkRequest: boolean equals(Object)>,24,25,<android.net.NetworkRequest: boolean equals(Object)>,<android.net.NetworkRequest: boolean equals(Object)>,0,"{
    if (obj instanceof NetworkRequest == false)
        return false;
    NetworkRequest that = (NetworkRequest) obj;
    return (that.legacyType == this.legacyType && that.requestId == this.requestId && ((that.networkCapabilities == null && this.networkCapabilities == null) || (that.networkCapabilities != null && that.networkCapabilities.equals(this.networkCapabilities))));
}","{
    if (obj instanceof NetworkRequest == false)
        return false;
    NetworkRequest that = (NetworkRequest) obj;
    return (that.legacyType == this.legacyType && that.requestId == this.requestId && that.type == this.type && Objects.equals(that.networkCapabilities, this.networkCapabilities));
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The return statement in the late version includes a new comparison (that.type == this.type) and uses Objects.equals for comparing networkCapabilities instead of a manual null check and equality check, so the code change type is 1 and 4 due to the new field comparison and the use of a different method for comparison.","Considering the added comparison of 'that.type == this.type' in the return statement, this change may lead to the method returning different boolean values than before when the 'type' field is considered. This constitutes a potential different return value, so the CI type is 1."
22,"<android.view.ThreadedRenderer.ProcessInitializer: void init(Context,long)>",24,25,"<android.view.ThreadedRenderer.ProcessInitializer: void init(Context,long)>","<android.view.ThreadedRenderer.ProcessInitializer: void init(Context,long)>",0,"{
    if (mInitialized)
        return;
    mInitialized = true;
    initGraphicsStats(context, renderProxy);
    initAssetAtlas(context, renderProxy);
}","{
    if (mInitialized)
        return;
    mInitialized = true;
    initSched(context, renderProxy);
    initGraphicsStats(context, renderProxy);
    initAssetAtlas(context, renderProxy);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"A new method call initSched(context, renderProxy) has been added to the late version implementation, so the code change type is 4.","The addition of the initSched(context, renderProxy) method does not result in a change to the return type, value, or thrown exceptions of this void method, thus there is no compatibility issue, meaning CI type is 0."
24,<android.net.NetworkRequest.Builder: NetworkRequest build()>,24,25,<android.net.NetworkRequest.Builder: NetworkRequest build()>,<android.net.NetworkRequest.Builder: NetworkRequest build()>,0,"{
    // Make a copy of mNetworkCapabilities so we don't inadvertently remove NOT_RESTRICTED
    // when later an unrestricted capability could be added to mNetworkCapabilities, in
    // which case NOT_RESTRICTED should be returned to mNetworkCapabilities, which
    // maybeMarkCapabilitiesRestricted() doesn't add back.
    final NetworkCapabilities nc = new NetworkCapabilities(mNetworkCapabilities);
    nc.maybeMarkCapabilitiesRestricted();
    return new NetworkRequest(nc, ConnectivityManager.TYPE_NONE, ConnectivityManager.REQUEST_ID_UNSET);
}","{
    // Make a copy of mNetworkCapabilities so we don't inadvertently remove NOT_RESTRICTED
    // when later an unrestricted capability could be added to mNetworkCapabilities, in
    // which case NOT_RESTRICTED should be returned to mNetworkCapabilities, which
    // maybeMarkCapabilitiesRestricted() doesn't add back.
    final NetworkCapabilities nc = new NetworkCapabilities(mNetworkCapabilities);
    nc.maybeMarkCapabilitiesRestricted();
    return new NetworkRequest(nc, ConnectivityManager.TYPE_NONE, ConnectivityManager.REQUEST_ID_UNSET, Type.NONE);
}",1,"/**
 * Build {@link NetworkRequest} give the current set of capabilities.
 */
","/**
 * Build {@link NetworkRequest} give the current set of capabilities.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The constructor of the NetworkRequest object in the return statement is different, it now includes an additional parameter Type.NONE in the late version, which indicates that the parameters passed to the constructor have changed. Therefore, the code change type is 1,5.","The early version of the API does not include the additional parameter Type.NONE when constructing a NetworkRequest, thus potentially leading to a different NetworkRequest object being returned. "
25,"<android.hardware.camera2.params.OutputConfiguration: void writeToParcel(Parcel,int)>",24,25,"<android.hardware.camera2.params.OutputConfiguration: void writeToParcel(Parcel,int)>","<android.hardware.camera2.params.OutputConfiguration: void writeToParcel(Parcel,int)>",0,"{
    if (dest == null) {
        throw new IllegalArgumentException(""dest must not be null"");
    }
    dest.writeInt(mRotation);
    dest.writeInt(mSurfaceGroupId);
    mSurface.writeToParcel(dest, flags);
}","{
    if (dest == null) {
        throw new IllegalArgumentException(""dest must not be null"");
    }
    dest.writeInt(mRotation);
    dest.writeInt(mSurfaceGroupId);
    dest.writeInt(mSurfaceType);
    dest.writeInt(mConfiguredSize.getWidth());
    dest.writeInt(mConfiguredSize.getHeight());
    if (mSurface != null) {
        mSurface.writeToParcel(dest, flags);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",0,"Additional writeInt() calls about mSurfaceType, and mConfiguredSize's width and height have been added to the implementation, and there's a change in the control flow with a new conditional check for mSurface being not null before calling writeToParcel. These are examples of ""Other statement changed"" and ""Control dependency changed,"" so the code change type is 1,3,4.","Although there is a change in what's written to the Parcel (the addition of mSurfaceType, mConfiguredSize's width and height, and the condition on mSurface), these changes do not affect the method's compatibility since writeToParcel method is designed to serialize the configuration into the Parcel, to be read back later recreating the original configuration. The recipient of the Parcel is expected to understand the updated format. Hence, there is no change that leads to a difference in return value or exception handling from this method's invocation, resulting in no compatibility issue; therefore, the CI type is 0."
27,<android.widget.Toolbar: int getContentInsetRight()>,24,25,<android.widget.Toolbar: int getContentInsetRight()>,<android.widget.Toolbar: int getContentInsetRight()>,0,"{
    return mContentInsets.getRight();
}","{
    return mContentInsets != null ? mContentInsets.getRight() : 0;
}",1,"/**
 * Gets the right content inset for this toolbar.
 *
 * <p>The content inset affects the valid area for Toolbar content other than
 * the navigation button and menu. Insets define the minimum margin for these components
 * and can be used to effectively align Toolbar content along well-known gridlines.</p>
 *
 * @return The right content inset for this toolbar
 *
 * @see #setContentInsetsRelative(int, int)
 * @see #setContentInsetsAbsolute(int, int)
 * @see #getContentInsetStart()
 * @see #getContentInsetEnd()
 * @see #getContentInsetLeft()
 * @attr ref android.R.styleable#Toolbar_contentInsetRight
 */
","/**
 * Gets the right content inset for this toolbar.
 *
 * <p>The content inset affects the valid area for Toolbar content other than
 * the navigation button and menu. Insets define the minimum margin for these components
 * and can be used to effectively align Toolbar content along well-known gridlines.</p>
 *
 * @return The right content inset for this toolbar
 *
 * @see #setContentInsetsRelative(int, int)
 * @see #setContentInsetsAbsolute(int, int)
 * @see #getContentInsetStart()
 * @see #getContentInsetEnd()
 * @see #getContentInsetLeft()
 * @attr ref android.R.styleable#Toolbar_contentInsetRight
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement has been modified to include a condition that checks if mContentInsets is non-null before returning its 'getRight()' value. If mContentInsets is null, it now returns 0, whereas earlier it would directly return mContentInsets.getRight() without the null check, so the change type is 1.","The addition of the null check for mContentInsets potentially alters the return value of the method. In the early version, if mContentInsets were null, it would lead to a NullPointerException, while in the late version it returns 0 instead. This change means the API will return a different value under certain conditions, so the CI type is 1."
28,<android.inputmethodservice.IInputMethodWrapper: void executeMessage(Message)>,24,25,<android.inputmethodservice.IInputMethodWrapper: void executeMessage(Message)>,<android.inputmethodservice.IInputMethodWrapper: void executeMessage(Message)>,0,"{
    InputMethod inputMethod = mInputMethod.get();
    // Need a valid reference to the inputMethod for everything except a dump.
    if (inputMethod == null && msg.what != DO_DUMP) {
        Log.w(TAG, ""Input method reference was null, ignoring message: "" + msg.what);
        return;
    }
    switch(msg.what) {
        case DO_DUMP:
            {
                AbstractInputMethodService target = mTarget.get();
                if (target == null) {
                    return;
                }
                SomeArgs args = (SomeArgs) msg.obj;
                try {
                    target.dump((FileDescriptor) args.arg1, (PrintWriter) args.arg2, (String[]) args.arg3);
                } catch (RuntimeException e) {
                    ((PrintWriter) args.arg2).println(""Exception: "" + e);
                }
                synchronized (args.arg4) {
                    ((CountDownLatch) args.arg4).countDown();
                }
                args.recycle();
                return;
            }
        case DO_ATTACH_TOKEN:
            {
                inputMethod.attachToken((IBinder) msg.obj);
                return;
            }
        case DO_SET_INPUT_CONTEXT:
            {
                inputMethod.bindInput((InputBinding) msg.obj);
                return;
            }
        case DO_UNSET_INPUT_CONTEXT:
            inputMethod.unbindInput();
            return;
        case DO_START_INPUT:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                int missingMethods = msg.arg1;
                IInputContext inputContext = (IInputContext) args.arg1;
                InputConnection ic = inputContext != null ? new InputConnectionWrapper(inputContext, missingMethods) : null;
                EditorInfo info = (EditorInfo) args.arg2;
                info.makeCompatible(mTargetSdkVersion);
                inputMethod.startInput(ic, info);
                args.recycle();
                return;
            }
        case DO_RESTART_INPUT:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                int missingMethods = msg.arg1;
                IInputContext inputContext = (IInputContext) args.arg1;
                InputConnection ic = inputContext != null ? new InputConnectionWrapper(inputContext, missingMethods) : null;
                EditorInfo info = (EditorInfo) args.arg2;
                info.makeCompatible(mTargetSdkVersion);
                inputMethod.restartInput(ic, info);
                args.recycle();
                return;
            }
        case DO_CREATE_SESSION:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                inputMethod.createSession(new InputMethodSessionCallbackWrapper(mContext, (InputChannel) args.arg1, (IInputSessionCallback) args.arg2));
                args.recycle();
                return;
            }
        case DO_SET_SESSION_ENABLED:
            inputMethod.setSessionEnabled((InputMethodSession) msg.obj, msg.arg1 != 0);
            return;
        case DO_REVOKE_SESSION:
            inputMethod.revokeSession((InputMethodSession) msg.obj);
            return;
        case DO_SHOW_SOFT_INPUT:
            inputMethod.showSoftInput(msg.arg1, (ResultReceiver) msg.obj);
            return;
        case DO_HIDE_SOFT_INPUT:
            inputMethod.hideSoftInput(msg.arg1, (ResultReceiver) msg.obj);
            return;
        case DO_CHANGE_INPUTMETHOD_SUBTYPE:
            inputMethod.changeInputMethodSubtype((InputMethodSubtype) msg.obj);
            return;
    }
    Log.w(TAG, ""Unhandled message code: "" + msg.what);
}","{
    InputMethod inputMethod = mInputMethod.get();
    // Need a valid reference to the inputMethod for everything except a dump.
    if (inputMethod == null && msg.what != DO_DUMP) {
        Log.w(TAG, ""Input method reference was null, ignoring message: "" + msg.what);
        return;
    }
    switch(msg.what) {
        case DO_DUMP:
            {
                AbstractInputMethodService target = mTarget.get();
                if (target == null) {
                    return;
                }
                SomeArgs args = (SomeArgs) msg.obj;
                try {
                    target.dump((FileDescriptor) args.arg1, (PrintWriter) args.arg2, (String[]) args.arg3);
                } catch (RuntimeException e) {
                    ((PrintWriter) args.arg2).println(""Exception: "" + e);
                }
                synchronized (args.arg4) {
                    ((CountDownLatch) args.arg4).countDown();
                }
                args.recycle();
                return;
            }
        case DO_ATTACH_TOKEN:
            {
                inputMethod.attachToken((IBinder) msg.obj);
                return;
            }
        case DO_SET_INPUT_CONTEXT:
            {
                inputMethod.bindInput((InputBinding) msg.obj);
                return;
            }
        case DO_UNSET_INPUT_CONTEXT:
            inputMethod.unbindInput();
            return;
        case DO_START_INPUT:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                int missingMethods = msg.arg1;
                IInputContext inputContext = (IInputContext) args.arg1;
                InputConnection ic = inputContext != null ? new InputConnectionWrapper(mTarget, inputContext, missingMethods) : null;
                EditorInfo info = (EditorInfo) args.arg2;
                info.makeCompatible(mTargetSdkVersion);
                inputMethod.startInput(ic, info);
                args.recycle();
                return;
            }
        case DO_RESTART_INPUT:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                int missingMethods = msg.arg1;
                IInputContext inputContext = (IInputContext) args.arg1;
                InputConnection ic = inputContext != null ? new InputConnectionWrapper(mTarget, inputContext, missingMethods) : null;
                EditorInfo info = (EditorInfo) args.arg2;
                info.makeCompatible(mTargetSdkVersion);
                inputMethod.restartInput(ic, info);
                args.recycle();
                return;
            }
        case DO_CREATE_SESSION:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                inputMethod.createSession(new InputMethodSessionCallbackWrapper(mContext, (InputChannel) args.arg1, (IInputSessionCallback) args.arg2));
                args.recycle();
                return;
            }
        case DO_SET_SESSION_ENABLED:
            inputMethod.setSessionEnabled((InputMethodSession) msg.obj, msg.arg1 != 0);
            return;
        case DO_REVOKE_SESSION:
            inputMethod.revokeSession((InputMethodSession) msg.obj);
            return;
        case DO_SHOW_SOFT_INPUT:
            inputMethod.showSoftInput(msg.arg1, (ResultReceiver) msg.obj);
            return;
        case DO_HIDE_SOFT_INPUT:
            inputMethod.hideSoftInput(msg.arg1, (ResultReceiver) msg.obj);
            return;
        case DO_CHANGE_INPUTMETHOD_SUBTYPE:
            inputMethod.changeInputMethodSubtype((InputMethodSubtype) msg.obj);
            return;
    }
    Log.w(TAG, ""Unhandled message code: "" + msg.what);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
29,<android.app.ContextImpl: File[] getExternalMediaDirs()>,24,25,<android.app.ContextImpl: File[] getExternalMediaDirs()>,<android.app.ContextImpl: File[] getExternalMediaDirs()>,0,"{
    synchronized (mSync) {
        if (mExternalMediaDirs == null) {
            mExternalMediaDirs = Environment.buildExternalStorageAppMediaDirs(getPackageName());
        }
        // Create dirs if needed
        return ensureExternalDirsExistOrFilter(mExternalMediaDirs);
    }
}","{
    synchronized (mSync) {
        File[] dirs = Environment.buildExternalStorageAppMediaDirs(getPackageName());
        return ensureExternalDirsExistOrFilter(dirs);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The field mExternalMediaDirs is no longer used for caching the result and instead dirs local variable is used. But logically, it doesn't affect the return value as in both cases, the result from ensureExternalDirsExistOrFilter remains the same assuming getPackageName and Environment.buildExternalStorageAppMediaDirs behavior is unchanged.","Since there's no alteration affecting the outcome of the return statement or exception handling, and the changes don't influence the behavior of dependent APIs, there is no compatibility issue introduced by this change. The result of ensureExternalDirsExistOrFilter should still be the same, as it is called with the same parameters generated by the same method call sequence."
30,<android.nfc.NfcAdapter: void disableForegroundNdefPush(Activity)>,24,25,<android.nfc.NfcAdapter: void disableForegroundNdefPush(Activity)>,<android.nfc.NfcAdapter: void disableForegroundNdefPush(Activity)>,0,"{
    if (activity == null) {
        throw new NullPointerException();
    }
    enforceResumed(activity);
    mNfcActivityManager.setNdefPushMessage(activity, null, 0);
    mNfcActivityManager.setNdefPushMessageCallback(activity, null, 0);
    mNfcActivityManager.setOnNdefPushCompleteCallback(activity, null);
}","{
    synchronized (NfcAdapter.class) {
        if (!sHasNfcFeature) {
            throw new UnsupportedOperationException();
        }
    }
    if (activity == null) {
        throw new NullPointerException();
    }
    enforceResumed(activity);
    mNfcActivityManager.setNdefPushMessage(activity, null, 0);
    mNfcActivityManager.setNdefPushMessageCallback(activity, null, 0);
    mNfcActivityManager.setOnNdefPushCompleteCallback(activity, null);
}",1,"/**
 * Disable NDEF message push over P2P.
 *
 * <p>After calling {@link #enableForegroundNdefPush}, an activity
 * must call this method before its {@link Activity#onPause} callback
 * completes.
 *
 * <p>Strongly recommend to use the new {@link #setNdefPushMessage}
 * instead: it automatically hooks into your activity life-cycle,
 * so you do not need to call enable/disable in your onResume/onPause.
 *
 * <p>This method must be called from the main thread.
 *
 * <p class=""note"">Requires the {@link android.Manifest.permission#NFC} permission.
 *
 * @param activity the Foreground activity
 * @throws IllegalStateException if the Activity has already been paused
 * @deprecated use {@link #setNdefPushMessage} instead
 */
","/**
 * Disable NDEF message push over P2P.
 *
 * <p>After calling {@link #enableForegroundNdefPush}, an activity
 * must call this method before its {@link Activity#onPause} callback
 * completes.
 *
 * <p>Strongly recommend to use the new {@link #setNdefPushMessage}
 * instead: it automatically hooks into your activity life-cycle,
 * so you do not need to call enable/disable in your onResume/onPause.
 *
 * <p>This method must be called from the main thread.
 *
 * <p class=""note"">Requires the {@link android.Manifest.permission#NFC} permission.
 *
 * @param activity the Foreground activity
 * @throws IllegalStateException if the Activity has already been paused
 * @throws UnsupportedOperationException if FEATURE_NFC is unavailable.
 * @deprecated use {@link #setNdefPushMessage} instead
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,"2,3,5",2,"The late version introduces synchronized block with a new condition check and a different exception type thrown (UnsupportedOperationException vs. the original NullPointerException), so the code change types are 2 (exception handling statement changed), 3 (control dependency changed), and 5 (dependent API changed) due to the check for sHasNfcFeature.","The introduction of the new synchronized block and throwing a new type of exception (UnsupportedOperationException) instead of the original exception introduces a new execution path and new behavior. Therefore, there is a Compatibility Issue due to potential different exception handling, so the CI type is 2."
32,<android.view.animation.AnimationUtils: long currentAnimationTimeMillis()>,24,25,<android.view.animation.AnimationUtils: long currentAnimationTimeMillis()>,<android.view.animation.AnimationUtils: long currentAnimationTimeMillis()>,0,"{
    return SystemClock.uptimeMillis();
}","{
    AnimationState state = sAnimationState.get();
    if (state.animationClockLocked) {
        // It's important that time never rewinds
        return Math.max(state.currentVsyncTimeMillis, state.lastReportedTimeMillis);
    }
    state.lastReportedTimeMillis = SystemClock.uptimeMillis();
    return state.lastReportedTimeMillis;
}",1,"/**
 * Returns the current animation time in milliseconds. This time should be used when invoking
 * {@link Animation#setStartTime(long)}. Refer to {@link android.os.SystemClock} for more
 * information about the different available clocks. The clock used by this method is
 * <em>not</em> the ""wall"" clock (it is not {@link System#currentTimeMillis}).
 *
 * @return the current animation time in milliseconds
 *
 * @see android.os.SystemClock
 */
","/**
 * Returns the current animation time in milliseconds. This time should be used when invoking
 * {@link Animation#setStartTime(long)}. Refer to {@link android.os.SystemClock} for more
 * information about the different available clocks. The clock used by this method is
 * <em>not</em> the ""wall"" clock (it is not {@link System#currentTimeMillis}).
 *
 * @return the current animation time in milliseconds
 *
 * @see android.os.SystemClock
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The code change includes introducing new control flow logic with conditions and assignments (changes in control dependency), adding a new return statement, modifying the existing return statement's logic, and the implementation uses a new class 'AnimationState'. Thus the change types are 1,3,4,5.","The change in the return statement logic and the addition of control flow logic that depends on the `animationClockLocked` condition may lead to a different value being returned than in the prior version. Hence the possibility of a CI due to different return values exists, and the CI type is 1."
33,"<android.app.ActivityTransitionState: void startExitOutTransition(Activity,Bundle)>",24,25,"<android.app.ActivityTransitionState: void startExitOutTransition(Activity,Bundle)>","<android.app.ActivityTransitionState: void startExitOutTransition(Activity,Bundle)>",0,"{
    if (!activity.getWindow().hasFeature(Window.FEATURE_ACTIVITY_TRANSITIONS)) {
        return;
    }
    ActivityOptions activityOptions = new ActivityOptions(options);
    mEnterTransitionCoordinator = null;
    if (activityOptions.getAnimationType() == ActivityOptions.ANIM_SCENE_TRANSITION) {
        int key = activityOptions.getExitCoordinatorKey();
        int index = mExitTransitionCoordinators.indexOfKey(key);
        if (index >= 0) {
            mCalledExitCoordinator = mExitTransitionCoordinators.valueAt(index).get();
            mExitTransitionCoordinators.removeAt(index);
            if (mCalledExitCoordinator != null) {
                mExitingFrom = mCalledExitCoordinator.getAcceptedNames();
                mExitingTo = mCalledExitCoordinator.getMappedNames();
                mExitingToView = mCalledExitCoordinator.copyMappedViews();
                mCalledExitCoordinator.startExit();
            }
        }
    }
}","{
    mEnterTransitionCoordinator = null;
    if (!activity.getWindow().hasFeature(Window.FEATURE_ACTIVITY_TRANSITIONS) || mExitTransitionCoordinators == null) {
        return;
    }
    ActivityOptions activityOptions = new ActivityOptions(options);
    if (activityOptions.getAnimationType() == ActivityOptions.ANIM_SCENE_TRANSITION) {
        int key = activityOptions.getExitCoordinatorKey();
        int index = mExitTransitionCoordinators.indexOfKey(key);
        if (index >= 0) {
            mCalledExitCoordinator = mExitTransitionCoordinators.valueAt(index).get();
            mExitTransitionCoordinators.removeAt(index);
            if (mCalledExitCoordinator != null) {
                mExitingFrom = mCalledExitCoordinator.getAcceptedNames();
                mExitingTo = mCalledExitCoordinator.getMappedNames();
                mExitingToView = mCalledExitCoordinator.copyMappedViews();
                mCalledExitCoordinator.startExit();
            }
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,0,"The control dependency has changed. In the early version, the return is only dependent on checking if activity transitions are not enabled. In the late version, the code includes an extra conditional check (`mExitTransitionCoordinators == null`) before returning, combining two conditions with a logical OR.","Although the condition for returning early has changed, there is no new scenario under which a different value or exception would be returned or thrown due to this control flow change. The late version has an extra check for nullity of `mExitTransitionCoordinators`, which adds a safety check and prevents potential NullPointerException, but it doesn't affect the behavior of the method with respect to what value is returned or what exceptions are thrown in scenarios where both conditions are met in both versions. Therefore, there's no Compatibility Issue."
34,<android.app.EnterTransitionCoordinator: void prepareEnter()>,24,25,<android.app.EnterTransitionCoordinator: void prepareEnter()>,<android.app.EnterTransitionCoordinator: void prepareEnter()>,0,"{
    ViewGroup decorView = getDecor();
    if (mActivity == null || decorView == null) {
        return;
    }
    mActivity.overridePendingTransition(0, 0);
    if (!mIsReturning) {
        mWasOpaque = mActivity.convertToTranslucent(null, null);
        Drawable background = decorView.getBackground();
        if (background != null) {
            getWindow().setBackgroundDrawable(null);
            background = background.mutate();
            background.setAlpha(0);
            getWindow().setBackgroundDrawable(background);
        }
    } else {
        // all done with it now.
        mActivity = null;
    }
}","{
    ViewGroup decorView = getDecor();
    if (mActivity == null || decorView == null) {
        return;
    }
    if (!isCrossTask()) {
        mActivity.overridePendingTransition(0, 0);
    }
    if (!mIsReturning) {
        mWasOpaque = mActivity.convertToTranslucent(null, null);
        Drawable background = decorView.getBackground();
        if (background != null) {
            getWindow().setBackgroundDrawable(null);
            background = background.mutate();
            background.setAlpha(0);
            getWindow().setBackgroundDrawable(background);
        }
    } else {
        // all done with it now.
        mActivity = null;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,0,"Control dependency has changed with the addition of the condition `if (!isCrossTask())`. This alters when `mActivity.overridePendingTransition(0, 0);` is called.","Adding an additional conditional check (`if (!isCrossTask())`) before calling `overridePendingTransition` does not inherently produce a compatibility issue, since it only changes the condition under which the existing code operates and does not alter the existing exception handling or return values. It could lead to a behavioral change, but on its own does not cause the method to return a different value or throw a different exception."
35,<android.net.ConnectivityManager: void unregisterNetworkCallback(NetworkCallback)>,24,25,<android.net.ConnectivityManager: void unregisterNetworkCallback(NetworkCallback)>,<android.net.ConnectivityManager: void unregisterNetworkCallback(NetworkCallback)>,0,"{
    if (networkCallback == null || networkCallback.networkRequest == null || networkCallback.networkRequest.requestId == REQUEST_ID_UNSET) {
        throw new IllegalArgumentException(""Invalid NetworkCallback"");
    }
    try {
        mService.releaseNetworkRequest(networkCallback.networkRequest);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
    synchronized (sNetworkCallback) {
        sNetworkCallback.remove(networkCallback.networkRequest);
    }
}","{
    if (networkCallback == null || networkCallback.networkRequest == null || networkCallback.networkRequest.requestId == REQUEST_ID_UNSET) {
        throw new IllegalArgumentException(""Invalid NetworkCallback"");
    }
    try {
        // CallbackHandler will release callback when receiving CALLBACK_RELEASED.
        mService.releaseNetworkRequest(networkCallback.networkRequest);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Unregisters callbacks about and possibly releases networks originating from
 * {@link #requestNetwork(NetworkRequest, NetworkCallback)} and
 * {@link #registerNetworkCallback(NetworkRequest, NetworkCallback)} calls.
 * If the given {@code NetworkCallback} had previously been used with
 * {@code #requestNetwork}, any networks that had been connected to only to satisfy that request
 * will be disconnected.
 *
 * @param networkCallback The {@link NetworkCallback} used when making the request.
 */
","/**
 * Unregisters callbacks about and possibly releases networks originating from
 * {@link #requestNetwork(NetworkRequest, NetworkCallback)} and
 * {@link #registerNetworkCallback(NetworkRequest, NetworkCallback)} calls.
 * If the given {@code NetworkCallback} had previously been used with
 * {@code #requestNetwork}, any networks that had been connected to only to satisfy that request
 * will be disconnected.
 *
 * @param networkCallback The {@link NetworkCallback} used when making the request.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"There is no actual code change in the implementation, but a comment was added within the try block. Comments are not executable code, so there is no change that can affect the behavior of the API.","Since the changes are only in the form of comments and do not affect the code execution path or logic, there is no compatibility issue."
36,<android.service.quicksettings.Tile: void updateTile()>,24,25,<android.service.quicksettings.Tile: void updateTile()>,<android.service.quicksettings.Tile: void updateTile()>,0,"{
    try {
        mService.updateQsTile(this);
    } catch (RemoteException e) {
        Log.e(TAG, ""Couldn't update tile"");
    }
}","{
    try {
        mService.updateQsTile(this, mToken);
    } catch (RemoteException e) {
        Log.e(TAG, ""Couldn't update tile"");
    }
}",1,"/**
 * Pushes the state of the Tile to Quick Settings to be displayed.
 */
","/**
 * Pushes the state of the Tile to Quick Settings to be displayed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent API `mService.updateQsTile` has been changed with an additional parameter (`mToken`). This is reflected as a change in the type of parameters the method accepts, so the code change type is 5.","Although there is a change in the method parameters of a dependent API, this does not constitute a compatibility issue because the behavior from the perspective of the method's caller does not change; it still attempts to update the tile and catches a `RemoteException`, logging an error if it occurs, without modifying the API's return type or exception handling externally. Thus, there is no compatibility issue, so CI type is 0."
38,<android.os.Looper: void loop()>,24,25,<android.os.Looper: void loop()>,<android.os.Looper: void loop()>,0,"{
    final Looper me = myLooper();
    if (me == null) {
        throw new RuntimeException(""No Looper; Looper.prepare() wasn't called on this thread."");
    }
    final MessageQueue queue = me.mQueue;
    // Make sure the identity of this thread is that of the local process,
    // and keep track of what that identity token actually is.
    Binder.clearCallingIdentity();
    final long ident = Binder.clearCallingIdentity();
    for (; ; ) {
        // might block
        Message msg = queue.next();
        if (msg == null) {
            // No message indicates that the message queue is quitting.
            return;
        }
        // This must be in a local variable, in case a UI event sets the logger
        final Printer logging = me.mLogging;
        if (logging != null) {
            logging.println("">>>>> Dispatching to "" + msg.target + "" "" + msg.callback + "": "" + msg.what);
        }
        final long traceTag = me.mTraceTag;
        if (traceTag != 0) {
            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));
        }
        try {
            msg.target.dispatchMessage(msg);
        } finally {
            if (traceTag != 0) {
                Trace.traceEnd(traceTag);
            }
        }
        if (logging != null) {
            logging.println(""<<<<< Finished to "" + msg.target + "" "" + msg.callback);
        }
        // Make sure that during the course of dispatching the
        // identity of the thread wasn't corrupted.
        final long newIdent = Binder.clearCallingIdentity();
        if (ident != newIdent) {
            Log.wtf(TAG, ""Thread identity changed from 0x"" + Long.toHexString(ident) + "" to 0x"" + Long.toHexString(newIdent) + "" while dispatching to "" + msg.target.getClass().getName() + "" "" + msg.callback + "" what="" + msg.what);
        }
        msg.recycleUnchecked();
    }
}","{
    final Looper me = myLooper();
    if (me == null) {
        throw new RuntimeException(""No Looper; Looper.prepare() wasn't called on this thread."");
    }
    final MessageQueue queue = me.mQueue;
    // Make sure the identity of this thread is that of the local process,
    // and keep track of what that identity token actually is.
    Binder.clearCallingIdentity();
    final long ident = Binder.clearCallingIdentity();
    for (; ; ) {
        // might block
        Message msg = queue.next();
        if (msg == null) {
            // No message indicates that the message queue is quitting.
            return;
        }
        // This must be in a local variable, in case a UI event sets the logger
        final Printer logging = me.mLogging;
        if (logging != null) {
            logging.println("">>>>> Dispatching to "" + msg.target + "" "" + msg.callback + "": "" + msg.what);
        }
        final long traceTag = me.mTraceTag;
        if (traceTag != 0 && Trace.isTagEnabled(traceTag)) {
            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));
        }
        try {
            msg.target.dispatchMessage(msg);
        } finally {
            if (traceTag != 0) {
                Trace.traceEnd(traceTag);
            }
        }
        if (logging != null) {
            logging.println(""<<<<< Finished to "" + msg.target + "" "" + msg.callback);
        }
        // Make sure that during the course of dispatching the
        // identity of the thread wasn't corrupted.
        final long newIdent = Binder.clearCallingIdentity();
        if (ident != newIdent) {
            Log.wtf(TAG, ""Thread identity changed from 0x"" + Long.toHexString(ident) + "" to 0x"" + Long.toHexString(newIdent) + "" while dispatching to "" + msg.target.getClass().getName() + "" "" + msg.callback + "" what="" + msg.what);
        }
        msg.recycleUnchecked();
    }
}",1,"/**
 * Run the message queue in this thread. Be sure to call
 * {@link #quit()} to end the loop.
 */
","/**
 * Run the message queue in this thread. Be sure to call
 * {@link #quit()} to end the loop.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,The only change is an additional condition check before tracing begins: `if (traceTag != 0 && Trace.isTagEnabled(traceTag))`. This is an addition to the control flow to decide when `Trace.traceBegin` should be executed.,"The additional conditional check for the trace tag does not alter the behavior of `Looper.loop()` in a way that would cause a compatibility issue. The method's functionality, in terms of input and output behavior, remains consistent as it is related to logging and not the core logic of message dispatching. Therefore, there is no compatibility issue."
39,<android.app.backup.FullBackup.BackupScheme: String tokenToDirectoryPath(String)>,24,25,<android.app.backup.FullBackup.BackupScheme: String tokenToDirectoryPath(String)>,<android.app.backup.FullBackup.BackupScheme: String tokenToDirectoryPath(String)>,0,"{
    try {
        if (domainToken.equals(FullBackup.FILES_TREE_TOKEN)) {
            return FILES_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.DATABASE_TREE_TOKEN)) {
            return DATABASE_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.ROOT_TREE_TOKEN)) {
            return ROOT_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.SHAREDPREFS_TREE_TOKEN)) {
            return SHAREDPREF_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.CACHE_TREE_TOKEN)) {
            return CACHE_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.NO_BACKUP_TREE_TOKEN)) {
            return NOBACKUP_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.DEVICE_FILES_TREE_TOKEN)) {
            return DEVICE_FILES_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.DEVICE_DATABASE_TREE_TOKEN)) {
            return DEVICE_DATABASE_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.DEVICE_ROOT_TREE_TOKEN)) {
            return DEVICE_ROOT_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.DEVICE_SHAREDPREFS_TREE_TOKEN)) {
            return DEVICE_SHAREDPREF_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.DEVICE_CACHE_TREE_TOKEN)) {
            return DEVICE_CACHE_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.DEVICE_NO_BACKUP_TREE_TOKEN)) {
            return DEVICE_NOBACKUP_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.MANAGED_EXTERNAL_TREE_TOKEN)) {
            if (EXTERNAL_DIR != null) {
                return EXTERNAL_DIR.getCanonicalPath();
            } else {
                return null;
            }
        }
        // Not a supported location
        Log.i(TAG, ""Unrecognized domain "" + domainToken);
        return null;
    } catch (IOException e) {
        Log.i(TAG, ""Error reading directory for domain: "" + domainToken);
        return null;
    }
}","{
    try {
        if (domainToken.equals(FullBackup.FILES_TREE_TOKEN)) {
            return FILES_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.DATABASE_TREE_TOKEN)) {
            return DATABASE_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.ROOT_TREE_TOKEN)) {
            return ROOT_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.SHAREDPREFS_TREE_TOKEN)) {
            return SHAREDPREF_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.CACHE_TREE_TOKEN)) {
            return CACHE_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.NO_BACKUP_TREE_TOKEN)) {
            return NOBACKUP_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.DEVICE_FILES_TREE_TOKEN)) {
            return DEVICE_FILES_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.DEVICE_DATABASE_TREE_TOKEN)) {
            return DEVICE_DATABASE_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.DEVICE_ROOT_TREE_TOKEN)) {
            return DEVICE_ROOT_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.DEVICE_SHAREDPREFS_TREE_TOKEN)) {
            return DEVICE_SHAREDPREF_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.DEVICE_CACHE_TREE_TOKEN)) {
            return DEVICE_CACHE_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.DEVICE_NO_BACKUP_TREE_TOKEN)) {
            return DEVICE_NOBACKUP_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.MANAGED_EXTERNAL_TREE_TOKEN)) {
            if (EXTERNAL_DIR != null) {
                return EXTERNAL_DIR.getCanonicalPath();
            } else {
                return null;
            }
        } else if (domainToken.startsWith(FullBackup.SHARED_PREFIX)) {
            return sharedDomainToPath(domainToken);
        }
        // Not a supported location
        Log.i(TAG, ""Unrecognized domain "" + domainToken);
        return null;
    } catch (Exception e) {
        Log.i(TAG, ""Error reading directory for domain: "" + domainToken);
        return null;
    }
}",1,"/**
 * Parse out the semantic domains into the correct physical location.
 */
","/**
 * Parse out the semantic domains into the correct physical location.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,3,4,5","1,2","The late version introduces a new conditional block for 'else if (domainToken.startsWith(FullBackup.SHARED_PREFIX))', changes the catch block from catching IOException to Exception, and uses a new dependent API called 'sharedDomainToPath(domainToken)'. This leads to change types 1 (due to the new return statement), 2 (due to the changed exception type caught), 3 (due to the new control structure introduced), 4 (for using the sharedDomainToPath method), and 5 (due to a new dependent API usage).","There's a potential CI due to different return values because of the added control structure and potential new return value from 'sharedDomainToPath(domainToken)', so the CI type is 1. There is also a CI due to different exception handling because the catch block is now catching a more generic Exception instead of only an IOException, which could result in different exceptions being caught and handled, so CI type is 2."
40,<android.widget.Toolbar: int getContentInsetLeft()>,24,25,<android.widget.Toolbar: int getContentInsetLeft()>,<android.widget.Toolbar: int getContentInsetLeft()>,0,"{
    return mContentInsets.getLeft();
}","{
    return mContentInsets != null ? mContentInsets.getLeft() : 0;
}",1,"/**
 * Gets the left content inset for this toolbar.
 *
 * <p>The content inset affects the valid area for Toolbar content other than
 * the navigation button and menu. Insets define the minimum margin for these components
 * and can be used to effectively align Toolbar content along well-known gridlines.</p>
 *
 * @return The left content inset for this toolbar
 *
 * @see #setContentInsetsRelative(int, int)
 * @see #setContentInsetsAbsolute(int, int)
 * @see #getContentInsetStart()
 * @see #getContentInsetEnd()
 * @see #getContentInsetRight()
 * @attr ref android.R.styleable#Toolbar_contentInsetLeft
 */
","/**
 * Gets the left content inset for this toolbar.
 *
 * <p>The content inset affects the valid area for Toolbar content other than
 * the navigation button and menu. Insets define the minimum margin for these components
 * and can be used to effectively align Toolbar content along well-known gridlines.</p>
 *
 * @return The left content inset for this toolbar
 *
 * @see #setContentInsetsRelative(int, int)
 * @see #setContentInsetsAbsolute(int, int)
 * @see #getContentInsetStart()
 * @see #getContentInsetEnd()
 * @see #getContentInsetRight()
 * @attr ref android.R.styleable#Toolbar_contentInsetLeft
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The change is that an additional null check condition has been added before calling getLeft() on mContentInsets, and the ternary operator was not present earlier. Code changes include both a control dependency change because the control flow now depends on whether mContentInsets is null or not, and an other statement changed due to the introduction of a ternary operator. Additionally, as this change affects what value is returned by the method (either a value from getLeft() or 0), this is also a return statement changed.","The late version introduces a null check for mContentInsets and returns 0 if mContentInsets is null, whereas the early version would have resulted in a NullPointerException if mContentInsets was null. This change means that the method could potentially return different values (0 instead of throwing an exception) between the two versions, thus there is a Compatibility Issue caused by potential different return values or types."
41,<android.net.NetworkRequest: int hashCode()>,24,25,<android.net.NetworkRequest: int hashCode()>,<android.net.NetworkRequest: int hashCode()>,0,"{
    return requestId + (legacyType * 1013) + (networkCapabilities.hashCode() * 1051);
}","{
    return Objects.hash(requestId, legacyType, networkCapabilities, type);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The implementation of the hashCode() method has been completely changed from using arithmetic operations to using the Objects.hash method. This is considered an ""Other statement changed"" as well as a ""Return statement changed"" because the actual return value of the method is computed differently.","The change in how the hashCode is computed means the API could potentially return different hash values for the same objects, if the layout of fields or their hashCodes have changed. This represents a CI type 1."
42,<android.hardware.camera2.params.OutputConfiguration: int hashCode()>,24,25,<android.hardware.camera2.params.OutputConfiguration: int hashCode()>,<android.hardware.camera2.params.OutputConfiguration: int hashCode()>,0,"{
    return HashCodeHelpers.hashCode(mRotation, mSurface.hashCode(), mConfiguredGenerationId, mConfiguredSize.hashCode(), mConfiguredFormat, mConfiguredDataspace, mSurfaceGroupId);
}","{
    // surface is set.
    if (mIsDeferredConfig) {
        return HashCodeHelpers.hashCode(mRotation, mConfiguredSize.hashCode(), mConfiguredFormat, mConfiguredDataspace, mSurfaceGroupId, mSurfaceType);
    }
    return HashCodeHelpers.hashCode(mRotation, mSurface.hashCode(), mConfiguredGenerationId, mConfiguredSize.hashCode(), mConfiguredFormat, mConfiguredDataspace, mSurfaceGroupId);
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"The late version implementation introduces a new control flow dependency (`if` statement) that checks `mIsDeferredConfig` and adjusts the return value accordingly, which includes different fields in the hash code calculation. So, there's a control dependency change (type 3) and a change in the return statement because a new code path that returns a different hash value has been introduced (type 1).","The introduction of the new control flow and the change in the fields used for the hash code calculation may lead to a different return value. Depending on the state of `mIsDeferredConfig`, the hash code for an `OutputConfiguration` object could be different between the early and late version, which is a compatibility issue of type 1."
45,<android.widget.LinearLayout: LayoutParams generateLayoutParams(LayoutParams)>,24,25,<android.widget.LinearLayout: LayoutParams generateLayoutParams(LayoutParams)>,<android.widget.LinearLayout: LayoutParams generateLayoutParams(LayoutParams)>,0,"{
    if (lp instanceof LayoutParams) {
        return new LayoutParams((LayoutParams) lp);
    } else if (lp instanceof MarginLayoutParams) {
        return new LayoutParams((MarginLayoutParams) lp);
    } else {
        return new LayoutParams(lp);
    }
}","{
    if (sPreserveMarginParamsInLayoutParamConversion) {
        if (lp instanceof LayoutParams) {
            return new LayoutParams((LayoutParams) lp);
        } else if (lp instanceof MarginLayoutParams) {
            return new LayoutParams((MarginLayoutParams) lp);
        }
    }
    return new LayoutParams(lp);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,"The code has introduced a new control flow dependency on the condition 'sPreserveMarginParamsInLayoutParamConversion'. The structure of the conditional has changed, which means a control dependency change (3).","There is no Compatibility Issue detected since the behavior of the API has been guarded by the new flag 'sPreserveMarginParamsInLayoutParamConversion'. When this flag is false, the late version behaves exactly like the early version. When the flag is true, it maintains the ability to handle the same types of parameters as before. This doesn't lead to a change in API behavior because it would still return a new `LayoutParams` object based on the type of `lp` passed to it. The return type remains the same, and the method still successfully handles all the types of `LayoutParams` it did before. Thus, no Compatibility Issue is identified."
46,<android.app.ActivityThread.H: void handleMessage(Message)>,24,25,<android.app.ActivityThread.H: void handleMessage(Message)>,<android.app.ActivityThread.H: void handleMessage(Message)>,0,"{
    if (DEBUG_MESSAGES)
        Slog.v(TAG, "">>> handling: "" + codeToString(msg.what));
    switch(msg.what) {
        case LAUNCH_ACTIVITY:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityStart"");
                final ActivityClientRecord r = (ActivityClientRecord) msg.obj;
                r.packageInfo = getPackageInfoNoCheck(r.activityInfo.applicationInfo, r.compatInfo);
                handleLaunchActivity(r, null, ""LAUNCH_ACTIVITY"");
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case RELAUNCH_ACTIVITY:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityRestart"");
                ActivityClientRecord r = (ActivityClientRecord) msg.obj;
                handleRelaunchActivity(r);
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case PAUSE_ACTIVITY:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityPause"");
                SomeArgs args = (SomeArgs) msg.obj;
                handlePauseActivity((IBinder) args.arg1, false, (args.argi1 & USER_LEAVING) != 0, args.argi2, (args.argi1 & DONT_REPORT) != 0, args.argi3);
                maybeSnapshot();
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case PAUSE_ACTIVITY_FINISHING:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityPause"");
                SomeArgs args = (SomeArgs) msg.obj;
                handlePauseActivity((IBinder) args.arg1, true, (args.argi1 & USER_LEAVING) != 0, args.argi2, (args.argi1 & DONT_REPORT) != 0, args.argi3);
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case STOP_ACTIVITY_SHOW:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityStop"");
                SomeArgs args = (SomeArgs) msg.obj;
                handleStopActivity((IBinder) args.arg1, true, args.argi2, args.argi3);
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case STOP_ACTIVITY_HIDE:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityStop"");
                SomeArgs args = (SomeArgs) msg.obj;
                handleStopActivity((IBinder) args.arg1, false, args.argi2, args.argi3);
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case SHOW_WINDOW:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityShowWindow"");
            handleWindowVisibility((IBinder) msg.obj, true);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case HIDE_WINDOW:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityHideWindow"");
            handleWindowVisibility((IBinder) msg.obj, false);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case RESUME_ACTIVITY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityResume"");
            SomeArgs args = (SomeArgs) msg.obj;
            handleResumeActivity((IBinder) args.arg1, true, args.argi1 != 0, true, args.argi3, ""RESUME_ACTIVITY"");
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SEND_RESULT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityDeliverResult"");
            handleSendResult((ResultData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case DESTROY_ACTIVITY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityDestroy"");
            handleDestroyActivity((IBinder) msg.obj, msg.arg1 != 0, msg.arg2, false);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case BIND_APPLICATION:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""bindApplication"");
            AppBindData data = (AppBindData) msg.obj;
            handleBindApplication(data);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case EXIT_APPLICATION:
            if (mInitialApplication != null) {
                mInitialApplication.onTerminate();
            }
            Looper.myLooper().quit();
            break;
        case NEW_INTENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityNewIntent"");
            handleNewIntent((NewIntentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case RECEIVER:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastReceiveComp"");
            handleReceiver((ReceiverData) msg.obj);
            maybeSnapshot();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CREATE_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (""serviceCreate: "" + String.valueOf(msg.obj)));
            handleCreateService((CreateServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case BIND_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceBind"");
            handleBindService((BindServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UNBIND_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceUnbind"");
            handleUnbindService((BindServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SERVICE_ARGS:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (""serviceStart: "" + String.valueOf(msg.obj)));
            handleServiceArgs((ServiceArgsData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case STOP_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceStop"");
            handleStopService((IBinder) msg.obj);
            maybeSnapshot();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CONFIGURATION_CHANGED:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""configChanged"");
            mCurDefaultDisplayDpi = ((Configuration) msg.obj).densityDpi;
            handleConfigurationChanged((Configuration) msg.obj, null);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CLEAN_UP_CONTEXT:
            ContextCleanupInfo cci = (ContextCleanupInfo) msg.obj;
            cci.context.performFinalCleanup(cci.who, cci.what);
            break;
        case GC_WHEN_IDLE:
            scheduleGcIdler();
            break;
        case DUMP_SERVICE:
            handleDumpService((DumpComponentInfo) msg.obj);
            break;
        case LOW_MEMORY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""lowMemory"");
            handleLowMemory();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case ACTIVITY_CONFIGURATION_CHANGED:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityConfigChanged"");
            handleActivityConfigurationChanged((ActivityConfigChangeData) msg.obj, msg.arg1 == 1 ? REPORT_TO_ACTIVITY : !REPORT_TO_ACTIVITY);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case PROFILER_CONTROL:
            handleProfilerControl(msg.arg1 != 0, (ProfilerInfo) msg.obj, msg.arg2);
            break;
        case CREATE_BACKUP_AGENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""backupCreateAgent"");
            handleCreateBackupAgent((CreateBackupAgentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case DESTROY_BACKUP_AGENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""backupDestroyAgent"");
            handleDestroyBackupAgent((CreateBackupAgentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SUICIDE:
            Process.killProcess(Process.myPid());
            break;
        case REMOVE_PROVIDER:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""providerRemove"");
            completeRemoveProvider((ProviderRefCount) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case ENABLE_JIT:
            ensureJitEnabled();
            break;
        case DISPATCH_PACKAGE_BROADCAST:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastPackage"");
            handleDispatchPackageBroadcast(msg.arg1, (String[]) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SCHEDULE_CRASH:
            throw new RemoteServiceException((String) msg.obj);
        case DUMP_HEAP:
            handleDumpHeap(msg.arg1 != 0, (DumpHeapData) msg.obj);
            break;
        case DUMP_ACTIVITY:
            handleDumpActivity((DumpComponentInfo) msg.obj);
            break;
        case DUMP_PROVIDER:
            handleDumpProvider((DumpComponentInfo) msg.obj);
            break;
        case SLEEPING:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""sleeping"");
            handleSleeping((IBinder) msg.obj, msg.arg1 != 0);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SET_CORE_SETTINGS:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""setCoreSettings"");
            handleSetCoreSettings((Bundle) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UPDATE_PACKAGE_COMPATIBILITY_INFO:
            handleUpdatePackageCompatibilityInfo((UpdateCompatibilityData) msg.obj);
            break;
        case TRIM_MEMORY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""trimMemory"");
            handleTrimMemory(msg.arg1);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UNSTABLE_PROVIDER_DIED:
            handleUnstableProviderDied((IBinder) msg.obj, false);
            break;
        case REQUEST_ASSIST_CONTEXT_EXTRAS:
            handleRequestAssistContextExtras((RequestAssistContextExtras) msg.obj);
            break;
        case TRANSLUCENT_CONVERSION_COMPLETE:
            handleTranslucentConversionComplete((IBinder) msg.obj, msg.arg1 == 1);
            break;
        case INSTALL_PROVIDER:
            handleInstallProvider((ProviderInfo) msg.obj);
            break;
        case ON_NEW_ACTIVITY_OPTIONS:
            Pair<IBinder, ActivityOptions> pair = (Pair<IBinder, ActivityOptions>) msg.obj;
            onNewActivityOptions(pair.first, pair.second);
            break;
        case CANCEL_VISIBLE_BEHIND:
            handleCancelVisibleBehind((IBinder) msg.obj);
            break;
        case BACKGROUND_VISIBLE_BEHIND_CHANGED:
            handleOnBackgroundVisibleBehindChanged((IBinder) msg.obj, msg.arg1 > 0);
            break;
        case ENTER_ANIMATION_COMPLETE:
            handleEnterAnimationComplete((IBinder) msg.obj);
            break;
        case START_BINDER_TRACKING:
            handleStartBinderTracking();
            break;
        case STOP_BINDER_TRACKING_AND_DUMP:
            handleStopBinderTrackingAndDump((ParcelFileDescriptor) msg.obj);
            break;
        case MULTI_WINDOW_MODE_CHANGED:
            handleMultiWindowModeChanged((IBinder) msg.obj, msg.arg1 == 1);
            break;
        case PICTURE_IN_PICTURE_MODE_CHANGED:
            handlePictureInPictureModeChanged((IBinder) msg.obj, msg.arg1 == 1);
            break;
        case LOCAL_VOICE_INTERACTION_STARTED:
            handleLocalVoiceInteractionStarted((IBinder) ((SomeArgs) msg.obj).arg1, (IVoiceInteractor) ((SomeArgs) msg.obj).arg2);
            break;
    }
    Object obj = msg.obj;
    if (obj instanceof SomeArgs) {
        ((SomeArgs) obj).recycle();
    }
    if (DEBUG_MESSAGES)
        Slog.v(TAG, ""<<< done: "" + codeToString(msg.what));
}","{
    if (DEBUG_MESSAGES)
        Slog.v(TAG, "">>> handling: "" + codeToString(msg.what));
    switch(msg.what) {
        case LAUNCH_ACTIVITY:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityStart"");
                final ActivityClientRecord r = (ActivityClientRecord) msg.obj;
                r.packageInfo = getPackageInfoNoCheck(r.activityInfo.applicationInfo, r.compatInfo);
                handleLaunchActivity(r, null, ""LAUNCH_ACTIVITY"");
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case RELAUNCH_ACTIVITY:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityRestart"");
                ActivityClientRecord r = (ActivityClientRecord) msg.obj;
                handleRelaunchActivity(r);
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case PAUSE_ACTIVITY:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityPause"");
                SomeArgs args = (SomeArgs) msg.obj;
                handlePauseActivity((IBinder) args.arg1, false, (args.argi1 & USER_LEAVING) != 0, args.argi2, (args.argi1 & DONT_REPORT) != 0, args.argi3);
                maybeSnapshot();
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case PAUSE_ACTIVITY_FINISHING:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityPause"");
                SomeArgs args = (SomeArgs) msg.obj;
                handlePauseActivity((IBinder) args.arg1, true, (args.argi1 & USER_LEAVING) != 0, args.argi2, (args.argi1 & DONT_REPORT) != 0, args.argi3);
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case STOP_ACTIVITY_SHOW:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityStop"");
                SomeArgs args = (SomeArgs) msg.obj;
                handleStopActivity((IBinder) args.arg1, true, args.argi2, args.argi3);
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case STOP_ACTIVITY_HIDE:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityStop"");
                SomeArgs args = (SomeArgs) msg.obj;
                handleStopActivity((IBinder) args.arg1, false, args.argi2, args.argi3);
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case SHOW_WINDOW:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityShowWindow"");
            handleWindowVisibility((IBinder) msg.obj, true);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case HIDE_WINDOW:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityHideWindow"");
            handleWindowVisibility((IBinder) msg.obj, false);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case RESUME_ACTIVITY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityResume"");
            SomeArgs args = (SomeArgs) msg.obj;
            handleResumeActivity((IBinder) args.arg1, true, args.argi1 != 0, true, args.argi3, ""RESUME_ACTIVITY"");
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SEND_RESULT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityDeliverResult"");
            handleSendResult((ResultData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case DESTROY_ACTIVITY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityDestroy"");
            handleDestroyActivity((IBinder) msg.obj, msg.arg1 != 0, msg.arg2, false);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case BIND_APPLICATION:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""bindApplication"");
            AppBindData data = (AppBindData) msg.obj;
            handleBindApplication(data);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case EXIT_APPLICATION:
            if (mInitialApplication != null) {
                mInitialApplication.onTerminate();
            }
            Looper.myLooper().quit();
            break;
        case NEW_INTENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityNewIntent"");
            handleNewIntent((NewIntentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case RECEIVER:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastReceiveComp"");
            handleReceiver((ReceiverData) msg.obj);
            maybeSnapshot();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CREATE_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (""serviceCreate: "" + String.valueOf(msg.obj)));
            handleCreateService((CreateServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case BIND_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceBind"");
            handleBindService((BindServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UNBIND_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceUnbind"");
            handleUnbindService((BindServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SERVICE_ARGS:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (""serviceStart: "" + String.valueOf(msg.obj)));
            handleServiceArgs((ServiceArgsData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case STOP_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceStop"");
            handleStopService((IBinder) msg.obj);
            maybeSnapshot();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CONFIGURATION_CHANGED:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""configChanged"");
            mCurDefaultDisplayDpi = ((Configuration) msg.obj).densityDpi;
            mUpdatingSystemConfig = true;
            handleConfigurationChanged((Configuration) msg.obj, null);
            mUpdatingSystemConfig = false;
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CLEAN_UP_CONTEXT:
            ContextCleanupInfo cci = (ContextCleanupInfo) msg.obj;
            cci.context.performFinalCleanup(cci.who, cci.what);
            break;
        case GC_WHEN_IDLE:
            scheduleGcIdler();
            break;
        case DUMP_SERVICE:
            handleDumpService((DumpComponentInfo) msg.obj);
            break;
        case LOW_MEMORY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""lowMemory"");
            handleLowMemory();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case ACTIVITY_CONFIGURATION_CHANGED:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityConfigChanged"");
            handleActivityConfigurationChanged((ActivityConfigChangeData) msg.obj, msg.arg1 == 1 ? REPORT_TO_ACTIVITY : !REPORT_TO_ACTIVITY);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case PROFILER_CONTROL:
            handleProfilerControl(msg.arg1 != 0, (ProfilerInfo) msg.obj, msg.arg2);
            break;
        case CREATE_BACKUP_AGENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""backupCreateAgent"");
            handleCreateBackupAgent((CreateBackupAgentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case DESTROY_BACKUP_AGENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""backupDestroyAgent"");
            handleDestroyBackupAgent((CreateBackupAgentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SUICIDE:
            Process.killProcess(Process.myPid());
            break;
        case REMOVE_PROVIDER:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""providerRemove"");
            completeRemoveProvider((ProviderRefCount) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case ENABLE_JIT:
            ensureJitEnabled();
            break;
        case DISPATCH_PACKAGE_BROADCAST:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastPackage"");
            handleDispatchPackageBroadcast(msg.arg1, (String[]) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SCHEDULE_CRASH:
            throw new RemoteServiceException((String) msg.obj);
        case DUMP_HEAP:
            handleDumpHeap(msg.arg1 != 0, (DumpHeapData) msg.obj);
            break;
        case DUMP_ACTIVITY:
            handleDumpActivity((DumpComponentInfo) msg.obj);
            break;
        case DUMP_PROVIDER:
            handleDumpProvider((DumpComponentInfo) msg.obj);
            break;
        case SLEEPING:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""sleeping"");
            handleSleeping((IBinder) msg.obj, msg.arg1 != 0);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SET_CORE_SETTINGS:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""setCoreSettings"");
            handleSetCoreSettings((Bundle) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UPDATE_PACKAGE_COMPATIBILITY_INFO:
            handleUpdatePackageCompatibilityInfo((UpdateCompatibilityData) msg.obj);
            break;
        case TRIM_MEMORY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""trimMemory"");
            handleTrimMemory(msg.arg1);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UNSTABLE_PROVIDER_DIED:
            handleUnstableProviderDied((IBinder) msg.obj, false);
            break;
        case REQUEST_ASSIST_CONTEXT_EXTRAS:
            handleRequestAssistContextExtras((RequestAssistContextExtras) msg.obj);
            break;
        case TRANSLUCENT_CONVERSION_COMPLETE:
            handleTranslucentConversionComplete((IBinder) msg.obj, msg.arg1 == 1);
            break;
        case INSTALL_PROVIDER:
            handleInstallProvider((ProviderInfo) msg.obj);
            break;
        case ON_NEW_ACTIVITY_OPTIONS:
            Pair<IBinder, ActivityOptions> pair = (Pair<IBinder, ActivityOptions>) msg.obj;
            onNewActivityOptions(pair.first, pair.second);
            break;
        case CANCEL_VISIBLE_BEHIND:
            handleCancelVisibleBehind((IBinder) msg.obj);
            break;
        case BACKGROUND_VISIBLE_BEHIND_CHANGED:
            handleOnBackgroundVisibleBehindChanged((IBinder) msg.obj, msg.arg1 > 0);
            break;
        case ENTER_ANIMATION_COMPLETE:
            handleEnterAnimationComplete((IBinder) msg.obj);
            break;
        case START_BINDER_TRACKING:
            handleStartBinderTracking();
            break;
        case STOP_BINDER_TRACKING_AND_DUMP:
            handleStopBinderTrackingAndDump((ParcelFileDescriptor) msg.obj);
            break;
        case MULTI_WINDOW_MODE_CHANGED:
            handleMultiWindowModeChanged((IBinder) msg.obj, msg.arg1 == 1);
            break;
        case PICTURE_IN_PICTURE_MODE_CHANGED:
            handlePictureInPictureModeChanged((IBinder) msg.obj, msg.arg1 == 1);
            break;
        case LOCAL_VOICE_INTERACTION_STARTED:
            handleLocalVoiceInteractionStarted((IBinder) ((SomeArgs) msg.obj).arg1, (IVoiceInteractor) ((SomeArgs) msg.obj).arg2);
            break;
    }
    Object obj = msg.obj;
    if (obj instanceof SomeArgs) {
        ((SomeArgs) obj).recycle();
    }
    if (DEBUG_MESSAGES)
        Slog.v(TAG, ""<<< done: "" + codeToString(msg.what));
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
47,<android.app.ContextImpl: File[] getExternalFilesDirs(String)>,24,25,<android.app.ContextImpl: File[] getExternalFilesDirs(String)>,<android.app.ContextImpl: File[] getExternalFilesDirs(String)>,0,"{
    synchronized (mSync) {
        if (mExternalFilesDirs == null) {
            mExternalFilesDirs = Environment.buildExternalStorageAppFilesDirs(getPackageName());
        }
        // Splice in requested type, if any
        File[] dirs = mExternalFilesDirs;
        if (type != null) {
            dirs = Environment.buildPaths(dirs, type);
        }
        // Create dirs if needed
        return ensureExternalDirsExistOrFilter(dirs);
    }
}","{
    synchronized (mSync) {
        File[] dirs = Environment.buildExternalStorageAppFilesDirs(getPackageName());
        if (type != null) {
            dirs = Environment.buildPaths(dirs, type);
        }
        return ensureExternalDirsExistOrFilter(dirs);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The code change is the removal of the condition checking for 'mExternalFilesDirs == null' and its associated assignment to 'mExternalFilesDirs'. This alters how 'dirs' is assigned but does not impact the method's external behavior because 'dirs' is immediately assigned in the next line with the result of 'Environment.buildExternalStorageAppFilesDirs(getPackageName())'. Therefore, the type of modification is 4.","There's no Compatibility Issue because the change in implementation does not affect the behavior observed by the clients of the API. The method still returns the result of 'ensureExternalDirsExistOrFilter(dirs)', which depends on the 'dirs' constructed in the same way as before in practical use."
49,<android.app.ContextImpl: File[] getObbDirs()>,24,25,<android.app.ContextImpl: File[] getObbDirs()>,<android.app.ContextImpl: File[] getObbDirs()>,0,"{
    synchronized (mSync) {
        if (mExternalObbDirs == null) {
            mExternalObbDirs = Environment.buildExternalStorageAppObbDirs(getPackageName());
        }
        // Create dirs if needed
        return ensureExternalDirsExistOrFilter(mExternalObbDirs);
    }
}","{
    synchronized (mSync) {
        File[] dirs = Environment.buildExternalStorageAppObbDirs(getPackageName());
        return ensureExternalDirsExistOrFilter(dirs);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The implementation has changed to always call Environment.buildExternalStorageAppObbDirs without checking if mExternalObbDirs is null and without assigning the result to mExternalObbDirs. Therefore, the implementation avoids using the potentially cached directory paths and always rebuilds them. The code change type is 4 because only the assignment to a variable has been removed, which does not fall under the other specified change types.","There is no Compatibility Issue here. The alteration made to the code does not change the behavior in terms of returning a different value or throwing a different exception. The API still returns the result of ensureExternalDirsExistOrFilter, which now uses a freshly built array of directories each time instead of possibly reusing a previously built one. This change does not inherently lead to different outcomes from the perspective of the API's caller as the result is filtered through ensureExternalDirsExistOrFilter to ensure the directories exist."
50,<android.hardware.camera2.impl.CameraCaptureSessionImpl: void close()>,24,25,<android.hardware.camera2.impl.CameraCaptureSessionImpl: void close()>,<android.hardware.camera2.impl.CameraCaptureSessionImpl: void close()>,0,"{
    if (mClosed) {
        if (DEBUG)
            Log.v(TAG, mIdString + ""close - reentering"");
        return;
    }
    if (DEBUG)
        Log.v(TAG, mIdString + ""close - first time"");
    mClosed = true;
    /*
         * Flush out any repeating request. Since camera is closed, no new requests
         * can be queued, and eventually the entire request queue will be drained.
         *
         * If the camera device was already closed, short circuit and do nothing; since
         * no more internal device callbacks will fire anyway.
         *
         * Otherwise, once stopRepeating is done, wait for camera to idle, then unconfigure the
         * camera. Once that's done, fire #onClosed.
         */
    try {
        mDeviceImpl.stopRepeating();
    } catch (IllegalStateException e) {
        // OK: Camera device may already be closed, nothing else to do
        // TODO: Fire onClosed anytime we get the device onClosed or the ISE?
        // or just suppress the ISE only and rely onClosed.
        // Also skip any of the draining work if this is already closed.
        // Short-circuit; queue callback immediately and return
        mStateCallback.onClosed(this);
        return;
    } catch (CameraAccessException e) {
        // OK: close does not throw checked exceptions.
        Log.e(TAG, mIdString + ""Exception while stopping repeating: "", e);
    // TODO: call onError instead of onClosed if this happens
    }
    // If no sequences are pending, fire #onClosed immediately
    mSequenceDrainer.beginDrain();
}","{
    synchronized (this) {
        if (mClosed) {
            if (DEBUG)
                Log.v(TAG, mIdString + ""close - reentering"");
            return;
        }
        if (DEBUG)
            Log.v(TAG, mIdString + ""close - first time"");
        mClosed = true;
    }
    synchronized (mDeviceImpl.mInterfaceLock) {
        synchronized (this) {
            /*
                 * Flush out any repeating request. Since camera is closed, no new requests
                 * can be queued, and eventually the entire request queue will be drained.
                 *
                 * If the camera device was already closed, short circuit and do nothing; since
                 * no more internal device callbacks will fire anyway.
                 *
                 * Otherwise, once stopRepeating is done, wait for camera to idle, then unconfigure
                 * the camera. Once that's done, fire #onClosed.
                 */
            try {
                mDeviceImpl.stopRepeating();
            } catch (IllegalStateException e) {
                // OK: Camera device may already be closed, nothing else to do
                // TODO: Fire onClosed anytime we get the device onClosed or the ISE?
                // or just suppress the ISE only and rely onClosed.
                // Also skip any of the draining work if this is already closed.
                // Short-circuit; queue callback immediately and return
                mStateCallback.onClosed(this);
                return;
            } catch (CameraAccessException e) {
                // OK: close does not throw checked exceptions.
                Log.e(TAG, mIdString + ""Exception while stopping repeating: "", e);
            // TODO: call onError instead of onClosed if this happens
            }
        }
    }
    synchronized (this) {
        // If no sequences are pending, fire #onClosed immediately
        mSequenceDrainer.beginDrain();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"Synchronization blocks have been introduced around the existing implementation. The code outside the try-catch blocks is wrapped in a synchronized block on the `this` object, and another synchronized block on `mDeviceImpl.mInterfaceLock` is added around the try-catch blocks. The actual logic of the code hasn't changed, only the order of execution may be enforced to be more thread-safe. No statements affecting return variables or exceptions have been introduced or removed.","Since the new synchronization blocks do not alter the control flow related to return values or exceptions being thrown, they do not cause a compatibility issue. The actual operations performed are the same and will result in the same behavior from an external perspective, assuming correct multi-threaded handling in client code."
51,<android.service.quicksettings.TileService: void unlockAndRun(Runnable)>,24,25,<android.service.quicksettings.TileService: void unlockAndRun(Runnable)>,<android.service.quicksettings.TileService: void unlockAndRun(Runnable)>,0,"{
    mUnlockRunnable = runnable;
    try {
        mService.startUnlockAndRun(mTile);
    } catch (RemoteException e) {
    }
}","{
    mUnlockRunnable = runnable;
    try {
        mService.startUnlockAndRun(mTileToken);
    } catch (RemoteException e) {
    }
}",1,"/**
 * Prompts the user to unlock the device before executing the Runnable.
 * <p>
 * The user will be prompted for their current security method if applicable
 * and if successful, runnable will be executed.  The Runnable will not be
 * executed if the user fails to unlock the device or cancels the operation.
 */
","/**
 * Prompts the user to unlock the device before executing the Runnable.
 * <p>
 * The user will be prompted for their current security method if applicable
 * and if successful, runnable will be executed.  The Runnable will not be
 * executed if the user fails to unlock the device or cancels the operation.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The change occurred in the parameter passed to the `startUnlockAndRun` method, from `mTile` to `mTileToken`. This indicates a change in a variable being used, which is considered as type 4, and also indicates a dependent API change as it involves the method `startUnlockAndRun`, so it is also a type 5 change.","No Compatibility Issue is detected because, from the given information, there's no indication that this change would lead to the API returning a different value or throwing a different exception. The exception handling for `RemoteException` has not been modified, and there's no change in the control flow or return values within the `unlockAndRun` method itself."
52,"<android.widget.AbsListView: View obtainView(int,boolean[])>",24,25,"<android.widget.AbsListView: View obtainView(int,boolean[])>","<android.widget.AbsListView: View obtainView(int,boolean[])>",0,"{
    Trace.traceBegin(Trace.TRACE_TAG_VIEW, ""obtainView"");
    isScrap[0] = false;
    // Check whether we have a transient state view. Attempt to re-bind the
    // data and discard the view if we fail.
    final View transientView = mRecycler.getTransientStateView(position);
    if (transientView != null) {
        final LayoutParams params = (LayoutParams) transientView.getLayoutParams();
        // If the view type hasn't changed, attempt to re-bind the data.
        if (params.viewType == mAdapter.getItemViewType(position)) {
            final View updatedView = mAdapter.getView(position, transientView, this);
            // If we failed to re-bind the data, scrap the obtained view.
            if (updatedView != transientView) {
                setItemViewLayoutParams(updatedView, position);
                mRecycler.addScrapView(updatedView, position);
            }
        }
        isScrap[0] = true;
        // Finish the temporary detach started in addScrapView().
        transientView.dispatchFinishTemporaryDetach();
        return transientView;
    }
    final View scrapView = mRecycler.getScrapView(position);
    final View child = mAdapter.getView(position, scrapView, this);
    if (scrapView != null) {
        if (child != scrapView) {
            // Failed to re-bind the data, return scrap to the heap.
            mRecycler.addScrapView(scrapView, position);
        } else {
            if (child.isTemporarilyDetached()) {
                isScrap[0] = true;
                // Finish the temporary detach started in addScrapView().
                child.dispatchFinishTemporaryDetach();
            } else {
                // we set isScrap to ""true"" only if the view is temporarily detached.
                // if the view is fully detached, it is as good as a view created by the
                // adapter
                isScrap[0] = false;
            }
        }
    }
    if (mCacheColorHint != 0) {
        child.setDrawingCacheBackgroundColor(mCacheColorHint);
    }
    if (child.getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
        child.setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);
    }
    setItemViewLayoutParams(child, position);
    if (AccessibilityManager.getInstance(mContext).isEnabled()) {
        if (mAccessibilityDelegate == null) {
            mAccessibilityDelegate = new ListItemAccessibilityDelegate();
        }
        if (child.getAccessibilityDelegate() == null) {
            child.setAccessibilityDelegate(mAccessibilityDelegate);
        }
    }
    Trace.traceEnd(Trace.TRACE_TAG_VIEW);
    return child;
}","{
    Trace.traceBegin(Trace.TRACE_TAG_VIEW, ""obtainView"");
    outMetadata[0] = false;
    // Check whether we have a transient state view. Attempt to re-bind the
    // data and discard the view if we fail.
    final View transientView = mRecycler.getTransientStateView(position);
    if (transientView != null) {
        final LayoutParams params = (LayoutParams) transientView.getLayoutParams();
        // If the view type hasn't changed, attempt to re-bind the data.
        if (params.viewType == mAdapter.getItemViewType(position)) {
            final View updatedView = mAdapter.getView(position, transientView, this);
            // If we failed to re-bind the data, scrap the obtained view.
            if (updatedView != transientView) {
                setItemViewLayoutParams(updatedView, position);
                mRecycler.addScrapView(updatedView, position);
            }
        }
        outMetadata[0] = true;
        // Finish the temporary detach started in addScrapView().
        transientView.dispatchFinishTemporaryDetach();
        return transientView;
    }
    final View scrapView = mRecycler.getScrapView(position);
    final View child = mAdapter.getView(position, scrapView, this);
    if (scrapView != null) {
        if (child != scrapView) {
            // Failed to re-bind the data, return scrap to the heap.
            mRecycler.addScrapView(scrapView, position);
        } else if (child.isTemporarilyDetached()) {
            outMetadata[0] = true;
            // Finish the temporary detach started in addScrapView().
            child.dispatchFinishTemporaryDetach();
        }
    }
    if (mCacheColorHint != 0) {
        child.setDrawingCacheBackgroundColor(mCacheColorHint);
    }
    if (child.getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
        child.setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);
    }
    setItemViewLayoutParams(child, position);
    if (AccessibilityManager.getInstance(mContext).isEnabled()) {
        if (mAccessibilityDelegate == null) {
            mAccessibilityDelegate = new ListItemAccessibilityDelegate();
        }
        if (child.getAccessibilityDelegate() == null) {
            child.setAccessibilityDelegate(mAccessibilityDelegate);
        }
    }
    Trace.traceEnd(Trace.TRACE_TAG_VIEW);
    return child;
}",1,"/**
 * Get a view and have it show the data associated with the specified
 * position. This is called when we have already discovered that the view is
 * not available for reuse in the recycle bin. The only choices left are
 * converting an old view or making a new one.
 *
 * @param position The position to display
 * @param isScrap Array of at least 1 boolean, the first entry will become true if
 * the returned view was taken from the ""temporary detached"" scrap heap, false if
 * otherwise.
 *
 * @return A view displaying the data associated with the specified position
 */
","/**
 * Gets a view and have it show the data associated with the specified
 * position. This is called when we have already discovered that the view
 * is not available for reuse in the recycle bin. The only choices left are
 * converting an old view or making a new one.
 *
 * @param position the position to display
 * @param outMetadata an array of at least 1 boolean where the first entry
 * will be set {@code true} if the view is currently
 * attached to the window, {@code false} otherwise (e.g.
 * newly-inflated or remained scrap for multiple layout
 * passes)
 *
 * @return A view displaying the data associated with the specified position
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
53,<android.app.ActivityTransitionState: boolean startExitBackTransition(Activity)>,24,25,<android.app.ActivityTransitionState: boolean startExitBackTransition(Activity)>,<android.app.ActivityTransitionState: boolean startExitBackTransition(Activity)>,0,"{
    if (mEnteringNames == null || mCalledExitCoordinator != null) {
        return false;
    } else {
        if (!mHasExited) {
            mHasExited = true;
            Transition enterViewsTransition = null;
            ViewGroup decor = null;
            boolean delayExitBack = false;
            if (mEnterTransitionCoordinator != null) {
                enterViewsTransition = mEnterTransitionCoordinator.getEnterViewsTransition();
                decor = mEnterTransitionCoordinator.getDecor();
                delayExitBack = mEnterTransitionCoordinator.cancelEnter();
                mEnterTransitionCoordinator = null;
                if (enterViewsTransition != null && decor != null) {
                    enterViewsTransition.pause(decor);
                }
            }
            mReturnExitCoordinator = new ExitTransitionCoordinator(activity, mEnteringNames, null, null, true);
            if (enterViewsTransition != null && decor != null) {
                enterViewsTransition.resume(decor);
            }
            if (delayExitBack && decor != null) {
                final ViewGroup finalDecor = decor;
                decor.getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {

                    @Override
                    public boolean onPreDraw() {
                        finalDecor.getViewTreeObserver().removeOnPreDrawListener(this);
                        if (mReturnExitCoordinator != null) {
                            mReturnExitCoordinator.startExit(activity.mResultCode, activity.mResultData);
                        }
                        return true;
                    }
                });
            } else {
                mReturnExitCoordinator.startExit(activity.mResultCode, activity.mResultData);
            }
        }
        return true;
    }
}","{
    if (mEnteringNames == null || mCalledExitCoordinator != null) {
        return false;
    } else {
        if (!mHasExited) {
            mHasExited = true;
            Transition enterViewsTransition = null;
            ViewGroup decor = null;
            boolean delayExitBack = false;
            if (mEnterTransitionCoordinator != null) {
                enterViewsTransition = mEnterTransitionCoordinator.getEnterViewsTransition();
                decor = mEnterTransitionCoordinator.getDecor();
                delayExitBack = mEnterTransitionCoordinator.cancelEnter();
                mEnterTransitionCoordinator = null;
                if (enterViewsTransition != null && decor != null) {
                    enterViewsTransition.pause(decor);
                }
            }
            mReturnExitCoordinator = new ExitTransitionCoordinator(activity, activity.getWindow(), activity.mEnterTransitionListener, mEnteringNames, null, null, true);
            if (enterViewsTransition != null && decor != null) {
                enterViewsTransition.resume(decor);
            }
            if (delayExitBack && decor != null) {
                final ViewGroup finalDecor = decor;
                decor.getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {

                    @Override
                    public boolean onPreDraw() {
                        finalDecor.getViewTreeObserver().removeOnPreDrawListener(this);
                        if (mReturnExitCoordinator != null) {
                            mReturnExitCoordinator.startExit(activity.mResultCode, activity.mResultData);
                        }
                        return true;
                    }
                });
            } else {
                mReturnExitCoordinator.startExit(activity.mResultCode, activity.mResultData);
            }
        }
        return true;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,5,0,"The ""new ExitTransitionCoordinator"" constructor call is different, with extra parameters passed in the late implementation. This is a modification that falls under Dependent API changed, so the code change type is 5.","The method's behavior has not changed in terms of return values or exception handling; only the internal object creation logic is modified. Since this change does not cause the API to return a different value or throw a different exception, it is not considered a Compatibility Issue, leading to a CI type of 0."
54,"<android.service.wallpaper.WallpaperService.Engine: void updateSurface(boolean,boolean,boolean)>",24,25,"<android.service.wallpaper.WallpaperService.Engine: void updateSurface(boolean,boolean,boolean)>","<android.service.wallpaper.WallpaperService.Engine: void updateSurface(boolean,boolean,boolean)>",0,"{
    if (mDestroyed) {
        Log.w(TAG, ""Ignoring updateSurface: destroyed"");
    }
    boolean fixedSize = false;
    int myWidth = mSurfaceHolder.getRequestedWidth();
    if (myWidth <= 0)
        myWidth = ViewGroup.LayoutParams.MATCH_PARENT;
    else
        fixedSize = true;
    int myHeight = mSurfaceHolder.getRequestedHeight();
    if (myHeight <= 0)
        myHeight = ViewGroup.LayoutParams.MATCH_PARENT;
    else
        fixedSize = true;
    final boolean creating = !mCreated;
    final boolean surfaceCreating = !mSurfaceCreated;
    final boolean formatChanged = mFormat != mSurfaceHolder.getRequestedFormat();
    boolean sizeChanged = mWidth != myWidth || mHeight != myHeight;
    boolean insetsChanged = !mCreated;
    final boolean typeChanged = mType != mSurfaceHolder.getRequestedType();
    final boolean flagsChanged = mCurWindowFlags != mWindowFlags || mCurWindowPrivateFlags != mWindowPrivateFlags;
    if (forceRelayout || creating || surfaceCreating || formatChanged || sizeChanged || typeChanged || flagsChanged || redrawNeeded || !mIWallpaperEngine.mShownReported) {
        if (DEBUG)
            Log.v(TAG, ""Changes: creating="" + creating + "" format="" + formatChanged + "" size="" + sizeChanged);
        try {
            mWidth = myWidth;
            mHeight = myHeight;
            mFormat = mSurfaceHolder.getRequestedFormat();
            mType = mSurfaceHolder.getRequestedType();
            mLayout.x = 0;
            mLayout.y = 0;
            mLayout.width = myWidth;
            mLayout.height = myHeight;
            mLayout.format = mFormat;
            mCurWindowFlags = mWindowFlags;
            mLayout.flags = mWindowFlags | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
            mCurWindowPrivateFlags = mWindowPrivateFlags;
            mLayout.privateFlags = mWindowPrivateFlags;
            mLayout.memoryType = mType;
            mLayout.token = mWindowToken;
            if (!mCreated) {
                // Retrieve watch round info
                TypedArray windowStyle = obtainStyledAttributes(com.android.internal.R.styleable.Window);
                windowStyle.recycle();
                // Add window
                mLayout.type = mIWallpaperEngine.mWindowType;
                mLayout.gravity = Gravity.START | Gravity.TOP;
                mLayout.setTitle(WallpaperService.this.getClass().getName());
                mLayout.windowAnimations = com.android.internal.R.style.Animation_Wallpaper;
                mInputChannel = new InputChannel();
                if (mSession.addToDisplay(mWindow, mWindow.mSeq, mLayout, View.VISIBLE, Display.DEFAULT_DISPLAY, mContentInsets, mStableInsets, mOutsets, mInputChannel) < 0) {
                    Log.w(TAG, ""Failed to add window while updating wallpaper surface."");
                    return;
                }
                mCreated = true;
                mInputEventReceiver = new WallpaperInputEventReceiver(mInputChannel, Looper.myLooper());
            }
            mSurfaceHolder.mSurfaceLock.lock();
            mDrawingAllowed = true;
            if (!fixedSize) {
                mLayout.surfaceInsets.set(mIWallpaperEngine.mDisplayPadding);
                mLayout.surfaceInsets.left += mOutsets.left;
                mLayout.surfaceInsets.top += mOutsets.top;
                mLayout.surfaceInsets.right += mOutsets.right;
                mLayout.surfaceInsets.bottom += mOutsets.bottom;
            } else {
                mLayout.surfaceInsets.set(0, 0, 0, 0);
            }
            final int relayoutResult = mSession.relayout(mWindow, mWindow.mSeq, mLayout, mWidth, mHeight, View.VISIBLE, 0, mWinFrame, mOverscanInsets, mContentInsets, mVisibleInsets, mStableInsets, mOutsets, mBackdropFrame, mConfiguration, mSurfaceHolder.mSurface);
            if (DEBUG)
                Log.v(TAG, ""New surface: "" + mSurfaceHolder.mSurface + "", frame="" + mWinFrame);
            int w = mWinFrame.width();
            int h = mWinFrame.height();
            if (!fixedSize) {
                final Rect padding = mIWallpaperEngine.mDisplayPadding;
                w += padding.left + padding.right + mOutsets.left + mOutsets.right;
                h += padding.top + padding.bottom + mOutsets.top + mOutsets.bottom;
                mOverscanInsets.left += padding.left;
                mOverscanInsets.top += padding.top;
                mOverscanInsets.right += padding.right;
                mOverscanInsets.bottom += padding.bottom;
                mContentInsets.left += padding.left;
                mContentInsets.top += padding.top;
                mContentInsets.right += padding.right;
                mContentInsets.bottom += padding.bottom;
                mStableInsets.left += padding.left;
                mStableInsets.top += padding.top;
                mStableInsets.right += padding.right;
                mStableInsets.bottom += padding.bottom;
            }
            if (mCurWidth != w) {
                sizeChanged = true;
                mCurWidth = w;
            }
            if (mCurHeight != h) {
                sizeChanged = true;
                mCurHeight = h;
            }
            if (DEBUG) {
                Log.v(TAG, ""Wallpaper size has changed: ("" + mCurWidth + "", "" + mCurHeight);
            }
            insetsChanged |= !mDispatchedOverscanInsets.equals(mOverscanInsets);
            insetsChanged |= !mDispatchedContentInsets.equals(mContentInsets);
            insetsChanged |= !mDispatchedStableInsets.equals(mStableInsets);
            insetsChanged |= !mDispatchedOutsets.equals(mOutsets);
            mSurfaceHolder.setSurfaceFrameSize(w, h);
            mSurfaceHolder.mSurfaceLock.unlock();
            if (!mSurfaceHolder.mSurface.isValid()) {
                reportSurfaceDestroyed();
                if (DEBUG)
                    Log.v(TAG, ""Layout: Surface destroyed"");
                return;
            }
            boolean didSurface = false;
            try {
                mSurfaceHolder.ungetCallbacks();
                if (surfaceCreating) {
                    mIsCreating = true;
                    didSurface = true;
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceCreated("" + mSurfaceHolder + ""): "" + this);
                    onSurfaceCreated(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceCreated(mSurfaceHolder);
                        }
                    }
                }
                redrawNeeded |= creating || (relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0;
                if (forceReport || creating || surfaceCreating || formatChanged || sizeChanged) {
                    if (DEBUG) {
                        RuntimeException e = new RuntimeException();
                        e.fillInStackTrace();
                        Log.w(TAG, ""forceReport="" + forceReport + "" creating="" + creating + "" formatChanged="" + formatChanged + "" sizeChanged="" + sizeChanged, e);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceChanged("" + mSurfaceHolder + "", "" + mFormat + "", "" + mCurWidth + "", "" + mCurHeight + ""): "" + this);
                    didSurface = true;
                    onSurfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                        }
                    }
                }
                if (insetsChanged) {
                    mDispatchedOverscanInsets.set(mOverscanInsets);
                    mDispatchedOverscanInsets.left += mOutsets.left;
                    mDispatchedOverscanInsets.top += mOutsets.top;
                    mDispatchedOverscanInsets.right += mOutsets.right;
                    mDispatchedOverscanInsets.bottom += mOutsets.bottom;
                    mDispatchedContentInsets.set(mContentInsets);
                    mDispatchedStableInsets.set(mStableInsets);
                    mDispatchedOutsets.set(mOutsets);
                    mFinalSystemInsets.set(mDispatchedOverscanInsets);
                    mFinalStableInsets.set(mDispatchedStableInsets);
                    WindowInsets insets = new WindowInsets(mFinalSystemInsets, null, mFinalStableInsets, getResources().getConfiguration().isScreenRound(), false);
                    if (DEBUG) {
                        Log.v(TAG, ""dispatching insets="" + insets);
                    }
                    onApplyWindowInsets(insets);
                }
                if (redrawNeeded) {
                    onSurfaceRedrawNeeded(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            if (c instanceof SurfaceHolder.Callback2) {
                                ((SurfaceHolder.Callback2) c).surfaceRedrawNeeded(mSurfaceHolder);
                            }
                        }
                    }
                }
                if (didSurface && !mReportedVisible) {
                    // don't want wallpapers running when not visible.
                    if (mIsCreating) {
                        // the state to get them to notice.
                        if (DEBUG)
                            Log.v(TAG, ""onVisibilityChanged(true) at surface: "" + this);
                        onVisibilityChanged(true);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onVisibilityChanged(false) at surface: "" + this);
                    onVisibilityChanged(false);
                }
            } finally {
                mIsCreating = false;
                mSurfaceCreated = true;
                if (redrawNeeded) {
                    mSession.finishDrawing(mWindow);
                }
                mIWallpaperEngine.reportShown();
            }
        } catch (RemoteException ex) {
        }
        if (DEBUG)
            Log.v(TAG, ""Layout: x="" + mLayout.x + "" y="" + mLayout.y + "" w="" + mLayout.width + "" h="" + mLayout.height);
    }
}","{
    if (mDestroyed) {
        Log.w(TAG, ""Ignoring updateSurface: destroyed"");
    }
    boolean fixedSize = false;
    int myWidth = mSurfaceHolder.getRequestedWidth();
    if (myWidth <= 0)
        myWidth = ViewGroup.LayoutParams.MATCH_PARENT;
    else
        fixedSize = true;
    int myHeight = mSurfaceHolder.getRequestedHeight();
    if (myHeight <= 0)
        myHeight = ViewGroup.LayoutParams.MATCH_PARENT;
    else
        fixedSize = true;
    final boolean creating = !mCreated;
    final boolean surfaceCreating = !mSurfaceCreated;
    final boolean formatChanged = mFormat != mSurfaceHolder.getRequestedFormat();
    boolean sizeChanged = mWidth != myWidth || mHeight != myHeight;
    boolean insetsChanged = !mCreated;
    final boolean typeChanged = mType != mSurfaceHolder.getRequestedType();
    final boolean flagsChanged = mCurWindowFlags != mWindowFlags || mCurWindowPrivateFlags != mWindowPrivateFlags;
    if (forceRelayout || creating || surfaceCreating || formatChanged || sizeChanged || typeChanged || flagsChanged || redrawNeeded || !mIWallpaperEngine.mShownReported) {
        if (DEBUG)
            Log.v(TAG, ""Changes: creating="" + creating + "" format="" + formatChanged + "" size="" + sizeChanged);
        try {
            mWidth = myWidth;
            mHeight = myHeight;
            mFormat = mSurfaceHolder.getRequestedFormat();
            mType = mSurfaceHolder.getRequestedType();
            mLayout.x = 0;
            mLayout.y = 0;
            mLayout.width = myWidth;
            mLayout.height = myHeight;
            mLayout.format = mFormat;
            mCurWindowFlags = mWindowFlags;
            mLayout.flags = mWindowFlags | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
            mCurWindowPrivateFlags = mWindowPrivateFlags;
            mLayout.privateFlags = mWindowPrivateFlags;
            mLayout.memoryType = mType;
            mLayout.token = mWindowToken;
            if (!mCreated) {
                // Retrieve watch round info
                TypedArray windowStyle = obtainStyledAttributes(com.android.internal.R.styleable.Window);
                windowStyle.recycle();
                // Add window
                mLayout.type = mIWallpaperEngine.mWindowType;
                mLayout.gravity = Gravity.START | Gravity.TOP;
                mLayout.setTitle(WallpaperService.this.getClass().getName());
                mLayout.windowAnimations = com.android.internal.R.style.Animation_Wallpaper;
                mInputChannel = new InputChannel();
                if (mSession.addToDisplay(mWindow, mWindow.mSeq, mLayout, View.VISIBLE, Display.DEFAULT_DISPLAY, mContentInsets, mStableInsets, mOutsets, mInputChannel) < 0) {
                    Log.w(TAG, ""Failed to add window while updating wallpaper surface."");
                    return;
                }
                mCreated = true;
                mInputEventReceiver = new WallpaperInputEventReceiver(mInputChannel, Looper.myLooper());
            }
            mSurfaceHolder.mSurfaceLock.lock();
            mDrawingAllowed = true;
            if (!fixedSize) {
                mLayout.surfaceInsets.set(mIWallpaperEngine.mDisplayPadding);
                mLayout.surfaceInsets.left += mOutsets.left;
                mLayout.surfaceInsets.top += mOutsets.top;
                mLayout.surfaceInsets.right += mOutsets.right;
                mLayout.surfaceInsets.bottom += mOutsets.bottom;
            } else {
                mLayout.surfaceInsets.set(0, 0, 0, 0);
            }
            final int relayoutResult = mSession.relayout(mWindow, mWindow.mSeq, mLayout, mWidth, mHeight, View.VISIBLE, 0, mWinFrame, mOverscanInsets, mContentInsets, mVisibleInsets, mStableInsets, mOutsets, mBackdropFrame, mConfiguration, mSurfaceHolder.mSurface);
            if (DEBUG)
                Log.v(TAG, ""New surface: "" + mSurfaceHolder.mSurface + "", frame="" + mWinFrame);
            int w = mWinFrame.width();
            int h = mWinFrame.height();
            if (!fixedSize) {
                final Rect padding = mIWallpaperEngine.mDisplayPadding;
                w += padding.left + padding.right + mOutsets.left + mOutsets.right;
                h += padding.top + padding.bottom + mOutsets.top + mOutsets.bottom;
                mOverscanInsets.left += padding.left;
                mOverscanInsets.top += padding.top;
                mOverscanInsets.right += padding.right;
                mOverscanInsets.bottom += padding.bottom;
                mContentInsets.left += padding.left;
                mContentInsets.top += padding.top;
                mContentInsets.right += padding.right;
                mContentInsets.bottom += padding.bottom;
                mStableInsets.left += padding.left;
                mStableInsets.top += padding.top;
                mStableInsets.right += padding.right;
                mStableInsets.bottom += padding.bottom;
            }
            if (mCurWidth != w) {
                sizeChanged = true;
                mCurWidth = w;
            }
            if (mCurHeight != h) {
                sizeChanged = true;
                mCurHeight = h;
            }
            if (DEBUG) {
                Log.v(TAG, ""Wallpaper size has changed: ("" + mCurWidth + "", "" + mCurHeight);
            }
            insetsChanged |= !mDispatchedOverscanInsets.equals(mOverscanInsets);
            insetsChanged |= !mDispatchedContentInsets.equals(mContentInsets);
            insetsChanged |= !mDispatchedStableInsets.equals(mStableInsets);
            insetsChanged |= !mDispatchedOutsets.equals(mOutsets);
            mSurfaceHolder.setSurfaceFrameSize(w, h);
            mSurfaceHolder.mSurfaceLock.unlock();
            if (!mSurfaceHolder.mSurface.isValid()) {
                reportSurfaceDestroyed();
                if (DEBUG)
                    Log.v(TAG, ""Layout: Surface destroyed"");
                return;
            }
            boolean didSurface = false;
            try {
                mSurfaceHolder.ungetCallbacks();
                if (surfaceCreating) {
                    mIsCreating = true;
                    didSurface = true;
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceCreated("" + mSurfaceHolder + ""): "" + this);
                    onSurfaceCreated(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceCreated(mSurfaceHolder);
                        }
                    }
                }
                redrawNeeded |= creating || (relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0;
                if (forceReport || creating || surfaceCreating || formatChanged || sizeChanged) {
                    if (DEBUG) {
                        RuntimeException e = new RuntimeException();
                        e.fillInStackTrace();
                        Log.w(TAG, ""forceReport="" + forceReport + "" creating="" + creating + "" formatChanged="" + formatChanged + "" sizeChanged="" + sizeChanged, e);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceChanged("" + mSurfaceHolder + "", "" + mFormat + "", "" + mCurWidth + "", "" + mCurHeight + ""): "" + this);
                    didSurface = true;
                    onSurfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                        }
                    }
                }
                if (insetsChanged) {
                    mDispatchedOverscanInsets.set(mOverscanInsets);
                    mDispatchedOverscanInsets.left += mOutsets.left;
                    mDispatchedOverscanInsets.top += mOutsets.top;
                    mDispatchedOverscanInsets.right += mOutsets.right;
                    mDispatchedOverscanInsets.bottom += mOutsets.bottom;
                    mDispatchedContentInsets.set(mContentInsets);
                    mDispatchedStableInsets.set(mStableInsets);
                    mDispatchedOutsets.set(mOutsets);
                    mFinalSystemInsets.set(mDispatchedOverscanInsets);
                    mFinalStableInsets.set(mDispatchedStableInsets);
                    WindowInsets insets = new WindowInsets(mFinalSystemInsets, null, mFinalStableInsets, getResources().getConfiguration().isScreenRound(), false);
                    if (DEBUG) {
                        Log.v(TAG, ""dispatching insets="" + insets);
                    }
                    onApplyWindowInsets(insets);
                }
                if (redrawNeeded) {
                    onSurfaceRedrawNeeded(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            if (c instanceof SurfaceHolder.Callback2) {
                                ((SurfaceHolder.Callback2) c).surfaceRedrawNeeded(mSurfaceHolder);
                            }
                        }
                    }
                }
                if (didSurface && !mReportedVisible) {
                    // don't want wallpapers running when not visible.
                    if (mIsCreating) {
                        // the state to get them to notice.
                        if (DEBUG)
                            Log.v(TAG, ""onVisibilityChanged(true) at surface: "" + this);
                        onVisibilityChanged(true);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onVisibilityChanged(false) at surface: "" + this);
                    onVisibilityChanged(false);
                }
            } finally {
                mIsCreating = false;
                mSurfaceCreated = true;
                if (redrawNeeded) {
                    mSession.finishDrawing(mWindow);
                }
                mIWallpaperEngine.reportShown();
            }
        } catch (RemoteException ex) {
        }
        if (DEBUG)
            Log.v(TAG, ""Layout: x="" + mLayout.x + "" y="" + mLayout.y + "" w="" + mLayout.width + "" h="" + mLayout.height);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
55,<android.bluetooth.BluetoothA2dp: List<BluetoothDevice> getDevicesMatchingConnectionStates(int[])>,24,25,<android.bluetooth.BluetoothA2dp: List<BluetoothDevice> getDevicesMatchingConnectionStates(int[])>,<android.bluetooth.BluetoothA2dp: List<BluetoothDevice> getDevicesMatchingConnectionStates(int[])>,0,"{
    if (VDBG)
        log(""getDevicesMatchingStates()"");
    if (mService != null && isEnabled()) {
        try {
            return mService.getDevicesMatchingConnectionStates(states);
        } catch (RemoteException e) {
            Log.e(TAG, ""Stack:"" + Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (mService == null)
        Log.w(TAG, ""Proxy not attached to service"");
    return new ArrayList<BluetoothDevice>();
}","{
    if (VDBG)
        log(""getDevicesMatchingStates()"");
    try {
        mServiceLock.readLock().lock();
        if (mService != null && isEnabled()) {
            return mService.getDevicesMatchingConnectionStates(states);
        }
        if (mService == null)
            Log.w(TAG, ""Proxy not attached to service"");
        return new ArrayList<BluetoothDevice>();
    } catch (RemoteException e) {
        Log.e(TAG, ""Stack:"" + Log.getStackTraceString(new Throwable()));
        return new ArrayList<BluetoothDevice>();
    } finally {
        mServiceLock.readLock().unlock();
    }
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The late version adds a lock mechanism around the code with mServiceLock.readLock().lock() and mServiceLock.readLock().unlock(), which is a change in the other statements (type 4). Further, the try-catch block now surrounds additional logic, which constitutes a control dependency change (type 3). However, the essence of what the method does internally in terms of logic remains the same.",There is no Compatibility Issue because the method's behavior in terms of the values it returns and the exceptions it throws has not changed substantially. The addition of a lock mechanism and the repositioning of a try-catch block do not impact the method's interface or observable behavior from the caller's perspective.
56,<android.widget.RelativeLayout: LayoutParams generateLayoutParams(LayoutParams)>,24,25,<android.widget.RelativeLayout: LayoutParams generateLayoutParams(LayoutParams)>,<android.widget.RelativeLayout: LayoutParams generateLayoutParams(LayoutParams)>,0,"{
    if (lp instanceof LayoutParams) {
        return new LayoutParams((LayoutParams) lp);
    } else if (lp instanceof MarginLayoutParams) {
        return new LayoutParams((MarginLayoutParams) lp);
    } else {
        return new LayoutParams(lp);
    }
}","{
    if (sPreserveMarginParamsInLayoutParamConversion) {
        if (lp instanceof LayoutParams) {
            return new LayoutParams((LayoutParams) lp);
        } else if (lp instanceof MarginLayoutParams) {
            return new LayoutParams((MarginLayoutParams) lp);
        }
    }
    return new LayoutParams(lp);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,"The control statement (if condition) was added for a feature toggle, sPreserveMarginParamsInLayoutParamConversion, that can impact the flow of which constructor for LayoutParams is invoked. So the code change type is 3.","Despite the addition of a feature toggle and new control flow, the behavior of the method is consistent with the earlier version when the toggle is true. The method still returns a new instance of LayoutParams constructed from the input 'lp'. In the case when sPreserveMarginParamsInLayoutParamConversion is false, it always returns a new LayoutParams(lp), which is also consistent with the original else branch. Thus, there is no CI because the actual return values will not differ based on the conditions given, and the method's execution paths still result in the same types of LayoutParams objects being returned."
57,<android.service.notification.ZenModeConfig.ZenRule: boolean equals(Object)>,24,25,<android.service.notification.ZenModeConfig.ZenRule: boolean equals(Object)>,<android.service.notification.ZenModeConfig.ZenRule: boolean equals(Object)>,0,"{
    if (!(o instanceof ZenRule))
        return false;
    if (o == this)
        return true;
    final ZenRule other = (ZenRule) o;
    return other.enabled == enabled && other.snoozing == snoozing && Objects.equals(other.name, name) && other.zenMode == zenMode && Objects.equals(other.conditionId, conditionId) && Objects.equals(other.condition, condition) && Objects.equals(other.component, component) && Objects.equals(other.id, id) && other.creationTime == creationTime;
}","{
    if (!(o instanceof ZenRule))
        return false;
    if (o == this)
        return true;
    final ZenRule other = (ZenRule) o;
    return other.enabled == enabled && other.snoozing == snoozing && Objects.equals(other.name, name) && other.zenMode == zenMode && Objects.equals(other.conditionId, conditionId) && Objects.equals(other.condition, condition) && Objects.equals(other.component, component) && Objects.equals(other.id, id) && other.creationTime == creationTime && Objects.equals(other.enabler, enabler);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"An additional check Objects.equals(other.enabler, enabler) is added at the end of the return statement. This change is classified as a return statement change (1), and since this is part of the boolean expression to determine equality, it's also classified under other statement changed (4).","The additional equality check for the 'enabler' field could cause the 'equals' method to return different results for comparisons that involve this field, therefore there is a potential compatibility issue due to a different return value, classified under CI type 1."
59,<android.view.SurfaceControl.PhysicalDisplayInfo: boolean equals(PhysicalDisplayInfo)>,24,25,<android.view.SurfaceControl.PhysicalDisplayInfo: boolean equals(PhysicalDisplayInfo)>,<android.view.SurfaceControl.PhysicalDisplayInfo: boolean equals(PhysicalDisplayInfo)>,0,"{
    return other != null && width == other.width && height == other.height && refreshRate == other.refreshRate && density == other.density && xDpi == other.xDpi && yDpi == other.yDpi && secure == other.secure && appVsyncOffsetNanos == other.appVsyncOffsetNanos && presentationDeadlineNanos == other.presentationDeadlineNanos && colorTransform == other.colorTransform;
}","{
    return other != null && width == other.width && height == other.height && refreshRate == other.refreshRate && density == other.density && xDpi == other.xDpi && yDpi == other.yDpi && secure == other.secure && appVsyncOffsetNanos == other.appVsyncOffsetNanos && presentationDeadlineNanos == other.presentationDeadlineNanos;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,1,1,"The conditions checked within the return statement have changed; the check for `colorTransform` has been removed. This signifies that a different set of fields is considered when determining equality between `PhysicalDisplayInfo` objects, and thus the equality logic has changed, constituting a change in the return statement.","Since the logic to determine equality has been altered by removing the `colorTransform` condition, this could potentially lead to the API returning different boolean values for the same input parameters when comparing the early and late versions. Hence, the Compatibility Issue is of type 1, caused by the potential for the API to return different values."
60,<android.service.quicksettings.TileService: void showDialog(Dialog)>,24,25,<android.service.quicksettings.TileService: void showDialog(Dialog)>,<android.service.quicksettings.TileService: void showDialog(Dialog)>,0,"{
    dialog.getWindow().getAttributes().token = mToken;
    dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_QS_DIALOG);
    dialog.getWindow().getDecorView().addOnAttachStateChangeListener(new OnAttachStateChangeListener() {

        @Override
        public void onViewAttachedToWindow(View v) {
        }

        @Override
        public void onViewDetachedFromWindow(View v) {
            try {
                mService.onDialogHidden(getQsTile());
            } catch (RemoteException e) {
            }
        }
    });
    dialog.show();
    try {
        mService.onShowDialog(mTile);
    } catch (RemoteException e) {
    }
}","{
    dialog.getWindow().getAttributes().token = mToken;
    dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_QS_DIALOG);
    dialog.getWindow().getDecorView().addOnAttachStateChangeListener(new OnAttachStateChangeListener() {

        @Override
        public void onViewAttachedToWindow(View v) {
        }

        @Override
        public void onViewDetachedFromWindow(View v) {
            try {
                mService.onDialogHidden(mTileToken);
            } catch (RemoteException e) {
            }
        }
    });
    dialog.show();
    try {
        mService.onShowDialog(mTileToken);
    } catch (RemoteException e) {
    }
}",1,"/**
 * Used to show a dialog.
 *
 * This will collapse the Quick Settings panel and show the dialog.
 *
 * @param dialog Dialog to show.
 *
 * @see #isLocked()
 */
","/**
 * Used to show a dialog.
 *
 * This will collapse the Quick Settings panel and show the dialog.
 *
 * @param dialog Dialog to show.
 *
 * @see #isLocked()
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The code change involves changing the variable from `getQsTile()` to `mTileToken` in the `mService.onDialogHidden` method call, and from `mTile` to `mTileToken` in the `mService.onShowDialog` method call, indicating a change in the method invocation arguments (which is part of Other statement changed). There are no changes in return statements, exception handling statements, or control dependencies. However, since the implementation relies on the variable that has been changed without changing the API method signatures that are being called (`mService.onDialogHidden` and `mService.onShowDialog`), this is also a change in a Dependent API.","There is no Compatibility Issue since the API behavior hasn't fundamentally changed; it still performs the same operations with the same API calls and exception handling. The change in variable names does not affect how the API functions from the caller's perspective, assuming that `getQsTile()` and `mTileToken` refer to the same or equivalent entities in this context. If `mTileToken` represents the same tile that was previously returned by `getQsTile()`, then the API’s behavior would remain unchanged, and there would be no Compatibility Issue."
61,<android.hardware.camera2.impl.CameraCaptureSessionImpl: void abortCaptures()>,24,25,<android.hardware.camera2.impl.CameraCaptureSessionImpl: void abortCaptures()>,<android.hardware.camera2.impl.CameraCaptureSessionImpl: void abortCaptures()>,0,"{
    checkNotClosed();
    if (DEBUG) {
        Log.v(TAG, mIdString + ""abortCaptures"");
    }
    if (mAborting) {
        Log.w(TAG, mIdString + ""abortCaptures - Session is already aborting; doing nothing"");
        return;
    }
    mAborting = true;
    mAbortDrainer.taskStarted();
    mDeviceImpl.flush();
// The next BUSY -> IDLE set of transitions will mark the end of the abort.
}","{
    synchronized (this) {
        checkNotClosed();
        if (DEBUG) {
            Log.v(TAG, mIdString + ""abortCaptures"");
        }
        if (mAborting) {
            Log.w(TAG, mIdString + ""abortCaptures - Session is already aborting; doing nothing"");
            return;
        }
        mAborting = true;
        mAbortDrainer.taskStarted();
    }
    synchronized (mDeviceImpl.mInterfaceLock) {
        synchronized (this) {
            mDeviceImpl.flush();
        // The next BUSY -> IDLE set of transitions will mark the end of the abort.
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3, 4",0,"The late version of the code has added synchronized blocks around the existing code and a nested synchronized block on a different lock, mDeviceImpl.mInterfaceLock. The changes involve both the control dependency (3) due to the addition of the synchronized blocks and the other statements (4) because of the new nested lock structure.","While the changes involve the addition of synchronized blocks intended for thread safety and preventing concurrent access issues, they do not affect the outward behavior of the method in terms of what it returns or the exceptions it may throw. The method’s functionality, which manages the state of mAborting and calls mDeviceImpl.flush(), remains the same. Thus, there is no Compatibility Issue as the behavior from an external perspective should remain consistent with what it would have been before the change."
63,<android.view.TextureView: void setSurfaceTexture(SurfaceTexture)>,24,25,<android.view.TextureView: void setSurfaceTexture(SurfaceTexture)>,<android.view.TextureView: void setSurfaceTexture(SurfaceTexture)>,0,"{
    if (surfaceTexture == null) {
        throw new NullPointerException(""surfaceTexture must not be null"");
    }
    if (surfaceTexture == mSurface) {
        throw new IllegalArgumentException(""Trying to setSurfaceTexture to "" + ""the same SurfaceTexture that's already set."");
    }
    if (surfaceTexture.isReleased()) {
        throw new IllegalArgumentException(""Cannot setSurfaceTexture to a "" + ""released SurfaceTexture"");
    }
    if (mSurface != null) {
        mSurface.release();
    }
    mSurface = surfaceTexture;
    /*
         * If the view is visible and we already made a layer, update the
         * listener in the new surface to use the existing listener in the view.
         * Otherwise this will be called when the view becomes visible or the
         * layer is created
         */
    if (((mViewFlags & VISIBILITY_MASK) == VISIBLE) && mLayer != null) {
        mSurface.setOnFrameAvailableListener(mUpdateListener, mAttachInfo.mHandler);
    }
    mUpdateSurface = true;
    invalidateParentIfNeeded();
}","{
    if (surfaceTexture == null) {
        throw new NullPointerException(""surfaceTexture must not be null"");
    }
    if (surfaceTexture == mSurface) {
        throw new IllegalArgumentException(""Trying to setSurfaceTexture to "" + ""the same SurfaceTexture that's already set."");
    }
    if (surfaceTexture.isReleased()) {
        throw new IllegalArgumentException(""Cannot setSurfaceTexture to a "" + ""released SurfaceTexture"");
    }
    if (mSurface != null) {
        nDestroyNativeWindow();
        mSurface.release();
    }
    mSurface = surfaceTexture;
    nCreateNativeWindow(mSurface);
    /*
         * If the view is visible and we already made a layer, update the
         * listener in the new surface to use the existing listener in the view.
         * Otherwise this will be called when the view becomes visible or the
         * layer is created
         */
    if (((mViewFlags & VISIBILITY_MASK) == VISIBLE) && mLayer != null) {
        mSurface.setOnFrameAvailableListener(mUpdateListener, mAttachInfo.mHandler);
    }
    mUpdateSurface = true;
    invalidateParentIfNeeded();
}",1,"/**
 * Set the {@link SurfaceTexture} for this view to use. If a {@link
 * SurfaceTexture} is already being used by this view, it is immediately
 * released and not be usable any more.  The {@link
 * SurfaceTextureListener#onSurfaceTextureDestroyed} callback is <b>not</b>
 * called for the previous {@link SurfaceTexture}.  Similarly, the {@link
 * SurfaceTextureListener#onSurfaceTextureAvailable} callback is <b>not</b>
 * called for the {@link SurfaceTexture} passed to setSurfaceTexture.
 *
 * The {@link SurfaceTexture} object must be detached from all OpenGL ES
 * contexts prior to calling this method.
 *
 * @param surfaceTexture The {@link SurfaceTexture} that the view should use.
 * @see SurfaceTexture#detachFromGLContext()
 */
","/**
 * Set the {@link SurfaceTexture} for this view to use. If a {@link
 * SurfaceTexture} is already being used by this view, it is immediately
 * released and not be usable any more.  The {@link
 * SurfaceTextureListener#onSurfaceTextureDestroyed} callback is <b>not</b>
 * called for the previous {@link SurfaceTexture}.  Similarly, the {@link
 * SurfaceTextureListener#onSurfaceTextureAvailable} callback is <b>not</b>
 * called for the {@link SurfaceTexture} passed to setSurfaceTexture.
 *
 * The {@link SurfaceTexture} object must be detached from all OpenGL ES
 * contexts prior to calling this method.
 *
 * @param surfaceTexture The {@link SurfaceTexture} that the view should use.
 * @see SurfaceTexture#detachFromGLContext()
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The late version introduces two new method calls: nDestroyNativeWindow() before releasing the existing surface, and nCreateNativeWindow(mSurface) after assigning the new surface texture to mSurface. These changes represent a type 4 change, ""Other statement changed,"" as they are neither control dependency changes nor do they affect the return value or exception handling of the method.","There are no new return statements, exception handling statements, or control dependency changes. The two new native method calls (assuming they do not throw exceptions that would bubble up to the caller) would not introduce a compatibility issue by themselves since they are related to internal implementation details and would not be observable by clients of the API in terms of differing return values or exceptions. Therefore, there is no compatibility issue (0)."
66,<android.service.notification.ZenModeConfig.ZenRule: int hashCode()>,24,25,<android.service.notification.ZenModeConfig.ZenRule: int hashCode()>,<android.service.notification.ZenModeConfig.ZenRule: int hashCode()>,0,"{
    return Objects.hash(enabled, snoozing, name, zenMode, conditionId, condition, component, id, creationTime);
}","{
    return Objects.hash(enabled, snoozing, name, zenMode, conditionId, condition, component, id, creationTime, enabler);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The late version implementation includes the additional variable 'enabler' in the Objects.hash() method compared to the early version, therefore an element has been added to the method call, leading to a change type 1. This is also an ""Other statement changed"" because an additional parameter is passed to a method call, which is change type 4.","Including an additional object ('enabler') in the hash calculation will result in a different hash code being returned if 'enabler' differs, which is a potential different return value. Therefore, the change can cause a Compatibility Issue due to potential different return values, and the CI type is 1."
67,"<android.app.ActivityOptions: ActivityOptions makeSceneTransitionAnimation(Activity,Pair<View, String>)>",24,25,"<android.app.ActivityOptions: ActivityOptions makeSceneTransitionAnimation(Activity,Pair<View, String>)>","<android.app.ActivityOptions: ActivityOptions makeSceneTransitionAnimation(Activity,Pair<View, String>)>",0,"{
    ActivityOptions opts = new ActivityOptions();
    if (!activity.getWindow().hasFeature(Window.FEATURE_ACTIVITY_TRANSITIONS)) {
        opts.mAnimationType = ANIM_DEFAULT;
        return opts;
    }
    opts.mAnimationType = ANIM_SCENE_TRANSITION;
    ArrayList<String> names = new ArrayList<String>();
    ArrayList<View> views = new ArrayList<View>();
    if (sharedElements != null) {
        for (int i = 0; i < sharedElements.length; i++) {
            Pair<View, String> sharedElement = sharedElements[i];
            String sharedElementName = sharedElement.second;
            if (sharedElementName == null) {
                throw new IllegalArgumentException(""Shared element name must not be null"");
            }
            names.add(sharedElementName);
            View view = sharedElement.first;
            if (view == null) {
                throw new IllegalArgumentException(""Shared element must not be null"");
            }
            views.add(sharedElement.first);
        }
    }
    ExitTransitionCoordinator exit = new ExitTransitionCoordinator(activity, names, names, views, false);
    opts.mTransitionReceiver = exit;
    opts.mSharedElementNames = names;
    opts.mIsReturning = false;
    opts.mExitCoordinatorIndex = activity.mActivityTransitionState.addExitTransitionCoordinator(exit);
    return opts;
}","{
    ActivityOptions opts = new ActivityOptions();
    makeSceneTransitionAnimation(activity, activity.getWindow(), opts, activity.mExitTransitionListener, sharedElements);
    return opts;
}",1,"/**
 * Create an ActivityOptions to transition between Activities using cross-Activity scene
 * animations. This method carries the position of multiple shared elements to the started
 * Activity. The position of the first element in sharedElements
 * will be used as the epicenter for the exit Transition. The position of the associated
 * shared element in the launched Activity will be the epicenter of its entering Transition.
 *
 * <p>This requires {@link android.view.Window#FEATURE_ACTIVITY_TRANSITIONS} to be
 * enabled on the calling Activity to cause an exit transition. The same must be in
 * the called Activity to get an entering transition.</p>
 * @param activity The Activity whose window contains the shared elements.
 * @param sharedElements The names of the shared elements to transfer to the called
 * Activity and their associated Views. The Views must each have
 * a unique shared element name.
 * @return Returns a new ActivityOptions object that you can use to
 * supply these options as the options Bundle when starting an activity.
 * @see android.transition.Transition#setEpicenterCallback(
 * android.transition.Transition.EpicenterCallback)
 */
","/**
 * Create an ActivityOptions to transition between Activities using cross-Activity scene
 * animations. This method carries the position of multiple shared elements to the started
 * Activity. The position of the first element in sharedElements
 * will be used as the epicenter for the exit Transition. The position of the associated
 * shared element in the launched Activity will be the epicenter of its entering Transition.
 *
 * <p>This requires {@link android.view.Window#FEATURE_ACTIVITY_TRANSITIONS} to be
 * enabled on the calling Activity to cause an exit transition. The same must be in
 * the called Activity to get an entering transition.</p>
 * @param activity The Activity whose window contains the shared elements.
 * @param sharedElements The names of the shared elements to transfer to the called
 * Activity and their associated Views. The Views must each have
 * a unique shared element name.
 * @return Returns a new ActivityOptions object that you can use to
 * supply these options as the options Bundle when starting an activity.
 * @see android.transition.Transition#setEpicenterCallback(
 * android.transition.Transition.EpicenterCallback)
 */
",-1,[@SafeVarargs],[@SafeVarargs],-1,-1,-1,-1,-1,-1,"4,5",0,"The early version directly manipulates the ActivityOptions instance within the method, while the late version uses another method, makeSceneTransitionAnimation(activity, activity.getWindow(), opts, activity.mExitTransitionListener, sharedElements), to perform the operation. This constitutes a dependent API change. Additionally, there's a change in the method structure (not introducing new control flow or altering return values directly in the public API). ",
68,<android.nfc.NfcAdapter: boolean invokeBeam(Activity)>,24,25,<android.nfc.NfcAdapter: boolean invokeBeam(Activity)>,<android.nfc.NfcAdapter: boolean invokeBeam(Activity)>,0,"{
    if (activity == null) {
        throw new NullPointerException(""activity may not be null."");
    }
    enforceResumed(activity);
    try {
        sService.invokeBeam();
        return true;
    } catch (RemoteException e) {
        Log.e(TAG, ""invokeBeam: NFC process has died."");
        attemptDeadServiceRecovery(e);
        return false;
    }
}","{
    synchronized (NfcAdapter.class) {
        if (!sHasNfcFeature) {
            throw new UnsupportedOperationException();
        }
    }
    if (activity == null) {
        throw new NullPointerException(""activity may not be null."");
    }
    enforceResumed(activity);
    try {
        sService.invokeBeam();
        return true;
    } catch (RemoteException e) {
        Log.e(TAG, ""invokeBeam: NFC process has died."");
        attemptDeadServiceRecovery(e);
        return false;
    }
}",1,"/**
 * Manually invoke Android Beam to share data.
 *
 * <p>The Android Beam animation is normally only shown when two NFC-capable
 * devices come into range.
 * By calling this method, an Activity can invoke the Beam animation directly
 * even if no other NFC device is in range yet. The Beam animation will then
 * prompt the user to tap another NFC-capable device to complete the data
 * transfer.
 *
 * <p>The main advantage of using this method is that it avoids the need for the
 * user to tap the screen to complete the transfer, as this method already
 * establishes the direction of the transfer and the consent of the user to
 * share data. Callers are responsible for making sure that the user has
 * consented to sharing data on NFC tap.
 *
 * <p>Note that to use this method, the passed in Activity must have already
 * set data to share over Beam by using method calls such as
 * {@link #setNdefPushMessageCallback} or
 * {@link #setBeamPushUrisCallback}.
 *
 * @param activity the current foreground Activity that has registered data to share
 * @return whether the Beam animation was successfully invoked
 */
","/**
 * Manually invoke Android Beam to share data.
 *
 * <p>The Android Beam animation is normally only shown when two NFC-capable
 * devices come into range.
 * By calling this method, an Activity can invoke the Beam animation directly
 * even if no other NFC device is in range yet. The Beam animation will then
 * prompt the user to tap another NFC-capable device to complete the data
 * transfer.
 *
 * <p>The main advantage of using this method is that it avoids the need for the
 * user to tap the screen to complete the transfer, as this method already
 * establishes the direction of the transfer and the consent of the user to
 * share data. Callers are responsible for making sure that the user has
 * consented to sharing data on NFC tap.
 *
 * <p>Note that to use this method, the passed in Activity must have already
 * set data to share over Beam by using method calls such as
 * {@link #setNdefPushMessageCallback} or
 * {@link #setBeamPushUrisCallback}.
 *
 * @param activity the current foreground Activity that has registered data to share
 * @return whether the Beam animation was successfully invoked
 * @throws UnsupportedOperationException if FEATURE_NFC is unavailable.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The code change involves a newly added synchronized block that checks if the device has NFC feature, throwing an UnsupportedOperationException if not, along with the `sHasNfcFeature` static variable check within the synchronized block. This change in control dependency is represented as change type 3. Change type 4 also applies because a new conditional check and throw statement has been introduced to the method.","While the newly introduced check for NFC feature and throwing of an UnsupportedOperationException does change the method's behavior, it does not create an incompatibility concerning the return variable/type or exception handling as compared to the early version. The invocation of the method `enforceResumed(activity)` and `sService.invokeBeam()` remain the same, and they handle the activity non-null requirement and remote invocation as before. Thus, we do not have a return variable/type or exception handling CI issue, and the pred_CI is 0."
70,"<android.app.LoadedApk.ServiceDispatcher: void death(ComponentName,IBinder)>",24,25,"<android.app.LoadedApk.ServiceDispatcher: void death(ComponentName,IBinder)>","<android.app.LoadedApk.ServiceDispatcher: void death(ComponentName,IBinder)>",0,"{
    ServiceDispatcher.ConnectionInfo old;
    synchronized (this) {
        old = mActiveConnections.remove(name);
        if (old == null || old.binder != service) {
            // reported...  just ignore it.
            return;
        }
        old.binder.unlinkToDeath(old.deathMonitor, 0);
    }
    if (mActivityThread != null) {
        mActivityThread.post(new RunConnection(name, service, 1));
    } else {
        doDeath(name, service);
    }
}","{
    if (mActivityThread != null) {
        mActivityThread.post(new RunConnection(name, service, 1));
    } else {
        doDeath(name, service);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The early implementation includes a block of code to remove a service connection and perform some checks and actions which is missing in the late implementation. The removal of this block and its contained statements including 'synchronized' and 'if' conditions signifies a code change type of 3 for control dependency changed, and 4 for other statement changed.","Since the deleted statements were responsible for preliminary checks and unregistration operations, their removal may change the internal state of the ServiceDispatcher but do not directly cause an API to return a different value or throw a different exception as viewed from the API's exterior behavior; thus, there is no Compatibility Issue with respect to return values or exception handling. The remaining code block which posts a Runnable or calls doDeath directly remains unchanged, making the visible behavior consistent regardless of the internal handling. Therefore, the CI type is 0."
71,"<android.nfc.NfcAdapter: void setBeamPushUrisCallback(CreateBeamUrisCallback,Activity)>",24,25,"<android.nfc.NfcAdapter: void setBeamPushUrisCallback(CreateBeamUrisCallback,Activity)>","<android.nfc.NfcAdapter: void setBeamPushUrisCallback(CreateBeamUrisCallback,Activity)>",0,"{
    if (activity == null) {
        throw new NullPointerException(""activity cannot be null"");
    }
    mNfcActivityManager.setNdefPushContentUriCallback(activity, callback);
}","{
    synchronized (NfcAdapter.class) {
        if (!sHasNfcFeature) {
            throw new UnsupportedOperationException();
        }
    }
    if (activity == null) {
        throw new NullPointerException(""activity cannot be null"");
    }
    mNfcActivityManager.setNdefPushContentUriCallback(activity, callback);
}",1,"/**
 * Set a callback that will dynamically generate one or more {@link Uri}s
 * to send using Android Beam (TM). Every Uri the callback provides
 * must have either scheme 'file' or scheme 'content'.
 *
 * <p>For the data provided through this callback, Android Beam tries to
 * switch to alternate transports such as Bluetooth to achieve a fast
 * transfer speed. Hence this method is very suitable
 * for transferring large files such as pictures or songs.
 *
 * <p>The receiving side will store the content of each Uri in
 * a file and present a notification to the user to open the file
 * with a {@link android.content.Intent} with action
 * {@link android.content.Intent#ACTION_VIEW}.
 * If multiple URIs are sent, the {@link android.content.Intent} will refer
 * to the first of the stored files.
 *
 * <p>This method may be called at any time before {@link Activity#onDestroy},
 * but the URI(s) are only made available for Android Beam when the
 * specified activity(s) are in resumed (foreground) state. The recommended
 * approach is to call this method during your Activity's
 * {@link Activity#onCreate} - see sample
 * code below. This method does not immediately perform any I/O or blocking work,
 * so is safe to call on your main thread.
 *
 * <p>{@link #setBeamPushUris} and {@link #setBeamPushUrisCallback}
 * have priority over both {@link #setNdefPushMessage} and
 * {@link #setNdefPushMessageCallback}.
 *
 * <p>If {@link #setBeamPushUris} is called with a null Uri array,
 * and/or {@link #setBeamPushUrisCallback} is called with a null callback,
 * then the Uri push will be completely disabled for the specified activity(s).
 *
 * <p>Code example:
 * <pre>
 * protected void onCreate(Bundle savedInstanceState) {
 * super.onCreate(savedInstanceState);
 * NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
 * if (nfcAdapter == null) return;  // NFC not available on this device
 * nfcAdapter.setBeamPushUrisCallback(callback, this);
 * }</pre>
 * And that is it. Only one call per activity is necessary. The Android
 * OS will automatically release its references to the Uri(s) and the
 * Activity object when it is destroyed if you follow this pattern.
 *
 * <p class=""note"">Do not pass in an Activity that has already been through
 * {@link Activity#onDestroy}. This is guaranteed if you call this API
 * during {@link Activity#onCreate}.
 *
 * <p class=""note"">If this device does not support alternate transports
 * such as Bluetooth or WiFI, calling this method does nothing.
 *
 * <p class=""note"">Requires the {@link android.Manifest.permission#NFC} permission.
 *
 * @param callback callback, or null to disable
 * @param activity activity for which the Uri(s) will be pushed
 */
","/**
 * Set a callback that will dynamically generate one or more {@link Uri}s
 * to send using Android Beam (TM). Every Uri the callback provides
 * must have either scheme 'file' or scheme 'content'.
 *
 * <p>For the data provided through this callback, Android Beam tries to
 * switch to alternate transports such as Bluetooth to achieve a fast
 * transfer speed. Hence this method is very suitable
 * for transferring large files such as pictures or songs.
 *
 * <p>The receiving side will store the content of each Uri in
 * a file and present a notification to the user to open the file
 * with a {@link android.content.Intent} with action
 * {@link android.content.Intent#ACTION_VIEW}.
 * If multiple URIs are sent, the {@link android.content.Intent} will refer
 * to the first of the stored files.
 *
 * <p>This method may be called at any time before {@link Activity#onDestroy},
 * but the URI(s) are only made available for Android Beam when the
 * specified activity(s) are in resumed (foreground) state. The recommended
 * approach is to call this method during your Activity's
 * {@link Activity#onCreate} - see sample
 * code below. This method does not immediately perform any I/O or blocking work,
 * so is safe to call on your main thread.
 *
 * <p>{@link #setBeamPushUris} and {@link #setBeamPushUrisCallback}
 * have priority over both {@link #setNdefPushMessage} and
 * {@link #setNdefPushMessageCallback}.
 *
 * <p>If {@link #setBeamPushUris} is called with a null Uri array,
 * and/or {@link #setBeamPushUrisCallback} is called with a null callback,
 * then the Uri push will be completely disabled for the specified activity(s).
 *
 * <p>Code example:
 * <pre>
 * protected void onCreate(Bundle savedInstanceState) {
 * super.onCreate(savedInstanceState);
 * NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
 * if (nfcAdapter == null) return;  // NFC not available on this device
 * nfcAdapter.setBeamPushUrisCallback(callback, this);
 * }</pre>
 * And that is it. Only one call per activity is necessary. The Android
 * OS will automatically release its references to the Uri(s) and the
 * Activity object when it is destroyed if you follow this pattern.
 *
 * <p class=""note"">Do not pass in an Activity that has already been through
 * {@link Activity#onDestroy}. This is guaranteed if you call this API
 * during {@link Activity#onCreate}.
 *
 * <p class=""note"">If this device does not support alternate transports
 * such as Bluetooth or WiFI, calling this method does nothing.
 *
 * <p class=""note"">Requires the {@link android.Manifest.permission#NFC} permission.
 *
 * @param callback callback, or null to disable
 * @param activity activity for which the Uri(s) will be pushed
 * @throws UnsupportedOperationException if FEATURE_NFC is unavailable.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"An additional exception handling statement has been introduced, which includes a synchronized block and a new throw statement. The code now checks for a feature before proceeding and throws UnsupportedOperationException if the feature is not present. There is also a control dependency change due to the addition of a synchronized block. Therefore, change type 2 and 3 have occurred.",The additional 'throw new UnsupportedOperationException()' could cause a different exception to be thrown than in previous versions if the sHasNfcFeature condition is not fulfilled. This leads to a potential Compatibility Issue of type 2 caused by different exception handlings.
72,<android.bluetooth.BluetoothA2dp: boolean isA2dpPlaying(BluetoothDevice)>,24,25,<android.bluetooth.BluetoothA2dp: boolean isA2dpPlaying(BluetoothDevice)>,<android.bluetooth.BluetoothA2dp: boolean isA2dpPlaying(BluetoothDevice)>,0,"{
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.isA2dpPlaying(device);
        } catch (RemoteException e) {
            Log.e(TAG, ""Stack:"" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (mService == null)
        Log.w(TAG, ""Proxy not attached to service"");
    return false;
}","{
    try {
        mServiceLock.readLock().lock();
        if (mService != null && isEnabled() && isValidDevice(device)) {
            return mService.isA2dpPlaying(device);
        }
        if (mService == null)
            Log.w(TAG, ""Proxy not attached to service"");
        return false;
    } catch (RemoteException e) {
        Log.e(TAG, ""Stack:"" + Log.getStackTraceString(new Throwable()));
        return false;
    } finally {
        mServiceLock.readLock().unlock();
    }
}",1,"/**
 * Check if A2DP profile is streaming music.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param device BluetoothDevice device
 */
","/**
 * Check if A2DP profile is streaming music.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param device BluetoothDevice device
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The late version wraps the existing code with a try-finally block for acquiring and releasing a read lock (mServiceLock.readLock().lock() and mServiceLock.readLock().unlock()), which is a new control dependency, meaning change type 3. The structure and flow of the code inside the try block have not changed, and neither have the return statements nor exception handling; therefore, the change also includes type 4 due to changes in lock management.","The changes do not affect the return value or exception handling that the API would produce as viewed by the caller. The wrapped code behaves the same way in terms of its checks and return values. The lock is an internal implementation detail that aims to manage concurrent access but does not change the API's external behavior, assuming it's used correctly and doesn't introduce deadlocks or similar concurrency issues. Thus, there is no Compatibility Issue."
74,<android.view.View: void onDrawScrollBars(Canvas)>,24,25,<android.view.View: void onDrawScrollBars(Canvas)>,<android.view.View: void onDrawScrollBars(Canvas)>,0,"{
    // scrollbars are drawn only when the animation is running
    final ScrollabilityCache cache = mScrollCache;
    if (cache != null) {
        int state = cache.state;
        if (state == ScrollabilityCache.OFF) {
            return;
        }
        boolean invalidate = false;
        if (state == ScrollabilityCache.FADING) {
            // We're fading -- get our fade interpolation
            if (cache.interpolatorValues == null) {
                cache.interpolatorValues = new float[1];
            }
            float[] values = cache.interpolatorValues;
            // Stops the animation if we're done
            if (cache.scrollBarInterpolator.timeToValues(values) == Interpolator.Result.FREEZE_END) {
                cache.state = ScrollabilityCache.OFF;
            } else {
                cache.scrollBar.mutate().setAlpha(Math.round(values[0]));
            }
            // This will make the scroll bars inval themselves after
            // drawing. We only want this when we're fading so that
            // we prevent excessive redraws
            invalidate = true;
        } else {
            // We're just on -- but we may have been fading before so
            // reset alpha
            cache.scrollBar.mutate().setAlpha(255);
        }
        final boolean drawHorizontalScrollBar = isHorizontalScrollBarEnabled();
        final boolean drawVerticalScrollBar = isVerticalScrollBarEnabled() && !isVerticalScrollBarHidden();
        if (drawVerticalScrollBar || drawHorizontalScrollBar) {
            final ScrollBarDrawable scrollBar = cache.scrollBar;
            if (drawHorizontalScrollBar) {
                scrollBar.setParameters(computeHorizontalScrollRange(), computeHorizontalScrollOffset(), computeHorizontalScrollExtent(), false);
                final Rect bounds = cache.mScrollBarBounds;
                getHorizontalScrollBarBounds(bounds);
                onDrawHorizontalScrollBar(canvas, scrollBar, bounds.left, bounds.top, bounds.right, bounds.bottom);
                if (invalidate) {
                    invalidate(bounds);
                }
            }
            if (drawVerticalScrollBar) {
                scrollBar.setParameters(computeVerticalScrollRange(), computeVerticalScrollOffset(), computeVerticalScrollExtent(), true);
                final Rect bounds = cache.mScrollBarBounds;
                getVerticalScrollBarBounds(bounds);
                onDrawVerticalScrollBar(canvas, scrollBar, bounds.left, bounds.top, bounds.right, bounds.bottom);
                if (invalidate) {
                    invalidate(bounds);
                }
            }
        }
    }
}","{
    // scrollbars are drawn only when the animation is running
    final ScrollabilityCache cache = mScrollCache;
    if (cache != null) {
        int state = cache.state;
        if (state == ScrollabilityCache.OFF) {
            return;
        }
        boolean invalidate = false;
        if (state == ScrollabilityCache.FADING) {
            // We're fading -- get our fade interpolation
            if (cache.interpolatorValues == null) {
                cache.interpolatorValues = new float[1];
            }
            float[] values = cache.interpolatorValues;
            // Stops the animation if we're done
            if (cache.scrollBarInterpolator.timeToValues(values) == Interpolator.Result.FREEZE_END) {
                cache.state = ScrollabilityCache.OFF;
            } else {
                cache.scrollBar.mutate().setAlpha(Math.round(values[0]));
            }
            // This will make the scroll bars inval themselves after
            // drawing. We only want this when we're fading so that
            // we prevent excessive redraws
            invalidate = true;
        } else {
            // We're just on -- but we may have been fading before so
            // reset alpha
            cache.scrollBar.mutate().setAlpha(255);
        }
        final boolean drawHorizontalScrollBar = isHorizontalScrollBarEnabled();
        final boolean drawVerticalScrollBar = isVerticalScrollBarEnabled() && !isVerticalScrollBarHidden();
        // Fork out the scroll bar drawing for round wearable devices.
        if (mRoundScrollbarRenderer != null) {
            if (drawVerticalScrollBar) {
                final Rect bounds = cache.mScrollBarBounds;
                getVerticalScrollBarBounds(bounds);
                mRoundScrollbarRenderer.drawRoundScrollbars(canvas, (float) cache.scrollBar.getAlpha() / 255f, bounds);
                if (invalidate) {
                    invalidate();
                }
            }
        // Do not draw horizontal scroll bars for round wearable devices.
        } else if (drawVerticalScrollBar || drawHorizontalScrollBar) {
            final ScrollBarDrawable scrollBar = cache.scrollBar;
            if (drawHorizontalScrollBar) {
                scrollBar.setParameters(computeHorizontalScrollRange(), computeHorizontalScrollOffset(), computeHorizontalScrollExtent(), false);
                final Rect bounds = cache.mScrollBarBounds;
                getHorizontalScrollBarBounds(bounds);
                onDrawHorizontalScrollBar(canvas, scrollBar, bounds.left, bounds.top, bounds.right, bounds.bottom);
                if (invalidate) {
                    invalidate(bounds);
                }
            }
            if (drawVerticalScrollBar) {
                scrollBar.setParameters(computeVerticalScrollRange(), computeVerticalScrollOffset(), computeVerticalScrollExtent(), true);
                final Rect bounds = cache.mScrollBarBounds;
                getVerticalScrollBarBounds(bounds);
                onDrawVerticalScrollBar(canvas, scrollBar, bounds.left, bounds.top, bounds.right, bounds.bottom);
                if (invalidate) {
                    invalidate(bounds);
                }
            }
        }
    }
}",1,"/**
 * <p>Request the drawing of the horizontal and the vertical scrollbar. The
 * scrollbars are painted only if they have been awakened first.</p>
 *
 * @param canvas the canvas on which to draw the scrollbars
 *
 * @see #awakenScrollBars(int)
 */
","/**
 * <p>Request the drawing of the horizontal and the vertical scrollbar. The
 * scrollbars are painted only if they have been awakened first.</p>
 *
 * @param canvas the canvas on which to draw the scrollbars
 *
 * @see #awakenScrollBars(int)
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
75,"<android.app.LoadedApk.ServiceDispatcher: void doConnected(ComponentName,IBinder)>",24,25,"<android.app.LoadedApk.ServiceDispatcher: void doConnected(ComponentName,IBinder)>","<android.app.LoadedApk.ServiceDispatcher: void doConnected(ComponentName,IBinder)>",0,"{
    ServiceDispatcher.ConnectionInfo old;
    ServiceDispatcher.ConnectionInfo info;
    synchronized (this) {
        if (mForgotten) {
            // any connection received.
            return;
        }
        old = mActiveConnections.get(name);
        if (old != null && old.binder == service) {
            // Huh, already have this one.  Oh well!
            return;
        }
        if (service != null) {
            // A new service is being connected... set it all up.
            info = new ConnectionInfo();
            info.binder = service;
            info.deathMonitor = new DeathMonitor(name, service);
            try {
                service.linkToDeath(info.deathMonitor, 0);
                mActiveConnections.put(name, info);
            } catch (RemoteException e) {
                // This service was dead before we got it...  just
                // don't do anything with it.
                mActiveConnections.remove(name);
                return;
            }
        } else {
            // The named service is being disconnected... clean up.
            mActiveConnections.remove(name);
        }
        if (old != null) {
            old.binder.unlinkToDeath(old.deathMonitor, 0);
        }
    }
    // If there was an old service, it is not disconnected.
    if (old != null) {
        mConnection.onServiceDisconnected(name);
    }
    // If there is a new service, it is now connected.
    if (service != null) {
        mConnection.onServiceConnected(name, service);
    }
}","{
    ServiceDispatcher.ConnectionInfo old;
    ServiceDispatcher.ConnectionInfo info;
    synchronized (this) {
        if (mForgotten) {
            // any connection received.
            return;
        }
        old = mActiveConnections.get(name);
        if (old != null && old.binder == service) {
            // Huh, already have this one.  Oh well!
            return;
        }
        if (service != null) {
            // A new service is being connected... set it all up.
            info = new ConnectionInfo();
            info.binder = service;
            info.deathMonitor = new DeathMonitor(name, service);
            try {
                service.linkToDeath(info.deathMonitor, 0);
                mActiveConnections.put(name, info);
            } catch (RemoteException e) {
                // This service was dead before we got it...  just
                // don't do anything with it.
                mActiveConnections.remove(name);
                return;
            }
        } else {
            // The named service is being disconnected... clean up.
            mActiveConnections.remove(name);
        }
        if (old != null) {
            old.binder.unlinkToDeath(old.deathMonitor, 0);
        }
    }
    // If there was an old service, it is now disconnected.
    if (old != null) {
        mConnection.onServiceDisconnected(name);
    }
    // If there is a new service, it is now connected.
    if (service != null) {
        mConnection.onServiceConnected(name, service);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,0,0,"There are no changes in the implementations between the early and late versions. Therefore, no code change is detected.","Since there is no difference between the early and late versions of the code, there are no Compatibility Issues."
76,"<android.app.WallpaperManager.Globals: Bitmap peekWallpaperBitmap(Context,boolean,int,int)>",24,25,"<android.app.WallpaperManager.Globals: Bitmap peekWallpaperBitmap(Context,boolean,int,int)>","<android.app.WallpaperManager.Globals: Bitmap peekWallpaperBitmap(Context,boolean,int,int)>",0,"{
    synchronized (this) {
        if (mService != null) {
            try {
                if (!mService.isWallpaperSupported(context.getOpPackageName())) {
                    return null;
                }
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
        }
        if (mCachedWallpaper != null && mCachedWallpaperUserId == userId) {
            return mCachedWallpaper;
        }
        mCachedWallpaper = null;
        mCachedWallpaperUserId = 0;
        try {
            mCachedWallpaper = getCurrentWallpaperLocked(userId);
            mCachedWallpaperUserId = userId;
        } catch (OutOfMemoryError e) {
            Log.w(TAG, ""No memory load current wallpaper"", e);
        }
        if (mCachedWallpaper != null) {
            return mCachedWallpaper;
        }
        if (returnDefault) {
            if (mDefaultWallpaper == null) {
                mDefaultWallpaper = getDefaultWallpaperLocked(context, which);
            }
            return mDefaultWallpaper;
        }
        return null;
    }
}","{
    if (mService != null) {
        try {
            if (!mService.isWallpaperSupported(context.getOpPackageName())) {
                return null;
            }
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    synchronized (this) {
        if (mCachedWallpaper != null && mCachedWallpaperUserId == userId) {
            return mCachedWallpaper;
        }
        mCachedWallpaper = null;
        mCachedWallpaperUserId = 0;
        try {
            mCachedWallpaper = getCurrentWallpaperLocked(userId);
            mCachedWallpaperUserId = userId;
        } catch (OutOfMemoryError e) {
            Log.w(TAG, ""No memory load current wallpaper"", e);
        }
        if (mCachedWallpaper != null) {
            return mCachedWallpaper;
        }
    }
    if (returnDefault) {
        Bitmap defaultWallpaper = mDefaultWallpaper;
        if (defaultWallpaper == null) {
            defaultWallpaper = getDefaultWallpaper(context, which);
            synchronized (this) {
                mDefaultWallpaper = defaultWallpaper;
            }
        }
        return defaultWallpaper;
    }
    return null;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The synchronization block has been altered by moving a conditional block outside of it, also there is an additional assignment for the `defaultWallaper`, and there is a change in how `mDefaultWallpaper` is assigned in a newly created synchronized block. The conditional checking `if (mCachedWallpaper != null)` is now contained within the synchronized block, and the block handling `returnDefault` has been moved outside of the synchronized block. This means that the changes in the code include a control dependency change as well as other statements due to the restructuring of the code (change type 3, 4).","Despite the restructuring of the synchronization and the moving of code blocks, the behavior of the method itself has not fundamentally changed. The logic before and after the modifications maintains the same checks and operations on the object's state, returning the same wallpaper under the same conditions. The synchronization change and the addition of assigning `defaultWallpaper` to `mDefaultWallpaper` within its own synchronized block don't impact the bitmap that will ultimately be returned to the caller. Thus, we do not expect any potential Compatibility Issue arising from this change (CI type 0)."
77,"<android.hardware.camera2.CameraManager: void openCamera(String,StateCallback,Handler)>",24,25,"<android.hardware.camera2.CameraManager: void openCamera(String,StateCallback,Handler)>","<android.hardware.camera2.CameraManager: void openCamera(String,StateCallback,Handler)>",0,"{
    if (cameraId == null) {
        throw new IllegalArgumentException(""cameraId was null"");
    } else if (callback == null) {
        throw new IllegalArgumentException(""callback was null"");
    } else if (handler == null) {
        if (Looper.myLooper() != null) {
            handler = new Handler();
        } else {
            throw new IllegalArgumentException(""Handler argument is null, but no looper exists in the calling thread"");
        }
    }
    openCameraDeviceUserAsync(cameraId, callback, handler);
}","{
    openCameraForUid(cameraId, callback, handler, USE_CALLING_UID);
}",1,"/**
 * Open a connection to a camera with the given ID.
 *
 * <p>Use {@link #getCameraIdList} to get the list of available camera
 * devices. Note that even if an id is listed, open may fail if the device
 * is disconnected between the calls to {@link #getCameraIdList} and
 * {@link #openCamera}, or if a higher-priority camera API client begins using the
 * camera device.</p>
 *
 * <p>As of API level 23, devices for which the
 * {@link AvailabilityCallback#onCameraUnavailable(String)} callback has been called due to the
 * device being in use by a lower-priority, background camera API client can still potentially
 * be opened by calling this method when the calling camera API client has a higher priority
 * than the current camera API client using this device.  In general, if the top, foreground
 * activity is running within your application process, your process will be given the highest
 * priority when accessing the camera, and this method will succeed even if the camera device is
 * in use by another camera API client. Any lower-priority application that loses control of the
 * camera in this way will receive an
 * {@link android.hardware.camera2.CameraDevice.StateCallback#onDisconnected} callback.</p>
 *
 * <p>Once the camera is successfully opened, {@link CameraDevice.StateCallback#onOpened} will
 * be invoked with the newly opened {@link CameraDevice}. The camera device can then be set up
 * for operation by calling {@link CameraDevice#createCaptureSession} and
 * {@link CameraDevice#createCaptureRequest}</p>
 *
 * <!--
 * <p>Since the camera device will be opened asynchronously, any asynchronous operations done
 * on the returned CameraDevice instance will be queued up until the device startup has
 * completed and the callback's {@link CameraDevice.StateCallback#onOpened onOpened} method is
 * called. The pending operations are then processed in order.</p>
 * -->
 * <p>If the camera becomes disconnected during initialization
 * after this function call returns,
 * {@link CameraDevice.StateCallback#onDisconnected} with a
 * {@link CameraDevice} in the disconnected state (and
 * {@link CameraDevice.StateCallback#onOpened} will be skipped).</p>
 *
 * <p>If opening the camera device fails, then the device callback's
 * {@link CameraDevice.StateCallback#onError onError} method will be called, and subsequent
 * calls on the camera device will throw a {@link CameraAccessException}.</p>
 *
 * @param cameraId
 * The unique identifier of the camera device to open
 * @param callback
 * The callback which is invoked once the camera is opened
 * @param handler
 * The handler on which the callback should be invoked, or
 * {@code null} to use the current thread's {@link android.os.Looper looper}.
 *
 * @throws CameraAccessException if the camera is disabled by device policy,
 * has been disconnected, or is being used by a higher-priority camera API client.
 *
 * @throws IllegalArgumentException if cameraId or the callback was null,
 * or the cameraId does not match any currently or previously available
 * camera device.
 *
 * @throws SecurityException if the application does not have permission to
 * access the camera
 *
 * @see #getCameraIdList
 * @see android.app.admin.DevicePolicyManager#setCameraDisabled
 */
","/**
 * Open a connection to a camera with the given ID.
 *
 * <p>Use {@link #getCameraIdList} to get the list of available camera
 * devices. Note that even if an id is listed, open may fail if the device
 * is disconnected between the calls to {@link #getCameraIdList} and
 * {@link #openCamera}, or if a higher-priority camera API client begins using the
 * camera device.</p>
 *
 * <p>As of API level 23, devices for which the
 * {@link AvailabilityCallback#onCameraUnavailable(String)} callback has been called due to the
 * device being in use by a lower-priority, background camera API client can still potentially
 * be opened by calling this method when the calling camera API client has a higher priority
 * than the current camera API client using this device.  In general, if the top, foreground
 * activity is running within your application process, your process will be given the highest
 * priority when accessing the camera, and this method will succeed even if the camera device is
 * in use by another camera API client. Any lower-priority application that loses control of the
 * camera in this way will receive an
 * {@link android.hardware.camera2.CameraDevice.StateCallback#onDisconnected} callback.</p>
 *
 * <p>Once the camera is successfully opened, {@link CameraDevice.StateCallback#onOpened} will
 * be invoked with the newly opened {@link CameraDevice}. The camera device can then be set up
 * for operation by calling {@link CameraDevice#createCaptureSession} and
 * {@link CameraDevice#createCaptureRequest}</p>
 *
 * <!--
 * <p>Since the camera device will be opened asynchronously, any asynchronous operations done
 * on the returned CameraDevice instance will be queued up until the device startup has
 * completed and the callback's {@link CameraDevice.StateCallback#onOpened onOpened} method is
 * called. The pending operations are then processed in order.</p>
 * -->
 * <p>If the camera becomes disconnected during initialization
 * after this function call returns,
 * {@link CameraDevice.StateCallback#onDisconnected} with a
 * {@link CameraDevice} in the disconnected state (and
 * {@link CameraDevice.StateCallback#onOpened} will be skipped).</p>
 *
 * <p>If opening the camera device fails, then the device callback's
 * {@link CameraDevice.StateCallback#onError onError} method will be called, and subsequent
 * calls on the camera device will throw a {@link CameraAccessException}.</p>
 *
 * @param cameraId
 * The unique identifier of the camera device to open
 * @param callback
 * The callback which is invoked once the camera is opened
 * @param handler
 * The handler on which the callback should be invoked, or
 * {@code null} to use the current thread's {@link android.os.Looper looper}.
 *
 * @throws CameraAccessException if the camera is disabled by device policy,
 * has been disconnected, or is being used by a higher-priority camera API client.
 *
 * @throws IllegalArgumentException if cameraId or the callback was null,
 * or the cameraId does not match any currently or previously available
 * camera device.
 *
 * @throws SecurityException if the application does not have permission to
 * access the camera
 *
 * @see #getCameraIdList
 * @see android.app.admin.DevicePolicyManager#setCameraDisabled
 */
",-1,[@RequiresPermission(android.Manifest.permission.CAMERA)],[@RequiresPermission(android.Manifest.permission.CAMERA)],-1,-1,-1,-1,-1,-1,"4,5",0,"The entire argument validation and handler setting logic has been removed from the method's body, and the method called within the body has been changed from openCameraDeviceUserAsync() to openCameraForUid(). The removed logic managed argument checking and created a new Handler if needed while running on a thread with a Looper. Thus, it's an 'Other statement changed' and also a 'Dependent API changed' because a different method is being called to perform the action.","Despite the significant refactoring of this API's implementation, it does not necessarily introduce a compatibility issue from the perspective of different return values or exceptions being thrown. Since the new implementation (assuming correct functionality of openCameraForUid with the constant USE_CALLING_UID) should transparently handle the responsibilities of the early version's explicit argument validation and Handler creation internally, end users should not experience any change in functionality. If the method openCameraForUid intrinsically manages these responsibilities, the behavior of the API remains consistent with the previous version, resulting in 'No Compatibility Issue'."
79,<android.app.ActivityTransitionState: void enterReady(Activity)>,24,25,<android.app.ActivityTransitionState: void enterReady(Activity)>,<android.app.ActivityTransitionState: void enterReady(Activity)>,0,"{
    if (mEnterActivityOptions == null || mIsEnterTriggered) {
        return;
    }
    mIsEnterTriggered = true;
    mHasExited = false;
    ArrayList<String> sharedElementNames = mEnterActivityOptions.getSharedElementNames();
    ResultReceiver resultReceiver = mEnterActivityOptions.getResultReceiver();
    if (mEnterActivityOptions.isReturning()) {
        restoreExitedViews();
        activity.getWindow().getDecorView().setVisibility(View.VISIBLE);
    }
    mEnterTransitionCoordinator = new EnterTransitionCoordinator(activity, resultReceiver, sharedElementNames, mEnterActivityOptions.isReturning());
    if (!mIsEnterPostponed) {
        startEnter();
    }
}","{
    if (mEnterActivityOptions == null || mIsEnterTriggered) {
        return;
    }
    mIsEnterTriggered = true;
    mHasExited = false;
    ArrayList<String> sharedElementNames = mEnterActivityOptions.getSharedElementNames();
    ResultReceiver resultReceiver = mEnterActivityOptions.getResultReceiver();
    if (mEnterActivityOptions.isReturning()) {
        restoreExitedViews();
        activity.getWindow().getDecorView().setVisibility(View.VISIBLE);
    }
    mEnterTransitionCoordinator = new EnterTransitionCoordinator(activity, resultReceiver, sharedElementNames, mEnterActivityOptions.isReturning(), mEnterActivityOptions.isCrossTask());
    if (mEnterActivityOptions.isCrossTask()) {
        mExitingFrom = new ArrayList<>(mEnterActivityOptions.getSharedElementNames());
        mExitingTo = new ArrayList<>(mEnterActivityOptions.getSharedElementNames());
    }
    if (!mIsEnterPostponed) {
        startEnter();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The signature for the constructor of EnterTransitionCoordinator has changed with an additional parameter for isCrossTask(). There is also a new if block introduced which initializes two new ArrayLists if mEnterActivityOptions.isCrossTask() is true. These represent other statement changes and dependent API changes, making the change type 4,5.","Given that modifications include changes to the construction of an EnterTransitionCoordinator with a possibly new behavior dictated by the isCrossTask() condition in addition to the new initialization of mExitingFrom and mExitingTo, the API could lead to different behaviors when isCrossTask() is true. Therefore, a compatibility issue could arise from the potential different return values or states, rendering the CI type as 1."
81,<android.widget.Toolbar: int getContentInsetEnd()>,24,25,<android.widget.Toolbar: int getContentInsetEnd()>,<android.widget.Toolbar: int getContentInsetEnd()>,0,"{
    return mContentInsets.getEnd();
}","{
    return mContentInsets != null ? mContentInsets.getEnd() : 0;
}",1,"/**
 * Gets the ending content inset for this toolbar.
 *
 * <p>The content inset affects the valid area for Toolbar content other than
 * the navigation button and menu. Insets define the minimum margin for these components
 * and can be used to effectively align Toolbar content along well-known gridlines.</p>
 *
 * @return The ending content inset for this toolbar
 *
 * @see #setContentInsetsRelative(int, int)
 * @see #setContentInsetsAbsolute(int, int)
 * @see #getContentInsetStart()
 * @see #getContentInsetLeft()
 * @see #getContentInsetRight()
 * @attr ref android.R.styleable#Toolbar_contentInsetEnd
 */
","/**
 * Gets the ending content inset for this toolbar.
 *
 * <p>The content inset affects the valid area for Toolbar content other than
 * the navigation button and menu. Insets define the minimum margin for these components
 * and can be used to effectively align Toolbar content along well-known gridlines.</p>
 *
 * @return The ending content inset for this toolbar
 *
 * @see #setContentInsetsRelative(int, int)
 * @see #setContentInsetsAbsolute(int, int)
 * @see #getContentInsetStart()
 * @see #getContentInsetLeft()
 * @see #getContentInsetRight()
 * @attr ref android.R.styleable#Toolbar_contentInsetEnd
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The late version of the code includes a null check on `mContentInsets` and returns 0 if `mContentInsets` is null. This is a defensive programming change to handle possible null-pointer exceptions and qualifies as both a return statement change and an other statement change. Therefore, the code change type is 1,4.","Since the early version would potentially throw a null-pointer exception when `mContentInsets` is null, whereas the late version returns 0 in this case, the behavior of the method has changed significantly. This could cause a compatibility issue for programs expecting an exception instead of a 0 return value when `mContentInsets` is null. Thus, the CI type is 1."
82,<android.bluetooth.BluetoothA2dp: int getConnectionState(BluetoothDevice)>,24,25,<android.bluetooth.BluetoothA2dp: int getConnectionState(BluetoothDevice)>,<android.bluetooth.BluetoothA2dp: int getConnectionState(BluetoothDevice)>,0,"{
    if (VDBG)
        log(""getState("" + device + "")"");
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.getConnectionState(device);
        } catch (RemoteException e) {
            Log.e(TAG, ""Stack:"" + Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.STATE_DISCONNECTED;
        }
    }
    if (mService == null)
        Log.w(TAG, ""Proxy not attached to service"");
    return BluetoothProfile.STATE_DISCONNECTED;
}","{
    if (VDBG)
        log(""getState("" + device + "")"");
    try {
        mServiceLock.readLock().lock();
        if (mService != null && isEnabled() && isValidDevice(device)) {
            return mService.getConnectionState(device);
        }
        if (mService == null)
            Log.w(TAG, ""Proxy not attached to service"");
        return BluetoothProfile.STATE_DISCONNECTED;
    } catch (RemoteException e) {
        Log.e(TAG, ""Stack:"" + Log.getStackTraceString(new Throwable()));
        return BluetoothProfile.STATE_DISCONNECTED;
    } finally {
        mServiceLock.readLock().unlock();
    }
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The try-catch block has been expanded to include locking and unlocking of a read lock, which is an addition of a control dependency and an other statement change, so the code change type is 3,4.","The change is related to concurrency control using a read lock, and does not affect the behavior of how the API computes or returns a result or how exceptions are handled. The core logic and the return values remain the same, thus there is no Compatibility Issue; the CI type is 0."
85,"<android.bluetooth.BluetoothSocket: int write(byte[],int,int)>",24,25,"<android.bluetooth.BluetoothSocket: int write(byte[],int,int)>","<android.bluetooth.BluetoothSocket: int write(byte[],int,int)>",0,"{
    // to the actual message length.
    if (VDBG)
        Log.d(TAG, ""write: "" + mSocketOS + "" length: "" + length);
    if (mType == TYPE_L2CAP) {
        if (length <= mMaxTxPacketSize) {
            mSocketOS.write(b, offset, length);
        } else {
            int tmpOffset = offset;
            int tmpLength = mMaxTxPacketSize;
            int endIndex = offset + length;
            boolean done = false;
            if (DBG)
                Log.w(TAG, ""WARNING: Write buffer larger than L2CAP packet size!\n"" + ""Packet will be divided into SDU packets of size "" + mMaxTxPacketSize);
            do {
                mSocketOS.write(b, tmpOffset, tmpLength);
                tmpOffset += mMaxTxPacketSize;
                if ((tmpOffset + mMaxTxPacketSize) > endIndex) {
                    tmpLength = endIndex - tmpOffset;
                    done = true;
                }
            } while (!done);
        }
    } else {
        mSocketOS.write(b, offset, length);
    }
    // There is no good way to confirm since the entire process is asynchronous anyway
    if (VDBG)
        Log.d(TAG, ""write out: "" + mSocketOS + "" length: "" + length);
    return length;
}","{
    // to the actual message length.
    if (VDBG)
        Log.d(TAG, ""write: "" + mSocketOS + "" length: "" + length);
    if (mType == TYPE_L2CAP) {
        if (length <= mMaxTxPacketSize) {
            mSocketOS.write(b, offset, length);
        } else {
            if (DBG)
                Log.w(TAG, ""WARNING: Write buffer larger than L2CAP packet size!\n"" + ""Packet will be divided into SDU packets of size "" + mMaxTxPacketSize);
            int tmpOffset = offset;
            int bytesToWrite = length;
            while (bytesToWrite > 0) {
                int tmpLength = (bytesToWrite > mMaxTxPacketSize) ? mMaxTxPacketSize : bytesToWrite;
                mSocketOS.write(b, tmpOffset, tmpLength);
                tmpOffset += tmpLength;
                bytesToWrite -= tmpLength;
            }
        }
    } else {
        mSocketOS.write(b, offset, length);
    }
    // There is no good way to confirm since the entire process is asynchronous anyway
    if (VDBG)
        Log.d(TAG, ""write out: "" + mSocketOS + "" length: "" + length);
    return length;
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The 'do-while' loop in the early version was replaced with a 'while' loop in the late version, which is a change in control structure (type 3). The internal logic of loop iteration has been altered slightly, with the introduction of the bytesToWrite variable in place of the done boolean, so it's also an Other statement changed (type 4).","Despite the changes in control flow and internal loop logic, there is no impact on the output of the method. Both implementations aim at splitting large byte arrays into smaller packets conforming to mMaxTxPacketSize and writing them to mSocketOS. Therefore, no Compatibility Issue arises in this case (type 0)."
86,<android.service.notification.ZenModeConfig.ZenRule: String toString()>,24,25,<android.service.notification.ZenModeConfig.ZenRule: String toString()>,<android.service.notification.ZenModeConfig.ZenRule: String toString()>,0,"{
    return new StringBuilder(ZenRule.class.getSimpleName()).append('[').append(""enabled="").append(enabled).append("",snoozing="").append(snoozing).append("",name="").append(name).append("",zenMode="").append(Global.zenModeToString(zenMode)).append("",conditionId="").append(conditionId).append("",condition="").append(condition).append("",component="").append(component).append("",id="").append(id).append("",creationTime="").append(creationTime).append(']').toString();
}","{
    return new StringBuilder(ZenRule.class.getSimpleName()).append('[').append(""enabled="").append(enabled).append("",snoozing="").append(snoozing).append("",name="").append(name).append("",zenMode="").append(Global.zenModeToString(zenMode)).append("",conditionId="").append(conditionId).append("",condition="").append(condition).append("",component="").append(component).append("",id="").append(id).append("",creationTime="").append(creationTime).append("",enabler="").append(enabler).append(']').toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The method implementation has been appended with "",enabler="").append(enabler) which is an addition to the StringBuilder construction. This change does not involve a return type change, exception handling change, or control dependency change. It's just additional information being appended to the string, indicating a change type of 4.","There is no compatibility issue because the method's purpose is to return a string representation of the object's state, and the addition of extra state information does not affect the method's contract or expected behavior. It continues to fulfill the contract of returning a string representation."
87,<android.bluetooth.BluetoothA2dp: List<BluetoothDevice> getConnectedDevices()>,24,25,<android.bluetooth.BluetoothA2dp: List<BluetoothDevice> getConnectedDevices()>,<android.bluetooth.BluetoothA2dp: List<BluetoothDevice> getConnectedDevices()>,0,"{
    if (VDBG)
        log(""getConnectedDevices()"");
    if (mService != null && isEnabled()) {
        try {
            return mService.getConnectedDevices();
        } catch (RemoteException e) {
            Log.e(TAG, ""Stack:"" + Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (mService == null)
        Log.w(TAG, ""Proxy not attached to service"");
    return new ArrayList<BluetoothDevice>();
}","{
    if (VDBG)
        log(""getConnectedDevices()"");
    try {
        mServiceLock.readLock().lock();
        if (mService != null && isEnabled()) {
            return mService.getConnectedDevices();
        }
        if (mService == null)
            Log.w(TAG, ""Proxy not attached to service"");
        return new ArrayList<BluetoothDevice>();
    } catch (RemoteException e) {
        Log.e(TAG, ""Stack:"" + Log.getStackTraceString(new Throwable()));
        return new ArrayList<BluetoothDevice>();
    } finally {
        mServiceLock.readLock().unlock();
    }
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"There is a new control structure (try-finally block) surrounding the code in the late version, and also the exception handling has moved out from the if condition, so the code change types are 3 and 4.","While the overall structure of the code is different due to the addition of the read lock and the change in the location of the try-catch block, the core logic determining the behavior of the method (i.e., whether it returns the list of connected devices or an empty list) has not been altered. The method still returns the same value under the same circumstances as it did before. As such, there is no change in the exception handling that would affect the client's code, nor is there a change in the return statements or values under the same conditions. Hence, there is no Compatibility Issue."
88,"<android.nfc.NfcAdapter: void enableForegroundDispatch(Activity,PendingIntent,IntentFilter[],String[][])>",24,25,"<android.nfc.NfcAdapter: void enableForegroundDispatch(Activity,PendingIntent,IntentFilter[],String[][])>","<android.nfc.NfcAdapter: void enableForegroundDispatch(Activity,PendingIntent,IntentFilter[],String[][])>",0,"{
    if (activity == null || intent == null) {
        throw new NullPointerException();
    }
    if (!activity.isResumed()) {
        throw new IllegalStateException(""Foreground dispatch can only be enabled "" + ""when your activity is resumed"");
    }
    try {
        TechListParcel parcel = null;
        if (techLists != null && techLists.length > 0) {
            parcel = new TechListParcel(techLists);
        }
        ActivityThread.currentActivityThread().registerOnActivityPausedListener(activity, mForegroundDispatchListener);
        sService.setForegroundDispatch(intent, filters, parcel);
    } catch (RemoteException e) {
        attemptDeadServiceRecovery(e);
    }
}","{
    synchronized (NfcAdapter.class) {
        if (!sHasNfcFeature) {
            throw new UnsupportedOperationException();
        }
    }
    if (activity == null || intent == null) {
        throw new NullPointerException();
    }
    if (!activity.isResumed()) {
        throw new IllegalStateException(""Foreground dispatch can only be enabled "" + ""when your activity is resumed"");
    }
    try {
        TechListParcel parcel = null;
        if (techLists != null && techLists.length > 0) {
            parcel = new TechListParcel(techLists);
        }
        ActivityThread.currentActivityThread().registerOnActivityPausedListener(activity, mForegroundDispatchListener);
        sService.setForegroundDispatch(intent, filters, parcel);
    } catch (RemoteException e) {
        attemptDeadServiceRecovery(e);
    }
}",1,"/**
 * Enable foreground dispatch to the given Activity.
 *
 * <p>This will give give priority to the foreground activity when
 * dispatching a discovered {@link Tag} to an application.
 *
 * <p>If any IntentFilters are provided to this method they are used to match dispatch Intents
 * for both the {@link NfcAdapter#ACTION_NDEF_DISCOVERED} and
 * {@link NfcAdapter#ACTION_TAG_DISCOVERED}. Since {@link NfcAdapter#ACTION_TECH_DISCOVERED}
 * relies on meta data outside of the IntentFilter matching for that dispatch Intent is handled
 * by passing in the tech lists separately. Each first level entry in the tech list represents
 * an array of technologies that must all be present to match. If any of the first level sets
 * match then the dispatch is routed through the given PendingIntent. In other words, the second
 * level is ANDed together and the first level entries are ORed together.
 *
 * <p>If you pass {@code null} for both the {@code filters} and {@code techLists} parameters
 * that acts a wild card and will cause the foreground activity to receive all tags via the
 * {@link NfcAdapter#ACTION_TAG_DISCOVERED} intent.
 *
 * <p>This method must be called from the main thread, and only when the activity is in the
 * foreground (resumed). Also, activities must call {@link #disableForegroundDispatch} before
 * the completion of their {@link Activity#onPause} callback to disable foreground dispatch
 * after it has been enabled.
 *
 * <p class=""note"">Requires the {@link android.Manifest.permission#NFC} permission.
 *
 * @param activity the Activity to dispatch to
 * @param intent the PendingIntent to start for the dispatch
 * @param filters the IntentFilters to override dispatching for, or null to always dispatch
 * @param techLists the tech lists used to perform matching for dispatching of the
 * {@link NfcAdapter#ACTION_TECH_DISCOVERED} intent
 * @throws IllegalStateException if the Activity is not currently in the foreground
 */
","/**
 * Enable foreground dispatch to the given Activity.
 *
 * <p>This will give give priority to the foreground activity when
 * dispatching a discovered {@link Tag} to an application.
 *
 * <p>If any IntentFilters are provided to this method they are used to match dispatch Intents
 * for both the {@link NfcAdapter#ACTION_NDEF_DISCOVERED} and
 * {@link NfcAdapter#ACTION_TAG_DISCOVERED}. Since {@link NfcAdapter#ACTION_TECH_DISCOVERED}
 * relies on meta data outside of the IntentFilter matching for that dispatch Intent is handled
 * by passing in the tech lists separately. Each first level entry in the tech list represents
 * an array of technologies that must all be present to match. If any of the first level sets
 * match then the dispatch is routed through the given PendingIntent. In other words, the second
 * level is ANDed together and the first level entries are ORed together.
 *
 * <p>If you pass {@code null} for both the {@code filters} and {@code techLists} parameters
 * that acts a wild card and will cause the foreground activity to receive all tags via the
 * {@link NfcAdapter#ACTION_TAG_DISCOVERED} intent.
 *
 * <p>This method must be called from the main thread, and only when the activity is in the
 * foreground (resumed). Also, activities must call {@link #disableForegroundDispatch} before
 * the completion of their {@link Activity#onPause} callback to disable foreground dispatch
 * after it has been enabled.
 *
 * <p class=""note"">Requires the {@link android.Manifest.permission#NFC} permission.
 *
 * @param activity the Activity to dispatch to
 * @param intent the PendingIntent to start for the dispatch
 * @param filters the IntentFilters to override dispatching for, or null to always dispatch
 * @param techLists the tech lists used to perform matching for dispatching of the
 * {@link NfcAdapter#ACTION_TECH_DISCOVERED} intent
 * @throws IllegalStateException if the Activity is not currently in the foreground
 * @throws UnsupportedOperationException if FEATURE_NFC is unavailable.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"The early version does not check if the NFC feature is available on the device, whereas the late version does with an additional synchronized block containing a new exception handling statement for throwing an UnsupportedOperationException, hence the changes are related to a control dependency (3) and exception handling statement (2).","The introduction of a new exception (UnsupportedOperationException) for the case when the NFC feature is not available on the device is a Compatibility Issue as this exception was not thrown in the previous version, which could lead to different behavior when the newer API version is used. Thus, the CI type is 2."
89,<android.app.ActivityOptions: Bundle toBundle()>,24,25,<android.app.ActivityOptions: Bundle toBundle()>,<android.app.ActivityOptions: Bundle toBundle()>,0,"{
    if (mAnimationType == ANIM_DEFAULT) {
        return null;
    }
    Bundle b = new Bundle();
    if (mPackageName != null) {
        b.putString(KEY_PACKAGE_NAME, mPackageName);
    }
    if (mLaunchBounds != null) {
        b.putParcelable(KEY_LAUNCH_BOUNDS, mLaunchBounds);
    }
    b.putInt(KEY_ANIM_TYPE, mAnimationType);
    if (mUsageTimeReport != null) {
        b.putParcelable(KEY_USAGE_TIME_REPORT, mUsageTimeReport);
    }
    switch(mAnimationType) {
        case ANIM_CUSTOM:
            b.putInt(KEY_ANIM_ENTER_RES_ID, mCustomEnterResId);
            b.putInt(KEY_ANIM_EXIT_RES_ID, mCustomExitResId);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_CUSTOM_IN_PLACE:
            b.putInt(KEY_ANIM_IN_PLACE_RES_ID, mCustomInPlaceResId);
            break;
        case ANIM_SCALE_UP:
        case ANIM_CLIP_REVEAL:
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
        case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
        case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
            b.putParcelable(KEY_ANIM_THUMBNAIL, mThumbnail);
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_SCENE_TRANSITION:
            if (mTransitionReceiver != null) {
                b.putParcelable(KEY_TRANSITION_COMPLETE_LISTENER, mTransitionReceiver);
            }
            b.putBoolean(KEY_TRANSITION_IS_RETURNING, mIsReturning);
            b.putStringArrayList(KEY_TRANSITION_SHARED_ELEMENTS, mSharedElementNames);
            b.putParcelable(KEY_RESULT_DATA, mResultData);
            b.putInt(KEY_RESULT_CODE, mResultCode);
            b.putInt(KEY_EXIT_COORDINATOR_INDEX, mExitCoordinatorIndex);
            break;
    }
    b.putInt(KEY_LAUNCH_STACK_ID, mLaunchStackId);
    b.putInt(KEY_LAUNCH_TASK_ID, mLaunchTaskId);
    b.putBoolean(KEY_TASK_OVERLAY, mTaskOverlay);
    b.putInt(KEY_DOCK_CREATE_MODE, mDockCreateMode);
    if (mAnimSpecs != null) {
        b.putParcelableArray(KEY_ANIM_SPECS, mAnimSpecs);
    }
    if (mAnimationFinishedListener != null) {
        b.putBinder(KEY_ANIMATION_FINISHED_LISTENER, mAnimationFinishedListener.asBinder());
    }
    return b;
}","{
    if (mAnimationType == ANIM_DEFAULT) {
        return null;
    }
    Bundle b = new Bundle();
    if (mPackageName != null) {
        b.putString(KEY_PACKAGE_NAME, mPackageName);
    }
    if (mLaunchBounds != null) {
        b.putParcelable(KEY_LAUNCH_BOUNDS, mLaunchBounds);
    }
    b.putInt(KEY_ANIM_TYPE, mAnimationType);
    if (mUsageTimeReport != null) {
        b.putParcelable(KEY_USAGE_TIME_REPORT, mUsageTimeReport);
    }
    switch(mAnimationType) {
        case ANIM_CUSTOM:
            b.putInt(KEY_ANIM_ENTER_RES_ID, mCustomEnterResId);
            b.putInt(KEY_ANIM_EXIT_RES_ID, mCustomExitResId);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_CUSTOM_IN_PLACE:
            b.putInt(KEY_ANIM_IN_PLACE_RES_ID, mCustomInPlaceResId);
            break;
        case ANIM_SCALE_UP:
        case ANIM_CLIP_REVEAL:
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
        case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
        case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
            b.putParcelable(KEY_ANIM_THUMBNAIL, mThumbnail);
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_SCENE_TRANSITION:
            if (mTransitionReceiver != null) {
                b.putParcelable(KEY_TRANSITION_COMPLETE_LISTENER, mTransitionReceiver);
            }
            b.putBoolean(KEY_TRANSITION_IS_RETURNING, mIsReturning);
            b.putStringArrayList(KEY_TRANSITION_SHARED_ELEMENTS, mSharedElementNames);
            b.putParcelable(KEY_RESULT_DATA, mResultData);
            b.putInt(KEY_RESULT_CODE, mResultCode);
            b.putInt(KEY_EXIT_COORDINATOR_INDEX, mExitCoordinatorIndex);
            break;
    }
    b.putInt(KEY_LAUNCH_STACK_ID, mLaunchStackId);
    b.putInt(KEY_LAUNCH_TASK_ID, mLaunchTaskId);
    b.putBoolean(KEY_TASK_OVERLAY, mTaskOverlay);
    b.putInt(KEY_DOCK_CREATE_MODE, mDockCreateMode);
    if (mAnimSpecs != null) {
        b.putParcelableArray(KEY_ANIM_SPECS, mAnimSpecs);
    }
    if (mAnimationFinishedListener != null) {
        b.putBinder(KEY_ANIMATION_FINISHED_LISTENER, mAnimationFinishedListener.asBinder());
    }
    b.putInt(KEY_ROTATION_ANIMATION_HINT, mRotationAnimationHint);
    return b;
}",1,"/**
 * Returns the created options as a Bundle, which can be passed to
 * {@link android.content.Context#startActivity(android.content.Intent, android.os.Bundle)
 * Context.startActivity(Intent, Bundle)} and related methods.
 * Note that the returned Bundle is still owned by the ActivityOptions
 * object; you must not modify it, but can supply it to the startActivity
 * methods that take an options Bundle.
 */
","/**
 * Returns the created options as a Bundle, which can be passed to
 * {@link android.content.Context#startActivity(android.content.Intent, android.os.Bundle)
 * Context.startActivity(Intent, Bundle)} and related methods.
 * Note that the returned Bundle is still owned by the ActivityOptions
 * object; you must not modify it, but can supply it to the startActivity
 * methods that take an options Bundle.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
90,<android.bluetooth.BluetoothA2dp: void close()>,24,25,<android.bluetooth.BluetoothA2dp: void close()>,<android.bluetooth.BluetoothA2dp: void close()>,0,"{
    mServiceListener = null;
    IBluetoothManager mgr = mAdapter.getBluetoothManager();
    if (mgr != null) {
        try {
            mgr.unregisterStateChangeCallback(mBluetoothStateChangeCallback);
        } catch (Exception e) {
            Log.e(TAG, """", e);
        }
    }
    synchronized (mConnection) {
        if (mService != null) {
            try {
                mService = null;
                mContext.unbindService(mConnection);
            } catch (Exception re) {
                Log.e(TAG, """", re);
            }
        }
    }
}","{
    mServiceListener = null;
    IBluetoothManager mgr = mAdapter.getBluetoothManager();
    if (mgr != null) {
        try {
            mgr.unregisterStateChangeCallback(mBluetoothStateChangeCallback);
        } catch (Exception e) {
            Log.e(TAG, """", e);
        }
    }
    try {
        mServiceLock.writeLock().lock();
        if (mService != null) {
            mService = null;
            mContext.unbindService(mConnection);
        }
    } catch (Exception re) {
        Log.e(TAG, """", re);
    } finally {
        mServiceLock.writeLock().unlock();
    }
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The method has introduced a try-catch block around the existing `synchronized` block and replaced it with a write lock on `mServiceLock`. The exception block remains the same. Therefore, we have a control dependency change due to the new lock mechanism and other statement change due to the added `finally` block.","Since the exception handling has not changed and the method does not return anything, there are no changes to the exceptions thrown or the returned values/types. The logic inside the protected block remains unchanged and the synchronization mechanism change does not directly affect the API's behavior from an external perspective. Therefore, there are no potential Compatibility Issues."
91,<android.appwidget.AppWidgetHost: void startListening()>,24,25,<android.appwidget.AppWidgetHost: void startListening()>,<android.appwidget.AppWidgetHost: void startListening()>,0,"{
    final int[] idsToUpdate;
    synchronized (mViews) {
        int N = mViews.size();
        idsToUpdate = new int[N];
        for (int i = 0; i < N; i++) {
            idsToUpdate[i] = mViews.keyAt(i);
        }
    }
    List<RemoteViews> updatedViews;
    int[] updatedIds = new int[idsToUpdate.length];
    try {
        updatedViews = sService.startListening(mCallbacks, mContextOpPackageName, mHostId, idsToUpdate, updatedIds).getList();
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
    int N = updatedViews.size();
    for (int i = 0; i < N; i++) {
        updateAppWidgetView(updatedIds[i], updatedViews.get(i));
    }
}","{
    final int[] idsToUpdate;
    synchronized (mViews) {
        int N = mViews.size();
        idsToUpdate = new int[N];
        for (int i = 0; i < N; i++) {
            idsToUpdate[i] = mViews.keyAt(i);
        }
    }
    List<PendingHostUpdate> updates;
    try {
        updates = sService.startListening(mCallbacks, mContextOpPackageName, mHostId, idsToUpdate).getList();
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
    int N = updates.size();
    for (int i = 0; i < N; i++) {
        PendingHostUpdate update = updates.get(i);
        switch(update.type) {
            case PendingHostUpdate.TYPE_VIEWS_UPDATE:
                updateAppWidgetView(update.appWidgetId, update.views);
                break;
            case PendingHostUpdate.TYPE_PROVIDER_CHANGED:
                onProviderChanged(update.appWidgetId, update.widgetInfo);
                break;
            case PendingHostUpdate.TYPE_VIEW_DATA_CHANGED:
                viewDataChanged(update.appWidgetId, update.viewId);
        }
    }
}",1,"/**
 * Start receiving onAppWidgetChanged calls for your AppWidgets.  Call this when your activity
 * becomes visible, i.e. from onStart() in your Activity.
 */
","/**
 * Start receiving onAppWidgetChanged calls for your AppWidgets.  Call this when your activity
 * becomes visible, i.e. from onStart() in your Activity.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,The method implementation changes significantly: ,- The `sService.startListening` method's signature has changed; it does not take `updatedIds` anymore.
92,<android.widget.Toolbar: int getContentInsetStart()>,24,25,<android.widget.Toolbar: int getContentInsetStart()>,<android.widget.Toolbar: int getContentInsetStart()>,0,"{
    return mContentInsets.getStart();
}","{
    return mContentInsets != null ? mContentInsets.getStart() : 0;
}",1,"/**
 * Gets the starting content inset for this toolbar.
 *
 * <p>The content inset affects the valid area for Toolbar content other than
 * the navigation button and menu. Insets define the minimum margin for these components
 * and can be used to effectively align Toolbar content along well-known gridlines.</p>
 *
 * @return The starting content inset for this toolbar
 *
 * @see #setContentInsetsRelative(int, int)
 * @see #setContentInsetsAbsolute(int, int)
 * @see #getContentInsetEnd()
 * @see #getContentInsetLeft()
 * @see #getContentInsetRight()
 * @attr ref android.R.styleable#Toolbar_contentInsetStart
 */
","/**
 * Gets the starting content inset for this toolbar.
 *
 * <p>The content inset affects the valid area for Toolbar content other than
 * the navigation button and menu. Insets define the minimum margin for these components
 * and can be used to effectively align Toolbar content along well-known gridlines.</p>
 *
 * @return The starting content inset for this toolbar
 *
 * @see #setContentInsetsRelative(int, int)
 * @see #setContentInsetsAbsolute(int, int)
 * @see #getContentInsetEnd()
 * @see #getContentInsetLeft()
 * @see #getContentInsetRight()
 * @attr ref android.R.styleable#Toolbar_contentInsetStart
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The return statement has been wrapped in a conditional expression to check if `mContentInsets` is non-null, and if it's null, it returns 0. This constitutes a return statement change (1) and an other statement change (4), due to the addition of the conditional check.","The change introduces a new return value (0) in case `mContentInsets` is null, which would result in a different behavior if `mContentInsets` is indeed null. Hence, a Compatibility Issue could arise due to the potential for different return values (1)."
94,<android.app.WallpaperManager: WallpaperInfo getWallpaperInfo()>,24,25,<android.app.WallpaperManager: WallpaperInfo getWallpaperInfo()>,<android.app.WallpaperManager: WallpaperInfo getWallpaperInfo()>,0,"{
    try {
        if (sGlobals.mService == null) {
            Log.w(TAG, ""WallpaperService not running"");
            throw new RuntimeException(new DeadSystemException());
        } else {
            return sGlobals.mService.getWallpaperInfo();
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        if (sGlobals.mService == null) {
            Log.w(TAG, ""WallpaperService not running"");
            throw new RuntimeException(new DeadSystemException());
        } else {
            return sGlobals.mService.getWallpaperInfo(UserHandle.myUserId());
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * If the current wallpaper is a live wallpaper component, return the
 * information about that wallpaper.  Otherwise, if it is a static image,
 * simply return null.
 */
","/**
 * If the current wallpaper is a live wallpaper component, return the
 * information about that wallpaper.  Otherwise, if it is a static image,
 * simply return null.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The change is in the invocation of sGlobals.mService.getWallpaperInfo(), where the late version is passing an additional parameter (UserHandle.myUserId()). This is neither a return statement nor an exception handling statement change, putting it under the class Other statement changed, also as a dependent API in the implementation has a parameter change, it falls under the Dependent API changed class, so the code change types are 4,5.","Assuming that UserHandle.myUserId() does not change the behavior of getWallpaperInfo() in a way that would cause it to return a different result or throw an exception under different conditions, i.e., if it only serves to specify the user for whom the wallpaper info is fetched and doesn't affect compatibility, then there is no Compatibility Issue. The change made doesn't inherently suggest that it would lead to a different return value or type or cause a different exception to be thrown, it's a refinement of which user's wallpaper info is fetched. If the underlying system correctly handles different user IDs for the same caller and the method's purpose is purely to fetch the corresponding user's wallpaper info, there shouldn't be a compatibility issue."
95,<android.view.accessibility.AccessibilityManager: void sendAccessibilityEvent(AccessibilityEvent)>,24,25,<android.view.accessibility.AccessibilityManager: void sendAccessibilityEvent(AccessibilityEvent)>,<android.view.accessibility.AccessibilityManager: void sendAccessibilityEvent(AccessibilityEvent)>,0,"{
    final IAccessibilityManager service;
    final int userId;
    synchronized (mLock) {
        service = getServiceLocked();
        if (service == null) {
            return;
        }
        if (!mIsEnabled) {
            throw new IllegalStateException(""Accessibility off. Did you forget to check that?"");
        }
        userId = mUserId;
    }
    boolean doRecycle = false;
    try {
        event.setEventTime(SystemClock.uptimeMillis());
        // it is possible that this manager is in the same process as the service but
        // client using it is called through Binder from another process. Example: MMS
        // app adds a SMS notification and the NotificationManagerService calls this method
        long identityToken = Binder.clearCallingIdentity();
        doRecycle = service.sendAccessibilityEvent(event, userId);
        Binder.restoreCallingIdentity(identityToken);
        if (DEBUG) {
            Log.i(LOG_TAG, event + "" sent"");
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error during sending "" + event + "" "", re);
    } finally {
        if (doRecycle) {
            event.recycle();
        }
    }
}","{
    final IAccessibilityManager service;
    final int userId;
    synchronized (mLock) {
        service = getServiceLocked();
        if (service == null) {
            return;
        }
        if (!mIsEnabled) {
            Looper myLooper = Looper.myLooper();
            if (myLooper == Looper.getMainLooper()) {
                throw new IllegalStateException(""Accessibility off. Did you forget to check that?"");
            } else {
                // If we're not running on the thread with the main looper, it's possible for
                // the state of accessibility to change between checking isEnabled and
                // calling this method. So just log the error rather than throwing the
                // exception.
                Log.e(LOG_TAG, ""AccessibilityEvent sent with accessibility disabled"");
                return;
            }
        }
        userId = mUserId;
    }
    boolean doRecycle = false;
    try {
        event.setEventTime(SystemClock.uptimeMillis());
        // it is possible that this manager is in the same process as the service but
        // client using it is called through Binder from another process. Example: MMS
        // app adds a SMS notification and the NotificationManagerService calls this method
        long identityToken = Binder.clearCallingIdentity();
        doRecycle = service.sendAccessibilityEvent(event, userId);
        Binder.restoreCallingIdentity(identityToken);
        if (DEBUG) {
            Log.i(LOG_TAG, event + "" sent"");
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error during sending "" + event + "" "", re);
    } finally {
        if (doRecycle) {
            event.recycle();
        }
    }
}",1,"/**
 * Sends an {@link AccessibilityEvent}.
 *
 * @param event The event to send.
 *
 * @throws IllegalStateException if accessibility is not enabled.
 *
 * <strong>Note:</strong> The preferred mechanism for sending custom accessibility
 * events is through calling
 * {@link android.view.ViewParent#requestSendAccessibilityEvent(View, AccessibilityEvent)}
 * instead of this method to allow predecessors to augment/filter events sent by
 * their descendants.
 */
","/**
 * Sends an {@link AccessibilityEvent}.
 *
 * @param event The event to send.
 *
 * @throws IllegalStateException if accessibility is not enabled.
 *
 * <strong>Note:</strong> The preferred mechanism for sending custom accessibility
 * events is through calling
 * {@link android.view.ViewParent#requestSendAccessibilityEvent(View, AccessibilityEvent)}
 * instead of this method to allow predecessors to augment/filter events sent by
 * their descendants.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"There is an addition of a conditional statement to check if the current looper is the main looper or not, and accordingly either throw an exception or log an error. There are no other changes in the control flow or execution path that would alter the behavior fundamentally. Therefore, the change type is 4.","Despite the change in exception handling logic for a non-main looper thread, compatibility is not affected because the exception is thrown in the same circumstances when the main looper is active. For other threads, instead of throwing an exception, which the previous version did not do either, it simply logs the error. Therefore, there is no CI as the API's behavior would not change in a way that affects existing clients. The existing CI rules are maintained for clients using the main looper."
96,"<android.nfc.NfcAdapter: void setOnNdefPushCompleteCallback(OnNdefPushCompleteCallback,Activity,Activity)>",24,25,"<android.nfc.NfcAdapter: void setOnNdefPushCompleteCallback(OnNdefPushCompleteCallback,Activity,Activity)>","<android.nfc.NfcAdapter: void setOnNdefPushCompleteCallback(OnNdefPushCompleteCallback,Activity,Activity)>",0,"{
    int targetSdkVersion = getSdkVersion();
    try {
        if (activity == null) {
            throw new NullPointerException(""activity cannot be null"");
        }
        mNfcActivityManager.setOnNdefPushCompleteCallback(activity, callback);
        for (Activity a : activities) {
            if (a == null) {
                throw new NullPointerException(""activities cannot contain null"");
            }
            mNfcActivityManager.setOnNdefPushCompleteCallback(a, callback);
        }
    } catch (IllegalStateException e) {
        if (targetSdkVersion < android.os.Build.VERSION_CODES.JELLY_BEAN) {
            // Less strict on old applications - just log the error
            Log.e(TAG, ""Cannot call API with Activity that has already "" + ""been destroyed"", e);
        } else {
            // Prevent new applications from making this mistake, re-throw
            throw (e);
        }
    }
}","{
    synchronized (NfcAdapter.class) {
        if (!sHasNfcFeature) {
            throw new UnsupportedOperationException();
        }
    }
    int targetSdkVersion = getSdkVersion();
    try {
        if (activity == null) {
            throw new NullPointerException(""activity cannot be null"");
        }
        mNfcActivityManager.setOnNdefPushCompleteCallback(activity, callback);
        for (Activity a : activities) {
            if (a == null) {
                throw new NullPointerException(""activities cannot contain null"");
            }
            mNfcActivityManager.setOnNdefPushCompleteCallback(a, callback);
        }
    } catch (IllegalStateException e) {
        if (targetSdkVersion < android.os.Build.VERSION_CODES.JELLY_BEAN) {
            // Less strict on old applications - just log the error
            Log.e(TAG, ""Cannot call API with Activity that has already "" + ""been destroyed"", e);
        } else {
            // Prevent new applications from making this mistake, re-throw
            throw (e);
        }
    }
}",1,"/**
 * Set a callback on successful Android Beam (TM).
 *
 * <p>This method may be called at any time before {@link Activity#onDestroy},
 * but the callback can only occur when the
 * specified activity(s) are in resumed (foreground) state. The recommended
 * approach is to call this method during your Activity's
 * {@link Activity#onCreate} - see sample
 * code below. This method does not immediately perform any I/O or blocking work,
 * so is safe to call on your main thread.
 *
 * <p>The API allows for multiple activities to be specified at a time,
 * but it is strongly recommended to just register one at a time,
 * and to do so during the activity's {@link Activity#onCreate}. For example:
 * <pre>
 * protected void onCreate(Bundle savedInstanceState) {
 * super.onCreate(savedInstanceState);
 * NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
 * if (nfcAdapter == null) return;  // NFC not available on this device
 * nfcAdapter.setOnNdefPushCompleteCallback(callback, this);
 * }</pre>
 * And that is it. Only one call per activity is necessary. The Android
 * OS will automatically release its references to the callback and the
 * Activity object when it is destroyed if you follow this pattern.
 *
 * <p class=""note"">Do not pass in an Activity that has already been through
 * {@link Activity#onDestroy}. This is guaranteed if you call this API
 * during {@link Activity#onCreate}.
 *
 * <p class=""note"">Requires the {@link android.Manifest.permission#NFC} permission.
 *
 * @param callback callback, or null to disable
 * @param activity activity for which the NDEF message will be pushed
 * @param activities optional additional activities, however we strongly recommend
 * to only register one at a time, and to do so in that activity's
 * {@link Activity#onCreate}
 */
","/**
 * Set a callback on successful Android Beam (TM).
 *
 * <p>This method may be called at any time before {@link Activity#onDestroy},
 * but the callback can only occur when the
 * specified activity(s) are in resumed (foreground) state. The recommended
 * approach is to call this method during your Activity's
 * {@link Activity#onCreate} - see sample
 * code below. This method does not immediately perform any I/O or blocking work,
 * so is safe to call on your main thread.
 *
 * <p>The API allows for multiple activities to be specified at a time,
 * but it is strongly recommended to just register one at a time,
 * and to do so during the activity's {@link Activity#onCreate}. For example:
 * <pre>
 * protected void onCreate(Bundle savedInstanceState) {
 * super.onCreate(savedInstanceState);
 * NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
 * if (nfcAdapter == null) return;  // NFC not available on this device
 * nfcAdapter.setOnNdefPushCompleteCallback(callback, this);
 * }</pre>
 * And that is it. Only one call per activity is necessary. The Android
 * OS will automatically release its references to the callback and the
 * Activity object when it is destroyed if you follow this pattern.
 *
 * <p class=""note"">Do not pass in an Activity that has already been through
 * {@link Activity#onDestroy}. This is guaranteed if you call this API
 * during {@link Activity#onCreate}.
 *
 * <p class=""note"">Requires the {@link android.Manifest.permission#NFC} permission.
 *
 * @param callback callback, or null to disable
 * @param activity activity for which the NDEF message will be pushed
 * @param activities optional additional activities, however we strongly recommend
 * to only register one at a time, and to do so in that activity's
 * {@link Activity#onCreate}
 * @throws UnsupportedOperationException if FEATURE_NFC is unavailable.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,A new code block that checks for NFC feature support by throwing an exception was added at the beginning of the method. This is a code change type 4.,"There is no Compatibility Issue arising from the code addition because it imposes a new precondition check which does not affect the return value or exception handling of any existing calls that would have succeeded before the change. If the device does not have NFC support, the method will fail in both the early and the late version, albeit with possibly different exception types (UnsupportedOperationException in the late version, other internal errors in the early version). This does not constitute a behavior change related to the API's purpose and usage; it's merely a more explicit early failure for a precondition that was always in place."
97,"<android.hardware.camera2.impl.CameraDeviceImpl: boolean configureStreamsChecked(InputConfiguration,List<OutputConfiguration>,boolean)>",24,25,"<android.hardware.camera2.impl.CameraDeviceImpl: boolean configureStreamsChecked(InputConfiguration,List<OutputConfiguration>,boolean)>","<android.hardware.camera2.impl.CameraDeviceImpl: boolean configureStreamsChecked(InputConfiguration,List<OutputConfiguration>,boolean)>",0,"{
    // Treat a null input the same an empty list
    if (outputs == null) {
        outputs = new ArrayList<OutputConfiguration>();
    }
    if (outputs.size() == 0 && inputConfig != null) {
        throw new IllegalArgumentException(""cannot configure an input stream without "" + ""any output streams"");
    }
    checkInputConfiguration(inputConfig);
    boolean success = false;
    synchronized (mInterfaceLock) {
        checkIfCameraClosedOrInError();
        // Streams to create
        HashSet<OutputConfiguration> addSet = new HashSet<OutputConfiguration>(outputs);
        // Streams to delete
        List<Integer> deleteList = new ArrayList<Integer>();
        // Determine which streams need to be created, which to be deleted
        for (int i = 0; i < mConfiguredOutputs.size(); ++i) {
            int streamId = mConfiguredOutputs.keyAt(i);
            OutputConfiguration outConfig = mConfiguredOutputs.valueAt(i);
            if (!outputs.contains(outConfig)) {
                deleteList.add(streamId);
            } else {
                // Don't create a stream previously created
                addSet.remove(outConfig);
            }
        }
        mDeviceHandler.post(mCallOnBusy);
        stopRepeating();
        try {
            waitUntilIdle();
            mRemoteDevice.beginConfigure();
            // reconfigure the input stream if the input configuration is different.
            InputConfiguration currentInputConfig = mConfiguredInput.getValue();
            if (inputConfig != currentInputConfig && (inputConfig == null || !inputConfig.equals(currentInputConfig))) {
                if (currentInputConfig != null) {
                    mRemoteDevice.deleteStream(mConfiguredInput.getKey());
                    mConfiguredInput = new SimpleEntry<Integer, InputConfiguration>(REQUEST_ID_NONE, null);
                }
                if (inputConfig != null) {
                    int streamId = mRemoteDevice.createInputStream(inputConfig.getWidth(), inputConfig.getHeight(), inputConfig.getFormat());
                    mConfiguredInput = new SimpleEntry<Integer, InputConfiguration>(streamId, inputConfig);
                }
            }
            // Delete all streams first (to free up HW resources)
            for (Integer streamId : deleteList) {
                mRemoteDevice.deleteStream(streamId);
                mConfiguredOutputs.delete(streamId);
            }
            // Add all new streams
            for (OutputConfiguration outConfig : outputs) {
                if (addSet.contains(outConfig)) {
                    int streamId = mRemoteDevice.createStream(outConfig);
                    mConfiguredOutputs.put(streamId, outConfig);
                }
            }
            mRemoteDevice.endConfigure(isConstrainedHighSpeed);
            success = true;
        } catch (IllegalArgumentException e) {
            // OK. camera service can reject stream config if it's not supported by HAL
            // This is only the result of a programmer misusing the camera2 api.
            Log.w(TAG, ""Stream configuration failed due to: "" + e.getMessage());
            return false;
        } catch (CameraAccessException e) {
            if (e.getReason() == CameraAccessException.CAMERA_IN_USE) {
                throw new IllegalStateException(""The camera is currently busy."" + "" You must wait until the previous operation completes."", e);
            }
            throw e;
        } finally {
            if (success && outputs.size() > 0) {
                mDeviceHandler.post(mCallOnIdle);
            } else {
                // Always return to the 'unconfigured' state if we didn't hit a fatal error
                mDeviceHandler.post(mCallOnUnconfigured);
            }
        }
    }
    return success;
}","{
    // Treat a null input the same an empty list
    if (outputs == null) {
        outputs = new ArrayList<OutputConfiguration>();
    }
    if (outputs.size() == 0 && inputConfig != null) {
        throw new IllegalArgumentException(""cannot configure an input stream without "" + ""any output streams"");
    }
    checkInputConfiguration(inputConfig);
    boolean success = false;
    synchronized (mInterfaceLock) {
        checkIfCameraClosedOrInError();
        // Streams to create
        HashSet<OutputConfiguration> addSet = new HashSet<OutputConfiguration>(outputs);
        // Streams to delete
        List<Integer> deleteList = new ArrayList<Integer>();
        // Determine which streams need to be created, which to be deleted
        for (int i = 0; i < mConfiguredOutputs.size(); ++i) {
            int streamId = mConfiguredOutputs.keyAt(i);
            OutputConfiguration outConfig = mConfiguredOutputs.valueAt(i);
            if (!outputs.contains(outConfig) || outConfig.isDeferredConfiguration()) {
                // Always delete the deferred output configuration when the session
                // is created, as the deferred output configuration doesn't have unique surface
                // related identifies.
                deleteList.add(streamId);
            } else {
                // Don't create a stream previously created
                addSet.remove(outConfig);
            }
        }
        mDeviceHandler.post(mCallOnBusy);
        stopRepeating();
        try {
            waitUntilIdle();
            mRemoteDevice.beginConfigure();
            // reconfigure the input stream if the input configuration is different.
            InputConfiguration currentInputConfig = mConfiguredInput.getValue();
            if (inputConfig != currentInputConfig && (inputConfig == null || !inputConfig.equals(currentInputConfig))) {
                if (currentInputConfig != null) {
                    mRemoteDevice.deleteStream(mConfiguredInput.getKey());
                    mConfiguredInput = new SimpleEntry<Integer, InputConfiguration>(REQUEST_ID_NONE, null);
                }
                if (inputConfig != null) {
                    int streamId = mRemoteDevice.createInputStream(inputConfig.getWidth(), inputConfig.getHeight(), inputConfig.getFormat());
                    mConfiguredInput = new SimpleEntry<Integer, InputConfiguration>(streamId, inputConfig);
                }
            }
            // Delete all streams first (to free up HW resources)
            for (Integer streamId : deleteList) {
                mRemoteDevice.deleteStream(streamId);
                mConfiguredOutputs.delete(streamId);
            }
            // Add all new streams
            for (OutputConfiguration outConfig : outputs) {
                if (addSet.contains(outConfig)) {
                    int streamId = mRemoteDevice.createStream(outConfig);
                    mConfiguredOutputs.put(streamId, outConfig);
                }
            }
            mRemoteDevice.endConfigure(isConstrainedHighSpeed);
            success = true;
        } catch (IllegalArgumentException e) {
            // OK. camera service can reject stream config if it's not supported by HAL
            // This is only the result of a programmer misusing the camera2 api.
            Log.w(TAG, ""Stream configuration failed due to: "" + e.getMessage());
            return false;
        } catch (CameraAccessException e) {
            if (e.getReason() == CameraAccessException.CAMERA_IN_USE) {
                throw new IllegalStateException(""The camera is currently busy."" + "" You must wait until the previous operation completes."", e);
            }
            throw e;
        } finally {
            if (success && outputs.size() > 0) {
                mDeviceHandler.post(mCallOnIdle);
            } else {
                // Always return to the 'unconfigured' state if we didn't hit a fatal error
                mDeviceHandler.post(mCallOnUnconfigured);
            }
        }
    }
    return success;
}",1,"/**
 * Attempt to configure the input and outputs; the device goes to idle and then configures the
 * new input and outputs if possible.
 *
 * <p>The configuration may gracefully fail, if input configuration is not supported,
 * if there are too many outputs, if the formats are not supported, or if the sizes for that
 * format is not supported. In this case this function will return {@code false} and the
 * unconfigured callback will be fired.</p>
 *
 * <p>If the configuration succeeds (with 1 or more outputs with or without an input),
 * then the idle callback is fired. Unconfiguring the device always fires the idle callback.</p>
 *
 * @param inputConfig input configuration or {@code null} for no input
 * @param outputs a list of one or more surfaces, or {@code null} to unconfigure
 * @param isConstrainedHighSpeed If the streams configuration is for constrained high speed output.
 * @return whether or not the configuration was successful
 *
 * @throws CameraAccessException if there were any unexpected problems during configuration
 */
","/**
 * Attempt to configure the input and outputs; the device goes to idle and then configures the
 * new input and outputs if possible.
 *
 * <p>The configuration may gracefully fail, if input configuration is not supported,
 * if there are too many outputs, if the formats are not supported, or if the sizes for that
 * format is not supported. In this case this function will return {@code false} and the
 * unconfigured callback will be fired.</p>
 *
 * <p>If the configuration succeeds (with 1 or more outputs with or without an input),
 * then the idle callback is fired. Unconfiguring the device always fires the idle callback.</p>
 *
 * @param inputConfig input configuration or {@code null} for no input
 * @param outputs a list of one or more surfaces, or {@code null} to unconfigure
 * @param isConstrainedHighSpeed If the streams configuration is for constrained high speed output.
 * @return whether or not the configuration was successful
 *
 * @throws CameraAccessException if there were any unexpected problems during configuration
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
101,"<android.nfc.NfcAdapter: void setNdefPushMessage(NdefMessage,Activity,Activity)>",24,25,"<android.nfc.NfcAdapter: void setNdefPushMessage(NdefMessage,Activity,Activity)>","<android.nfc.NfcAdapter: void setNdefPushMessage(NdefMessage,Activity,Activity)>",0,"{
    int targetSdkVersion = getSdkVersion();
    try {
        if (activity == null) {
            throw new NullPointerException(""activity cannot be null"");
        }
        mNfcActivityManager.setNdefPushMessage(activity, message, 0);
        for (Activity a : activities) {
            if (a == null) {
                throw new NullPointerException(""activities cannot contain null"");
            }
            mNfcActivityManager.setNdefPushMessage(a, message, 0);
        }
    } catch (IllegalStateException e) {
        if (targetSdkVersion < android.os.Build.VERSION_CODES.JELLY_BEAN) {
            // Less strict on old applications - just log the error
            Log.e(TAG, ""Cannot call API with Activity that has already "" + ""been destroyed"", e);
        } else {
            // Prevent new applications from making this mistake, re-throw
            throw (e);
        }
    }
}","{
    synchronized (NfcAdapter.class) {
        if (!sHasNfcFeature) {
            throw new UnsupportedOperationException();
        }
    }
    int targetSdkVersion = getSdkVersion();
    try {
        if (activity == null) {
            throw new NullPointerException(""activity cannot be null"");
        }
        mNfcActivityManager.setNdefPushMessage(activity, message, 0);
        for (Activity a : activities) {
            if (a == null) {
                throw new NullPointerException(""activities cannot contain null"");
            }
            mNfcActivityManager.setNdefPushMessage(a, message, 0);
        }
    } catch (IllegalStateException e) {
        if (targetSdkVersion < android.os.Build.VERSION_CODES.JELLY_BEAN) {
            // Less strict on old applications - just log the error
            Log.e(TAG, ""Cannot call API with Activity that has already "" + ""been destroyed"", e);
        } else {
            // Prevent new applications from making this mistake, re-throw
            throw (e);
        }
    }
}",1,"/**
 * Set a static {@link NdefMessage} to send using Android Beam (TM).
 *
 * <p>This method may be called at any time before {@link Activity#onDestroy},
 * but the NDEF message is only made available for NDEF push when the
 * specified activity(s) are in resumed (foreground) state. The recommended
 * approach is to call this method during your Activity's
 * {@link Activity#onCreate} - see sample
 * code below. This method does not immediately perform any I/O or blocking work,
 * so is safe to call on your main thread.
 *
 * <p>Only one NDEF message can be pushed by the currently resumed activity.
 * If both {@link #setNdefPushMessage} and
 * {@link #setNdefPushMessageCallback} are set, then
 * the callback will take priority.
 *
 * <p>If neither {@link #setNdefPushMessage} or
 * {@link #setNdefPushMessageCallback} have been called for your activity, then
 * the Android OS may choose to send a default NDEF message on your behalf,
 * such as a URI for your application.
 *
 * <p>If {@link #setNdefPushMessage} is called with a null NDEF message,
 * and/or {@link #setNdefPushMessageCallback} is called with a null callback,
 * then NDEF push will be completely disabled for the specified activity(s).
 * This also disables any default NDEF message the Android OS would have
 * otherwise sent on your behalf for those activity(s).
 *
 * <p>If you want to prevent the Android OS from sending default NDEF
 * messages completely (for all activities), you can include a
 * {@code <meta-data>} element inside the {@code <application>}
 * element of your AndroidManifest.xml file, like this:
 * <pre>
 * &lt;application ...>
 * &lt;meta-data android:name=""android.nfc.disable_beam_default""
 * android:value=""true"" />
 * &lt;/application></pre>
 *
 * <p>The API allows for multiple activities to be specified at a time,
 * but it is strongly recommended to just register one at a time,
 * and to do so during the activity's {@link Activity#onCreate}. For example:
 * <pre>
 * protected void onCreate(Bundle savedInstanceState) {
 * super.onCreate(savedInstanceState);
 * NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
 * if (nfcAdapter == null) return;  // NFC not available on this device
 * nfcAdapter.setNdefPushMessage(ndefMessage, this);
 * }</pre>
 * And that is it. Only one call per activity is necessary. The Android
 * OS will automatically release its references to the NDEF message and the
 * Activity object when it is destroyed if you follow this pattern.
 *
 * <p>If your Activity wants to dynamically generate an NDEF message,
 * then set a callback using {@link #setNdefPushMessageCallback} instead
 * of a static message.
 *
 * <p class=""note"">Do not pass in an Activity that has already been through
 * {@link Activity#onDestroy}. This is guaranteed if you call this API
 * during {@link Activity#onCreate}.
 *
 * <p class=""note"">For sending large content such as pictures and songs,
 * consider using {@link #setBeamPushUris}, which switches to alternate transports
 * such as Bluetooth to achieve a fast transfer rate.
 *
 * <p class=""note"">Requires the {@link android.Manifest.permission#NFC} permission.
 *
 * @param message NDEF message to push over NFC, or null to disable
 * @param activity activity for which the NDEF message will be pushed
 * @param activities optional additional activities, however we strongly recommend
 * to only register one at a time, and to do so in that activity's
 * {@link Activity#onCreate}
 */
","/**
 * Set a static {@link NdefMessage} to send using Android Beam (TM).
 *
 * <p>This method may be called at any time before {@link Activity#onDestroy},
 * but the NDEF message is only made available for NDEF push when the
 * specified activity(s) are in resumed (foreground) state. The recommended
 * approach is to call this method during your Activity's
 * {@link Activity#onCreate} - see sample
 * code below. This method does not immediately perform any I/O or blocking work,
 * so is safe to call on your main thread.
 *
 * <p>Only one NDEF message can be pushed by the currently resumed activity.
 * If both {@link #setNdefPushMessage} and
 * {@link #setNdefPushMessageCallback} are set, then
 * the callback will take priority.
 *
 * <p>If neither {@link #setNdefPushMessage} or
 * {@link #setNdefPushMessageCallback} have been called for your activity, then
 * the Android OS may choose to send a default NDEF message on your behalf,
 * such as a URI for your application.
 *
 * <p>If {@link #setNdefPushMessage} is called with a null NDEF message,
 * and/or {@link #setNdefPushMessageCallback} is called with a null callback,
 * then NDEF push will be completely disabled for the specified activity(s).
 * This also disables any default NDEF message the Android OS would have
 * otherwise sent on your behalf for those activity(s).
 *
 * <p>If you want to prevent the Android OS from sending default NDEF
 * messages completely (for all activities), you can include a
 * {@code <meta-data>} element inside the {@code <application>}
 * element of your AndroidManifest.xml file, like this:
 * <pre>
 * &lt;application ...>
 * &lt;meta-data android:name=""android.nfc.disable_beam_default""
 * android:value=""true"" />
 * &lt;/application></pre>
 *
 * <p>The API allows for multiple activities to be specified at a time,
 * but it is strongly recommended to just register one at a time,
 * and to do so during the activity's {@link Activity#onCreate}. For example:
 * <pre>
 * protected void onCreate(Bundle savedInstanceState) {
 * super.onCreate(savedInstanceState);
 * NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
 * if (nfcAdapter == null) return;  // NFC not available on this device
 * nfcAdapter.setNdefPushMessage(ndefMessage, this);
 * }</pre>
 * And that is it. Only one call per activity is necessary. The Android
 * OS will automatically release its references to the NDEF message and the
 * Activity object when it is destroyed if you follow this pattern.
 *
 * <p>If your Activity wants to dynamically generate an NDEF message,
 * then set a callback using {@link #setNdefPushMessageCallback} instead
 * of a static message.
 *
 * <p class=""note"">Do not pass in an Activity that has already been through
 * {@link Activity#onDestroy}. This is guaranteed if you call this API
 * during {@link Activity#onCreate}.
 *
 * <p class=""note"">For sending large content such as pictures and songs,
 * consider using {@link #setBeamPushUris}, which switches to alternate transports
 * such as Bluetooth to achieve a fast transfer rate.
 *
 * <p class=""note"">Requires the {@link android.Manifest.permission#NFC} permission.
 *
 * @param message NDEF message to push over NFC, or null to disable
 * @param activity activity for which the NDEF message will be pushed
 * @param activities optional additional activities, however we strongly recommend
 * to only register one at a time, and to do so in that activity's
 * {@link Activity#onCreate}
 * @throws UnsupportedOperationException if FEATURE_NFC is unavailable.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,4",2,"The new code introduces a synchronized block and a new exception (throw new UnsupportedOperationException()), and the exception is thrown under a new condition not present in the early version. Also, the exception handling logic inside the try-catch block remains the same, but due to the new synchronized block and additional UnsupportedOperationException, this results in other code changes and control dependency changes—types 2, 3, and 4.","The introduction of a new exception (UnsupportedOperationException) within a synchronized block potentially causes the late version API to throw a different exception that the early version would not have thrown. Furthermore, this exception occurs before the pre-existing logic, which could preempt the IllegalStateException handling. Hence, this introduces a potential behavior change, making the CI type 2."
102,"<android.app.LoadedApk.ServiceDispatcher: void doDeath(ComponentName,IBinder)>",24,25,"<android.app.LoadedApk.ServiceDispatcher: void doDeath(ComponentName,IBinder)>","<android.app.LoadedApk.ServiceDispatcher: void doDeath(ComponentName,IBinder)>",0,"{
    mConnection.onServiceDisconnected(name);
}","{
    synchronized (this) {
        ConnectionInfo old = mActiveConnections.get(name);
        if (old == null || old.binder != service) {
            // reported...  just ignore it.
            return;
        }
        mActiveConnections.remove(name);
        old.binder.unlinkToDeath(old.deathMonitor, 0);
    }
    mConnection.onServiceDisconnected(name);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"There have been new method calls and a synchronized block added to the implementation, so the code change type is 3 for the control dependency change introduced by the synchronized block, and 4 for the other statement changes (e.g., interaction with mActiveConnections and unlinkToDeath).","There is no compatibility issue caused by these changes. The new code adds checks and manages the state of the service connections, but it doesn't affect how the method behaves from an external point of view; it still ultimately triggers the onServiceDisconnected callback. The additional logic is for internal bookkeeping that doesn't manifest as a difference in external behavior."
103,<android.service.quicksettings.TileService: void startActivityAndCollapse(Intent)>,24,25,<android.service.quicksettings.TileService: void startActivityAndCollapse(Intent)>,<android.service.quicksettings.TileService: void startActivityAndCollapse(Intent)>,0,"{
    startActivity(intent);
    try {
        mService.onStartActivity(mTile);
    } catch (RemoteException e) {
    }
}","{
    startActivity(intent);
    try {
        mService.onStartActivity(mTileToken);
    } catch (RemoteException e) {
    }
}",1,"/**
 * Start an activity while collapsing the panel.
 */
","/**
 * Start an activity while collapsing the panel.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method argument used within the try block has been changed from mTile to mTileToken; this signifies a change in the dependent API variable being used, so the code change type is 5.","Despite the change in the variable passed to the mService.onStartActivity() method, there's no indication this modification would lead to a change in behavior that corresponds to a different return value or exception handling since the method's signature remains the same and the surrounding code has not changed. Therefore, there's no compatibility issue detected, corresponding to type 0."
105,<android.view.SurfaceControl.PhysicalDisplayInfo: String toString()>,24,25,<android.view.SurfaceControl.PhysicalDisplayInfo: String toString()>,<android.view.SurfaceControl.PhysicalDisplayInfo: String toString()>,0,"{
    return ""PhysicalDisplayInfo{"" + width + "" x "" + height + "", "" + refreshRate + "" fps, "" + ""density "" + density + "", "" + xDpi + "" x "" + yDpi + "" dpi, secure "" + secure + "", appVsyncOffset "" + appVsyncOffsetNanos + "", bufferDeadline "" + presentationDeadlineNanos + "", colorTransform "" + colorTransform + ""}"";
}","{
    return ""PhysicalDisplayInfo{"" + width + "" x "" + height + "", "" + refreshRate + "" fps, "" + ""density "" + density + "", "" + xDpi + "" x "" + yDpi + "" dpi, secure "" + secure + "", appVsyncOffset "" + appVsyncOffsetNanos + "", bufferDeadline "" + presentationDeadlineNanos + ""}"";
}",1,"// For debugging purposes
","// For debugging purposes
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"The return statement has changed with the removal of "", colorTransform "" + colorTransform from the returned String, therefore the return statement changed, which is type 1.","Since the return statement is modified and the change in the string concatenation omits a piece of information from the result, the API potentially returns a different value. Thus, the CI type is 1."
106,<android.animation.ObjectAnimator: void animateValue(float)>,24,25,<android.animation.ObjectAnimator: void animateValue(float)>,<android.animation.ObjectAnimator: void animateValue(float)>,0,"{
    final Object target = getTarget();
    if (mTarget != null && target == null) {
        // We lost the target reference, cancel and clean up.
        cancel();
        return;
    }
    super.animateValue(fraction);
    int numValues = mValues.length;
    for (int i = 0; i < numValues; ++i) {
        mValues[i].setAnimatedValue(target);
    }
}","{
    final Object target = getTarget();
    if (target == null) {
        // We lost the target reference, cancel and clean up.
        cancel();
        return;
    }
    super.animateValue(fraction);
    int numValues = mValues.length;
    for (int i = 0; i < numValues; ++i) {
        mValues[i].setAnimatedValue(target);
    }
}",1,"/**
 * This method is called with the elapsed fraction of the animation during every
 * animation frame. This function turns the elapsed fraction into an interpolated fraction
 * and then into an animated value (from the evaluator. The function is called mostly during
 * animation updates, but it is also called when the <code>end()</code>
 * function is called, to set the final value on the property.
 *
 * <p>Overrides of this method must call the superclass to perform the calculation
 * of the animated value.</p>
 *
 * @param fraction The elapsed fraction of the animation.
 */
","/**
 * This method is called with the elapsed fraction of the animation during every
 * animation frame. This function turns the elapsed fraction into an interpolated fraction
 * and then into an animated value (from the evaluator. The function is called mostly during
 * animation updates, but it is also called when the <code>end()</code>
 * function is called, to set the final value on the property.
 *
 * <p>Overrides of this method must call the superclass to perform the calculation
 * of the animated value.</p>
 *
 * @param fraction The elapsed fraction of the animation.
 */
",-1,"[@CallSuper, @Override]","[@CallSuper, @Override]",-1,-1,-1,-1,-1,-1,3,0,"The condition in the if statement has changed from checking both `mTarget` and `target` to only checking `target`. It simplifies the condition, but it does not affect the behavior of the API as the subsequent behavior remains the same. There has been a control dependency change, so the code change type is 3.","There is no Compatibility Issue since the change in the condition will not lead to a different behavior from the perspective of the API consumer. If the target is null, the `cancel()` method will be called and the method will return early in both versions. The check on `mTarget` was redundant because the value of `mTarget` was never used before the condition was checked. Therefore, the removal of `mTarget != null` has no impact on the execution or the outcome. The CI type is 0."
108,"<android.nfc.NfcAdapter: void setBeamPushUris(Uri[],Activity)>",24,25,"<android.nfc.NfcAdapter: void setBeamPushUris(Uri[],Activity)>","<android.nfc.NfcAdapter: void setBeamPushUris(Uri[],Activity)>",0,"{
    if (activity == null) {
        throw new NullPointerException(""activity cannot be null"");
    }
    if (uris != null) {
        for (Uri uri : uris) {
            if (uri == null)
                throw new NullPointerException(""Uri not "" + ""allowed to be null"");
            String scheme = uri.getScheme();
            if (scheme == null || (!scheme.equalsIgnoreCase(""file"") && !scheme.equalsIgnoreCase(""content""))) {
                throw new IllegalArgumentException(""URI needs to have "" + ""either scheme file or scheme content"");
            }
        }
    }
    mNfcActivityManager.setNdefPushContentUri(activity, uris);
}","{
    synchronized (NfcAdapter.class) {
        if (!sHasNfcFeature) {
            throw new UnsupportedOperationException();
        }
    }
    if (activity == null) {
        throw new NullPointerException(""activity cannot be null"");
    }
    if (uris != null) {
        for (Uri uri : uris) {
            if (uri == null)
                throw new NullPointerException(""Uri not "" + ""allowed to be null"");
            String scheme = uri.getScheme();
            if (scheme == null || (!scheme.equalsIgnoreCase(""file"") && !scheme.equalsIgnoreCase(""content""))) {
                throw new IllegalArgumentException(""URI needs to have "" + ""either scheme file or scheme content"");
            }
        }
    }
    mNfcActivityManager.setNdefPushContentUri(activity, uris);
}",1,"/**
 * Set one or more {@link Uri}s to send using Android Beam (TM). Every
 * Uri you provide must have either scheme 'file' or scheme 'content'.
 *
 * <p>For the data provided through this method, Android Beam tries to
 * switch to alternate transports such as Bluetooth to achieve a fast
 * transfer speed. Hence this method is very suitable
 * for transferring large files such as pictures or songs.
 *
 * <p>The receiving side will store the content of each Uri in
 * a file and present a notification to the user to open the file
 * with a {@link android.content.Intent} with action
 * {@link android.content.Intent#ACTION_VIEW}.
 * If multiple URIs are sent, the {@link android.content.Intent} will refer
 * to the first of the stored files.
 *
 * <p>This method may be called at any time before {@link Activity#onDestroy},
 * but the URI(s) are only made available for Android Beam when the
 * specified activity(s) are in resumed (foreground) state. The recommended
 * approach is to call this method during your Activity's
 * {@link Activity#onCreate} - see sample
 * code below. This method does not immediately perform any I/O or blocking work,
 * so is safe to call on your main thread.
 *
 * <p>{@link #setBeamPushUris} and {@link #setBeamPushUrisCallback}
 * have priority over both {@link #setNdefPushMessage} and
 * {@link #setNdefPushMessageCallback}.
 *
 * <p>If {@link #setBeamPushUris} is called with a null Uri array,
 * and/or {@link #setBeamPushUrisCallback} is called with a null callback,
 * then the Uri push will be completely disabled for the specified activity(s).
 *
 * <p>Code example:
 * <pre>
 * protected void onCreate(Bundle savedInstanceState) {
 * super.onCreate(savedInstanceState);
 * NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
 * if (nfcAdapter == null) return;  // NFC not available on this device
 * nfcAdapter.setBeamPushUris(new Uri[] {uri1, uri2}, this);
 * }</pre>
 * And that is it. Only one call per activity is necessary. The Android
 * OS will automatically release its references to the Uri(s) and the
 * Activity object when it is destroyed if you follow this pattern.
 *
 * <p>If your Activity wants to dynamically supply Uri(s),
 * then set a callback using {@link #setBeamPushUrisCallback} instead
 * of using this method.
 *
 * <p class=""note"">Do not pass in an Activity that has already been through
 * {@link Activity#onDestroy}. This is guaranteed if you call this API
 * during {@link Activity#onCreate}.
 *
 * <p class=""note"">If this device does not support alternate transports
 * such as Bluetooth or WiFI, calling this method does nothing.
 *
 * <p class=""note"">Requires the {@link android.Manifest.permission#NFC} permission.
 *
 * @param uris an array of Uri(s) to push over Android Beam
 * @param activity activity for which the Uri(s) will be pushed
 */
","/**
 * Set one or more {@link Uri}s to send using Android Beam (TM). Every
 * Uri you provide must have either scheme 'file' or scheme 'content'.
 *
 * <p>For the data provided through this method, Android Beam tries to
 * switch to alternate transports such as Bluetooth to achieve a fast
 * transfer speed. Hence this method is very suitable
 * for transferring large files such as pictures or songs.
 *
 * <p>The receiving side will store the content of each Uri in
 * a file and present a notification to the user to open the file
 * with a {@link android.content.Intent} with action
 * {@link android.content.Intent#ACTION_VIEW}.
 * If multiple URIs are sent, the {@link android.content.Intent} will refer
 * to the first of the stored files.
 *
 * <p>This method may be called at any time before {@link Activity#onDestroy},
 * but the URI(s) are only made available for Android Beam when the
 * specified activity(s) are in resumed (foreground) state. The recommended
 * approach is to call this method during your Activity's
 * {@link Activity#onCreate} - see sample
 * code below. This method does not immediately perform any I/O or blocking work,
 * so is safe to call on your main thread.
 *
 * <p>{@link #setBeamPushUris} and {@link #setBeamPushUrisCallback}
 * have priority over both {@link #setNdefPushMessage} and
 * {@link #setNdefPushMessageCallback}.
 *
 * <p>If {@link #setBeamPushUris} is called with a null Uri array,
 * and/or {@link #setBeamPushUrisCallback} is called with a null callback,
 * then the Uri push will be completely disabled for the specified activity(s).
 *
 * <p>Code example:
 * <pre>
 * protected void onCreate(Bundle savedInstanceState) {
 * super.onCreate(savedInstanceState);
 * NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
 * if (nfcAdapter == null) return;  // NFC not available on this device
 * nfcAdapter.setBeamPushUris(new Uri[] {uri1, uri2}, this);
 * }</pre>
 * And that is it. Only one call per activity is necessary. The Android
 * OS will automatically release its references to the Uri(s) and the
 * Activity object when it is destroyed if you follow this pattern.
 *
 * <p>If your Activity wants to dynamically supply Uri(s),
 * then set a callback using {@link #setBeamPushUrisCallback} instead
 * of using this method.
 *
 * <p class=""note"">Do not pass in an Activity that has already been through
 * {@link Activity#onDestroy}. This is guaranteed if you call this API
 * during {@link Activity#onCreate}.
 *
 * <p class=""note"">If this device does not support alternate transports
 * such as Bluetooth or WiFI, calling this method does nothing.
 *
 * <p class=""note"">Requires the {@link android.Manifest.permission#NFC} permission.
 *
 * @param uris an array of Uri(s) to push over Android Beam
 * @param activity activity for which the Uri(s) will be pushed
 * @throws UnsupportedOperationException if FEATURE_NFC is unavailable.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"There is an introduction of a new control dependency 'synchronized (NfcAdapter.class)' that checks a static field 'sHasNfcFeature' and throws an exception if it is not true. This is a control dependency change, and since it introduces a new exception that may be thrown, it is also an exception handling statement change, so the code change types are 2,3.","Given the newly added block that can potentially throw a new type of exception (UnsupportedOperationException), there is a change regarding exception handling. Therefore, there could be a Compatibility Issue caused by potential different exception handling, and the CI type is 2."
109,<android.nfc.NfcAdapter: void disableForegroundDispatch(Activity)>,24,25,<android.nfc.NfcAdapter: void disableForegroundDispatch(Activity)>,<android.nfc.NfcAdapter: void disableForegroundDispatch(Activity)>,0,"{
    ActivityThread.currentActivityThread().unregisterOnActivityPausedListener(activity, mForegroundDispatchListener);
    disableForegroundDispatchInternal(activity, false);
}","{
    synchronized (NfcAdapter.class) {
        if (!sHasNfcFeature) {
            throw new UnsupportedOperationException();
        }
    }
    ActivityThread.currentActivityThread().unregisterOnActivityPausedListener(activity, mForegroundDispatchListener);
    disableForegroundDispatchInternal(activity, false);
}",1,"/**
 * Disable foreground dispatch to the given activity.
 *
 * <p>After calling {@link #enableForegroundDispatch}, an activity
 * must call this method before its {@link Activity#onPause} callback
 * completes.
 *
 * <p>This method must be called from the main thread.
 *
 * <p class=""note"">Requires the {@link android.Manifest.permission#NFC} permission.
 *
 * @param activity the Activity to disable dispatch to
 * @throws IllegalStateException if the Activity has already been paused
 */
","/**
 * Disable foreground dispatch to the given activity.
 *
 * <p>After calling {@link #enableForegroundDispatch}, an activity
 * must call this method before its {@link Activity#onPause} callback
 * completes.
 *
 * <p>This method must be called from the main thread.
 *
 * <p class=""note"">Requires the {@link android.Manifest.permission#NFC} permission.
 *
 * @param activity the Activity to disable dispatch to
 * @throws IllegalStateException if the Activity has already been paused
 * @throws UnsupportedOperationException if FEATURE_NFC is unavailable.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",2,"The addition of a 'synchronized' block that includes a conditional exception throw has been added, so the code change types are 3,4.","The added exception throw (UnsupportedOperationException) represents a change in the exception handling behavior of the method, which could lead to a potential Compatibility Issue as clients relying on this API will now have to handle a possible new exception thrown by the method. Thus, the CI type is 2."
110,<android.content.pm.ShortcutInfo.Builder: Builder setIntent(Intent)>,24,25,<android.content.pm.ShortcutInfo.Builder: Builder setIntent(Intent)>,<android.content.pm.ShortcutInfo.Builder: Builder setIntent(Intent)>,0,"{
    mIntent = Preconditions.checkNotNull(intent, ""intent"");
    return this;
}","{
    return setIntents(new Intent[] { intent });
}",1,"/**
 * Sets the intent of a shortcut.  This is a mandatory field.  The extras must only contain
 * persistable information.  (See {@link PersistableBundle}).
 */
","/**
 * Sets the intent of a shortcut.  Alternatively, {@link #setIntents(Intent[])} can be used
 * to launch an activity with other activities in the back stack.
 *
 * <p>This is a mandatory field when publishing a new shortcut with
 * {@link ShortcutManager#addDynamicShortcuts(List)} or
 * {@link ShortcutManager#setDynamicShortcuts(List)}.
 *
 * <p>A shortcut can launch any intent that the publisher application has permission to
 * launch.  For example, a shortcut can launch an unexported activity within the publisher
 * application.  A shortcut intent doesn't have to point at the target activity.
 *
 * <p>The given {@code intent} can contain extras, but these extras must contain values
 * of primitive types in order for the system to persist these values.
 *
 * @see ShortcutInfo#getIntent()
 * @see #setIntents(Intent[])
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation has changed from directly setting mIntent to calling setIntents(new Intent[] { intent }), which indicates a change in the method being used to set the intent, making it a dependent API change. Therefore, the code change types are 1,5.","Since the method used to set the intent has changed, even though the signature of the API remains the same, the API behavior may differ due to the use of a different method internally (setIntents instead of directly assigning to mIntent). Therefore, there is a potential for the API to return a different value, and the CI type is 1."
112,"<android.app.WallpaperManager: int setResource(int,int)>",24,25,"<android.app.WallpaperManager: int setResource(int,int)>","<android.app.WallpaperManager: int setResource(int,int)>",0,"{
    if (sGlobals.mService == null) {
        Log.w(TAG, ""WallpaperService not running"");
        throw new RuntimeException(new DeadSystemException());
    }
    final Bundle result = new Bundle();
    final WallpaperSetCompletion completion = new WallpaperSetCompletion();
    try {
        Resources resources = mContext.getResources();
        /* Set the wallpaper to the default values */
        ParcelFileDescriptor fd = sGlobals.mService.setWallpaper(""res:"" + resources.getResourceName(resid), mContext.getOpPackageName(), null, false, result, which, completion);
        if (fd != null) {
            FileOutputStream fos = null;
            boolean ok = false;
            try {
                fos = new ParcelFileDescriptor.AutoCloseOutputStream(fd);
                copyStreamToWallpaperFile(resources.openRawResource(resid), fos);
                // The 'close()' is the trigger for any server-side image manipulation,
                // so we must do that before waiting for completion.
                fos.close();
                completion.waitForCompletion();
            } finally {
                // Might be redundant but completion shouldn't wait unless the write
                // succeeded; this is a fallback if it threw past the close+wait.
                IoUtils.closeQuietly(fos);
            }
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
    return result.getInt(EXTRA_NEW_WALLPAPER_ID, 0);
}","{
    if (sGlobals.mService == null) {
        Log.w(TAG, ""WallpaperService not running"");
        throw new RuntimeException(new DeadSystemException());
    }
    final Bundle result = new Bundle();
    final WallpaperSetCompletion completion = new WallpaperSetCompletion();
    try {
        Resources resources = mContext.getResources();
        /* Set the wallpaper to the default values */
        ParcelFileDescriptor fd = sGlobals.mService.setWallpaper(""res:"" + resources.getResourceName(resid), mContext.getOpPackageName(), null, false, result, which, completion, UserHandle.myUserId());
        if (fd != null) {
            FileOutputStream fos = null;
            boolean ok = false;
            try {
                fos = new ParcelFileDescriptor.AutoCloseOutputStream(fd);
                copyStreamToWallpaperFile(resources.openRawResource(resid), fos);
                // The 'close()' is the trigger for any server-side image manipulation,
                // so we must do that before waiting for completion.
                fos.close();
                completion.waitForCompletion();
            } finally {
                // Might be redundant but completion shouldn't wait unless the write
                // succeeded; this is a fallback if it threw past the close+wait.
                IoUtils.closeQuietly(fos);
            }
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
    return result.getInt(EXTRA_NEW_WALLPAPER_ID, 0);
}",1,"/**
 * Version of {@link #setResource(int)} that allows the caller to specify which
 * of the supported wallpaper categories to set.
 *
 * @param resid The resource ID of the bitmap to be used as the wallpaper image
 * @param which Flags indicating which wallpaper(s) to configure with the new imagery
 *
 * @see #FLAG_LOCK
 * @see #FLAG_SYSTEM
 *
 * @return An integer ID assigned to the newly active wallpaper; or zero on failure.
 *
 * @throws IOException
 */
","/**
 * Version of {@link #setResource(int)} that allows the caller to specify which
 * of the supported wallpaper categories to set.
 *
 * @param resid The resource ID of the bitmap to be used as the wallpaper image
 * @param which Flags indicating which wallpaper(s) to configure with the new imagery
 *
 * @see #FLAG_LOCK
 * @see #FLAG_SYSTEM
 *
 * @return An integer ID assigned to the newly active wallpaper; or zero on failure.
 *
 * @throws IOException
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,"The change lies in the additional parameter 'UserHandle.myUserId()' in the late implementation. This is a change to a dependent API `setWallpaper`, which adds an extra parameter to the method call in the late version.","The additional parameter in the dependent API call could potentially result in a different outcome of the 'setWallpaper' method, which could lead to a different 'result' Bundle being returned. Therefore, this could potentially cause the API to return a different value, and the CI type is 1."
114,<android.hardware.camera2.params.OutputConfiguration: boolean equals(Object)>,24,25,<android.hardware.camera2.params.OutputConfiguration: boolean equals(Object)>,<android.hardware.camera2.params.OutputConfiguration: boolean equals(Object)>,0,"{
    if (obj == null) {
        return false;
    } else if (this == obj) {
        return true;
    } else if (obj instanceof OutputConfiguration) {
        final OutputConfiguration other = (OutputConfiguration) obj;
        return mRotation == other.mRotation && mSurface == other.mSurface && mConfiguredGenerationId == other.mConfiguredGenerationId && mConfiguredSize.equals(other.mConfiguredSize) && mConfiguredFormat == other.mConfiguredFormat && mConfiguredDataspace == other.mConfiguredDataspace && mSurfaceGroupId == other.mSurfaceGroupId;
    }
    return false;
}","{
    if (obj == null) {
        return false;
    } else if (this == obj) {
        return true;
    } else if (obj instanceof OutputConfiguration) {
        final OutputConfiguration other = (OutputConfiguration) obj;
        boolean iSSurfaceEqual = mSurface == other.mSurface && mConfiguredGenerationId == other.mConfiguredGenerationId;
        if (mIsDeferredConfig) {
            Log.i(TAG, ""deferred config has the same surface"");
            iSSurfaceEqual = true;
        }
        return mRotation == other.mRotation && iSSurfaceEqual && mConfiguredSize.equals(other.mConfiguredSize) && mConfiguredFormat == other.mConfiguredFormat && mConfiguredDataspace == other.mConfiguredDataspace && mSurfaceGroupId == other.mSurfaceGroupId && mSurfaceType == other.mSurfaceType && mIsDeferredConfig == other.mIsDeferredConfig;
    }
    return false;
}",1,"/**
 * Check if this {@link OutputConfiguration} is equal to another {@link OutputConfiguration}.
 *
 * <p>Two output configurations are only equal if and only if the underlying surfaces, surface
 * properties (width, height, format, dataspace) when the output configurations are created,
 * and all other configuration parameters are equal. </p>
 *
 * @return {@code true} if the objects were equal, {@code false} otherwise
 */
","/**
 * Check if this {@link OutputConfiguration} is equal to another {@link OutputConfiguration}.
 *
 * <p>Two output configurations are only equal if and only if the underlying surfaces, surface
 * properties (width, height, format, dataspace) when the output configurations are created,
 * and all other configuration parameters are equal. </p>
 *
 * @return {@code true} if the objects were equal, {@code false} otherwise
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,The implementation of `equals` method has changed in three ways:,"- New comparisons in the final return statement, more specifically `mSurfaceType == other.mSurfaceType && mIsDeferredConfig == other.mIsDeferredConfig`, are added."
115,<android.widget.ListView: void setSelectionAfterHeaderView()>,24,25,<android.widget.ListView: void setSelectionAfterHeaderView()>,<android.widget.ListView: void setSelectionAfterHeaderView()>,0,"{
    final int count = mHeaderViewInfos.size();
    if (count > 0) {
        mNextSelectedPosition = 0;
        return;
    }
    if (mAdapter != null) {
        setSelection(count);
    } else {
        mNextSelectedPosition = count;
        mLayoutMode = LAYOUT_SET_SELECTION;
    }
}","{
    final int count = getHeaderViewsCount();
    if (count > 0) {
        mNextSelectedPosition = 0;
        return;
    }
    if (mAdapter != null) {
        setSelection(count);
    } else {
        mNextSelectedPosition = count;
        mLayoutMode = LAYOUT_SET_SELECTION;
    }
}",1,"/**
 * setSelectionAfterHeaderView set the selection to be the first list item
 * after the header views.
 */
","/**
 * setSelectionAfterHeaderView set the selection to be the first list item
 * after the header views.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The only change is the way to get the count of header views: the direct access to mHeaderViewInfos.size() has been replaced with a call to the method getHeaderViewsCount(). The rest of the code and the overall logic remain unchanged, which means that this change type is 5.",There is no compatibility issue because the method getHeaderViewsCount() should logically return the same value that mHeaderViewInfos.size() would return. The behavior of the API remains unchanged even though a dependent API has undergone a modification.
117,"<android.nfc.NfcAdapter: void enableForegroundNdefPush(Activity,NdefMessage)>",24,25,"<android.nfc.NfcAdapter: void enableForegroundNdefPush(Activity,NdefMessage)>","<android.nfc.NfcAdapter: void enableForegroundNdefPush(Activity,NdefMessage)>",0,"{
    if (activity == null || message == null) {
        throw new NullPointerException();
    }
    enforceResumed(activity);
    mNfcActivityManager.setNdefPushMessage(activity, message, 0);
}","{
    synchronized (NfcAdapter.class) {
        if (!sHasNfcFeature) {
            throw new UnsupportedOperationException();
        }
    }
    if (activity == null || message == null) {
        throw new NullPointerException();
    }
    enforceResumed(activity);
    mNfcActivityManager.setNdefPushMessage(activity, message, 0);
}",1,"/**
 * Enable NDEF message push over NFC while this Activity is in the foreground.
 *
 * <p>You must explicitly call this method every time the activity is
 * resumed, and you must call {@link #disableForegroundNdefPush} before
 * your activity completes {@link Activity#onPause}.
 *
 * <p>Strongly recommend to use the new {@link #setNdefPushMessage}
 * instead: it automatically hooks into your activity life-cycle,
 * so you do not need to call enable/disable in your onResume/onPause.
 *
 * <p>For NDEF push to function properly the other NFC device must
 * support either NFC Forum's SNEP (Simple Ndef Exchange Protocol), or
 * Android's ""com.android.npp"" (Ndef Push Protocol). This was optional
 * on Gingerbread level Android NFC devices, but SNEP is mandatory on
 * Ice-Cream-Sandwich and beyond.
 *
 * <p>This method must be called from the main thread.
 *
 * <p class=""note"">Requires the {@link android.Manifest.permission#NFC} permission.
 *
 * @param activity foreground activity
 * @param message a NDEF Message to push over NFC
 * @throws IllegalStateException if the activity is not currently in the foreground
 * @deprecated use {@link #setNdefPushMessage} instead
 */
","/**
 * Enable NDEF message push over NFC while this Activity is in the foreground.
 *
 * <p>You must explicitly call this method every time the activity is
 * resumed, and you must call {@link #disableForegroundNdefPush} before
 * your activity completes {@link Activity#onPause}.
 *
 * <p>Strongly recommend to use the new {@link #setNdefPushMessage}
 * instead: it automatically hooks into your activity life-cycle,
 * so you do not need to call enable/disable in your onResume/onPause.
 *
 * <p>For NDEF push to function properly the other NFC device must
 * support either NFC Forum's SNEP (Simple Ndef Exchange Protocol), or
 * Android's ""com.android.npp"" (Ndef Push Protocol). This was optional
 * on Gingerbread level Android NFC devices, but SNEP is mandatory on
 * Ice-Cream-Sandwich and beyond.
 *
 * <p>This method must be called from the main thread.
 *
 * <p class=""note"">Requires the {@link android.Manifest.permission#NFC} permission.
 *
 * @param activity foreground activity
 * @param message a NDEF Message to push over NFC
 * @throws IllegalStateException if the activity is not currently in the foreground
 * @throws UnsupportedOperationException if FEATURE_NFC is unavailable.
 * @deprecated use {@link #setNdefPushMessage} instead
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,"2,3,4",2,"The late version includes a new synchronized block that checks if the NFC feature is supported and throws an exception if it's not, a new exception handling statement has been introduced, and also the synchronization control introduces a new control dependency. So the change types are 2, 3, and 4.","Because a new exception (UnsupportedOperationException) could be thrown before the previous checks are performed, the behavior of the API could be different when it is called on a device without NFC feature. Thus, this change could potentially lead to compatibility issues caused by different exception handlings, and the CI type is 2."
118,<android.widget.FrameLayout: LayoutParams generateLayoutParams(LayoutParams)>,24,25,<android.widget.FrameLayout: LayoutParams generateLayoutParams(LayoutParams)>,<android.widget.FrameLayout: LayoutParams generateLayoutParams(LayoutParams)>,0,"{
    if (lp instanceof LayoutParams) {
        return new LayoutParams((LayoutParams) lp);
    } else if (lp instanceof MarginLayoutParams) {
        return new LayoutParams((MarginLayoutParams) lp);
    } else {
        return new LayoutParams(lp);
    }
}","{
    if (sPreserveMarginParamsInLayoutParamConversion) {
        if (lp instanceof LayoutParams) {
            return new LayoutParams((LayoutParams) lp);
        } else if (lp instanceof MarginLayoutParams) {
            return new LayoutParams((MarginLayoutParams) lp);
        }
    }
    return new LayoutParams(lp);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"A new static boolean field `sPreserveMarginParamsInLayoutParamConversion` has been introduced to control the execution of if-else blocks, and the final else block has been moved outside the conditional check. This is a change in the control dependency (3) and also a structural change in the code (4), but it has no effect on the actual behavior since the final 'return new LayoutParams(lp);' is still there to catch all cases that do not match the previous conditions.","Since the final default behavior ('return new LayoutParams(lp);') is still the same and the additional condition still creates a `LayoutParams` object from a `MarginLayoutParams` or `LayoutParams` object if applicable, the logic to generate the `LayoutParams` does not change from the behavior in the early version, meaning there is no difference in the return values or exceptions thrown by this method. Therefore, there is no compatibility issue, so the CI type is 0."
119,<android.view.TextureView: HardwareLayer getHardwareLayer()>,24,25,<android.view.TextureView: HardwareLayer getHardwareLayer()>,<android.view.TextureView: HardwareLayer getHardwareLayer()>,0,"{
    if (mLayer == null) {
        if (mAttachInfo == null || mAttachInfo.mHardwareRenderer == null) {
            return null;
        }
        mLayer = mAttachInfo.mHardwareRenderer.createTextureLayer();
        if (!mUpdateSurface) {
            // Create a new SurfaceTexture for the layer.
            mSurface = new SurfaceTexture(false);
            mLayer.setSurfaceTexture(mSurface);
        }
        mSurface.setDefaultBufferSize(getWidth(), getHeight());
        nCreateNativeWindow(mSurface);
        mSurface.setOnFrameAvailableListener(mUpdateListener, mAttachInfo.mHandler);
        if (mListener != null && !mUpdateSurface) {
            mListener.onSurfaceTextureAvailable(mSurface, getWidth(), getHeight());
        }
        mLayer.setLayerPaint(mLayerPaint);
    }
    if (mUpdateSurface) {
        // Someone has requested that we use a specific SurfaceTexture, so
        // tell mLayer about it and set the SurfaceTexture to use the
        // current view size.
        mUpdateSurface = false;
        // Since we are updating the layer, force an update to ensure its
        // parameters are correct (width, height, transform, etc.)
        updateLayer();
        mMatrixChanged = true;
        mLayer.setSurfaceTexture(mSurface);
        mSurface.setDefaultBufferSize(getWidth(), getHeight());
    }
    return mLayer;
}","{
    if (mLayer == null) {
        if (mAttachInfo == null || mAttachInfo.mHardwareRenderer == null) {
            return null;
        }
        mLayer = mAttachInfo.mHardwareRenderer.createTextureLayer();
        boolean createNewSurface = (mSurface == null);
        if (createNewSurface) {
            // Create a new SurfaceTexture for the layer.
            mSurface = new SurfaceTexture(false);
            nCreateNativeWindow(mSurface);
        }
        mLayer.setSurfaceTexture(mSurface);
        mSurface.setDefaultBufferSize(getWidth(), getHeight());
        mSurface.setOnFrameAvailableListener(mUpdateListener, mAttachInfo.mHandler);
        if (mListener != null && createNewSurface) {
            mListener.onSurfaceTextureAvailable(mSurface, getWidth(), getHeight());
        }
        mLayer.setLayerPaint(mLayerPaint);
    }
    if (mUpdateSurface) {
        // Someone has requested that we use a specific SurfaceTexture, so
        // tell mLayer about it and set the SurfaceTexture to use the
        // current view size.
        mUpdateSurface = false;
        // Since we are updating the layer, force an update to ensure its
        // parameters are correct (width, height, transform, etc.)
        updateLayer();
        mMatrixChanged = true;
        mLayer.setSurfaceTexture(mSurface);
        mSurface.setDefaultBufferSize(getWidth(), getHeight());
    }
    return mLayer;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The variable initialization logic has been changed, which is indicative of a control dependency change, specifically the introduction of the ""createNewSurface"" variable and its usage in the conditionals. The statements inside the 'if' have also been refactored. The removal of `!mUpdateSurface` and replacing it with `createNewSurface` will change the way the conditions are evaluated. In addition, the call to `nCreateNativeWindow(mSurface)` is now under a different condition. These are changes in control dependency and other statements, which warrant classifying the change as 3,4.","Despite the changes in conditionals and refactoring, there's no direct evidence that these changes will affect the returned value or the exceptions thrown. The API's overall behavior and returned value (`mLayer`) remain consistent between the two versions. Therefore, there's no compatibility issue in terms of different return values or exceptions, and the CI type is 0."
