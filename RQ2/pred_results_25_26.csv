Number,Signature,Early_Version,Late_Version,Early_Signature,Late_Signature,Diff_Signature,Early_Implementation,Late_Implementation,Diff_Implementation,Early_Comment,Late_Comment,Diff_Comment,Early_Annotation,Late_Annotation,Diff_Annotation,Early_Callback,Late_Callback,Diff_Callback,GT_CI_ControlFlow,GT_CI_Type,pred_change,pred_CI,change_description,CI_description
1,<android.app.FragmentManagerImpl: FragmentManagerNonConfig retainNonConfig()>,25,26,<android.app.FragmentManagerImpl: FragmentManagerNonConfig retainNonConfig()>,<android.app.FragmentManagerImpl: FragmentManagerNonConfig retainNonConfig()>,0,"{
    ArrayList<Fragment> fragments = null;
    ArrayList<FragmentManagerNonConfig> childFragments = null;
    if (mActive != null) {
        for (int i = 0; i < mActive.size(); i++) {
            Fragment f = mActive.get(i);
            if (f != null) {
                if (f.mRetainInstance) {
                    if (fragments == null) {
                        fragments = new ArrayList<>();
                    }
                    fragments.add(f);
                    f.mRetaining = true;
                    f.mTargetIndex = f.mTarget != null ? f.mTarget.mIndex : -1;
                    if (DEBUG)
                        Log.v(TAG, ""retainNonConfig: keeping retained "" + f);
                }
                boolean addedChild = false;
                if (f.mChildFragmentManager != null) {
                    FragmentManagerNonConfig child = f.mChildFragmentManager.retainNonConfig();
                    if (child != null) {
                        if (childFragments == null) {
                            childFragments = new ArrayList<>();
                            for (int j = 0; j < i; j++) {
                                childFragments.add(null);
                            }
                        }
                        childFragments.add(child);
                        addedChild = true;
                    }
                }
                if (childFragments != null && !addedChild) {
                    childFragments.add(null);
                }
            }
        }
    }
    if (fragments == null && childFragments == null) {
        return null;
    }
    return new FragmentManagerNonConfig(fragments, childFragments);
}","{
    setRetaining(mSavedNonConfig);
    return mSavedNonConfig;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The entire implementation has changed. The late version does not use the complex logic of the early version but simply calls `setRetaining(mSavedNonConfig)` and returns `mSavedNonConfig`. The method signature itself didn't change, but the logic of what is being returned has completely changed. The introduction of `setRetaining` and the omission of the previous logic processing `mActive` is an 'Other statement changed', and the change in the return statement indicates a 'Return statement changed', which is type 4 and type 1 respectively.","The change in return statement, where the late version is simply returning a variable that seems to be set elsewhere (`mSavedNonConfig`) compared to the early version where a new `FragmentManagerNonConfig` object is constructed and returned, will definitely lead to a different return value. This represents a compatibility issue as clients of this API will get different results when they call the method in version 26 than they would have in version 25, so the CI type is 1."
3,"<android.provider.DocumentsContract: Uri moveDocument(ContentResolver,Uri,Uri,Uri)>",25,26,"<android.provider.DocumentsContract: Uri moveDocument(ContentResolver,Uri,Uri,Uri)>","<android.provider.DocumentsContract: Uri moveDocument(ContentResolver,Uri,Uri,Uri)>",0,"{
    final ContentProviderClient client = resolver.acquireUnstableContentProviderClient(sourceDocumentUri.getAuthority());
    try {
        return moveDocument(client, sourceDocumentUri, sourceParentDocumentUri, targetParentDocumentUri);
    } catch (Exception e) {
        Log.w(TAG, ""Failed to move document"", e);
        return null;
    } finally {
        ContentProviderClient.releaseQuietly(client);
    }
}","{
    final ContentProviderClient client = resolver.acquireUnstableContentProviderClient(sourceDocumentUri.getAuthority());
    try {
        return moveDocument(client, sourceDocumentUri, sourceParentDocumentUri, targetParentDocumentUri);
    } catch (Exception e) {
        Log.w(TAG, ""Failed to move document"", e);
        rethrowIfNecessary(resolver, e);
        return null;
    } finally {
        ContentProviderClient.releaseQuietly(client);
    }
}",1,"/**
 * Moves the given document under a new parent.
 *
 * @param sourceDocumentUri document with {@link Document#FLAG_SUPPORTS_MOVE}
 * @param sourceParentDocumentUri parent document of the document to move.
 * @param targetParentDocumentUri document which will become a new parent of the source
 * document.
 * @return the moved document, or {@code null} if failed.
 */
","/**
 * Moves the given document under a new parent.
 *
 * @param sourceDocumentUri document with {@link Document#FLAG_SUPPORTS_MOVE}
 * @param sourceParentDocumentUri parent document of the document to move.
 * @param targetParentDocumentUri document which will become a new parent of the source
 * document.
 * @return the moved document, or {@code null} if failed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method 'rethrowIfNecessary(resolver, e);' has been inserted before the return null statement in the exception handling block, which is an other statement changed so the code change type is 4.","The addition of 'rethrowIfNecessary(resolver, e);' does not lead to a compatibility issue as it doesn't alter the return value or the type of exceptions thrown since the method rethrowIfNecessary might re-throw the exception that is caught, which is the same behavior as logging the exception and returning null. No new exception types are thrown, and the return value remains null in the event of an exception, so there is no compatibility issue, which means the CI type is 0."
4,"<android.app.admin.DevicePolicyManager: boolean setPermissionGrantState(ComponentName,String,String,int)>",25,26,"<android.app.admin.DevicePolicyManager: boolean setPermissionGrantState(ComponentName,String,String,int)>","<android.app.admin.DevicePolicyManager: boolean setPermissionGrantState(ComponentName,String,String,int)>",0,"{
    throwIfParentInstance(""setPermissionGrantState"");
    try {
        return mService.setPermissionGrantState(admin, packageName, permission, grantState);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}","{
    throwIfParentInstance(""setPermissionGrantState"");
    try {
        return mService.setPermissionGrantState(admin, mContext.getPackageName(), packageName, permission, grantState);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}",1,"/**
 * Sets the grant state of a runtime permission for a specific application. The state can be
 * {@link #PERMISSION_GRANT_STATE_DEFAULT default} in which a user can manage it through the UI,
 * {@link #PERMISSION_GRANT_STATE_DENIED denied}, in which the permission is denied and the user
 * cannot manage it through the UI, and {@link #PERMISSION_GRANT_STATE_GRANTED granted} in which
 * the permission is granted and the user cannot manage it through the UI. This might affect all
 * permissions in a group that the runtime permission belongs to. This method can only be called
 * by a profile or device owner.
 * <p/>
 * Setting the grant state to {@link #PERMISSION_GRANT_STATE_DEFAULT default} does not revoke
 * the permission. It retains the previous grant, if any.
 * <p/>
 * Permissions can be granted or revoked only for applications built with a
 * {@code targetSdkVersion} of {@link android.os.Build.VERSION_CODES#M} or later.
 *
 * @param admin Which profile or device owner this request is associated with.
 * @param packageName The application to grant or revoke a permission to.
 * @param permission The permission to grant or revoke.
 * @param grantState The permission grant state which is one of
 * {@link #PERMISSION_GRANT_STATE_DENIED}, {@link #PERMISSION_GRANT_STATE_DEFAULT},
 * {@link #PERMISSION_GRANT_STATE_GRANTED},
 * @return whether the permission was successfully granted or revoked.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 * @see #PERMISSION_GRANT_STATE_DENIED
 * @see #PERMISSION_GRANT_STATE_DEFAULT
 * @see #PERMISSION_GRANT_STATE_GRANTED
 */
","/**
 * Sets the grant state of a runtime permission for a specific application. The state can be
 * {@link #PERMISSION_GRANT_STATE_DEFAULT default} in which a user can manage it through the UI,
 * {@link #PERMISSION_GRANT_STATE_DENIED denied}, in which the permission is denied and the user
 * cannot manage it through the UI, and {@link #PERMISSION_GRANT_STATE_GRANTED granted} in which
 * the permission is granted and the user cannot manage it through the UI. This might affect all
 * permissions in a group that the runtime permission belongs to. This method can only be called
 * by a profile owner, device owner, or a delegate given the
 * {@link #DELEGATION_PERMISSION_GRANT} scope via {@link #setDelegatedScopes}.
 * <p/>
 * Setting the grant state to {@link #PERMISSION_GRANT_STATE_DEFAULT default} does not revoke
 * the permission. It retains the previous grant, if any.
 * <p/>
 * Permissions can be granted or revoked only for applications built with a
 * {@code targetSdkVersion} of {@link android.os.Build.VERSION_CODES#M} or later.
 *
 * @param admin Which profile or device owner this request is associated with.
 * @param packageName The application to grant or revoke a permission to.
 * @param permission The permission to grant or revoke.
 * @param grantState The permission grant state which is one of
 * {@link #PERMISSION_GRANT_STATE_DENIED}, {@link #PERMISSION_GRANT_STATE_DEFAULT},
 * {@link #PERMISSION_GRANT_STATE_GRANTED},
 * @return whether the permission was successfully granted or revoked.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 * @see #PERMISSION_GRANT_STATE_DENIED
 * @see #PERMISSION_GRANT_STATE_DEFAULT
 * @see #PERMISSION_GRANT_STATE_GRANTED
 * @see #setDelegatedScopes
 * @see #DELEGATION_PERMISSION_GRANT
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The dependent API has changed as `mService.setPermissionGrantState` now includes added mContext.getPackageName() as one of its arguments, so the code change type is 4,5.","The Dependency API is adding a new parameter (mContext.getPackageName()), which means that the behaviour of the dependent API `mService.setPermissionGrantState` could potentially be different as it could be using this new parameter in its logic. Therefore, the late version could return a different result compared to the early version, and the CI type is 1."
5,"<android.app.Activity: void overridePendingTransition(int,int)>",25,26,"<android.app.Activity: void overridePendingTransition(int,int)>","<android.app.Activity: void overridePendingTransition(int,int)>",0,"{
    try {
        ActivityManagerNative.getDefault().overridePendingTransition(mToken, getPackageName(), enterAnim, exitAnim);
    } catch (RemoteException e) {
    }
}","{
    try {
        ActivityManager.getService().overridePendingTransition(mToken, getPackageName(), enterAnim, exitAnim);
    } catch (RemoteException e) {
    }
}",1,"/**
 * Call immediately after one of the flavors of {@link #startActivity(Intent)}
 * or {@link #finish} to specify an explicit transition animation to
 * perform next.
 *
 * <p>As of {@link android.os.Build.VERSION_CODES#JELLY_BEAN} an alternative
 * to using this with starting activities is to supply the desired animation
 * information through a {@link ActivityOptions} bundle to
 * {@link #startActivity(Intent, Bundle)} or a related function.  This allows
 * you to specify a custom animation even when starting an activity from
 * outside the context of the current top activity.
 *
 * @param enterAnim A resource ID of the animation resource to use for
 * the incoming activity.  Use 0 for no animation.
 * @param exitAnim A resource ID of the animation resource to use for
 * the outgoing activity.  Use 0 for no animation.
 */
","/**
 * Call immediately after one of the flavors of {@link #startActivity(Intent)}
 * or {@link #finish} to specify an explicit transition animation to
 * perform next.
 *
 * <p>As of {@link android.os.Build.VERSION_CODES#JELLY_BEAN} an alternative
 * to using this with starting activities is to supply the desired animation
 * information through a {@link ActivityOptions} bundle to
 * {@link #startActivity(Intent, Bundle)} or a related function.  This allows
 * you to specify a custom animation even when starting an activity from
 * outside the context of the current top activity.
 *
 * @param enterAnim A resource ID of the animation resource to use for
 * the incoming activity.  Use 0 for no animation.
 * @param exitAnim A resource ID of the animation resource to use for
 * the outgoing activity.  Use 0 for no animation.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"There is a change in the dependent API from `ActivityManagerNative.getDefault()` to `ActivityManager.getService()`, which indicates that the implementation now relies on a different method to achieve its functionality.","This change does not directly lead to a different return value or an exception being thrown, as the API's contract or behavior from the caller's perspective is unchanged. Both versions contain identical try-catch blocks for `RemoteException`, and the purpose of this method is to initiate an action rather than return a value or exception to the caller. Thus, there is no compatibility issue."
7,<android.app.ContextImpl: void unregisterReceiver(BroadcastReceiver)>,25,26,<android.app.ContextImpl: void unregisterReceiver(BroadcastReceiver)>,<android.app.ContextImpl: void unregisterReceiver(BroadcastReceiver)>,0,"{
    if (mPackageInfo != null) {
        IIntentReceiver rd = mPackageInfo.forgetReceiverDispatcher(getOuterContext(), receiver);
        try {
            ActivityManagerNative.getDefault().unregisterReceiver(rd);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    } else {
        throw new RuntimeException(""Not supported in system context"");
    }
}","{
    if (mPackageInfo != null) {
        IIntentReceiver rd = mPackageInfo.forgetReceiverDispatcher(getOuterContext(), receiver);
        try {
            ActivityManager.getService().unregisterReceiver(rd);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    } else {
        throw new RuntimeException(""Not supported in system context"");
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The dependent API call inside the try block has been changed from ActivityManagerNative.getDefault().unregisterReceiver(rd); to ActivityManager.getService().unregisterReceiver(rd);, which indicates that the method call dependency has been modified, so the change type is 5.","Despite the dependent API call has changed, the modification inside the try block does not affect the behaviour exposed to the caller of unregisterReceiver in terms of return values or exceptions. There is no addition or removal of return statements or changes in exception handling pattern. Both the early and late versions aim to call the system service to unregister a receiver and throw a wrapped RemoteException if the remote call fails. Thus the change does not introduce any Compatibility Issue, so CI type is 0."
12,"<android.view.View: boolean startDragAndDrop(ClipData,DragShadowBuilder,Object,int)>",25,26,"<android.view.View: boolean startDragAndDrop(ClipData,DragShadowBuilder,Object,int)>","<android.view.View: boolean startDragAndDrop(ClipData,DragShadowBuilder,Object,int)>",0,"{
    if (ViewDebug.DEBUG_DRAG) {
        Log.d(VIEW_LOG_TAG, ""startDragAndDrop: data="" + data + "" flags="" + flags);
    }
    if (mAttachInfo == null) {
        Log.w(VIEW_LOG_TAG, ""startDragAndDrop called on a detached view."");
        return false;
    }
    boolean okay = false;
    Point shadowSize = new Point();
    Point shadowTouchPoint = new Point();
    shadowBuilder.onProvideShadowMetrics(shadowSize, shadowTouchPoint);
    if ((shadowSize.x < 0) || (shadowSize.y < 0) || (shadowTouchPoint.x < 0) || (shadowTouchPoint.y < 0)) {
        throw new IllegalStateException(""Drag shadow dimensions must not be negative"");
    }
    if (ViewDebug.DEBUG_DRAG) {
        Log.d(VIEW_LOG_TAG, ""drag shadow: width="" + shadowSize.x + "" height="" + shadowSize.y + "" shadowX="" + shadowTouchPoint.x + "" shadowY="" + shadowTouchPoint.y);
    }
    if (mAttachInfo.mDragSurface != null) {
        mAttachInfo.mDragSurface.release();
    }
    mAttachInfo.mDragSurface = new Surface();
    try {
        mAttachInfo.mDragToken = mAttachInfo.mSession.prepareDrag(mAttachInfo.mWindow, flags, shadowSize.x, shadowSize.y, mAttachInfo.mDragSurface);
        if (ViewDebug.DEBUG_DRAG)
            Log.d(VIEW_LOG_TAG, ""prepareDrag returned token="" + mAttachInfo.mDragToken + "" surface="" + mAttachInfo.mDragSurface);
        if (mAttachInfo.mDragToken != null) {
            Canvas canvas = mAttachInfo.mDragSurface.lockCanvas(null);
            try {
                canvas.drawColor(0, PorterDuff.Mode.CLEAR);
                shadowBuilder.onDrawShadow(canvas);
            } finally {
                mAttachInfo.mDragSurface.unlockCanvasAndPost(canvas);
            }
            final ViewRootImpl root = getViewRootImpl();
            // Cache the local state object for delivery with DragEvents
            root.setLocalDragState(myLocalState);
            // repurpose 'shadowSize' for the last touch point
            root.getLastTouchPoint(shadowSize);
            okay = mAttachInfo.mSession.performDrag(mAttachInfo.mWindow, mAttachInfo.mDragToken, root.getLastTouchSource(), shadowSize.x, shadowSize.y, shadowTouchPoint.x, shadowTouchPoint.y, data);
            if (ViewDebug.DEBUG_DRAG)
                Log.d(VIEW_LOG_TAG, ""performDrag returned "" + okay);
        }
    } catch (Exception e) {
        Log.e(VIEW_LOG_TAG, ""Unable to initiate drag"", e);
        mAttachInfo.mDragSurface.destroy();
        mAttachInfo.mDragSurface = null;
    }
    return okay;
}","{
    if (ViewDebug.DEBUG_DRAG) {
        Log.d(VIEW_LOG_TAG, ""startDragAndDrop: data="" + data + "" flags="" + flags);
    }
    if (mAttachInfo == null) {
        Log.w(VIEW_LOG_TAG, ""startDragAndDrop called on a detached view."");
        return false;
    }
    if (data != null) {
        data.prepareToLeaveProcess((flags & View.DRAG_FLAG_GLOBAL) != 0);
    }
    boolean okay = false;
    Point shadowSize = new Point();
    Point shadowTouchPoint = new Point();
    shadowBuilder.onProvideShadowMetrics(shadowSize, shadowTouchPoint);
    if ((shadowSize.x < 0) || (shadowSize.y < 0) || (shadowTouchPoint.x < 0) || (shadowTouchPoint.y < 0)) {
        throw new IllegalStateException(""Drag shadow dimensions must not be negative"");
    }
    if (ViewDebug.DEBUG_DRAG) {
        Log.d(VIEW_LOG_TAG, ""drag shadow: width="" + shadowSize.x + "" height="" + shadowSize.y + "" shadowX="" + shadowTouchPoint.x + "" shadowY="" + shadowTouchPoint.y);
    }
    if (mAttachInfo.mDragSurface != null) {
        mAttachInfo.mDragSurface.release();
    }
    mAttachInfo.mDragSurface = new Surface();
    try {
        mAttachInfo.mDragToken = mAttachInfo.mSession.prepareDrag(mAttachInfo.mWindow, flags, shadowSize.x, shadowSize.y, mAttachInfo.mDragSurface);
        if (ViewDebug.DEBUG_DRAG)
            Log.d(VIEW_LOG_TAG, ""prepareDrag returned token="" + mAttachInfo.mDragToken + "" surface="" + mAttachInfo.mDragSurface);
        if (mAttachInfo.mDragToken != null) {
            Canvas canvas = mAttachInfo.mDragSurface.lockCanvas(null);
            try {
                canvas.drawColor(0, PorterDuff.Mode.CLEAR);
                shadowBuilder.onDrawShadow(canvas);
            } finally {
                mAttachInfo.mDragSurface.unlockCanvasAndPost(canvas);
            }
            final ViewRootImpl root = getViewRootImpl();
            // Cache the local state object for delivery with DragEvents
            root.setLocalDragState(myLocalState);
            // repurpose 'shadowSize' for the last touch point
            root.getLastTouchPoint(shadowSize);
            okay = mAttachInfo.mSession.performDrag(mAttachInfo.mWindow, mAttachInfo.mDragToken, root.getLastTouchSource(), shadowSize.x, shadowSize.y, shadowTouchPoint.x, shadowTouchPoint.y, data);
            if (ViewDebug.DEBUG_DRAG)
                Log.d(VIEW_LOG_TAG, ""performDrag returned "" + okay);
        }
    } catch (Exception e) {
        Log.e(VIEW_LOG_TAG, ""Unable to initiate drag"", e);
        mAttachInfo.mDragSurface.destroy();
        mAttachInfo.mDragSurface = null;
    }
    return okay;
}",1,"/**
 * Starts a drag and drop operation. When your application calls this method, it passes a
 * {@link android.view.View.DragShadowBuilder} object to the system. The
 * system calls this object's {@link DragShadowBuilder#onProvideShadowMetrics(Point, Point)}
 * to get metrics for the drag shadow, and then calls the object's
 * {@link DragShadowBuilder#onDrawShadow(Canvas)} to draw the drag shadow itself.
 * <p>
 * Once the system has the drag shadow, it begins the drag and drop operation by sending
 * drag events to all the View objects in your application that are currently visible. It does
 * this either by calling the View object's drag listener (an implementation of
 * {@link android.view.View.OnDragListener#onDrag(View,DragEvent) onDrag()} or by calling the
 * View object's {@link android.view.View#onDragEvent(DragEvent) onDragEvent()} method.
 * Both are passed a {@link android.view.DragEvent} object that has a
 * {@link android.view.DragEvent#getAction()} value of
 * {@link android.view.DragEvent#ACTION_DRAG_STARTED}.
 * </p>
 * <p>
 * Your application can invoke {@link #startDragAndDrop(ClipData, DragShadowBuilder, Object,
 * int) startDragAndDrop()} on any attached View object. The View object does not need to be
 * the one used in {@link android.view.View.DragShadowBuilder}, nor does it need to be related
 * to the View the user selected for dragging.
 * </p>
 * @param data A {@link android.content.ClipData} object pointing to the data to be
 * transferred by the drag and drop operation.
 * @param shadowBuilder A {@link android.view.View.DragShadowBuilder} object for building the
 * drag shadow.
 * @param myLocalState An {@link java.lang.Object} containing local data about the drag and
 * drop operation. This Object is put into every DragEvent object sent by the system during the
 * current drag.
 * <p>
 * myLocalState is a lightweight mechanism for the sending information from the dragged View
 * to the target Views. For example, it can contain flags that differentiate between a
 * a copy operation and a move operation.
 * </p>
 * @param flags Flags that control the drag and drop operation. This can be set to 0 for no
 * flags, or any combination of the following:
 * <ul>
 * <li>{@link #DRAG_FLAG_GLOBAL}</li>
 * <li>{@link #DRAG_FLAG_GLOBAL_PERSISTABLE_URI_PERMISSION}</li>
 * <li>{@link #DRAG_FLAG_GLOBAL_PREFIX_URI_PERMISSION}</li>
 * <li>{@link #DRAG_FLAG_GLOBAL_URI_READ}</li>
 * <li>{@link #DRAG_FLAG_GLOBAL_URI_WRITE}</li>
 * <li>{@link #DRAG_FLAG_OPAQUE}</li>
 * </ul>
 * @return {@code true} if the method completes successfully, or
 * {@code false} if it fails anywhere. Returning {@code false} means the system was unable to
 * do a drag, and so no drag operation is in progress.
 */
","/**
 * Starts a drag and drop operation. When your application calls this method, it passes a
 * {@link android.view.View.DragShadowBuilder} object to the system. The
 * system calls this object's {@link DragShadowBuilder#onProvideShadowMetrics(Point, Point)}
 * to get metrics for the drag shadow, and then calls the object's
 * {@link DragShadowBuilder#onDrawShadow(Canvas)} to draw the drag shadow itself.
 * <p>
 * Once the system has the drag shadow, it begins the drag and drop operation by sending
 * drag events to all the View objects in your application that are currently visible. It does
 * this either by calling the View object's drag listener (an implementation of
 * {@link android.view.View.OnDragListener#onDrag(View,DragEvent) onDrag()} or by calling the
 * View object's {@link android.view.View#onDragEvent(DragEvent) onDragEvent()} method.
 * Both are passed a {@link android.view.DragEvent} object that has a
 * {@link android.view.DragEvent#getAction()} value of
 * {@link android.view.DragEvent#ACTION_DRAG_STARTED}.
 * </p>
 * <p>
 * Your application can invoke {@link #startDragAndDrop(ClipData, DragShadowBuilder, Object,
 * int) startDragAndDrop()} on any attached View object. The View object does not need to be
 * the one used in {@link android.view.View.DragShadowBuilder}, nor does it need to be related
 * to the View the user selected for dragging.
 * </p>
 * @param data A {@link android.content.ClipData} object pointing to the data to be
 * transferred by the drag and drop operation.
 * @param shadowBuilder A {@link android.view.View.DragShadowBuilder} object for building the
 * drag shadow.
 * @param myLocalState An {@link java.lang.Object} containing local data about the drag and
 * drop operation. When dispatching drag events to views in the same activity this object
 * will be available through {@link android.view.DragEvent#getLocalState()}. Views in other
 * activities will not have access to this data ({@link android.view.DragEvent#getLocalState()}
 * will return null).
 * <p>
 * myLocalState is a lightweight mechanism for the sending information from the dragged View
 * to the target Views. For example, it can contain flags that differentiate between a
 * a copy operation and a move operation.
 * </p>
 * @param flags Flags that control the drag and drop operation. This can be set to 0 for no
 * flags, or any combination of the following:
 * <ul>
 * <li>{@link #DRAG_FLAG_GLOBAL}</li>
 * <li>{@link #DRAG_FLAG_GLOBAL_PERSISTABLE_URI_PERMISSION}</li>
 * <li>{@link #DRAG_FLAG_GLOBAL_PREFIX_URI_PERMISSION}</li>
 * <li>{@link #DRAG_FLAG_GLOBAL_URI_READ}</li>
 * <li>{@link #DRAG_FLAG_GLOBAL_URI_WRITE}</li>
 * <li>{@link #DRAG_FLAG_OPAQUE}</li>
 * </ul>
 * @return {@code true} if the method completes successfully, or
 * {@code false} if it fails anywhere. Returning {@code false} means the system was unable to
 * do a drag, and so no drag operation is in progress.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
14,<android.widget.ScrollView: boolean onGenericMotionEvent(MotionEvent)>,25,26,<android.widget.ScrollView: boolean onGenericMotionEvent(MotionEvent)>,<android.widget.ScrollView: boolean onGenericMotionEvent(MotionEvent)>,0,"{
    if ((event.getSource() & InputDevice.SOURCE_CLASS_POINTER) != 0) {
        switch(event.getAction()) {
            case MotionEvent.ACTION_SCROLL:
                {
                    if (!mIsBeingDragged) {
                        final float vscroll = event.getAxisValue(MotionEvent.AXIS_VSCROLL);
                        if (vscroll != 0) {
                            final int delta = (int) (vscroll * getVerticalScrollFactor());
                            final int range = getScrollRange();
                            int oldScrollY = mScrollY;
                            int newScrollY = oldScrollY - delta;
                            if (newScrollY < 0) {
                                newScrollY = 0;
                            } else if (newScrollY > range) {
                                newScrollY = range;
                            }
                            if (newScrollY != oldScrollY) {
                                super.scrollTo(mScrollX, newScrollY);
                                return true;
                            }
                        }
                    }
                }
        }
    }
    return super.onGenericMotionEvent(event);
}","{
    switch(event.getAction()) {
        case MotionEvent.ACTION_SCROLL:
            final float axisValue;
            if (event.isFromSource(InputDevice.SOURCE_CLASS_POINTER)) {
                axisValue = event.getAxisValue(MotionEvent.AXIS_VSCROLL);
            } else if (event.isFromSource(InputDevice.SOURCE_ROTARY_ENCODER)) {
                axisValue = event.getAxisValue(MotionEvent.AXIS_SCROLL);
            } else {
                axisValue = 0;
            }
            final int delta = Math.round(axisValue * mVerticalScrollFactor);
            if (delta != 0) {
                final int range = getScrollRange();
                int oldScrollY = mScrollY;
                int newScrollY = oldScrollY - delta;
                if (newScrollY < 0) {
                    newScrollY = 0;
                } else if (newScrollY > range) {
                    newScrollY = range;
                }
                if (newScrollY != oldScrollY) {
                    super.scrollTo(mScrollX, newScrollY);
                    return true;
                }
            }
            break;
    }
    return super.onGenericMotionEvent(event);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"The method's control flow has changed with conditional checks and logical statements being restructured. The early version only processes events from `InputDevice.SOURCE_CLASS_POINTER`, while the late version processes both from `InputDevice.SOURCE_CLASS_POINTER` and `InputDevice.SOURCE_ROTARY_ENCODER`. The factor used for scrolling calculation (`getVerticalScrollFactor()` vs `mVerticalScrollFactor`) and the way of rounding the delta value (cast to `int` vs `Math.round()`) have also changed. The code change types are 1 and 3.","Due to the changes in which events are processed and how the delta is calculated, it's possible that the late version of the method might return `true` for a different set of input events or for different scroll amounts, which would affect the behaviour seen by the end-user of this API, thereby constituting a compatibility issue of type 1."
16,<android.app.admin.DevicePolicyManager: boolean isAdminActive(ComponentName)>,25,26,<android.app.admin.DevicePolicyManager: boolean isAdminActive(ComponentName)>,<android.app.admin.DevicePolicyManager: boolean isAdminActive(ComponentName)>,0,"{
    return isAdminActiveAsUser(admin, myUserId());
}","{
    throwIfParentInstance(""isAdminActive"");
    return isAdminActiveAsUser(admin, myUserId());
}",1,"/**
 * Return true if the given administrator component is currently active (enabled) in the system.
 *
 * @param admin The administrator component to check for.
 * @return {@code true} if {@code admin} is currently enabled in the system, {@code false}
 * otherwise
 */
","/**
 * Return true if the given administrator component is currently active (enabled) in the system.
 *
 * @param admin The administrator component to check for.
 * @return {@code true} if {@code admin} is currently enabled in the system, {@code false}
 * otherwise
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"The late version of the method introduces a new exception handling statement throwIfParentInstance(""isAdminActive"") before the return statement. Other statements remain unchanged, so the code change type includes 2 (Exception handling statement changed) and 4 (Other statement changed).","The new exception handling could lead to a new exception being thrown, which did not occur in the early version. This change may affect the behavior of existing apps that rely on this method not throwing an exception in certain circumstances, so the CI type is 2 (Compatibility Issue caused by potential different exception handlings)."
17,"<android.app.SharedPreferencesImpl: Set<String> getStringSet(String,Set<String>)>",25,26,"<android.app.SharedPreferencesImpl: Set<String> getStringSet(String,Set<String>)>","<android.app.SharedPreferencesImpl: Set<String> getStringSet(String,Set<String>)>",0,"{
    synchronized (this) {
        awaitLoadedLocked();
        Set<String> v = (Set<String>) mMap.get(key);
        return v != null ? v : defValues;
    }
}","{
    synchronized (mLock) {
        awaitLoadedLocked();
        Set<String> v = (Set<String>) mMap.get(key);
        return v != null ? v : defValues;
    }
}",1,,,-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,4,0,"The only change is in the object on which synchronization is performed, from 'this' to 'mLock', so the code change type is 4.",There is no compatibility issue since neither the returned value nor the exception handling has changed—the synchronized block still ensures thread safety and does not affect the API's behavior.
18,<android.app.KeyguardManager: boolean isDeviceSecure()>,25,26,<android.app.KeyguardManager: boolean isDeviceSecure()>,<android.app.KeyguardManager: boolean isDeviceSecure()>,0,"{
    return isDeviceSecure(UserHandle.getCallingUserId());
}","{
    return isDeviceSecure(UserHandle.myUserId());
}",1,"/**
 * Returns whether the device is secured with a PIN, pattern or
 * password.
 *
 * <p>See also {@link #isKeyguardSecure} which treats SIM locked states as secure.
 *
 * @return true if a PIN, pattern or password was set.
 */
","/**
 * Returns whether the device is secured with a PIN, pattern or
 * password.
 *
 * <p>See also {@link #isKeyguardSecure} which treats SIM locked states as secure.
 *
 * @return true if a PIN, pattern or password was set.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method isDeviceSecure has been called with a different parameter: from isDeviceSecure(UserHandle.getCallingUserId()) in the early version to isDeviceSecure(UserHandle.myUserId()) in the late version. Hence, the change is related to a dependent API, so the code change type is 5.","The change from getCallingUserId() to myUserId() doesn't cause a Compatibility Issue as both methods are intended to return the user ID of the current process. They will generally return the same value when the method isDeviceSecure is called in a process that is operating on behalf of the calling user. Therefore, there's no CI."
19,<android.app.ActivityManager: void clearWatchHeapLimit()>,25,26,<android.app.ActivityManager: void clearWatchHeapLimit()>,<android.app.ActivityManager: void clearWatchHeapLimit()>,0,"{
    try {
        ActivityManagerNative.getDefault().setDumpHeapDebugLimit(null, 0, 0, null);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        getService().setDumpHeapDebugLimit(null, 0, 0, null);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Clear a heap watch limit previously set by {@link #setWatchHeapLimit(long)}.
 */
","/**
 * Clear a heap watch limit previously set by {@link #setWatchHeapLimit(long)}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method used to obtain the service interface has changed from ActivityManagerNative.getDefault() to getService(), which is a change in the method called to get a dependent API service. Therefore, the code change type is 5.","There is no direct change in behaviour detected in the API because both the early_version and late_version are calling the same 'setDumpHeapDebugLimit' method with the same parameters after obtaining the service. As long as getService() is ensuring the same contract as ActivityManagerNative.getDefault(), this should not cause a Compatibility Issue; thus the CI type is 0."
22,<android.os.Parcel: void writeException(Exception)>,25,26,<android.os.Parcel: void writeException(Exception)>,<android.os.Parcel: void writeException(Exception)>,0,"{
    int code = 0;
    if (e instanceof SecurityException) {
        code = EX_SECURITY;
    } else if (e instanceof BadParcelableException) {
        code = EX_BAD_PARCELABLE;
    } else if (e instanceof IllegalArgumentException) {
        code = EX_ILLEGAL_ARGUMENT;
    } else if (e instanceof NullPointerException) {
        code = EX_NULL_POINTER;
    } else if (e instanceof IllegalStateException) {
        code = EX_ILLEGAL_STATE;
    } else if (e instanceof NetworkOnMainThreadException) {
        code = EX_NETWORK_MAIN_THREAD;
    } else if (e instanceof UnsupportedOperationException) {
        code = EX_UNSUPPORTED_OPERATION;
    } else if (e instanceof ServiceSpecificException) {
        code = EX_SERVICE_SPECIFIC;
    }
    writeInt(code);
    StrictMode.clearGatheredViolations();
    if (code == 0) {
        if (e instanceof RuntimeException) {
            throw (RuntimeException) e;
        }
        throw new RuntimeException(e);
    }
    writeString(e.getMessage());
    if (e instanceof ServiceSpecificException) {
        writeInt(((ServiceSpecificException) e).errorCode);
    }
}","{
    int code = 0;
    if (e instanceof Parcelable && (e.getClass().getClassLoader() == Parcelable.class.getClassLoader())) {
        // We only send Parcelable exceptions that are in the
        // BootClassLoader to ensure that the receiver can unpack them
        code = EX_PARCELABLE;
    } else if (e instanceof SecurityException) {
        code = EX_SECURITY;
    } else if (e instanceof BadParcelableException) {
        code = EX_BAD_PARCELABLE;
    } else if (e instanceof IllegalArgumentException) {
        code = EX_ILLEGAL_ARGUMENT;
    } else if (e instanceof NullPointerException) {
        code = EX_NULL_POINTER;
    } else if (e instanceof IllegalStateException) {
        code = EX_ILLEGAL_STATE;
    } else if (e instanceof NetworkOnMainThreadException) {
        code = EX_NETWORK_MAIN_THREAD;
    } else if (e instanceof UnsupportedOperationException) {
        code = EX_UNSUPPORTED_OPERATION;
    } else if (e instanceof ServiceSpecificException) {
        code = EX_SERVICE_SPECIFIC;
    }
    writeInt(code);
    StrictMode.clearGatheredViolations();
    if (code == 0) {
        if (e instanceof RuntimeException) {
            throw (RuntimeException) e;
        }
        throw new RuntimeException(e);
    }
    writeString(e.getMessage());
    switch(code) {
        case EX_SERVICE_SPECIFIC:
            writeInt(((ServiceSpecificException) e).errorCode);
            break;
        case EX_PARCELABLE:
            // Write parceled exception prefixed by length
            final int sizePosition = dataPosition();
            writeInt(0);
            writeParcelable((Parcelable) e, Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
            final int payloadPosition = dataPosition();
            setDataPosition(sizePosition);
            writeInt(payloadPosition - sizePosition);
            setDataPosition(payloadPosition);
            break;
    }
}",1,"/**
 * Special function for writing an exception result at the header of
 * a parcel, to be used when returning an exception from a transaction.
 * Note that this currently only supports a few exception types; any other
 * exception will be re-thrown by this function as a RuntimeException
 * (to be caught by the system's last-resort exception handling when
 * dispatching a transaction).
 *
 * <p>The supported exception types are:
 * <ul>
 * <li>{@link BadParcelableException}
 * <li>{@link IllegalArgumentException}
 * <li>{@link IllegalStateException}
 * <li>{@link NullPointerException}
 * <li>{@link SecurityException}
 * <li>{@link NetworkOnMainThreadException}
 * </ul>
 *
 * @param e The Exception to be written.
 *
 * @see #writeNoException
 * @see #readException
 */
","/**
 * Special function for writing an exception result at the header of
 * a parcel, to be used when returning an exception from a transaction.
 * Note that this currently only supports a few exception types; any other
 * exception will be re-thrown by this function as a RuntimeException
 * (to be caught by the system's last-resort exception handling when
 * dispatching a transaction).
 *
 * <p>The supported exception types are:
 * <ul>
 * <li>{@link BadParcelableException}
 * <li>{@link IllegalArgumentException}
 * <li>{@link IllegalStateException}
 * <li>{@link NullPointerException}
 * <li>{@link SecurityException}
 * <li>{@link NetworkOnMainThreadException}
 * </ul>
 *
 * @param e The Exception to be written.
 *
 * @see #writeNoException
 * @see #readException
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,5","1,2","The `writeException` method has been modified to support the handling of Parcelable exceptions with a special class loader condition, a new check for `Parcelable` at the beginning of the `if-else` chain is introduced, the way `ServiceSpecificException` is handled has been moved into a new `switch` block, and a new case `EX_PARCELABLE` for writing Parcelable exceptions has been added. These are control dependency changes (code 3) because the control flow is altered, and other statement changes due to the added block for writing Parcelable exceptions (code 5). Additionally, an exception handling statement now throws `RuntimeException` directly for unknown exceptions rather than only when `code == 0`, which is a change in exception handling (code 2).","The changes in control flow, handling of parcelable exceptions, and the direct throwing of a `RuntimeException` can cause this method to behave differently between versions. If an exception is an instance of Parcelable and has the BootClassLoader, it will now be written to the Parcel in a special manner instead of throwing, which is a potential compatibility issue due to different return types or values (CI 1). Moreover, the method will behave differently when exceptions occur, potentially leading to a different kind of exception being thrown, introducing a compatibility issue due to different exception handlings (CI 2)."
23,<android.app.FragmentManagerImpl: Parcelable saveAllState()>,25,26,<android.app.FragmentManagerImpl: Parcelable saveAllState()>,<android.app.FragmentManagerImpl: Parcelable saveAllState()>,0,"{
    // Make sure all pending operations have now been executed to get
    // our state update-to-date.
    execPendingActions();
    mStateSaved = true;
    if (mActive == null || mActive.size() <= 0) {
        return null;
    }
    // First collect all active fragments.
    int N = mActive.size();
    FragmentState[] active = new FragmentState[N];
    boolean haveFragments = false;
    for (int i = 0; i < N; i++) {
        Fragment f = mActive.get(i);
        if (f != null) {
            if (f.mIndex < 0) {
                throwException(new IllegalStateException(""Failure saving state: active "" + f + "" has cleared index: "" + f.mIndex));
            }
            haveFragments = true;
            FragmentState fs = new FragmentState(f);
            active[i] = fs;
            if (f.mState > Fragment.INITIALIZING && fs.mSavedFragmentState == null) {
                fs.mSavedFragmentState = saveFragmentBasicState(f);
                if (f.mTarget != null) {
                    if (f.mTarget.mIndex < 0) {
                        throwException(new IllegalStateException(""Failure saving state: "" + f + "" has target not in fragment manager: "" + f.mTarget));
                    }
                    if (fs.mSavedFragmentState == null) {
                        fs.mSavedFragmentState = new Bundle();
                    }
                    putFragment(fs.mSavedFragmentState, FragmentManagerImpl.TARGET_STATE_TAG, f.mTarget);
                    if (f.mTargetRequestCode != 0) {
                        fs.mSavedFragmentState.putInt(FragmentManagerImpl.TARGET_REQUEST_CODE_STATE_TAG, f.mTargetRequestCode);
                    }
                }
            } else {
                fs.mSavedFragmentState = f.mSavedFragmentState;
            }
            if (DEBUG)
                Log.v(TAG, ""Saved state of "" + f + "": "" + fs.mSavedFragmentState);
        }
    }
    if (!haveFragments) {
        if (DEBUG)
            Log.v(TAG, ""saveAllState: no fragments!"");
        return null;
    }
    int[] added = null;
    BackStackState[] backStack = null;
    // Build list of currently added fragments.
    if (mAdded != null) {
        N = mAdded.size();
        if (N > 0) {
            added = new int[N];
            for (int i = 0; i < N; i++) {
                added[i] = mAdded.get(i).mIndex;
                if (added[i] < 0) {
                    throwException(new IllegalStateException(""Failure saving state: active "" + mAdded.get(i) + "" has cleared index: "" + added[i]));
                }
                if (DEBUG)
                    Log.v(TAG, ""saveAllState: adding fragment #"" + i + "": "" + mAdded.get(i));
            }
        }
    }
    // Now save back stack.
    if (mBackStack != null) {
        N = mBackStack.size();
        if (N > 0) {
            backStack = new BackStackState[N];
            for (int i = 0; i < N; i++) {
                backStack[i] = new BackStackState(this, mBackStack.get(i));
                if (DEBUG)
                    Log.v(TAG, ""saveAllState: adding back stack #"" + i + "": "" + mBackStack.get(i));
            }
        }
    }
    FragmentManagerState fms = new FragmentManagerState();
    fms.mActive = active;
    fms.mAdded = added;
    fms.mBackStack = backStack;
    return fms;
}","{
    // Make sure all pending operations have now been executed to get
    // our state update-to-date.
    forcePostponedTransactions();
    endAnimatingAwayFragments();
    execPendingActions();
    mStateSaved = true;
    mSavedNonConfig = null;
    if (mActive == null || mActive.size() <= 0) {
        return null;
    }
    // First collect all active fragments.
    int N = mActive.size();
    FragmentState[] active = new FragmentState[N];
    boolean haveFragments = false;
    for (int i = 0; i < N; i++) {
        Fragment f = mActive.valueAt(i);
        if (f != null) {
            if (f.mIndex < 0) {
                throwException(new IllegalStateException(""Failure saving state: active "" + f + "" has cleared index: "" + f.mIndex));
            }
            haveFragments = true;
            FragmentState fs = new FragmentState(f);
            active[i] = fs;
            if (f.mState > Fragment.INITIALIZING && fs.mSavedFragmentState == null) {
                fs.mSavedFragmentState = saveFragmentBasicState(f);
                if (f.mTarget != null) {
                    if (f.mTarget.mIndex < 0) {
                        throwException(new IllegalStateException(""Failure saving state: "" + f + "" has target not in fragment manager: "" + f.mTarget));
                    }
                    if (fs.mSavedFragmentState == null) {
                        fs.mSavedFragmentState = new Bundle();
                    }
                    putFragment(fs.mSavedFragmentState, FragmentManagerImpl.TARGET_STATE_TAG, f.mTarget);
                    if (f.mTargetRequestCode != 0) {
                        fs.mSavedFragmentState.putInt(FragmentManagerImpl.TARGET_REQUEST_CODE_STATE_TAG, f.mTargetRequestCode);
                    }
                }
            } else {
                fs.mSavedFragmentState = f.mSavedFragmentState;
            }
            if (DEBUG)
                Log.v(TAG, ""Saved state of "" + f + "": "" + fs.mSavedFragmentState);
        }
    }
    if (!haveFragments) {
        if (DEBUG)
            Log.v(TAG, ""saveAllState: no fragments!"");
        return null;
    }
    int[] added = null;
    BackStackState[] backStack = null;
    // Build list of currently added fragments.
    if (mAdded != null) {
        N = mAdded.size();
        if (N > 0) {
            added = new int[N];
            for (int i = 0; i < N; i++) {
                added[i] = mAdded.get(i).mIndex;
                if (added[i] < 0) {
                    throwException(new IllegalStateException(""Failure saving state: active "" + mAdded.get(i) + "" has cleared index: "" + added[i]));
                }
                if (DEBUG)
                    Log.v(TAG, ""saveAllState: adding fragment #"" + i + "": "" + mAdded.get(i));
            }
        }
    }
    // Now save back stack.
    if (mBackStack != null) {
        N = mBackStack.size();
        if (N > 0) {
            backStack = new BackStackState[N];
            for (int i = 0; i < N; i++) {
                backStack[i] = new BackStackState(this, mBackStack.get(i));
                if (DEBUG)
                    Log.v(TAG, ""saveAllState: adding back stack #"" + i + "": "" + mBackStack.get(i));
            }
        }
    }
    FragmentManagerState fms = new FragmentManagerState();
    fms.mActive = active;
    fms.mAdded = added;
    fms.mBackStack = backStack;
    fms.mNextFragmentIndex = mNextFragmentIndex;
    if (mPrimaryNav != null) {
        fms.mPrimaryNavActiveIndex = mPrimaryNav.mIndex;
    }
    saveNonConfig();
    return fms;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
25,<android.hardware.camera2.impl.CameraCaptureSessionImpl: StateCallbackKK getDeviceStateCallback()>,25,26,<android.hardware.camera2.impl.CameraCaptureSessionImpl: StateCallbackKK getDeviceStateCallback()>,<android.hardware.camera2.impl.CameraCaptureSessionImpl: StateCallbackKK getDeviceStateCallback()>,0,"{
    final CameraCaptureSession session = this;
    return new CameraDeviceImpl.StateCallbackKK() {

        private boolean mBusy = false;

        private boolean mActive = false;

        @Override
        public void onOpened(CameraDevice camera) {
            throw new AssertionError(""Camera must already be open before creating a session"");
        }

        @Override
        public void onDisconnected(CameraDevice camera) {
            if (DEBUG)
                Log.v(TAG, mIdString + ""onDisconnected"");
            close();
        }

        @Override
        public void onError(CameraDevice camera, int error) {
            // Should not be reached, handled by device code
            Log.wtf(TAG, mIdString + ""Got device error "" + error);
        }

        @Override
        public void onActive(CameraDevice camera) {
            mIdleDrainer.taskStarted();
            mActive = true;
            if (DEBUG)
                Log.v(TAG, mIdString + ""onActive"");
            mStateCallback.onActive(session);
        }

        @Override
        public void onIdle(CameraDevice camera) {
            boolean isAborting;
            if (DEBUG)
                Log.v(TAG, mIdString + ""onIdle"");
            synchronized (session) {
                isAborting = mAborting;
            }
            /*
                 * Check which states we transitioned through:
                 *
                 * (ACTIVE -> IDLE)
                 * (BUSY -> IDLE)
                 *
                 * Note that this is also legal:
                 * (ACTIVE -> BUSY -> IDLE)
                 *
                 * and mark those tasks as finished
                 */
            if (mBusy && isAborting) {
                mAbortDrainer.taskFinished();
                synchronized (session) {
                    mAborting = false;
                }
            }
            if (mActive) {
                mIdleDrainer.taskFinished();
            }
            mBusy = false;
            mActive = false;
            mStateCallback.onReady(session);
        }

        @Override
        public void onBusy(CameraDevice camera) {
            mBusy = true;
            // Don't signal the application since there's no clean mapping here
            if (DEBUG)
                Log.v(TAG, mIdString + ""onBusy"");
        }

        @Override
        public void onUnconfigured(CameraDevice camera) {
            if (DEBUG)
                Log.v(TAG, mIdString + ""onUnconfigured"");
        }

        @Override
        public void onSurfacePrepared(Surface surface) {
            if (DEBUG)
                Log.v(TAG, mIdString + ""onPrepared"");
            mStateCallback.onSurfacePrepared(session, surface);
        }
    };
}","{
    final CameraCaptureSession session = this;
    return new CameraDeviceImpl.StateCallbackKK() {

        private boolean mBusy = false;

        private boolean mActive = false;

        @Override
        public void onOpened(CameraDevice camera) {
            throw new AssertionError(""Camera must already be open before creating a session"");
        }

        @Override
        public void onDisconnected(CameraDevice camera) {
            if (DEBUG)
                Log.v(TAG, mIdString + ""onDisconnected"");
            close();
        }

        @Override
        public void onError(CameraDevice camera, int error) {
            // Should not be reached, handled by device code
            Log.wtf(TAG, mIdString + ""Got device error "" + error);
        }

        @Override
        public void onActive(CameraDevice camera) {
            mIdleDrainer.taskStarted();
            mActive = true;
            if (DEBUG)
                Log.v(TAG, mIdString + ""onActive"");
            mStateCallback.onActive(session);
        }

        @Override
        public void onIdle(CameraDevice camera) {
            boolean isAborting;
            if (DEBUG)
                Log.v(TAG, mIdString + ""onIdle"");
            synchronized (session) {
                isAborting = mAborting;
            }
            /*
                 * Check which states we transitioned through:
                 *
                 * (ACTIVE -> IDLE)
                 * (BUSY -> IDLE)
                 *
                 * Note that this is also legal:
                 * (ACTIVE -> BUSY -> IDLE)
                 *
                 * and mark those tasks as finished
                 */
            if (mBusy && isAborting) {
                mAbortDrainer.taskFinished();
                synchronized (session) {
                    mAborting = false;
                }
            }
            if (mActive) {
                mIdleDrainer.taskFinished();
            }
            mBusy = false;
            mActive = false;
            mStateCallback.onReady(session);
        }

        @Override
        public void onBusy(CameraDevice camera) {
            mBusy = true;
            // Don't signal the application since there's no clean mapping here
            if (DEBUG)
                Log.v(TAG, mIdString + ""onBusy"");
        }

        @Override
        public void onUnconfigured(CameraDevice camera) {
            if (DEBUG)
                Log.v(TAG, mIdString + ""onUnconfigured"");
        }

        @Override
        public void onRequestQueueEmpty() {
            if (DEBUG)
                Log.v(TAG, mIdString + ""onRequestQueueEmpty"");
            mStateCallback.onCaptureQueueEmpty(session);
        }

        @Override
        public void onSurfacePrepared(Surface surface) {
            if (DEBUG)
                Log.v(TAG, mIdString + ""onSurfacePrepared"");
            mStateCallback.onSurfacePrepared(session, surface);
        }
    };
}",1,"/**
 * Create an internal state callback, to be invoked on the mDeviceHandler
 *
 * <p>It has a few behaviors:
 * <ul>
 * <li>Convert device state changes into session state changes.
 * <li>Keep track of async tasks that the session began (idle, abort).
 * </ul>
 * </p>
 */
","/**
 * Create an internal state callback, to be invoked on the mDeviceHandler
 *
 * <p>It has a few behaviors:
 * <ul>
 * <li>Convert device state changes into session state changes.
 * <li>Keep track of async tasks that the session began (idle, abort).
 * </ul>
 * </p>
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
26,<android.app.Activity: void startLocalVoiceInteraction(Bundle)>,25,26,<android.app.Activity: void startLocalVoiceInteraction(Bundle)>,<android.app.Activity: void startLocalVoiceInteraction(Bundle)>,0,"{
    try {
        ActivityManagerNative.getDefault().startLocalVoiceInteraction(mToken, privateOptions);
    } catch (RemoteException re) {
    }
}","{
    try {
        ActivityManager.getService().startLocalVoiceInteraction(mToken, privateOptions);
    } catch (RemoteException re) {
    }
}",1,"/**
 * Starts a local voice interaction session. When ready,
 * {@link #onLocalVoiceInteractionStarted()} is called. You can pass a bundle of private options
 * to the registered voice interaction service.
 * @param privateOptions a Bundle of private arguments to the current voice interaction service
 */
","/**
 * Starts a local voice interaction session. When ready,
 * {@link #onLocalVoiceInteractionStarted()} is called. You can pass a bundle of private options
 * to the registered voice interaction service.
 * @param privateOptions a Bundle of private arguments to the current voice interaction service
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method called inside the try block has changed from ActivityManagerNative.getDefault().startLocalVoiceInteraction to ActivityManager.getService().startLocalVoiceInteraction, but the actual implementation logic has not changed, so the code change type is 4,5.","This change does not lead to a Compatibility Issue because the method name and behavior for starting local voice interaction seems to remain the same. The API service object retrieval method changed, but it should still provide the same functionality without changing the expected behavior to the caller. The try-catch block remains the same, thus exceptions are also handled in the same way."
27,<android.text.method.DateTimeKeyListener: int getInputType()>,25,26,<android.text.method.DateTimeKeyListener: int getInputType()>,<android.text.method.DateTimeKeyListener: int getInputType()>,0,"{
    return InputType.TYPE_CLASS_DATETIME | InputType.TYPE_DATETIME_VARIATION_NORMAL;
}","{
    if (mNeedsAdvancedInput) {
        return InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_NORMAL;
    } else {
        return InputType.TYPE_CLASS_DATETIME | InputType.TYPE_DATETIME_VARIATION_NORMAL;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The late version of the code has introduced a new condition with a control dependency 'if' statement, and this new control block returns a different value based on the condition, so the changes involve both a control dependency and other statements, which classifies the change type as 3,4.","The addition of a conditional check which determines the return value introduces the possibility of the API returning a different input type. Therefore, this modification can result in a different return value depending on the state of `mNeedsAdvancedInput`. This presents a potential Compatibility Issue due to the potential for different return values or types, classified as CI type 1."
29,<android.app.job.JobInfo: long getInitialBackoffMillis()>,25,26,<android.app.job.JobInfo: long getInitialBackoffMillis()>,<android.app.job.JobInfo: long getInitialBackoffMillis()>,0,"{
    return initialBackoffMillis;
}","{
    final long minBackoff = getMinBackoffMillis();
    return initialBackoffMillis >= minBackoff ? initialBackoffMillis : minBackoff;
}",1,"/**
 * The amount of time the JobScheduler will wait before rescheduling a failed job. This value
 * will be increased depending on the backoff policy specified at job creation time. Defaults
 * to 5 seconds.
 */
","/**
 * The amount of time the JobScheduler will wait before rescheduling a failed job. This value
 * will be increased depending on the backoff policy specified at job creation time. Defaults
 * to 30 seconds, minimum is currently 10 seconds.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed to include a conditional check, which compares initialBackoffMillis with minBackoff and also there is a new call to the method getMinBackoffMillis(), so the changes are classified as type 1,5.","The modified implementation includes a new condition that could potentially return a different value (minimum backoff time) if the initialBackoffMillis is less than minBackoff. This modification leads to a change in the behavior of the API that could result in a different return value, so the CI type is 1."
30,<android.widget.TextView: void onProvideStructure(ViewStructure)>,25,26,<android.widget.TextView: void onProvideStructure(ViewStructure)>,<android.widget.TextView: void onProvideStructure(ViewStructure)>,0,"{
    super.onProvideStructure(structure);
    final boolean isPassword = hasPasswordTransformationMethod() || isPasswordInputType(getInputType());
    if (!isPassword) {
        if (mLayout == null) {
            assumeLayout();
        }
        Layout layout = mLayout;
        final int lineCount = layout.getLineCount();
        if (lineCount <= 1) {
            // Simple case: this is a single line.
            structure.setText(getText(), getSelectionStart(), getSelectionEnd());
        } else {
            // Complex case: multi-line, could be scrolled or within a scroll container
            // so some lines are not visible.
            final int[] tmpCords = new int[2];
            getLocationInWindow(tmpCords);
            final int topWindowLocation = tmpCords[1];
            View root = this;
            ViewParent viewParent = getParent();
            while (viewParent instanceof View) {
                root = (View) viewParent;
                viewParent = root.getParent();
            }
            final int windowHeight = root.getHeight();
            final int topLine;
            final int bottomLine;
            if (topWindowLocation >= 0) {
                // The top of the view is fully within its window; start text at line 0.
                topLine = getLineAtCoordinateUnclamped(0);
                bottomLine = getLineAtCoordinateUnclamped(windowHeight - 1);
            } else {
                // The top of hte window has scrolled off the top of the window; figure out
                // the starting line for this.
                topLine = getLineAtCoordinateUnclamped(-topWindowLocation);
                bottomLine = getLineAtCoordinateUnclamped(windowHeight - 1 - topWindowLocation);
            }
            // We want to return some contextual lines above/below the lines that are
            // actually visible.
            int expandedTopLine = topLine - (bottomLine - topLine) / 2;
            if (expandedTopLine < 0) {
                expandedTopLine = 0;
            }
            int expandedBottomLine = bottomLine + (bottomLine - topLine) / 2;
            if (expandedBottomLine >= lineCount) {
                expandedBottomLine = lineCount - 1;
            }
            // Convert lines into character offsets.
            int expandedTopChar = layout.getLineStart(expandedTopLine);
            int expandedBottomChar = layout.getLineEnd(expandedBottomLine);
            // Take into account selection -- if there is a selection, we need to expand
            // the text we are returning to include that selection.
            final int selStart = getSelectionStart();
            final int selEnd = getSelectionEnd();
            if (selStart < selEnd) {
                if (selStart < expandedTopChar) {
                    expandedTopChar = selStart;
                }
                if (selEnd > expandedBottomChar) {
                    expandedBottomChar = selEnd;
                }
            }
            // Get the text and trim it to the range we are reporting.
            CharSequence text = getText();
            if (expandedTopChar > 0 || expandedBottomChar < text.length()) {
                text = text.subSequence(expandedTopChar, expandedBottomChar);
            }
            structure.setText(text, selStart - expandedTopChar, selEnd - expandedTopChar);
            final int[] lineOffsets = new int[bottomLine - topLine + 1];
            final int[] lineBaselines = new int[bottomLine - topLine + 1];
            final int baselineOffset = getBaselineOffset();
            for (int i = topLine; i <= bottomLine; i++) {
                lineOffsets[i - topLine] = layout.getLineStart(i);
                lineBaselines[i - topLine] = layout.getLineBaseline(i) + baselineOffset;
            }
            structure.setTextLines(lineOffsets, lineBaselines);
        }
        // Extract style information that applies to the TextView as a whole.
        int style = 0;
        int typefaceStyle = getTypefaceStyle();
        if ((typefaceStyle & Typeface.BOLD) != 0) {
            style |= AssistStructure.ViewNode.TEXT_STYLE_BOLD;
        }
        if ((typefaceStyle & Typeface.ITALIC) != 0) {
            style |= AssistStructure.ViewNode.TEXT_STYLE_ITALIC;
        }
        // Global styles can also be set via TextView.setPaintFlags().
        int paintFlags = mTextPaint.getFlags();
        if ((paintFlags & Paint.FAKE_BOLD_TEXT_FLAG) != 0) {
            style |= AssistStructure.ViewNode.TEXT_STYLE_BOLD;
        }
        if ((paintFlags & Paint.UNDERLINE_TEXT_FLAG) != 0) {
            style |= AssistStructure.ViewNode.TEXT_STYLE_UNDERLINE;
        }
        if ((paintFlags & Paint.STRIKE_THRU_TEXT_FLAG) != 0) {
            style |= AssistStructure.ViewNode.TEXT_STYLE_STRIKE_THRU;
        }
        // TextView does not have its own text background color. A background is either part
        // of the View (and can be any drawable) or a BackgroundColorSpan inside the text.
        structure.setTextStyle(getTextSize(), getCurrentTextColor(), AssistStructure.ViewNode.TEXT_COLOR_UNDEFINED, /* bgColor */
        style);
    }
    structure.setHint(getHint());
}","{
    super.onProvideStructure(structure);
    onProvideAutoStructureForAssistOrAutofill(structure, false);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
31,<android.widget.LinearLayout: void setDividerDrawable(Drawable)>,25,26,<android.widget.LinearLayout: void setDividerDrawable(Drawable)>,<android.widget.LinearLayout: void setDividerDrawable(Drawable)>,0,"{
    if (divider == mDivider) {
        return;
    }
    mDivider = divider;
    if (divider != null) {
        mDividerWidth = divider.getIntrinsicWidth();
        mDividerHeight = divider.getIntrinsicHeight();
    } else {
        mDividerWidth = 0;
        mDividerHeight = 0;
    }
    setWillNotDraw(divider == null);
    requestLayout();
}","{
    if (divider == mDivider) {
        return;
    }
    mDivider = divider;
    if (divider != null) {
        mDividerWidth = divider.getIntrinsicWidth();
        mDividerHeight = divider.getIntrinsicHeight();
    } else {
        mDividerWidth = 0;
        mDividerHeight = 0;
    }
    setWillNotDraw(!isShowingDividers());
    requestLayout();
}",1,"/**
 * Set a drawable to be used as a divider between items.
 *
 * @param divider Drawable that will divide each item.
 *
 * @see #setShowDividers(int)
 *
 * @attr ref android.R.styleable#LinearLayout_divider
 */
","/**
 * Set a drawable to be used as a divider between items.
 *
 * @param divider Drawable that will divide each item.
 *
 * @see #setShowDividers(int)
 *
 * @attr ref android.R.styleable#LinearLayout_divider
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The change is in the parameter passed to the setWillNotDraw() method from 'divider == null' to '!isShowingDividers()', which reflects a control dependency change (3), as well as another method invocation (4).",There is no Compatibility Issue from this change as the modification in the method call to setWillNotDraw() does not affect the method's return type or value (since the method returns void) and does not introduce any new exceptions that it might throw.
33,<android.widget.PopupWindow: void dismiss()>,25,26,<android.widget.PopupWindow: void dismiss()>,<android.widget.PopupWindow: void dismiss()>,0,"{
    if (!isShowing() || mIsTransitioningToDismiss) {
        return;
    }
    final PopupDecorView decorView = mDecorView;
    final View contentView = mContentView;
    final ViewGroup contentHolder;
    final ViewParent contentParent = contentView.getParent();
    if (contentParent instanceof ViewGroup) {
        contentHolder = ((ViewGroup) contentParent);
    } else {
        contentHolder = null;
    }
    // Ensure any ongoing or pending transitions are canceled.
    decorView.cancelTransitions();
    mIsShowing = false;
    mIsTransitioningToDismiss = true;
    // This method may be called as part of window detachment, in which
    // case the anchor view (and its root) will still return true from
    // isAttachedToWindow() during execution of this method; however, we
    // can expect the OnAttachStateChangeListener to have been called prior
    // to executing this method, so we can rely on that instead.
    final Transition exitTransition = mExitTransition;
    if (mIsAnchorRootAttached && exitTransition != null && decorView.isLaidOut()) {
        // The decor view is non-interactive and non-IME-focusable during exit transitions.
        final LayoutParams p = (LayoutParams) decorView.getLayoutParams();
        p.flags |= LayoutParams.FLAG_NOT_TOUCHABLE;
        p.flags |= LayoutParams.FLAG_NOT_FOCUSABLE;
        p.flags &= ~LayoutParams.FLAG_ALT_FOCUSABLE_IM;
        mWindowManager.updateViewLayout(decorView, p);
        // Once we start dismissing the decor view, all state (including
        // the anchor root) needs to be moved to the decor view since we
        // may open another popup while it's busy exiting.
        final View anchorRoot = mAnchorRoot != null ? mAnchorRoot.get() : null;
        final Rect epicenter = getTransitionEpicenter();
        exitTransition.setEpicenterCallback(new EpicenterCallback() {

            @Override
            public Rect onGetEpicenter(Transition transition) {
                return epicenter;
            }
        });
        decorView.startExitTransition(exitTransition, anchorRoot, new TransitionListenerAdapter() {

            @Override
            public void onTransitionEnd(Transition transition) {
                dismissImmediate(decorView, contentHolder, contentView);
            }
        });
    } else {
        dismissImmediate(decorView, contentHolder, contentView);
    }
    // Clears the anchor view.
    detachFromAnchor();
    if (mOnDismissListener != null) {
        mOnDismissListener.onDismiss();
    }
}","{
    if (!isShowing() || isTransitioningToDismiss()) {
        return;
    }
    final PopupDecorView decorView = mDecorView;
    final View contentView = mContentView;
    final ViewGroup contentHolder;
    final ViewParent contentParent = contentView.getParent();
    if (contentParent instanceof ViewGroup) {
        contentHolder = ((ViewGroup) contentParent);
    } else {
        contentHolder = null;
    }
    // Ensure any ongoing or pending transitions are canceled.
    decorView.cancelTransitions();
    mIsShowing = false;
    mIsTransitioningToDismiss = true;
    // This method may be called as part of window detachment, in which
    // case the anchor view (and its root) will still return true from
    // isAttachedToWindow() during execution of this method; however, we
    // can expect the OnAttachStateChangeListener to have been called prior
    // to executing this method, so we can rely on that instead.
    final Transition exitTransition = mExitTransition;
    if (exitTransition != null && decorView.isLaidOut() && (mIsAnchorRootAttached || mAnchorRoot == null)) {
        // The decor view is non-interactive and non-IME-focusable during exit transitions.
        final LayoutParams p = (LayoutParams) decorView.getLayoutParams();
        p.flags |= LayoutParams.FLAG_NOT_TOUCHABLE;
        p.flags |= LayoutParams.FLAG_NOT_FOCUSABLE;
        p.flags &= ~LayoutParams.FLAG_ALT_FOCUSABLE_IM;
        mWindowManager.updateViewLayout(decorView, p);
        final View anchorRoot = mAnchorRoot != null ? mAnchorRoot.get() : null;
        final Rect epicenter = getTransitionEpicenter();
        // Once we start dismissing the decor view, all state (including
        // the anchor root) needs to be moved to the decor view since we
        // may open another popup while it's busy exiting.
        decorView.startExitTransition(exitTransition, anchorRoot, epicenter, new TransitionListenerAdapter() {

            @Override
            public void onTransitionEnd(Transition transition) {
                dismissImmediate(decorView, contentHolder, contentView);
            }
        });
    } else {
        dismissImmediate(decorView, contentHolder, contentView);
    }
    // Clears the anchor view.
    detachFromAnchor();
    if (mOnDismissListener != null) {
        mOnDismissListener.onDismiss();
    }
}",1,"/**
 * Disposes of the popup window. This method can be invoked only after
 * {@link #showAsDropDown(android.view.View)} has been executed. Failing
 * that, calling this method will have no effect.
 *
 * @see #showAsDropDown(android.view.View)
 */
","/**
 * Disposes of the popup window. This method can be invoked only after
 * {@link #showAsDropDown(android.view.View)} has been executed. Failing
 * that, calling this method will have no effect.
 *
 * @see #showAsDropDown(android.view.View)
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
34,"<android.widget.RemoteViews.SetRemoteViewsAdapterIntent: void apply(View,ViewGroup,OnClickHandler)>",25,26,"<android.widget.RemoteViews.SetRemoteViewsAdapterIntent: void apply(View,ViewGroup,OnClickHandler)>","<android.widget.RemoteViews.SetRemoteViewsAdapterIntent: void apply(View,ViewGroup,OnClickHandler)>",0,"{
    final View target = root.findViewById(viewId);
    if (target == null)
        return;
    // Ensure that we are applying to an AppWidget root
    if (!(rootParent instanceof AppWidgetHostView)) {
        Log.e(LOG_TAG, ""SetRemoteViewsAdapterIntent action can only be used for "" + ""AppWidgets (root id: "" + viewId + "")"");
        return;
    }
    // Ensure that we are calling setRemoteAdapter on an AdapterView that supports it
    if (!(target instanceof AbsListView) && !(target instanceof AdapterViewAnimator)) {
        Log.e(LOG_TAG, ""Cannot setRemoteViewsAdapter on a view which is not "" + ""an AbsListView or AdapterViewAnimator (id: "" + viewId + "")"");
        return;
    }
    // Embed the AppWidget Id for use in RemoteViewsAdapter when connecting to the intent
    // RemoteViewsService
    AppWidgetHostView host = (AppWidgetHostView) rootParent;
    intent.putExtra(EXTRA_REMOTEADAPTER_APPWIDGET_ID, host.getAppWidgetId());
    if (target instanceof AbsListView) {
        AbsListView v = (AbsListView) target;
        v.setRemoteViewsAdapter(intent);
        v.setRemoteViewsOnClickHandler(handler);
    } else if (target instanceof AdapterViewAnimator) {
        AdapterViewAnimator v = (AdapterViewAnimator) target;
        v.setRemoteViewsAdapter(intent);
        v.setRemoteViewsOnClickHandler(handler);
    }
}","{
    final View target = root.findViewById(viewId);
    if (target == null)
        return;
    // Ensure that we are applying to an AppWidget root
    if (!(rootParent instanceof AppWidgetHostView)) {
        Log.e(LOG_TAG, ""SetRemoteViewsAdapterIntent action can only be used for "" + ""AppWidgets (root id: "" + viewId + "")"");
        return;
    }
    // Ensure that we are calling setRemoteAdapter on an AdapterView that supports it
    if (!(target instanceof AbsListView) && !(target instanceof AdapterViewAnimator)) {
        Log.e(LOG_TAG, ""Cannot setRemoteViewsAdapter on a view which is not "" + ""an AbsListView or AdapterViewAnimator (id: "" + viewId + "")"");
        return;
    }
    // Embed the AppWidget Id for use in RemoteViewsAdapter when connecting to the intent
    // RemoteViewsService
    AppWidgetHostView host = (AppWidgetHostView) rootParent;
    intent.putExtra(EXTRA_REMOTEADAPTER_APPWIDGET_ID, host.getAppWidgetId());
    if (target instanceof AbsListView) {
        AbsListView v = (AbsListView) target;
        v.setRemoteViewsAdapter(intent, isAsync);
        v.setRemoteViewsOnClickHandler(handler);
    } else if (target instanceof AdapterViewAnimator) {
        AdapterViewAnimator v = (AdapterViewAnimator) target;
        v.setRemoteViewsAdapter(intent, isAsync);
        v.setRemoteViewsOnClickHandler(handler);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The method `setRemoteViewsAdapter` has changed to include a new parameter `isAsync` in the late version, which implies there's a modification in the method signature. It means the change type is both 4 (Other statement changed because the method call is different) and 5 (Dependent API changed since the `setRemoteViewsAdapter` method has been changed to include a new parameter).","Despite the change in the statement that adds a new parameter to the `setRemoteViewsAdapter` of `AbsListView` or `AdapterViewAnimator`, this wouldn't constitute a backwards compatibility issue as the method `apply` itself does not return a value and the exception handling mechanism remains the same. The additional parameter is handled internally within the `apply` method and would not affect existing code that utilizes `apply`. Therefore, there is no Compatibility Issue (CI 0)."
35,"<android.app.FragmentManagerImpl: void popBackStack(int,int)>",25,26,"<android.app.FragmentManagerImpl: void popBackStack(int,int)>","<android.app.FragmentManagerImpl: void popBackStack(int,int)>",0,"{
    if (id < 0) {
        throw new IllegalArgumentException(""Bad id: "" + id);
    }
    enqueueAction(new Runnable() {

        @Override
        public void run() {
            popBackStackState(mHost.getHandler(), null, id, flags);
        }
    }, false);
}","{
    if (id < 0) {
        throw new IllegalArgumentException(""Bad id: "" + id);
    }
    enqueueAction(new PopBackStackState(null, id, flags), false);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The change has occurred in the way the action is enqueued. The anonymous Runnable implementation is replaced with a new instance of PopBackStackState, and it indicates a dependent API change because a different constructor or class is being used to define the action. However, the logic within the run method seems to be identical to the logic within the PopBackStackState, which suggests that the runnable action being enqueued is performing the same operation. This is an example of change type 4 due to the structural code change and type 5 since a different dependent API is used (PopBackStackState).","No Compatibility Issue could arise for this API change since the behavior of the 'popBackStackState()' method call remains the same. The modification is purely internal and does not affect the public-facing behavior or contract of the method. Thus, CI type is 0."
36,<android.app.ContextImpl: void sendStickyBroadcast(Intent)>,25,26,<android.app.ContextImpl: void sendStickyBroadcast(Intent)>,<android.app.ContextImpl: void sendStickyBroadcast(Intent)>,0,"{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, true, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, true, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,"[@Override, @Deprecated]","[@Override, @Deprecated]",-1,-1,-1,-1,-1,-1,5,0,"The method that is called to broadcast the intent has changed from ActivityManagerNative.getDefault().broadcastIntent(...) to ActivityManager.getService().broadcastIntent(...), indicating the dependent API has changed, so the code change type is 5.","Despite ActivityManagerNative.getDefault() being replaced with ActivityManager.getService(), this does not inherently lead to a Compatibility Issue because the method signatures for broadcastIntent(...) remain the same. Hence, as long as the ActivityManager.getService() is designed to return a similar object with a broadcastIntent(...) method that behaves the same way as the previous one, the behavior of sendStickyBroadcast(Intent) should remain consistent for the caller. Therefore, there would not be any Compatibility Issue."
37,<android.widget.TabHost: void setup()>,25,26,<android.widget.TabHost: void setup()>,<android.widget.TabHost: void setup()>,0,"{
    mTabWidget = (TabWidget) findViewById(com.android.internal.R.id.tabs);
    if (mTabWidget == null) {
        throw new RuntimeException(""Your TabHost must have a TabWidget whose id attribute is 'android.R.id.tabs'"");
    }
    // KeyListener to attach to all tabs. Detects non-navigation keys
    // and relays them to the tab content.
    mTabKeyListener = new OnKeyListener() {

        public boolean onKey(View v, int keyCode, KeyEvent event) {
            switch(keyCode) {
                case KeyEvent.KEYCODE_DPAD_CENTER:
                case KeyEvent.KEYCODE_DPAD_LEFT:
                case KeyEvent.KEYCODE_DPAD_RIGHT:
                case KeyEvent.KEYCODE_DPAD_UP:
                case KeyEvent.KEYCODE_DPAD_DOWN:
                case KeyEvent.KEYCODE_ENTER:
                    return false;
            }
            mTabContent.requestFocus(View.FOCUS_FORWARD);
            return mTabContent.dispatchKeyEvent(event);
        }
    };
    mTabWidget.setTabSelectionListener(new TabWidget.OnTabSelectionChanged() {

        public void onTabSelectionChanged(int tabIndex, boolean clicked) {
            setCurrentTab(tabIndex);
            if (clicked) {
                mTabContent.requestFocus(View.FOCUS_FORWARD);
            }
        }
    });
    mTabContent = (FrameLayout) findViewById(com.android.internal.R.id.tabcontent);
    if (mTabContent == null) {
        throw new RuntimeException(""Your TabHost must have a FrameLayout whose id attribute is "" + ""'android.R.id.tabcontent'"");
    }
}","{
    mTabWidget = findViewById(com.android.internal.R.id.tabs);
    if (mTabWidget == null) {
        throw new RuntimeException(""Your TabHost must have a TabWidget whose id attribute is 'android.R.id.tabs'"");
    }
    // KeyListener to attach to all tabs. Detects non-navigation keys
    // and relays them to the tab content.
    mTabKeyListener = new OnKeyListener() {

        public boolean onKey(View v, int keyCode, KeyEvent event) {
            switch(keyCode) {
                case KeyEvent.KEYCODE_DPAD_CENTER:
                case KeyEvent.KEYCODE_DPAD_LEFT:
                case KeyEvent.KEYCODE_DPAD_RIGHT:
                case KeyEvent.KEYCODE_DPAD_UP:
                case KeyEvent.KEYCODE_DPAD_DOWN:
                case KeyEvent.KEYCODE_ENTER:
                    return false;
            }
            mTabContent.requestFocus(View.FOCUS_FORWARD);
            return mTabContent.dispatchKeyEvent(event);
        }
    };
    mTabWidget.setTabSelectionListener(new TabWidget.OnTabSelectionChanged() {

        public void onTabSelectionChanged(int tabIndex, boolean clicked) {
            setCurrentTab(tabIndex);
            if (clicked) {
                mTabContent.requestFocus(View.FOCUS_FORWARD);
            }
        }
    });
    mTabContent = findViewById(com.android.internal.R.id.tabcontent);
    if (mTabContent == null) {
        throw new RuntimeException(""Your TabHost must have a FrameLayout whose id attribute is "" + ""'android.R.id.tabcontent'"");
    }
}",1,"/**
 * <p>Call setup() before adding tabs if loading TabHost using findViewById().
 * <i><b>However</i></b>: You do not need to call setup() after getTabHost()
 * in {@link android.app.TabActivity TabActivity}.
 * Example:</p>
 * <pre>mTabHost = (TabHost)findViewById(R.id.tabhost);
 * mTabHost.setup();
 * mTabHost.addTab(TAB_TAG_1, ""Hello, world!"", ""Tab 1"");
 */
","/**
 * <p>Call setup() before adding tabs if loading TabHost using findViewById().
 * <i><b>However</i></b>: You do not need to call setup() after getTabHost()
 * in {@link android.app.TabActivity TabActivity}.
 * Example:</p>
 * <pre>mTabHost = (TabHost)findViewById(R.id.tabhost);
 * mTabHost.setup();
 * mTabHost.addTab(TAB_TAG_1, ""Hello, world!"", ""Tab 1"");
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The type casting to `(TabWidget)` and `(FrameLayout)` for `findViewById` results has been removed. Since `findViewById` in recent versions of Android returns `<T extends View>` instead of `View`, explicit casting is not necessarily required. However, this should not affect the behavior of the API as long as `mTabWidget` and `mTabContent` are of the correct type. So the code change type is 4.","There is no Compatibility Issue here because the removal of explicit casting does not change the behavior of the method, assuming that the expected returned types from `findViewById` (TabWidget and FrameLayout, respectively) match the type of the class fields `mTabWidget` and `mTabContent`. The contract of the `findViewById` function should ensure that the correct type is returned, hence there should be no behavior change from the perspective of a client using the `setup()` method."
40,<android.app.FragmentManagerImpl: boolean execPendingActions()>,25,26,<android.app.FragmentManagerImpl: boolean execPendingActions()>,<android.app.FragmentManagerImpl: boolean execPendingActions()>,0,"{
    if (mExecutingActions) {
        throw new IllegalStateException(""Recursive entry to executePendingTransactions"");
    }
    if (Looper.myLooper() != mHost.getHandler().getLooper()) {
        throw new IllegalStateException(""Must be called from main thread of process"");
    }
    boolean didSomething = false;
    while (true) {
        int numActions;
        synchronized (this) {
            if (mPendingActions == null || mPendingActions.size() == 0) {
                break;
            }
            numActions = mPendingActions.size();
            if (mTmpActions == null || mTmpActions.length < numActions) {
                mTmpActions = new Runnable[numActions];
            }
            mPendingActions.toArray(mTmpActions);
            mPendingActions.clear();
            mHost.getHandler().removeCallbacks(mExecCommit);
        }
        mExecutingActions = true;
        for (int i = 0; i < numActions; i++) {
            mTmpActions[i].run();
            mTmpActions[i] = null;
        }
        mExecutingActions = false;
        didSomething = true;
    }
    doPendingDeferredStart();
    return didSomething;
}","{
    ensureExecReady(true);
    boolean didSomething = false;
    while (generateOpsForPendingActions(mTmpRecords, mTmpIsPop)) {
        mExecutingActions = true;
        try {
            removeRedundantOperationsAndExecute(mTmpRecords, mTmpIsPop);
        } finally {
            cleanupExec();
        }
        didSomething = true;
    }
    doPendingDeferredStart();
    burpActive();
    return didSomething;
}",1,"/**
 * Only call from main thread!
 */
","/**
 * Only call from main thread!
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5","1,2","The old implementation contains explicit checks, a while loop with synchronization, and array manipulations, which have been removed and replaced by a call to ensureExecReady(true) and the while loop condition has been altered. The method generateOpsForPendingActions is introduced, and there's a try-finally block where removeRedundantOperationsAndExecute is called followed by cleanupExec in the finally block. A call to the new method burpActive has been added at the end. Exception throwing logic has been altered as well, moving to ensureExecReady, removeRedundantOperationsAndExecute, and cleanupExec which likely have their own exception handling. Therefore, the return statements, control dependencies, other statements, and dependent APIs have been changed, so the code change types are 1,3,4,5.","The replacement of the while loop's logic and associated synchronization block with a new method that likely has a different implementation can cause a change in return values, as didSomething is set to true under potentially different conditions. Given the significant changes including removal and addition of functionality, exception handling has potentially changed too. Therefore, the CI types are 1 (for potential different return values) and 2 (for potential different exception handlings)."
41,<android.app.BackStackState: BackStackRecord instantiate(FragmentManagerImpl)>,25,26,<android.app.BackStackState: BackStackRecord instantiate(FragmentManagerImpl)>,<android.app.BackStackState: BackStackRecord instantiate(FragmentManagerImpl)>,0,"{
    BackStackRecord bse = new BackStackRecord(fm);
    int pos = 0;
    int num = 0;
    while (pos < mOps.length) {
        BackStackRecord.Op op = new BackStackRecord.Op();
        op.cmd = mOps[pos++];
        if (FragmentManagerImpl.DEBUG) {
            Log.v(FragmentManagerImpl.TAG, ""Instantiate "" + bse + "" op #"" + num + "" base fragment #"" + mOps[pos]);
        }
        int findex = mOps[pos++];
        if (findex >= 0) {
            Fragment f = fm.mActive.get(findex);
            op.fragment = f;
        } else {
            op.fragment = null;
        }
        op.enterAnim = mOps[pos++];
        op.exitAnim = mOps[pos++];
        op.popEnterAnim = mOps[pos++];
        op.popExitAnim = mOps[pos++];
        final int N = mOps[pos++];
        if (N > 0) {
            op.removed = new ArrayList<Fragment>(N);
            for (int i = 0; i < N; i++) {
                if (FragmentManagerImpl.DEBUG) {
                    Log.v(FragmentManagerImpl.TAG, ""Instantiate "" + bse + "" set remove fragment #"" + mOps[pos]);
                }
                Fragment r = fm.mActive.get(mOps[pos++]);
                op.removed.add(r);
            }
        }
        bse.mEnterAnim = op.enterAnim;
        bse.mExitAnim = op.exitAnim;
        bse.mPopEnterAnim = op.popEnterAnim;
        bse.mPopExitAnim = op.popExitAnim;
        bse.addOp(op);
        num++;
    }
    bse.mTransition = mTransition;
    bse.mTransitionStyle = mTransitionStyle;
    bse.mName = mName;
    bse.mIndex = mIndex;
    bse.mAddToBackStack = true;
    bse.mBreadCrumbTitleRes = mBreadCrumbTitleRes;
    bse.mBreadCrumbTitleText = mBreadCrumbTitleText;
    bse.mBreadCrumbShortTitleRes = mBreadCrumbShortTitleRes;
    bse.mBreadCrumbShortTitleText = mBreadCrumbShortTitleText;
    bse.mSharedElementSourceNames = mSharedElementSourceNames;
    bse.mSharedElementTargetNames = mSharedElementTargetNames;
    bse.bumpBackStackNesting(1);
    return bse;
}","{
    BackStackRecord bse = new BackStackRecord(fm);
    int pos = 0;
    int num = 0;
    while (pos < mOps.length) {
        BackStackRecord.Op op = new BackStackRecord.Op();
        op.cmd = mOps[pos++];
        if (FragmentManagerImpl.DEBUG) {
            Log.v(FragmentManagerImpl.TAG, ""Instantiate "" + bse + "" op #"" + num + "" base fragment #"" + mOps[pos]);
        }
        int findex = mOps[pos++];
        if (findex >= 0) {
            Fragment f = fm.mActive.get(findex);
            op.fragment = f;
        } else {
            op.fragment = null;
        }
        op.enterAnim = mOps[pos++];
        op.exitAnim = mOps[pos++];
        op.popEnterAnim = mOps[pos++];
        op.popExitAnim = mOps[pos++];
        bse.mEnterAnim = op.enterAnim;
        bse.mExitAnim = op.exitAnim;
        bse.mPopEnterAnim = op.popEnterAnim;
        bse.mPopExitAnim = op.popExitAnim;
        bse.addOp(op);
        num++;
    }
    bse.mTransition = mTransition;
    bse.mTransitionStyle = mTransitionStyle;
    bse.mName = mName;
    bse.mIndex = mIndex;
    bse.mAddToBackStack = true;
    bse.mBreadCrumbTitleRes = mBreadCrumbTitleRes;
    bse.mBreadCrumbTitleText = mBreadCrumbTitleText;
    bse.mBreadCrumbShortTitleRes = mBreadCrumbShortTitleRes;
    bse.mBreadCrumbShortTitleText = mBreadCrumbShortTitleText;
    bse.mSharedElementSourceNames = mSharedElementSourceNames;
    bse.mSharedElementTargetNames = mSharedElementTargetNames;
    bse.mReorderingAllowed = mReorderingAllowed;
    bse.bumpBackStackNesting(1);
    return bse;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,The main change in the late version is the addition of the line:,```
42,<android.view.ViewGroup: void dispatchProvideStructure(ViewStructure)>,25,26,<android.view.ViewGroup: void dispatchProvideStructure(ViewStructure)>,<android.view.ViewGroup: void dispatchProvideStructure(ViewStructure)>,0,"{
    super.dispatchProvideStructure(structure);
    if (!isAssistBlocked()) {
        if (structure.getChildCount() == 0) {
            final int childrenCount = getChildCount();
            if (childrenCount > 0) {
                structure.setChildCount(childrenCount);
                ArrayList<View> preorderedList = buildOrderedChildList();
                boolean customOrder = preorderedList == null && isChildrenDrawingOrderEnabled();
                final View[] children = mChildren;
                for (int i = 0; i < childrenCount; i++) {
                    int childIndex;
                    try {
                        childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);
                    } catch (IndexOutOfBoundsException e) {
                        childIndex = i;
                        if (mContext.getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.M) {
                            Log.w(TAG, ""Bad getChildDrawingOrder while collecting assist @ "" + i + "" of "" + childrenCount, e);
                            // At least one app is failing when we call getChildDrawingOrder
                            // at this point, so deal semi-gracefully with it by falling back
                            // on the basic order.
                            customOrder = false;
                            if (i > 0) {
                                // If we failed at the first index, there really isn't
                                // anything to do -- we will just proceed with the simple
                                // sequence order.
                                // Otherwise, we failed in the middle, so need to come up
                                // with an order for the remaining indices and use that.
                                // Failed at the first one, easy peasy.
                                int[] permutation = new int[childrenCount];
                                SparseBooleanArray usedIndices = new SparseBooleanArray();
                                // Go back and collected the indices we have done so far.
                                for (int j = 0; j < i; j++) {
                                    permutation[j] = getChildDrawingOrder(childrenCount, j);
                                    usedIndices.put(permutation[j], true);
                                }
                                // Fill in the remaining indices with indices that have not
                                // yet been used.
                                int nextIndex = 0;
                                for (int j = i; j < childrenCount; j++) {
                                    while (usedIndices.get(nextIndex, false)) {
                                        nextIndex++;
                                    }
                                    permutation[j] = nextIndex;
                                    nextIndex++;
                                }
                                // Build the final view list.
                                preorderedList = new ArrayList<>(childrenCount);
                                for (int j = 0; j < childrenCount; j++) {
                                    preorderedList.add(children[permutation[j]]);
                                }
                            }
                        } else {
                            throw e;
                        }
                    }
                    final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);
                    final ViewStructure cstructure = structure.newChild(i);
                    child.dispatchProvideStructure(cstructure);
                }
                if (preorderedList != null)
                    preorderedList.clear();
            }
        }
    }
}","{
    super.dispatchProvideStructure(structure);
    if (isAssistBlocked() || structure.getChildCount() != 0) {
        return;
    }
    final int childrenCount = mChildrenCount;
    if (childrenCount <= 0) {
        return;
    }
    structure.setChildCount(childrenCount);
    ArrayList<View> preorderedList = buildOrderedChildList();
    boolean customOrder = preorderedList == null && isChildrenDrawingOrderEnabled();
    for (int i = 0; i < childrenCount; i++) {
        int childIndex;
        try {
            childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);
        } catch (IndexOutOfBoundsException e) {
            childIndex = i;
            if (mContext.getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.M) {
                Log.w(TAG, ""Bad getChildDrawingOrder while collecting assist @ "" + i + "" of "" + childrenCount, e);
                // At least one app is failing when we call getChildDrawingOrder
                // at this point, so deal semi-gracefully with it by falling back
                // on the basic order.
                customOrder = false;
                if (i > 0) {
                    // If we failed at the first index, there really isn't
                    // anything to do -- we will just proceed with the simple
                    // sequence order.
                    // Otherwise, we failed in the middle, so need to come up
                    // with an order for the remaining indices and use that.
                    // Failed at the first one, easy peasy.
                    int[] permutation = new int[childrenCount];
                    SparseBooleanArray usedIndices = new SparseBooleanArray();
                    // Go back and collected the indices we have done so far.
                    for (int j = 0; j < i; j++) {
                        permutation[j] = getChildDrawingOrder(childrenCount, j);
                        usedIndices.put(permutation[j], true);
                    }
                    // Fill in the remaining indices with indices that have not
                    // yet been used.
                    int nextIndex = 0;
                    for (int j = i; j < childrenCount; j++) {
                        while (usedIndices.get(nextIndex, false)) {
                            nextIndex++;
                        }
                        permutation[j] = nextIndex;
                        nextIndex++;
                    }
                    // Build the final view list.
                    preorderedList = new ArrayList<>(childrenCount);
                    for (int j = 0; j < childrenCount; j++) {
                        final int index = permutation[j];
                        final View child = mChildren[index];
                        preorderedList.add(child);
                    }
                }
            } else {
                throw e;
            }
        }
        final View child = getAndVerifyPreorderedView(preorderedList, mChildren, childIndex);
        final ViewStructure cstructure = structure.newChild(i);
        child.dispatchProvideStructure(cstructure);
    }
    if (preorderedList != null) {
        preorderedList.clear();
    }
}",1,"/**
 * Dispatch creation of {@link ViewStructure} down the hierarchy.  This implementation
 * adds in all child views of the view group, in addition to calling the default View
 * implementation.
 */
","/**
 * Dispatch creation of {@link ViewStructure} down the hierarchy.  This implementation
 * adds in all child views of the view group, in addition to calling the default View
 * implementation.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
43,<android.text.method.TimeKeyListener: TimeKeyListener getInstance()>,25,26,<android.text.method.TimeKeyListener: TimeKeyListener getInstance()>,<android.text.method.TimeKeyListener: TimeKeyListener getInstance()>,0,"{
    if (sInstance != null)
        return sInstance;
    sInstance = new TimeKeyListener();
    return sInstance;
}","{
    return getInstance(null);
}",1,,"/**
 * @deprecated Use {@link #getInstance(Locale)} instead.
 */
",-1,,"[@Deprecated, @NonNull]",-1,-1,-1,-1,-1,-1,"4,5",0,"The method implementation has changed from direct instance handling to delegating the instance creation to another method (getInstance(null)), and a new dependent API (getInstance overloaded method with a parameter) is likely introduced which indicates a change type of 4,5.","There is no compatibility issue introduced by this change as long as the getInstance(null) method returns the same sInstance object, which the early version does. Assuming the getInstance(null) method is correctly implemented to maintain the singleton pattern, it will not lead to a change in the behavior of the API in terms of return values or exception handling. Hence, the CI type is 0."
44,"<android.app.Activity: void onProvideKeyboardShortcuts(List<KeyboardShortcutGroup>,Menu,int)>",25,26,"<android.app.Activity: void onProvideKeyboardShortcuts(List<KeyboardShortcutGroup>,Menu,int)>","<android.app.Activity: void onProvideKeyboardShortcuts(List<KeyboardShortcutGroup>,Menu,int)>",0,"{
    if (menu == null) {
        return;
    }
    KeyboardShortcutGroup group = null;
    int menuSize = menu.size();
    for (int i = 0; i < menuSize; ++i) {
        final MenuItem item = menu.getItem(i);
        final CharSequence title = item.getTitle();
        final char alphaShortcut = item.getAlphabeticShortcut();
        if (title != null && alphaShortcut != MIN_VALUE) {
            if (group == null) {
                final int resource = mApplication.getApplicationInfo().labelRes;
                group = new KeyboardShortcutGroup(resource != 0 ? getString(resource) : null);
            }
            group.addItem(new KeyboardShortcutInfo(title, alphaShortcut, KeyEvent.META_CTRL_ON));
        }
    }
    if (group != null) {
        data.add(group);
    }
}","{
    if (menu == null) {
        return;
    }
    KeyboardShortcutGroup group = null;
    int menuSize = menu.size();
    for (int i = 0; i < menuSize; ++i) {
        final MenuItem item = menu.getItem(i);
        final CharSequence title = item.getTitle();
        final char alphaShortcut = item.getAlphabeticShortcut();
        final int alphaModifiers = item.getAlphabeticModifiers();
        if (title != null && alphaShortcut != MIN_VALUE) {
            if (group == null) {
                final int resource = mApplication.getApplicationInfo().labelRes;
                group = new KeyboardShortcutGroup(resource != 0 ? getString(resource) : null);
            }
            group.addItem(new KeyboardShortcutInfo(title, alphaShortcut, alphaModifiers));
        }
    }
    if (group != null) {
        data.add(group);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The late version introduces a new variable 'alphaModifiers' and calls the 'getAlphabeticModifiers()' method on the MenuItem instance, which affects how KeyboardShortcutInfo instances are created. The previous version did not include this variable or the dependent API call. Based on the method signature, the return type of 'getAlphabeticModifiers()' is not included, but we can infer that there is a change in a dependent API which yields an impact on the object creation for 'KeyboardShortcutInfo'. Thus, the change type is classified as 4 (Other statement changed) and 5 (Dependent API changed).","Although a new variable and a dependent API call have been added, they do not result in a Compatibility Issue concerning the return type or exception handling of the method because the method's return type is 'void' and there are no changes to exception handling. The changes in the loop modify internal behavior but do not affect the overall method contract for callers. Therefore, the method does not have any Compatibility Issues (CI type 0)."
46,<android.net.NetworkRequest.Builder: Builder setNetworkSpecifier(String)>,25,26,<android.net.NetworkRequest.Builder: Builder setNetworkSpecifier(String)>,<android.net.NetworkRequest.Builder: Builder setNetworkSpecifier(String)>,0,"{
    if (NetworkCapabilities.MATCH_ALL_REQUESTS_NETWORK_SPECIFIER.equals(networkSpecifier)) {
        throw new IllegalArgumentException(""Invalid network specifier - must not be '"" + NetworkCapabilities.MATCH_ALL_REQUESTS_NETWORK_SPECIFIER + ""'"");
    }
    mNetworkCapabilities.setNetworkSpecifier(networkSpecifier);
    return this;
}","{
    /*
             * A StringNetworkSpecifier does not accept null or empty ("""") strings. When network
             * specifiers were strings a null string and an empty string were considered equivalent.
             * Hence no meaning is attached to a null or empty ("""") string.
             */
    return setNetworkSpecifier(TextUtils.isEmpty(networkSpecifier) ? null : new StringNetworkSpecifier(networkSpecifier));
}",1,"/**
 * Sets the optional bearer specific network specifier.
 * This has no meaning if a single transport is also not specified, so calling
 * this without a single transport set will generate an exception, as will
 * subsequently adding or removing transports after this is set.
 * </p>
 * The interpretation of this {@code String} is bearer specific and bearers that use
 * it should document their particulars.  For example, Bluetooth may use some sort of
 * device id while WiFi could used ssid and/or bssid.  Cellular may use carrier spn.
 *
 * @param networkSpecifier An {@code String} of opaque format used to specify the bearer
 * specific network specifier where the bearer has a choice of
 * networks.
 */
","/**
 * Sets the optional bearer specific network specifier.
 * This has no meaning if a single transport is also not specified, so calling
 * this without a single transport set will generate an exception, as will
 * subsequently adding or removing transports after this is set.
 * </p>
 * The interpretation of this {@code String} is bearer specific and bearers that use
 * it should document their particulars.  For example, Bluetooth may use some sort of
 * device id while WiFi could used ssid and/or bssid.  Cellular may use carrier spn.
 *
 * @param networkSpecifier An {@code String} of opaque format used to specify the bearer
 * specific network specifier where the bearer has a choice of
 * networks.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,4,5","1,2","Exception handling statement has changed by adding a new condition (TextUtils.isEmpty(networkSpecifier)) and removing the old IllegalArgumentException throw. The control dependency (if) has changed. A new dependent API (TextUtils.isEmpty and new StringNetworkSpecifier) is used in the late version, causing other statements to change as well. The code change type is 2,3,4,5.","The introduction of a new check (TextUtils.isEmpty(networkSpecifier)) can lead to different behavior if the string is empty or null, where the late version does not throw an IllegalArgumentException but instead calls setNetworkSpecifier(null). The changes in exception handling, control dependency, and introduction of new dependent APIs indicate both different return values and exception handlings could occur, hence the CI types are 1,2."
47,<android.bluetooth.BluetoothGatt: void close()>,25,26,<android.bluetooth.BluetoothGatt: void close()>,<android.bluetooth.BluetoothGatt: void close()>,0,"{
    if (DBG)
        Log.d(TAG, ""close()"");
    unregisterApp();
    mConnState = CONN_STATE_CLOSED;
}","{
    if (DBG)
        Log.d(TAG, ""close()"");
    unregisterApp();
    mConnState = CONN_STATE_CLOSED;
    mAuthRetryState = AUTH_RETRY_STATE_IDLE;
}",1,"/**
 * Close this Bluetooth GATT client.
 *
 * Application should call this method as early as possible after it is done with
 * this GATT client.
 */
","/**
 * Close this Bluetooth GATT client.
 *
 * Application should call this method as early as possible after it is done with
 * this GATT client.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"A new line of code mAuthRetryState = AUTH_RETRY_STATE_IDLE; is added, which is not affecting the return value or exception handling of the API. Therefore, the code change type is 4.","There is no Compatibility Issue since this change does not affect the API's behavior in terms of return values or exceptions thrown, it just alters the authentication retry state internally. The API still does not return any value and it does not throw any exceptions, so the output to the caller will not have changed."
48,<android.app.Activity: void recreate()>,25,26,<android.app.Activity: void recreate()>,<android.app.Activity: void recreate()>,0,"{
    if (mParent != null) {
        throw new IllegalStateException(""Can only be called on top-level activity"");
    }
    if (Looper.myLooper() != mMainThread.getLooper()) {
        throw new IllegalStateException(""Must be called from main thread"");
    }
    mMainThread.requestRelaunchActivity(mToken, null, null, 0, false, null, null, false, false);
}","{
    if (mParent != null) {
        throw new IllegalStateException(""Can only be called on top-level activity"");
    }
    if (Looper.myLooper() != mMainThread.getLooper()) {
        throw new IllegalStateException(""Must be called from main thread"");
    }
    try {
        ActivityManager.getService().requestActivityRelaunch(mToken);
    } catch (RemoteException e) {
    }
}",1,"/**
 * Cause this Activity to be recreated with a new instance.  This results
 * in essentially the same flow as when the Activity is created due to
 * a configuration change -- the current instance will go through its
 * lifecycle to {@link #onDestroy} and a new instance then created after it.
 */
","/**
 * Cause this Activity to be recreated with a new instance.  This results
 * in essentially the same flow as when the Activity is created due to
 * a configuration change -- the current instance will go through its
 * lifecycle to {@link #onDestroy} and a new instance then created after it.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method call mMainThread.requestRelaunchActivity(...) has been replaced with ActivityManager.getService().requestActivityRelaunch(mToken); with no new return statements and exception changes just wrapped within try-catch, so the code change types are 4 and 5.","There are no changes in the method's signature, and the return type remains void. Both the old and new implementations throw the same exceptions under the same conditions. The change in the internal implementation to initiate the activity relaunch does not lead to a divergence in behavior from the perspective of the method's caller thus there is no compatibility issue as the method's external behavior remains consistent."
49,<android.app.SharedPreferencesImpl.EditorImpl: boolean commit()>,25,26,<android.app.SharedPreferencesImpl.EditorImpl: boolean commit()>,<android.app.SharedPreferencesImpl.EditorImpl: boolean commit()>,0,"{
    MemoryCommitResult mcr = commitToMemory();
    SharedPreferencesImpl.this.enqueueDiskWrite(mcr, null);
    try {
        mcr.writtenToDiskLatch.await();
    } catch (InterruptedException e) {
        return false;
    }
    notifyListeners(mcr);
    return mcr.writeToDiskResult;
}","{
    long startTime = 0;
    if (DEBUG) {
        startTime = System.currentTimeMillis();
    }
    MemoryCommitResult mcr = commitToMemory();
    SharedPreferencesImpl.this.enqueueDiskWrite(mcr, null);
    try {
        mcr.writtenToDiskLatch.await();
    } catch (InterruptedException e) {
        return false;
    } finally {
        if (DEBUG) {
            Log.d(TAG, mFile.getName() + "":"" + mcr.memoryStateGeneration + "" committed after "" + (System.currentTimeMillis() - startTime) + "" ms"");
        }
    }
    notifyListeners(mcr);
    return mcr.writeToDiskResult;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code added is related to logging the time taken for the disk write process if debugging is enabled. There are no changes in the actual functionality of the 'commit()' method, so the code change type is 4.","Since the new statements are related to debugging and do not affect the return values or exceptions thrown by the 'commit()' method, there is no Compatibility Issue introduced by this change."
50,<android.app.ContextImpl: void unbindService(ServiceConnection)>,25,26,<android.app.ContextImpl: void unbindService(ServiceConnection)>,<android.app.ContextImpl: void unbindService(ServiceConnection)>,0,"{
    if (conn == null) {
        throw new IllegalArgumentException(""connection is null"");
    }
    if (mPackageInfo != null) {
        IServiceConnection sd = mPackageInfo.forgetServiceDispatcher(getOuterContext(), conn);
        try {
            ActivityManagerNative.getDefault().unbindService(sd);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    } else {
        throw new RuntimeException(""Not supported in system context"");
    }
}","{
    if (conn == null) {
        throw new IllegalArgumentException(""connection is null"");
    }
    if (mPackageInfo != null) {
        IServiceConnection sd = mPackageInfo.forgetServiceDispatcher(getOuterContext(), conn);
        try {
            ActivityManager.getService().unbindService(sd);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    } else {
        throw new RuntimeException(""Not supported in system context"");
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The only change in the implementation is the method call from `ActivityManagerNative.getDefault().unbindService(sd)` to `ActivityManager.getService().unbindService(sd)`, which is a change in the dependent API. Therefore, the code change type is 5.","There is no compatibility issue arising from this change assuming that `ActivityManager.getService().unbindService(sd)` is intended to be a direct replacement for the deprecated `ActivityManagerNative.getDefault().unbindService(sd)` with the same behavior. Thus, the CI type is 0."
53,"<android.content.res.AssetManager: CharSequence getPooledStringForCookie(int,int)>",25,26,"<android.content.res.AssetManager: CharSequence getPooledStringForCookie(int,int)>","<android.content.res.AssetManager: CharSequence getPooledStringForCookie(int,int)>",0,"{
    // Cookies map to string blocks starting at 1.
    return mStringBlocks[cookie - 1].get(id);
}","{
    synchronized (this) {
        // Cookies map to string blocks starting at 1.
        return mStringBlocks[cookie - 1].get(id);
    }
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"A synchronization block has been added to the method body, which changes the control dependency, so the code change type is 3.","The change in synchronization does not affect the return value or the types returned by the API. No new exception handling is introduced, and no existing exception handling is modified; therefore, there is no Compatibility Issue, and the CI type is 0."
55,"<android.content.res.Resources: Drawable getDrawableForDensity(int,int,Theme)>",25,26,"<android.content.res.Resources: Drawable getDrawableForDensity(int,int,Theme)>","<android.content.res.Resources: Drawable getDrawableForDensity(int,int,Theme)>",0,"{
    final TypedValue value = obtainTempTypedValue();
    try {
        final ResourcesImpl impl = mResourcesImpl;
        impl.getValueForDensity(id, density, value, true);
        // If the drawable's XML lives in our current density qualifier,
        // it's okay to use a scaled version from the cache. Otherwise, we
        // need to actually load the drawable from XML.
        final DisplayMetrics metrics = impl.getDisplayMetrics();
        final boolean useCache = value.density == metrics.densityDpi;
        /*
             * Pretend the requested density is actually the display density. If
             * the drawable returned is not the requested density, then force it
             * to be scaled later by dividing its density by the ratio of
             * requested density to actual device density. Drawables that have
             * undefined density or no density don't need to be handled here.
             */
        if (value.density > 0 && value.density != TypedValue.DENSITY_NONE) {
            if (value.density == density) {
                value.density = metrics.densityDpi;
            } else {
                value.density = (value.density * metrics.densityDpi) / density;
            }
        }
        return impl.loadDrawable(this, value, id, theme, useCache);
    } finally {
        releaseTempTypedValue(value);
    }
}","{
    final TypedValue value = obtainTempTypedValue();
    try {
        final ResourcesImpl impl = mResourcesImpl;
        impl.getValueForDensity(id, density, value, true);
        return impl.loadDrawable(this, value, id, density, theme);
    } finally {
        releaseTempTypedValue(value);
    }
}",1,"/**
 * Return a drawable object associated with a particular resource ID for the
 * given screen density in DPI and styled for the specified theme.
 *
 * @param id The desired resource identifier, as generated by the aapt tool.
 * This integer encodes the package, type, and resource entry.
 * The value 0 is an invalid identifier.
 * @param density The desired screen density indicated by the resource as
 * found in {@link DisplayMetrics}.
 * @param theme The theme used to style the drawable attributes, may be {@code null}.
 * @return Drawable An object that can be used to draw this resource.
 * @throws NotFoundException Throws NotFoundException if the given ID does
 * not exist.
 */
","/**
 * Return a drawable object associated with a particular resource ID for the
 * given screen density in DPI and styled for the specified theme.
 *
 * @param id The desired resource identifier, as generated by the aapt tool.
 * This integer encodes the package, type, and resource entry.
 * The value 0 is an invalid identifier.
 * @param density The desired screen density indicated by the resource as
 * found in {@link DisplayMetrics}. A value of 0 means to use the
 * density returned from {@link #getConfiguration()}.
 * This is equivalent to calling {@link #getDrawable(int, Theme)}.
 * @param theme The theme used to style the drawable attributes, may be {@code null}.
 * @return Drawable An object that can be used to draw this resource.
 * @throws NotFoundException Throws NotFoundException if the given ID does
 * not exist.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"One return statement and parts of the logic related to handling drawable scaling based on density have changed, so the code change types are 1 and 4.","Since the return statement has been altered by removing the logic for handling different density values and scaling, and it directly affects what Drawable is returned (potentially a Drawable with different scaling properties), a CI arises due to a potential difference in the returned Drawable object. The CI type is 1."
56,"<android.app.ContextImpl: void sendOrderedBroadcast(Intent,String,int,BroadcastReceiver,Handler,int,String,Bundle,Bundle)>",25,26,"<android.app.ContextImpl: void sendOrderedBroadcast(Intent,String,int,BroadcastReceiver,Handler,int,String,Bundle,Bundle)>","<android.app.ContextImpl: void sendOrderedBroadcast(Intent,String,int,BroadcastReceiver,Handler,int,String,Bundle,Bundle)>",0,"{
    warnIfCallingFromSystemProcess();
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, rd, initialCode, initialData, initialExtras, receiverPermissions, appOp, options, true, false, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    warnIfCallingFromSystemProcess();
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, rd, initialCode, initialData, initialExtras, receiverPermissions, appOp, options, true, false, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,5,0,The change is in calling `ActivityManagerNative.getDefault()` to `ActivityManager.getService()` to get the instance for performing the broadcastIntent operation. It's a change of a dependent API.,"This change does not introduce a potential Compatibility Issue, as it's an internal change in the mechanism of how the service instance is obtained. The behavior of the `sendOrderedBroadcast` method remains the same from the caller's perspective."
57,<android.animation.AnimatorSet: AnimatorSet clone()>,25,26,<android.animation.AnimatorSet: AnimatorSet clone()>,<android.animation.AnimatorSet: AnimatorSet clone()>,0,"{
    final AnimatorSet anim = (AnimatorSet) super.clone();
    /*
         * The basic clone() operation copies all items. This doesn't work very well for
         * AnimatorSet, because it will copy references that need to be recreated and state
         * that may not apply. What we need to do now is put the clone in an uninitialized
         * state, with fresh, empty data structures. Then we will build up the nodes list
         * manually, as we clone each Node (and its animation). The clone will then be sorted,
         * and will populate any appropriate lists, when it is started.
         */
    final int nodeCount = mNodes.size();
    anim.mTerminated = false;
    anim.mStarted = false;
    anim.mPlayingSet = new ArrayList<Animator>();
    anim.mNodeMap = new ArrayMap<Animator, Node>();
    anim.mNodes = new ArrayList<Node>(nodeCount);
    anim.mReversible = mReversible;
    anim.mSetListener = new AnimatorSetListener(anim);
    for (int n = 0; n < nodeCount; n++) {
        final Node node = mNodes.get(n);
        Node nodeClone = node.clone();
        node.mTmpClone = nodeClone;
        anim.mNodes.add(nodeClone);
        anim.mNodeMap.put(nodeClone.mAnimation, nodeClone);
        // clear out any listeners that were set up by the AnimatorSet
        final ArrayList<AnimatorListener> cloneListeners = nodeClone.mAnimation.getListeners();
        if (cloneListeners != null) {
            for (int i = cloneListeners.size() - 1; i >= 0; i--) {
                final AnimatorListener listener = cloneListeners.get(i);
                if (listener instanceof AnimatorSetListener) {
                    cloneListeners.remove(i);
                }
            }
        }
    }
    anim.mRootNode = mRootNode.mTmpClone;
    anim.mDelayAnim = (ValueAnimator) anim.mRootNode.mAnimation;
    // dependencies, mapping the old dependencies to the new nodes
    for (int i = 0; i < nodeCount; i++) {
        Node node = mNodes.get(i);
        // Update dependencies for node's clone
        node.mTmpClone.mLatestParent = node.mLatestParent == null ? null : node.mLatestParent.mTmpClone;
        int size = node.mChildNodes == null ? 0 : node.mChildNodes.size();
        for (int j = 0; j < size; j++) {
            node.mTmpClone.mChildNodes.set(j, node.mChildNodes.get(j).mTmpClone);
        }
        size = node.mSiblings == null ? 0 : node.mSiblings.size();
        for (int j = 0; j < size; j++) {
            node.mTmpClone.mSiblings.set(j, node.mSiblings.get(j).mTmpClone);
        }
        size = node.mParents == null ? 0 : node.mParents.size();
        for (int j = 0; j < size; j++) {
            node.mTmpClone.mParents.set(j, node.mParents.get(j).mTmpClone);
        }
    }
    for (int n = 0; n < nodeCount; n++) {
        mNodes.get(n).mTmpClone = null;
    }
    return anim;
}","{
    final AnimatorSet anim = (AnimatorSet) super.clone();
    /*
         * The basic clone() operation copies all items. This doesn't work very well for
         * AnimatorSet, because it will copy references that need to be recreated and state
         * that may not apply. What we need to do now is put the clone in an uninitialized
         * state, with fresh, empty data structures. Then we will build up the nodes list
         * manually, as we clone each Node (and its animation). The clone will then be sorted,
         * and will populate any appropriate lists, when it is started.
         */
    final int nodeCount = mNodes.size();
    anim.mStarted = false;
    anim.mLastFrameTime = -1;
    anim.mFirstFrame = -1;
    anim.mLastEventId = -1;
    anim.mPaused = false;
    anim.mPauseTime = -1;
    anim.mSeekState = new SeekState();
    anim.mSelfPulse = true;
    anim.mPlayingSet = new ArrayList<Node>();
    anim.mNodeMap = new ArrayMap<Animator, Node>();
    anim.mNodes = new ArrayList<Node>(nodeCount);
    anim.mEvents = new ArrayList<AnimationEvent>();
    anim.mDummyListener = new AnimatorListenerAdapter() {

        @Override
        public void onAnimationEnd(Animator animation) {
            if (anim.mNodeMap.get(animation) == null) {
                throw new AndroidRuntimeException(""Error: animation ended is not in the node"" + "" map"");
            }
            anim.mNodeMap.get(animation).mEnded = true;
        }
    };
    anim.mReversing = false;
    anim.mDependencyDirty = true;
    // Walk through the old nodes list, cloning each node and adding it to the new nodemap.
    // One problem is that the old node dependencies point to nodes in the old AnimatorSet.
    // We need to track the old/new nodes in order to reconstruct the dependencies in the clone.
    HashMap<Node, Node> clonesMap = new HashMap<>(nodeCount);
    for (int n = 0; n < nodeCount; n++) {
        final Node node = mNodes.get(n);
        Node nodeClone = node.clone();
        // Remove the old internal listener from the cloned child
        nodeClone.mAnimation.removeListener(mDummyListener);
        clonesMap.put(node, nodeClone);
        anim.mNodes.add(nodeClone);
        anim.mNodeMap.put(nodeClone.mAnimation, nodeClone);
    }
    anim.mRootNode = clonesMap.get(mRootNode);
    anim.mDelayAnim = (ValueAnimator) anim.mRootNode.mAnimation;
    // dependencies, mapping the old dependencies to the new nodes
    for (int i = 0; i < nodeCount; i++) {
        Node node = mNodes.get(i);
        // Update dependencies for node's clone
        Node nodeClone = clonesMap.get(node);
        nodeClone.mLatestParent = node.mLatestParent == null ? null : clonesMap.get(node.mLatestParent);
        int size = node.mChildNodes == null ? 0 : node.mChildNodes.size();
        for (int j = 0; j < size; j++) {
            nodeClone.mChildNodes.set(j, clonesMap.get(node.mChildNodes.get(j)));
        }
        size = node.mSiblings == null ? 0 : node.mSiblings.size();
        for (int j = 0; j < size; j++) {
            nodeClone.mSiblings.set(j, clonesMap.get(node.mSiblings.get(j)));
        }
        size = node.mParents == null ? 0 : node.mParents.size();
        for (int j = 0; j < size; j++) {
            nodeClone.mParents.set(j, clonesMap.get(node.mParents.get(j)));
        }
    }
    return anim;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
59,"<android.view.inputmethod.InputMethodManager: boolean startInputInner(int,IBinder,int,int,int)>",25,26,"<android.view.inputmethod.InputMethodManager: boolean startInputInner(int,IBinder,int,int,int)>","<android.view.inputmethod.InputMethodManager: boolean startInputInner(int,IBinder,int,int,int)>",0,"{
    final View view;
    synchronized (mH) {
        view = mServedView;
        // Make sure we have a window token for the served view.
        if (DEBUG) {
            Log.v(TAG, ""Starting input: view="" + dumpViewInfo(view) + "" reason="" + InputMethodClient.getStartInputReason(startInputReason));
        }
        if (view == null) {
            if (DEBUG)
                Log.v(TAG, ""ABORT input: no served view!"");
            return false;
        }
    }
    // Now we need to get an input connection from the served view.
    // This is complicated in a couple ways: we can't be holding our lock
    // when calling out to the view, and we need to make sure we call into
    // the view on the same thread that is driving its view hierarchy.
    Handler vh = view.getHandler();
    if (vh == null) {
        // screen without a connection.
        if (DEBUG)
            Log.v(TAG, ""ABORT input: no handler for view! Close current input."");
        closeCurrentInput();
        return false;
    }
    if (vh.getLooper() != Looper.myLooper()) {
        // we need to reschedule our work for over there.
        if (DEBUG)
            Log.v(TAG, ""Starting input: reschedule to view thread"");
        vh.post(new Runnable() {

            @Override
            public void run() {
                startInputInner(startInputReason, null, 0, 0, 0);
            }
        });
        return false;
    }
    // Okay we are now ready to call into the served view and have it
    // do its stuff.
    // Life is good: let's hook everything up!
    EditorInfo tba = new EditorInfo();
    // Note: Use Context#getOpPackageName() rather than Context#getPackageName() so that the
    // system can verify the consistency between the uid of this process and package name passed
    // from here. See comment of Context#getOpPackageName() for details.
    tba.packageName = view.getContext().getOpPackageName();
    tba.fieldId = view.getId();
    InputConnection ic = view.onCreateInputConnection(tba);
    if (DEBUG)
        Log.v(TAG, ""Starting input: tba="" + tba + "" ic="" + ic);
    synchronized (mH) {
        // changed.
        if (mServedView != view || !mServedConnecting) {
            // Something else happened, so abort.
            if (DEBUG)
                Log.v(TAG, ""Starting input: finished by someone else. view="" + dumpViewInfo(view) + "" mServedView="" + dumpViewInfo(mServedView) + "" mServedConnecting="" + mServedConnecting);
            return false;
        }
        // connected so we want to restart it.
        if (mCurrentTextBoxAttribute == null) {
            controlFlags |= CONTROL_START_INITIAL;
        }
        // Hook 'em up and let 'er rip.
        mCurrentTextBoxAttribute = tba;
        mServedConnecting = false;
        if (mServedInputConnectionWrapper != null) {
            mServedInputConnectionWrapper.deactivate();
            mServedInputConnectionWrapper = null;
        }
        ControlledInputConnectionWrapper servedContext;
        final int missingMethodFlags;
        if (ic != null) {
            mCursorSelStart = tba.initialSelStart;
            mCursorSelEnd = tba.initialSelEnd;
            mCursorCandStart = -1;
            mCursorCandEnd = -1;
            mCursorRect.setEmpty();
            mCursorAnchorInfo = null;
            final Handler icHandler;
            missingMethodFlags = InputConnectionInspector.getMissingMethodFlags(ic);
            if ((missingMethodFlags & InputConnectionInspector.MissingMethodFlags.GET_HANDLER) != 0) {
                // InputConnection#getHandler() is not implemented.
                icHandler = null;
            } else {
                icHandler = ic.getHandler();
            }
            servedContext = new ControlledInputConnectionWrapper(icHandler != null ? icHandler.getLooper() : vh.getLooper(), ic, this);
        } else {
            servedContext = null;
            missingMethodFlags = 0;
        }
        mServedInputConnectionWrapper = servedContext;
        try {
            if (DEBUG)
                Log.v(TAG, ""START INPUT: view="" + dumpViewInfo(view) + "" ic="" + ic + "" tba="" + tba + "" controlFlags=#"" + Integer.toHexString(controlFlags));
            final InputBindResult res = mService.startInputOrWindowGainedFocus(startInputReason, mClient, windowGainingFocus, controlFlags, softInputMode, windowFlags, tba, servedContext, missingMethodFlags);
            if (DEBUG)
                Log.v(TAG, ""Starting input: Bind result="" + res);
            if (res != null) {
                if (res.id != null) {
                    setInputChannelLocked(res.channel);
                    mBindSequence = res.sequence;
                    mCurMethod = res.method;
                    mCurId = res.id;
                    mNextUserActionNotificationSequenceNumber = res.userActionNotificationSequenceNumber;
                    if (mServedInputConnectionWrapper != null) {
                        mServedInputConnectionWrapper.setInputMethodId(mCurId);
                    }
                } else {
                    if (res.channel != null && res.channel != mCurChannel) {
                        res.channel.dispose();
                    }
                    if (mCurMethod == null) {
                        // This means there is no input method available.
                        if (DEBUG)
                            Log.v(TAG, ""ABORT input: no input method!"");
                        return true;
                    }
                }
            } else {
                if (startInputReason == InputMethodClient.START_INPUT_REASON_WINDOW_FOCUS_GAIN) {
                    // TODO: InputBindResult should have the error code.
                    if (DEBUG)
                        Log.w(TAG, ""startInputOrWindowGainedFocus failed. "" + ""Window focus may have already been lost. "" + ""win="" + windowGainingFocus + "" view="" + dumpViewInfo(view));
                    if (!mActive) {
                        // mHasBeenInactive is a latch switch to forcefully refresh IME focus
                        // state when an inactive (mActive == false) client is gaining window
                        // focus. In case we have unnecessary disable the latch due to this
                        // spurious wakeup, we re-enable the latch here.
                        // TODO: Come up with more robust solution.
                        mHasBeenInactive = true;
                    }
                }
            }
            if (mCurMethod != null && mCompletions != null) {
                try {
                    mCurMethod.displayCompletions(mCompletions);
                } catch (RemoteException e) {
                }
            }
        } catch (RemoteException e) {
            Log.w(TAG, ""IME died: "" + mCurId, e);
        }
    }
    return true;
}","{
    final View view;
    synchronized (mH) {
        view = mServedView;
        // Make sure we have a window token for the served view.
        if (DEBUG) {
            Log.v(TAG, ""Starting input: view="" + dumpViewInfo(view) + "" reason="" + InputMethodClient.getStartInputReason(startInputReason));
        }
        if (view == null) {
            if (DEBUG)
                Log.v(TAG, ""ABORT input: no served view!"");
            return false;
        }
    }
    // Now we need to get an input connection from the served view.
    // This is complicated in a couple ways: we can't be holding our lock
    // when calling out to the view, and we need to make sure we call into
    // the view on the same thread that is driving its view hierarchy.
    Handler vh = view.getHandler();
    if (vh == null) {
        // screen without a connection.
        if (DEBUG)
            Log.v(TAG, ""ABORT input: no handler for view! Close current input."");
        closeCurrentInput();
        return false;
    }
    if (vh.getLooper() != Looper.myLooper()) {
        // we need to reschedule our work for over there.
        if (DEBUG)
            Log.v(TAG, ""Starting input: reschedule to view thread"");
        vh.post(new Runnable() {

            @Override
            public void run() {
                startInputInner(startInputReason, null, 0, 0, 0);
            }
        });
        return false;
    }
    // Okay we are now ready to call into the served view and have it
    // do its stuff.
    // Life is good: let's hook everything up!
    EditorInfo tba = new EditorInfo();
    // Note: Use Context#getOpPackageName() rather than Context#getPackageName() so that the
    // system can verify the consistency between the uid of this process and package name passed
    // from here. See comment of Context#getOpPackageName() for details.
    tba.packageName = view.getContext().getOpPackageName();
    tba.fieldId = view.getId();
    InputConnection ic = view.onCreateInputConnection(tba);
    if (DEBUG)
        Log.v(TAG, ""Starting input: tba="" + tba + "" ic="" + ic);
    synchronized (mH) {
        // changed.
        if (mServedView != view || !mServedConnecting) {
            // Something else happened, so abort.
            if (DEBUG)
                Log.v(TAG, ""Starting input: finished by someone else. view="" + dumpViewInfo(view) + "" mServedView="" + dumpViewInfo(mServedView) + "" mServedConnecting="" + mServedConnecting);
            return false;
        }
        // connected so we want to restart it.
        if (mCurrentTextBoxAttribute == null) {
            controlFlags |= CONTROL_START_INITIAL;
        }
        // Hook 'em up and let 'er rip.
        mCurrentTextBoxAttribute = tba;
        mServedConnecting = false;
        if (mServedInputConnectionWrapper != null) {
            mServedInputConnectionWrapper.deactivate();
            mServedInputConnectionWrapper = null;
        }
        ControlledInputConnectionWrapper servedContext;
        final int missingMethodFlags;
        if (ic != null) {
            mCursorSelStart = tba.initialSelStart;
            mCursorSelEnd = tba.initialSelEnd;
            mCursorCandStart = -1;
            mCursorCandEnd = -1;
            mCursorRect.setEmpty();
            mCursorAnchorInfo = null;
            final Handler icHandler;
            missingMethodFlags = InputConnectionInspector.getMissingMethodFlags(ic);
            if ((missingMethodFlags & InputConnectionInspector.MissingMethodFlags.GET_HANDLER) != 0) {
                // InputConnection#getHandler() is not implemented.
                icHandler = null;
            } else {
                icHandler = ic.getHandler();
            }
            servedContext = new ControlledInputConnectionWrapper(icHandler != null ? icHandler.getLooper() : vh.getLooper(), ic, this);
        } else {
            servedContext = null;
            missingMethodFlags = 0;
        }
        mServedInputConnectionWrapper = servedContext;
        try {
            if (DEBUG)
                Log.v(TAG, ""START INPUT: view="" + dumpViewInfo(view) + "" ic="" + ic + "" tba="" + tba + "" controlFlags=#"" + Integer.toHexString(controlFlags));
            final InputBindResult res = mService.startInputOrWindowGainedFocus(startInputReason, mClient, windowGainingFocus, controlFlags, softInputMode, windowFlags, tba, servedContext, missingMethodFlags);
            if (DEBUG)
                Log.v(TAG, ""Starting input: Bind result="" + res);
            if (res != null) {
                if (res.id != null) {
                    setInputChannelLocked(res.channel);
                    mBindSequence = res.sequence;
                    mCurMethod = res.method;
                    mCurId = res.id;
                    mNextUserActionNotificationSequenceNumber = res.userActionNotificationSequenceNumber;
                } else {
                    if (res.channel != null && res.channel != mCurChannel) {
                        res.channel.dispose();
                    }
                    if (mCurMethod == null) {
                        // This means there is no input method available.
                        if (DEBUG)
                            Log.v(TAG, ""ABORT input: no input method!"");
                        return true;
                    }
                }
            } else {
                if (startInputReason == InputMethodClient.START_INPUT_REASON_WINDOW_FOCUS_GAIN) {
                    // TODO: InputBindResult should have the error code.
                    if (DEBUG)
                        Log.w(TAG, ""startInputOrWindowGainedFocus failed. "" + ""Window focus may have already been lost. "" + ""win="" + windowGainingFocus + "" view="" + dumpViewInfo(view));
                    if (!mActive) {
                        // mHasBeenInactive is a latch switch to forcefully refresh IME focus
                        // state when an inactive (mActive == false) client is gaining window
                        // focus. In case we have unnecessary disable the latch due to this
                        // spurious wakeup, we re-enable the latch here.
                        // TODO: Come up with more robust solution.
                        mHasBeenInactive = true;
                    }
                }
            }
            if (mCurMethod != null && mCompletions != null) {
                try {
                    mCurMethod.displayCompletions(mCompletions);
                } catch (RemoteException e) {
                }
            }
        } catch (RemoteException e) {
            Log.w(TAG, ""IME died: "" + mCurId, e);
        }
    }
    return true;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
61,<android.widget.TextView: boolean performLongClick()>,25,26,<android.widget.TextView: boolean performLongClick()>,<android.widget.TextView: boolean performLongClick()>,0,"{
    boolean handled = false;
    if (mEditor != null) {
        mEditor.mIsBeingLongClicked = true;
    }
    if (super.performLongClick()) {
        handled = true;
    }
    if (mEditor != null) {
        handled |= mEditor.performLongClick(handled);
        mEditor.mIsBeingLongClicked = false;
    }
    if (handled) {
        performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
        if (mEditor != null)
            mEditor.mDiscardNextActionUp = true;
    }
    return handled;
}","{
    boolean handled = false;
    if (mEditor != null) {
        mEditor.mIsBeingLongClicked = true;
    }
    if (super.performLongClick()) {
        handled = true;
    }
    if (mEditor != null) {
        handled |= mEditor.performLongClick(handled);
        mEditor.mIsBeingLongClicked = false;
    }
    if (handled) {
        performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
        if (mEditor != null)
            mEditor.mDiscardNextActionUp = true;
    } else {
        MetricsLogger.action(mContext, MetricsEvent.TEXT_LONGPRESS, TextViewMetrics.SUBTYPE_LONG_PRESS_OTHER);
    }
    return handled;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"An 'else' branch with a logging action has been added, but it does not alter the returned value or the exceptions that can be thrown. Therefore, the change type is 4 (Other statement changed).","There is no Compatibility Issue because the change made does not affect the returned value or the exception handling. The modification is for logging purposes, which doesn't impact the method’s behavior as observed by the caller. Hence, the behavior of the API remains consistent between the two versions."
62,<android.preference.Preference: boolean getPersistedBoolean(boolean)>,25,26,<android.preference.Preference: boolean getPersistedBoolean(boolean)>,<android.preference.Preference: boolean getPersistedBoolean(boolean)>,0,"{
    if (!shouldPersist()) {
        return defaultReturnValue;
    }
    return mPreferenceManager.getSharedPreferences().getBoolean(mKey, defaultReturnValue);
}","{
    if (!shouldPersist()) {
        return defaultReturnValue;
    }
    PreferenceDataStore dataStore = getPreferenceDataStore();
    if (dataStore != null) {
        return dataStore.getBoolean(mKey, defaultReturnValue);
    }
    return mPreferenceManager.getSharedPreferences().getBoolean(mKey, defaultReturnValue);
}",1,"/**
 * Attempts to get a persisted boolean from the {@link android.content.SharedPreferences}.
 *
 * @param defaultReturnValue The default value to return if either this
 * Preference is not persistent or this Preference is not in the
 * SharedPreferences.
 * @return The value from the SharedPreferences or the default return
 * value.
 * @see #getPersistedString(String)
 * @see #persistBoolean(boolean)
 */
","/**
 * Attempts to get a persisted boolean if this Preference is persistent.
 *
 * @param defaultReturnValue The default value to return if either this
 * Preference is not persistent or this Preference is not present.
 * @return The value from the data store or the default return
 * value.
 * @see #getPersistedString(String)
 * @see #persistBoolean(boolean)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"A new control dependency (if-condition checking if dataStore is not null) has been introduced, and the use of the new PreferenceDataStore API to retrieve the boolean value is a new code path that did not exist before, so the change types are 3 and 4.","The addition of a new control dependency and the new operation involving PreferenceDataStore could lead to a different return value if it is not null. Therefore, it can potentially return a different boolean value which can cause a CI of type 1."
64,<android.widget.TextView: boolean onTextContextMenuItem(int)>,25,26,<android.widget.TextView: boolean onTextContextMenuItem(int)>,<android.widget.TextView: boolean onTextContextMenuItem(int)>,0,"{
    int min = 0;
    int max = mText.length();
    if (isFocused()) {
        final int selStart = getSelectionStart();
        final int selEnd = getSelectionEnd();
        min = Math.max(0, Math.min(selStart, selEnd));
        max = Math.max(0, Math.max(selStart, selEnd));
    }
    switch(id) {
        case ID_SELECT_ALL:
            selectAllText();
            return true;
        case ID_UNDO:
            if (mEditor != null) {
                mEditor.undo();
            }
            // Returns true even if nothing was undone.
            return true;
        case ID_REDO:
            if (mEditor != null) {
                mEditor.redo();
            }
            // Returns true even if nothing was undone.
            return true;
        case ID_PASTE:
            paste(min, max, true);
            return true;
        case ID_PASTE_AS_PLAIN_TEXT:
            paste(min, max, false);
            return true;
        case ID_CUT:
            setPrimaryClip(ClipData.newPlainText(null, getTransformedText(min, max)));
            deleteText_internal(min, max);
            return true;
        case ID_COPY:
            setPrimaryClip(ClipData.newPlainText(null, getTransformedText(min, max)));
            stopTextActionMode();
            return true;
        case ID_REPLACE:
            if (mEditor != null) {
                mEditor.replace();
            }
            return true;
        case ID_SHARE:
            shareSelectedText();
            return true;
    }
    return false;
}","{
    int min = 0;
    int max = mText.length();
    if (isFocused()) {
        final int selStart = getSelectionStart();
        final int selEnd = getSelectionEnd();
        min = Math.max(0, Math.min(selStart, selEnd));
        max = Math.max(0, Math.max(selStart, selEnd));
    }
    switch(id) {
        case ID_SELECT_ALL:
            final boolean hadSelection = hasSelection();
            selectAllText();
            if (mEditor != null && hadSelection) {
                mEditor.invalidateActionModeAsync();
            }
            return true;
        case ID_UNDO:
            if (mEditor != null) {
                mEditor.undo();
            }
            // Returns true even if nothing was undone.
            return true;
        case ID_REDO:
            if (mEditor != null) {
                mEditor.redo();
            }
            // Returns true even if nothing was undone.
            return true;
        case ID_PASTE:
            paste(min, max, true);
            return true;
        case ID_PASTE_AS_PLAIN_TEXT:
            paste(min, max, false);
            return true;
        case ID_CUT:
            setPrimaryClip(ClipData.newPlainText(null, getTransformedText(min, max)));
            deleteText_internal(min, max);
            return true;
        case ID_COPY:
            setPrimaryClip(ClipData.newPlainText(null, getTransformedText(min, max)));
            stopTextActionMode();
            return true;
        case ID_REPLACE:
            if (mEditor != null) {
                mEditor.replace();
            }
            return true;
        case ID_SHARE:
            shareSelectedText();
            return true;
        case ID_AUTOFILL:
            requestAutofill();
            stopTextActionMode();
            return true;
    }
    return false;
}",1,"/**
 * Called when a context menu option for the text view is selected.  Currently
 * this will be one of {@link android.R.id#selectAll}, {@link android.R.id#cut},
 * {@link android.R.id#copy}, {@link android.R.id#paste} or {@link android.R.id#shareText}.
 *
 * @return true if the context menu item action was performed.
 */
","/**
 * Called when a context menu option for the text view is selected.  Currently
 * this will be one of {@link android.R.id#selectAll}, {@link android.R.id#cut},
 * {@link android.R.id#copy}, {@link android.R.id#paste} or {@link android.R.id#shareText}.
 *
 * @return true if the context menu item action was performed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The source code change includes new case statements for handling ID_AUTOFILL and a conditional check for calling invalidateActionModeAsync() within the ID_SELECT_ALL case. Therefore, the code change types are 3 for the modified control flow within the switch cases and 4 for the addition of new statements.","Despite the addition of new code branches and statements, the changes will not cause a previously valid input to behave differently; they only extend the functionality by handling a new case (ID_AUTOFILL) and by possibly invalidating the action mode asynchronously when there is an existing selection during ID_SELECT_ALL. The existing behavior for inputs that do not match the newly-added case or the new condition is unchanged. Thus, there is no Compatibility Issue since the old behavior is preserved for previously valid inputs."
70,<android.hardware.camera2.params.StreamConfigurationMap: boolean isOutputSupportedFor(Surface)>,25,26,<android.hardware.camera2.params.StreamConfigurationMap: boolean isOutputSupportedFor(Surface)>,<android.hardware.camera2.params.StreamConfigurationMap: boolean isOutputSupportedFor(Surface)>,0,"{
    checkNotNull(surface, ""surface must not be null"");
    Size surfaceSize = SurfaceUtils.getSurfaceSize(surface);
    int surfaceFormat = SurfaceUtils.getSurfaceFormat(surface);
    int surfaceDataspace = SurfaceUtils.getSurfaceDataspace(surface);
    // See if consumer is flexible.
    boolean isFlexible = SurfaceUtils.isFlexibleConsumer(surface);
    // Override RGB formats to IMPLEMENTATION_DEFINED, b/9487482
    if ((surfaceFormat >= LegacyMetadataMapper.HAL_PIXEL_FORMAT_RGBA_8888 && surfaceFormat <= LegacyMetadataMapper.HAL_PIXEL_FORMAT_BGRA_8888)) {
        surfaceFormat = HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED;
    }
    StreamConfiguration[] configs = surfaceDataspace != HAL_DATASPACE_DEPTH ? mConfigurations : mDepthConfigurations;
    for (StreamConfiguration config : configs) {
        if (config.getFormat() == surfaceFormat && config.isOutput()) {
            // and a size no bigger than MAX_DIMEN_FOR_ROUNDING
            if (config.getSize().equals(surfaceSize)) {
                return true;
            } else if (isFlexible && (config.getSize().getWidth() <= LegacyCameraDevice.MAX_DIMEN_FOR_ROUNDING)) {
                return true;
            }
        }
    }
    return false;
}","{
    checkNotNull(surface, ""surface must not be null"");
    Size surfaceSize = SurfaceUtils.getSurfaceSize(surface);
    int surfaceFormat = SurfaceUtils.getSurfaceFormat(surface);
    int surfaceDataspace = SurfaceUtils.getSurfaceDataspace(surface);
    // See if consumer is flexible.
    boolean isFlexible = SurfaceUtils.isFlexibleConsumer(surface);
    StreamConfiguration[] configs = surfaceDataspace != HAL_DATASPACE_DEPTH ? mConfigurations : mDepthConfigurations;
    for (StreamConfiguration config : configs) {
        if (config.getFormat() == surfaceFormat && config.isOutput()) {
            // and a size no bigger than MAX_DIMEN_FOR_ROUNDING
            if (config.getSize().equals(surfaceSize)) {
                return true;
            } else if (isFlexible && (config.getSize().getWidth() <= LegacyCameraDevice.MAX_DIMEN_FOR_ROUNDING)) {
                return true;
            }
        }
    }
    return false;
}",1,"/**
 * Determine whether or not the {@code surface} in its current state is suitable to be included
 * in a {@link CameraDevice#createCaptureSession capture session} as an output.
 *
 * <p>Not all surfaces are usable with the {@link CameraDevice}, and not all configurations
 * of that {@code surface} are compatible. Some classes that provide the {@code surface} are
 * compatible with the {@link CameraDevice} in general
 * (see {@link #isOutputSupportedFor(Class)}, but it is the caller's responsibility to put the
 * {@code surface} into a state that will be compatible with the {@link CameraDevice}.</p>
 *
 * <p>Reasons for a {@code surface} being specifically incompatible might be:
 * <ul>
 * <li>Using a format that's not listed by {@link #getOutputFormats}
 * <li>Using a format/size combination that's not listed by {@link #getOutputSizes}
 * <li>The {@code surface} itself is not in a state where it can service a new producer.</p>
 * </li>
 * </ul>
 *
 * <p>Surfaces from flexible sources will return true even if the exact size of the Surface does
 * not match a camera-supported size, as long as the format (or class) is supported and the
 * camera device supports a size that is equal to or less than 1080p in that format. If such as
 * Surface is used to create a capture session, it will have its size rounded to the nearest
 * supported size, below or equal to 1080p. Flexible sources include SurfaceView, SurfaceTexture,
 * and ImageReader.</p>
 *
 * <p>This is not an exhaustive list; see the particular class's documentation for further
 * possible reasons of incompatibility.</p>
 *
 * @param surface a non-{@code null} {@link Surface} object reference
 * @return {@code true} if this is supported, {@code false} otherwise
 *
 * @throws NullPointerException if {@code surface} was {@code null}
 * @throws IllegalArgumentException if the Surface endpoint is no longer valid
 *
 * @see CameraDevice#createCaptureSession
 * @see #isOutputSupportedFor(Class)
 */
","/**
 * Determine whether or not the {@code surface} in its current state is suitable to be included
 * in a {@link CameraDevice#createCaptureSession capture session} as an output.
 *
 * <p>Not all surfaces are usable with the {@link CameraDevice}, and not all configurations
 * of that {@code surface} are compatible. Some classes that provide the {@code surface} are
 * compatible with the {@link CameraDevice} in general
 * (see {@link #isOutputSupportedFor(Class)}, but it is the caller's responsibility to put the
 * {@code surface} into a state that will be compatible with the {@link CameraDevice}.</p>
 *
 * <p>Reasons for a {@code surface} being specifically incompatible might be:
 * <ul>
 * <li>Using a format that's not listed by {@link #getOutputFormats}
 * <li>Using a format/size combination that's not listed by {@link #getOutputSizes}
 * <li>The {@code surface} itself is not in a state where it can service a new producer.</p>
 * </li>
 * </ul>
 *
 * <p>Surfaces from flexible sources will return true even if the exact size of the Surface does
 * not match a camera-supported size, as long as the format (or class) is supported and the
 * camera device supports a size that is equal to or less than 1080p in that format. If such as
 * Surface is used to create a capture session, it will have its size rounded to the nearest
 * supported size, below or equal to 1080p. Flexible sources include SurfaceView, SurfaceTexture,
 * and ImageReader.</p>
 *
 * <p>This is not an exhaustive list; see the particular class's documentation for further
 * possible reasons of incompatibility.</p>
 *
 * @param surface a non-{@code null} {@link Surface} object reference
 * @return {@code true} if this is supported, {@code false} otherwise
 *
 * @throws NullPointerException if {@code surface} was {@code null}
 * @throws IllegalArgumentException if the Surface endpoint is no longer valid
 *
 * @see CameraDevice#createCaptureSession
 * @see #isOutputSupportedFor(Class)
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,There is no difference between the early version and the late version of the code.,No Compatibility Issue arises as there is no change detected between the two versions of the API.
71,<android.view.View: boolean verifyDrawable(Drawable)>,25,26,<android.view.View: boolean verifyDrawable(Drawable)>,<android.view.View: boolean verifyDrawable(Drawable)>,0,"{
    // drawable from triggering invalidations and scheduling runnables.
    return who == mBackground || (mForegroundInfo != null && mForegroundInfo.mDrawable == who);
}","{
    // drawable from triggering invalidations and scheduling runnables.
    return who == mBackground || (mForegroundInfo != null && mForegroundInfo.mDrawable == who) || (mDefaultFocusHighlight == who);
}",1,"/**
 * If your view subclass is displaying its own Drawable objects, it should
 * override this function and return true for any Drawable it is
 * displaying.  This allows animations for those drawables to be
 * scheduled.
 *
 * <p>Be sure to call through to the super class when overriding this
 * function.
 *
 * @param who The Drawable to verify.  Return true if it is one you are
 * displaying, else return the result of calling through to the
 * super class.
 *
 * @return boolean If true than the Drawable is being displayed in the
 * view; else false and it is not allowed to animate.
 *
 * @see #unscheduleDrawable(android.graphics.drawable.Drawable)
 * @see #drawableStateChanged()
 */
","/**
 * If your view subclass is displaying its own Drawable objects, it should
 * override this function and return true for any Drawable it is
 * displaying.  This allows animations for those drawables to be
 * scheduled.
 *
 * <p>Be sure to call through to the super class when overriding this
 * function.
 *
 * @param who The Drawable to verify.  Return true if it is one you are
 * displaying, else return the result of calling through to the
 * super class.
 *
 * @return boolean If true than the Drawable is being displayed in the
 * view; else false and it is not allowed to animate.
 *
 * @see #unscheduleDrawable(android.graphics.drawable.Drawable)
 * @see #drawableStateChanged()
 */
",-1,[@CallSuper],[@CallSuper],-1,-1,-1,-1,-1,-1,1,1,"A new condition '(mDefaultFocusHighlight == who)' is appended to the return statement, so the code change type is 1.","As there is an additional condition appended that could potentially return true where it previously would not, the API in the late version can return a different value than the early version, hence the CI type is 1."
72,"<android.app.admin.DevicePolicyManager: void setPermissionPolicy(ComponentName,int)>",25,26,"<android.app.admin.DevicePolicyManager: void setPermissionPolicy(ComponentName,int)>","<android.app.admin.DevicePolicyManager: void setPermissionPolicy(ComponentName,int)>",0,"{
    throwIfParentInstance(""setPermissionPolicy"");
    try {
        mService.setPermissionPolicy(admin, policy);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}","{
    throwIfParentInstance(""setPermissionPolicy"");
    try {
        mService.setPermissionPolicy(admin, mContext.getPackageName(), policy);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}",1,"/**
 * Called by profile or device owners to set the default response for future runtime permission
 * requests by applications. The policy can allow for normal operation which prompts the user to
 * grant a permission, or can allow automatic granting or denying of runtime permission requests
 * by an application. This also applies to new permissions declared by app updates. When a
 * permission is denied or granted this way, the effect is equivalent to setting the permission
 * grant state via {@link #setPermissionGrantState}.
 * <p/>
 * As this policy only acts on runtime permission requests, it only applies to applications
 * built with a {@code targetSdkVersion} of {@link android.os.Build.VERSION_CODES#M} or later.
 *
 * @param admin Which profile or device owner this request is associated with.
 * @param policy One of the policy constants {@link #PERMISSION_POLICY_PROMPT},
 * {@link #PERMISSION_POLICY_AUTO_GRANT} and {@link #PERMISSION_POLICY_AUTO_DENY}.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 * @see #setPermissionGrantState
 */
","/**
 * Set the default response for future runtime permission requests by applications. This
 * function can be called by a device owner, profile owner, or by a delegate given the
 * {@link #DELEGATION_PERMISSION_GRANT} scope via {@link #setDelegatedScopes}.
 * The policy can allow for normal operation which prompts the user to grant a permission, or
 * can allow automatic granting or denying of runtime permission requests by an application.
 * This also applies to new permissions declared by app updates. When a permission is denied or
 * granted this way, the effect is equivalent to setting the permission * grant state via
 * {@link #setPermissionGrantState}.
 * <p/>
 * As this policy only acts on runtime permission requests, it only applies to applications
 * built with a {@code targetSdkVersion} of {@link android.os.Build.VERSION_CODES#M} or later.
 *
 * @param admin Which profile or device owner this request is associated with.
 * @param policy One of the policy constants {@link #PERMISSION_POLICY_PROMPT},
 * {@link #PERMISSION_POLICY_AUTO_GRANT} and {@link #PERMISSION_POLICY_AUTO_DENY}.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 * @see #setPermissionGrantState
 * @see #setDelegatedScopes
 * @see #DELEGATION_PERMISSION_GRANT
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent API `mService.setPermissionPolicy` now includes an additional parameter `mContext.getPackageName()`, so the change type is 5.","Although the dependent API `mService.setPermissionPolicy` called within the method now has an additional parameter, this change does not alter the return type or value (since the method is void and does not return anything), nor does it change exception handling. Therefore, there is no Compatibility Issue, as the method will behave the same way from the caller's perspective in terms of return value or exception thrown. The Compatibility Issue situation is 0."
73,<android.preference.Preference: boolean persistFloat(float)>,25,26,<android.preference.Preference: boolean persistFloat(float)>,<android.preference.Preference: boolean persistFloat(float)>,0,"{
    if (shouldPersist()) {
        if (value == getPersistedFloat(Float.NaN)) {
            // It's already there, so the same as persisting
            return true;
        }
        SharedPreferences.Editor editor = mPreferenceManager.getEditor();
        editor.putFloat(mKey, value);
        tryCommit(editor);
        return true;
    }
    return false;
}","{
    if (!shouldPersist()) {
        return false;
    }
    if (value == getPersistedFloat(Float.NaN)) {
        // It's already there, so the same as persisting
        return true;
    }
    PreferenceDataStore dataStore = getPreferenceDataStore();
    if (dataStore != null) {
        dataStore.putFloat(mKey, value);
    } else {
        SharedPreferences.Editor editor = mPreferenceManager.getEditor();
        editor.putFloat(mKey, value);
        tryCommit(editor);
    }
    return true;
}",1,"/**
 * Attempts to persist a float to the {@link android.content.SharedPreferences}.
 *
 * @param value The value to persist.
 * @return True if this Preference is persistent. (This is not whether the
 * value was persisted, since we may not necessarily commit if there
 * will be a batch commit later.)
 * @see #persistString(String)
 * @see #getPersistedFloat(float)
 */
","/**
 * Attempts to persist a long if this Preference is persistent.
 *
 * @param value The value to persist.
 * @return True if this Preference is persistent. (This is not whether the
 * value was persisted, since we may not necessarily commit if there
 * will be a batch commit later.)
 * @see #persistString(String)
 * @see #getPersistedFloat(float)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,5",1,"The early version and the late version implementations have several changes. The control dependency is inverted at the start of the method (from `if (shouldPersist())` to `if (!shouldPersist())` with a return false), the method now checks for a `PreferenceDataStore` and uses it if available which is a dependent API change (since the method of storing the value is now different), and there's a new control flow branch introduced. Also, there is no modification in the 'return true' and 'return false' statements or their meaning, so the return statement has not changed, but it is related to the control dependency change, so that's why the category 1 is also marked alongside 3 and 5.","The compatibility issue arises due to the introduction of `PreferenceDataStore` which may have a different implementation for storing preferences than `SharedPreferences.Editor`, potentially leading to a change in behavior of where or how the data is persisted. Although the return type is still a boolean, the actual effect of the persist operation could have changed because the underlying data store can be different (data store vs. shared preferences). Additionally, the inversion of the control dependency at the beginning of the method (`if (!shouldPersist())`) may also result in different behavior when the condition is met. This qualifies as a compatibility issue type 1."
74,<android.bluetooth.BluetoothGattServer: boolean removeService(BluetoothGattService)>,25,26,<android.bluetooth.BluetoothGattServer: boolean removeService(BluetoothGattService)>,<android.bluetooth.BluetoothGattServer: boolean removeService(BluetoothGattService)>,0,"{
    if (DBG)
        Log.d(TAG, ""removeService() - service: "" + service.getUuid());
    if (mService == null || mServerIf == 0)
        return false;
    BluetoothGattService intService = getService(service.getUuid(), service.getInstanceId(), service.getType());
    if (intService == null)
        return false;
    try {
        mService.removeService(mServerIf, service.getType(), service.getInstanceId(), new ParcelUuid(service.getUuid()));
        mServices.remove(intService);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        return false;
    }
    return true;
}","{
    if (DBG)
        Log.d(TAG, ""removeService() - service: "" + service.getUuid());
    if (mService == null || mServerIf == 0)
        return false;
    BluetoothGattService intService = getService(service.getUuid(), service.getInstanceId(), service.getType());
    if (intService == null)
        return false;
    try {
        mService.removeService(mServerIf, service.getInstanceId());
        mServices.remove(intService);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        return false;
    }
    return true;
}",1,"/**
 * Removes a service from the list of services to be provided.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param service Service to be removed.
 * @return true, if the service has been removed
 */
","/**
 * Removes a service from the list of services to be provided.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param service Service to be removed.
 * @return true, if the service has been removed
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The change includes the removal of a parameter in the 'mService.removeService' method call and the way the Service is being identified for removal. The early version uses service.getType(), service.getInstanceId(), and a new ParcelUuid(service.getUuid()), while the late version only uses mServerIf, service.getInstanceId(). The 'other statement' change type is 4 because an argument has been removed, which is an alteration in the method call that does not fit into other definitions of change types. Additionally, a 'Dependent API' has changed because the method signature of 'mService.removeService' has been altered to have different parameters (change type 5).","Since the method call to remove a service has been modified to exclude the service type and make use of different parameters for identifying which service to remove, it could potentially lead to a different return value if the behavior of the 'removeService' API depends on the removed information (service type), thus causing type 1 CI."
75,"<android.inputmethodservice.InputMethodService.InputMethodImpl: void showSoftInput(int,ResultReceiver)>",25,26,"<android.inputmethodservice.InputMethodService.InputMethodImpl: void showSoftInput(int,ResultReceiver)>","<android.inputmethodservice.InputMethodService.InputMethodImpl: void showSoftInput(int,ResultReceiver)>",0,"{
    if (DEBUG)
        Log.v(TAG, ""showSoftInput()"");
    boolean wasVis = isInputViewShown();
    if (dispatchOnShowInputRequested(flags, false)) {
        try {
            showWindow(true);
        } catch (BadTokenException e) {
        // We have ignored BadTokenException here since Jelly Bean MR-2 (API Level 18).
        // We could ignore BadTokenException in InputMethodService#showWindow() instead,
        // but it may break assumptions for those who override #showWindow() that we can
        // detect errors in #showWindow() by checking BadTokenException.
        // TODO: Investigate its feasibility.  Update JavaDoc of #showWindow() of
        // whether it's OK to override #showWindow() or not.
        }
    }
    clearInsetOfPreviousIme();
    // If user uses hard keyboard, IME button should always be shown.
    boolean showing = isInputViewShown();
    mImm.setImeWindowStatus(mToken, IME_ACTIVE | (showing ? IME_VISIBLE : 0), mBackDisposition);
    if (resultReceiver != null) {
        resultReceiver.send(wasVis != isInputViewShown() ? InputMethodManager.RESULT_SHOWN : (wasVis ? InputMethodManager.RESULT_UNCHANGED_SHOWN : InputMethodManager.RESULT_UNCHANGED_HIDDEN), null);
    }
}","{
    if (DEBUG)
        Log.v(TAG, ""showSoftInput()"");
    boolean wasVis = isInputViewShown();
    if (dispatchOnShowInputRequested(flags, false)) {
        try {
            showWindow(true);
        } catch (BadTokenException e) {
        // We have ignored BadTokenException here since Jelly Bean MR-2 (API Level 18).
        // We could ignore BadTokenException in InputMethodService#showWindow() instead,
        // but it may break assumptions for those who override #showWindow() that we can
        // detect errors in #showWindow() by checking BadTokenException.
        // TODO: Investigate its feasibility.  Update JavaDoc of #showWindow() of
        // whether it's OK to override #showWindow() or not.
        }
    }
    clearInsetOfPreviousIme();
    // If user uses hard keyboard, IME button should always be shown.
    boolean showing = isInputViewShown();
    mImm.setImeWindowStatus(mToken, mStartInputToken, IME_ACTIVE | (showing ? IME_VISIBLE : 0), mBackDisposition);
    if (resultReceiver != null) {
        resultReceiver.send(wasVis != isInputViewShown() ? InputMethodManager.RESULT_SHOWN : (wasVis ? InputMethodManager.RESULT_UNCHANGED_SHOWN : InputMethodManager.RESULT_UNCHANGED_HIDDEN), null);
    }
}",1,"/**
 * Handle a request by the system to show the soft input area.
 */
","/**
 * Handle a request by the system to show the soft input area.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,The only change in the method is the addition of the mStartInputToken in the line:,"mImm.setImeWindowStatus(mToken, mStartInputToken, IME_ACTIVE | (showing ? IME_VISIBLE : 0), mBackDisposition);"
76,<android.app.Notification.Builder: Builder addAction(Action)>,25,26,<android.app.Notification.Builder: Builder addAction(Action)>,<android.app.Notification.Builder: Builder addAction(Action)>,0,"{
    mActions.add(action);
    return this;
}","{
    if (action != null) {
        mActions.add(action);
    }
    return this;
}",1,"/**
 * Add an action to this notification. Actions are typically displayed by
 * the system as a button adjacent to the notification content.
 * <p>
 * Every action must have an icon (32dp square and matching the
 * <a href=""{@docRoot}design/style/iconography.html#action-bar"">Holo
 * Dark action bar</a> visual style), a textual label, and a {@link PendingIntent}.
 * <p>
 * A notification in its expanded form can display up to 3 actions, from left to right in
 * the order they were added. Actions will not be displayed when the notification is
 * collapsed, however, so be sure that any essential functions may be accessed by the user
 * in some other way (for example, in the Activity pointed to by {@link #contentIntent}).
 *
 * @param action The action to add.
 */
","/**
 * Add an action to this notification. Actions are typically displayed by
 * the system as a button adjacent to the notification content.
 * <p>
 * Every action must have an icon (32dp square and matching the
 * <a href=""{@docRoot}design/style/iconography.html#action-bar"">Holo
 * Dark action bar</a> visual style), a textual label, and a {@link PendingIntent}.
 * <p>
 * A notification in its expanded form can display up to 3 actions, from left to right in
 * the order they were added. Actions will not be displayed when the notification is
 * collapsed, however, so be sure that any essential functions may be accessed by the user
 * in some other way (for example, in the Activity pointed to by {@link #contentIntent}).
 *
 * @param action The action to add.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"An if-statement has been added to check for null before adding the action to mActions; this represents a control dependency change (type 3). However, since there are no other new variables introduced or any removed variables, it is also an other statement changed (type 4).","The newly added null-check does not influence the return type or value, since both the early and late versions return 'this'. There is also no change in exception throwing behavior. Therefore, no Compatibility Issue should arise from this change."
78,<android.app.ActivityManager: List<RunningAppProcessInfo> getRunningAppProcesses()>,25,26,<android.app.ActivityManager: List<RunningAppProcessInfo> getRunningAppProcesses()>,<android.app.ActivityManager: List<RunningAppProcessInfo> getRunningAppProcesses()>,0,"{
    try {
        return ActivityManagerNative.getDefault().getRunningAppProcesses();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        return getService().getRunningAppProcesses();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns a list of application processes that are running on the device.
 *
 * <p><b>Note: this method is only intended for debugging or building
 * a user-facing process management UI.</b></p>
 *
 * @return Returns a list of RunningAppProcessInfo records, or null if there are no
 * running processes (it will not return an empty list).  This list ordering is not
 * specified.
 */
","/**
 * Returns a list of application processes that are running on the device.
 *
 * <p><b>Note: this method is only intended for debugging or building
 * a user-facing process management UI.</b></p>
 *
 * @return Returns a list of RunningAppProcessInfo records, or null if there are no
 * running processes (it will not return an empty list).  This list ordering is not
 * specified.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method used to obtain the service has changed from ActivityManagerNative.getDefault() to getService(). This modification is an internal implementation detail, hence the code change type is 5.","Since the method change does not impact the behavior of how an exception is thrown or how values are returned by the API, no Compatibility Issue is introduced. It's an internal refactoring that should not affect the API contract."
79,<android.app.SharedPreferencesImpl.EditorImpl: void apply()>,25,26,<android.app.SharedPreferencesImpl.EditorImpl: void apply()>,<android.app.SharedPreferencesImpl.EditorImpl: void apply()>,0,"{
    final MemoryCommitResult mcr = commitToMemory();
    final Runnable awaitCommit = new Runnable() {

        public void run() {
            try {
                mcr.writtenToDiskLatch.await();
            } catch (InterruptedException ignored) {
            }
        }
    };
    QueuedWork.add(awaitCommit);
    Runnable postWriteRunnable = new Runnable() {

        public void run() {
            awaitCommit.run();
            QueuedWork.remove(awaitCommit);
        }
    };
    SharedPreferencesImpl.this.enqueueDiskWrite(mcr, postWriteRunnable);
    // Okay to notify the listeners before it's hit disk
    // because the listeners should always get the same
    // SharedPreferences instance back, which has the
    // changes reflected in memory.
    notifyListeners(mcr);
}","{
    final long startTime = System.currentTimeMillis();
    final MemoryCommitResult mcr = commitToMemory();
    final Runnable awaitCommit = new Runnable() {

        public void run() {
            try {
                mcr.writtenToDiskLatch.await();
            } catch (InterruptedException ignored) {
            }
            if (DEBUG && mcr.wasWritten) {
                Log.d(TAG, mFile.getName() + "":"" + mcr.memoryStateGeneration + "" applied after "" + (System.currentTimeMillis() - startTime) + "" ms"");
            }
        }
    };
    QueuedWork.addFinisher(awaitCommit);
    Runnable postWriteRunnable = new Runnable() {

        public void run() {
            awaitCommit.run();
            QueuedWork.removeFinisher(awaitCommit);
        }
    };
    SharedPreferencesImpl.this.enqueueDiskWrite(mcr, postWriteRunnable);
    // Okay to notify the listeners before it's hit disk
    // because the listeners should always get the same
    // SharedPreferences instance back, which has the
    // changes reflected in memory.
    notifyListeners(mcr);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only changes are the addition of a variable (startTime) for logging purposes and the renaming of functions from QueuedWork.add to QueuedWork.addFinisher and QueuedWork.remove to QueuedWork.removeFinisher. Logging does not change the behavior of the method, and the renaming indicates a refactor without implications on overall behavior assuming the renamed methods have the same behavior.",There is no compatibility issue here because the use of startTime for logging purposes and the renamed methods are unlikely to change the method's behavior from the caller's perspective.
80,"<android.view.ViewGroup: void invalidateChild(View,Rect)>",25,26,"<android.view.ViewGroup: void invalidateChild(View,Rect)>","<android.view.ViewGroup: void invalidateChild(View,Rect)>",0,"{
    ViewParent parent = this;
    final AttachInfo attachInfo = mAttachInfo;
    if (attachInfo != null) {
        // If the child is drawing an animation, we want to copy this flag onto
        // ourselves and the parent to make sure the invalidate request goes
        // through
        final boolean drawAnimation = (child.mPrivateFlags & PFLAG_DRAW_ANIMATION) == PFLAG_DRAW_ANIMATION;
        // Check whether the child that requests the invalidate is fully opaque
        // Views being animated or transformed are not considered opaque because we may
        // be invalidating their old position and need the parent to paint behind them.
        Matrix childMatrix = child.getMatrix();
        final boolean isOpaque = child.isOpaque() && !drawAnimation && child.getAnimation() == null && childMatrix.isIdentity();
        // Mark the child as dirty, using the appropriate flag
        // Make sure we do not set both flags at the same time
        int opaqueFlag = isOpaque ? PFLAG_DIRTY_OPAQUE : PFLAG_DIRTY;
        if (child.mLayerType != LAYER_TYPE_NONE) {
            mPrivateFlags |= PFLAG_INVALIDATED;
            mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
        }
        final int[] location = attachInfo.mInvalidateChildLocation;
        location[CHILD_LEFT_INDEX] = child.mLeft;
        location[CHILD_TOP_INDEX] = child.mTop;
        if (!childMatrix.isIdentity() || (mGroupFlags & ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != 0) {
            RectF boundingRect = attachInfo.mTmpTransformRect;
            boundingRect.set(dirty);
            Matrix transformMatrix;
            if ((mGroupFlags & ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != 0) {
                Transformation t = attachInfo.mTmpTransformation;
                boolean transformed = getChildStaticTransformation(child, t);
                if (transformed) {
                    transformMatrix = attachInfo.mTmpMatrix;
                    transformMatrix.set(t.getMatrix());
                    if (!childMatrix.isIdentity()) {
                        transformMatrix.preConcat(childMatrix);
                    }
                } else {
                    transformMatrix = childMatrix;
                }
            } else {
                transformMatrix = childMatrix;
            }
            transformMatrix.mapRect(boundingRect);
            dirty.set((int) Math.floor(boundingRect.left), (int) Math.floor(boundingRect.top), (int) Math.ceil(boundingRect.right), (int) Math.ceil(boundingRect.bottom));
        }
        do {
            View view = null;
            if (parent instanceof View) {
                view = (View) parent;
            }
            if (drawAnimation) {
                if (view != null) {
                    view.mPrivateFlags |= PFLAG_DRAW_ANIMATION;
                } else if (parent instanceof ViewRootImpl) {
                    ((ViewRootImpl) parent).mIsAnimating = true;
                }
            }
            // flag coming from the child that initiated the invalidate
            if (view != null) {
                if ((view.mViewFlags & FADING_EDGE_MASK) != 0 && view.getSolidColor() == 0) {
                    opaqueFlag = PFLAG_DIRTY;
                }
                if ((view.mPrivateFlags & PFLAG_DIRTY_MASK) != PFLAG_DIRTY) {
                    view.mPrivateFlags = (view.mPrivateFlags & ~PFLAG_DIRTY_MASK) | opaqueFlag;
                }
            }
            parent = parent.invalidateChildInParent(location, dirty);
            if (view != null) {
                // Account for transform on current parent
                Matrix m = view.getMatrix();
                if (!m.isIdentity()) {
                    RectF boundingRect = attachInfo.mTmpTransformRect;
                    boundingRect.set(dirty);
                    m.mapRect(boundingRect);
                    dirty.set((int) Math.floor(boundingRect.left), (int) Math.floor(boundingRect.top), (int) Math.ceil(boundingRect.right), (int) Math.ceil(boundingRect.bottom));
                }
            }
        } while (parent != null);
    }
}","{
    final AttachInfo attachInfo = mAttachInfo;
    if (attachInfo != null && attachInfo.mHardwareAccelerated) {
        // HW accelerated fast path
        onDescendantInvalidated(child, child);
        return;
    }
    ViewParent parent = this;
    if (attachInfo != null) {
        // If the child is drawing an animation, we want to copy this flag onto
        // ourselves and the parent to make sure the invalidate request goes
        // through
        final boolean drawAnimation = (child.mPrivateFlags & PFLAG_DRAW_ANIMATION) != 0;
        // Check whether the child that requests the invalidate is fully opaque
        // Views being animated or transformed are not considered opaque because we may
        // be invalidating their old position and need the parent to paint behind them.
        Matrix childMatrix = child.getMatrix();
        final boolean isOpaque = child.isOpaque() && !drawAnimation && child.getAnimation() == null && childMatrix.isIdentity();
        // Mark the child as dirty, using the appropriate flag
        // Make sure we do not set both flags at the same time
        int opaqueFlag = isOpaque ? PFLAG_DIRTY_OPAQUE : PFLAG_DIRTY;
        if (child.mLayerType != LAYER_TYPE_NONE) {
            mPrivateFlags |= PFLAG_INVALIDATED;
            mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
        }
        final int[] location = attachInfo.mInvalidateChildLocation;
        location[CHILD_LEFT_INDEX] = child.mLeft;
        location[CHILD_TOP_INDEX] = child.mTop;
        if (!childMatrix.isIdentity() || (mGroupFlags & ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != 0) {
            RectF boundingRect = attachInfo.mTmpTransformRect;
            boundingRect.set(dirty);
            Matrix transformMatrix;
            if ((mGroupFlags & ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != 0) {
                Transformation t = attachInfo.mTmpTransformation;
                boolean transformed = getChildStaticTransformation(child, t);
                if (transformed) {
                    transformMatrix = attachInfo.mTmpMatrix;
                    transformMatrix.set(t.getMatrix());
                    if (!childMatrix.isIdentity()) {
                        transformMatrix.preConcat(childMatrix);
                    }
                } else {
                    transformMatrix = childMatrix;
                }
            } else {
                transformMatrix = childMatrix;
            }
            transformMatrix.mapRect(boundingRect);
            dirty.set((int) Math.floor(boundingRect.left), (int) Math.floor(boundingRect.top), (int) Math.ceil(boundingRect.right), (int) Math.ceil(boundingRect.bottom));
        }
        do {
            View view = null;
            if (parent instanceof View) {
                view = (View) parent;
            }
            if (drawAnimation) {
                if (view != null) {
                    view.mPrivateFlags |= PFLAG_DRAW_ANIMATION;
                } else if (parent instanceof ViewRootImpl) {
                    ((ViewRootImpl) parent).mIsAnimating = true;
                }
            }
            // flag coming from the child that initiated the invalidate
            if (view != null) {
                if ((view.mViewFlags & FADING_EDGE_MASK) != 0 && view.getSolidColor() == 0) {
                    opaqueFlag = PFLAG_DIRTY;
                }
                if ((view.mPrivateFlags & PFLAG_DIRTY_MASK) != PFLAG_DIRTY) {
                    view.mPrivateFlags = (view.mPrivateFlags & ~PFLAG_DIRTY_MASK) | opaqueFlag;
                }
            }
            parent = parent.invalidateChildInParent(location, dirty);
            if (view != null) {
                // Account for transform on current parent
                Matrix m = view.getMatrix();
                if (!m.isIdentity()) {
                    RectF boundingRect = attachInfo.mTmpTransformRect;
                    boundingRect.set(dirty);
                    m.mapRect(boundingRect);
                    dirty.set((int) Math.floor(boundingRect.left), (int) Math.floor(boundingRect.top), (int) Math.ceil(boundingRect.right), (int) Math.ceil(boundingRect.bottom));
                }
            }
        } while (parent != null);
    }
}",1,"/**
 * Don't call or override this method. It is used for the implementation of
 * the view hierarchy.
 */
","/**
 * Don't call or override this method. It is used for the implementation of
 * the view hierarchy.
 *
 * @deprecated Use {@link #onDescendantInvalidated(View, View)} instead to observe updates to
 * draw state in descendants.
 */
",-1,[@Override],"[@Deprecated, @Override]",-1,-1,-1,-1,-1,-1,,,,
81,"<android.content.UriMatcher: void addURI(String,String,int)>",25,26,"<android.content.UriMatcher: void addURI(String,String,int)>","<android.content.UriMatcher: void addURI(String,String,int)>",0,"{
    if (code < 0) {
        throw new IllegalArgumentException(""code "" + code + "" is invalid: it must be positive"");
    }
    String[] tokens = null;
    if (path != null) {
        String newPath = path;
        // Strip leading slash if present.
        if (path.length() > 0 && path.charAt(0) == '/') {
            newPath = path.substring(1);
        }
        tokens = newPath.split(""/"");
    }
    int numTokens = tokens != null ? tokens.length : 0;
    UriMatcher node = this;
    for (int i = -1; i < numTokens; i++) {
        String token = i < 0 ? authority : tokens[i];
        ArrayList<UriMatcher> children = node.mChildren;
        int numChildren = children.size();
        UriMatcher child;
        int j;
        for (j = 0; j < numChildren; j++) {
            child = children.get(j);
            if (token.equals(child.mText)) {
                node = child;
                break;
            }
        }
        if (j == numChildren) {
            // Child not found, create it
            child = new UriMatcher();
            if (token.equals(""#"")) {
                child.mWhich = NUMBER;
            } else if (token.equals(""*"")) {
                child.mWhich = TEXT;
            } else {
                child.mWhich = EXACT;
            }
            child.mText = token;
            node.mChildren.add(child);
            node = child;
        }
    }
    node.mCode = code;
}","{
    if (code < 0) {
        throw new IllegalArgumentException(""code "" + code + "" is invalid: it must be positive"");
    }
    String[] tokens = null;
    if (path != null) {
        String newPath = path;
        // Strip leading slash if present.
        if (path.length() > 1 && path.charAt(0) == '/') {
            newPath = path.substring(1);
        }
        tokens = newPath.split(""/"");
    }
    int numTokens = tokens != null ? tokens.length : 0;
    UriMatcher node = this;
    for (int i = -1; i < numTokens; i++) {
        String token = i < 0 ? authority : tokens[i];
        ArrayList<UriMatcher> children = node.mChildren;
        int numChildren = children.size();
        UriMatcher child;
        int j;
        for (j = 0; j < numChildren; j++) {
            child = children.get(j);
            if (token.equals(child.mText)) {
                node = child;
                break;
            }
        }
        if (j == numChildren) {
            // Child not found, create it
            child = new UriMatcher();
            if (token.equals(""#"")) {
                child.mWhich = NUMBER;
            } else if (token.equals(""*"")) {
                child.mWhich = TEXT;
            } else {
                child.mWhich = EXACT;
            }
            child.mText = token;
            node.mChildren.add(child);
            node = child;
        }
    }
    node.mCode = code;
}",1,"/**
 * Add a URI to match, and the code to return when this URI is
 * matched. URI nodes may be exact match string, the token ""*""
 * that matches any text, or the token ""#"" that matches only
 * numbers.
 * <p>
 * Starting from API level {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2},
 * this method will accept a leading slash in the path.
 *
 * @param authority the authority to match
 * @param path the path to match. * may be used as a wild card for
 * any text, and # may be used as a wild card for numbers.
 * @param code the code that is returned when a URI is matched
 * against the given components. Must be positive.
 */
","/**
 * Add a URI to match, and the code to return when this URI is
 * matched. URI nodes may be exact match string, the token ""*""
 * that matches any text, or the token ""#"" that matches only
 * numbers.
 * <p>
 * Starting from API level {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2},
 * this method will accept a leading slash in the path.
 *
 * @param authority the authority to match
 * @param path the path to match. * may be used as a wild card for
 * any text, and # may be used as a wild card for numbers.
 * @param code the code that is returned when a URI is matched
 * against the given components. Must be positive.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The path.length() condition check has changed from > 0 to > 1 in the statement that strips the leading slash, which changes the control dependency. Therefore, the code change type is 3.","There should be no Compatibility Issue introduced by this change, because the modified condition is specifically designed to avoid stripping the leading slash when there is only one character in the path (which would be the slash itself). This is more of a correctness fix than a change in the method's behavior when it comes to handling URIs. The logic for handling tokens and assigning codes remains consistent with the previous version of the API. Hence, the CI type is 0."
82,"<android.text.StaticLayout: void generate(Builder,boolean,boolean)>",25,26,"<android.text.StaticLayout: void generate(Builder,boolean,boolean)>","<android.text.StaticLayout: void generate(Builder,boolean,boolean)>",0,"{
    CharSequence source = b.mText;
    int bufStart = b.mStart;
    int bufEnd = b.mEnd;
    TextPaint paint = b.mPaint;
    int outerWidth = b.mWidth;
    TextDirectionHeuristic textDir = b.mTextDir;
    float spacingmult = b.mSpacingMult;
    float spacingadd = b.mSpacingAdd;
    float ellipsizedWidth = b.mEllipsizedWidth;
    TextUtils.TruncateAt ellipsize = b.mEllipsize;
    // TODO: move to builder to avoid allocation costs
    LineBreaks lineBreaks = new LineBreaks();
    // store span end locations
    int[] spanEndCache = new int[4];
    // store fontMetrics per span range
    // must be a multiple of 4 (and > 0) (store top, bottom, ascent, and descent per range)
    int[] fmCache = new int[4 * 4];
    // TODO: also respect LocaleSpan within the text
    b.setLocale(paint.getTextLocale());
    mLineCount = 0;
    int v = 0;
    boolean needMultiply = (spacingmult != 1 || spacingadd != 0);
    Paint.FontMetricsInt fm = b.mFontMetricsInt;
    int[] chooseHtv = null;
    MeasuredText measured = b.mMeasuredText;
    Spanned spanned = null;
    if (source instanceof Spanned)
        spanned = (Spanned) source;
    int paraEnd;
    for (int paraStart = bufStart; paraStart <= bufEnd; paraStart = paraEnd) {
        paraEnd = TextUtils.indexOf(source, CHAR_NEW_LINE, paraStart, bufEnd);
        if (paraEnd < 0)
            paraEnd = bufEnd;
        else
            paraEnd++;
        int firstWidthLineCount = 1;
        int firstWidth = outerWidth;
        int restWidth = outerWidth;
        LineHeightSpan[] chooseHt = null;
        if (spanned != null) {
            LeadingMarginSpan[] sp = getParagraphSpans(spanned, paraStart, paraEnd, LeadingMarginSpan.class);
            for (int i = 0; i < sp.length; i++) {
                LeadingMarginSpan lms = sp[i];
                firstWidth -= sp[i].getLeadingMargin(true);
                restWidth -= sp[i].getLeadingMargin(false);
                // leading margin spans, not just this particular one
                if (lms instanceof LeadingMarginSpan2) {
                    LeadingMarginSpan2 lms2 = (LeadingMarginSpan2) lms;
                    firstWidthLineCount = Math.max(firstWidthLineCount, lms2.getLeadingMarginLineCount());
                }
            }
            chooseHt = getParagraphSpans(spanned, paraStart, paraEnd, LineHeightSpan.class);
            if (chooseHt.length == 0) {
                // So that out() would not assume it has any contents
                chooseHt = null;
            } else {
                if (chooseHtv == null || chooseHtv.length < chooseHt.length) {
                    chooseHtv = ArrayUtils.newUnpaddedIntArray(chooseHt.length);
                }
                for (int i = 0; i < chooseHt.length; i++) {
                    int o = spanned.getSpanStart(chooseHt[i]);
                    if (o < paraStart) {
                        // starts in this layout, before the
                        // current paragraph
                        chooseHtv[i] = getLineTop(getLineForOffset(o));
                    } else {
                        // starts in this paragraph
                        chooseHtv[i] = v;
                    }
                }
            }
        }
        measured.setPara(source, paraStart, paraEnd, textDir, b);
        char[] chs = measured.mChars;
        float[] widths = measured.mWidths;
        byte[] chdirs = measured.mLevels;
        int dir = measured.mDir;
        boolean easy = measured.mEasy;
        // tab stop locations
        int[] variableTabStops = null;
        if (spanned != null) {
            TabStopSpan[] spans = getParagraphSpans(spanned, paraStart, paraEnd, TabStopSpan.class);
            if (spans.length > 0) {
                int[] stops = new int[spans.length];
                for (int i = 0; i < spans.length; i++) {
                    stops[i] = spans[i].getTabStop();
                }
                Arrays.sort(stops, 0, stops.length);
                variableTabStops = stops;
            }
        }
        nSetupParagraph(b.mNativePtr, chs, paraEnd - paraStart, firstWidth, firstWidthLineCount, restWidth, variableTabStops, TAB_INCREMENT, b.mBreakStrategy, b.mHyphenationFrequency);
        if (mLeftIndents != null || mRightIndents != null) {
            // TODO(raph) performance: it would be better to do this once per layout rather
            // than once per paragraph, but that would require a change to the native
            // interface.
            int leftLen = mLeftIndents == null ? 0 : mLeftIndents.length;
            int rightLen = mRightIndents == null ? 0 : mRightIndents.length;
            int indentsLen = Math.max(1, Math.max(leftLen, rightLen) - mLineCount);
            int[] indents = new int[indentsLen];
            for (int i = 0; i < indentsLen; i++) {
                int leftMargin = mLeftIndents == null ? 0 : mLeftIndents[Math.min(i + mLineCount, leftLen - 1)];
                int rightMargin = mRightIndents == null ? 0 : mRightIndents[Math.min(i + mLineCount, rightLen - 1)];
                indents[i] = leftMargin + rightMargin;
            }
            nSetIndents(b.mNativePtr, indents);
        }
        // measurement has to be done before performing line breaking
        // but we don't want to recompute fontmetrics or span ranges the
        // second time, so we cache those and then use those stored values
        int fmCacheCount = 0;
        int spanEndCacheCount = 0;
        for (int spanStart = paraStart, spanEnd; spanStart < paraEnd; spanStart = spanEnd) {
            if (fmCacheCount * 4 >= fmCache.length) {
                int[] grow = new int[fmCacheCount * 4 * 2];
                System.arraycopy(fmCache, 0, grow, 0, fmCacheCount * 4);
                fmCache = grow;
            }
            if (spanEndCacheCount >= spanEndCache.length) {
                int[] grow = new int[spanEndCacheCount * 2];
                System.arraycopy(spanEndCache, 0, grow, 0, spanEndCacheCount);
                spanEndCache = grow;
            }
            if (spanned == null) {
                spanEnd = paraEnd;
                int spanLen = spanEnd - spanStart;
                measured.addStyleRun(paint, spanLen, fm);
            } else {
                spanEnd = spanned.nextSpanTransition(spanStart, paraEnd, MetricAffectingSpan.class);
                int spanLen = spanEnd - spanStart;
                MetricAffectingSpan[] spans = spanned.getSpans(spanStart, spanEnd, MetricAffectingSpan.class);
                spans = TextUtils.removeEmptySpans(spans, spanned, MetricAffectingSpan.class);
                measured.addStyleRun(paint, spans, spanLen, fm);
            }
            // the order of storage here (top, bottom, ascent, descent) has to match the code below
            // where these values are retrieved
            fmCache[fmCacheCount * 4 + 0] = fm.top;
            fmCache[fmCacheCount * 4 + 1] = fm.bottom;
            fmCache[fmCacheCount * 4 + 2] = fm.ascent;
            fmCache[fmCacheCount * 4 + 3] = fm.descent;
            fmCacheCount++;
            spanEndCache[spanEndCacheCount] = spanEnd;
            spanEndCacheCount++;
        }
        nGetWidths(b.mNativePtr, widths);
        int breakCount = nComputeLineBreaks(b.mNativePtr, lineBreaks, lineBreaks.breaks, lineBreaks.widths, lineBreaks.flags, lineBreaks.breaks.length);
        int[] breaks = lineBreaks.breaks;
        float[] lineWidths = lineBreaks.widths;
        int[] flags = lineBreaks.flags;
        final int remainingLineCount = mMaximumVisibleLineCount - mLineCount;
        final boolean ellipsisMayBeApplied = ellipsize != null && (ellipsize == TextUtils.TruncateAt.END || (mMaximumVisibleLineCount == 1 && ellipsize != TextUtils.TruncateAt.MARQUEE));
        if (remainingLineCount > 0 && remainingLineCount < breakCount && ellipsisMayBeApplied) {
            // Calculate width and flag.
            float width = 0;
            int flag = 0;
            for (int i = remainingLineCount - 1; i < breakCount; i++) {
                if (i == breakCount - 1) {
                    width += lineWidths[i];
                } else {
                    for (int j = (i == 0 ? 0 : breaks[i - 1]); j < breaks[i]; j++) {
                        width += widths[j];
                    }
                }
                flag |= flags[i] & TAB_MASK;
            }
            // Treat the last line and overflowed lines as a single line.
            breaks[remainingLineCount - 1] = breaks[breakCount - 1];
            lineWidths[remainingLineCount - 1] = width;
            flags[remainingLineCount - 1] = flag;
            breakCount = remainingLineCount;
        }
        // here is the offset of the starting character of the line we are currently measuring
        int here = paraStart;
        int fmTop = 0, fmBottom = 0, fmAscent = 0, fmDescent = 0;
        int fmCacheIndex = 0;
        int spanEndCacheIndex = 0;
        int breakIndex = 0;
        for (int spanStart = paraStart, spanEnd; spanStart < paraEnd; spanStart = spanEnd) {
            // retrieve end of span
            spanEnd = spanEndCache[spanEndCacheIndex++];
            // retrieve cached metrics, order matches above
            fm.top = fmCache[fmCacheIndex * 4 + 0];
            fm.bottom = fmCache[fmCacheIndex * 4 + 1];
            fm.ascent = fmCache[fmCacheIndex * 4 + 2];
            fm.descent = fmCache[fmCacheIndex * 4 + 3];
            fmCacheIndex++;
            if (fm.top < fmTop) {
                fmTop = fm.top;
            }
            if (fm.ascent < fmAscent) {
                fmAscent = fm.ascent;
            }
            if (fm.descent > fmDescent) {
                fmDescent = fm.descent;
            }
            if (fm.bottom > fmBottom) {
                fmBottom = fm.bottom;
            }
            // skip breaks ending before current span range
            while (breakIndex < breakCount && paraStart + breaks[breakIndex] < spanStart) {
                breakIndex++;
            }
            while (breakIndex < breakCount && paraStart + breaks[breakIndex] <= spanEnd) {
                int endPos = paraStart + breaks[breakIndex];
                boolean moreChars = (endPos < bufEnd);
                v = out(source, here, endPos, fmAscent, fmDescent, fmTop, fmBottom, v, spacingmult, spacingadd, chooseHt, chooseHtv, fm, flags[breakIndex], needMultiply, chdirs, dir, easy, bufEnd, includepad, trackpad, chs, widths, paraStart, ellipsize, ellipsizedWidth, lineWidths[breakIndex], paint, moreChars);
                if (endPos < spanEnd) {
                    // preserve metrics for current span
                    fmTop = fm.top;
                    fmBottom = fm.bottom;
                    fmAscent = fm.ascent;
                    fmDescent = fm.descent;
                } else {
                    fmTop = fmBottom = fmAscent = fmDescent = 0;
                }
                here = endPos;
                breakIndex++;
                if (mLineCount >= mMaximumVisibleLineCount) {
                    return;
                }
            }
        }
        if (paraEnd == bufEnd)
            break;
    }
    if ((bufEnd == bufStart || source.charAt(bufEnd - 1) == CHAR_NEW_LINE) && mLineCount < mMaximumVisibleLineCount) {
        // Log.e(""text"", ""output last "" + bufEnd);
        measured.setPara(source, bufEnd, bufEnd, textDir, b);
        paint.getFontMetricsInt(fm);
        v = out(source, bufEnd, bufEnd, fm.ascent, fm.descent, fm.top, fm.bottom, v, spacingmult, spacingadd, null, null, fm, 0, needMultiply, measured.mLevels, measured.mDir, measured.mEasy, bufEnd, includepad, trackpad, null, null, bufStart, ellipsize, ellipsizedWidth, 0, paint, false);
    }
}","{
    CharSequence source = b.mText;
    int bufStart = b.mStart;
    int bufEnd = b.mEnd;
    TextPaint paint = b.mPaint;
    int outerWidth = b.mWidth;
    TextDirectionHeuristic textDir = b.mTextDir;
    float spacingmult = b.mSpacingMult;
    float spacingadd = b.mSpacingAdd;
    float ellipsizedWidth = b.mEllipsizedWidth;
    TextUtils.TruncateAt ellipsize = b.mEllipsize;
    // TODO: move to builder to avoid allocation costs
    LineBreaks lineBreaks = new LineBreaks();
    // store span end locations
    int[] spanEndCache = new int[4];
    // store fontMetrics per span range
    // must be a multiple of 4 (and > 0) (store top, bottom, ascent, and descent per range)
    int[] fmCache = new int[4 * 4];
    // TODO: also respect LocaleSpan within the text
    b.setLocale(paint.getTextLocale());
    mLineCount = 0;
    int v = 0;
    boolean needMultiply = (spacingmult != 1 || spacingadd != 0);
    Paint.FontMetricsInt fm = b.mFontMetricsInt;
    int[] chooseHtv = null;
    MeasuredText measured = b.mMeasuredText;
    Spanned spanned = null;
    if (source instanceof Spanned)
        spanned = (Spanned) source;
    int paraEnd;
    for (int paraStart = bufStart; paraStart <= bufEnd; paraStart = paraEnd) {
        paraEnd = TextUtils.indexOf(source, CHAR_NEW_LINE, paraStart, bufEnd);
        if (paraEnd < 0)
            paraEnd = bufEnd;
        else
            paraEnd++;
        int firstWidthLineCount = 1;
        int firstWidth = outerWidth;
        int restWidth = outerWidth;
        LineHeightSpan[] chooseHt = null;
        if (spanned != null) {
            LeadingMarginSpan[] sp = getParagraphSpans(spanned, paraStart, paraEnd, LeadingMarginSpan.class);
            for (int i = 0; i < sp.length; i++) {
                LeadingMarginSpan lms = sp[i];
                firstWidth -= sp[i].getLeadingMargin(true);
                restWidth -= sp[i].getLeadingMargin(false);
                // leading margin spans, not just this particular one
                if (lms instanceof LeadingMarginSpan2) {
                    LeadingMarginSpan2 lms2 = (LeadingMarginSpan2) lms;
                    firstWidthLineCount = Math.max(firstWidthLineCount, lms2.getLeadingMarginLineCount());
                }
            }
            chooseHt = getParagraphSpans(spanned, paraStart, paraEnd, LineHeightSpan.class);
            if (chooseHt.length == 0) {
                // So that out() would not assume it has any contents
                chooseHt = null;
            } else {
                if (chooseHtv == null || chooseHtv.length < chooseHt.length) {
                    chooseHtv = ArrayUtils.newUnpaddedIntArray(chooseHt.length);
                }
                for (int i = 0; i < chooseHt.length; i++) {
                    int o = spanned.getSpanStart(chooseHt[i]);
                    if (o < paraStart) {
                        // starts in this layout, before the
                        // current paragraph
                        chooseHtv[i] = getLineTop(getLineForOffset(o));
                    } else {
                        // starts in this paragraph
                        chooseHtv[i] = v;
                    }
                }
            }
        }
        measured.setPara(source, paraStart, paraEnd, textDir, b);
        char[] chs = measured.mChars;
        float[] widths = measured.mWidths;
        byte[] chdirs = measured.mLevels;
        int dir = measured.mDir;
        boolean easy = measured.mEasy;
        // tab stop locations
        int[] variableTabStops = null;
        if (spanned != null) {
            TabStopSpan[] spans = getParagraphSpans(spanned, paraStart, paraEnd, TabStopSpan.class);
            if (spans.length > 0) {
                int[] stops = new int[spans.length];
                for (int i = 0; i < spans.length; i++) {
                    stops[i] = spans[i].getTabStop();
                }
                Arrays.sort(stops, 0, stops.length);
                variableTabStops = stops;
            }
        }
        nSetupParagraph(b.mNativePtr, chs, paraEnd - paraStart, firstWidth, firstWidthLineCount, restWidth, variableTabStops, TAB_INCREMENT, b.mBreakStrategy, b.mHyphenationFrequency, // TODO: Support more justification mode, e.g. letter spacing, stretching.
        b.mJustificationMode != Layout.JUSTIFICATION_MODE_NONE);
        if (mLeftIndents != null || mRightIndents != null) {
            // TODO(raph) performance: it would be better to do this once per layout rather
            // than once per paragraph, but that would require a change to the native
            // interface.
            int leftLen = mLeftIndents == null ? 0 : mLeftIndents.length;
            int rightLen = mRightIndents == null ? 0 : mRightIndents.length;
            int indentsLen = Math.max(1, Math.max(leftLen, rightLen) - mLineCount);
            int[] indents = new int[indentsLen];
            for (int i = 0; i < indentsLen; i++) {
                int leftMargin = mLeftIndents == null ? 0 : mLeftIndents[Math.min(i + mLineCount, leftLen - 1)];
                int rightMargin = mRightIndents == null ? 0 : mRightIndents[Math.min(i + mLineCount, rightLen - 1)];
                indents[i] = leftMargin + rightMargin;
            }
            nSetIndents(b.mNativePtr, indents);
        }
        // measurement has to be done before performing line breaking
        // but we don't want to recompute fontmetrics or span ranges the
        // second time, so we cache those and then use those stored values
        int fmCacheCount = 0;
        int spanEndCacheCount = 0;
        for (int spanStart = paraStart, spanEnd; spanStart < paraEnd; spanStart = spanEnd) {
            if (fmCacheCount * 4 >= fmCache.length) {
                int[] grow = new int[fmCacheCount * 4 * 2];
                System.arraycopy(fmCache, 0, grow, 0, fmCacheCount * 4);
                fmCache = grow;
            }
            if (spanEndCacheCount >= spanEndCache.length) {
                int[] grow = new int[spanEndCacheCount * 2];
                System.arraycopy(spanEndCache, 0, grow, 0, spanEndCacheCount);
                spanEndCache = grow;
            }
            if (spanned == null) {
                spanEnd = paraEnd;
                int spanLen = spanEnd - spanStart;
                measured.addStyleRun(paint, spanLen, fm);
            } else {
                spanEnd = spanned.nextSpanTransition(spanStart, paraEnd, MetricAffectingSpan.class);
                int spanLen = spanEnd - spanStart;
                MetricAffectingSpan[] spans = spanned.getSpans(spanStart, spanEnd, MetricAffectingSpan.class);
                spans = TextUtils.removeEmptySpans(spans, spanned, MetricAffectingSpan.class);
                measured.addStyleRun(paint, spans, spanLen, fm);
            }
            // the order of storage here (top, bottom, ascent, descent) has to match the code below
            // where these values are retrieved
            fmCache[fmCacheCount * 4 + 0] = fm.top;
            fmCache[fmCacheCount * 4 + 1] = fm.bottom;
            fmCache[fmCacheCount * 4 + 2] = fm.ascent;
            fmCache[fmCacheCount * 4 + 3] = fm.descent;
            fmCacheCount++;
            spanEndCache[spanEndCacheCount] = spanEnd;
            spanEndCacheCount++;
        }
        nGetWidths(b.mNativePtr, widths);
        int breakCount = nComputeLineBreaks(b.mNativePtr, lineBreaks, lineBreaks.breaks, lineBreaks.widths, lineBreaks.flags, lineBreaks.breaks.length);
        int[] breaks = lineBreaks.breaks;
        float[] lineWidths = lineBreaks.widths;
        int[] flags = lineBreaks.flags;
        final int remainingLineCount = mMaximumVisibleLineCount - mLineCount;
        final boolean ellipsisMayBeApplied = ellipsize != null && (ellipsize == TextUtils.TruncateAt.END || (mMaximumVisibleLineCount == 1 && ellipsize != TextUtils.TruncateAt.MARQUEE));
        if (remainingLineCount > 0 && remainingLineCount < breakCount && ellipsisMayBeApplied) {
            // Calculate width and flag.
            float width = 0;
            int flag = 0;
            for (int i = remainingLineCount - 1; i < breakCount; i++) {
                if (i == breakCount - 1) {
                    width += lineWidths[i];
                } else {
                    for (int j = (i == 0 ? 0 : breaks[i - 1]); j < breaks[i]; j++) {
                        width += widths[j];
                    }
                }
                flag |= flags[i] & TAB_MASK;
            }
            // Treat the last line and overflowed lines as a single line.
            breaks[remainingLineCount - 1] = breaks[breakCount - 1];
            lineWidths[remainingLineCount - 1] = width;
            flags[remainingLineCount - 1] = flag;
            breakCount = remainingLineCount;
        }
        // here is the offset of the starting character of the line we are currently measuring
        int here = paraStart;
        int fmTop = 0, fmBottom = 0, fmAscent = 0, fmDescent = 0;
        int fmCacheIndex = 0;
        int spanEndCacheIndex = 0;
        int breakIndex = 0;
        for (int spanStart = paraStart, spanEnd; spanStart < paraEnd; spanStart = spanEnd) {
            // retrieve end of span
            spanEnd = spanEndCache[spanEndCacheIndex++];
            // retrieve cached metrics, order matches above
            fm.top = fmCache[fmCacheIndex * 4 + 0];
            fm.bottom = fmCache[fmCacheIndex * 4 + 1];
            fm.ascent = fmCache[fmCacheIndex * 4 + 2];
            fm.descent = fmCache[fmCacheIndex * 4 + 3];
            fmCacheIndex++;
            if (fm.top < fmTop) {
                fmTop = fm.top;
            }
            if (fm.ascent < fmAscent) {
                fmAscent = fm.ascent;
            }
            if (fm.descent > fmDescent) {
                fmDescent = fm.descent;
            }
            if (fm.bottom > fmBottom) {
                fmBottom = fm.bottom;
            }
            // skip breaks ending before current span range
            while (breakIndex < breakCount && paraStart + breaks[breakIndex] < spanStart) {
                breakIndex++;
            }
            while (breakIndex < breakCount && paraStart + breaks[breakIndex] <= spanEnd) {
                int endPos = paraStart + breaks[breakIndex];
                boolean moreChars = (endPos < bufEnd);
                v = out(source, here, endPos, fmAscent, fmDescent, fmTop, fmBottom, v, spacingmult, spacingadd, chooseHt, chooseHtv, fm, flags[breakIndex], needMultiply, chdirs, dir, easy, bufEnd, includepad, trackpad, chs, widths, paraStart, ellipsize, ellipsizedWidth, lineWidths[breakIndex], paint, moreChars);
                if (endPos < spanEnd) {
                    // preserve metrics for current span
                    fmTop = fm.top;
                    fmBottom = fm.bottom;
                    fmAscent = fm.ascent;
                    fmDescent = fm.descent;
                } else {
                    fmTop = fmBottom = fmAscent = fmDescent = 0;
                }
                here = endPos;
                breakIndex++;
                if (mLineCount >= mMaximumVisibleLineCount && mEllipsized) {
                    return;
                }
            }
        }
        if (paraEnd == bufEnd)
            break;
    }
    if ((bufEnd == bufStart || source.charAt(bufEnd - 1) == CHAR_NEW_LINE) && mLineCount < mMaximumVisibleLineCount) {
        // Log.e(""text"", ""output last "" + bufEnd);
        measured.setPara(source, bufEnd, bufEnd, textDir, b);
        paint.getFontMetricsInt(fm);
        v = out(source, bufEnd, bufEnd, fm.ascent, fm.descent, fm.top, fm.bottom, v, spacingmult, spacingadd, null, null, fm, 0, needMultiply, measured.mLevels, measured.mDir, measured.mEasy, bufEnd, includepad, trackpad, null, null, bufStart, ellipsize, ellipsizedWidth, 0, paint, false);
    }
}",1,"/* package */
","/* package */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
83,"<android.bluetooth.le.BluetoothLeScanner.BleScanCallbackWrapper: void onFoundOrLost(boolean,ScanResult)>",25,26,"<android.bluetooth.le.BluetoothLeScanner.BleScanCallbackWrapper: void onFoundOrLost(boolean,ScanResult)>","<android.bluetooth.le.BluetoothLeScanner.BleScanCallbackWrapper: void onFoundOrLost(boolean,ScanResult)>",0,"{
    if (VDBG) {
        Log.d(TAG, ""onFoundOrLost() - onFound = "" + onFound + "" "" + scanResult.toString());
    }
    // Check null in case the scan has been stopped
    synchronized (this) {
        if (mClientIf <= 0)
            return;
    }
    Handler handler = new Handler(Looper.getMainLooper());
    handler.post(new Runnable() {

        @Override
        public void run() {
            if (onFound) {
                mScanCallback.onScanResult(ScanSettings.CALLBACK_TYPE_FIRST_MATCH, scanResult);
            } else {
                mScanCallback.onScanResult(ScanSettings.CALLBACK_TYPE_MATCH_LOST, scanResult);
            }
        }
    });
}","{
    if (VDBG) {
        Log.d(TAG, ""onFoundOrLost() - onFound = "" + onFound + "" "" + scanResult.toString());
    }
    // Check null in case the scan has been stopped
    synchronized (this) {
        if (mScannerId <= 0)
            return;
    }
    Handler handler = new Handler(Looper.getMainLooper());
    handler.post(new Runnable() {

        @Override
        public void run() {
            if (onFound) {
                mScanCallback.onScanResult(ScanSettings.CALLBACK_TYPE_FIRST_MATCH, scanResult);
            } else {
                mScanCallback.onScanResult(ScanSettings.CALLBACK_TYPE_MATCH_LOST, scanResult);
            }
        }
    });
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The change in the implementation is just the replacement of the variable name from `mClientIf` to `mScannerId`. No change in functionality, control flow, return value, or exception handling occurred, hence the code change type is 4.","The change is just renaming an internal variable without impacting the external behavior of the method. Since no functionality has been altered and the method signature remains the same, there is no compatibility issue."
85,<android.bluetooth.BluetoothGatt: boolean connect()>,25,26,<android.bluetooth.BluetoothGatt: boolean connect()>,<android.bluetooth.BluetoothGatt: boolean connect()>,0,"{
    try {
        mService.clientConnect(mClientIf, mDevice.getAddress(), false, // autoConnect is inverse of ""isDirect""
        mTransport);
        return true;
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        return false;
    }
}","{
    try {
        mService.clientConnect(mClientIf, mDevice.getAddress(), false, mTransport, // autoConnect is inverse of ""isDirect""
        mPhy);
        return true;
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        return false;
    }
}",1,"/**
 * Connect back to remote device.
 *
 * <p>This method is used to re-connect to a remote device after the
 * connection has been dropped. If the device is not in range, the
 * re-connection will be triggered once the device is back in range.
 *
 * @return true, if the connection attempt was initiated successfully
 */
","/**
 * Connect back to remote device.
 *
 * <p>This method is used to re-connect to a remote device after the
 * connection has been dropped. If the device is not in range, the
 * re-connection will be triggered once the device is back in range.
 *
 * @return true, if the connection attempt was initiated successfully
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The dependent API clientConnect(...) has an additional parameter in the late version, so the code change type is 4 for the change in parameters of the method call, and 5 for the change in the dependent API.","Although there's an additional parameter in the clientConnect(...) method call, the handling of the call and the return statement are not affected. The method still catches the RemoteException and returns either true or false as before. Thus, there is no Compatibility Issue as the behavior of the API has not changed."
86,"<android.app.SharedPreferencesImpl: Map<String, ?> getAll()>",25,26,"<android.app.SharedPreferencesImpl: Map<String, ?> getAll()>","<android.app.SharedPreferencesImpl: Map<String, ?> getAll()>",0,"{
    synchronized (this) {
        awaitLoadedLocked();
        // noinspection unchecked
        return new HashMap<String, Object>(mMap);
    }
}","{
    synchronized (mLock) {
        awaitLoadedLocked();
        // noinspection unchecked
        return new HashMap<String, Object>(mMap);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,The only change made here is synchronization of a different object; the earlier version synchronizes on `this` while the late version synchronizes on `mLock`. So the change is of type 4 (Other statement changed).,"This change does not affect the behavior of the method's logic itself; it changes the object on which the method is synchronized to prevent concurrent modifications. The actual logic that constructs and returns the HashMap remains unchanged. Therefore, this modification does not lead to a Compatibility Issue."
87,<android.view.View: boolean dispatchDragEvent(DragEvent)>,25,26,<android.view.View: boolean dispatchDragEvent(DragEvent)>,<android.view.View: boolean dispatchDragEvent(DragEvent)>,0,"{
    ListenerInfo li = mListenerInfo;
    // noinspection SimplifiableIfStatement
    if (li != null && li.mOnDragListener != null && (mViewFlags & ENABLED_MASK) == ENABLED && li.mOnDragListener.onDrag(this, event)) {
        return true;
    }
    return onDragEvent(event);
}","{
    event.mEventHandlerWasCalled = true;
    if (event.mAction == DragEvent.ACTION_DRAG_LOCATION || event.mAction == DragEvent.ACTION_DROP) {
        // About to deliver an event with coordinates to this view. Notify that now this view
        // has drag focus. This will send exit/enter events as needed.
        getViewRootImpl().setDragFocus(this, event);
    }
    return callDragEventHandler(event);
}",1,"/**
 * Detects if this View is enabled and has a drag event listener.
 * If both are true, then it calls the drag event listener with the
 * {@link android.view.DragEvent} it received. If the drag event listener returns
 * {@code true}, then dispatchDragEvent() returns {@code true}.
 * <p>
 * For all other cases, the method calls the
 * {@link android.view.View#onDragEvent(DragEvent) onDragEvent()} drag event handler
 * method and returns its result.
 * </p>
 * <p>
 * This ensures that a drag event is always consumed, even if the View does not have a drag
 * event listener. However, if the View has a listener and the listener returns true, then
 * onDragEvent() is not called.
 * </p>
 */
","/**
 * Detects if this View is enabled and has a drag event listener.
 * If both are true, then it calls the drag event listener with the
 * {@link android.view.DragEvent} it received. If the drag event listener returns
 * {@code true}, then dispatchDragEvent() returns {@code true}.
 * <p>
 * For all other cases, the method calls the
 * {@link android.view.View#onDragEvent(DragEvent) onDragEvent()} drag event handler
 * method and returns its result.
 * </p>
 * <p>
 * This ensures that a drag event is always consumed, even if the View does not have a drag
 * event listener. However, if the View has a listener and the listener returns true, then
 * onDragEvent() is not called.
 * </p>
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",2,"There are new statements added to set event handler flags and to handle drag focus which changes the control flow. There's also a change from directly calling li.mOnDragListener.onDrag() and onDragEvent(event) to using callDragEventHandler(event), which is an internal behavior change. Therefore, the code change types are 3 (for control dependency change) and 4 (for other statement changed).","Since the late version includes additional logic to manage the event handler and handle drag focus, along with changing the method of handling the drag event, this creates the potential for different exception handling behavior. If there is an exception in this new logic (e.g., from getViewRootImpl()), it would constitute a different exception behavior not present in the early version. Hence, this leads to a CI of type 2 (Compatibility Issue caused by potential different exception handlings)."
88,<android.app.ActivityThread.Idler: boolean queueIdle()>,25,26,<android.app.ActivityThread.Idler: boolean queueIdle()>,<android.app.ActivityThread.Idler: boolean queueIdle()>,0,"{
    ActivityClientRecord a = mNewActivities;
    boolean stopProfiling = false;
    if (mBoundApplication != null && mProfiler.profileFd != null && mProfiler.autoStopProfiler) {
        stopProfiling = true;
    }
    if (a != null) {
        mNewActivities = null;
        IActivityManager am = ActivityManagerNative.getDefault();
        ActivityClientRecord prev;
        do {
            if (localLOGV)
                Slog.v(TAG, ""Reporting idle of "" + a + "" finished="" + (a.activity != null && a.activity.mFinished));
            if (a.activity != null && !a.activity.mFinished) {
                try {
                    am.activityIdle(a.token, a.createdConfig, stopProfiling);
                    a.createdConfig = null;
                } catch (RemoteException ex) {
                    throw ex.rethrowFromSystemServer();
                }
            }
            prev = a;
            a = a.nextIdle;
            prev.nextIdle = null;
        } while (a != null);
    }
    if (stopProfiling) {
        mProfiler.stopProfiling();
    }
    ensureJitEnabled();
    return false;
}","{
    ActivityClientRecord a = mNewActivities;
    boolean stopProfiling = false;
    if (mBoundApplication != null && mProfiler.profileFd != null && mProfiler.autoStopProfiler) {
        stopProfiling = true;
    }
    if (a != null) {
        mNewActivities = null;
        IActivityManager am = ActivityManager.getService();
        ActivityClientRecord prev;
        do {
            if (localLOGV)
                Slog.v(TAG, ""Reporting idle of "" + a + "" finished="" + (a.activity != null && a.activity.mFinished));
            if (a.activity != null && !a.activity.mFinished) {
                try {
                    am.activityIdle(a.token, a.createdConfig, stopProfiling);
                    a.createdConfig = null;
                } catch (RemoteException ex) {
                    throw ex.rethrowFromSystemServer();
                }
            }
            prev = a;
            a = a.nextIdle;
            prev.nextIdle = null;
        } while (a != null);
    }
    if (stopProfiling) {
        mProfiler.stopProfiling();
    }
    ensureJitEnabled();
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The dependent API has changed from `ActivityManagerNative.getDefault()` to `ActivityManager.getService()`, which is a change in the dependent API being invoked. Hence, the code change type is 5.","There is no change to the control flow, exception handling, or return values, but the dependent API change does not inherently lead to a change in behavior as long as the new dependent API method provides the same functionality, so there is no compatibility issue: CI type is 0."
89,<android.app.Activity: boolean navigateUpTo(Intent)>,25,26,<android.app.Activity: boolean navigateUpTo(Intent)>,<android.app.Activity: boolean navigateUpTo(Intent)>,0,"{
    if (mParent == null) {
        ComponentName destInfo = upIntent.getComponent();
        if (destInfo == null) {
            destInfo = upIntent.resolveActivity(getPackageManager());
            if (destInfo == null) {
                return false;
            }
            upIntent = new Intent(upIntent);
            upIntent.setComponent(destInfo);
        }
        int resultCode;
        Intent resultData;
        synchronized (this) {
            resultCode = mResultCode;
            resultData = mResultData;
        }
        if (resultData != null) {
            resultData.prepareToLeaveProcess(this);
        }
        try {
            upIntent.prepareToLeaveProcess(this);
            return ActivityManagerNative.getDefault().navigateUpTo(mToken, upIntent, resultCode, resultData);
        } catch (RemoteException e) {
            return false;
        }
    } else {
        return mParent.navigateUpToFromChild(this, upIntent);
    }
}","{
    if (mParent == null) {
        ComponentName destInfo = upIntent.getComponent();
        if (destInfo == null) {
            destInfo = upIntent.resolveActivity(getPackageManager());
            if (destInfo == null) {
                return false;
            }
            upIntent = new Intent(upIntent);
            upIntent.setComponent(destInfo);
        }
        int resultCode;
        Intent resultData;
        synchronized (this) {
            resultCode = mResultCode;
            resultData = mResultData;
        }
        if (resultData != null) {
            resultData.prepareToLeaveProcess(this);
        }
        try {
            upIntent.prepareToLeaveProcess(this);
            return ActivityManager.getService().navigateUpTo(mToken, upIntent, resultCode, resultData);
        } catch (RemoteException e) {
            return false;
        }
    } else {
        return mParent.navigateUpToFromChild(this, upIntent);
    }
}",1,"/**
 * Navigate from this activity to the activity specified by upIntent, finishing this activity
 * in the process. If the activity indicated by upIntent already exists in the task's history,
 * this activity and all others before the indicated activity in the history stack will be
 * finished.
 *
 * <p>If the indicated activity does not appear in the history stack, this will finish
 * each activity in this task until the root activity of the task is reached, resulting in
 * an ""in-app home"" behavior. This can be useful in apps with a complex navigation hierarchy
 * when an activity may be reached by a path not passing through a canonical parent
 * activity.</p>
 *
 * <p>This method should be used when performing up navigation from within the same task
 * as the destination. If up navigation should cross tasks in some cases, see
 * {@link #shouldUpRecreateTask(Intent)}.</p>
 *
 * @param upIntent An intent representing the target destination for up navigation
 *
 * @return true if up navigation successfully reached the activity indicated by upIntent and
 * upIntent was delivered to it. false if an instance of the indicated activity could
 * not be found and this activity was simply finished normally.
 */
","/**
 * Navigate from this activity to the activity specified by upIntent, finishing this activity
 * in the process. If the activity indicated by upIntent already exists in the task's history,
 * this activity and all others before the indicated activity in the history stack will be
 * finished.
 *
 * <p>If the indicated activity does not appear in the history stack, this will finish
 * each activity in this task until the root activity of the task is reached, resulting in
 * an ""in-app home"" behavior. This can be useful in apps with a complex navigation hierarchy
 * when an activity may be reached by a path not passing through a canonical parent
 * activity.</p>
 *
 * <p>This method should be used when performing up navigation from within the same task
 * as the destination. If up navigation should cross tasks in some cases, see
 * {@link #shouldUpRecreateTask(Intent)}.</p>
 *
 * @param upIntent An intent representing the target destination for up navigation
 *
 * @return true if up navigation successfully reached the activity indicated by upIntent and
 * upIntent was delivered to it. false if an instance of the indicated activity could
 * not be found and this activity was simply finished normally.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method used to obtain the Activity Manager service has changed from ActivityManagerNative.getDefault() to ActivityManager.getService(), so the change type is 5.","The change in how the Activity Manager service is acquired does not affect the return value or the exception handling of the method, as it's an internal detail of how the service is retrieved. The method semantics remain the same, and thus, no compatibility issue should arise due to this change."
91,"<android.accounts.AccountManager: AccountManagerFuture<Account> renameAccount(Account,String,AccountManagerCallback<Account>,Handler)>",25,26,"<android.accounts.AccountManager: AccountManagerFuture<Account> renameAccount(Account,String,AccountManagerCallback<Account>,Handler)>","<android.accounts.AccountManager: AccountManagerFuture<Account> renameAccount(Account,String,AccountManagerCallback<Account>,Handler)>",0,"{
    if (account == null)
        throw new IllegalArgumentException(""account is null."");
    if (TextUtils.isEmpty(newName)) {
        throw new IllegalArgumentException(""newName is empty or null."");
    }
    return new Future2Task<Account>(handler, callback) {

        @Override
        public void doWork() throws RemoteException {
            mService.renameAccount(mResponse, account, newName);
        }

        @Override
        public Account bundleToResult(Bundle bundle) throws AuthenticatorException {
            String name = bundle.getString(KEY_ACCOUNT_NAME);
            String type = bundle.getString(KEY_ACCOUNT_TYPE);
            return new Account(name, type);
        }
    }.start();
}","{
    if (account == null)
        throw new IllegalArgumentException(""account is null."");
    if (TextUtils.isEmpty(newName)) {
        throw new IllegalArgumentException(""newName is empty or null."");
    }
    return new Future2Task<Account>(handler, callback) {

        @Override
        public void doWork() throws RemoteException {
            mService.renameAccount(mResponse, account, newName);
        }

        @Override
        public Account bundleToResult(Bundle bundle) throws AuthenticatorException {
            String name = bundle.getString(KEY_ACCOUNT_NAME);
            String type = bundle.getString(KEY_ACCOUNT_TYPE);
            String accessId = bundle.getString(KEY_ACCOUNT_ACCESS_ID);
            return new Account(name, type, accessId);
        }
    }.start();
}",1,"/**
 * Rename the specified {@link Account}.  This is equivalent to removing
 * the existing account and adding a new renamed account with the old
 * account's user data.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>This method requires the caller to have a signature match with the
 * authenticator that manages the specified account.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * AUTHENTICATE_ACCOUNTS permission and same UID as account's authenticator
 * is needed for those platforms. See docs for this function in API level 22.
 *
 * @param account The {@link Account} to rename
 * @param newName String name to be associated with the account.
 * @param callback Callback to invoke when the request completes, null for
 * no callback
 * @param handler {@link Handler} identifying the callback thread, null for
 * the main thread
 * @return An {@link AccountManagerFuture} which resolves to the Account
 * after the name change. If successful the account's name will be the
 * specified new name.
 */
","/**
 * Rename the specified {@link Account}.  This is equivalent to removing
 * the existing account and adding a new renamed account with the old
 * account's user data.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>This method requires the caller to have a signature match with the
 * authenticator that manages the specified account.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * AUTHENTICATE_ACCOUNTS permission and same UID as account's authenticator
 * is needed for those platforms. See docs for this function in API level 22.
 *
 * @param account The {@link Account} to rename
 * @param newName String name to be associated with the account.
 * @param callback Callback to invoke when the request completes, null for
 * no callback
 * @param handler {@link Handler} identifying the callback thread, null for
 * the main thread
 * @return An {@link AccountManagerFuture} which resolves to the Account
 * after the name change. If successful the account's name will be the
 * specified new name.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"There is an addition in the `bundleToResult` method where a new `String` variable `accessId` is retrieved from the bundle, and this new variable is used to create a new `Account` object. The signature of the `Account` constructor has changed to include this new `accessId` parameter. This constitutes an ""Other statement changed,"" as well as a ""Dependent API changed,"" because the constructor of `Account` is a dependent API that has presumably changed to accommodate the new parameter. Therefore, the code change type is 4,5.","This change can potentially cause the `renameAccount` method to return a different `Account` object because it now includes an access ID that it did not include before. Clients relying on the result of this method might not expect an `accessId` to be included in the returned `Account` object, leading to different behavior in the client code. Thus, there's a potential Compatibility Issue caused by potential different return values or types, making the CI type 1."
92,<android.widget.LinearLayout: void setDividerPadding(int)>,25,26,<android.widget.LinearLayout: void setDividerPadding(int)>,<android.widget.LinearLayout: void setDividerPadding(int)>,0,"{
    mDividerPadding = padding;
}","{
    if (padding == mDividerPadding) {
        return;
    }
    mDividerPadding = padding;
    if (isShowingDividers()) {
        requestLayout();
        invalidate();
    }
}",1,"/**
 * Set padding displayed on both ends of dividers.
 *
 * @param padding Padding value in pixels that will be applied to each end
 *
 * @see #setShowDividers(int)
 * @see #setDividerDrawable(Drawable)
 * @see #getDividerPadding()
 */
","/**
 * Set padding displayed on both ends of dividers. For a vertical layout, the padding is applied
 * to left and right end of dividers. For a horizontal layout, the padding is applied to top and
 * bottom end of dividers.
 *
 * @param padding Padding value in pixels that will be applied to each end
 *
 * @see #setShowDividers(int)
 * @see #setDividerDrawable(Drawable)
 * @see #getDividerPadding()
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",0,"In the new implementation, there is a new if-check that introduces an early return if `padding` is equal to `mDividerPadding` which wasn't present before. Moreover, additional functionality is added that calls `requestLayout()` and `invalidate()` if `isShowingDividers()` evaluates to true, which is a change in the control dependency as well as the introduction of new statements, so the code change types are 1,3.","While there are changes in the implementation code, these changes do not constitute a Compatibility Issue since they do not affect the return value or the type, and neither do they change exception handling. The method signature still returns void, and the flow of control only adds an early exit and extra operations under certain conditions without changing the ability of the API to execute without error."
93,"<android.widget.RemoteViews.ViewGroupAction: void apply(View,ViewGroup,OnClickHandler)>",25,26,"<android.widget.RemoteViews.ViewGroupAction: void apply(View,ViewGroup,OnClickHandler)>","<android.widget.RemoteViews.ViewGroupAction: void apply(View,ViewGroup,OnClickHandler)>",0,"{
    final Context context = root.getContext();
    final ViewGroup target = (ViewGroup) root.findViewById(viewId);
    if (target == null)
        return;
    if (nestedViews != null) {
        // Inflate nested views and add as children
        target.addView(nestedViews.apply(context, target, handler));
    } else {
        // Clear all children when nested views omitted
        target.removeAllViews();
    }
}","{
    final Context context = root.getContext();
    final ViewGroup target = root.findViewById(viewId);
    if (target == null)
        return;
    if (nestedViews != null) {
        // Inflate nested views and add as children
        target.addView(nestedViews.apply(context, target, handler));
    } else {
        // Clear all children when nested views omitted
        target.removeAllViews();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The only change between the two versions is the casting removed from `root.findViewById(viewId)` in the type of the variable `target`. However, the cast to `ViewGroup` is not necessary for `findViewById` as it returns a `View` which is already ensured to be a `ViewGroup` by assigning it to `ViewGroup target`, so this is not expected to lead to a change in behavior. Thus, the code change type is classified as 4.","The change will not introduce a Compatibility Issue because it does not affect the behavior of the method in terms of what it returns or the exceptions it throws. The method's functionality will remain the same, and therefore, there is no Compatibility Issue."
94,"<android.app.Notification.MessagingStyle: MessagingStyle addMessage(CharSequence,long,CharSequence)>",25,26,"<android.app.Notification.MessagingStyle: MessagingStyle addMessage(CharSequence,long,CharSequence)>","<android.app.Notification.MessagingStyle: MessagingStyle addMessage(CharSequence,long,CharSequence)>",0,"{
    mMessages.add(new Message(text, timestamp, sender));
    if (mMessages.size() > MAXIMUM_RETAINED_MESSAGES) {
        mMessages.remove(0);
    }
    return this;
}","{
    return addMessage(new Message(text, timestamp, sender));
}",1,"/**
 * Adds a message for display by this notification. Convenience call for a simple
 * {@link Message} in {@link #addMessage(Notification.MessagingStyle.Message)}.
 * @param text A {@link CharSequence} to be displayed as the message content
 * @param timestamp Time at which the message arrived
 * @param sender A {@link CharSequence} to be used for displaying the name of the
 * sender. Should be <code>null</code> for messages by the current user, in which case
 * the platform will insert {@link #getUserDisplayName()}.
 * Should be unique amongst all individuals in the conversation, and should be
 * consistent during re-posts of the notification.
 *
 * @see Message#Message(CharSequence, long, CharSequence)
 *
 * @return this object for method chaining
 */
","/**
 * Adds a message for display by this notification. Convenience call for a simple
 * {@link Message} in {@link #addMessage(Notification.MessagingStyle.Message)}.
 * @param text A {@link CharSequence} to be displayed as the message content
 * @param timestamp Time at which the message arrived
 * @param sender A {@link CharSequence} to be used for displaying the name of the
 * sender. Should be <code>null</code> for messages by the current user, in which case
 * the platform will insert {@link #getUserDisplayName()}.
 * Should be unique amongst all individuals in the conversation, and should be
 * consistent during re-posts of the notification.
 *
 * @see Message#Message(CharSequence, long, CharSequence)
 *
 * @return this object for method chaining
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The method implementation has changed to call an overloaded version of addMessage(), which could have different logic compared to directly adding the Message object to mMessages list and doing a check afterwards. A return statement is now returning the result of a function call, and the code that removes the oldest message if the limit is exceeded has been removed, so the change type is 1,4.","The change results in potential different return values for this method, specifically if the overloaded addMessage() method manipulates the mMessages differently or has side effects that were not present in the early version, thus the CI type is 1."
95,<android.animation.ValueAnimator: void resume()>,25,26,<android.animation.ValueAnimator: void resume()>,<android.animation.ValueAnimator: void resume()>,0,"{
    if (Looper.myLooper() == null) {
        throw new AndroidRuntimeException(""Animators may only be resumed from the same "" + ""thread that the animator was started on"");
    }
    if (mPaused && !mResumed) {
        mResumed = true;
        if (mPauseTime > 0) {
            AnimationHandler handler = AnimationHandler.getInstance();
            handler.addAnimationFrameCallback(this, 0);
        }
    }
    super.resume();
}","{
    if (Looper.myLooper() == null) {
        throw new AndroidRuntimeException(""Animators may only be resumed from the same "" + ""thread that the animator was started on"");
    }
    if (mPaused && !mResumed) {
        mResumed = true;
        if (mPauseTime > 0) {
            addAnimationCallback(0);
        }
    }
    super.resume();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation now calls `addAnimationCallback(0)` instead of `AnimationHandler.getInstance().addAnimationFrameCallback(this, 0)`, which indicates that a dependent API within the class has changed, leading to code change type 4,5.","The underlying behavior of resuming the animator does not appear to have changed because it's likely that the `addAnimationCallback(0)` is a wrapper or a refactored version of the same operation previously performed by `AnimationHandler.getInstance().addAnimationFrameCallback(this, 0)`. Considering there are no changes to the control flow, exceptions thrown, or return statements, no compatibility issues seem to arise from this change."
96,"<android.app.admin.DevicePolicyManager: void uninstallCaCert(ComponentName,byte[])>",25,26,"<android.app.admin.DevicePolicyManager: void uninstallCaCert(ComponentName,byte[])>","<android.app.admin.DevicePolicyManager: void uninstallCaCert(ComponentName,byte[])>",0,"{
    throwIfParentInstance(""uninstallCaCert"");
    if (mService != null) {
        try {
            final String alias = getCaCertAlias(certBuffer);
            mService.uninstallCaCerts(admin, new String[] { alias });
        } catch (CertificateException e) {
            Log.w(TAG, ""Unable to parse certificate"", e);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}","{
    throwIfParentInstance(""uninstallCaCert"");
    if (mService != null) {
        try {
            final String alias = getCaCertAlias(certBuffer);
            mService.uninstallCaCerts(admin, mContext.getPackageName(), new String[] { alias });
        } catch (CertificateException e) {
            Log.w(TAG, ""Unable to parse certificate"", e);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Uninstalls the given certificate from trusted user CAs, if present.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or
 * {@code null} if calling from a delegated certificate installer.
 * @param certBuffer encoded form of the certificate to remove.
 * @throws SecurityException if {@code admin} is not {@code null} and not a device or profile
 * owner.
 */
","/**
 * Uninstalls the given certificate from trusted user CAs, if present.
 *
 * The caller must be a profile or device owner on that user, or a delegate package given the
 * {@link #DELEGATION_CERT_INSTALL} scope via {@link #setDelegatedScopes}; otherwise a
 * security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or
 * {@code null} if calling from a delegated certificate installer.
 * @param certBuffer encoded form of the certificate to remove.
 * @throws SecurityException if {@code admin} is not {@code null} and not a device or profile
 * owner.
 * @see #setDelegatedScopes
 * @see #DELEGATION_CERT_INSTALL
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method call within the try block has been altered from `mService.uninstallCaCerts(admin, new String[] { alias })` to `mService.uninstallCaCerts(admin, mContext.getPackageName(), new String[] { alias })`, including an additional argument, `mContext.getPackageName()`. This change can be categorized under type 5.","The alteration of the `uninstallCaCerts` method call does not change the return type or the exception throwing behavior of the given method `uninstallCaCert()`. The execution flow remains the same regardless of the inclusion of the new argument. Thus, there is no Compatibility Issue, and the CI type is 0."
97,<android.content.ClipboardManager: boolean hasPrimaryClip()>,25,26,<android.content.ClipboardManager: boolean hasPrimaryClip()>,<android.content.ClipboardManager: boolean hasPrimaryClip()>,0,"{
    try {
        return getService().hasPrimaryClip(mContext.getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        return mService.hasPrimaryClip(mContext.getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns true if there is currently a primary clip on the clipboard.
 */
","/**
 * Returns true if there is currently a primary clip on the clipboard.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The way the ""service"" is accessed has changed from getService() to a direct access through a presumably pre-fetched service from a field mService. This is an instance variable reference change, so the code change type is 4.","The change doesn't affect the return value or the exception handling; it's merely a reference change to the service object, assuming mService is initialized to the value of getService(). Thus, there is no Compatibility Issue, and the type is 0."
98,<android.app.Activity: boolean isInMultiWindowMode()>,25,26,<android.app.Activity: boolean isInMultiWindowMode()>,<android.app.Activity: boolean isInMultiWindowMode()>,0,"{
    try {
        return ActivityManagerNative.getDefault().isInMultiWindowMode(mToken);
    } catch (RemoteException e) {
    }
    return false;
}","{
    try {
        return ActivityManager.getService().isInMultiWindowMode(mToken);
    } catch (RemoteException e) {
    }
    return false;
}",1,"/**
 * Returns true if the activity is currently in multi-window mode.
 * @see android.R.attr#resizeableActivity
 *
 * @return True if the activity is in multi-window mode.
 */
","/**
 * Returns true if the activity is currently in multi-window mode.
 * @see android.R.attr#resizeableActivity
 *
 * @return True if the activity is in multi-window mode.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,The method that is called within the try block has changed from ActivityManagerNative.getDefault().isInMultiWindowMode(mToken) to ActivityManager.getService().isInMultiWindowMode(mToken). This indicates that the change type is 5 (Dependent API changed).,"There is no Compatibility Issue related to return values or exception handling; the return value (`false`) and the exception handling (empty catch block) have not changed. Hence, the CI type is 0 (No Compatibility Issue)."
99,<android.app.ActivityThread.H: String codeToString(int)>,25,26,<android.app.ActivityThread.H: String codeToString(int)>,<android.app.ActivityThread.H: String codeToString(int)>,0,"{
    if (DEBUG_MESSAGES) {
        switch(code) {
            case LAUNCH_ACTIVITY:
                return ""LAUNCH_ACTIVITY"";
            case PAUSE_ACTIVITY:
                return ""PAUSE_ACTIVITY"";
            case PAUSE_ACTIVITY_FINISHING:
                return ""PAUSE_ACTIVITY_FINISHING"";
            case STOP_ACTIVITY_SHOW:
                return ""STOP_ACTIVITY_SHOW"";
            case STOP_ACTIVITY_HIDE:
                return ""STOP_ACTIVITY_HIDE"";
            case SHOW_WINDOW:
                return ""SHOW_WINDOW"";
            case HIDE_WINDOW:
                return ""HIDE_WINDOW"";
            case RESUME_ACTIVITY:
                return ""RESUME_ACTIVITY"";
            case SEND_RESULT:
                return ""SEND_RESULT"";
            case DESTROY_ACTIVITY:
                return ""DESTROY_ACTIVITY"";
            case BIND_APPLICATION:
                return ""BIND_APPLICATION"";
            case EXIT_APPLICATION:
                return ""EXIT_APPLICATION"";
            case NEW_INTENT:
                return ""NEW_INTENT"";
            case RECEIVER:
                return ""RECEIVER"";
            case CREATE_SERVICE:
                return ""CREATE_SERVICE"";
            case SERVICE_ARGS:
                return ""SERVICE_ARGS"";
            case STOP_SERVICE:
                return ""STOP_SERVICE"";
            case CONFIGURATION_CHANGED:
                return ""CONFIGURATION_CHANGED"";
            case CLEAN_UP_CONTEXT:
                return ""CLEAN_UP_CONTEXT"";
            case GC_WHEN_IDLE:
                return ""GC_WHEN_IDLE"";
            case BIND_SERVICE:
                return ""BIND_SERVICE"";
            case UNBIND_SERVICE:
                return ""UNBIND_SERVICE"";
            case DUMP_SERVICE:
                return ""DUMP_SERVICE"";
            case LOW_MEMORY:
                return ""LOW_MEMORY"";
            case ACTIVITY_CONFIGURATION_CHANGED:
                return ""ACTIVITY_CONFIGURATION_CHANGED"";
            case RELAUNCH_ACTIVITY:
                return ""RELAUNCH_ACTIVITY"";
            case PROFILER_CONTROL:
                return ""PROFILER_CONTROL"";
            case CREATE_BACKUP_AGENT:
                return ""CREATE_BACKUP_AGENT"";
            case DESTROY_BACKUP_AGENT:
                return ""DESTROY_BACKUP_AGENT"";
            case SUICIDE:
                return ""SUICIDE"";
            case REMOVE_PROVIDER:
                return ""REMOVE_PROVIDER"";
            case ENABLE_JIT:
                return ""ENABLE_JIT"";
            case DISPATCH_PACKAGE_BROADCAST:
                return ""DISPATCH_PACKAGE_BROADCAST"";
            case SCHEDULE_CRASH:
                return ""SCHEDULE_CRASH"";
            case DUMP_HEAP:
                return ""DUMP_HEAP"";
            case DUMP_ACTIVITY:
                return ""DUMP_ACTIVITY"";
            case SLEEPING:
                return ""SLEEPING"";
            case SET_CORE_SETTINGS:
                return ""SET_CORE_SETTINGS"";
            case UPDATE_PACKAGE_COMPATIBILITY_INFO:
                return ""UPDATE_PACKAGE_COMPATIBILITY_INFO"";
            case TRIM_MEMORY:
                return ""TRIM_MEMORY"";
            case DUMP_PROVIDER:
                return ""DUMP_PROVIDER"";
            case UNSTABLE_PROVIDER_DIED:
                return ""UNSTABLE_PROVIDER_DIED"";
            case REQUEST_ASSIST_CONTEXT_EXTRAS:
                return ""REQUEST_ASSIST_CONTEXT_EXTRAS"";
            case TRANSLUCENT_CONVERSION_COMPLETE:
                return ""TRANSLUCENT_CONVERSION_COMPLETE"";
            case INSTALL_PROVIDER:
                return ""INSTALL_PROVIDER"";
            case ON_NEW_ACTIVITY_OPTIONS:
                return ""ON_NEW_ACTIVITY_OPTIONS"";
            case CANCEL_VISIBLE_BEHIND:
                return ""CANCEL_VISIBLE_BEHIND"";
            case BACKGROUND_VISIBLE_BEHIND_CHANGED:
                return ""BACKGROUND_VISIBLE_BEHIND_CHANGED"";
            case ENTER_ANIMATION_COMPLETE:
                return ""ENTER_ANIMATION_COMPLETE"";
            case MULTI_WINDOW_MODE_CHANGED:
                return ""MULTI_WINDOW_MODE_CHANGED"";
            case PICTURE_IN_PICTURE_MODE_CHANGED:
                return ""PICTURE_IN_PICTURE_MODE_CHANGED"";
            case LOCAL_VOICE_INTERACTION_STARTED:
                return ""LOCAL_VOICE_INTERACTION_STARTED"";
        }
    }
    return Integer.toString(code);
}","{
    if (DEBUG_MESSAGES) {
        switch(code) {
            case LAUNCH_ACTIVITY:
                return ""LAUNCH_ACTIVITY"";
            case PAUSE_ACTIVITY:
                return ""PAUSE_ACTIVITY"";
            case PAUSE_ACTIVITY_FINISHING:
                return ""PAUSE_ACTIVITY_FINISHING"";
            case STOP_ACTIVITY_SHOW:
                return ""STOP_ACTIVITY_SHOW"";
            case STOP_ACTIVITY_HIDE:
                return ""STOP_ACTIVITY_HIDE"";
            case SHOW_WINDOW:
                return ""SHOW_WINDOW"";
            case HIDE_WINDOW:
                return ""HIDE_WINDOW"";
            case RESUME_ACTIVITY:
                return ""RESUME_ACTIVITY"";
            case SEND_RESULT:
                return ""SEND_RESULT"";
            case DESTROY_ACTIVITY:
                return ""DESTROY_ACTIVITY"";
            case BIND_APPLICATION:
                return ""BIND_APPLICATION"";
            case EXIT_APPLICATION:
                return ""EXIT_APPLICATION"";
            case NEW_INTENT:
                return ""NEW_INTENT"";
            case RECEIVER:
                return ""RECEIVER"";
            case CREATE_SERVICE:
                return ""CREATE_SERVICE"";
            case SERVICE_ARGS:
                return ""SERVICE_ARGS"";
            case STOP_SERVICE:
                return ""STOP_SERVICE"";
            case CONFIGURATION_CHANGED:
                return ""CONFIGURATION_CHANGED"";
            case CLEAN_UP_CONTEXT:
                return ""CLEAN_UP_CONTEXT"";
            case GC_WHEN_IDLE:
                return ""GC_WHEN_IDLE"";
            case BIND_SERVICE:
                return ""BIND_SERVICE"";
            case UNBIND_SERVICE:
                return ""UNBIND_SERVICE"";
            case DUMP_SERVICE:
                return ""DUMP_SERVICE"";
            case LOW_MEMORY:
                return ""LOW_MEMORY"";
            case ACTIVITY_CONFIGURATION_CHANGED:
                return ""ACTIVITY_CONFIGURATION_CHANGED"";
            case ACTIVITY_MOVED_TO_DISPLAY:
                return ""ACTIVITY_MOVED_TO_DISPLAY"";
            case RELAUNCH_ACTIVITY:
                return ""RELAUNCH_ACTIVITY"";
            case PROFILER_CONTROL:
                return ""PROFILER_CONTROL"";
            case CREATE_BACKUP_AGENT:
                return ""CREATE_BACKUP_AGENT"";
            case DESTROY_BACKUP_AGENT:
                return ""DESTROY_BACKUP_AGENT"";
            case SUICIDE:
                return ""SUICIDE"";
            case REMOVE_PROVIDER:
                return ""REMOVE_PROVIDER"";
            case ENABLE_JIT:
                return ""ENABLE_JIT"";
            case DISPATCH_PACKAGE_BROADCAST:
                return ""DISPATCH_PACKAGE_BROADCAST"";
            case SCHEDULE_CRASH:
                return ""SCHEDULE_CRASH"";
            case DUMP_HEAP:
                return ""DUMP_HEAP"";
            case DUMP_ACTIVITY:
                return ""DUMP_ACTIVITY"";
            case SLEEPING:
                return ""SLEEPING"";
            case SET_CORE_SETTINGS:
                return ""SET_CORE_SETTINGS"";
            case UPDATE_PACKAGE_COMPATIBILITY_INFO:
                return ""UPDATE_PACKAGE_COMPATIBILITY_INFO"";
            case TRIM_MEMORY:
                return ""TRIM_MEMORY"";
            case DUMP_PROVIDER:
                return ""DUMP_PROVIDER"";
            case UNSTABLE_PROVIDER_DIED:
                return ""UNSTABLE_PROVIDER_DIED"";
            case REQUEST_ASSIST_CONTEXT_EXTRAS:
                return ""REQUEST_ASSIST_CONTEXT_EXTRAS"";
            case TRANSLUCENT_CONVERSION_COMPLETE:
                return ""TRANSLUCENT_CONVERSION_COMPLETE"";
            case INSTALL_PROVIDER:
                return ""INSTALL_PROVIDER"";
            case ON_NEW_ACTIVITY_OPTIONS:
                return ""ON_NEW_ACTIVITY_OPTIONS"";
            case CANCEL_VISIBLE_BEHIND:
                return ""CANCEL_VISIBLE_BEHIND"";
            case BACKGROUND_VISIBLE_BEHIND_CHANGED:
                return ""BACKGROUND_VISIBLE_BEHIND_CHANGED"";
            case ENTER_ANIMATION_COMPLETE:
                return ""ENTER_ANIMATION_COMPLETE"";
            case MULTI_WINDOW_MODE_CHANGED:
                return ""MULTI_WINDOW_MODE_CHANGED"";
            case PICTURE_IN_PICTURE_MODE_CHANGED:
                return ""PICTURE_IN_PICTURE_MODE_CHANGED"";
            case LOCAL_VOICE_INTERACTION_STARTED:
                return ""LOCAL_VOICE_INTERACTION_STARTED"";
            case ATTACH_AGENT:
                return ""ATTACH_AGENT"";
            case APPLICATION_INFO_CHANGED:
                return ""APPLICATION_INFO_CHANGED"";
        }
    }
    return Integer.toString(code);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
102,"<android.provider.DocumentsContract: Uri createDocument(ContentResolver,Uri,String,String)>",25,26,"<android.provider.DocumentsContract: Uri createDocument(ContentResolver,Uri,String,String)>","<android.provider.DocumentsContract: Uri createDocument(ContentResolver,Uri,String,String)>",0,"{
    final ContentProviderClient client = resolver.acquireUnstableContentProviderClient(parentDocumentUri.getAuthority());
    try {
        return createDocument(client, parentDocumentUri, mimeType, displayName);
    } catch (Exception e) {
        Log.w(TAG, ""Failed to create document"", e);
        return null;
    } finally {
        ContentProviderClient.releaseQuietly(client);
    }
}","{
    final ContentProviderClient client = resolver.acquireUnstableContentProviderClient(parentDocumentUri.getAuthority());
    try {
        return createDocument(client, parentDocumentUri, mimeType, displayName);
    } catch (Exception e) {
        Log.w(TAG, ""Failed to create document"", e);
        rethrowIfNecessary(resolver, e);
        return null;
    } finally {
        ContentProviderClient.releaseQuietly(client);
    }
}",1,"/**
 * Create a new document with given MIME type and display name.
 *
 * @param parentDocumentUri directory with
 * {@link Document#FLAG_DIR_SUPPORTS_CREATE}
 * @param mimeType MIME type of new document
 * @param displayName name of new document
 * @return newly created document, or {@code null} if failed
 */
","/**
 * Create a new document with given MIME type and display name.
 *
 * @param parentDocumentUri directory with {@link Document#FLAG_DIR_SUPPORTS_CREATE}
 * @param mimeType MIME type of new document
 * @param displayName name of new document
 * @return newly created document, or {@code null} if failed
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"There is an additional method call 'rethrowIfNecessary(resolver, e)' inside the catch block in the late version, which creates an additional side effect, but does not change the return variable or exception thrown, hence the code change type is 4.","The additional method call 'rethrowIfNecessary(resolver, e)' does not lead to any difference in behavior since it is called before returning null, which is identical to the early version. The flow of returning null is still present, and the catch block does not throw a new exception or change the existing one. Therefore, there is no compatibility issue, and the CI type is 0."
103,<android.hardware.display.DisplayManagerInternal.DisplayPowerRequest: String toString()>,25,26,<android.hardware.display.DisplayManagerInternal.DisplayPowerRequest: String toString()>,<android.hardware.display.DisplayManagerInternal.DisplayPowerRequest: String toString()>,0,"{
    return ""policy="" + policyToString(policy) + "", useProximitySensor="" + useProximitySensor + "", screenBrightness="" + screenBrightness + "", screenAutoBrightnessAdjustment="" + screenAutoBrightnessAdjustment + "", brightnessSetByUser="" + brightnessSetByUser + "", useAutoBrightness="" + useAutoBrightness + "", blockScreenOn="" + blockScreenOn + "", lowPowerMode="" + lowPowerMode + "", boostScreenBrightness="" + boostScreenBrightness + "", dozeScreenBrightness="" + dozeScreenBrightness + "", dozeScreenState="" + Display.stateToString(dozeScreenState) + "", useTwilight="" + useTwilight;
}","{
    return ""policy="" + policyToString(policy) + "", useProximitySensor="" + useProximitySensor + "", screenBrightness="" + screenBrightness + "", screenAutoBrightnessAdjustment="" + screenAutoBrightnessAdjustment + "", screenLowPowerBrightnessFactor="" + screenLowPowerBrightnessFactor + "", brightnessSetByUser="" + brightnessSetByUser + "", useAutoBrightness="" + useAutoBrightness + "", blockScreenOn="" + blockScreenOn + "", lowPowerMode="" + lowPowerMode + "", boostScreenBrightness="" + boostScreenBrightness + "", dozeScreenBrightness="" + dozeScreenBrightness + "", dozeScreenState="" + Display.stateToString(dozeScreenState);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The implementation of the toString() method has changed: the ""useTwilight="" + useTwilight part has been removed, and ""screenLowPowerBrightnessFactor="" + screenLowPowerBrightnessFactor has been added in the late version. Therefore, the code change type is 1,4.","Since the return value of the method has changed (it now includes different information), this can cause a Compatibility Issue as the string representation of the object in the late version is different from the early version. It would affect any client code that depends on the specific format of the string. Hence the CI type is 1."
104,<android.app.ContextImpl: Context createDeviceProtectedStorageContext()>,25,26,<android.app.ContextImpl: Context createDeviceProtectedStorageContext()>,<android.app.ContextImpl: Context createDeviceProtectedStorageContext()>,0,"{
    final int flags = (mFlags & ~Context.CONTEXT_CREDENTIAL_PROTECTED_STORAGE) | Context.CONTEXT_DEVICE_PROTECTED_STORAGE;
    return new ContextImpl(this, mMainThread, mPackageInfo, mActivityToken, mUser, flags, mDisplay, null, Display.INVALID_DISPLAY);
}","{
    final int flags = (mFlags & ~Context.CONTEXT_CREDENTIAL_PROTECTED_STORAGE) | Context.CONTEXT_DEVICE_PROTECTED_STORAGE;
    return new ContextImpl(this, mMainThread, mPackageInfo, mSplitName, mActivityToken, mUser, flags, mClassLoader);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,1,"There is a dependent API change, as the constructor of ContextImpl has changed with different parameters. In the early version, the constructor takes a different set and order of parameters compared to the late version, so the change type is 5.","The dependent API, which is the constructor of ContextImpl, has undergone changes that could potentially cause a different behavior in object creation. This would likely lead to a Compatibility Issue of type 1, as the API could return a differently constructed Context object."
105,"<android.widget.RemoteViews.TextViewDrawableAction: Action initActionAsync(ViewTree,ViewGroup,OnClickHandler)>",25,26,"<android.widget.RemoteViews.TextViewDrawableAction: Action initActionAsync(ViewTree,ViewGroup,OnClickHandler)>","<android.widget.RemoteViews.TextViewDrawableAction: Action initActionAsync(ViewTree,ViewGroup,OnClickHandler)>",0,"{
    final TextView target = (TextView) root.findViewById(viewId);
    if (target == null)
        return ACTION_NOOP;
    TextViewDrawableAction copy = useIcons ? new TextViewDrawableAction(viewId, isRelative, i1, i2, i3, i4) : new TextViewDrawableAction(viewId, isRelative, d1, d2, d3, d4);
    // Load the drawables on the background thread.
    copy.drawablesLoaded = true;
    final Context ctx = target.getContext();
    if (useIcons) {
        copy.id1 = i1 == null ? null : i1.loadDrawable(ctx);
        copy.id2 = i2 == null ? null : i2.loadDrawable(ctx);
        copy.id3 = i3 == null ? null : i3.loadDrawable(ctx);
        copy.id4 = i4 == null ? null : i4.loadDrawable(ctx);
    } else {
        copy.id1 = d1 == 0 ? null : ctx.getDrawable(d1);
        copy.id2 = d2 == 0 ? null : ctx.getDrawable(d2);
        copy.id3 = d3 == 0 ? null : ctx.getDrawable(d3);
        copy.id4 = d4 == 0 ? null : ctx.getDrawable(d4);
    }
    return copy;
}","{
    final TextView target = root.findViewById(viewId);
    if (target == null)
        return ACTION_NOOP;
    TextViewDrawableAction copy = useIcons ? new TextViewDrawableAction(viewId, isRelative, i1, i2, i3, i4) : new TextViewDrawableAction(viewId, isRelative, d1, d2, d3, d4);
    // Load the drawables on the background thread.
    copy.drawablesLoaded = true;
    final Context ctx = target.getContext();
    if (useIcons) {
        copy.id1 = i1 == null ? null : i1.loadDrawable(ctx);
        copy.id2 = i2 == null ? null : i2.loadDrawable(ctx);
        copy.id3 = i3 == null ? null : i3.loadDrawable(ctx);
        copy.id4 = i4 == null ? null : i4.loadDrawable(ctx);
    } else {
        copy.id1 = d1 == 0 ? null : ctx.getDrawable(d1);
        copy.id2 = d2 == 0 ? null : ctx.getDrawable(d2);
        copy.id3 = d3 == 0 ? null : ctx.getDrawable(d3);
        copy.id4 = d4 == 0 ? null : ctx.getDrawable(d4);
    }
    return copy;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,0,0,"The code change between the early and late version is only the removal of the type casting to `TextView` on the `root.findViewById(viewId)` call. Since the `findViewById` method returns `View`, and `TextView` is a subclass of `View`, this does not change the behavior if the `viewId` actually refers to a `TextView`. The rest of the method implementation remains unchanged with no differences in exception handling or control flow.",There's no Compatibility Issue because the change in the type casting does not affect the functionality of the method. The method's execution behavior remains consistent between versions -- it will still return either `ACTION_NOOP` or a `copy` of `TextViewDrawableAction`. The API's contract regarding returned value types and possible exceptions is adhered to.
107,<android.widget.TextView: boolean bringPointIntoView(int)>,25,26,<android.widget.TextView: boolean bringPointIntoView(int)>,<android.widget.TextView: boolean bringPointIntoView(int)>,0,"{
    if (isLayoutRequested()) {
        mDeferScroll = offset;
        return false;
    }
    boolean changed = false;
    Layout layout = isShowingHint() ? mHintLayout : mLayout;
    if (layout == null)
        return changed;
    int line = layout.getLineForOffset(offset);
    int grav;
    switch(layout.getParagraphAlignment(line)) {
        case ALIGN_LEFT:
            grav = 1;
            break;
        case ALIGN_RIGHT:
            grav = -1;
            break;
        case ALIGN_NORMAL:
            grav = layout.getParagraphDirection(line);
            break;
        case ALIGN_OPPOSITE:
            grav = -layout.getParagraphDirection(line);
            break;
        case ALIGN_CENTER:
        default:
            grav = 0;
            break;
    }
    // We only want to clamp the cursor to fit within the layout width
    // in left-to-right modes, because in a right to left alignment,
    // we want to scroll to keep the line-right on the screen, as other
    // lines are likely to have text flush with the right margin, which
    // we want to keep visible.
    // A better long-term solution would probably be to measure both
    // the full line and a blank-trimmed version, and, for example, use
    // the latter measurement for centering and right alignment, but for
    // the time being we only implement the cursor clamping in left to
    // right where it is most likely to be annoying.
    final boolean clamped = grav > 0;
    // FIXME: Is it okay to truncate this, or should we round?
    final int x = (int) layout.getPrimaryHorizontal(offset, clamped);
    final int top = layout.getLineTop(line);
    final int bottom = layout.getLineTop(line + 1);
    int left = (int) Math.floor(layout.getLineLeft(line));
    int right = (int) Math.ceil(layout.getLineRight(line));
    int ht = layout.getHeight();
    int hspace = mRight - mLeft - getCompoundPaddingLeft() - getCompoundPaddingRight();
    int vspace = mBottom - mTop - getExtendedPaddingTop() - getExtendedPaddingBottom();
    if (!mHorizontallyScrolling && right - left > hspace && right > x) {
        // If cursor has been clamped, make sure we don't scroll.
        right = Math.max(x, left + hspace);
    }
    int hslack = (bottom - top) / 2;
    int vslack = hslack;
    if (vslack > vspace / 4)
        vslack = vspace / 4;
    if (hslack > hspace / 4)
        hslack = hspace / 4;
    int hs = mScrollX;
    int vs = mScrollY;
    if (top - vs < vslack)
        vs = top - vslack;
    if (bottom - vs > vspace - vslack)
        vs = bottom - (vspace - vslack);
    if (ht - vs < vspace)
        vs = ht - vspace;
    if (0 - vs > 0)
        vs = 0;
    if (grav != 0) {
        if (x - hs < hslack) {
            hs = x - hslack;
        }
        if (x - hs > hspace - hslack) {
            hs = x - (hspace - hslack);
        }
    }
    if (grav < 0) {
        if (left - hs > 0)
            hs = left;
        if (right - hs < hspace)
            hs = right - hspace;
    } else if (grav > 0) {
        if (right - hs < hspace)
            hs = right - hspace;
        if (left - hs > 0)
            hs = left;
    } else /* grav == 0 */
    {
        if (right - left <= hspace) {
            /*
                 * If the entire text fits, center it exactly.
                 */
            hs = left - (hspace - (right - left)) / 2;
        } else if (x > right - hslack) {
            /*
                 * If we are near the right edge, keep the right edge
                 * at the edge of the view.
                 */
            hs = right - hspace;
        } else if (x < left + hslack) {
            /*
                 * If we are near the left edge, keep the left edge
                 * at the edge of the view.
                 */
            hs = left;
        } else if (left > hs) {
            /*
                 * Is there whitespace visible at the left?  Fix it if so.
                 */
            hs = left;
        } else if (right < hs + hspace) {
            /*
                 * Is there whitespace visible at the right?  Fix it if so.
                 */
            hs = right - hspace;
        } else {
            /*
                 * Otherwise, float as needed.
                 */
            if (x - hs < hslack) {
                hs = x - hslack;
            }
            if (x - hs > hspace - hslack) {
                hs = x - (hspace - hslack);
            }
        }
    }
    if (hs != mScrollX || vs != mScrollY) {
        if (mScroller == null) {
            scrollTo(hs, vs);
        } else {
            long duration = AnimationUtils.currentAnimationTimeMillis() - mLastScroll;
            int dx = hs - mScrollX;
            int dy = vs - mScrollY;
            if (duration > ANIMATED_SCROLL_GAP) {
                mScroller.startScroll(mScrollX, mScrollY, dx, dy);
                awakenScrollBars(mScroller.getDuration());
                invalidate();
            } else {
                if (!mScroller.isFinished()) {
                    mScroller.abortAnimation();
                }
                scrollBy(dx, dy);
            }
            mLastScroll = AnimationUtils.currentAnimationTimeMillis();
        }
        changed = true;
    }
    if (isFocused()) {
        // will be ignored.
        if (mTempRect == null)
            mTempRect = new Rect();
        mTempRect.set(x - 2, top, x + 2, bottom);
        getInterestingRect(mTempRect, line);
        mTempRect.offset(mScrollX, mScrollY);
        if (requestRectangleOnScreen(mTempRect)) {
            changed = true;
        }
    }
    return changed;
}","{
    if (isLayoutRequested()) {
        mDeferScroll = offset;
        return false;
    }
    boolean changed = false;
    Layout layout = isShowingHint() ? mHintLayout : mLayout;
    if (layout == null)
        return changed;
    int line = layout.getLineForOffset(offset);
    int grav;
    switch(layout.getParagraphAlignment(line)) {
        case ALIGN_LEFT:
            grav = 1;
            break;
        case ALIGN_RIGHT:
            grav = -1;
            break;
        case ALIGN_NORMAL:
            grav = layout.getParagraphDirection(line);
            break;
        case ALIGN_OPPOSITE:
            grav = -layout.getParagraphDirection(line);
            break;
        case ALIGN_CENTER:
        default:
            grav = 0;
            break;
    }
    // We only want to clamp the cursor to fit within the layout width
    // in left-to-right modes, because in a right to left alignment,
    // we want to scroll to keep the line-right on the screen, as other
    // lines are likely to have text flush with the right margin, which
    // we want to keep visible.
    // A better long-term solution would probably be to measure both
    // the full line and a blank-trimmed version, and, for example, use
    // the latter measurement for centering and right alignment, but for
    // the time being we only implement the cursor clamping in left to
    // right where it is most likely to be annoying.
    final boolean clamped = grav > 0;
    // FIXME: Is it okay to truncate this, or should we round?
    final int x = (int) layout.getPrimaryHorizontal(offset, clamped);
    final int top = layout.getLineTop(line);
    final int bottom = layout.getLineTop(line + 1);
    int left = (int) Math.floor(layout.getLineLeft(line));
    int right = (int) Math.ceil(layout.getLineRight(line));
    int ht = layout.getHeight();
    int hspace = mRight - mLeft - getCompoundPaddingLeft() - getCompoundPaddingRight();
    int vspace = mBottom - mTop - getExtendedPaddingTop() - getExtendedPaddingBottom();
    if (!mHorizontallyScrolling && right - left > hspace && right > x) {
        // If cursor has been clamped, make sure we don't scroll.
        right = Math.max(x, left + hspace);
    }
    int hslack = (bottom - top) / 2;
    int vslack = hslack;
    if (vslack > vspace / 4) {
        vslack = vspace / 4;
    }
    if (hslack > hspace / 4) {
        hslack = hspace / 4;
    }
    int hs = mScrollX;
    int vs = mScrollY;
    if (top - vs < vslack) {
        vs = top - vslack;
    }
    if (bottom - vs > vspace - vslack) {
        vs = bottom - (vspace - vslack);
    }
    if (ht - vs < vspace) {
        vs = ht - vspace;
    }
    if (0 - vs > 0) {
        vs = 0;
    }
    if (grav != 0) {
        if (x - hs < hslack) {
            hs = x - hslack;
        }
        if (x - hs > hspace - hslack) {
            hs = x - (hspace - hslack);
        }
    }
    if (grav < 0) {
        if (left - hs > 0) {
            hs = left;
        }
        if (right - hs < hspace) {
            hs = right - hspace;
        }
    } else if (grav > 0) {
        if (right - hs < hspace) {
            hs = right - hspace;
        }
        if (left - hs > 0) {
            hs = left;
        }
    } else /* grav == 0 */
    {
        if (right - left <= hspace) {
            /*
                 * If the entire text fits, center it exactly.
                 */
            hs = left - (hspace - (right - left)) / 2;
        } else if (x > right - hslack) {
            /*
                 * If we are near the right edge, keep the right edge
                 * at the edge of the view.
                 */
            hs = right - hspace;
        } else if (x < left + hslack) {
            /*
                 * If we are near the left edge, keep the left edge
                 * at the edge of the view.
                 */
            hs = left;
        } else if (left > hs) {
            /*
                 * Is there whitespace visible at the left?  Fix it if so.
                 */
            hs = left;
        } else if (right < hs + hspace) {
            /*
                 * Is there whitespace visible at the right?  Fix it if so.
                 */
            hs = right - hspace;
        } else {
            /*
                 * Otherwise, float as needed.
                 */
            if (x - hs < hslack) {
                hs = x - hslack;
            }
            if (x - hs > hspace - hslack) {
                hs = x - (hspace - hslack);
            }
        }
    }
    if (hs != mScrollX || vs != mScrollY) {
        if (mScroller == null) {
            scrollTo(hs, vs);
        } else {
            long duration = AnimationUtils.currentAnimationTimeMillis() - mLastScroll;
            int dx = hs - mScrollX;
            int dy = vs - mScrollY;
            if (duration > ANIMATED_SCROLL_GAP) {
                mScroller.startScroll(mScrollX, mScrollY, dx, dy);
                awakenScrollBars(mScroller.getDuration());
                invalidate();
            } else {
                if (!mScroller.isFinished()) {
                    mScroller.abortAnimation();
                }
                scrollBy(dx, dy);
            }
            mLastScroll = AnimationUtils.currentAnimationTimeMillis();
        }
        changed = true;
    }
    if (isFocused()) {
        // will be ignored.
        if (mTempRect == null)
            mTempRect = new Rect();
        mTempRect.set(x - 2, top, x + 2, bottom);
        getInterestingRect(mTempRect, line);
        mTempRect.offset(mScrollX, mScrollY);
        if (requestRectangleOnScreen(mTempRect)) {
            changed = true;
        }
    }
    return changed;
}",1,"/**
 * Move the point, specified by the offset, into the view if it is needed.
 * This has to be called after layout. Returns true if anything changed.
 */
","/**
 * Move the point, specified by the offset, into the view if it is needed.
 * This has to be called after layout. Returns true if anything changed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
108,<android.view.ViewTreeObserver: void addOnDrawListener(OnDrawListener)>,25,26,<android.view.ViewTreeObserver: void addOnDrawListener(OnDrawListener)>,<android.view.ViewTreeObserver: void addOnDrawListener(OnDrawListener)>,0,"{
    checkIsAlive();
    if (mOnDrawListeners == null) {
        mOnDrawListeners = new ArrayList<OnDrawListener>();
    }
    mOnDrawListeners.add(listener);
}","{
    checkIsAlive();
    if (mOnDrawListeners == null) {
        mOnDrawListeners = new ArrayList<OnDrawListener>();
    }
    if (mInDispatchOnDraw) {
        IllegalStateException ex = new IllegalStateException(""Cannot call addOnDrawListener inside of onDraw"");
        if (sIllegalOnDrawModificationIsFatal) {
            throw ex;
        } else {
            Log.e(""ViewTreeObserver"", ex.getMessage(), ex);
        }
    }
    mOnDrawListeners.add(listener);
}",1,"/**
 * <p>Register a callback to be invoked when the view tree is about to be drawn.</p>
 * <p><strong>Note:</strong> this method <strong>cannot</strong> be invoked from
 * {@link android.view.ViewTreeObserver.OnDrawListener#onDraw()}.</p>
 *
 * @param listener The callback to add
 *
 * @throws IllegalStateException If {@link #isAlive()} returns false
 */
","/**
 * <p>Register a callback to be invoked when the view tree is about to be drawn.</p>
 * <p><strong>Note:</strong> this method <strong>cannot</strong> be invoked from
 * {@link android.view.ViewTreeObserver.OnDrawListener#onDraw()}.</p>
 *
 * @param listener The callback to add
 *
 * @throws IllegalStateException If {@link #isAlive()} returns false
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3","1,2","An 'if' statement has been introduced which checks the value of mInDispatchOnDraw; then based on its value, it either throws an exception or logs an error without adding the listener, so the code change includes changes in control dependency (3) and exception handling statement (2).","Introducing a new check that can result in throwing an IllegalStateException or logging an error depending on the value of a static flag causes a compatibility issue. This is because it may prevent the listener from being added, which constitutes a compatibility issue related to potential different behaviors (CI type 1). Additionally, since new exceptions can be thrown, there is a compatibility issue related to potential different exception handling (CI type 2)."
109,<android.widget.DatePickerCalendarDelegate: void onLocaleChanged(Locale)>,25,26,<android.widget.DatePickerCalendarDelegate: void onLocaleChanged(Locale)>,<android.widget.DatePickerCalendarDelegate: void onLocaleChanged(Locale)>,0,"{
    final TextView headerYear = mHeaderYear;
    if (headerYear == null) {
        // again later after everything has been set up.
        return;
    }
    // Update the date formatter.
    final String datePattern = DateFormat.getBestDateTimePattern(locale, ""EMMMd"");
    mMonthDayFormat = new SimpleDateFormat(datePattern, locale);
    mMonthDayFormat.setContext(DisplayContext.CAPITALIZATION_FOR_STANDALONE);
    mYearFormat = new SimpleDateFormat(""y"", locale);
    // Clear out the lazily-initialized accessibility event formatter.
    mAccessibilityEventFormat = null;
    // Update the header text.
    onCurrentDateChanged(false);
}","{
    final TextView headerYear = mHeaderYear;
    if (headerYear == null) {
        // again later after everything has been set up.
        return;
    }
    // Update the date formatter.
    final String datePattern = DateFormat.getBestDateTimePattern(locale, ""EMMMd"");
    mMonthDayFormat = new SimpleDateFormat(datePattern, locale);
    mMonthDayFormat.setContext(DisplayContext.CAPITALIZATION_FOR_STANDALONE);
    mYearFormat = new SimpleDateFormat(""y"", locale);
    // Update the header text.
    onCurrentDateChanged(false);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The statement `mAccessibilityEventFormat = null;` has been removed in the late version, so the code change type is 4.","The removed line `mAccessibilityEventFormat = null;` does not affect the return value of the method because the method is of return type `void`, and it does not affect any exception handling within the method. Therefore, there is no compatibility issue with this change."
110,"<android.widget.DayPickerPagerAdapter: Object instantiateItem(ViewGroup,int)>",25,26,"<android.widget.DayPickerPagerAdapter: Object instantiateItem(ViewGroup,int)>","<android.widget.DayPickerPagerAdapter: Object instantiateItem(ViewGroup,int)>",0,"{
    final View itemView = mInflater.inflate(mLayoutResId, container, false);
    final SimpleMonthView v = (SimpleMonthView) itemView.findViewById(mCalendarViewId);
    v.setOnDayClickListener(mOnDayClickListener);
    v.setMonthTextAppearance(mMonthTextAppearance);
    v.setDayOfWeekTextAppearance(mDayOfWeekTextAppearance);
    v.setDayTextAppearance(mDayTextAppearance);
    if (mDaySelectorColor != null) {
        v.setDaySelectorColor(mDaySelectorColor);
    }
    if (mDayHighlightColor != null) {
        v.setDayHighlightColor(mDayHighlightColor);
    }
    if (mCalendarTextColor != null) {
        v.setMonthTextColor(mCalendarTextColor);
        v.setDayOfWeekTextColor(mCalendarTextColor);
        v.setDayTextColor(mCalendarTextColor);
    }
    final int month = getMonthForPosition(position);
    final int year = getYearForPosition(position);
    final int selectedDay;
    if (mSelectedDay != null && mSelectedDay.get(Calendar.MONTH) == month) {
        selectedDay = mSelectedDay.get(Calendar.DAY_OF_MONTH);
    } else {
        selectedDay = -1;
    }
    final int enabledDayRangeStart;
    if (mMinDate.get(Calendar.MONTH) == month && mMinDate.get(Calendar.YEAR) == year) {
        enabledDayRangeStart = mMinDate.get(Calendar.DAY_OF_MONTH);
    } else {
        enabledDayRangeStart = 1;
    }
    final int enabledDayRangeEnd;
    if (mMaxDate.get(Calendar.MONTH) == month && mMaxDate.get(Calendar.YEAR) == year) {
        enabledDayRangeEnd = mMaxDate.get(Calendar.DAY_OF_MONTH);
    } else {
        enabledDayRangeEnd = 31;
    }
    v.setMonthParams(selectedDay, month, year, mFirstDayOfWeek, enabledDayRangeStart, enabledDayRangeEnd);
    final ViewHolder holder = new ViewHolder(position, itemView, v);
    mItems.put(position, holder);
    container.addView(itemView);
    return holder;
}","{
    final View itemView = mInflater.inflate(mLayoutResId, container, false);
    final SimpleMonthView v = itemView.findViewById(mCalendarViewId);
    v.setOnDayClickListener(mOnDayClickListener);
    v.setMonthTextAppearance(mMonthTextAppearance);
    v.setDayOfWeekTextAppearance(mDayOfWeekTextAppearance);
    v.setDayTextAppearance(mDayTextAppearance);
    if (mDaySelectorColor != null) {
        v.setDaySelectorColor(mDaySelectorColor);
    }
    if (mDayHighlightColor != null) {
        v.setDayHighlightColor(mDayHighlightColor);
    }
    if (mCalendarTextColor != null) {
        v.setMonthTextColor(mCalendarTextColor);
        v.setDayOfWeekTextColor(mCalendarTextColor);
        v.setDayTextColor(mCalendarTextColor);
    }
    final int month = getMonthForPosition(position);
    final int year = getYearForPosition(position);
    final int selectedDay;
    if (mSelectedDay != null && mSelectedDay.get(Calendar.MONTH) == month) {
        selectedDay = mSelectedDay.get(Calendar.DAY_OF_MONTH);
    } else {
        selectedDay = -1;
    }
    final int enabledDayRangeStart;
    if (mMinDate.get(Calendar.MONTH) == month && mMinDate.get(Calendar.YEAR) == year) {
        enabledDayRangeStart = mMinDate.get(Calendar.DAY_OF_MONTH);
    } else {
        enabledDayRangeStart = 1;
    }
    final int enabledDayRangeEnd;
    if (mMaxDate.get(Calendar.MONTH) == month && mMaxDate.get(Calendar.YEAR) == year) {
        enabledDayRangeEnd = mMaxDate.get(Calendar.DAY_OF_MONTH);
    } else {
        enabledDayRangeEnd = 31;
    }
    v.setMonthParams(selectedDay, month, year, mFirstDayOfWeek, enabledDayRangeStart, enabledDayRangeEnd);
    final ViewHolder holder = new ViewHolder(position, itemView, v);
    mItems.put(position, holder);
    container.addView(itemView);
    return holder;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,0,0,"There is no difference between the two implementations of the given API. The code in both early and late versions are identical, and thus no change is observed.","Since there is no change in the implementations between the two versions, no compatibility issue could arise from this API."
111,"<android.widget.AbsListView.RecycleBin: void addScrapView(View,int)>",25,26,"<android.widget.AbsListView.RecycleBin: void addScrapView(View,int)>","<android.widget.AbsListView.RecycleBin: void addScrapView(View,int)>",0,"{
    final AbsListView.LayoutParams lp = (AbsListView.LayoutParams) scrap.getLayoutParams();
    if (lp == null) {
        // Ignore it completely.
        return;
    }
    lp.scrappedFromPosition = position;
    // Remove but don't scrap header or footer views, or views that
    // should otherwise not be recycled.
    final int viewType = lp.viewType;
    if (!shouldRecycleViewType(viewType)) {
        // heap and we'll fully detach the view later.
        if (viewType != ITEM_VIEW_TYPE_HEADER_OR_FOOTER) {
            getSkippedScrap().add(scrap);
        }
        return;
    }
    scrap.dispatchStartTemporaryDetach();
    // The the accessibility state of the view may change while temporary
    // detached and we do not allow detached views to fire accessibility
    // events. So we are announcing that the subtree changed giving a chance
    // to clients holding on to a view in this subtree to refresh it.
    notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_SUBTREE);
    // Don't scrap views that have transient state.
    final boolean scrapHasTransientState = scrap.hasTransientState();
    if (scrapHasTransientState) {
        if (mAdapter != null && mAdapterHasStableIds) {
            // the same data.
            if (mTransientStateViewsById == null) {
                mTransientStateViewsById = new LongSparseArray<>();
            }
            mTransientStateViewsById.put(lp.itemId, scrap);
        } else if (!mDataChanged) {
            // their old positions.
            if (mTransientStateViews == null) {
                mTransientStateViews = new SparseArray<>();
            }
            mTransientStateViews.put(position, scrap);
        } else {
            // Otherwise, we'll have to remove the view and start over.
            getSkippedScrap().add(scrap);
        }
    } else {
        if (mViewTypeCount == 1) {
            mCurrentScrap.add(scrap);
        } else {
            mScrapViews[viewType].add(scrap);
        }
        if (mRecyclerListener != null) {
            mRecyclerListener.onMovedToScrapHeap(scrap);
        }
    }
}","{
    final AbsListView.LayoutParams lp = (AbsListView.LayoutParams) scrap.getLayoutParams();
    if (lp == null) {
        // Ignore it completely.
        return;
    }
    lp.scrappedFromPosition = position;
    // Remove but don't scrap header or footer views, or views that
    // should otherwise not be recycled.
    final int viewType = lp.viewType;
    if (!shouldRecycleViewType(viewType)) {
        // heap and we'll fully detach the view later.
        if (viewType != ITEM_VIEW_TYPE_HEADER_OR_FOOTER) {
            getSkippedScrap().add(scrap);
        }
        return;
    }
    scrap.dispatchStartTemporaryDetach();
    // The the accessibility state of the view may change while temporary
    // detached and we do not allow detached views to fire accessibility
    // events. So we are announcing that the subtree changed giving a chance
    // to clients holding on to a view in this subtree to refresh it.
    notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_SUBTREE);
    // Don't scrap views that have transient state.
    final boolean scrapHasTransientState = scrap.hasTransientState();
    if (scrapHasTransientState) {
        if (mAdapter != null && mAdapterHasStableIds) {
            // the same data.
            if (mTransientStateViewsById == null) {
                mTransientStateViewsById = new LongSparseArray<>();
            }
            mTransientStateViewsById.put(lp.itemId, scrap);
        } else if (!mDataChanged) {
            // their old positions.
            if (mTransientStateViews == null) {
                mTransientStateViews = new SparseArray<>();
            }
            mTransientStateViews.put(position, scrap);
        } else {
            // Otherwise, we'll have to remove the view and start over.
            clearScrapForRebind(scrap);
            getSkippedScrap().add(scrap);
        }
    } else {
        clearScrapForRebind(scrap);
        if (mViewTypeCount == 1) {
            mCurrentScrap.add(scrap);
        } else {
            mScrapViews[viewType].add(scrap);
        }
        if (mRecyclerListener != null) {
            mRecyclerListener.onMovedToScrapHeap(scrap);
        }
    }
}",1,"/**
 * Puts a view into the list of scrap views.
 * <p>
 * If the list data hasn't changed or the adapter has stable IDs, views
 * with transient state will be preserved for later retrieval.
 *
 * @param scrap The view to add
 * @param position The view's position within its parent
 */
","/**
 * Puts a view into the list of scrap views.
 * <p>
 * If the list data hasn't changed or the adapter has stable IDs, views
 * with transient state will be preserved for later retrieval.
 *
 * @param scrap The view to add
 * @param position The view's position within its parent
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method implementation introduces a new function call, clearScrapForRebind(scrap), before adding the view to the mCurrentScrap or the mScrapViews[viewType]. Since this is a change in the sequence of operations performed within the method, the code change type is classified as 4 (Other statement changed).","The change made does not alter the signature of the method or the return type, nor does it introduce or remove any return statements or exception handling. Thus, this modification does not lead to potential different return values or exception handlings and, therefore, does not introduce a Compatibility Issue."
112,"<android.app.Activity: boolean startActivityIfNeeded(Intent,int,Bundle)>",25,26,"<android.app.Activity: boolean startActivityIfNeeded(Intent,int,Bundle)>","<android.app.Activity: boolean startActivityIfNeeded(Intent,int,Bundle)>",0,"{
    if (mParent == null) {
        int result = ActivityManager.START_RETURN_INTENT_TO_CALLER;
        try {
            Uri referrer = onProvideReferrer();
            if (referrer != null) {
                intent.putExtra(Intent.EXTRA_REFERRER, referrer);
            }
            intent.migrateExtraStreamToClipData();
            intent.prepareToLeaveProcess(this);
            result = ActivityManagerNative.getDefault().startActivity(mMainThread.getApplicationThread(), getBasePackageName(), intent, intent.resolveTypeIfNeeded(getContentResolver()), mToken, mEmbeddedID, requestCode, ActivityManager.START_FLAG_ONLY_IF_NEEDED, null, options);
        } catch (RemoteException e) {
        // Empty
        }
        Instrumentation.checkStartActivityResult(result, intent);
        if (requestCode >= 0) {
            // If this start is requesting a result, we can avoid making
            // the activity visible until the result is received.  Setting
            // this code during onCreate(Bundle savedInstanceState) or onResume() will keep the
            // activity hidden during this time, to avoid flickering.
            // This can only be done when a result is requested because
            // that guarantees we will get information back when the
            // activity is finished, no matter what happens to it.
            mStartedActivity = true;
        }
        return result != ActivityManager.START_RETURN_INTENT_TO_CALLER;
    }
    throw new UnsupportedOperationException(""startActivityIfNeeded can only be called from a top-level activity"");
}","{
    if (mParent == null) {
        int result = ActivityManager.START_RETURN_INTENT_TO_CALLER;
        try {
            Uri referrer = onProvideReferrer();
            if (referrer != null) {
                intent.putExtra(Intent.EXTRA_REFERRER, referrer);
            }
            intent.migrateExtraStreamToClipData();
            intent.prepareToLeaveProcess(this);
            result = ActivityManager.getService().startActivity(mMainThread.getApplicationThread(), getBasePackageName(), intent, intent.resolveTypeIfNeeded(getContentResolver()), mToken, mEmbeddedID, requestCode, ActivityManager.START_FLAG_ONLY_IF_NEEDED, null, options);
        } catch (RemoteException e) {
        // Empty
        }
        Instrumentation.checkStartActivityResult(result, intent);
        if (requestCode >= 0) {
            // If this start is requesting a result, we can avoid making
            // the activity visible until the result is received.  Setting
            // this code during onCreate(Bundle savedInstanceState) or onResume() will keep the
            // activity hidden during this time, to avoid flickering.
            // This can only be done when a result is requested because
            // that guarantees we will get information back when the
            // activity is finished, no matter what happens to it.
            mStartedActivity = true;
        }
        return result != ActivityManager.START_RETURN_INTENT_TO_CALLER;
    }
    throw new UnsupportedOperationException(""startActivityIfNeeded can only be called from a top-level activity"");
}",1,"/**
 * A special variation to launch an activity only if a new activity
 * instance is needed to handle the given Intent.  In other words, this is
 * just like {@link #startActivityForResult(Intent, int)} except: if you are
 * using the {@link Intent#FLAG_ACTIVITY_SINGLE_TOP} flag, or
 * singleTask or singleTop
 * {@link android.R.styleable#AndroidManifestActivity_launchMode launchMode},
 * and the activity
 * that handles <var>intent</var> is the same as your currently running
 * activity, then a new instance is not needed.  In this case, instead of
 * the normal behavior of calling {@link #onNewIntent} this function will
 * return and you can handle the Intent yourself.
 *
 * <p>This function can only be called from a top-level activity; if it is
 * called from a child activity, a runtime exception will be thrown.
 *
 * @param intent The intent to start.
 * @param requestCode If >= 0, this code will be returned in
 * onActivityResult() when the activity exits, as described in
 * {@link #startActivityForResult}.
 * @param options Additional options for how the Activity should be started.
 * See {@link android.content.Context#startActivity(Intent, Bundle)
 * Context.startActivity(Intent, Bundle)} for more details.
 *
 * @return If a new activity was launched then true is returned; otherwise
 * false is returned and you must handle the Intent yourself.
 *
 * @see #startActivity
 * @see #startActivityForResult
 */
","/**
 * A special variation to launch an activity only if a new activity
 * instance is needed to handle the given Intent.  In other words, this is
 * just like {@link #startActivityForResult(Intent, int)} except: if you are
 * using the {@link Intent#FLAG_ACTIVITY_SINGLE_TOP} flag, or
 * singleTask or singleTop
 * {@link android.R.styleable#AndroidManifestActivity_launchMode launchMode},
 * and the activity
 * that handles <var>intent</var> is the same as your currently running
 * activity, then a new instance is not needed.  In this case, instead of
 * the normal behavior of calling {@link #onNewIntent} this function will
 * return and you can handle the Intent yourself.
 *
 * <p>This function can only be called from a top-level activity; if it is
 * called from a child activity, a runtime exception will be thrown.
 *
 * @param intent The intent to start.
 * @param requestCode If >= 0, this code will be returned in
 * onActivityResult() when the activity exits, as described in
 * {@link #startActivityForResult}.
 * @param options Additional options for how the Activity should be started.
 * See {@link android.content.Context#startActivity(Intent, Bundle)}
 * Context.startActivity(Intent, Bundle)} for more details.
 *
 * @return If a new activity was launched then true is returned; otherwise
 * false is returned and you must handle the Intent yourself.
 *
 * @see #startActivity
 * @see #startActivityForResult
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method used to start the activity has changed from ActivityManagerNative.getDefault().startActivity(...) to ActivityManager.getService().startActivity(...), which demonstrates a change in the dependent API (5).","However, this change does not necessarily result in a compatibility issue, assuming the Service API and the Native API provide the same functionality and return the same results. The change in method call is an internal detail that likely has no effect on the behavior experienced by the caller of startActivityIfNeeded. Without further information suggesting that the service's functionality or expected results have been modified, we would classify this as having no Compatibility Issue (0)."
113,<android.view.Surface: void readFromParcel(Parcel)>,25,26,<android.view.Surface: void readFromParcel(Parcel)>,<android.view.Surface: void readFromParcel(Parcel)>,0,"{
    if (source == null) {
        throw new IllegalArgumentException(""source must not be null"");
    }
    synchronized (mLock) {
        // nativeReadFromParcel() will either return mNativeObject, or
        // create a new native Surface and return it after reducing
        // the reference count on mNativeObject.  Either way, it is
        // not necessary to call nativeRelease() here.
        mName = source.readString();
        setNativeObjectLocked(nativeReadFromParcel(mNativeObject, source));
    }
}","{
    if (source == null) {
        throw new IllegalArgumentException(""source must not be null"");
    }
    synchronized (mLock) {
        // nativeReadFromParcel() will either return mNativeObject, or
        // create a new native Surface and return it after reducing
        // the reference count on mNativeObject.  Either way, it is
        // not necessary to call nativeRelease() here.
        // NOTE: This must be kept synchronized with the native parceling code
        // in frameworks/native/libs/Surface.cpp
        mName = source.readString();
        mIsSingleBuffered = source.readInt() != 0;
        setNativeObjectLocked(nativeReadFromParcel(mNativeObject, source));
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The added statement mIsSingleBuffered = source.readInt() != 0; does not result in any control flow, return value, or exception handling changes. It merely assigns a value to a variable, so the code change type is 4.","The newly introduced statement does not affect the method's behavior regarding its return value or exception handling from the perspective of an external caller, and so would not lead to a Compatibility Issue."
114,<android.app.Activity: void onCreate(Bundle)>,25,26,<android.app.Activity: void onCreate(Bundle)>,<android.app.Activity: void onCreate(Bundle)>,0,"{
    if (DEBUG_LIFECYCLE)
        Slog.v(TAG, ""onCreate "" + this + "": "" + savedInstanceState);
    if (mLastNonConfigurationInstances != null) {
        mFragments.restoreLoaderNonConfig(mLastNonConfigurationInstances.loaders);
    }
    if (mActivityInfo.parentActivityName != null) {
        if (mActionBar == null) {
            mEnableDefaultActionBarUp = true;
        } else {
            mActionBar.setDefaultDisplayHomeAsUpEnabled(true);
        }
    }
    if (savedInstanceState != null) {
        Parcelable p = savedInstanceState.getParcelable(FRAGMENTS_TAG);
        mFragments.restoreAllState(p, mLastNonConfigurationInstances != null ? mLastNonConfigurationInstances.fragments : null);
    }
    mFragments.dispatchCreate();
    getApplication().dispatchActivityCreated(this, savedInstanceState);
    if (mVoiceInteractor != null) {
        mVoiceInteractor.attachActivity(this);
    }
    mCalled = true;
}","{
    if (DEBUG_LIFECYCLE)
        Slog.v(TAG, ""onCreate "" + this + "": "" + savedInstanceState);
    if (getApplicationInfo().targetSdkVersion > O && mActivityInfo.isFixedOrientation()) {
        final TypedArray ta = obtainStyledAttributes(com.android.internal.R.styleable.Window);
        final boolean isTranslucentOrFloating = ActivityInfo.isTranslucentOrFloating(ta);
        ta.recycle();
        if (isTranslucentOrFloating) {
            throw new IllegalStateException(""Only fullscreen opaque activities can request orientation"");
        }
    }
    if (mLastNonConfigurationInstances != null) {
        mFragments.restoreLoaderNonConfig(mLastNonConfigurationInstances.loaders);
    }
    if (mActivityInfo.parentActivityName != null) {
        if (mActionBar == null) {
            mEnableDefaultActionBarUp = true;
        } else {
            mActionBar.setDefaultDisplayHomeAsUpEnabled(true);
        }
    }
    if (savedInstanceState != null) {
        mAutoFillResetNeeded = savedInstanceState.getBoolean(AUTOFILL_RESET_NEEDED, false);
        mLastAutofillId = savedInstanceState.getInt(LAST_AUTOFILL_ID, View.LAST_APP_AUTOFILL_ID);
        if (mAutoFillResetNeeded) {
            getAutofillManager().onCreate(savedInstanceState);
        }
        Parcelable p = savedInstanceState.getParcelable(FRAGMENTS_TAG);
        mFragments.restoreAllState(p, mLastNonConfigurationInstances != null ? mLastNonConfigurationInstances.fragments : null);
    }
    mFragments.dispatchCreate();
    getApplication().dispatchActivityCreated(this, savedInstanceState);
    if (mVoiceInteractor != null) {
        mVoiceInteractor.attachActivity(this);
    }
    mCalled = true;
}",1,"/**
 * Called when the activity is starting.  This is where most initialization
 * should go: calling {@link #setContentView(int)} to inflate the
 * activity's UI, using {@link #findViewById} to programmatically interact
 * with widgets in the UI, calling
 * {@link #managedQuery(android.net.Uri , String[], String, String[], String)} to retrieve
 * cursors for data being displayed, etc.
 *
 * <p>You can call {@link #finish} from within this function, in
 * which case onDestroy() will be immediately called without any of the rest
 * of the activity lifecycle ({@link #onStart}, {@link #onResume},
 * {@link #onPause}, etc) executing.
 *
 * <p><em>Derived classes must call through to the super class's
 * implementation of this method.  If they do not, an exception will be
 * thrown.</em></p>
 *
 * @param savedInstanceState If the activity is being re-initialized after
 * previously being shut down then this Bundle contains the data it most
 * recently supplied in {@link #onSaveInstanceState}.  <b><i>Note: Otherwise it is null.</i></b>
 *
 * @see #onStart
 * @see #onSaveInstanceState
 * @see #onRestoreInstanceState
 * @see #onPostCreate
 */
","/**
 * Called when the activity is starting.  This is where most initialization
 * should go: calling {@link #setContentView(int)} to inflate the
 * activity's UI, using {@link #findViewById} to programmatically interact
 * with widgets in the UI, calling
 * {@link #managedQuery(android.net.Uri , String[], String, String[], String)} to retrieve
 * cursors for data being displayed, etc.
 *
 * <p>You can call {@link #finish} from within this function, in
 * which case onDestroy() will be immediately called without any of the rest
 * of the activity lifecycle ({@link #onStart}, {@link #onResume},
 * {@link #onPause}, etc) executing.
 *
 * <p><em>Derived classes must call through to the super class's
 * implementation of this method.  If they do not, an exception will be
 * thrown.</em></p>
 *
 * @param savedInstanceState If the activity is being re-initialized after
 * previously being shut down then this Bundle contains the data it most
 * recently supplied in {@link #onSaveInstanceState}.  <b><i>Note: Otherwise it is null.</i></b>
 *
 * @see #onStart
 * @see #onSaveInstanceState
 * @see #onRestoreInstanceState
 * @see #onPostCreate
 */
",-1,"[@MainThread, @CallSuper]","[@MainThread, @CallSuper]",-1,-1,-1,-1,-1,-1,"2,3,4","1,2","The implementation has an added block of code that checks if the target SDK version is above O and if the activity's requested orientation is fixed. If certain conditions are met, it throws a new IllegalStateException, which is a new exception handling statement (type 2). Control dependency has changed because a new if condition has been introduced (type 3). There is also a new branch of logic that sets values based on the savedInstanceState, which is another statement changed that does not fall under the aforementioned categories (type 4).","The new exception being thrown for a specific case where the activity is both translucent or floating and is requesting orientation can cause a Compatibility Issue as it changes the exception handling behavior (CI type 2). Additionally, since there is new logic that alters behavior based on `savedInstanceState`, it could lead to different return values or types, thus also causing a Compatibility Issue (CI type 1)."
115,"<android.app.ContextImpl: void sendStickyOrderedBroadcast(Intent,BroadcastReceiver,Handler,int,String,Bundle)>",25,26,"<android.app.ContextImpl: void sendStickyOrderedBroadcast(Intent,BroadcastReceiver,Handler,int,String,Bundle)>","<android.app.ContextImpl: void sendStickyOrderedBroadcast(Intent,BroadcastReceiver,Handler,int,String,Bundle)>",0,"{
    warnIfCallingFromSystemProcess();
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, rd, initialCode, initialData, initialExtras, null, AppOpsManager.OP_NONE, null, true, true, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    warnIfCallingFromSystemProcess();
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, rd, initialCode, initialData, initialExtras, null, AppOpsManager.OP_NONE, null, true, true, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,"[@Override, @Deprecated]","[@Override, @Deprecated]",-1,-1,-1,-1,-1,-1,"4,5",0,"The API used to send the broadcast intent has changed from ""ActivityManagerNative.getDefault()"" to ""ActivityManager.getService()"". This is a change in a dependent API, code change type 5. There's also a minor change in the way the ActivityManager service is accessed, which is considered an Other statement change (code change type 4).","There is no Compatibility Issue detectable from this change since the method signature remains the same and the functionality provided by the ActivityManager service's broadcastIntent method is intended to maintain its contract between versions. Thus, the change should not affect the outward behavior of the sendStickyOrderedBroadcast method."
118,<android.app.Activity: boolean dispatchKeyEvent(KeyEvent)>,25,26,<android.app.Activity: boolean dispatchKeyEvent(KeyEvent)>,<android.app.Activity: boolean dispatchKeyEvent(KeyEvent)>,0,"{
    onUserInteraction();
    // Let action bars open menus in response to the menu key prioritized over
    // the window handling it
    final int keyCode = event.getKeyCode();
    if (keyCode == KeyEvent.KEYCODE_MENU && mActionBar != null && mActionBar.onMenuKeyEvent(event)) {
        return true;
    } else if (event.isCtrlPressed() && event.getUnicodeChar(event.getMetaState() & ~KeyEvent.META_CTRL_MASK) == '<') {
        // Capture the Control-< and send focus to the ActionBar
        final int action = event.getAction();
        if (action == KeyEvent.ACTION_DOWN) {
            final ActionBar actionBar = getActionBar();
            if (actionBar != null && actionBar.isShowing() && actionBar.requestFocus()) {
                mEatKeyUpEvent = true;
                return true;
            }
        } else if (action == KeyEvent.ACTION_UP && mEatKeyUpEvent) {
            mEatKeyUpEvent = false;
            return true;
        }
    }
    Window win = getWindow();
    if (win.superDispatchKeyEvent(event)) {
        return true;
    }
    View decor = mDecor;
    if (decor == null)
        decor = win.getDecorView();
    return event.dispatch(this, decor != null ? decor.getKeyDispatcherState() : null, this);
}","{
    onUserInteraction();
    // Let action bars open menus in response to the menu key prioritized over
    // the window handling it
    final int keyCode = event.getKeyCode();
    if (keyCode == KeyEvent.KEYCODE_MENU && mActionBar != null && mActionBar.onMenuKeyEvent(event)) {
        return true;
    }
    Window win = getWindow();
    if (win.superDispatchKeyEvent(event)) {
        return true;
    }
    View decor = mDecor;
    if (decor == null)
        decor = win.getDecorView();
    return event.dispatch(this, decor != null ? decor.getKeyDispatcherState() : null, this);
}",1,"/**
 * Called to process key events.  You can override this to intercept all
 * key events before they are dispatched to the window.  Be sure to call
 * this implementation for key events that should be handled normally.
 *
 * @param event The key event.
 *
 * @return boolean Return true if this event was consumed.
 */
","/**
 * Called to process key events.  You can override this to intercept all
 * key events before they are dispatched to the window.  Be sure to call
 * this implementation for key events that should be handled normally.
 *
 * @param event The key event.
 *
 * @return boolean Return true if this event was consumed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"There is a removal of an entire control dependency segment ""else if (event.isCtrlPressed()...)"" along with its contained return statements, thus the code change types are 1 for return statement changed and 3 for control dependency changed.","The removed conditional code and return statements could potentially cause different behavior in the event handling, possibly producing different return values based on the KeyEvent provided. This constitutes a compatibility issue of type 1, where the API could return different values."
120,<android.os.RemoteCallbackList: void finishBroadcast()>,25,26,<android.os.RemoteCallbackList: void finishBroadcast()>,<android.os.RemoteCallbackList: void finishBroadcast()>,0,"{
    if (mBroadcastCount < 0) {
        throw new IllegalStateException(""finishBroadcast() called outside of a broadcast"");
    }
    Object[] active = mActiveBroadcast;
    if (active != null) {
        final int N = mBroadcastCount;
        for (int i = 0; i < N; i++) {
            active[i] = null;
        }
    }
    mBroadcastCount = -1;
}","{
    synchronized (mCallbacks) {
        if (mBroadcastCount < 0) {
            throw new IllegalStateException(""finishBroadcast() called outside of a broadcast"");
        }
        Object[] active = mActiveBroadcast;
        if (active != null) {
            final int N = mBroadcastCount;
            for (int i = 0; i < N; i++) {
                active[i] = null;
            }
        }
        mBroadcastCount = -1;
    }
}",1,"/**
 * Clean up the state of a broadcast previously initiated by calling
 * {@link #beginBroadcast}.  This must always be called when you are done
 * with a broadcast.
 *
 * @see #beginBroadcast
 */
","/**
 * Clean up the state of a broadcast previously initiated by calling
 * {@link #beginBroadcast}.  This must always be called when you are done
 * with a broadcast.
 *
 * @see #beginBroadcast
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The early version of the implementation does not have synchronization control around the code block, while the late version introduces a synchronized block on mCallbacks. This change is classified as a control dependency change; therefore, the code change type is 3.","The introduction of a synchronized block doesn't change the logic of how values are returned or exceptions are thrown inside the method; it merely ensures that the code block is executed atomically, which can prevent concurrent modification issues but doesn't inherently change the method's behavior from an API consumer's perspective. Hence, there is no compatibility issue; the CI type is 0."
121,<android.animation.AnimatorSet: void end()>,25,26,<android.animation.AnimatorSet: void end()>,<android.animation.AnimatorSet: void end()>,0,"{
    if (mShouldIgnoreEndWithoutStart && !isStarted()) {
        return;
    }
    mTerminated = true;
    if (isStarted()) {
        endRemainingAnimations();
    }
    if (mListeners != null) {
        ArrayList<AnimatorListener> tmpListeners = (ArrayList<AnimatorListener>) mListeners.clone();
        for (int i = 0; i < tmpListeners.size(); i++) {
            tmpListeners.get(i).onAnimationEnd(this);
        }
    }
    mStarted = false;
}","{
    if (Looper.myLooper() == null) {
        throw new AndroidRuntimeException(""Animators may only be run on Looper threads"");
    }
    if (mShouldIgnoreEndWithoutStart && !isStarted()) {
        return;
    }
    if (isStarted()) {
        // Iterate the animations that haven't finished or haven't started, and end them.
        if (mReversing) {
            // Between start() and first frame, mLastEventId would be unset (i.e. -1)
            mLastEventId = mLastEventId == -1 ? mEvents.size() : mLastEventId;
            while (mLastEventId > 0) {
                mLastEventId = mLastEventId - 1;
                AnimationEvent event = mEvents.get(mLastEventId);
                Animator anim = event.mNode.mAnimation;
                if (mNodeMap.get(anim).mEnded) {
                    continue;
                }
                if (event.mEvent == AnimationEvent.ANIMATION_END) {
                    anim.reverse();
                } else if (event.mEvent == AnimationEvent.ANIMATION_DELAY_ENDED && anim.isStarted()) {
                    // Make sure anim hasn't finished before calling end() so that we don't end
                    // already ended animations, which will cause start and end callbacks to be
                    // triggered again.
                    anim.end();
                }
            }
        } else {
            while (mLastEventId < mEvents.size() - 1) {
                // Avoid potential reentrant loop caused by child animators manipulating
                // AnimatorSet's lifecycle (i.e. not a recommended approach).
                mLastEventId = mLastEventId + 1;
                AnimationEvent event = mEvents.get(mLastEventId);
                Animator anim = event.mNode.mAnimation;
                if (mNodeMap.get(anim).mEnded) {
                    continue;
                }
                if (event.mEvent == AnimationEvent.ANIMATION_START) {
                    anim.start();
                } else if (event.mEvent == AnimationEvent.ANIMATION_END && anim.isStarted()) {
                    // Make sure anim hasn't finished before calling end() so that we don't end
                    // already ended animations, which will cause start and end callbacks to be
                    // triggered again.
                    anim.end();
                }
            }
        }
        mPlayingSet.clear();
    }
    endAnimation();
}",1,"/**
 * {@inheritDoc}
 *
 * <p>Note that ending a <code>AnimatorSet</code> also ends all of the animations that it is
 * responsible for.</p>
 */
","/**
 * {@inheritDoc}
 *
 * <p>Note that ending a <code>AnimatorSet</code> also ends all of the animations that it is
 * responsible for.</p>
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,2,3","1,2","The late version introduces a new throw statement at the beginning, which could potentially throw a new exception. It adds a check for the `Looper` and a different handling mechanism for the animations (e.g., reversing and ending animations using different conditions). These changes involve control dependency, exception handling, and return statement changes (due to additional conditions before returning), thus the change type is 1,2,3.","The API in the late version introduces a new exception (AndroidRuntimeException) that was not present in the early version, which directly affects the exception handling (CI type 2). Moreover, changes in the logic of how the animation set is ended can alter the state of the animation set and potentially change the return type or value when the 'end()' method is called (CI type 1)."
122,<android.text.method.DigitsKeyListener: int getInputType()>,25,26,<android.text.method.DigitsKeyListener: int getInputType()>,<android.text.method.DigitsKeyListener: int getInputType()>,0,"{
    int contentType = InputType.TYPE_CLASS_NUMBER;
    if (mSign) {
        contentType |= InputType.TYPE_NUMBER_FLAG_SIGNED;
    }
    if (mDecimal) {
        contentType |= InputType.TYPE_NUMBER_FLAG_DECIMAL;
    }
    return contentType;
}","{
    int contentType;
    if (mNeedsAdvancedInput) {
        contentType = InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_NORMAL;
    } else {
        contentType = InputType.TYPE_CLASS_NUMBER;
        if (mSign) {
            contentType |= InputType.TYPE_NUMBER_FLAG_SIGNED;
        }
        if (mDecimal) {
            contentType |= InputType.TYPE_NUMBER_FLAG_DECIMAL;
        }
    }
    return contentType;
}",1,,"/**
 * Returns the input type for the listener.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"A new control flow statement is introduced to set the `contentType` depending on the value of the `mNeedsAdvancedInput` variable. Also, local variable initialization changed from directly initializing `contentType` to conditional initialization, so the changes are 3 and 4.","Due to the new control flow statement introduced to check `mNeedsAdvancedInput`, the method may return different values when `mNeedsAdvancedInput` is `true`. This results in the method potentially returning a different type/content of input type, hence the CI type is 1."
123,<android.util.ArrayMap: V removeAt(int)>,25,26,<android.util.ArrayMap: V removeAt(int)>,<android.util.ArrayMap: V removeAt(int)>,0,"{
    final Object old = mArray[(index << 1) + 1];
    if (mSize <= 1) {
        // Now empty.
        if (DEBUG)
            Log.d(TAG, ""remove: shrink from "" + mHashes.length + "" to 0"");
        freeArrays(mHashes, mArray, mSize);
        mHashes = EmptyArray.INT;
        mArray = EmptyArray.OBJECT;
        mSize = 0;
    } else {
        if (mHashes.length > (BASE_SIZE * 2) && mSize < mHashes.length / 3) {
            // Shrunk enough to reduce size of arrays.  We don't allow it to
            // shrink smaller than (BASE_SIZE*2) to avoid flapping between
            // that and BASE_SIZE.
            final int n = mSize > (BASE_SIZE * 2) ? (mSize + (mSize >> 1)) : (BASE_SIZE * 2);
            if (DEBUG)
                Log.d(TAG, ""remove: shrink from "" + mHashes.length + "" to "" + n);
            final int[] ohashes = mHashes;
            final Object[] oarray = mArray;
            allocArrays(n);
            mSize--;
            if (index > 0) {
                if (DEBUG)
                    Log.d(TAG, ""remove: copy from 0-"" + index + "" to 0"");
                System.arraycopy(ohashes, 0, mHashes, 0, index);
                System.arraycopy(oarray, 0, mArray, 0, index << 1);
            }
            if (index < mSize) {
                if (DEBUG)
                    Log.d(TAG, ""remove: copy from "" + (index + 1) + ""-"" + mSize + "" to "" + index);
                System.arraycopy(ohashes, index + 1, mHashes, index, mSize - index);
                System.arraycopy(oarray, (index + 1) << 1, mArray, index << 1, (mSize - index) << 1);
            }
        } else {
            mSize--;
            if (index < mSize) {
                if (DEBUG)
                    Log.d(TAG, ""remove: move "" + (index + 1) + ""-"" + mSize + "" to "" + index);
                System.arraycopy(mHashes, index + 1, mHashes, index, mSize - index);
                System.arraycopy(mArray, (index + 1) << 1, mArray, index << 1, (mSize - index) << 1);
            }
            mArray[mSize << 1] = null;
            mArray[(mSize << 1) + 1] = null;
        }
    }
    return (V) old;
}","{
    final Object old = mArray[(index << 1) + 1];
    final int osize = mSize;
    final int nsize;
    if (osize <= 1) {
        // Now empty.
        if (DEBUG)
            Log.d(TAG, ""remove: shrink from "" + mHashes.length + "" to 0"");
        freeArrays(mHashes, mArray, osize);
        mHashes = EmptyArray.INT;
        mArray = EmptyArray.OBJECT;
        nsize = 0;
    } else {
        nsize = osize - 1;
        if (mHashes.length > (BASE_SIZE * 2) && mSize < mHashes.length / 3) {
            // Shrunk enough to reduce size of arrays.  We don't allow it to
            // shrink smaller than (BASE_SIZE*2) to avoid flapping between
            // that and BASE_SIZE.
            final int n = osize > (BASE_SIZE * 2) ? (osize + (osize >> 1)) : (BASE_SIZE * 2);
            if (DEBUG)
                Log.d(TAG, ""remove: shrink from "" + mHashes.length + "" to "" + n);
            final int[] ohashes = mHashes;
            final Object[] oarray = mArray;
            allocArrays(n);
            if (CONCURRENT_MODIFICATION_EXCEPTIONS && osize != mSize) {
                throw new ConcurrentModificationException();
            }
            if (index > 0) {
                if (DEBUG)
                    Log.d(TAG, ""remove: copy from 0-"" + index + "" to 0"");
                System.arraycopy(ohashes, 0, mHashes, 0, index);
                System.arraycopy(oarray, 0, mArray, 0, index << 1);
            }
            if (index < nsize) {
                if (DEBUG)
                    Log.d(TAG, ""remove: copy from "" + (index + 1) + ""-"" + nsize + "" to "" + index);
                System.arraycopy(ohashes, index + 1, mHashes, index, nsize - index);
                System.arraycopy(oarray, (index + 1) << 1, mArray, index << 1, (nsize - index) << 1);
            }
        } else {
            if (index < nsize) {
                if (DEBUG)
                    Log.d(TAG, ""remove: move "" + (index + 1) + ""-"" + nsize + "" to "" + index);
                System.arraycopy(mHashes, index + 1, mHashes, index, nsize - index);
                System.arraycopy(mArray, (index + 1) << 1, mArray, index << 1, (nsize - index) << 1);
            }
            mArray[nsize << 1] = null;
            mArray[(nsize << 1) + 1] = null;
        }
    }
    if (CONCURRENT_MODIFICATION_EXCEPTIONS && osize != mSize) {
        throw new ConcurrentModificationException();
    }
    mSize = nsize;
    return (V) old;
}",1,"/**
 * Remove the key/value mapping at the given index.
 * @param index The desired index, must be between 0 and {@link #size()}-1.
 * @return Returns the value that was stored at this index.
 */
","/**
 * Remove the key/value mapping at the given index.
 * @param index The desired index, must be between 0 and {@link #size()}-1.
 * @return Returns the value that was stored at this index.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
125,"<android.view.View: View findUserSetNextFocus(View,int)>",25,26,"<android.view.View: View findUserSetNextFocus(View,int)>","<android.view.View: View findUserSetNextFocus(View,int)>",0,"{
    switch(direction) {
        case FOCUS_LEFT:
            if (mNextFocusLeftId == View.NO_ID)
                return null;
            return findViewInsideOutShouldExist(root, mNextFocusLeftId);
        case FOCUS_RIGHT:
            if (mNextFocusRightId == View.NO_ID)
                return null;
            return findViewInsideOutShouldExist(root, mNextFocusRightId);
        case FOCUS_UP:
            if (mNextFocusUpId == View.NO_ID)
                return null;
            return findViewInsideOutShouldExist(root, mNextFocusUpId);
        case FOCUS_DOWN:
            if (mNextFocusDownId == View.NO_ID)
                return null;
            return findViewInsideOutShouldExist(root, mNextFocusDownId);
        case FOCUS_FORWARD:
            if (mNextFocusForwardId == View.NO_ID)
                return null;
            return findViewInsideOutShouldExist(root, mNextFocusForwardId);
        case FOCUS_BACKWARD:
            {
                if (mID == View.NO_ID)
                    return null;
                final int id = mID;
                return root.findViewByPredicateInsideOut(this, new Predicate<View>() {

                    @Override
                    public boolean apply(View t) {
                        return t.mNextFocusForwardId == id;
                    }
                });
            }
    }
    return null;
}","{
    switch(direction) {
        case FOCUS_LEFT:
            if (mNextFocusLeftId == View.NO_ID)
                return null;
            return findViewInsideOutShouldExist(root, mNextFocusLeftId);
        case FOCUS_RIGHT:
            if (mNextFocusRightId == View.NO_ID)
                return null;
            return findViewInsideOutShouldExist(root, mNextFocusRightId);
        case FOCUS_UP:
            if (mNextFocusUpId == View.NO_ID)
                return null;
            return findViewInsideOutShouldExist(root, mNextFocusUpId);
        case FOCUS_DOWN:
            if (mNextFocusDownId == View.NO_ID)
                return null;
            return findViewInsideOutShouldExist(root, mNextFocusDownId);
        case FOCUS_FORWARD:
            if (mNextFocusForwardId == View.NO_ID)
                return null;
            return findViewInsideOutShouldExist(root, mNextFocusForwardId);
        case FOCUS_BACKWARD:
            {
                if (mID == View.NO_ID)
                    return null;
                final int id = mID;
                return root.findViewByPredicateInsideOut(this, new Predicate<View>() {

                    @Override
                    public boolean test(View t) {
                        return t.mNextFocusForwardId == id;
                    }
                });
            }
    }
    return null;
}",1,"/**
 * If a user manually specified the next view id for a particular direction,
 * use the root to look up the view.
 * @param root The root view of the hierarchy containing this view.
 * @param direction One of FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, FOCUS_RIGHT, FOCUS_FORWARD,
 * or FOCUS_BACKWARD.
 * @return The user specified next view, or null if there is none.
 */
","/**
 * If a user manually specified the next view id for a particular direction,
 * use the root to look up the view.
 * @param root The root view of the hierarchy containing this view.
 * @param direction One of FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, FOCUS_RIGHT, FOCUS_FORWARD,
 * or FOCUS_BACKWARD.
 * @return The user specified next view, or null if there is none.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code change consists of the change of a method name inside the anonymous `Predicate` from `apply` to `test`, which reflects a change in the method that needs to be overridden due to an update in the `Predicate` interface. So the code change type is 4.","Despite the method name being changed from `apply` to `test` inside the `Predicate`, this does not change the behavior of the API, as it's just an update to conform to the new `Predicate` interface requirements in Java. This method will still be called as it was before, resulting in the same behavioral outcome. Therefore, there is no compatibility issue, so the CI type is 0."
127,<android.app.SharedPreferencesImpl: void startReloadIfChangedUnexpectedly()>,25,26,<android.app.SharedPreferencesImpl: void startReloadIfChangedUnexpectedly()>,<android.app.SharedPreferencesImpl: void startReloadIfChangedUnexpectedly()>,0,"{
    synchronized (this) {
        // TODO: wait for any pending writes to disk?
        if (!hasFileChangedUnexpectedly()) {
            return;
        }
        startLoadFromDisk();
    }
}","{
    synchronized (mLock) {
        // TODO: wait for any pending writes to disk?
        if (!hasFileChangedUnexpectedly()) {
            return;
        }
        startLoadFromDisk();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change between the early version and the late version is the lock object in the synchronized statement, from `this` to `mLock`. This qualifies as an ""Other statement changed"" according to the coding rules.","This change doesn't affect the method's control flow or its behavior but only the object on which it synchronizes. Clients using this method should not experience altered behavior as a result of this locking strategy change. Hence, there is no Compatibility Issue."
128,<android.app.ActivityManager: int getLockTaskModeState()>,25,26,<android.app.ActivityManager: int getLockTaskModeState()>,<android.app.ActivityManager: int getLockTaskModeState()>,0,"{
    try {
        return ActivityManagerNative.getDefault().getLockTaskModeState();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        return getService().getLockTaskModeState();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Return the current state of task locking. The three possible outcomes
 * are {@link #LOCK_TASK_MODE_NONE}, {@link #LOCK_TASK_MODE_LOCKED}
 * and {@link #LOCK_TASK_MODE_PINNED}.
 *
 * @see Activity#startLockTask()
 */
","/**
 * Return the current state of task locking. The three possible outcomes
 * are {@link #LOCK_TASK_MODE_NONE}, {@link #LOCK_TASK_MODE_LOCKED}
 * and {@link #LOCK_TASK_MODE_PINNED}.
 *
 * @see Activity#startLockTask()
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method called within the return statement changed from ActivityManagerNative.getDefault().getLockTaskModeState() to getService().getLockTaskModeState(). This reflects a change in the dependencies used within the method rather than the functionality of the method itself, hence the change type is 5.",There is no compatibility issue detected since the return type and exception handling remain consistent. The change of the dependent method does not imply different behavior as long as the contract of getService().getLockTaskModeState() remains identical to ActivityManagerNative.getDefault().getLockTaskModeState().
129,<android.app.Activity: void showLockTaskEscapeMessage()>,25,26,<android.app.Activity: void showLockTaskEscapeMessage()>,<android.app.Activity: void showLockTaskEscapeMessage()>,0,"{
    try {
        ActivityManagerNative.getDefault().showLockTaskEscapeMessage(mToken);
    } catch (RemoteException e) {
    }
}","{
    try {
        ActivityManager.getService().showLockTaskEscapeMessage(mToken);
    } catch (RemoteException e) {
    }
}",1,"/**
 * Shows the user the system defined message for telling the user how to exit
 * lock task mode. The task containing this activity must be in lock task mode at the time
 * of this call for the message to be displayed.
 */
","/**
 * Shows the user the system defined message for telling the user how to exit
 * lock task mode. The task containing this activity must be in lock task mode at the time
 * of this call for the message to be displayed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The API used within the 'try' block has changed from ActivityManagerNative.getDefault() to ActivityManager.getService(), which indicates that a dependent API has changed. No return or exception handling changes are introduced. So the change type is 5.","Since this change does not affect the behavior of showLockTaskEscapeMessage() in terms of altering return values, introducing new exception handling, or changing control flow, it should not cause any compatibility issues. The API's core functionality, showing the Lock Task escape message, remains intact across versions. The change is inside a try block, and catches a RemoteException without altering how it is handled. Therefore, no compatibility issue is introduced."
130,"<android.os.BaseBundle: void writeToParcelInner(Parcel,int)>",25,26,"<android.os.BaseBundle: void writeToParcelInner(Parcel,int)>","<android.os.BaseBundle: void writeToParcelInner(Parcel,int)>",0,"{
    // Keep implementation in sync with writeToParcel() in
    // frameworks/native/libs/binder/PersistableBundle.cpp.
    final Parcel parcelledData;
    synchronized (this) {
        parcelledData = mParcelledData;
    }
    if (parcelledData != null) {
        if (isEmptyParcel()) {
            parcel.writeInt(0);
        } else {
            int length = parcelledData.dataSize();
            parcel.writeInt(length);
            parcel.writeInt(BUNDLE_MAGIC);
            parcel.appendFrom(parcelledData, 0, length);
        }
    } else {
        // Special case for empty bundles.
        if (mMap == null || mMap.size() <= 0) {
            parcel.writeInt(0);
            return;
        }
        int lengthPos = parcel.dataPosition();
        // dummy, will hold length
        parcel.writeInt(-1);
        parcel.writeInt(BUNDLE_MAGIC);
        int startPos = parcel.dataPosition();
        parcel.writeArrayMapInternal(mMap);
        int endPos = parcel.dataPosition();
        // Backpatch length
        parcel.setDataPosition(lengthPos);
        int length = endPos - startPos;
        parcel.writeInt(length);
        parcel.setDataPosition(endPos);
    }
}","{
    // Keep implementation in sync with writeToParcel() in
    // frameworks/native/libs/binder/PersistableBundle.cpp.
    final ArrayMap<String, Object> map;
    synchronized (this) {
        // at the wrong time. So synchronize access the mParcelledData's content.
        if (mParcelledData != null) {
            if (mParcelledData == NoImagePreloadHolder.EMPTY_PARCEL) {
                parcel.writeInt(0);
            } else {
                int length = mParcelledData.dataSize();
                parcel.writeInt(length);
                parcel.writeInt(BUNDLE_MAGIC);
                parcel.appendFrom(mParcelledData, 0, length);
            }
            return;
        }
        map = mMap;
    }
    // Special case for empty bundles.
    if (map == null || map.size() <= 0) {
        parcel.writeInt(0);
        return;
    }
    int lengthPos = parcel.dataPosition();
    // dummy, will hold length
    parcel.writeInt(-1);
    parcel.writeInt(BUNDLE_MAGIC);
    int startPos = parcel.dataPosition();
    parcel.writeArrayMapInternal(map);
    int endPos = parcel.dataPosition();
    // Backpatch length
    parcel.setDataPosition(lengthPos);
    int length = endPos - startPos;
    parcel.writeInt(length);
    parcel.setDataPosition(endPos);
}",1,"/**
 * Writes the Bundle contents to a Parcel, typically in order for
 * it to be passed through an IBinder connection.
 * @param parcel The parcel to copy this bundle to.
 */
","/**
 * Writes the Bundle contents to a Parcel, typically in order for
 * it to be passed through an IBinder connection.
 * @param parcel The parcel to copy this bundle to.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The change occurs in the structure of the synchronization block and the introduction of a new local variable, ""map"". Furthermore, there is also a change from checking 'isEmptyParcel()' to comparing 'mParcelledData' with 'NoImagePreloadHolder.EMPTY_PARCEL'. Thus, the changes are in control dependency (3) and other statements (4).","Although there are changes in the implementation, these changes do not affect the behavior of the method in terms of what it writes to the parcel or the exceptions it may throw. The method still performs parcel writing with the same logic, just with a slightly different internal structure and code optimization. Therefore, there is no compatibility issue (0)."
132,<android.content.ContentResolver: String getType(Uri)>,25,26,<android.content.ContentResolver: String getType(Uri)>,<android.content.ContentResolver: String getType(Uri)>,0,"{
    Preconditions.checkNotNull(url, ""url"");
    // XXX would like to have an acquireExistingUnstableProvider for this.
    IContentProvider provider = acquireExistingProvider(url);
    if (provider != null) {
        try {
            return provider.getType(url);
        } catch (RemoteException e) {
            return null;
        } catch (java.lang.Exception e) {
            Log.w(TAG, ""Failed to get type for: "" + url + "" ("" + e.getMessage() + "")"");
            return null;
        } finally {
            releaseProvider(provider);
        }
    }
    if (!SCHEME_CONTENT.equals(url.getScheme())) {
        return null;
    }
    try {
        String type = ActivityManagerNative.getDefault().getProviderMimeType(ContentProvider.getUriWithoutUserId(url), resolveUserId(url));
        return type;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } catch (java.lang.Exception e) {
        Log.w(TAG, ""Failed to get type for: "" + url + "" ("" + e.getMessage() + "")"");
        return null;
    }
}","{
    Preconditions.checkNotNull(url, ""url"");
    // XXX would like to have an acquireExistingUnstableProvider for this.
    IContentProvider provider = acquireExistingProvider(url);
    if (provider != null) {
        try {
            return provider.getType(url);
        } catch (RemoteException e) {
            return null;
        } catch (java.lang.Exception e) {
            Log.w(TAG, ""Failed to get type for: "" + url + "" ("" + e.getMessage() + "")"");
            return null;
        } finally {
            releaseProvider(provider);
        }
    }
    if (!SCHEME_CONTENT.equals(url.getScheme())) {
        return null;
    }
    try {
        String type = ActivityManager.getService().getProviderMimeType(ContentProvider.getUriWithoutUserId(url), resolveUserId(url));
        return type;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } catch (java.lang.Exception e) {
        Log.w(TAG, ""Failed to get type for: "" + url + "" ("" + e.getMessage() + "")"");
        return null;
    }
}",1,"/**
 * Return the MIME type of the given content URL.
 *
 * @param url A Uri identifying content (either a list or specific type),
 * using the content:// scheme.
 * @return A MIME type for the content, or null if the URL is invalid or the type is unknown
 */
","/**
 * Return the MIME type of the given content URL.
 *
 * @param url A Uri identifying content (either a list or specific type),
 * using the content:// scheme.
 * @return A MIME type for the content, or null if the URL is invalid or the type is unknown
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,5,0,"The dependent API `ActivityManagerNative.getDefault()` in the try block has been changed to `ActivityManager.getService()`. This is a change in a dependent API, so the code change type is 5.","There is no Compatibility Issue because the change is simply replacing the call to a singleton getter of the ActivityManager class with a new, likely equivalent, singleton getter method. This should not affect the behavior observed by clients of the `getType(Uri)` API, as long as the new method `getService()` is intended to return the same instance as the old `getDefault()` method. Assuming that is the case, the client will receive the exact same service object and thereby the same functionality, and the return behavior of this API will not change. Thus, it is reasonable to assume no Compatibility Issue will arise, hence CI type is 0."
133,<android.view.accessibility.AccessibilityWindowInfo: AccessibilityWindowInfo getParent()>,25,26,<android.view.accessibility.AccessibilityWindowInfo: AccessibilityWindowInfo getParent()>,<android.view.accessibility.AccessibilityWindowInfo: AccessibilityWindowInfo getParent()>,0,"{
    if (mConnectionId == UNDEFINED || mParentId == UNDEFINED) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.getWindow(mConnectionId, mParentId);
}","{
    if (mConnectionId == UNDEFINED_WINDOW_ID || mParentId == UNDEFINED_WINDOW_ID) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.getWindow(mConnectionId, mParentId);
}",1,"/**
 * Gets the parent window.
 *
 * @return The parent window, or {@code null} if none exists.
 */
","/**
 * Gets the parent window.
 *
 * @return The parent window, or {@code null} if none exists.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change is related to the constant values for 'UNDEFINED' which has been renamed to 'UNDEFINED_WINDOW_ID' for both mConnectionId and mParentId. This is an internal constant change, so it is categorized as a change in Other statement (code change type 4).","Since the behavior of the method has not changed and it only involves renaming internal constants without changing logic or behavior, no Compatibility Issue should arise as a result of this change (CI type is 0)."
134,<android.app.ActivityManager.TaskDescription: String toString()>,25,26,<android.app.ActivityManager.TaskDescription: String toString()>,<android.app.ActivityManager.TaskDescription: String toString()>,0,"{
    return ""TaskDescription Label: "" + mLabel + "" Icon: "" + mIcon + "" IconFilename: "" + mIconFilename + "" colorPrimary: "" + mColorPrimary + "" colorBackground: "" + mColorBackground;
}","{
    return ""TaskDescription Label: "" + mLabel + "" Icon: "" + mIcon + "" IconFilename: "" + mIconFilename + "" colorPrimary: "" + mColorPrimary + "" colorBackground: "" + mColorBackground + "" statusBarColor: "" + mColorBackground + "" navigationBarColor: "" + mNavigationBarColor;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"The return statement has been extended to include additional information (`statusBarColor: ` and `navigationBarColor: `), indicating that the string returned by `toString()` will be different in the late version. The code change type is 1.","The change in the return statement means the method will return a different string value than before, thus there is a potential Compatibility Issue caused by different return values, so the CI type is 1."
135,<android.view.ViewGroup: boolean dispatchHoverEvent(MotionEvent)>,25,26,<android.view.ViewGroup: boolean dispatchHoverEvent(MotionEvent)>,<android.view.ViewGroup: boolean dispatchHoverEvent(MotionEvent)>,0,"{
    final int action = event.getAction();
    // First check whether the view group wants to intercept the hover event.
    final boolean interceptHover = onInterceptHoverEvent(event);
    // restore action in case it was changed
    event.setAction(action);
    MotionEvent eventNoHistory = event;
    boolean handled = false;
    // Send events to the hovered children and build a new list of hover targets until
    // one is found that handles the event.
    HoverTarget firstOldHoverTarget = mFirstHoverTarget;
    mFirstHoverTarget = null;
    if (!interceptHover && action != MotionEvent.ACTION_HOVER_EXIT) {
        final float x = event.getX();
        final float y = event.getY();
        final int childrenCount = mChildrenCount;
        if (childrenCount != 0) {
            final ArrayList<View> preorderedList = buildOrderedChildList();
            final boolean customOrder = preorderedList == null && isChildrenDrawingOrderEnabled();
            final View[] children = mChildren;
            HoverTarget lastHoverTarget = null;
            for (int i = childrenCount - 1; i >= 0; i--) {
                final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);
                final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);
                if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) {
                    continue;
                }
                // Obtain a hover target for this child.  Dequeue it from the
                // old hover target list if the child was previously hovered.
                HoverTarget hoverTarget = firstOldHoverTarget;
                final boolean wasHovered;
                for (HoverTarget predecessor = null; ; ) {
                    if (hoverTarget == null) {
                        hoverTarget = HoverTarget.obtain(child);
                        wasHovered = false;
                        break;
                    }
                    if (hoverTarget.child == child) {
                        if (predecessor != null) {
                            predecessor.next = hoverTarget.next;
                        } else {
                            firstOldHoverTarget = hoverTarget.next;
                        }
                        hoverTarget.next = null;
                        wasHovered = true;
                        break;
                    }
                    predecessor = hoverTarget;
                    hoverTarget = hoverTarget.next;
                }
                // Enqueue the hover target onto the new hover target list.
                if (lastHoverTarget != null) {
                    lastHoverTarget.next = hoverTarget;
                } else {
                    mFirstHoverTarget = hoverTarget;
                }
                lastHoverTarget = hoverTarget;
                // Dispatch the event to the child.
                if (action == MotionEvent.ACTION_HOVER_ENTER) {
                    if (!wasHovered) {
                        // Send the enter as is.
                        handled |= dispatchTransformedGenericPointerEvent(event, // enter
                        child);
                    }
                } else if (action == MotionEvent.ACTION_HOVER_MOVE) {
                    if (!wasHovered) {
                        // Synthesize an enter from a move.
                        eventNoHistory = obtainMotionEventNoHistoryOrSelf(eventNoHistory);
                        eventNoHistory.setAction(MotionEvent.ACTION_HOVER_ENTER);
                        handled |= dispatchTransformedGenericPointerEvent(eventNoHistory, // enter
                        child);
                        eventNoHistory.setAction(action);
                        handled |= dispatchTransformedGenericPointerEvent(eventNoHistory, // move
                        child);
                    } else {
                        // Send the move as is.
                        handled |= dispatchTransformedGenericPointerEvent(event, child);
                    }
                }
                if (handled) {
                    break;
                }
            }
            if (preorderedList != null)
                preorderedList.clear();
        }
    }
    // Send exit events to all previously hovered children that are no longer hovered.
    while (firstOldHoverTarget != null) {
        final View child = firstOldHoverTarget.child;
        // Exit the old hovered child.
        if (action == MotionEvent.ACTION_HOVER_EXIT) {
            // Send the exit as is.
            handled |= dispatchTransformedGenericPointerEvent(event, // exit
            child);
        } else {
            // Ignore the result because hover focus has moved to a different view.
            if (action == MotionEvent.ACTION_HOVER_MOVE) {
                dispatchTransformedGenericPointerEvent(event, // move
                child);
            }
            eventNoHistory = obtainMotionEventNoHistoryOrSelf(eventNoHistory);
            eventNoHistory.setAction(MotionEvent.ACTION_HOVER_EXIT);
            dispatchTransformedGenericPointerEvent(eventNoHistory, // exit
            child);
            eventNoHistory.setAction(action);
        }
        final HoverTarget nextOldHoverTarget = firstOldHoverTarget.next;
        firstOldHoverTarget.recycle();
        firstOldHoverTarget = nextOldHoverTarget;
    }
    // Send events to the view group itself if no children have handled it.
    boolean newHoveredSelf = !handled;
    if (newHoveredSelf == mHoveredSelf) {
        if (newHoveredSelf) {
            // Send event to the view group as before.
            handled |= super.dispatchHoverEvent(event);
        }
    } else {
        if (mHoveredSelf) {
            // Exit the view group.
            if (action == MotionEvent.ACTION_HOVER_EXIT) {
                // Send the exit as is.
                // exit
                handled |= super.dispatchHoverEvent(event);
            } else {
                // Ignore the result because hover focus is moving to a different view.
                if (action == MotionEvent.ACTION_HOVER_MOVE) {
                    // move
                    super.dispatchHoverEvent(event);
                }
                eventNoHistory = obtainMotionEventNoHistoryOrSelf(eventNoHistory);
                eventNoHistory.setAction(MotionEvent.ACTION_HOVER_EXIT);
                // exit
                super.dispatchHoverEvent(eventNoHistory);
                eventNoHistory.setAction(action);
            }
            mHoveredSelf = false;
        }
        if (newHoveredSelf) {
            // Enter the view group.
            if (action == MotionEvent.ACTION_HOVER_ENTER) {
                // Send the enter as is.
                // enter
                handled |= super.dispatchHoverEvent(event);
                mHoveredSelf = true;
            } else if (action == MotionEvent.ACTION_HOVER_MOVE) {
                // Synthesize an enter from a move.
                eventNoHistory = obtainMotionEventNoHistoryOrSelf(eventNoHistory);
                eventNoHistory.setAction(MotionEvent.ACTION_HOVER_ENTER);
                // enter
                handled |= super.dispatchHoverEvent(eventNoHistory);
                eventNoHistory.setAction(action);
                // move
                handled |= super.dispatchHoverEvent(eventNoHistory);
                mHoveredSelf = true;
            }
        }
    }
    // Recycle the copy of the event that we made.
    if (eventNoHistory != event) {
        eventNoHistory.recycle();
    }
    // Done.
    return handled;
}","{
    final int action = event.getAction();
    // First check whether the view group wants to intercept the hover event.
    final boolean interceptHover = onInterceptHoverEvent(event);
    // restore action in case it was changed
    event.setAction(action);
    MotionEvent eventNoHistory = event;
    boolean handled = false;
    // Send events to the hovered children and build a new list of hover targets until
    // one is found that handles the event.
    HoverTarget firstOldHoverTarget = mFirstHoverTarget;
    mFirstHoverTarget = null;
    if (!interceptHover && action != MotionEvent.ACTION_HOVER_EXIT) {
        final float x = event.getX();
        final float y = event.getY();
        final int childrenCount = mChildrenCount;
        if (childrenCount != 0) {
            final ArrayList<View> preorderedList = buildOrderedChildList();
            final boolean customOrder = preorderedList == null && isChildrenDrawingOrderEnabled();
            final View[] children = mChildren;
            HoverTarget lastHoverTarget = null;
            for (int i = childrenCount - 1; i >= 0; i--) {
                final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);
                final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);
                if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) {
                    continue;
                }
                // Obtain a hover target for this child.  Dequeue it from the
                // old hover target list if the child was previously hovered.
                HoverTarget hoverTarget = firstOldHoverTarget;
                final boolean wasHovered;
                for (HoverTarget predecessor = null; ; ) {
                    if (hoverTarget == null) {
                        hoverTarget = HoverTarget.obtain(child);
                        wasHovered = false;
                        break;
                    }
                    if (hoverTarget.child == child) {
                        if (predecessor != null) {
                            predecessor.next = hoverTarget.next;
                        } else {
                            firstOldHoverTarget = hoverTarget.next;
                        }
                        hoverTarget.next = null;
                        wasHovered = true;
                        break;
                    }
                    predecessor = hoverTarget;
                    hoverTarget = hoverTarget.next;
                }
                // Enqueue the hover target onto the new hover target list.
                if (lastHoverTarget != null) {
                    lastHoverTarget.next = hoverTarget;
                } else {
                    mFirstHoverTarget = hoverTarget;
                }
                lastHoverTarget = hoverTarget;
                // Dispatch the event to the child.
                if (action == MotionEvent.ACTION_HOVER_ENTER) {
                    if (!wasHovered) {
                        // Send the enter as is.
                        handled |= dispatchTransformedGenericPointerEvent(event, // enter
                        child);
                    }
                } else if (action == MotionEvent.ACTION_HOVER_MOVE) {
                    if (!wasHovered) {
                        // Synthesize an enter from a move.
                        eventNoHistory = obtainMotionEventNoHistoryOrSelf(eventNoHistory);
                        eventNoHistory.setAction(MotionEvent.ACTION_HOVER_ENTER);
                        handled |= dispatchTransformedGenericPointerEvent(eventNoHistory, // enter
                        child);
                        eventNoHistory.setAction(action);
                        handled |= dispatchTransformedGenericPointerEvent(eventNoHistory, // move
                        child);
                    } else {
                        // Send the move as is.
                        handled |= dispatchTransformedGenericPointerEvent(event, child);
                    }
                }
                if (handled) {
                    break;
                }
            }
            if (preorderedList != null)
                preorderedList.clear();
        }
    }
    // Send exit events to all previously hovered children that are no longer hovered.
    while (firstOldHoverTarget != null) {
        final View child = firstOldHoverTarget.child;
        // Exit the old hovered child.
        if (action == MotionEvent.ACTION_HOVER_EXIT) {
            // Send the exit as is.
            handled |= dispatchTransformedGenericPointerEvent(event, // exit
            child);
        } else {
            // Ignore the result because hover focus has moved to a different view.
            if (action == MotionEvent.ACTION_HOVER_MOVE) {
                final boolean hoverExitPending = event.isHoverExitPending();
                event.setHoverExitPending(true);
                dispatchTransformedGenericPointerEvent(event, // move
                child);
                event.setHoverExitPending(hoverExitPending);
            }
            eventNoHistory = obtainMotionEventNoHistoryOrSelf(eventNoHistory);
            eventNoHistory.setAction(MotionEvent.ACTION_HOVER_EXIT);
            dispatchTransformedGenericPointerEvent(eventNoHistory, // exit
            child);
            eventNoHistory.setAction(action);
        }
        final HoverTarget nextOldHoverTarget = firstOldHoverTarget.next;
        firstOldHoverTarget.recycle();
        firstOldHoverTarget = nextOldHoverTarget;
    }
    // Send events to the view group itself if no children have handled it and the view group
    // itself is not currently being hover-exited.
    boolean newHoveredSelf = !handled && (action != MotionEvent.ACTION_HOVER_EXIT) && !event.isHoverExitPending();
    if (newHoveredSelf == mHoveredSelf) {
        if (newHoveredSelf) {
            // Send event to the view group as before.
            handled |= super.dispatchHoverEvent(event);
        }
    } else {
        if (mHoveredSelf) {
            // Exit the view group.
            if (action == MotionEvent.ACTION_HOVER_EXIT) {
                // Send the exit as is.
                // exit
                handled |= super.dispatchHoverEvent(event);
            } else {
                // Ignore the result because hover focus is moving to a different view.
                if (action == MotionEvent.ACTION_HOVER_MOVE) {
                    // move
                    super.dispatchHoverEvent(event);
                }
                eventNoHistory = obtainMotionEventNoHistoryOrSelf(eventNoHistory);
                eventNoHistory.setAction(MotionEvent.ACTION_HOVER_EXIT);
                // exit
                super.dispatchHoverEvent(eventNoHistory);
                eventNoHistory.setAction(action);
            }
            mHoveredSelf = false;
        }
        if (newHoveredSelf) {
            // Enter the view group.
            if (action == MotionEvent.ACTION_HOVER_ENTER) {
                // Send the enter as is.
                // enter
                handled |= super.dispatchHoverEvent(event);
                mHoveredSelf = true;
            } else if (action == MotionEvent.ACTION_HOVER_MOVE) {
                // Synthesize an enter from a move.
                eventNoHistory = obtainMotionEventNoHistoryOrSelf(eventNoHistory);
                eventNoHistory.setAction(MotionEvent.ACTION_HOVER_ENTER);
                // enter
                handled |= super.dispatchHoverEvent(eventNoHistory);
                eventNoHistory.setAction(action);
                // move
                handled |= super.dispatchHoverEvent(eventNoHistory);
                mHoveredSelf = true;
            }
        }
    }
    // Recycle the copy of the event that we made.
    if (eventNoHistory != event) {
        eventNoHistory.recycle();
    }
    // Done.
    return handled;
}",1,,,-1,"[@SuppressWarnings({ ""ConstantConditions"" }), @Override]","[@SuppressWarnings({ ""ConstantConditions"" }), @Override]",-1,-1,-1,-1,-1,-1,,,,
136,<android.preference.PreferenceActivity: void onRestoreInstanceState(Bundle)>,25,26,<android.preference.PreferenceActivity: void onRestoreInstanceState(Bundle)>,<android.preference.PreferenceActivity: void onRestoreInstanceState(Bundle)>,0,"{
    if (mPreferenceManager != null) {
        Bundle container = state.getBundle(PREFERENCES_TAG);
        if (container != null) {
            final PreferenceScreen preferenceScreen = getPreferenceScreen();
            if (preferenceScreen != null) {
                preferenceScreen.restoreHierarchyState(container);
                mSavedInstanceState = state;
                return;
            }
        }
    }
    // Only call this if we didn't save the instance state for later.
    // If we did save it, it will be restored when we bind the adapter.
    super.onRestoreInstanceState(state);
}","{
    if (mPreferenceManager != null) {
        Bundle container = state.getBundle(PREFERENCES_TAG);
        if (container != null) {
            final PreferenceScreen preferenceScreen = getPreferenceScreen();
            if (preferenceScreen != null) {
                preferenceScreen.restoreHierarchyState(container);
                mSavedInstanceState = state;
                return;
            }
        }
    }
    // Only call this if we didn't save the instance state for later.
    // If we did save it, it will be restored when we bind the adapter.
    super.onRestoreInstanceState(state);
    if (!mSinglePane) {
        // Multi-pane.
        if (mCurHeader != null) {
            setSelectedHeader(mCurHeader);
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The late version includes additional logic to check `mSinglePane` and a call to `setSelectedHeader(mCurHeader)` outside of the condition which is only entered if `mPreferenceManager != null` is false. This code lies outside of any existing control structures affecting previous behavior, so the code change type is 4.","The new block of code will only execute after the superclass's `onRestoreInstanceState` when `mPreferenceManager` is null, which is functionality in addition to the existing logic and doesn't alter any previous behavior. Therefore, this does not represent a potential Compatibility Issue, and the CI type is 0."
137,<android.hardware.usb.UsbAccessory: int hashCode()>,25,26,<android.hardware.usb.UsbAccessory: int hashCode()>,<android.hardware.usb.UsbAccessory: int hashCode()>,0,"{
    return ((mManufacturer == null ? 0 : mManufacturer.hashCode()) ^ (mModel == null ? 0 : mModel.hashCode()) ^ (mDescription == null ? 0 : mDescription.hashCode()) ^ (mVersion == null ? 0 : mVersion.hashCode()) ^ (mUri == null ? 0 : mUri.hashCode()) ^ (mSerial == null ? 0 : mSerial.hashCode()));
}","{
    return mManufacturer.hashCode() ^ mModel.hashCode() ^ (mDescription == null ? 0 : mDescription.hashCode()) ^ (mVersion == null ? 0 : mVersion.hashCode()) ^ (mUri == null ? 0 : mUri.hashCode()) ^ (mSerial == null ? 0 : mSerial.hashCode());
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"There is a change in the way 'mManufacturer' and 'mModel' are being used to compute the hashCode. In the early version, it checks for null before calling hashCode(), while in the late version it directly calls hashCode(), implying that these fields can no longer be null as per the expectation. This constitutes a code change type 4.","Based on the provided code, there will be no compatibility issues if 'mManufacturer' and 'mModel' are guaranteed to be non-null in the later version as per API contract changes. The removal of null checks suggests those fields are expected not to be null in the usage context of the API in the later version. If those fields are non-null by API constraints, then the behavior of the method does not cause compatibility issues between versions, as it produces the same hashCode for the same set of non-null fields."
139,"<android.app.Activity: void finishActivityFromChild(Activity,int)>",25,26,"<android.app.Activity: void finishActivityFromChild(Activity,int)>","<android.app.Activity: void finishActivityFromChild(Activity,int)>",0,"{
    try {
        ActivityManagerNative.getDefault().finishSubActivity(mToken, child.mEmbeddedID, requestCode);
    } catch (RemoteException e) {
    // Empty
    }
}","{
    try {
        ActivityManager.getService().finishSubActivity(mToken, child.mEmbeddedID, requestCode);
    } catch (RemoteException e) {
    // Empty
    }
}",1,"/**
 * This is called when a child activity of this one calls its
 * finishActivity().
 *
 * @param child The activity making the call.
 * @param requestCode Request code that had been used to start the
 * activity.
 */
","/**
 * This is called when a child activity of this one calls its
 * finishActivity().
 *
 * @param child The activity making the call.
 * @param requestCode Request code that had been used to start the
 * activity.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The change occurs in the method used to retrieve the service: `ActivityManagerNative.getDefault()` has been replaced with `ActivityManager.getService()`. Thus, it belongs to the change type 5 which is a Dependent API changed.","There doesn't appear to be a Compatibility Issue as a result of this change. The signature and exception handling of the method `finishActivityFromChild` have not changed, and it is assumed that the new `ActivityManager.getService()` method is supposed to function identically to how `ActivityManagerNative.getDefault()` did, having the same effect on the execution of `finishSubActivity`. Therefore, it can be concluded that there is No Compatibility Issue, denoted by 0."
140,<android.preference.Preference: boolean persistBoolean(boolean)>,25,26,<android.preference.Preference: boolean persistBoolean(boolean)>,<android.preference.Preference: boolean persistBoolean(boolean)>,0,"{
    if (shouldPersist()) {
        if (value == getPersistedBoolean(!value)) {
            // It's already there, so the same as persisting
            return true;
        }
        SharedPreferences.Editor editor = mPreferenceManager.getEditor();
        editor.putBoolean(mKey, value);
        tryCommit(editor);
        return true;
    }
    return false;
}","{
    if (!shouldPersist()) {
        return false;
    }
    if (value == getPersistedBoolean(!value)) {
        // It's already there, so the same as persisting
        return true;
    }
    PreferenceDataStore dataStore = getPreferenceDataStore();
    if (dataStore != null) {
        dataStore.putBoolean(mKey, value);
    } else {
        SharedPreferences.Editor editor = mPreferenceManager.getEditor();
        editor.putBoolean(mKey, value);
        tryCommit(editor);
    }
    return true;
}",1,"/**
 * Attempts to persist a boolean to the {@link android.content.SharedPreferences}.
 *
 * @param value The value to persist.
 * @return True if this Preference is persistent. (This is not whether the
 * value was persisted, since we may not necessarily commit if there
 * will be a batch commit later.)
 * @see #persistString(String)
 * @see #getPersistedBoolean(boolean)
 */
","/**
 * Attempts to persist a boolean if this Preference is persistent.
 *
 * @param value The value to persist.
 * @return True if this Preference is persistent. (This is not whether the
 * value was persisted, since we may not necessarily commit if there
 * will be a batch commit later.)
 * @see #persistString(String)
 * @see #getPersistedBoolean(boolean)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,5",1,"The flow of the late version has changed by negating the ""shouldPersist()"" check and moving it up to immediately return false if the condition isn't met. Additionally, a new control dependency to check for a non-null ""dataStore"" is added, and the existing code for committing to editor has been moved inside the else block. It now depends on whether there is a ""PreferenceDataStore"" available or not, which is a change in dependent API usage. The use of a new API, ""getPreferenceDataStore"", is introduced as well, which represents a change in implementing dependent API. The code change types are 1,3,5.","Since the check for persistence is negated and moved, and the method now uses a potentially different mechanism for storing preferences (""PreferenceDataStore"" instead of ""SharedPreferences.Editor""), if ""getPreferenceDataStore"" returns a non-null value, the behavior of the method might be changed as it may store the preference in a different way. This can lead to a different return value if the storage mechanism behaves differently. Hence CI type is 1."
142,<android.view.View: boolean hasFocusable()>,25,26,<android.view.View: boolean hasFocusable()>,<android.view.View: boolean hasFocusable()>,0,"{
    if (!isFocusableInTouchMode()) {
        for (ViewParent p = mParent; p instanceof ViewGroup; p = p.getParent()) {
            final ViewGroup g = (ViewGroup) p;
            if (g.shouldBlockFocusForTouchscreen()) {
                return false;
            }
        }
    }
    return (mViewFlags & VISIBILITY_MASK) == VISIBLE && isFocusable();
}","{
    return hasFocusable(!sHasFocusableExcludeAutoFocusable, false);
}",1,"/**
 * Returns true if this view is focusable or if it contains a reachable View
 * for which {@link #hasFocusable()} returns true. A ""reachable hasFocusable()""
 * is a View whose parents do not block descendants focus.
 *
 * Only {@link #VISIBLE} views are considered focusable.
 *
 * @return True if the view is focusable or if the view contains a focusable
 * View, false otherwise.
 *
 * @see ViewGroup#FOCUS_BLOCK_DESCENDANTS
 * @see ViewGroup#getTouchscreenBlocksFocus()
 */
","/**
 * Returns true if this view is focusable or if it contains a reachable View
 * for which {@link #hasFocusable()} returns {@code true}. A ""reachable hasFocusable()""
 * is a view whose parents do not block descendants focus.
 * Only {@link #VISIBLE} views are considered focusable.
 *
 * <p>As of {@link Build.VERSION_CODES#O} views that are determined to be focusable
 * through {@link #FOCUSABLE_AUTO} will also cause this method to return {@code true}.
 * Apps that declare a {@link android.content.pm.ApplicationInfo#targetSdkVersion} of
 * earlier than {@link Build.VERSION_CODES#O} will continue to see this method return
 * {@code false} for views not explicitly marked as focusable.
 * Use {@link #hasExplicitFocusable()} if you require the pre-{@link Build.VERSION_CODES#O}
 * behavior.</p>
 *
 * @return {@code true} if the view is focusable or if the view contains a focusable
 * view, {@code false} otherwise
 *
 * @see ViewGroup#FOCUS_BLOCK_DESCENDANTS
 * @see ViewGroup#getTouchscreenBlocksFocus()
 * @see #hasExplicitFocusable()
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation of the method has been entirely replaced with a call to another method, `hasFocusable(!sHasFocusableExcludeAutoFocusable, false)`, indicating a change in the dependent API, hence the code change type is 5.","The new implementation now delegates the decision to `hasFocusable()` with specific parameters. Without additional context about how `hasFocusable()` behaves and assuming it does not introduce a change in behavior, we cannot determine if a Compatibility Issue exists based solely on the provided implementations. Therefore, based solely on the given implementations, we cannot conclusively detect a Compatibility Issue. However, if `hasFocusable()` is a new development or significantly altered the logic compared to the previous nested conditional logic, it could lead to different return values, thus potentially causing a Compatibility Issue. Given the strict limitations of the instruction and without more information on `hasFocusable()`'s behavior, the conservative answer for potential CI is 0."
143,"<android.transition.ChangeBounds: Animator createAnimator(ViewGroup,TransitionValues,TransitionValues)>",25,26,"<android.transition.ChangeBounds: Animator createAnimator(ViewGroup,TransitionValues,TransitionValues)>","<android.transition.ChangeBounds: Animator createAnimator(ViewGroup,TransitionValues,TransitionValues)>",0,"{
    if (startValues == null || endValues == null) {
        return null;
    }
    Map<String, Object> startParentVals = startValues.values;
    Map<String, Object> endParentVals = endValues.values;
    ViewGroup startParent = (ViewGroup) startParentVals.get(PROPNAME_PARENT);
    ViewGroup endParent = (ViewGroup) endParentVals.get(PROPNAME_PARENT);
    if (startParent == null || endParent == null) {
        return null;
    }
    final View view = endValues.view;
    if (parentMatches(startParent, endParent)) {
        Rect startBounds = (Rect) startValues.values.get(PROPNAME_BOUNDS);
        Rect endBounds = (Rect) endValues.values.get(PROPNAME_BOUNDS);
        final int startLeft = startBounds.left;
        final int endLeft = endBounds.left;
        final int startTop = startBounds.top;
        final int endTop = endBounds.top;
        final int startRight = startBounds.right;
        final int endRight = endBounds.right;
        final int startBottom = startBounds.bottom;
        final int endBottom = endBounds.bottom;
        final int startWidth = startRight - startLeft;
        final int startHeight = startBottom - startTop;
        final int endWidth = endRight - endLeft;
        final int endHeight = endBottom - endTop;
        Rect startClip = (Rect) startValues.values.get(PROPNAME_CLIP);
        Rect endClip = (Rect) endValues.values.get(PROPNAME_CLIP);
        int numChanges = 0;
        if ((startWidth != 0 && startHeight != 0) || (endWidth != 0 && endHeight != 0)) {
            if (startLeft != endLeft || startTop != endTop)
                ++numChanges;
            if (startRight != endRight || startBottom != endBottom)
                ++numChanges;
        }
        if ((startClip != null && !startClip.equals(endClip)) || (startClip == null && endClip != null)) {
            ++numChanges;
        }
        if (numChanges > 0) {
            Animator anim;
            if (!mResizeClip) {
                view.setLeftTopRightBottom(startLeft, startTop, startRight, startBottom);
                if (numChanges == 2) {
                    if (startWidth == endWidth && startHeight == endHeight) {
                        Path topLeftPath = getPathMotion().getPath(startLeft, startTop, endLeft, endTop);
                        anim = ObjectAnimator.ofObject(view, POSITION_PROPERTY, null, topLeftPath);
                    } else {
                        final ViewBounds viewBounds = new ViewBounds(view);
                        Path topLeftPath = getPathMotion().getPath(startLeft, startTop, endLeft, endTop);
                        ObjectAnimator topLeftAnimator = ObjectAnimator.ofObject(viewBounds, TOP_LEFT_PROPERTY, null, topLeftPath);
                        Path bottomRightPath = getPathMotion().getPath(startRight, startBottom, endRight, endBottom);
                        ObjectAnimator bottomRightAnimator = ObjectAnimator.ofObject(viewBounds, BOTTOM_RIGHT_PROPERTY, null, bottomRightPath);
                        AnimatorSet set = new AnimatorSet();
                        set.playTogether(topLeftAnimator, bottomRightAnimator);
                        anim = set;
                        set.addListener(new AnimatorListenerAdapter() {

                            // We need a strong reference to viewBounds until the
                            // animator ends.
                            private ViewBounds mViewBounds = viewBounds;
                        });
                    }
                } else if (startLeft != endLeft || startTop != endTop) {
                    Path topLeftPath = getPathMotion().getPath(startLeft, startTop, endLeft, endTop);
                    anim = ObjectAnimator.ofObject(view, TOP_LEFT_ONLY_PROPERTY, null, topLeftPath);
                } else {
                    Path bottomRight = getPathMotion().getPath(startRight, startBottom, endRight, endBottom);
                    anim = ObjectAnimator.ofObject(view, BOTTOM_RIGHT_ONLY_PROPERTY, null, bottomRight);
                }
            } else {
                int maxWidth = Math.max(startWidth, endWidth);
                int maxHeight = Math.max(startHeight, endHeight);
                view.setLeftTopRightBottom(startLeft, startTop, startLeft + maxWidth, startTop + maxHeight);
                ObjectAnimator positionAnimator = null;
                if (startLeft != endLeft || startTop != endTop) {
                    Path topLeftPath = getPathMotion().getPath(startLeft, startTop, endLeft, endTop);
                    positionAnimator = ObjectAnimator.ofObject(view, POSITION_PROPERTY, null, topLeftPath);
                }
                final Rect finalClip = endClip;
                if (startClip == null) {
                    startClip = new Rect(0, 0, startWidth, startHeight);
                }
                if (endClip == null) {
                    endClip = new Rect(0, 0, endWidth, endHeight);
                }
                ObjectAnimator clipAnimator = null;
                if (!startClip.equals(endClip)) {
                    view.setClipBounds(startClip);
                    clipAnimator = ObjectAnimator.ofObject(view, ""clipBounds"", sRectEvaluator, startClip, endClip);
                    clipAnimator.addListener(new AnimatorListenerAdapter() {

                        private boolean mIsCanceled;

                        @Override
                        public void onAnimationCancel(Animator animation) {
                            mIsCanceled = true;
                        }

                        @Override
                        public void onAnimationEnd(Animator animation) {
                            if (!mIsCanceled) {
                                view.setClipBounds(finalClip);
                                view.setLeftTopRightBottom(endLeft, endTop, endRight, endBottom);
                            }
                        }
                    });
                }
                anim = TransitionUtils.mergeAnimators(positionAnimator, clipAnimator);
            }
            if (view.getParent() instanceof ViewGroup) {
                final ViewGroup parent = (ViewGroup) view.getParent();
                parent.suppressLayout(true);
                TransitionListener transitionListener = new TransitionListenerAdapter() {

                    boolean mCanceled = false;

                    @Override
                    public void onTransitionCancel(Transition transition) {
                        parent.suppressLayout(false);
                        mCanceled = true;
                    }

                    @Override
                    public void onTransitionEnd(Transition transition) {
                        if (!mCanceled) {
                            parent.suppressLayout(false);
                        }
                    }

                    @Override
                    public void onTransitionPause(Transition transition) {
                        parent.suppressLayout(false);
                    }

                    @Override
                    public void onTransitionResume(Transition transition) {
                        parent.suppressLayout(true);
                    }
                };
                addListener(transitionListener);
            }
            return anim;
        }
    } else {
        sceneRoot.getLocationInWindow(tempLocation);
        int startX = (Integer) startValues.values.get(PROPNAME_WINDOW_X) - tempLocation[0];
        int startY = (Integer) startValues.values.get(PROPNAME_WINDOW_Y) - tempLocation[1];
        int endX = (Integer) endValues.values.get(PROPNAME_WINDOW_X) - tempLocation[0];
        int endY = (Integer) endValues.values.get(PROPNAME_WINDOW_Y) - tempLocation[1];
        // TODO: also handle size changes: check bounds and animate size changes
        if (startX != endX || startY != endY) {
            final int width = view.getWidth();
            final int height = view.getHeight();
            Bitmap bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
            Canvas canvas = new Canvas(bitmap);
            view.draw(canvas);
            final BitmapDrawable drawable = new BitmapDrawable(bitmap);
            drawable.setBounds(startX, startY, startX + width, startY + height);
            final float transitionAlpha = view.getTransitionAlpha();
            view.setTransitionAlpha(0);
            sceneRoot.getOverlay().add(drawable);
            Path topLeftPath = getPathMotion().getPath(startX, startY, endX, endY);
            PropertyValuesHolder origin = PropertyValuesHolder.ofObject(DRAWABLE_ORIGIN_PROPERTY, null, topLeftPath);
            ObjectAnimator anim = ObjectAnimator.ofPropertyValuesHolder(drawable, origin);
            anim.addListener(new AnimatorListenerAdapter() {

                @Override
                public void onAnimationEnd(Animator animation) {
                    sceneRoot.getOverlay().remove(drawable);
                    view.setTransitionAlpha(transitionAlpha);
                }
            });
            return anim;
        }
    }
    return null;
}","{
    if (startValues == null || endValues == null) {
        return null;
    }
    Map<String, Object> startParentVals = startValues.values;
    Map<String, Object> endParentVals = endValues.values;
    ViewGroup startParent = (ViewGroup) startParentVals.get(PROPNAME_PARENT);
    ViewGroup endParent = (ViewGroup) endParentVals.get(PROPNAME_PARENT);
    if (startParent == null || endParent == null) {
        return null;
    }
    final View view = endValues.view;
    if (parentMatches(startParent, endParent)) {
        Rect startBounds = (Rect) startValues.values.get(PROPNAME_BOUNDS);
        Rect endBounds = (Rect) endValues.values.get(PROPNAME_BOUNDS);
        final int startLeft = startBounds.left;
        final int endLeft = endBounds.left;
        final int startTop = startBounds.top;
        final int endTop = endBounds.top;
        final int startRight = startBounds.right;
        final int endRight = endBounds.right;
        final int startBottom = startBounds.bottom;
        final int endBottom = endBounds.bottom;
        final int startWidth = startRight - startLeft;
        final int startHeight = startBottom - startTop;
        final int endWidth = endRight - endLeft;
        final int endHeight = endBottom - endTop;
        Rect startClip = (Rect) startValues.values.get(PROPNAME_CLIP);
        Rect endClip = (Rect) endValues.values.get(PROPNAME_CLIP);
        int numChanges = 0;
        if ((startWidth != 0 && startHeight != 0) || (endWidth != 0 && endHeight != 0)) {
            if (startLeft != endLeft || startTop != endTop)
                ++numChanges;
            if (startRight != endRight || startBottom != endBottom)
                ++numChanges;
        }
        if ((startClip != null && !startClip.equals(endClip)) || (startClip == null && endClip != null)) {
            ++numChanges;
        }
        if (numChanges > 0) {
            Animator anim;
            if (!mResizeClip) {
                view.setLeftTopRightBottom(startLeft, startTop, startRight, startBottom);
                if (numChanges == 2) {
                    if (startWidth == endWidth && startHeight == endHeight) {
                        Path topLeftPath = getPathMotion().getPath(startLeft, startTop, endLeft, endTop);
                        anim = ObjectAnimator.ofObject(view, POSITION_PROPERTY, null, topLeftPath);
                    } else {
                        final ViewBounds viewBounds = new ViewBounds(view);
                        Path topLeftPath = getPathMotion().getPath(startLeft, startTop, endLeft, endTop);
                        ObjectAnimator topLeftAnimator = ObjectAnimator.ofObject(viewBounds, TOP_LEFT_PROPERTY, null, topLeftPath);
                        Path bottomRightPath = getPathMotion().getPath(startRight, startBottom, endRight, endBottom);
                        ObjectAnimator bottomRightAnimator = ObjectAnimator.ofObject(viewBounds, BOTTOM_RIGHT_PROPERTY, null, bottomRightPath);
                        AnimatorSet set = new AnimatorSet();
                        set.playTogether(topLeftAnimator, bottomRightAnimator);
                        anim = set;
                        set.addListener(new AnimatorListenerAdapter() {

                            // We need a strong reference to viewBounds until the
                            // animator ends.
                            private ViewBounds mViewBounds = viewBounds;
                        });
                    }
                } else if (startLeft != endLeft || startTop != endTop) {
                    Path topLeftPath = getPathMotion().getPath(startLeft, startTop, endLeft, endTop);
                    anim = ObjectAnimator.ofObject(view, TOP_LEFT_ONLY_PROPERTY, null, topLeftPath);
                } else {
                    Path bottomRight = getPathMotion().getPath(startRight, startBottom, endRight, endBottom);
                    anim = ObjectAnimator.ofObject(view, BOTTOM_RIGHT_ONLY_PROPERTY, null, bottomRight);
                }
            } else {
                int maxWidth = Math.max(startWidth, endWidth);
                int maxHeight = Math.max(startHeight, endHeight);
                view.setLeftTopRightBottom(startLeft, startTop, startLeft + maxWidth, startTop + maxHeight);
                ObjectAnimator positionAnimator = null;
                if (startLeft != endLeft || startTop != endTop) {
                    Path topLeftPath = getPathMotion().getPath(startLeft, startTop, endLeft, endTop);
                    positionAnimator = ObjectAnimator.ofObject(view, POSITION_PROPERTY, null, topLeftPath);
                }
                final Rect finalClip = endClip;
                if (startClip == null) {
                    startClip = new Rect(0, 0, startWidth, startHeight);
                }
                if (endClip == null) {
                    endClip = new Rect(0, 0, endWidth, endHeight);
                }
                ObjectAnimator clipAnimator = null;
                if (!startClip.equals(endClip)) {
                    view.setClipBounds(startClip);
                    clipAnimator = ObjectAnimator.ofObject(view, ""clipBounds"", sRectEvaluator, startClip, endClip);
                    clipAnimator.addListener(new AnimatorListenerAdapter() {

                        private boolean mIsCanceled;

                        @Override
                        public void onAnimationCancel(Animator animation) {
                            mIsCanceled = true;
                        }

                        @Override
                        public void onAnimationEnd(Animator animation) {
                            if (!mIsCanceled) {
                                view.setClipBounds(finalClip);
                                view.setLeftTopRightBottom(endLeft, endTop, endRight, endBottom);
                            }
                        }
                    });
                }
                anim = TransitionUtils.mergeAnimators(positionAnimator, clipAnimator);
            }
            if (view.getParent() instanceof ViewGroup) {
                final ViewGroup parent = (ViewGroup) view.getParent();
                parent.suppressLayout(true);
                TransitionListener transitionListener = new TransitionListenerAdapter() {

                    boolean mCanceled = false;

                    @Override
                    public void onTransitionCancel(Transition transition) {
                        parent.suppressLayout(false);
                        mCanceled = true;
                    }

                    @Override
                    public void onTransitionEnd(Transition transition) {
                        if (!mCanceled) {
                            parent.suppressLayout(false);
                        }
                        transition.removeListener(this);
                    }

                    @Override
                    public void onTransitionPause(Transition transition) {
                        parent.suppressLayout(false);
                    }

                    @Override
                    public void onTransitionResume(Transition transition) {
                        parent.suppressLayout(true);
                    }
                };
                addListener(transitionListener);
            }
            return anim;
        }
    } else {
        sceneRoot.getLocationInWindow(tempLocation);
        int startX = (Integer) startValues.values.get(PROPNAME_WINDOW_X) - tempLocation[0];
        int startY = (Integer) startValues.values.get(PROPNAME_WINDOW_Y) - tempLocation[1];
        int endX = (Integer) endValues.values.get(PROPNAME_WINDOW_X) - tempLocation[0];
        int endY = (Integer) endValues.values.get(PROPNAME_WINDOW_Y) - tempLocation[1];
        // TODO: also handle size changes: check bounds and animate size changes
        if (startX != endX || startY != endY) {
            final int width = view.getWidth();
            final int height = view.getHeight();
            Bitmap bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
            Canvas canvas = new Canvas(bitmap);
            view.draw(canvas);
            final BitmapDrawable drawable = new BitmapDrawable(bitmap);
            drawable.setBounds(startX, startY, startX + width, startY + height);
            final float transitionAlpha = view.getTransitionAlpha();
            view.setTransitionAlpha(0);
            sceneRoot.getOverlay().add(drawable);
            Path topLeftPath = getPathMotion().getPath(startX, startY, endX, endY);
            PropertyValuesHolder origin = PropertyValuesHolder.ofObject(DRAWABLE_ORIGIN_PROPERTY, null, topLeftPath);
            ObjectAnimator anim = ObjectAnimator.ofPropertyValuesHolder(drawable, origin);
            anim.addListener(new AnimatorListenerAdapter() {

                @Override
                public void onAnimationEnd(Animator animation) {
                    sceneRoot.getOverlay().remove(drawable);
                    view.setTransitionAlpha(transitionAlpha);
                }
            });
            return anim;
        }
    }
    return null;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
146,"<android.widget.RemoteViews.ReflectionAction: Action initActionAsync(ViewTree,ViewGroup,OnClickHandler)>",25,26,"<android.widget.RemoteViews.ReflectionAction: Action initActionAsync(ViewTree,ViewGroup,OnClickHandler)>","<android.widget.RemoteViews.ReflectionAction: Action initActionAsync(ViewTree,ViewGroup,OnClickHandler)>",0,"{
    final View view = root.findViewById(viewId);
    if (view == null)
        return ACTION_NOOP;
    Class<?> param = getParameterType();
    if (param == null) {
        throw new ActionException(""bad type: "" + this.type);
    }
    try {
        Method method = getMethod(view, this.methodName, param);
        Method asyncMethod = getAsyncMethod(method);
        if (asyncMethod != null) {
            Runnable endAction = (Runnable) asyncMethod.invoke(view, wrapArg(this.value));
            if (endAction == null) {
                return ACTION_NOOP;
            } else {
                return new RunnableAction(endAction);
            }
        }
    } catch (ActionException e) {
        throw e;
    } catch (Exception ex) {
        throw new ActionException(ex);
    }
    return this;
}","{
    final View view = root.findViewById(viewId);
    if (view == null)
        return ACTION_NOOP;
    Class<?> param = getParameterType();
    if (param == null) {
        throw new ActionException(""bad type: "" + this.type);
    }
    try {
        Method method = getMethod(view, this.methodName, param);
        Method asyncMethod = getAsyncMethod(method);
        if (asyncMethod != null) {
            Runnable endAction = (Runnable) asyncMethod.invoke(view, wrapArg(this.value));
            if (endAction == null) {
                return ACTION_NOOP;
            } else {
                // Special case view stub
                if (endAction instanceof ViewStub.ViewReplaceRunnable) {
                    root.createTree();
                    // Replace child tree
                    root.findViewTreeById(viewId).replaceView(((ViewStub.ViewReplaceRunnable) endAction).view);
                }
                return new RunnableAction(endAction);
            }
        }
    } catch (ActionException e) {
        throw e;
    } catch (Exception ex) {
        throw new ActionException(ex);
    }
    return this;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The late version introduces a new code block to handle a special case involving a `ViewStub.ViewReplaceRunnable`, which affects the control flow. This change does not modify any existing return or exception handling statements, but adds new behavior under a specific condition. Therefore, the change types are 3 (Control dependency change) and 4 (Other statement changed).","There is no Compatibility Issue detected. The additional checks and operations introduced in the late version only special case handling and they do not affect the previously existing return values or the type of exceptions thrown as the changes take place in a new branch of the control flow. The method still returns the same types (`ACTION_NOOP`, `RunnableAction`, or `this`) under the same conditions as before, just with an additional condition to handle a new case. Therefore, there is no change that would lead to a different behavior that would affect existing clients of the API."
147,<android.bluetooth.le.ScanResult: boolean equals(Object)>,25,26,<android.bluetooth.le.ScanResult: boolean equals(Object)>,<android.bluetooth.le.ScanResult: boolean equals(Object)>,0,"{
    if (this == obj) {
        return true;
    }
    if (obj == null || getClass() != obj.getClass()) {
        return false;
    }
    ScanResult other = (ScanResult) obj;
    return Objects.equals(mDevice, other.mDevice) && (mRssi == other.mRssi) && Objects.equals(mScanRecord, other.mScanRecord) && (mTimestampNanos == other.mTimestampNanos);
}","{
    if (this == obj) {
        return true;
    }
    if (obj == null || getClass() != obj.getClass()) {
        return false;
    }
    ScanResult other = (ScanResult) obj;
    return Objects.equals(mDevice, other.mDevice) && (mRssi == other.mRssi) && Objects.equals(mScanRecord, other.mScanRecord) && (mTimestampNanos == other.mTimestampNanos) && mEventType == other.mEventType && mPrimaryPhy == other.mPrimaryPhy && mSecondaryPhy == other.mSecondaryPhy && mAdvertisingSid == other.mAdvertisingSid && mTxPower == other.mTxPower && mPeriodicAdvertisingInterval == other.mPeriodicAdvertisingInterval;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"The return statement has been modified to include additional equality checks (mEventType == other.mEventType && mPrimaryPhy == other.mPrimaryPhy && mSecondaryPhy == other.mSecondaryPhy && mAdvertisingSid == other.mAdvertisingSid && mTxPower == other.mTxPower && mPeriodicAdvertisingInterval == other.mPeriodicAdvertisingInterval), hence the change type is 1.","Since the late version of the equals method includes additional field comparisons, the method could potentially return a different result from the earlier version when comparing two ScanResult objects with differing event types, PHY values, advertising SID, Tx power, or periodic advertising interval. Therefore, the potential Compatibility Issue is due to different return values, and the CI type is 1."
148,"<android.provider.DocumentsContract: boolean removeDocument(ContentResolver,Uri,Uri)>",25,26,"<android.provider.DocumentsContract: boolean removeDocument(ContentResolver,Uri,Uri)>","<android.provider.DocumentsContract: boolean removeDocument(ContentResolver,Uri,Uri)>",0,"{
    final ContentProviderClient client = resolver.acquireUnstableContentProviderClient(documentUri.getAuthority());
    try {
        removeDocument(client, documentUri, parentDocumentUri);
        return true;
    } catch (Exception e) {
        Log.w(TAG, ""Failed to remove document"", e);
        return false;
    } finally {
        ContentProviderClient.releaseQuietly(client);
    }
}","{
    final ContentProviderClient client = resolver.acquireUnstableContentProviderClient(documentUri.getAuthority());
    try {
        removeDocument(client, documentUri, parentDocumentUri);
        return true;
    } catch (Exception e) {
        Log.w(TAG, ""Failed to remove document"", e);
        rethrowIfNecessary(resolver, e);
        return false;
    } finally {
        ContentProviderClient.releaseQuietly(client);
    }
}",1,"/**
 * Removes the given document from a parent directory.
 *
 * <p>In contrast to {@link #deleteDocument} it requires specifying the parent.
 * This method is especially useful if the document can be in multiple parents.
 *
 * @param documentUri document with {@link Document#FLAG_SUPPORTS_REMOVE}
 * @param parentDocumentUri parent document of the document to remove.
 * @return true if the document was removed successfully.
 */
","/**
 * Removes the given document from a parent directory.
 *
 * <p>In contrast to {@link #deleteDocument} it requires specifying the parent.
 * This method is especially useful if the document can be in multiple parents.
 *
 * @param documentUri document with {@link Document#FLAG_SUPPORTS_REMOVE}
 * @param parentDocumentUri parent document of the document to remove.
 * @return true if the document was removed successfully.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"An additional statement (rethrowIfNecessary(resolver, e)) is introduced in the exception handling block, while the rest of the method body remains the same. This change does not modify the return statement but affects the exception handling. Therefore, the code change type is 2 (exception handling statement changed). The process around the try-catch block remains unchanged, so there is not a change of return value from the whole function perspective, however the new added line of code could rethrow an exception and thus affect outward behavior. There’s also a minor change in the exception handling logic, which can be categorized as other statement changed (type 4).","The introduction of the rethrowIfNecessary(resolver, e) method could potentially cause a different exception to be thrown (particularly, a previously handled exception might now be re-thrown), which would represent a change in the externally observable behavior of the API. Consequently, the CI type is 2 (Compatibility Issue caused by potential different exception handlings)."
149,<android.app.admin.DevicePolicyManager: void lockNow()>,25,26,<android.app.admin.DevicePolicyManager: void lockNow()>,<android.app.admin.DevicePolicyManager: void lockNow()>,0,"{
    if (mService != null) {
        try {
            mService.lockNow(mParentInstance);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}","{
    lockNow(0);
}",1,"/**
 * Make the device lock immediately, as if the lock screen timeout has expired at the point of
 * this call.
 * <p>
 * The calling device admin must have requested {@link DeviceAdminInfo#USES_POLICY_FORCE_LOCK}
 * to be able to call this method; if it has not, a security exception will be thrown.
 * <p>
 * This method can be called on the {@link DevicePolicyManager} instance returned by
 * {@link #getParentProfileInstance(ComponentName)} in order to lock the parent profile.
 *
 * @throws SecurityException if the calling application does not own an active administrator
 * that uses {@link DeviceAdminInfo#USES_POLICY_FORCE_LOCK}
 */
","/**
 * Make the device lock immediately, as if the lock screen timeout has expired at the point of
 * this call.
 * <p>
 * The calling device admin must have requested {@link DeviceAdminInfo#USES_POLICY_FORCE_LOCK}
 * to be able to call this method; if it has not, a security exception will be thrown.
 * <p>
 * This method can be called on the {@link DevicePolicyManager} instance returned by
 * {@link #getParentProfileInstance(ComponentName)} in order to lock the parent profile.
 * <p>
 * Equivalent to calling {@link #lockNow(int)} with no flags.
 *
 * @throws SecurityException if the calling application does not own an active administrator
 * that uses {@link DeviceAdminInfo#USES_POLICY_FORCE_LOCK}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The late version of the method redirects to another method with the signature lockNow(int flags), so the body of the method has changed, indicating an ""Other statement changed"". Also, since the implementation is now dependent on a different method signature (lockNow with an integer parameter), this is considered a ""Dependent API changed"". The change types are 4,5.",There is no Compatibility Issue because the behavior of the API as seen by the caller does not change. The method still initiates a lock on the device without returning a value or throwing a new exception that wasn't present in the early version. The locking behavior is presumed to be the same since it is an internal change rather than a change in the API's contract with its callers.
152,"<android.content.res.AssetManager: boolean getThemeValue(long,int,TypedValue,boolean)>",25,26,"<android.content.res.AssetManager: boolean getThemeValue(long,int,TypedValue,boolean)>","<android.content.res.AssetManager: boolean getThemeValue(long,int,TypedValue,boolean)>",0,"{
    final int block = loadThemeAttributeValue(theme, resId, outValue, resolveRefs);
    if (block < 0) {
        return false;
    }
    if (outValue.type == TypedValue.TYPE_STRING) {
        final StringBlock[] blocks = ensureStringBlocks();
        outValue.string = blocks[block].get(outValue.data);
    }
    return true;
}","{
    final int block = loadThemeAttributeValue(theme, resId, outValue, resolveRefs);
    if (block < 0) {
        return false;
    }
    // Convert the changing configurations flags populated by native code.
    outValue.changingConfigurations = ActivityInfo.activityInfoConfigNativeToJava(outValue.changingConfigurations);
    if (outValue.type == TypedValue.TYPE_STRING) {
        final StringBlock[] blocks = ensureStringBlocks();
        outValue.string = blocks[block].get(outValue.data);
    }
    return true;
}",1,"/**
 * Populates {@code outValue} with the data associated with a particular
 * resource identifier for the current configuration. Resolves theme
 * attributes against the specified theme.
 *
 * @param theme the native pointer of the theme
 * @param resId the resource identifier to load
 * @param outValue the typed value in which to put the data
 * @param resolveRefs {@code true} to resolve references, {@code false}
 * to leave them unresolved
 * @return {@code true} if the data was loaded into {@code outValue},
 * {@code false} otherwise
 */
","/**
 * Populates {@code outValue} with the data associated with a particular
 * resource identifier for the current configuration. Resolves theme
 * attributes against the specified theme.
 *
 * @param theme the native pointer of the theme
 * @param resId the resource identifier to load
 * @param outValue the typed value in which to put the data
 * @param resolveRefs {@code true} to resolve references, {@code false}
 * to leave them unresolved
 * @return {@code true} if the data was loaded into {@code outValue},
 * {@code false} otherwise
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,There is an additional statement that converts the changing configurations flags in the late version. The return statements and the exception handling statements remain unchanged. So the code change type is 4.,"The added conversion statement does not affect the return value of the method or introduce new exception handling, hence there is no Compatibility Issue; the method still returns a boolean value and does not alter its exception behavior. Therefore, the CI type is 0."
153,"<android.app.Fragment: Fragment instantiate(Context,String,Bundle)>",25,26,"<android.app.Fragment: Fragment instantiate(Context,String,Bundle)>","<android.app.Fragment: Fragment instantiate(Context,String,Bundle)>",0,"{
    try {
        Class<?> clazz = sClassMap.get(fname);
        if (clazz == null) {
            // Class not found in the cache, see if it's real, and try to add it
            clazz = context.getClassLoader().loadClass(fname);
            if (!Fragment.class.isAssignableFrom(clazz)) {
                throw new InstantiationException(""Trying to instantiate a class "" + fname + "" that is not a Fragment"", new ClassCastException());
            }
            sClassMap.put(fname, clazz);
        }
        Fragment f = (Fragment) clazz.newInstance();
        if (args != null) {
            args.setClassLoader(f.getClass().getClassLoader());
            f.mArguments = args;
        }
        return f;
    } catch (ClassNotFoundException e) {
        throw new InstantiationException(""Unable to instantiate fragment "" + fname + "": make sure class name exists, is public, and has an"" + "" empty constructor that is public"", e);
    } catch (java.lang.InstantiationException e) {
        throw new InstantiationException(""Unable to instantiate fragment "" + fname + "": make sure class name exists, is public, and has an"" + "" empty constructor that is public"", e);
    } catch (IllegalAccessException e) {
        throw new InstantiationException(""Unable to instantiate fragment "" + fname + "": make sure class name exists, is public, and has an"" + "" empty constructor that is public"", e);
    }
}","{
    try {
        Class<?> clazz = sClassMap.get(fname);
        if (clazz == null) {
            // Class not found in the cache, see if it's real, and try to add it
            clazz = context.getClassLoader().loadClass(fname);
            if (!Fragment.class.isAssignableFrom(clazz)) {
                throw new InstantiationException(""Trying to instantiate a class "" + fname + "" that is not a Fragment"", new ClassCastException());
            }
            sClassMap.put(fname, clazz);
        }
        Fragment f = (Fragment) clazz.getConstructor().newInstance();
        if (args != null) {
            args.setClassLoader(f.getClass().getClassLoader());
            f.setArguments(args);
        }
        return f;
    } catch (ClassNotFoundException e) {
        throw new InstantiationException(""Unable to instantiate fragment "" + fname + "": make sure class name exists, is public, and has an"" + "" empty constructor that is public"", e);
    } catch (java.lang.InstantiationException e) {
        throw new InstantiationException(""Unable to instantiate fragment "" + fname + "": make sure class name exists, is public, and has an"" + "" empty constructor that is public"", e);
    } catch (IllegalAccessException e) {
        throw new InstantiationException(""Unable to instantiate fragment "" + fname + "": make sure class name exists, is public, and has an"" + "" empty constructor that is public"", e);
    } catch (NoSuchMethodException e) {
        throw new InstantiationException(""Unable to instantiate fragment "" + fname + "": could not find Fragment constructor"", e);
    } catch (InvocationTargetException e) {
        throw new InstantiationException(""Unable to instantiate fragment "" + fname + "": calling Fragment constructor caused an exception"", e);
    }
}",1,"/**
 * Create a new instance of a Fragment with the given class name.  This is
 * the same as calling its empty constructor.
 *
 * @param context The calling context being used to instantiate the fragment.
 * This is currently just used to get its ClassLoader.
 * @param fname The class name of the fragment to instantiate.
 * @param args Bundle of arguments to supply to the fragment, which it
 * can retrieve with {@link #getArguments()}.  May be null.
 * @return Returns a new fragment instance.
 * @throws InstantiationException If there is a failure in instantiating
 * the given fragment class.  This is a runtime exception; it is not
 * normally expected to happen.
 */
","/**
 * Create a new instance of a Fragment with the given class name.  This is
 * the same as calling its empty constructor.
 *
 * @param context The calling context being used to instantiate the fragment.
 * This is currently just used to get its ClassLoader.
 * @param fname The class name of the fragment to instantiate.
 * @param args Bundle of arguments to supply to the fragment, which it
 * can retrieve with {@link #getArguments()}.  May be null.
 * @return Returns a new fragment instance.
 * @throws InstantiationException If there is a failure in instantiating
 * the given fragment class.  This is a runtime exception; it is not
 * normally expected to happen.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,4,5","1,2","The instantiation method of 'Fragment' class object changed from 'clazz.newInstance()' to 'clazz.getConstructor().newInstance()', introduction of two new catch blocks for 'NoSuchMethodException' and 'InvocationTargetException', and replacement of 'f.mArguments = args' with 'f.setArguments(args)'. This indicates changes in return statement (since instantiation process changed), exception handling statement (since new exceptions are handled), other statements (due to the usage of 'setArguments' method instead of direct assignment), and dependent API changes (because it now uses the 'getConstructor' and 'newInstance' method of 'Class'). Therefore, the code change type is 1,2,4,5.","These changes could lead to a Compatibility Issue due to the potential different return values or types because the instantiation process has changed, which might create instances differently in cases where the constructor is not accessible. Additionally, new exception types are being thrown ('NoSuchMethodException' and 'InvocationTargetException'), which were not thrown before, indicating a change in exception handling. So CI types are 1,2."
154,<android.view.View: Parcelable onSaveInstanceState()>,25,26,<android.view.View: Parcelable onSaveInstanceState()>,<android.view.View: Parcelable onSaveInstanceState()>,0,"{
    mPrivateFlags |= PFLAG_SAVE_STATE_CALLED;
    if (mStartActivityRequestWho != null) {
        BaseSavedState state = new BaseSavedState(AbsSavedState.EMPTY_STATE);
        state.mStartActivityRequestWhoSaved = mStartActivityRequestWho;
        return state;
    }
    return BaseSavedState.EMPTY_STATE;
}","{
    mPrivateFlags |= PFLAG_SAVE_STATE_CALLED;
    if (mStartActivityRequestWho != null || isAutofilled() || mAutofillViewId > LAST_APP_AUTOFILL_ID) {
        BaseSavedState state = new BaseSavedState(AbsSavedState.EMPTY_STATE);
        if (mStartActivityRequestWho != null) {
            state.mSavedData |= BaseSavedState.START_ACTIVITY_REQUESTED_WHO_SAVED;
        }
        if (isAutofilled()) {
            state.mSavedData |= BaseSavedState.IS_AUTOFILLED;
        }
        if (mAutofillViewId > LAST_APP_AUTOFILL_ID) {
            state.mSavedData |= BaseSavedState.AUTOFILL_ID;
        }
        state.mStartActivityRequestWhoSaved = mStartActivityRequestWho;
        state.mIsAutofilled = isAutofilled();
        state.mAutofillViewId = mAutofillViewId;
        return state;
    }
    return BaseSavedState.EMPTY_STATE;
}",1,"/**
 * Hook allowing a view to generate a representation of its internal state
 * that can later be used to create a new instance with that same state.
 * This state should only contain information that is not persistent or can
 * not be reconstructed later. For example, you will never store your
 * current position on screen because that will be computed again when a
 * new instance of the view is placed in its view hierarchy.
 * <p>
 * Some examples of things you may store here: the current cursor position
 * in a text view (but usually not the text itself since that is stored in a
 * content provider or other persistent storage), the currently selected
 * item in a list view.
 *
 * @return Returns a Parcelable object containing the view's current dynamic
 * state, or null if there is nothing interesting to save. The
 * default implementation returns null.
 * @see #onRestoreInstanceState(android.os.Parcelable)
 * @see #saveHierarchyState(android.util.SparseArray)
 * @see #dispatchSaveInstanceState(android.util.SparseArray)
 * @see #setSaveEnabled(boolean)
 */
","/**
 * Hook allowing a view to generate a representation of its internal state
 * that can later be used to create a new instance with that same state.
 * This state should only contain information that is not persistent or can
 * not be reconstructed later. For example, you will never store your
 * current position on screen because that will be computed again when a
 * new instance of the view is placed in its view hierarchy.
 * <p>
 * Some examples of things you may store here: the current cursor position
 * in a text view (but usually not the text itself since that is stored in a
 * content provider or other persistent storage), the currently selected
 * item in a list view.
 *
 * @return Returns a Parcelable object containing the view's current dynamic
 * state, or null if there is nothing interesting to save.
 * @see #onRestoreInstanceState(Parcelable)
 * @see #saveHierarchyState(SparseArray)
 * @see #dispatchSaveInstanceState(SparseArray)
 * @see #setSaveEnabled(boolean)
 */
",-1,[@CallSuper],"[@CallSuper, @Nullable]",-1,-1,-1,-1,-1,-1,"1,3",1,"The condition in the if-statement has been expanded to include additional checks (`isAutofilled()` and `mAutofillViewId > LAST_APP_AUTOFILL_ID`), and new state flags are being set inside that block. This is a control dependency change because of the added conditions, and also a return statement change since new information is being added to the state object that is returned.","This change adds additional conditions that could result in returning a `BaseSavedState` object with different data set on it in cases where `isAutofilled()` is true or `mAutofillViewId > LAST_APP_AUTOFILL_ID`, which were not considered in the earlier version. This results in a potential difference in the returned `Parcelable` state object, hence there's a CI due to potential different return values or types."
155,<android.os.StrictMode.VmPolicy.Builder: Builder detectAll()>,25,26,<android.os.StrictMode.VmPolicy.Builder: Builder detectAll()>,<android.os.StrictMode.VmPolicy.Builder: Builder detectAll()>,0,"{
    int flags = DETECT_VM_ACTIVITY_LEAKS | DETECT_VM_CURSOR_LEAKS | DETECT_VM_CLOSABLE_LEAKS | DETECT_VM_REGISTRATION_LEAKS | DETECT_VM_FILE_URI_EXPOSURE;
    // for apps to mark sockets that should be ignored
    if (SystemProperties.getBoolean(CLEARTEXT_PROPERTY, false)) {
        flags |= DETECT_VM_CLEARTEXT_NETWORK;
    }
    return enable(flags);
}","{
    detectLeakedSqlLiteObjects();
    final int targetSdk = VMRuntime.getRuntime().getTargetSdkVersion();
    if (targetSdk >= Build.VERSION_CODES.HONEYCOMB) {
        detectActivityLeaks();
        detectLeakedClosableObjects();
    }
    if (targetSdk >= Build.VERSION_CODES.JELLY_BEAN) {
        detectLeakedRegistrationObjects();
    }
    if (targetSdk >= Build.VERSION_CODES.JELLY_BEAN_MR2) {
        detectFileUriExposure();
    }
    if (targetSdk >= Build.VERSION_CODES.M) {
        // facility for apps to mark sockets that should be ignored
        if (SystemProperties.getBoolean(CLEARTEXT_PROPERTY, false)) {
            detectCleartextNetwork();
        }
    }
    if (targetSdk >= Build.VERSION_CODES.O) {
        detectContentUriWithoutPermission();
        detectUntaggedSockets();
    }
    return this;
}",1,"/**
 * Detect everything that's potentially suspect.
 *
 * <p>In the Honeycomb release this includes leaks of
 * SQLite cursors, Activities, and other closable objects
 * but will likely expand in future releases.
 */
","/**
 * Detect everything that's potentially suspect.
 *
 * <p>In the Honeycomb release this includes leaks of
 * SQLite cursors, Activities, and other closable objects
 * but will likely expand in future releases.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5","1,2","The new implementation has completely changed, replacing the bitwise flag manipulation with method calls based on the target SDK version, along with different detect* methods being invoked conditionally. There's a control dependency change due to the introduction of `if` statements based on `targetSdk`, and there are new method calls which constitute control dependency changes and potentially dependent API changes. The enable(flags) method has been replaced with a series of detect* method calls and finally returns 'this', which alters the returned value type (previously integer flags, now the Builder object itself).","There's a Compatibility Issue due to the potential to return different types/values (returning this instead of an int with flags set); also, the removed conditional check for CLEARTEXT_PROPERTY can lead to different behavior in exception handling (in the clear text network detection logic), which could cascade into an exception if certain network policies are violated on different versions of the Android SDK."
156,"<android.widget.Editor.TextActionModeCallback: boolean onPrepareActionMode(ActionMode,Menu)>",25,26,"<android.widget.Editor.TextActionModeCallback: boolean onPrepareActionMode(ActionMode,Menu)>","<android.widget.Editor.TextActionModeCallback: boolean onPrepareActionMode(ActionMode,Menu)>",0,"{
    updateSelectAllItem(menu);
    updateReplaceItem(menu);
    Callback customCallback = getCustomCallback();
    if (customCallback != null) {
        return customCallback.onPrepareActionMode(mode, menu);
    }
    return true;
}","{
    updateSelectAllItem(menu);
    updateReplaceItem(menu);
    updateAssistMenuItem(menu);
    Callback customCallback = getCustomCallback();
    if (customCallback != null) {
        return customCallback.onPrepareActionMode(mode, menu);
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"A new method call updateAssistMenuItem(menu) has been introduced which is neither altering the return values nor exception handling but could change internal object states. Therefore, the code change type is 4 (Other statement changed).","The change does not affect the output values or the exception handling of the method, as the return statement and the flow of the method have remained the same. There is no new return statement, nor is there a different variable returned, and no new exceptions thrown or changed exception handling. Therefore, there is no Compatibility Issue."
157,<android.view.accessibility.AccessibilityNodeInfo: String toString()>,25,26,<android.view.accessibility.AccessibilityNodeInfo: String toString()>,<android.view.accessibility.AccessibilityNodeInfo: String toString()>,0,"{
    StringBuilder builder = new StringBuilder();
    builder.append(super.toString());
    if (DEBUG) {
        builder.append(""; sourceNodeId: "" + mSourceNodeId);
        builder.append(""; accessibilityViewId: "" + getAccessibilityViewId(mSourceNodeId));
        builder.append(""; virtualDescendantId: "" + getVirtualDescendantId(mSourceNodeId));
        builder.append(""; mParentNodeId: "" + mParentNodeId);
        builder.append(""; traversalBefore: "").append(mTraversalBefore);
        builder.append(""; traversalAfter: "").append(mTraversalAfter);
        int granularities = mMovementGranularities;
        builder.append(""; MovementGranularities: ["");
        while (granularities != 0) {
            final int granularity = 1 << Integer.numberOfTrailingZeros(granularities);
            granularities &= ~granularity;
            builder.append(getMovementGranularitySymbolicName(granularity));
            if (granularities != 0) {
                builder.append("", "");
            }
        }
        builder.append(""]"");
        builder.append(""; childAccessibilityIds: ["");
        final LongArray childIds = mChildNodeIds;
        if (childIds != null) {
            for (int i = 0, count = childIds.size(); i < count; i++) {
                builder.append(childIds.get(i));
                if (i < count - 1) {
                    builder.append("", "");
                }
            }
        }
        builder.append(""]"");
    }
    builder.append(""; boundsInParent: "" + mBoundsInParent);
    builder.append(""; boundsInScreen: "" + mBoundsInScreen);
    builder.append(""; packageName: "").append(mPackageName);
    builder.append(""; className: "").append(mClassName);
    builder.append(""; text: "").append(mText);
    builder.append(""; error: "").append(mError);
    builder.append(""; maxTextLength: "").append(mMaxTextLength);
    builder.append(""; contentDescription: "").append(mContentDescription);
    builder.append(""; viewIdResName: "").append(mViewIdResourceName);
    builder.append(""; checkable: "").append(isCheckable());
    builder.append(""; checked: "").append(isChecked());
    builder.append(""; focusable: "").append(isFocusable());
    builder.append(""; focused: "").append(isFocused());
    builder.append(""; selected: "").append(isSelected());
    builder.append(""; clickable: "").append(isClickable());
    builder.append(""; longClickable: "").append(isLongClickable());
    builder.append(""; contextClickable: "").append(isContextClickable());
    builder.append(""; enabled: "").append(isEnabled());
    builder.append(""; password: "").append(isPassword());
    builder.append(""; scrollable: "").append(isScrollable());
    builder.append(""; actions: "").append(mActions);
    return builder.toString();
}","{
    StringBuilder builder = new StringBuilder();
    builder.append(super.toString());
    if (DEBUG) {
        builder.append(""; sourceNodeId: "" + mSourceNodeId);
        builder.append(""; accessibilityViewId: "" + getAccessibilityViewId(mSourceNodeId));
        builder.append(""; virtualDescendantId: "" + getVirtualDescendantId(mSourceNodeId));
        builder.append(""; mParentNodeId: "" + mParentNodeId);
        builder.append(""; traversalBefore: "").append(mTraversalBefore);
        builder.append(""; traversalAfter: "").append(mTraversalAfter);
        int granularities = mMovementGranularities;
        builder.append(""; MovementGranularities: ["");
        while (granularities != 0) {
            final int granularity = 1 << Integer.numberOfTrailingZeros(granularities);
            granularities &= ~granularity;
            builder.append(getMovementGranularitySymbolicName(granularity));
            if (granularities != 0) {
                builder.append("", "");
            }
        }
        builder.append(""]"");
        builder.append(""; childAccessibilityIds: ["");
        final LongArray childIds = mChildNodeIds;
        if (childIds != null) {
            for (int i = 0, count = childIds.size(); i < count; i++) {
                builder.append(childIds.get(i));
                if (i < count - 1) {
                    builder.append("", "");
                }
            }
        }
        builder.append(""]"");
    }
    builder.append(""; boundsInParent: "" + mBoundsInParent);
    builder.append(""; boundsInScreen: "" + mBoundsInScreen);
    builder.append(""; packageName: "").append(mPackageName);
    builder.append(""; className: "").append(mClassName);
    builder.append(""; text: "").append(mText);
    builder.append(""; error: "").append(mError);
    builder.append(""; maxTextLength: "").append(mMaxTextLength);
    builder.append(""; contentDescription: "").append(mContentDescription);
    builder.append(""; viewIdResName: "").append(mViewIdResourceName);
    builder.append(""; checkable: "").append(isCheckable());
    builder.append(""; checked: "").append(isChecked());
    builder.append(""; focusable: "").append(isFocusable());
    builder.append(""; focused: "").append(isFocused());
    builder.append(""; selected: "").append(isSelected());
    builder.append(""; clickable: "").append(isClickable());
    builder.append(""; longClickable: "").append(isLongClickable());
    builder.append(""; contextClickable: "").append(isContextClickable());
    builder.append(""; enabled: "").append(isEnabled());
    builder.append(""; password: "").append(isPassword());
    builder.append(""; scrollable: "").append(isScrollable());
    builder.append(""; importantForAccessibility: "").append(isImportantForAccessibility());
    builder.append(""; actions: "").append(mActions);
    return builder.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
158,<android.view.ViewGroup: boolean gatherTransparentRegion(Region)>,25,26,<android.view.ViewGroup: boolean gatherTransparentRegion(Region)>,<android.view.ViewGroup: boolean gatherTransparentRegion(Region)>,0,"{
    // If no transparent regions requested, we are always opaque.
    final boolean meOpaque = (mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) == 0;
    if (meOpaque && region == null) {
        // The caller doesn't care about the region, so stop now.
        return true;
    }
    super.gatherTransparentRegion(region);
    final View[] children = mChildren;
    final int count = mChildrenCount;
    boolean noneOfTheChildrenAreTransparent = true;
    for (int i = 0; i < count; i++) {
        final View child = children[i];
        if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) {
            if (!child.gatherTransparentRegion(region)) {
                noneOfTheChildrenAreTransparent = false;
            }
        }
    }
    return meOpaque || noneOfTheChildrenAreTransparent;
}","{
    // If no transparent regions requested, we are always opaque.
    final boolean meOpaque = (mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) == 0;
    if (meOpaque && region == null) {
        // The caller doesn't care about the region, so stop now.
        return true;
    }
    super.gatherTransparentRegion(region);
    // Instead of naively traversing the view tree, we have to traverse according to the Z
    // order here. We need to go with the same order as dispatchDraw().
    // One example is that after surfaceView punch a hole, we will still allow other views drawn
    // on top of that hole. In this case, those other views should be able to cut the
    // transparent region into smaller area.
    final int childrenCount = mChildrenCount;
    boolean noneOfTheChildrenAreTransparent = true;
    if (childrenCount > 0) {
        final ArrayList<View> preorderedList = buildOrderedChildList();
        final boolean customOrder = preorderedList == null && isChildrenDrawingOrderEnabled();
        final View[] children = mChildren;
        for (int i = 0; i < childrenCount; i++) {
            final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);
            final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);
            if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) {
                if (!child.gatherTransparentRegion(region)) {
                    noneOfTheChildrenAreTransparent = false;
                }
            }
        }
        if (preorderedList != null)
            preorderedList.clear();
    }
    return meOpaque || noneOfTheChildrenAreTransparent;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4,5",1,"The iteration over children to gather transparent regions has been modified to respect the Z-order rather than the naive traversal order. This includes calling `buildOrderedChildList()`, `isChildrenDrawingOrderEnabled()`, `getAndVerifyPreorderedIndex()`, and `getAndVerifyPreorderedView()`. New control structures and statements have been added, as well as dependent API changes due to new method calls, accounting for code change types 3, 4, 5.","The result of `gatherTransparentRegion` could now potentially return different values due to changes in the way the transparent region is computed (taking into account view hierarchy Z order which wasn't considered previously). This can change the boolean result of the method when there is a custom ordering of the view hierarchy. As a result, the CI type is 1."
159,<android.view.accessibility.AccessibilityManager: boolean removeAccessibilityStateChangeListener(AccessibilityStateChangeListener)>,25,26,<android.view.accessibility.AccessibilityManager: boolean removeAccessibilityStateChangeListener(AccessibilityStateChangeListener)>,<android.view.accessibility.AccessibilityManager: boolean removeAccessibilityStateChangeListener(AccessibilityStateChangeListener)>,0,"{
    // Final CopyOnWriteArrayList - no lock needed.
    return mAccessibilityStateChangeListeners.remove(listener);
}","{
    synchronized (mLock) {
        int index = mAccessibilityStateChangeListeners.indexOfKey(listener);
        mAccessibilityStateChangeListeners.remove(listener);
        return (index >= 0);
    }
}",1,"/**
 * Unregisters an {@link AccessibilityStateChangeListener}.
 *
 * @param listener The listener.
 * @return True if successfully unregistered.
 */
","/**
 * Unregisters an {@link AccessibilityStateChangeListener}.
 *
 * @param listener The listener.
 * @return True if the listener was previously registered.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",0,"The late version of the code introduces both a synchronization mechanism (synchronized block with mLock) and a different approach to handle the removal (checks index before removal), which alters the underlying implementation logic. Hence, the change types are 1, as there's a new return statement involving index verification, and 3, due to the introduction of the synchronized block and new logic for removal with index checking.","Despite the changes, there is no Compatibility Issue since the behavior of returning 'true' if the listener was registered and 'false' if otherwise is maintained before and after the change. The check against 'index >= 0' is essentially serving the same purpose as directly attempting removal from the CopyOnWriteArrayList, and the synchronized block doesn't affect the API's outcome, just ensures thread safety around the process."
160,<android.accessibilityservice.AccessibilityServiceInfo: String flagToString(int)>,25,26,<android.accessibilityservice.AccessibilityServiceInfo: String flagToString(int)>,<android.accessibilityservice.AccessibilityServiceInfo: String flagToString(int)>,0,"{
    switch(flag) {
        case DEFAULT:
            return ""DEFAULT"";
        case FLAG_INCLUDE_NOT_IMPORTANT_VIEWS:
            return ""FLAG_INCLUDE_NOT_IMPORTANT_VIEWS"";
        case FLAG_REQUEST_TOUCH_EXPLORATION_MODE:
            return ""FLAG_REQUEST_TOUCH_EXPLORATION_MODE"";
        case FLAG_REQUEST_ENHANCED_WEB_ACCESSIBILITY:
            return ""FLAG_REQUEST_ENHANCED_WEB_ACCESSIBILITY"";
        case FLAG_REPORT_VIEW_IDS:
            return ""FLAG_REPORT_VIEW_IDS"";
        case FLAG_REQUEST_FILTER_KEY_EVENTS:
            return ""FLAG_REQUEST_FILTER_KEY_EVENTS"";
        case FLAG_RETRIEVE_INTERACTIVE_WINDOWS:
            return ""FLAG_RETRIEVE_INTERACTIVE_WINDOWS"";
        default:
            return null;
    }
}","{
    switch(flag) {
        case DEFAULT:
            return ""DEFAULT"";
        case FLAG_INCLUDE_NOT_IMPORTANT_VIEWS:
            return ""FLAG_INCLUDE_NOT_IMPORTANT_VIEWS"";
        case FLAG_REQUEST_TOUCH_EXPLORATION_MODE:
            return ""FLAG_REQUEST_TOUCH_EXPLORATION_MODE"";
        case FLAG_REQUEST_ENHANCED_WEB_ACCESSIBILITY:
            return ""FLAG_REQUEST_ENHANCED_WEB_ACCESSIBILITY"";
        case FLAG_REPORT_VIEW_IDS:
            return ""FLAG_REPORT_VIEW_IDS"";
        case FLAG_REQUEST_FILTER_KEY_EVENTS:
            return ""FLAG_REQUEST_FILTER_KEY_EVENTS"";
        case FLAG_RETRIEVE_INTERACTIVE_WINDOWS:
            return ""FLAG_RETRIEVE_INTERACTIVE_WINDOWS"";
        case FLAG_ENABLE_ACCESSIBILITY_VOLUME:
            return ""FLAG_ENABLE_ACCESSIBILITY_VOLUME"";
        case FLAG_REQUEST_ACCESSIBILITY_BUTTON:
            return ""FLAG_REQUEST_ACCESSIBILITY_BUTTON"";
        case FLAG_REQUEST_FINGERPRINT_GESTURES:
            return ""FLAG_REQUEST_FINGERPRINT_GESTURES"";
        default:
            return null;
    }
}",1,"/**
 * Returns the string representation of a flag. For example,
 * {@link #DEFAULT} is represented by the string DEFAULT.
 *
 * @param flag The flag.
 * @return The string representation.
 */
","/**
 * Returns the string representation of a flag. For example,
 * {@link #DEFAULT} is represented by the string DEFAULT.
 *
 * @param flag The flag.
 * @return The string representation.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"New cases have been added to the switch statement for handling additional flags, so the code change type is 3 because the control dependency has changed by adding new cases in the switch structure.","However, this does not constitute a Compatibility Issue, as the new cases in the switch statement are for additional flag constants, and existing behavior for previous constants has not been altered. The default case still returns null for any undefined flag values, so any flag values that were understood in version 25 will behave exactly the same way in version 26. No change in return values or exception handling has been introduced for any previously existing flag values; hence the compatibility remains intact. The API will return the same results for flag values available in the early version. Therefore, there is no Compatibility Issue."
161,"<android.bluetooth.BluetoothAdapter: boolean getProfileProxy(Context,ServiceListener,int)>",25,26,"<android.bluetooth.BluetoothAdapter: boolean getProfileProxy(Context,ServiceListener,int)>","<android.bluetooth.BluetoothAdapter: boolean getProfileProxy(Context,ServiceListener,int)>",0,"{
    if (context == null || listener == null)
        return false;
    if (profile == BluetoothProfile.HEADSET) {
        BluetoothHeadset headset = new BluetoothHeadset(context, listener);
        return true;
    } else if (profile == BluetoothProfile.A2DP) {
        BluetoothA2dp a2dp = new BluetoothA2dp(context, listener);
        return true;
    } else if (profile == BluetoothProfile.A2DP_SINK) {
        BluetoothA2dpSink a2dpSink = new BluetoothA2dpSink(context, listener);
        return true;
    } else if (profile == BluetoothProfile.AVRCP_CONTROLLER) {
        BluetoothAvrcpController avrcp = new BluetoothAvrcpController(context, listener);
        return true;
    } else if (profile == BluetoothProfile.INPUT_DEVICE) {
        BluetoothInputDevice iDev = new BluetoothInputDevice(context, listener);
        return true;
    } else if (profile == BluetoothProfile.PAN) {
        BluetoothPan pan = new BluetoothPan(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEALTH) {
        BluetoothHealth health = new BluetoothHealth(context, listener);
        return true;
    } else if (profile == BluetoothProfile.MAP) {
        BluetoothMap map = new BluetoothMap(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEADSET_CLIENT) {
        BluetoothHeadsetClient headsetClient = new BluetoothHeadsetClient(context, listener);
        return true;
    } else if (profile == BluetoothProfile.SAP) {
        BluetoothSap sap = new BluetoothSap(context, listener);
        return true;
    } else if (profile == BluetoothProfile.PBAP_CLIENT) {
        BluetoothPbapClient pbapClient = new BluetoothPbapClient(context, listener);
        return true;
    } else {
        return false;
    }
}","{
    if (context == null || listener == null)
        return false;
    if (profile == BluetoothProfile.HEADSET) {
        BluetoothHeadset headset = new BluetoothHeadset(context, listener);
        return true;
    } else if (profile == BluetoothProfile.A2DP) {
        BluetoothA2dp a2dp = new BluetoothA2dp(context, listener);
        return true;
    } else if (profile == BluetoothProfile.A2DP_SINK) {
        BluetoothA2dpSink a2dpSink = new BluetoothA2dpSink(context, listener);
        return true;
    } else if (profile == BluetoothProfile.AVRCP_CONTROLLER) {
        BluetoothAvrcpController avrcp = new BluetoothAvrcpController(context, listener);
        return true;
    } else if (profile == BluetoothProfile.INPUT_DEVICE) {
        BluetoothInputDevice iDev = new BluetoothInputDevice(context, listener);
        return true;
    } else if (profile == BluetoothProfile.PAN) {
        BluetoothPan pan = new BluetoothPan(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEALTH) {
        BluetoothHealth health = new BluetoothHealth(context, listener);
        return true;
    } else if (profile == BluetoothProfile.MAP) {
        BluetoothMap map = new BluetoothMap(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEADSET_CLIENT) {
        BluetoothHeadsetClient headsetClient = new BluetoothHeadsetClient(context, listener);
        return true;
    } else if (profile == BluetoothProfile.SAP) {
        BluetoothSap sap = new BluetoothSap(context, listener);
        return true;
    } else if (profile == BluetoothProfile.PBAP_CLIENT) {
        BluetoothPbapClient pbapClient = new BluetoothPbapClient(context, listener);
        return true;
    } else if (profile == BluetoothProfile.MAP_CLIENT) {
        BluetoothMapClient mapClient = new BluetoothMapClient(context, listener);
        return true;
    } else if (profile == BluetoothProfile.INPUT_HOST) {
        BluetoothInputHost iHost = new BluetoothInputHost(context, listener);
        return true;
    } else {
        return false;
    }
}",1,"/**
 * Get the profile proxy object associated with the profile.
 *
 * <p>Profile can be one of {@link BluetoothProfile#HEALTH}, {@link BluetoothProfile#HEADSET},
 * {@link BluetoothProfile#A2DP}, {@link BluetoothProfile#GATT}, or
 * {@link BluetoothProfile#GATT_SERVER}. Clients must implement
 * {@link BluetoothProfile.ServiceListener} to get notified of
 * the connection status and to get the proxy object.
 *
 * @param context Context of the application
 * @param listener The service Listener for connection callbacks.
 * @param profile The Bluetooth profile; either {@link BluetoothProfile#HEALTH},
 * {@link BluetoothProfile#HEADSET}, {@link BluetoothProfile#A2DP}.
 * {@link BluetoothProfile#GATT} or {@link BluetoothProfile#GATT_SERVER}.
 * @return true on success, false on error
 */
","/**
 * Get the profile proxy object associated with the profile.
 *
 * <p>Profile can be one of {@link BluetoothProfile#HEALTH}, {@link BluetoothProfile#HEADSET},
 * {@link BluetoothProfile#A2DP}, {@link BluetoothProfile#GATT}, or
 * {@link BluetoothProfile#GATT_SERVER}. Clients must implement
 * {@link BluetoothProfile.ServiceListener} to get notified of
 * the connection status and to get the proxy object.
 *
 * @param context Context of the application
 * @param listener The service Listener for connection callbacks.
 * @param profile The Bluetooth profile; either {@link BluetoothProfile#HEALTH},
 * {@link BluetoothProfile#HEADSET}, {@link BluetoothProfile#A2DP}.
 * {@link BluetoothProfile#GATT} or {@link BluetoothProfile#GATT_SERVER}.
 * @return true on success, false on error
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",1,"There are additional 'else if' control branches introduced for the BluetoothProfile.MAP_CLIENT and BluetoothProfile.INPUT_HOST profiles. This qualifies as a control dependency change (3) and other statement change (4) because new profiles are now being handled. Moreover, since these new profiles correspond to new dependent APIs, the 'BluetoothMapClient(context, listener)' and 'BluetoothInputHost(context, listener)' constructor calls are examples of dependent API changes (5).","Because there are new control branches which can result in returning 'true' for additional profile types that were not previously handled, the behavior of the API may change in the late version—profiles that used to result in 'false' may now result in 'true'. This is a potential different return value change, so the CI type is 1."
162,<android.bluetooth.le.ScanResult: String toString()>,25,26,<android.bluetooth.le.ScanResult: String toString()>,<android.bluetooth.le.ScanResult: String toString()>,0,"{
    return ""ScanResult{"" + ""mDevice="" + mDevice + "", mScanRecord="" + Objects.toString(mScanRecord) + "", mRssi="" + mRssi + "", mTimestampNanos="" + mTimestampNanos + '}';
}","{
    return ""ScanResult{"" + ""device="" + mDevice + "", scanRecord="" + Objects.toString(mScanRecord) + "", rssi="" + mRssi + "", timestampNanos="" + mTimestampNanos + "", eventType="" + mEventType + "", primaryPhy="" + mPrimaryPhy + "", secondaryPhy="" + mSecondaryPhy + "", advertisingSid="" + mAdvertisingSid + "", txPower="" + mTxPower + "", periodicAdvertisingInterval="" + mPeriodicAdvertisingInterval + '}';
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The implementation of `toString()` has been changed to add additional information about the Bluetooth LE scan result; new fields like eventType, primaryPhy, secondaryPhy, advertisingSid, txPower, and periodicAdvertisingInterval have been appended to the toString() return value. This constitutes both a return statement change (1) and an other statement change (4).","The API will return a different value due to the added concatenate operations in the return statement. These changes affect the output of the method, which constitutes a potential different return value, thus the CI type is 1."
163,<android.app.Fragment: void performDetach()>,25,26,<android.app.Fragment: void performDetach()>,<android.app.Fragment: void performDetach()>,0,"{
    mCalled = false;
    onDetach();
    if (!mCalled) {
        throw new SuperNotCalledException(""Fragment "" + this + "" did not call through to super.onDetach()"");
    }
    // our child FragmentManager instance state will have already been saved.
    if (mChildFragmentManager != null) {
        if (!mRetaining) {
            throw new IllegalStateException(""Child FragmentManager of "" + this + "" was not "" + "" destroyed and this fragment is not retaining instance"");
        }
        mChildFragmentManager.dispatchDestroy();
        mChildFragmentManager = null;
    }
}","{
    mCalled = false;
    onDetach();
    mLayoutInflater = null;
    if (!mCalled) {
        throw new SuperNotCalledException(""Fragment "" + this + "" did not call through to super.onDetach()"");
    }
    // our child FragmentManager instance state will have already been saved.
    if (mChildFragmentManager != null) {
        if (!mRetaining) {
            throw new IllegalStateException(""Child FragmentManager of "" + this + "" was not "" + "" destroyed and this fragment is not retaining instance"");
        }
        mChildFragmentManager.dispatchDestroy();
        mChildFragmentManager = null;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"A new statement `mLayoutInflater = null;` has been introduced in the late version, which is not related to return statements, exception handling statements, control dependency changes, or dependent APIs. Therefore, the code change type is 4.","The added line of code does not affect the return value or the exception handling of the method. It is an assignment to a member variable which is nulling out a resource presumably as part of the detachment process. Therefore, there is no Compatibility Issue, so the CI type is 0."
164,<android.preference.PreferenceActivity: boolean isMultiPane()>,25,26,<android.preference.PreferenceActivity: boolean isMultiPane()>,<android.preference.PreferenceActivity: boolean isMultiPane()>,0,"{
    return hasHeaders() && mPrefsContainer.getVisibility() == View.VISIBLE;
}","{
    return !mSinglePane;
}",1,"/**
 * Returns true if this activity is showing multiple panes -- the headers
 * and a preference fragment.
 */
","/**
 * Returns true if this activity is showing multiple panes -- the headers
 * and a preference fragment.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement logic has been completely altered. In the early version, the return is based on conditions: hasHeaders() && mPrefsContainer.getVisibility() == View.VISIBLE. In the late version, it was simplified to return the boolean value of !mSinglePane. This change in the return statement logic signifies a code change type of 1.","Since the return statement now depends on a different boolean variable, the method could potentially return different values when called under identical circumstances, creating a change in behavior. This variation leads to a CI type of 1."
165,"<android.app.Instrumentation.ActivityMonitor: boolean match(Context,Activity,Intent)>",25,26,"<android.app.Instrumentation.ActivityMonitor: boolean match(Context,Activity,Intent)>","<android.app.Instrumentation.ActivityMonitor: boolean match(Context,Activity,Intent)>",0,"{
    synchronized (this) {
        if (mWhich != null && mWhich.match(who.getContentResolver(), intent, true, ""Instrumentation"") < 0) {
            return false;
        }
        if (mClass != null) {
            String cls = null;
            if (activity != null) {
                cls = activity.getClass().getName();
            } else if (intent.getComponent() != null) {
                cls = intent.getComponent().getClassName();
            }
            if (cls == null || !mClass.equals(cls)) {
                return false;
            }
        }
        if (activity != null) {
            mLastActivity = activity;
            notifyAll();
        }
        return true;
    }
}","{
    if (mIgnoreMatchingSpecificIntents) {
        return false;
    }
    synchronized (this) {
        if (mWhich != null && mWhich.match(who.getContentResolver(), intent, true, ""Instrumentation"") < 0) {
            return false;
        }
        if (mClass != null) {
            String cls = null;
            if (activity != null) {
                cls = activity.getClass().getName();
            } else if (intent.getComponent() != null) {
                cls = intent.getComponent().getClassName();
            }
            if (cls == null || !mClass.equals(cls)) {
                return false;
            }
        }
        if (activity != null) {
            mLastActivity = activity;
            notifyAll();
        }
        return true;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,1,"The added control dependency, 'if (mIgnoreMatchingSpecificIntents)', alters the flow of execution before the synchronized block by introducing a condition that can lead to an early return of 'false'. This is a control dependency change of type 3.","Due to the added 'if' statement, the method has the potential to return a different value ('false') before entering the synchronized block when 'mIgnoreMatchingSpecificIntents' is true. This may lead to a Compatibility Issue of type 1, caused by the potential for different return values."
168,<android.app.Activity: boolean isLocalVoiceInteractionSupported()>,25,26,<android.app.Activity: boolean isLocalVoiceInteractionSupported()>,<android.app.Activity: boolean isLocalVoiceInteractionSupported()>,0,"{
    try {
        return ActivityManagerNative.getDefault().supportsLocalVoiceInteraction();
    } catch (RemoteException re) {
    }
    return false;
}","{
    try {
        return ActivityManager.getService().supportsLocalVoiceInteraction();
    } catch (RemoteException re) {
    }
    return false;
}",1,"/**
 * Queries whether the currently enabled voice interaction service supports returning
 * a voice interactor for use by the activity. This is valid only for the duration of the
 * activity.
 *
 * @return whether the current voice interaction service supports local voice interaction
 */
","/**
 * Queries whether the currently enabled voice interaction service supports returning
 * a voice interactor for use by the activity. This is valid only for the duration of the
 * activity.
 *
 * @return whether the current voice interaction service supports local voice interaction
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method used to obtain a service instance changed from `ActivityManagerNative.getDefault()` to `ActivityManager.getService()`, although there were structural changes in how the service is obtained, the general flow and exception handling of the method remain the same. Additionally, the dependent API `supportsLocalVoiceInteraction()` call target has not changed, implying that the method signature for the dependent API remains the same. Therefore, the code change is classified as 4 for the method invocation change and 5 for the dependent API change.","There is no Compatibility Issue because the change does not affect the return value or exception handling behavior of the method itself. The ultimate fallback return value remains `false` in both versions upon catching a RemoteException, and the same exception type is caught. Thus, this change does not introduce any new behavior that would affect compatibility."
171,<android.preference.PreferenceManager: SharedPreferences getSharedPreferences()>,25,26,<android.preference.PreferenceManager: SharedPreferences getSharedPreferences()>,<android.preference.PreferenceManager: SharedPreferences getSharedPreferences()>,0,"{
    if (mSharedPreferences == null) {
        final Context storageContext;
        switch(mStorage) {
            case STORAGE_DEVICE_PROTECTED:
                storageContext = mContext.createDeviceProtectedStorageContext();
                break;
            case STORAGE_CREDENTIAL_PROTECTED:
                storageContext = mContext.createCredentialProtectedStorageContext();
                break;
            default:
                storageContext = mContext;
                break;
        }
        mSharedPreferences = storageContext.getSharedPreferences(mSharedPreferencesName, mSharedPreferencesMode);
    }
    return mSharedPreferences;
}","{
    if (mPreferenceDataStore != null) {
        return null;
    }
    if (mSharedPreferences == null) {
        final Context storageContext;
        switch(mStorage) {
            case STORAGE_DEVICE_PROTECTED:
                storageContext = mContext.createDeviceProtectedStorageContext();
                break;
            case STORAGE_CREDENTIAL_PROTECTED:
                storageContext = mContext.createCredentialProtectedStorageContext();
                break;
            default:
                storageContext = mContext;
                break;
        }
        mSharedPreferences = storageContext.getSharedPreferences(mSharedPreferencesName, mSharedPreferencesMode);
    }
    return mSharedPreferences;
}",1,"/**
 * Gets a SharedPreferences instance that preferences managed by this will
 * use.
 *
 * @return A SharedPreferences instance pointing to the file that contains
 * the values of preferences that are managed by this.
 */
","/**
 * Gets a {@link SharedPreferences} instance that preferences managed by this will use.
 *
 * @return a {@link SharedPreferences} instance pointing to the file that contains the values of
 * preferences that are managed by this PreferenceManager. If a
 * {@link PreferenceDataStore} has been set, this method returns {@code null}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The control dependency has changed with the addition of a new if statement that checks `if (mPreferenceDataStore != null)`, followed by a return null. Also, a return statement has been introduced at the beginning of the method, so the change type is 1,3.","The introduction of the new if statement and return null at the start of the method will cause the method to potentially return a different value than before when `mPreferenceDataStore` is not null. The value returned by the method has changed from the earlier version to potentially return null instead of an instance of SharedPreferences, leading to different behavior. Therefore, the CI type is 1."
174,<android.hardware.display.DisplayManagerInternal.DisplayPowerRequest: String policyToString(int)>,25,26,<android.hardware.display.DisplayManagerInternal.DisplayPowerRequest: String policyToString(int)>,<android.hardware.display.DisplayManagerInternal.DisplayPowerRequest: String policyToString(int)>,0,"{
    switch(policy) {
        case POLICY_OFF:
            return ""OFF"";
        case POLICY_DOZE:
            return ""DOZE"";
        case POLICY_DIM:
            return ""DIM"";
        case POLICY_BRIGHT:
            return ""BRIGHT"";
        default:
            return Integer.toString(policy);
    }
}","{
    switch(policy) {
        case POLICY_OFF:
            return ""OFF"";
        case POLICY_DOZE:
            return ""DOZE"";
        case POLICY_DIM:
            return ""DIM"";
        case POLICY_BRIGHT:
            return ""BRIGHT"";
        case POLICY_VR:
            return ""VR"";
        default:
            return Integer.toString(policy);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"A new case (POLICY_VR) has been added to the switch statement, therefore this is a change in the control dependency (type 3). Since no return statement's existing logic is changed or deleted, and a default case is present in both versions (no new branch without a corresponding return statement), overall logic for existing cases is maintained, so it's also an other statement change (type 4).","There is no compatibility issue (CI) because the added case provides handling for a new constant that did not have a specific string associated with it in the early version. Since the default case is preserved, all the policies handled in the early version continue behaving the same in the late version. The change is backward-compatible for all values that the method could take before the introduction of POLICY_VR (CI type is 0)."
175,"<android.hardware.camera2.impl.CameraDeviceImpl.CameraDeviceCallbacks: void onCaptureStarted(CaptureResultExtras,long)>",25,26,"<android.hardware.camera2.impl.CameraDeviceImpl.CameraDeviceCallbacks: void onCaptureStarted(CaptureResultExtras,long)>","<android.hardware.camera2.impl.CameraDeviceImpl.CameraDeviceCallbacks: void onCaptureStarted(CaptureResultExtras,long)>",0,"{
    int requestId = resultExtras.getRequestId();
    final long frameNumber = resultExtras.getFrameNumber();
    if (DEBUG) {
        Log.d(TAG, ""Capture started for id "" + requestId + "" frame number "" + frameNumber);
    }
    final CaptureCallbackHolder holder;
    synchronized (mInterfaceLock) {
        // Camera already closed
        if (mRemoteDevice == null)
            return;
        // Get the callback for this frame ID, if there is one
        holder = CameraDeviceImpl.this.mCaptureCallbackMap.get(requestId);
        if (holder == null) {
            return;
        }
        if (isClosed())
            return;
        // Dispatch capture start notice
        holder.getHandler().post(new Runnable() {

            @Override
            public void run() {
                if (!CameraDeviceImpl.this.isClosed()) {
                    holder.getCallback().onCaptureStarted(CameraDeviceImpl.this, holder.getRequest(resultExtras.getSubsequenceId()), timestamp, frameNumber);
                }
            }
        });
    }
}","{
    int requestId = resultExtras.getRequestId();
    final long frameNumber = resultExtras.getFrameNumber();
    if (DEBUG) {
        Log.d(TAG, ""Capture started for id "" + requestId + "" frame number "" + frameNumber);
    }
    final CaptureCallbackHolder holder;
    synchronized (mInterfaceLock) {
        // Camera already closed
        if (mRemoteDevice == null)
            return;
        // Get the callback for this frame ID, if there is one
        holder = CameraDeviceImpl.this.mCaptureCallbackMap.get(requestId);
        if (holder == null) {
            return;
        }
        if (isClosed())
            return;
        // Dispatch capture start notice
        holder.getHandler().post(new Runnable() {

            @Override
            public void run() {
                if (!CameraDeviceImpl.this.isClosed()) {
                    final int subsequenceId = resultExtras.getSubsequenceId();
                    final CaptureRequest request = holder.getRequest(subsequenceId);
                    if (holder.hasBatchedOutputs()) {
                        // Send derived onCaptureStarted for requests within the batch
                        final Range<Integer> fpsRange = request.get(CaptureRequest.CONTROL_AE_TARGET_FPS_RANGE);
                        for (int i = 0; i < holder.getRequestCount(); i++) {
                            holder.getCallback().onCaptureStarted(CameraDeviceImpl.this, holder.getRequest(i), timestamp - (subsequenceId - i) * NANO_PER_SECOND / fpsRange.getUpper(), frameNumber - (subsequenceId - i));
                        }
                    } else {
                        holder.getCallback().onCaptureStarted(CameraDeviceImpl.this, holder.getRequest(resultExtras.getSubsequenceId()), timestamp, frameNumber);
                    }
                }
            }
        });
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"The late version of the method implements an additional condition with a 'if' control structure checking if the holder has batched outputs, leading to additional logic to handle the 'onCaptureStarted' callbacks. Therefore, the change type is 3 for control dependency change and 4 for other statement change. ","Due to the new if condition and corresponding logic that iterate over holder.getRequestCount() and call holder.getCallback().onCaptureStarted() with modified arguments, the late version of the method can potentially invoke the callback with different parameters when batched outputs are present. This constitutes a change in the behavior of the API, which may produce different return values even though this is a void method, the resultant side effects constitute return value differences. Therefore, the CI is type 1."
178,<android.widget.AdapterView: void selectionChanged()>,25,26,<android.widget.AdapterView: void selectionChanged()>,<android.widget.AdapterView: void selectionChanged()>,0,"{
    // We're about to post or run the selection notifier, so we don't need
    // a pending notifier.
    mPendingSelectionNotifier = null;
    if (mOnItemSelectedListener != null || AccessibilityManager.getInstance(mContext).isEnabled()) {
        if (mInLayout || mBlockLayoutRequests) {
            // new layout or invalidate requests.
            if (mSelectionNotifier == null) {
                mSelectionNotifier = new SelectionNotifier();
            } else {
                removeCallbacks(mSelectionNotifier);
            }
            post(mSelectionNotifier);
        } else {
            dispatchOnItemSelected();
        }
    }
}","{
    // We're about to post or run the selection notifier, so we don't need
    // a pending notifier.
    mPendingSelectionNotifier = null;
    if (mOnItemSelectedListener != null || AccessibilityManager.getInstance(mContext).isEnabled()) {
        if (mInLayout || mBlockLayoutRequests) {
            // new layout or invalidate requests.
            if (mSelectionNotifier == null) {
                mSelectionNotifier = new SelectionNotifier();
            } else {
                removeCallbacks(mSelectionNotifier);
            }
            post(mSelectionNotifier);
        } else {
            dispatchOnItemSelected();
        }
    }
    // Always notify AutoFillManager - it will return right away if autofill is disabled.
    final AutofillManager afm = mContext.getSystemService(AutofillManager.class);
    if (afm != null) {
        afm.notifyValueChanged(this);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"A new block of code has been introduced to always notify the AutofillManager, which is not changing any return or exception handling statements. Hence, the change is type 4.","As the new code block does not affect the method's existing behavior such as returns or exceptions, but simply adds an additional function call, there is no Compatibility Issue. The method is void and thus does not return a value that could be affected, and the introduced code does not throw a new kind of exception. Therefore, the CI type is 0."
179,<android.view.accessibility.AccessibilityNodeInfo: boolean removeChild(View)>,25,26,<android.view.accessibility.AccessibilityNodeInfo: boolean removeChild(View)>,<android.view.accessibility.AccessibilityNodeInfo: boolean removeChild(View)>,0,"{
    return removeChild(child, UNDEFINED_ITEM_ID);
}","{
    return removeChild(child, AccessibilityNodeProvider.HOST_VIEW_ID);
}",1,"/**
 * Removes a child. If the child was not previously added to the node,
 * calling this method has no effect.
 * <p>
 * <strong>Note:</strong> Cannot be called from an
 * {@link android.accessibilityservice.AccessibilityService}.
 * This class is made immutable before being delivered to an AccessibilityService.
 * </p>
 *
 * @param child The child.
 * @return true if the child was present
 *
 * @throws IllegalStateException If called from an AccessibilityService.
 */
","/**
 * Removes a child. If the child was not previously added to the node,
 * calling this method has no effect.
 * <p>
 * <strong>Note:</strong> Cannot be called from an
 * {@link android.accessibilityservice.AccessibilityService}.
 * This class is made immutable before being delivered to an AccessibilityService.
 * </p>
 *
 * @param child The child.
 * @return true if the child was present
 *
 * @throws IllegalStateException If called from an AccessibilityService.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The change consists of switching from the constant UNDEFINED_ITEM_ID to AccessibilityNodeProvider.HOST_VIEW_ID when calling the removeChild method inside its own method body. This is a change to a method parameter value where the method signature itself hasn't changed, classified as Other statement changed (type 4) and Dependent API changed (type 5), because it depends on the value of a constant defined elsewhere.","The Compatibility Issue code is 0, because although the parameter value passed has changed, the method's contract presumably remains the same (remove a child view). It doesn't inherently imply that the return value or exception throwing behavior has changed since the method is designed to remove a child based on the provided identifier. The use of a different constant doesn't necessarily signify a CI unless the intention of the method or the meaning behind the constants has been altered. If AccessibilityNodeProvider.HOST_VIEW_ID is intended to represent the same concept as UNDEFINED_ITEM_ID in this context and the behavior of removeChild(child, id) remains consistent for the same child view regardless of the ID value, then there is no Compatibility Issue."
182,"<android.util.ArrayMap: V put(K,V)>",25,26,"<android.util.ArrayMap: V put(K,V)>","<android.util.ArrayMap: V put(K,V)>",0,"{
    final int hash;
    int index;
    if (key == null) {
        hash = 0;
        index = indexOfNull();
    } else {
        hash = mIdentityHashCode ? System.identityHashCode(key) : key.hashCode();
        index = indexOf(key, hash);
    }
    if (index >= 0) {
        index = (index << 1) + 1;
        final V old = (V) mArray[index];
        mArray[index] = value;
        return old;
    }
    index = ~index;
    if (mSize >= mHashes.length) {
        final int n = mSize >= (BASE_SIZE * 2) ? (mSize + (mSize >> 1)) : (mSize >= BASE_SIZE ? (BASE_SIZE * 2) : BASE_SIZE);
        if (DEBUG)
            Log.d(TAG, ""put: grow from "" + mHashes.length + "" to "" + n);
        final int[] ohashes = mHashes;
        final Object[] oarray = mArray;
        allocArrays(n);
        if (mHashes.length > 0) {
            if (DEBUG)
                Log.d(TAG, ""put: copy 0-"" + mSize + "" to 0"");
            System.arraycopy(ohashes, 0, mHashes, 0, ohashes.length);
            System.arraycopy(oarray, 0, mArray, 0, oarray.length);
        }
        freeArrays(ohashes, oarray, mSize);
    }
    if (index < mSize) {
        if (DEBUG)
            Log.d(TAG, ""put: move "" + index + ""-"" + (mSize - index) + "" to "" + (index + 1));
        System.arraycopy(mHashes, index, mHashes, index + 1, mSize - index);
        System.arraycopy(mArray, index << 1, mArray, (index + 1) << 1, (mSize - index) << 1);
    }
    mHashes[index] = hash;
    mArray[index << 1] = key;
    mArray[(index << 1) + 1] = value;
    mSize++;
    return null;
}","{
    final int osize = mSize;
    final int hash;
    int index;
    if (key == null) {
        hash = 0;
        index = indexOfNull();
    } else {
        hash = mIdentityHashCode ? System.identityHashCode(key) : key.hashCode();
        index = indexOf(key, hash);
    }
    if (index >= 0) {
        index = (index << 1) + 1;
        final V old = (V) mArray[index];
        mArray[index] = value;
        return old;
    }
    index = ~index;
    if (osize >= mHashes.length) {
        final int n = osize >= (BASE_SIZE * 2) ? (osize + (osize >> 1)) : (osize >= BASE_SIZE ? (BASE_SIZE * 2) : BASE_SIZE);
        if (DEBUG)
            Log.d(TAG, ""put: grow from "" + mHashes.length + "" to "" + n);
        final int[] ohashes = mHashes;
        final Object[] oarray = mArray;
        allocArrays(n);
        if (CONCURRENT_MODIFICATION_EXCEPTIONS && osize != mSize) {
            throw new ConcurrentModificationException();
        }
        if (mHashes.length > 0) {
            if (DEBUG)
                Log.d(TAG, ""put: copy 0-"" + osize + "" to 0"");
            System.arraycopy(ohashes, 0, mHashes, 0, ohashes.length);
            System.arraycopy(oarray, 0, mArray, 0, oarray.length);
        }
        freeArrays(ohashes, oarray, osize);
    }
    if (index < osize) {
        if (DEBUG)
            Log.d(TAG, ""put: move "" + index + ""-"" + (osize - index) + "" to "" + (index + 1));
        System.arraycopy(mHashes, index, mHashes, index + 1, osize - index);
        System.arraycopy(mArray, index << 1, mArray, (index + 1) << 1, (mSize - index) << 1);
    }
    if (CONCURRENT_MODIFICATION_EXCEPTIONS) {
        if (osize != mSize || index >= mHashes.length) {
            throw new ConcurrentModificationException();
        }
    }
    mHashes[index] = hash;
    mArray[index << 1] = key;
    mArray[(index << 1) + 1] = value;
    mSize++;
    return null;
}",1,"/**
 * Add a new value to the array map.
 * @param key The key under which to store the value.  If
 * this key already exists in the array, its value will be replaced.
 * @param value The value to store for the given key.
 * @return Returns the old value that was stored for the given key, or null if there
 * was no such key.
 */
","/**
 * Add a new value to the array map.
 * @param key The key under which to store the value.  If
 * this key already exists in the array, its value will be replaced.
 * @param value The value to store for the given key.
 * @return Returns the old value that was stored for the given key, or null if there
 * was no such key.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,3,4,5","1,2","The variable used to track the size of the map has been changed from `mSize` to `osize` at the beginning of the size comparison code block, and later for all operations related to growth and copying of the internal arrays. ",
183,<android.util.SparseArray: int indexOfValue(E)>,25,26,<android.util.SparseArray: int indexOfValue(E)>,<android.util.SparseArray: int indexOfValue(E)>,0,"{
    if (mGarbage) {
        gc();
    }
    for (int i = 0; i < mSize; i++) if (mValues[i] == value)
        return i;
    return -1;
}","{
    if (mGarbage) {
        gc();
    }
    for (int i = 0; i < mSize; i++) {
        if (mValues[i] == value) {
            return i;
        }
    }
    return -1;
}",1,"/**
 * Returns an index for which {@link #valueAt} would return the
 * specified key, or a negative number if no keys map to the
 * specified value.
 * <p>Beware that this is a linear search, unlike lookups by key,
 * and that multiple keys can map to the same value and this will
 * find only one of them.
 * <p>Note also that unlike most collections' {@code indexOf} methods,
 * this method compares values using {@code ==} rather than {@code equals}.
 */
","/**
 * Returns an index for which {@link #valueAt} would return the
 * specified key, or a negative number if no keys map to the
 * specified value.
 * <p>Beware that this is a linear search, unlike lookups by key,
 * and that multiple keys can map to the same value and this will
 * find only one of them.
 * <p>Note also that unlike most collections' {@code indexOf} methods,
 * this method compares values using {@code ==} rather than {@code equals}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"The only change made between the two versions is the introduction of braces around the if condition within the loop, which is merely a stylistic change. This does not affect the behavior or the return value of the API.",There is no compatibility issue as the change between versions does not impact the output or the way exceptions are handled by the method.
185,<android.content.res.ColorStateList: boolean isStateful()>,25,26,<android.content.res.ColorStateList: boolean isStateful()>,<android.content.res.ColorStateList: boolean isStateful()>,0,"{
    return mStateSpecs.length > 1;
}","{
    return mStateSpecs.length >= 1 && mStateSpecs[0].length > 0;
}",1,"/**
 * Indicates whether this color state list contains more than one state spec
 * and will change color based on state.
 *
 * @return True if this color state list changes color based on state, false
 * otherwise.
 * @see #getColorForState(int[], int)
 */
","/**
 * Indicates whether this color state list contains at least one state spec
 * and the first spec is not empty (e.g. match-all).
 *
 * @return True if this color state list changes color based on state, false
 * otherwise.
 * @see #getColorForState(int[], int)
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"The return statement has changed from checking only whether `mStateSpecs.length` is greater than 1 to now also checking whether `mStateSpecs[0].length` is greater than 0. Therefore, the code change type is 1.","The additional condition in the late version's return statement could lead to different return values under certain conditions. Specifically, if `mStateSpecs.length` is 1 but `mStateSpecs[0].length` is not greater than 0, the early version would return `true` while the late version would return `false`. Therefore, this represents a change in the return value of the method, so the CI type is 1."
186,<android.preference.Preference: long getPersistedLong(long)>,25,26,<android.preference.Preference: long getPersistedLong(long)>,<android.preference.Preference: long getPersistedLong(long)>,0,"{
    if (!shouldPersist()) {
        return defaultReturnValue;
    }
    return mPreferenceManager.getSharedPreferences().getLong(mKey, defaultReturnValue);
}","{
    if (!shouldPersist()) {
        return defaultReturnValue;
    }
    PreferenceDataStore dataStore = getPreferenceDataStore();
    if (dataStore != null) {
        return dataStore.getLong(mKey, defaultReturnValue);
    }
    return mPreferenceManager.getSharedPreferences().getLong(mKey, defaultReturnValue);
}",1,"/**
 * Attempts to get a persisted long from the {@link android.content.SharedPreferences}.
 *
 * @param defaultReturnValue The default value to return if either this
 * Preference is not persistent or this Preference is not in the
 * SharedPreferences.
 * @return The value from the SharedPreferences or the default return
 * value.
 * @see #getPersistedString(String)
 * @see #persistLong(long)
 */
","/**
 * Attempts to get a persisted long if this Preference is persistent.
 *
 * @param defaultReturnValue The default value to return if either this
 * Preference is not persistent or this Preference is not present.
 * @return The value from the data store or the default return
 * value.
 * @see #getPersistedString(String)
 * @see #persistLong(long)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,5",1,"A new control dependency has been introduced with an additional 'if' that checks if a PreferenceDataStore is not null and a new method call to that PreferenceDataStore, so the code change types are 3 and 5.","Because of the new control dependency and method invocation on a PreferenceDataStore object, this change can potentially lead the API to return a different value if the data store is being used instead of shared preferences. Hence, the CI type is 1."
188,<android.app.job.JobInfo.Builder: JobInfo build()>,25,26,<android.app.job.JobInfo.Builder: JobInfo build()>,<android.app.job.JobInfo.Builder: JobInfo build()>,0,"{
    // Allow jobs with no constraints - What am I, a database?
    if (!mHasEarlyConstraint && !mHasLateConstraint && !mRequiresCharging && !mRequiresDeviceIdle && mNetworkType == NETWORK_TYPE_NONE && mTriggerContentUris == null) {
        throw new IllegalArgumentException(""You're trying to build a job with no "" + ""constraints, this is not allowed."");
    }
    // Make our own copy.
    mExtras = new PersistableBundle(mExtras);
    // Check that a deadline was not set on a periodic job.
    if (mIsPeriodic && (mMaxExecutionDelayMillis != 0L)) {
        throw new IllegalArgumentException(""Can't call setOverrideDeadline() on a "" + ""periodic job."");
    }
    if (mIsPeriodic && (mMinLatencyMillis != 0L)) {
        throw new IllegalArgumentException(""Can't call setMinimumLatency() on a "" + ""periodic job"");
    }
    if (mIsPeriodic && (mTriggerContentUris != null)) {
        throw new IllegalArgumentException(""Can't call addTriggerContentUri() on a "" + ""periodic job"");
    }
    if (mIsPersisted && (mTriggerContentUris != null)) {
        throw new IllegalArgumentException(""Can't call addTriggerContentUri() on a "" + ""persisted job"");
    }
    if (mBackoffPolicySet && mRequiresDeviceIdle) {
        throw new IllegalArgumentException(""An idle mode job will not respect any"" + "" back-off policy, so calling setBackoffCriteria with"" + "" setRequiresDeviceIdle is an error."");
    }
    JobInfo job = new JobInfo(this);
    if (job.isPeriodic()) {
        if (job.intervalMillis != job.getIntervalMillis()) {
            StringBuilder builder = new StringBuilder();
            builder.append(""Specified interval for "").append(String.valueOf(mJobId)).append("" is "");
            formatDuration(mIntervalMillis, builder);
            builder.append("". Clamped to "");
            formatDuration(job.getIntervalMillis(), builder);
            Log.w(TAG, builder.toString());
        }
        if (job.flexMillis != job.getFlexMillis()) {
            StringBuilder builder = new StringBuilder();
            builder.append(""Specified flex for "").append(String.valueOf(mJobId)).append("" is "");
            formatDuration(mFlexMillis, builder);
            builder.append("". Clamped to "");
            formatDuration(job.getFlexMillis(), builder);
            Log.w(TAG, builder.toString());
        }
    }
    return job;
}","{
    // Allow jobs with no constraints - What am I, a database?
    if (!mHasEarlyConstraint && !mHasLateConstraint && mConstraintFlags == 0 && mNetworkType == NETWORK_TYPE_NONE && mTriggerContentUris == null) {
        throw new IllegalArgumentException(""You're trying to build a job with no "" + ""constraints, this is not allowed."");
    }
    // Check that a deadline was not set on a periodic job.
    if (mIsPeriodic) {
        if (mMaxExecutionDelayMillis != 0L) {
            throw new IllegalArgumentException(""Can't call setOverrideDeadline() on a "" + ""periodic job."");
        }
        if (mMinLatencyMillis != 0L) {
            throw new IllegalArgumentException(""Can't call setMinimumLatency() on a "" + ""periodic job"");
        }
        if (mTriggerContentUris != null) {
            throw new IllegalArgumentException(""Can't call addTriggerContentUri() on a "" + ""periodic job"");
        }
    }
    if (mIsPersisted) {
        if (mTriggerContentUris != null) {
            throw new IllegalArgumentException(""Can't call addTriggerContentUri() on a "" + ""persisted job"");
        }
        if (!mTransientExtras.isEmpty()) {
            throw new IllegalArgumentException(""Can't call setTransientExtras() on a "" + ""persisted job"");
        }
        if (mClipData != null) {
            throw new IllegalArgumentException(""Can't call setClipData() on a "" + ""persisted job"");
        }
    }
    if (mBackoffPolicySet && (mConstraintFlags & CONSTRAINT_FLAG_DEVICE_IDLE) != 0) {
        throw new IllegalArgumentException(""An idle mode job will not respect any"" + "" back-off policy, so calling setBackoffCriteria with"" + "" setRequiresDeviceIdle is an error."");
    }
    JobInfo job = new JobInfo(this);
    if (job.isPeriodic()) {
        if (job.intervalMillis != job.getIntervalMillis()) {
            StringBuilder builder = new StringBuilder();
            builder.append(""Specified interval for "").append(String.valueOf(mJobId)).append("" is "");
            formatDuration(mIntervalMillis, builder);
            builder.append("". Clamped to "");
            formatDuration(job.getIntervalMillis(), builder);
            Log.w(TAG, builder.toString());
        }
        if (job.flexMillis != job.getFlexMillis()) {
            StringBuilder builder = new StringBuilder();
            builder.append(""Specified flex for "").append(String.valueOf(mJobId)).append("" is "");
            formatDuration(mFlexMillis, builder);
            builder.append("". Clamped to "");
            formatDuration(job.getFlexMillis(), builder);
            Log.w(TAG, builder.toString());
        }
    }
    return job;
}",1,"/**
 * @return The job object to hand to the JobScheduler. This object is immutable.
 */
","/**
 * @return The job object to hand to the JobScheduler. This object is immutable.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
190,"<android.app.DownloadManager.Query: Cursor runQuery(ContentResolver,String[],Uri)>",25,26,"<android.app.DownloadManager.Query: Cursor runQuery(ContentResolver,String[],Uri)>","<android.app.DownloadManager.Query: Cursor runQuery(ContentResolver,String[],Uri)>",0,"{
    Uri uri = baseUri;
    List<String> selectionParts = new ArrayList<String>();
    String[] selectionArgs = null;
    if (mIds != null) {
        selectionParts.add(getWhereClauseForIds(mIds));
        selectionArgs = getWhereArgsForIds(mIds);
    }
    if (mStatusFlags != null) {
        List<String> parts = new ArrayList<String>();
        if ((mStatusFlags & STATUS_PENDING) != 0) {
            parts.add(statusClause(""="", Downloads.Impl.STATUS_PENDING));
        }
        if ((mStatusFlags & STATUS_RUNNING) != 0) {
            parts.add(statusClause(""="", Downloads.Impl.STATUS_RUNNING));
        }
        if ((mStatusFlags & STATUS_PAUSED) != 0) {
            parts.add(statusClause(""="", Downloads.Impl.STATUS_PAUSED_BY_APP));
            parts.add(statusClause(""="", Downloads.Impl.STATUS_WAITING_TO_RETRY));
            parts.add(statusClause(""="", Downloads.Impl.STATUS_WAITING_FOR_NETWORK));
            parts.add(statusClause(""="", Downloads.Impl.STATUS_QUEUED_FOR_WIFI));
        }
        if ((mStatusFlags & STATUS_SUCCESSFUL) != 0) {
            parts.add(statusClause(""="", Downloads.Impl.STATUS_SUCCESS));
        }
        if ((mStatusFlags & STATUS_FAILED) != 0) {
            parts.add(""("" + statusClause("">="", 400) + "" AND "" + statusClause(""<"", 600) + "")"");
        }
        selectionParts.add(joinStrings("" OR "", parts));
    }
    if (mOnlyIncludeVisibleInDownloadsUi) {
        selectionParts.add(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI + "" != '0'"");
    }
    // only return rows which are not marked 'deleted = 1'
    selectionParts.add(Downloads.Impl.COLUMN_DELETED + "" != '1'"");
    String selection = joinStrings("" AND "", selectionParts);
    String orderDirection = (mOrderDirection == ORDER_ASCENDING ? ""ASC"" : ""DESC"");
    String orderBy = mOrderByColumn + "" "" + orderDirection;
    return resolver.query(uri, projection, selection, selectionArgs, orderBy);
}","{
    Uri uri = baseUri;
    List<String> selectionParts = new ArrayList<String>();
    String[] selectionArgs = null;
    int whereArgsCount = (mIds == null) ? 0 : mIds.length;
    whereArgsCount = (mFilterString == null) ? whereArgsCount : whereArgsCount + 1;
    selectionArgs = new String[whereArgsCount];
    if (whereArgsCount > 0) {
        if (mIds != null) {
            selectionParts.add(getWhereClauseForIds(mIds));
            getWhereArgsForIds(mIds, selectionArgs);
        }
        if (mFilterString != null) {
            selectionParts.add(Downloads.Impl.COLUMN_TITLE + "" LIKE ?"");
            selectionArgs[selectionArgs.length - 1] = ""%"" + mFilterString + ""%"";
        }
    }
    if (mStatusFlags != null) {
        List<String> parts = new ArrayList<String>();
        if ((mStatusFlags & STATUS_PENDING) != 0) {
            parts.add(statusClause(""="", Downloads.Impl.STATUS_PENDING));
        }
        if ((mStatusFlags & STATUS_RUNNING) != 0) {
            parts.add(statusClause(""="", Downloads.Impl.STATUS_RUNNING));
        }
        if ((mStatusFlags & STATUS_PAUSED) != 0) {
            parts.add(statusClause(""="", Downloads.Impl.STATUS_PAUSED_BY_APP));
            parts.add(statusClause(""="", Downloads.Impl.STATUS_WAITING_TO_RETRY));
            parts.add(statusClause(""="", Downloads.Impl.STATUS_WAITING_FOR_NETWORK));
            parts.add(statusClause(""="", Downloads.Impl.STATUS_QUEUED_FOR_WIFI));
        }
        if ((mStatusFlags & STATUS_SUCCESSFUL) != 0) {
            parts.add(statusClause(""="", Downloads.Impl.STATUS_SUCCESS));
        }
        if ((mStatusFlags & STATUS_FAILED) != 0) {
            parts.add(""("" + statusClause("">="", 400) + "" AND "" + statusClause(""<"", 600) + "")"");
        }
        selectionParts.add(joinStrings("" OR "", parts));
    }
    if (mOnlyIncludeVisibleInDownloadsUi) {
        selectionParts.add(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI + "" != '0'"");
    }
    // only return rows which are not marked 'deleted = 1'
    selectionParts.add(Downloads.Impl.COLUMN_DELETED + "" != '1'"");
    String selection = joinStrings("" AND "", selectionParts);
    String orderDirection = (mOrderDirection == ORDER_ASCENDING ? ""ASC"" : ""DESC"");
    String orderBy = mOrderByColumn + "" "" + orderDirection;
    return resolver.query(uri, projection, selection, selectionArgs, orderBy);
}",1,"/**
 * Run this query using the given ContentResolver.
 * @param projection the projection to pass to ContentResolver.query()
 * @return the Cursor returned by ContentResolver.query()
 */
","/**
 * Run this query using the given ContentResolver.
 * @param projection the projection to pass to ContentResolver.query()
 * @return the Cursor returned by ContentResolver.query()
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",1,"The control dependency change occurs where the initialization of 'whereArgsCount' and a subsequent conditional 'if' block is added. This affects variable 'selectionArgs' and its usage. Also, a new filter mechanism for 'mFilterString' with corresponding 'selectionArgs' assignment is introduced. The implementation introduces changes in other statements as well, such as the modification of 'getWhereArgsForIds(mIds)' to 'getWhereArgsForIds(mIds, selectionArgs)' which changes how 'selectionArgs' is filled, falling under category 4. The dependent API, 'getWhereArgsForIds' seems altered in terms of its usage or signature, which constitutes a dependent API change, hence category 5 applies.","Due to the control flow change and initialization of 'selectionArgs', which is a key parameter in the query function, the API could potentially return different results (different 'selectionArgs' could lead to a different resulting 'Cursor'). Additionally, the change of dependent API 'getWhereArgsForIds' could also cause the API to return different results due to the altered behavior of this dependency. Thus, the change causes a Compatibility Issue of type 1."
192,<android.bluetooth.le.ScanResult: int hashCode()>,25,26,<android.bluetooth.le.ScanResult: int hashCode()>,<android.bluetooth.le.ScanResult: int hashCode()>,0,"{
    return Objects.hash(mDevice, mRssi, mScanRecord, mTimestampNanos);
}","{
    return Objects.hash(mDevice, mRssi, mScanRecord, mTimestampNanos, mEventType, mPrimaryPhy, mSecondaryPhy, mAdvertisingSid, mTxPower, mPeriodicAdvertisingInterval);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The hashCode() method is changed by including more fields in the hash calculation (mEventType, mPrimaryPhy, mSecondaryPhy, mAdvertisingSid, mTxPower, mPeriodicAdvertisingInterval). Additional class fields are being used in the Objects.hash() method in the late implementation, which is an ""Other statement changed"".","These changes could potentially lead to a different return value of the hashCode method due to the inclusion of additional fields in the hash computation, which might affect the result of the hash. Hence, the CI type is 1."
193,"<android.os.storage.StorageManager: boolean mountObb(String,String,OnObbStateChangeListener)>",25,26,"<android.os.storage.StorageManager: boolean mountObb(String,String,OnObbStateChangeListener)>","<android.os.storage.StorageManager: boolean mountObb(String,String,OnObbStateChangeListener)>",0,"{
    Preconditions.checkNotNull(rawPath, ""rawPath cannot be null"");
    Preconditions.checkNotNull(listener, ""listener cannot be null"");
    try {
        final String canonicalPath = new File(rawPath).getCanonicalPath();
        final int nonce = mObbActionListener.addListener(listener);
        mMountService.mountObb(rawPath, canonicalPath, key, mObbActionListener, nonce);
        return true;
    } catch (IOException e) {
        throw new IllegalArgumentException(""Failed to resolve path: "" + rawPath, e);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    Preconditions.checkNotNull(rawPath, ""rawPath cannot be null"");
    Preconditions.checkNotNull(listener, ""listener cannot be null"");
    try {
        final String canonicalPath = new File(rawPath).getCanonicalPath();
        final int nonce = mObbActionListener.addListener(listener);
        mStorageManager.mountObb(rawPath, canonicalPath, key, mObbActionListener, nonce);
        return true;
    } catch (IOException e) {
        throw new IllegalArgumentException(""Failed to resolve path: "" + rawPath, e);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Mount an Opaque Binary Blob (OBB) file. If a <code>key</code> is
 * specified, it is supplied to the mounting process to be used in any
 * encryption used in the OBB.
 * <p>
 * The OBB will remain mounted for as long as the StorageManager reference
 * is held by the application. As soon as this reference is lost, the OBBs
 * in use will be unmounted. The {@link OnObbStateChangeListener} registered
 * with this call will receive the success or failure of this operation.
 * <p>
 * <em>Note:</em> you can only mount OBB files for which the OBB tag on the
 * file matches a package ID that is owned by the calling program's UID.
 * That is, shared UID applications can attempt to mount any other
 * application's OBB that shares its UID.
 *
 * @param rawPath the path to the OBB file
 * @param key secret used to encrypt the OBB; may be <code>null</code> if no
 * encryption was used on the OBB.
 * @param listener will receive the success or failure of the operation
 * @return whether the mount call was successfully queued or not
 */
","/**
 * Mount an Opaque Binary Blob (OBB) file. If a <code>key</code> is
 * specified, it is supplied to the mounting process to be used in any
 * encryption used in the OBB.
 * <p>
 * The OBB will remain mounted for as long as the StorageManager reference
 * is held by the application. As soon as this reference is lost, the OBBs
 * in use will be unmounted. The {@link OnObbStateChangeListener} registered
 * with this call will receive the success or failure of this operation.
 * <p>
 * <em>Note:</em> you can only mount OBB files for which the OBB tag on the
 * file matches a package ID that is owned by the calling program's UID.
 * That is, shared UID applications can attempt to mount any other
 * application's OBB that shares its UID.
 *
 * @param rawPath the path to the OBB file
 * @param key secret used to encrypt the OBB; may be <code>null</code> if no
 * encryption was used on the OBB.
 * @param listener will receive the success or failure of the operation
 * @return whether the mount call was successfully queued or not
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"There is a change within the API implementation from `mMountService.mountObb` to `mStorageManager.mountObb`. This is a change to a dependent API, the name of the variable calling the mountObb method has been changed. Therefore, the code change types are 4 and 5.","There doesn't seem to be a Compatibility Issue caused by this change as there's no difference in the behavior of the API from the perspective of the caller. The try-catch blocks are the same and the method call to mountObb is expected to perform the same function despite being called on a different object. The underlying implementation of the `mountObb` method is not provided here, so we can only assume it remains the same functionally. Therefore, there's no CI in terms of returning different values/types (1) or different exception handling (2)."
194,<android.webkit.CookieSyncManager: CookieSyncManager getInstance()>,25,26,<android.webkit.CookieSyncManager: CookieSyncManager getInstance()>,<android.webkit.CookieSyncManager: CookieSyncManager getInstance()>,0,"{
    checkInstanceIsAllowed();
    if (sRef == null) {
        sRef = new CookieSyncManager();
    }
    return sRef;
}","{
    synchronized (sLock) {
        checkInstanceIsAllowed();
        if (sRef == null) {
            sRef = new CookieSyncManager();
        }
        return sRef;
    }
}",1,"/**
 * Singleton access to a {@link CookieSyncManager}. An
 * IllegalStateException will be thrown if
 * {@link CookieSyncManager#createInstance(Context)} is not called before.
 *
 * @return CookieSyncManager
 */
","/**
 * Singleton access to a {@link CookieSyncManager}. An
 * IllegalStateException will be thrown if
 * {@link CookieSyncManager#createInstance(Context)} is not called before.
 *
 * @return CookieSyncManager
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The late version adds a synchronized block, but the logic inside the block stays the same, which means the change type is 3 for a control dependency change.","Although there is a change in the control structure (introducing a synchronized block for thread safety), it does not affect the behavior of the method in terms of what it returns or what exceptions it may throw. Therefore, there's no Compatibility Issue, and the pred_CI is 0."
195,<android.app.ActivityManager: List<RunningTaskInfo> getRunningTasks(int)>,25,26,<android.app.ActivityManager: List<RunningTaskInfo> getRunningTasks(int)>,<android.app.ActivityManager: List<RunningTaskInfo> getRunningTasks(int)>,0,"{
    try {
        return ActivityManagerNative.getDefault().getTasks(maxNum, 0);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        return getService().getTasks(maxNum, 0);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Return a list of the tasks that are currently running, with
 * the most recent being first and older ones after in order.  Note that
 * ""running"" does not mean any of the task's code is currently loaded or
 * activity -- the task may have been frozen by the system, so that it
 * can be restarted in its previous state when next brought to the
 * foreground.
 *
 * <p><b>Note: this method is only intended for debugging and presenting
 * task management user interfaces</b>.  This should never be used for
 * core logic in an application, such as deciding between different
 * behaviors based on the information found here.  Such uses are
 * <em>not</em> supported, and will likely break in the future.  For
 * example, if multiple applications can be actively running at the
 * same time, assumptions made about the meaning of the data here for
 * purposes of control flow will be incorrect.</p>
 *
 * @deprecated As of {@link android.os.Build.VERSION_CODES#LOLLIPOP}, this method
 * is no longer available to third party
 * applications: the introduction of document-centric recents means
 * it can leak person information to the caller.  For backwards compatibility,
 * it will still retu rn a small subset of its data: at least the caller's
 * own tasks, and possibly some other tasks
 * such as home that are known to not be sensitive.
 *
 * @param maxNum The maximum number of entries to return in the list.  The
 * actual number returned may be smaller, depending on how many tasks the
 * user has started.
 *
 * @return Returns a list of RunningTaskInfo records describing each of
 * the running tasks.
 */
","/**
 * Return a list of the tasks that are currently running, with
 * the most recent being first and older ones after in order.  Note that
 * ""running"" does not mean any of the task's code is currently loaded or
 * activity -- the task may have been frozen by the system, so that it
 * can be restarted in its previous state when next brought to the
 * foreground.
 *
 * <p><b>Note: this method is only intended for debugging and presenting
 * task management user interfaces</b>.  This should never be used for
 * core logic in an application, such as deciding between different
 * behaviors based on the information found here.  Such uses are
 * <em>not</em> supported, and will likely break in the future.  For
 * example, if multiple applications can be actively running at the
 * same time, assumptions made about the meaning of the data here for
 * purposes of control flow will be incorrect.</p>
 *
 * @deprecated As of {@link android.os.Build.VERSION_CODES#LOLLIPOP}, this method
 * is no longer available to third party
 * applications: the introduction of document-centric recents means
 * it can leak person information to the caller.  For backwards compatibility,
 * it will still retu rn a small subset of its data: at least the caller's
 * own tasks, and possibly some other tasks
 * such as home that are known to not be sensitive.
 *
 * @param maxNum The maximum number of entries to return in the list.  The
 * actual number returned may be smaller, depending on how many tasks the
 * user has started.
 *
 * @return Returns a list of RunningTaskInfo records describing each of
 * the running tasks.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,5,0,"The change is only in the method used to get the service reference (from ActivityManagerNative.getDefault() to getService()). This is a dependent API change, hence the code change type is 5.","Since the method used to obtain the service reference changed, but the actual functionality of getting tasks (getTasks(maxNum, 0)) and throwing the exception did not change, there is no difference in the behavior of the API. Therefore, there is no compatibility issue, so the CI type is 0."
197,"<android.util.TypedValue: int complexToDimensionPixelSize(int,DisplayMetrics)>",25,26,"<android.util.TypedValue: int complexToDimensionPixelSize(int,DisplayMetrics)>","<android.util.TypedValue: int complexToDimensionPixelSize(int,DisplayMetrics)>",0,"{
    final float value = complexToFloat(data);
    final float f = applyDimension((data >> COMPLEX_UNIT_SHIFT) & COMPLEX_UNIT_MASK, value, metrics);
    final int res = (int) (f + 0.5f);
    if (res != 0)
        return res;
    if (value == 0)
        return 0;
    if (value > 0)
        return 1;
    return -1;
}","{
    final float value = complexToFloat(data);
    final float f = applyDimension((data >> COMPLEX_UNIT_SHIFT) & COMPLEX_UNIT_MASK, value, metrics);
    final int res = (int) ((f >= 0) ? (f + 0.5f) : (f - 0.5f));
    if (res != 0)
        return res;
    if (value == 0)
        return 0;
    if (value > 0)
        return 1;
    return -1;
}",1,"/**
 * Converts a complex data value holding a dimension to its final value
 * as an integer pixel size.  This is the same as
 * {@link #complexToDimension}, except the raw floating point value is
 * converted to an integer (pixel) value for use as a size.  A size
 * conversion involves rounding the base value, and ensuring that a
 * non-zero base value is at least one pixel in size.
 * The given <var>data</var> must be structured as a
 * {@link #TYPE_DIMENSION}.
 *
 * @param data A complex data value holding a unit, magnitude, and
 * mantissa.
 * @param metrics Current display metrics to use in the conversion --
 * supplies display density and scaling information.
 *
 * @return The number of pixels specified by the data and its desired
 * multiplier and units.
 */
","/**
 * Converts a complex data value holding a dimension to its final value
 * as an integer pixel size.  This is the same as
 * {@link #complexToDimension}, except the raw floating point value is
 * converted to an integer (pixel) value for use as a size.  A size
 * conversion involves rounding the base value, and ensuring that a
 * non-zero base value is at least one pixel in size.
 * The given <var>data</var> must be structured as a
 * {@link #TYPE_DIMENSION}.
 *
 * @param data A complex data value holding a unit, magnitude, and
 * mantissa.
 * @param metrics Current display metrics to use in the conversion --
 * supplies display density and scaling information.
 *
 * @return The number of pixels specified by the data and its desired
 * multiplier and units.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method of rounding 'res' changed from `(int) (f + 0.5f)` to `(int) ((f >= 0) ? (f + 0.5f) : (f - 0.5f))`, which is not a control dependency, return statement, or exception handling change. It is classified as an other statement changed, so the code change type is 4.","The change is a rounding logic modification which doesn't lead to a compatibility issue since it only fine-tunes how the final int is calculated for positive and negative values. For positive values, both versions effectively round up at 0.5 and above, and for negative values, the late version adjusts the rounding down correctly. Therefore, it fixes a bug rather than causing a compatibility issue—no CI."
198,<android.net.LocalServerSocket: LocalSocket accept()>,25,26,<android.net.LocalServerSocket: LocalSocket accept()>,<android.net.LocalServerSocket: LocalSocket accept()>,0,"{
    LocalSocketImpl acceptedImpl = new LocalSocketImpl();
    impl.accept(acceptedImpl);
    return new LocalSocket(acceptedImpl, LocalSocket.SOCKET_UNKNOWN);
}","{
    LocalSocketImpl acceptedImpl = new LocalSocketImpl();
    impl.accept(acceptedImpl);
    return LocalSocket.createLocalSocketForAccept(acceptedImpl);
}",1,"/**
 * Accepts a new connection to the socket. Blocks until a new
 * connection arrives.
 *
 * @return a socket representing the new connection.
 * @throws IOException
 */
","/**
 * Accepts a new connection to the socket. Blocks until a new
 * connection arrives.
 *
 * @return a socket representing the new connection.
 * @throws IOException
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from constructing a new LocalSocket object explicitly to calling a static method, LocalSocket.createLocalSocketForAccept. This change means the method used to create the LocalSocket object has changed, so there's a change in both the return statement and a dependent API call, making the code change type be 1,5.","The change of return statement could potentially lead to the API returning a different type or value because a different method is used to create the LocalSocket object. This could arise from differences in how LocalSocket.createLocalSocketForAccept initializes the object compared to how it was previously done directly in this method, so the CI type is 1."
201,<android.app.ContextImpl: int getThemeResId()>,25,26,<android.app.ContextImpl: int getThemeResId()>,<android.app.ContextImpl: int getThemeResId()>,0,"{
    return mThemeResource;
}","{
    synchronized (mSync) {
        return mThemeResource;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The code change only involves adding a synchronized block around the existing return statement, so the type of code change is 4.",There's no potential Compatibility Issue caused by this change since the value and type returned by the API have not changed. The addition of the synchronized block only affects thread-safety and does not impact the overall functionality from the perspective of a single-threaded scenario.
202,<android.content.ClipDescription: String[] filterMimeTypes(String)>,25,26,<android.content.ClipDescription: String[] filterMimeTypes(String)>,<android.content.ClipDescription: String[] filterMimeTypes(String)>,0,"{
    ArrayList<String> array = null;
    for (int i = 0; i < mMimeTypes.length; i++) {
        if (compareMimeTypes(mMimeTypes[i], mimeType)) {
            if (array == null) {
                array = new ArrayList<String>();
            }
            array.add(mMimeTypes[i]);
        }
    }
    if (array == null) {
        return null;
    }
    String[] rawArray = new String[array.size()];
    array.toArray(rawArray);
    return rawArray;
}","{
    ArrayList<String> array = null;
    final int size = mMimeTypes.size();
    for (int i = 0; i < size; i++) {
        if (compareMimeTypes(mMimeTypes.get(i), mimeType)) {
            if (array == null) {
                array = new ArrayList<String>();
            }
            array.add(mMimeTypes.get(i));
        }
    }
    if (array == null) {
        return null;
    }
    String[] rawArray = new String[array.size()];
    array.toArray(rawArray);
    return rawArray;
}",1,"/**
 * Filter the clip description MIME types by the given MIME type.  Returns
 * all MIME types in the clip that match the given MIME type.
 *
 * @param mimeType The desired MIME type.  May be a pattern.
 * @return Returns an array of all matching MIME types.  If there are no
 * matching MIME types, null is returned.
 */
","/**
 * Filter the clip description MIME types by the given MIME type.  Returns
 * all MIME types in the clip that match the given MIME type.
 *
 * @param mimeType The desired MIME type.  May be a pattern.
 * @return Returns an array of all matching MIME types.  If there are no
 * matching MIME types, null is returned.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The implementations have changed from using an array (mMimeTypes[]) to using an ArrayList (mMimeTypes.get(i)). This modification is not associated with a change in return statement, exception handling, or control dependency. So the code change type is 4,5.","Although there's a change in how the mimetypes are accessed (from array to ArrayList), the method's external behavior (the return value or thrown exceptions) hasn't changed. Therefore, there's no Compatibility Issue."
203,"<android.app.admin.DevicePolicyManager: String[] setPackagesSuspended(ComponentName,String[],boolean)>",25,26,"<android.app.admin.DevicePolicyManager: String[] setPackagesSuspended(ComponentName,String[],boolean)>","<android.app.admin.DevicePolicyManager: String[] setPackagesSuspended(ComponentName,String[],boolean)>",0,"{
    throwIfParentInstance(""setPackagesSuspended"");
    if (mService != null) {
        try {
            return mService.setPackagesSuspended(admin, packageNames, suspended);
        } catch (RemoteException re) {
            throw re.rethrowFromSystemServer();
        }
    }
    return packageNames;
}","{
    throwIfParentInstance(""setPackagesSuspended"");
    if (mService != null) {
        try {
            return mService.setPackagesSuspended(admin, mContext.getPackageName(), packageNames, suspended);
        } catch (RemoteException re) {
            throw re.rethrowFromSystemServer();
        }
    }
    return packageNames;
}",1,"/**
 * Called by device or profile owners to suspend packages for this user.
 * <p>
 * A suspended package will not be able to start activities. Its notifications will be hidden,
 * it will not show up in recents, will not be able to show toasts or dialogs or ring the
 * device.
 * <p>
 * The package must already be installed. If the package is uninstalled while suspended the
 * package will no longer be suspended. The admin can block this by using
 * {@link #setUninstallBlocked}.
 *
 * @param admin The name of the admin component to check.
 * @param packageNames The package names to suspend or unsuspend.
 * @param suspended If set to {@code true} than the packages will be suspended, if set to
 * {@code false} the packages will be unsuspended.
 * @return an array of package names for which the suspended status is not set as requested in
 * this method.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 */
","/**
 * Called by device or profile owners to suspend packages for this user. This function can be
 * called by a device owner, profile owner, or by a delegate given the
 * {@link #DELEGATION_PACKAGE_ACCESS} scope via {@link #setDelegatedScopes}.
 * <p>
 * A suspended package will not be able to start activities. Its notifications will be hidden,
 * it will not show up in recents, will not be able to show toasts or dialogs or ring the
 * device.
 * <p>
 * The package must already be installed. If the package is uninstalled while suspended the
 * package will no longer be suspended. The admin can block this by using
 * {@link #setUninstallBlocked}.
 *
 * @param admin The name of the admin component to check, or {@code null} if the caller is a
 * package access delegate.
 * @param packageNames The package names to suspend or unsuspend.
 * @param suspended If set to {@code true} than the packages will be suspended, if set to
 * {@code false} the packages will be unsuspended.
 * @return an array of package names for which the suspended status is not set as requested in
 * this method.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 * @see #setDelegatedScopes
 * @see #DELEGATION_PACKAGE_ACCESS
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,5,0,"The Dependent API changed: The method mService.setPackagesSuspended has a new parameter mContext.getPackageName() inserted before packageNames, so the code change type is 5.",No Compatibility Issue should arise from this change because the method's signature remains the same and the change in the dependent API does not change how this method behaves from the caller's perspective. It’s an internal change regarding how the method gets its data before invoking the dependent API.
204,"<android.widget.Editor.TextActionModeCallback: boolean onActionItemClicked(ActionMode,MenuItem)>",25,26,"<android.widget.Editor.TextActionModeCallback: boolean onActionItemClicked(ActionMode,MenuItem)>","<android.widget.Editor.TextActionModeCallback: boolean onActionItemClicked(ActionMode,MenuItem)>",0,"{
    if (mProcessTextIntentActionsHandler.performMenuItemAction(item)) {
        return true;
    }
    Callback customCallback = getCustomCallback();
    if (customCallback != null && customCallback.onActionItemClicked(mode, item)) {
        return true;
    }
    return mTextView.onTextContextMenuItem(item.getItemId());
}","{
    getSelectionActionModeHelper().onSelectionAction();
    if (mProcessTextIntentActionsHandler.performMenuItemAction(item)) {
        return true;
    }
    Callback customCallback = getCustomCallback();
    if (customCallback != null && customCallback.onActionItemClicked(mode, item)) {
        return true;
    }
    final TextClassification textClassification = getSelectionActionModeHelper().getTextClassification();
    if (TextView.ID_ASSIST == item.getItemId() && textClassification != null) {
        final OnClickListener onClickListener = textClassification.getOnClickListener();
        if (onClickListener != null) {
            onClickListener.onClick(mTextView);
        } else {
            final Intent intent = textClassification.getIntent();
            if (intent != null) {
                TextClassification.createStartActivityOnClickListener(mTextView.getContext(), intent).onClick(mTextView);
            }
        }
        mMetricsLogger.action(MetricsEvent.ACTION_TEXT_SELECTION_MENU_ITEM_ASSIST, textClassification.getLogType());
        stopTextActionMode();
        return true;
    }
    return mTextView.onTextContextMenuItem(item.getItemId());
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,"The late implementation introduced a new method call `getSelectionActionModeHelper().onSelectionAction()` at the beginning and new if-condition block that checks for `TextView.ID_ASSIST` and performs certain actions, including method calls that are not in the early version. These changes involve the control dependency (introduction of a new if-condition), and also other statements (method calls and additional logic). The return statement however did not change in terms of returning a different type, because the method has always potentially been returning `true` or the result of `mTextView.onTextContextMenuItem(item.getItemId())` in both versions. The type of code change is thus 1,3,4.","The late version might return `true` in cases where the early version would not due to the additional `if` block regarding `TextView.ID_ASSIST` and the newly introduced calls to `getSelectionActionModeHelper().onSelectionAction()` and `stopTextActionMode()`. Additionally, executing `onClickListener.onClick(mTextView)` or the intent related logic could produce different side effects or return `true` where the early version did not. The CI type is 1."
205,<android.os.StatFs: long getAvailableBytes()>,25,26,<android.os.StatFs: long getAvailableBytes()>,<android.os.StatFs: long getAvailableBytes()>,0,"{
    return mStat.f_bavail * mStat.f_bsize;
}","{
    return mStat.f_bavail * mStat.f_frsize;
}",1,"/**
 * The number of bytes that are free on the file system and available to
 * applications.
 */
","/**
 * The number of bytes that are free on the file system and available to
 * applications.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The multiplication has changed from using mStat.f_bsize to mStat.f_frsize, which is a change in the operands used in the return statement. It indicates that there has been a change in the dependent fields that are used to calculate the returned value. Therefore, the change type is 1 and 5.","The change in multiplication operand from mStat.f_bsize to mStat.f_frsize likely changes the result of the method, as these two fields might represent different sizes (block size vs fragment size). Hence, the API may return a different value, leading to compatibility issues of type 1."
206,<android.app.SharedPreferencesImpl.EditorImpl: Editor remove(String)>,25,26,<android.app.SharedPreferencesImpl.EditorImpl: Editor remove(String)>,<android.app.SharedPreferencesImpl.EditorImpl: Editor remove(String)>,0,"{
    synchronized (this) {
        mModified.put(key, this);
        return this;
    }
}","{
    synchronized (mLock) {
        mModified.put(key, this);
        return this;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The synchronization lock object was changed from ""this"" to ""mLock"". This change is not related to return statements, exception handling, or control dependency. Therefore, the change is classified as Other statement changed (4).","The change in the synchronization lock object does not affect the behavior of the method itself, as the method's logic and return type remain unchanged. Therefore, there is no compatibility issue, hence the prediction is No Compatibility Issue (0)."
207,"<android.app.FragmentManagerImpl: void moveToState(int,boolean)>",25,26,"<android.app.FragmentManagerImpl: void moveToState(int,boolean)>","<android.app.FragmentManagerImpl: void moveToState(int,boolean)>",0,"{
    moveToState(newState, 0, 0, always);
}","{
    if (mHost == null && newState != Fragment.INITIALIZING) {
        throw new IllegalStateException(""No activity"");
    }
    if (!always && mCurState == newState) {
        return;
    }
    mCurState = newState;
    if (mActive != null) {
        boolean loadersRunning = false;
        // Must add them in the proper order. mActive fragments may be out of order
        if (mAdded != null) {
            final int numAdded = mAdded.size();
            for (int i = 0; i < numAdded; i++) {
                Fragment f = mAdded.get(i);
                moveFragmentToExpectedState(f);
                if (f.mLoaderManager != null) {
                    loadersRunning |= f.mLoaderManager.hasRunningLoaders();
                }
            }
        }
        // Now iterate through all active fragments. These will include those that are removed
        // and detached.
        final int numActive = mActive.size();
        for (int i = 0; i < numActive; i++) {
            Fragment f = mActive.valueAt(i);
            if (f != null && (f.mRemoving || f.mDetached) && !f.mIsNewlyAdded) {
                moveFragmentToExpectedState(f);
                if (f.mLoaderManager != null) {
                    loadersRunning |= f.mLoaderManager.hasRunningLoaders();
                }
            }
        }
        if (!loadersRunning) {
            startPendingDeferredFragments();
        }
        if (mNeedMenuInvalidate && mHost != null && mCurState == Fragment.RESUMED) {
            mHost.onInvalidateOptionsMenu();
            mNeedMenuInvalidate = false;
        }
    }
}",1,,"/**
 * Changes the state of the fragment manager to {@code newState}. If the fragment manager
 * changes state or {@code always} is {@code true}, any fragments within it have their
 * states updated as well.
 *
 * @param newState The new state for the fragment manager
 * @param always If {@code true}, all fragments update their state, even
 * if {@code newState} matches the current fragment manager's state.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,4",2,"The late implementation introduces an exception handling statement (throw new IllegalStateException(""No activity"")), an early return based on a condition (if (!always && mCurState == newState)), and various assignments and control flow changes. Hence, the code change involves exception handling statement change, control dependency change, and other changes.","The introduction of a new exception handling statement could lead to a Compatibility Issue if the condition (if (mHost == null && newState != Fragment.INITIALIZING)) is met, causing the late implementation to throw an IllegalStateException where the early version would not. This is a CI caused by potentially different exception handlings, denoted as CI type 2."
208,<android.app.PendingIntent: int getCreatorUid()>,25,26,<android.app.PendingIntent: int getCreatorUid()>,<android.app.PendingIntent: int getCreatorUid()>,0,"{
    try {
        return ActivityManagerNative.getDefault().getUidForIntentSender(mTarget);
    } catch (RemoteException e) {
        // Should never happen.
        return -1;
    }
}","{
    try {
        return ActivityManager.getService().getUidForIntentSender(mTarget);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Return the uid of the application that created this
 * PendingIntent, that is the identity under which you will actually be
 * sending the Intent.  The returned integer is supplied by the system, so
 * that an application can not spoof its uid.
 *
 * <p class=""note"">Be careful about how you use this.  All this tells you is
 * who created the PendingIntent.  It does <strong>not</strong> tell you who
 * handed the PendingIntent to you: that is, PendingIntent objects are intended to be
 * passed between applications, so the PendingIntent you receive from an application
 * could actually be one it received from another application, meaning the result
 * you get here will identify the original application.  Because of this, you should
 * only use this information to identify who you expect to be interacting with
 * through a {@link #send} call, not who gave you the PendingIntent.</p>
 *
 * @return The uid of the PendingIntent, or -1 if there is
 * none associated with it.
 */
","/**
 * Return the uid of the application that created this
 * PendingIntent, that is the identity under which you will actually be
 * sending the Intent.  The returned integer is supplied by the system, so
 * that an application can not spoof its uid.
 *
 * <p class=""note"">Be careful about how you use this.  All this tells you is
 * who created the PendingIntent.  It does <strong>not</strong> tell you who
 * handed the PendingIntent to you: that is, PendingIntent objects are intended to be
 * passed between applications, so the PendingIntent you receive from an application
 * could actually be one it received from another application, meaning the result
 * you get here will identify the original application.  Because of this, you should
 * only use this information to identify who you expect to be interacting with
 * through a {@link #send} call, not who gave you the PendingIntent.</p>
 *
 * @return The uid of the PendingIntent, or -1 if there is
 * none associated with it.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4,5",2,"The method call within the return statement has been altered from `ActivityManagerNative.getDefault().getUidForIntentSender(mTarget)` to `ActivityManager.getService().getUidForIntentSender(mTarget)`, which indicates a change in the dependent API (5). Also, the exception handling has changed from returning -1 to throwing rethrowFromSystemServer(), which is a change in the exception handling statement (2). Additionally, the underlying method called has changed from `getDefault()` to `getService()`, which is an other statement change (4).","The change could lead to CI because the late version of the method throws an exception, whereas the early version returns a default value (-1) when a RemoteException occurs. This is an example where exception handling has changed and could lead to a different behavior (2)."
210,<android.app.ContextImpl: Theme getTheme()>,25,26,<android.app.ContextImpl: Theme getTheme()>,<android.app.ContextImpl: Theme getTheme()>,0,"{
    if (mTheme != null) {
        return mTheme;
    }
    mThemeResource = Resources.selectDefaultTheme(mThemeResource, getOuterContext().getApplicationInfo().targetSdkVersion);
    initializeTheme();
    return mTheme;
}","{
    synchronized (mSync) {
        if (mTheme != null) {
            return mTheme;
        }
        mThemeResource = Resources.selectDefaultTheme(mThemeResource, getOuterContext().getApplicationInfo().targetSdkVersion);
        initializeTheme();
        return mTheme;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,"The change is the introduction of a synchronized block around the existing code, which does not affect the return value or exception handling of the method, so the code change type is 3.","Although synchronization has been added to the method, it doesn't lead to a CI in terms of behavior because it does not change the return value or exception throwing behavior of the API; it just adds thread safety. Therefore, the CI type is 0."
212,<android.app.FragmentManagerImpl: Fragment findFragmentByTag(String)>,25,26,<android.app.FragmentManagerImpl: Fragment findFragmentByTag(String)>,<android.app.FragmentManagerImpl: Fragment findFragmentByTag(String)>,0,"{
    if (mAdded != null && tag != null) {
        // First look through added fragments.
        for (int i = mAdded.size() - 1; i >= 0; i--) {
            Fragment f = mAdded.get(i);
            if (f != null && tag.equals(f.mTag)) {
                return f;
            }
        }
    }
    if (mActive != null && tag != null) {
        // Now for any known fragment.
        for (int i = mActive.size() - 1; i >= 0; i--) {
            Fragment f = mActive.get(i);
            if (f != null && tag.equals(f.mTag)) {
                return f;
            }
        }
    }
    return null;
}","{
    if (mAdded != null && tag != null) {
        // First look through added fragments.
        for (int i = mAdded.size() - 1; i >= 0; i--) {
            Fragment f = mAdded.get(i);
            if (f != null && tag.equals(f.mTag)) {
                return f;
            }
        }
    }
    if (mActive != null && tag != null) {
        // Now for any known fragment.
        for (int i = mActive.size() - 1; i >= 0; i--) {
            Fragment f = mActive.valueAt(i);
            if (f != null && tag.equals(f.mTag)) {
                return f;
            }
        }
    }
    return null;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"There is a method change from 'get(i)' to 'valueAt(i)' for the mActive collection access, which likely indicates a change in the underlying data structure. This alteration corresponds to code change types 4 (Other statement changed) and 5 (Dependent API changed) because 'get(i)' and 'valueAt(i)' are typically used for different types of collections in Android (List and SparseArray respectively).","Since the method of accessing elements from mActive has changed, if the underlying data structure of mActive has changed to a different type that requires 'valueAt(i)' instead of 'get(i)', the fragments returned by 'findFragmentByTag' could potentially be different between the two versions. Thus, there could be a Compatibility Issue of type 1 (Compatibility Issue caused by potential different return values)."
213,<android.app.ActivityManager: void getMemoryInfo(MemoryInfo)>,25,26,<android.app.ActivityManager: void getMemoryInfo(MemoryInfo)>,<android.app.ActivityManager: void getMemoryInfo(MemoryInfo)>,0,"{
    try {
        ActivityManagerNative.getDefault().getMemoryInfo(outInfo);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        getService().getMemoryInfo(outInfo);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Return general information about the memory state of the system.  This
 * can be used to help decide how to manage your own memory, though note
 * that polling is not recommended and
 * {@link android.content.ComponentCallbacks2#onTrimMemory(int)
 * ComponentCallbacks2.onTrimMemory(int)} is the preferred way to do this.
 * Also see {@link #getMyMemoryState} for how to retrieve the current trim
 * level of your process as needed, which gives a better hint for how to
 * manage its memory.
 */
","/**
 * Return general information about the memory state of the system.  This
 * can be used to help decide how to manage your own memory, though note
 * that polling is not recommended and
 * {@link android.content.ComponentCallbacks2#onTrimMemory(int)
 * ComponentCallbacks2.onTrimMemory(int)} is the preferred way to do this.
 * Also see {@link #getMyMemoryState} for how to retrieve the current trim
 * level of your process as needed, which gives a better hint for how to
 * manage its memory.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"Dependent API changed from ActivityManagerNative.getDefault().getMemoryInfo(outInfo) to getService().getMemoryInfo(outInfo), the API that's being called to get the service instance has changed; hence, the code change type is 5.","Since the try-catch block remains the same and the method signature of 'getMemoryInfo' doesn't seem to be different as well, assuming getService() returns a valid service instance like ActivityManagerNative.getDefault() used to do, the change should not cause any different behavior from the point of view of the client code. Therefore, the CI type is 0."
214,<android.preference.Preference: Drawable getIcon()>,25,26,<android.preference.Preference: Drawable getIcon()>,<android.preference.Preference: Drawable getIcon()>,0,"{
    return mIcon;
}","{
    if (mIcon == null && mIconResId != 0) {
        mIcon = getContext().getDrawable(mIconResId);
    }
    return mIcon;
}",1,"/**
 * Returns the icon of this Preference.
 *
 * @return The icon.
 * @see #setIcon(Drawable)
 */
","/**
 * Returns the icon of this Preference.
 *
 * @return the icon
 * @see #setIcon(Drawable)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The late version implementation adds an `if` control statement to conditionally set the `mIcon`, which was not present in the early version. Therefore, there is a control dependency change (the `if` statement) as well as a potential return statement change since `mIcon` can be initialized now based on `mIconResId`. This qualifies as change types 1 and 3.","Since the new control flow (the `if` statement) can potentially initialize `mIcon`, the late version of the method may return a different drawable object when `mIcon` was previously null and `mIconResId` is not zero. This qualifies as a compatibility issue caused by the API potentially returning different values (type 1)."
215,<android.view.inputmethod.InputMethodManager.ControlledInputConnectionWrapper: String toString()>,25,26,<android.view.inputmethod.InputMethodManager.ControlledInputConnectionWrapper: String toString()>,<android.view.inputmethod.InputMethodManager.ControlledInputConnectionWrapper: String toString()>,0,"{
    return ""ControlledInputConnectionWrapper{"" + ""connection="" + getInputConnection() + "" finished="" + isFinished() + "" mParentInputMethodManager.mActive="" + mParentInputMethodManager.mActive + "" mInputMethodId="" + getInputMethodId() + ""}"";
}","{
    return ""ControlledInputConnectionWrapper{"" + ""connection="" + getInputConnection() + "" finished="" + isFinished() + "" mParentInputMethodManager.mActive="" + mParentInputMethodManager.mActive + ""}"";
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"A part of the `return` statement inside the `toString()` method which includes ""+ mInputMethodId="" + getInputMethodId()"" has been removed, and there are no other change types applicable, so the change class is 1.","The removal of ""+ mInputMethodId="" + getInputMethodId()"" from the return statement will change the return value of the `toString()` method, hence a potential Compatibility Issue caused by different return values is introduced, which is of type 1."
216,<android.animation.AnimatorSet: void resume()>,25,26,<android.animation.AnimatorSet: void resume()>,<android.animation.AnimatorSet: void resume()>,0,"{
    boolean previouslyPaused = mPaused;
    super.resume();
    if (previouslyPaused && !mPaused) {
        if (mDelayAnim.isStarted()) {
            // If start delay hasn't passed, resume the previously paused start delay animator
            mDelayAnim.resume();
        } else {
            int size = mNodes.size();
            for (int i = 0; i < size; i++) {
                Node node = mNodes.get(i);
                if (node != mRootNode) {
                    node.mAnimation.resume();
                }
            }
        }
    }
}","{
    if (Looper.myLooper() == null) {
        throw new AndroidRuntimeException(""Animators may only be run on Looper threads"");
    }
    boolean previouslyPaused = mPaused;
    super.resume();
    if (previouslyPaused && !mPaused) {
        if (mPauseTime >= 0) {
            addAnimationCallback(0);
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",0,"There's a new exception handling check that throws an AndroidRuntimeException and a change in the control flow and other statements: the mDelayAnim is not resumed, and loop that resumes each node's animation is removed, with another condition and method call (addAnimationCallback(0)) introduced. Therefore, the code change type is 1,3,4.","Although the implementation has substantially changed, including the addition of a new exception handling statement that could affect the compatibility, these changes do not directly lead to different return types or values (since the method returns void) nor different exceptions being thrown during normal operation; the new exception is thrown only when the AnimatorSet is attempted to be run on a non-Looper thread, which would not be a normal expected operating condition. As the newly introduced exception condition is aimed at ensuring the method is used correctly, it should not be counted as a Compatibility Issue for existing correct usages; it adds a constraint for all future usages. Thus, there is no Compatibility Issue."
217,"<android.os.Binder: void doDump(FileDescriptor,PrintWriter,String[])>",25,26,"<android.os.Binder: void doDump(FileDescriptor,PrintWriter,String[])>","<android.os.Binder: void doDump(FileDescriptor,PrintWriter,String[])>",0,"{
    final String disabled;
    synchronized (Binder.class) {
        disabled = sDumpDisabled;
    }
    if (disabled == null) {
        try {
            dump(fd, pw, args);
        } catch (SecurityException e) {
            pw.println(""Security exception: "" + e.getMessage());
            throw e;
        } catch (Throwable e) {
            // Unlike usual calls, in this case if an exception gets thrown
            // back to us we want to print it back in to the dump data, since
            // that is where the caller expects all interesting information to
            // go.
            pw.println();
            pw.println(""Exception occurred while dumping:"");
            e.printStackTrace(pw);
        }
    } else {
        pw.println(sDumpDisabled);
    }
}","{
    final String disabled = sDumpDisabled;
    if (disabled == null) {
        try {
            dump(fd, pw, args);
        } catch (SecurityException e) {
            pw.println(""Security exception: "" + e.getMessage());
            throw e;
        } catch (Throwable e) {
            // Unlike usual calls, in this case if an exception gets thrown
            // back to us we want to print it back in to the dump data, since
            // that is where the caller expects all interesting information to
            // go.
            pw.println();
            pw.println(""Exception occurred while dumping:"");
            e.printStackTrace(pw);
        }
    } else {
        pw.println(sDumpDisabled);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change is in the way the variable 'disabled' is initialized: it is directly assigned from 'sDumpDisabled' instead of being assigned within a synchronized block. This is an 'other statement changed' without altering any functional behavior of the method, classified as change type 4.","There is no Compatibility Issue since the change does not affect the return value or exception handling of the method. The method's behavior remains functionally identical from the caller's perspective, so CI type is 0."
219,<android.widget.AbsListView: void handleBoundsChange()>,25,26,<android.widget.AbsListView: void handleBoundsChange()>,<android.widget.AbsListView: void handleBoundsChange()>,0,"{
    final int childCount = getChildCount();
    if (childCount > 0) {
        mDataChanged = true;
        rememberSyncState();
        for (int i = 0; i < childCount; i++) {
            final View child = getChildAt(i);
            final ViewGroup.LayoutParams lp = child.getLayoutParams();
            // force layout child unless it has exact specs
            if (lp == null || lp.width < 1 || lp.height < 1) {
                child.forceLayout();
            }
        }
    }
}","{
    if (mInLayout) {
        return;
    }
    final int childCount = getChildCount();
    if (childCount > 0) {
        mDataChanged = true;
        rememberSyncState();
        for (int i = 0; i < childCount; i++) {
            final View child = getChildAt(i);
            final ViewGroup.LayoutParams lp = child.getLayoutParams();
            // force layout child unless it has exact specs
            if (lp == null || lp.width < 1 || lp.height < 1) {
                child.forceLayout();
            }
        }
    }
}",1,"/**
 * Called when bounds of the AbsListView are changed. AbsListView marks data set as changed
 * and force layouts all children that don't have exact measure specs.
 * <p>
 * This invalidation is necessary, otherwise, AbsListView may think the children are valid and
 * fail to relayout them properly to accommodate for new bounds.
 */
","/**
 * Called when bounds of the AbsListView are changed. AbsListView marks data set as changed
 * and force layouts all children that don't have exact measure specs.
 * <p>
 * This invalidation is necessary, otherwise, AbsListView may think the children are valid and
 * fail to relayout them properly to accommodate for new bounds.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"A check for `mInLayout` and an early return (`return;`) statement have been introduced before the rest of the method's execution. This is a control dependency change, classified as 3.","There is no compatibility issue caused by this change, because the new early return only affects the method execution when `mInLayout` is true. In a normal situation where the method should execute its logic, it will proceed exactly as before. Therefore, in the context where the method should have an effect, its behavior remains consistent with the earlier version."
221,<android.widget.TextView: void setKeyListener(KeyListener)>,25,26,<android.widget.TextView: void setKeyListener(KeyListener)>,<android.widget.TextView: void setKeyListener(KeyListener)>,0,"{
    setKeyListenerOnly(input);
    fixFocusableAndClickableSettings();
    if (input != null) {
        createEditorIfNeeded();
        try {
            mEditor.mInputType = mEditor.mKeyListener.getInputType();
        } catch (IncompatibleClassChangeError e) {
            mEditor.mInputType = EditorInfo.TYPE_CLASS_TEXT;
        }
        // Change inputType, without affecting transformation.
        // No need to applySingleLine since mSingleLine is unchanged.
        setInputTypeSingleLine(mSingleLine);
    } else {
        if (mEditor != null)
            mEditor.mInputType = EditorInfo.TYPE_NULL;
    }
    InputMethodManager imm = InputMethodManager.peekInstance();
    if (imm != null)
        imm.restartInput(this);
}","{
    mListenerChanged = true;
    setKeyListenerOnly(input);
    fixFocusableAndClickableSettings();
    if (input != null) {
        createEditorIfNeeded();
        setInputTypeFromEditor();
    } else {
        if (mEditor != null)
            mEditor.mInputType = EditorInfo.TYPE_NULL;
    }
    InputMethodManager imm = InputMethodManager.peekInstance();
    if (imm != null)
        imm.restartInput(this);
}",1,"/**
 * Sets the key listener to be used with this TextView.  This can be null
 * to disallow user input.  Note that this method has significant and
 * subtle interactions with soft keyboards and other input method:
 * see {@link KeyListener#getInputType() KeyListener.getContentType()}
 * for important details.  Calling this method will replace the current
 * content type of the text view with the content type returned by the
 * key listener.
 * <p>
 * Be warned that if you want a TextView with a key listener or movement
 * method not to be focusable, or if you want a TextView without a
 * key listener or movement method to be focusable, you must call
 * {@link #setFocusable} again after calling this to get the focusability
 * back the way you want it.
 *
 * @attr ref android.R.styleable#TextView_numeric
 * @attr ref android.R.styleable#TextView_digits
 * @attr ref android.R.styleable#TextView_phoneNumber
 * @attr ref android.R.styleable#TextView_inputMethod
 * @attr ref android.R.styleable#TextView_capitalize
 * @attr ref android.R.styleable#TextView_autoText
 */
","/**
 * Sets the key listener to be used with this TextView.  This can be null
 * to disallow user input.  Note that this method has significant and
 * subtle interactions with soft keyboards and other input method:
 * see {@link KeyListener#getInputType() KeyListener.getContentType()}
 * for important details.  Calling this method will replace the current
 * content type of the text view with the content type returned by the
 * key listener.
 * <p>
 * Be warned that if you want a TextView with a key listener or movement
 * method not to be focusable, or if you want a TextView without a
 * key listener or movement method to be focusable, you must call
 * {@link #setFocusable} again after calling this to get the focusability
 * back the way you want it.
 *
 * @attr ref android.R.styleable#TextView_numeric
 * @attr ref android.R.styleable#TextView_digits
 * @attr ref android.R.styleable#TextView_phoneNumber
 * @attr ref android.R.styleable#TextView_inputMethod
 * @attr ref android.R.styleable#TextView_capitalize
 * @attr ref android.R.styleable#TextView_autoText
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,The method implementation has several changes:,- The call to `setInputTypeSingleLine(mSingleLine);` has been removed in the late version. This indicates an other statement change.
222,<android.preference.PreferenceGroup: boolean addPreference(Preference)>,25,26,<android.preference.PreferenceGroup: boolean addPreference(Preference)>,<android.preference.PreferenceGroup: boolean addPreference(Preference)>,0,"{
    if (mPreferenceList.contains(preference)) {
        // Exists
        return true;
    }
    if (preference.getOrder() == Preference.DEFAULT_ORDER) {
        if (mOrderingAsAdded) {
            preference.setOrder(mCurrentPreferenceOrder++);
        }
        if (preference instanceof PreferenceGroup) {
            // TODO: fix (method is called tail recursively when inflating,
            // so we won't end up properly passing this flag down to children
            ((PreferenceGroup) preference).setOrderingAsAdded(mOrderingAsAdded);
        }
    }
    if (!onPrepareAddPreference(preference)) {
        return false;
    }
    synchronized (this) {
        int insertionIndex = Collections.binarySearch(mPreferenceList, preference);
        if (insertionIndex < 0) {
            insertionIndex = insertionIndex * -1 - 1;
        }
        mPreferenceList.add(insertionIndex, preference);
    }
    preference.onAttachedToHierarchy(getPreferenceManager());
    if (mAttachedToActivity) {
        preference.onAttachedToActivity();
    }
    notifyHierarchyChanged();
    return true;
}","{
    if (mPreferenceList.contains(preference)) {
        // Exists
        return true;
    }
    if (preference.getOrder() == Preference.DEFAULT_ORDER) {
        if (mOrderingAsAdded) {
            preference.setOrder(mCurrentPreferenceOrder++);
        }
        if (preference instanceof PreferenceGroup) {
            // TODO: fix (method is called tail recursively when inflating,
            // so we won't end up properly passing this flag down to children
            ((PreferenceGroup) preference).setOrderingAsAdded(mOrderingAsAdded);
        }
    }
    if (!onPrepareAddPreference(preference)) {
        return false;
    }
    synchronized (this) {
        int insertionIndex = Collections.binarySearch(mPreferenceList, preference);
        if (insertionIndex < 0) {
            insertionIndex = insertionIndex * -1 - 1;
        }
        mPreferenceList.add(insertionIndex, preference);
    }
    preference.onAttachedToHierarchy(getPreferenceManager());
    preference.assignParent(this);
    if (mAttachedToActivity) {
        preference.onAttachedToActivity();
    }
    notifyHierarchyChanged();
    return true;
}",1,"/**
 * Adds a {@link Preference} at the correct position based on the
 * preference's order.
 *
 * @param preference The preference to add.
 * @return Whether the preference is now in this group.
 */
","/**
 * Adds a {@link Preference} at the correct position based on the
 * preference's order.
 *
 * @param preference The preference to add.
 * @return Whether the preference is now in this group.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"A new method call, preference.assignParent(this), has been introduced in the late version, so the code has changed under the ""Other statement changed"" category, which is 4.","The addition of preference.assignParent(this) will not lead to a CI according to the given rules. This method call does presumably alter the internal state of the 'preference' object by setting its parent, but it does not affect the method's behavior in terms of its return value or exception throwing, which is what Compatibility Issue considers according to the provided definitions. Therefore, the result is 0, no Compatibility Issue."
223,<android.widget.Toast.TN: void handleHide()>,25,26,<android.widget.Toast.TN: void handleHide()>,<android.widget.Toast.TN: void handleHide()>,0,"{
    if (localLOGV)
        Log.v(TAG, ""HANDLE HIDE: "" + this + "" mView="" + mView);
    if (mView != null) {
        // the view isn't yet added, so let's try not to crash.
        if (mView.getParent() != null) {
            if (localLOGV)
                Log.v(TAG, ""REMOVE! "" + mView + "" in "" + this);
            mWM.removeView(mView);
        }
        mView = null;
    }
}","{
    if (localLOGV)
        Log.v(TAG, ""HANDLE HIDE: "" + this + "" mView="" + mView);
    if (mView != null) {
        // the view isn't yet added, so let's try not to crash.
        if (mView.getParent() != null) {
            if (localLOGV)
                Log.v(TAG, ""REMOVE! "" + mView + "" in "" + this);
            mWM.removeViewImmediate(mView);
        }
        mView = null;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"There is a change in an invoked method within the if condition: changing from ""mWM.removeView(mView);"" to ""mWM.removeViewImmediate(mView);"". This is the Other statement changed and the Dependent API changed, which is reflected in code change type 4,5.","The method ""removeView()"" has been replaced with ""removeViewImmediate()"", but this does not lead to a Compatibility Issue because the method call itself is designed to remove a view from the window manager. Both methods achieve the same objective with respect to the API's functionality, and while their internal implementations might differ (for example, ""removeViewImmediate()"" might remove the view instantly while ""removeView()"" might do so in a more deferred way), the behavior from the perspective of the API calling this method remains unchanged. Therefore, there's no Compatibility Issue, which is CI type 0."
225,<android.widget.TabHost: TabSpec newTabSpec(String)>,25,26,<android.widget.TabHost: TabSpec newTabSpec(String)>,<android.widget.TabHost: TabSpec newTabSpec(String)>,0,"{
    return new TabSpec(tag);
}","{
    if (tag == null) {
        throw new IllegalArgumentException(""tag must be non-null"");
    }
    return new TabSpec(tag);
}",1,"/**
 * Get a new {@link TabSpec} associated with this tab host.
 * @param tag required tag of tab.
 */
","/**
 * Creates a new {@link TabSpec} associated with this tab host.
 *
 * @param tag tag for the tab specification, must be non-null
 * @throws IllegalArgumentException If the passed tag is null
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,"2,3,5",2,"The late version introduces a new check for the parameter `tag` with a throw statement which throws an exception if `tag` is null. The `@NonNull` annotation is also added to enforce that `tag` should be non-null. The modified code includes changes for exception handling statement (2), control dependency change (3), and dependent API changed due to the added annotation (5).","The introduction of the new condition and subsequent throw statement could lead to different exception handling behavior compared to the early version. In the early version, the constructor of TabSpec could potentially handle a null `tag`, while the late version will explicitly throw an IllegalArgumentException instead. Hence, the change leads to Compatibility Issue type 2 because of different exception handlings."
227,<android.content.ContentValues: Boolean getAsBoolean(String)>,25,26,<android.content.ContentValues: Boolean getAsBoolean(String)>,<android.content.ContentValues: Boolean getAsBoolean(String)>,0,"{
    Object value = mValues.get(key);
    try {
        return (Boolean) value;
    } catch (ClassCastException e) {
        if (value instanceof CharSequence) {
            return Boolean.valueOf(value.toString());
        } else if (value instanceof Number) {
            return ((Number) value).intValue() != 0;
        } else {
            Log.e(TAG, ""Cannot cast value for "" + key + "" to a Boolean: "" + value, e);
            return null;
        }
    }
}","{
    Object value = mValues.get(key);
    try {
        return (Boolean) value;
    } catch (ClassCastException e) {
        if (value instanceof CharSequence) {
            // false.
            return Boolean.valueOf(value.toString()) || ""1"".equals(value);
        } else if (value instanceof Number) {
            return ((Number) value).intValue() != 0;
        } else {
            Log.e(TAG, ""Cannot cast value for "" + key + "" to a Boolean: "" + value, e);
            return null;
        }
    }
}",1,"/**
 * Gets a value and converts it to a Boolean.
 *
 * @param key the value to get
 * @return the Boolean value, or {@code null} if the value is missing or cannot be converted
 */
","/**
 * Gets a value and converts it to a Boolean.
 *
 * @param key the value to get
 * @return the Boolean value, or {@code null} if the value is missing or cannot be converted
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change involves an additional condition `|| ""1"".equals(value)` which is added to return a boolean value if the string value is ""1"", so the code change type is 4.","Despite the additional condition in the catch block, this condition does not introduce a new return value for any inputs that would have previously worked without error. If `value.toString()` is ""true"", `Boolean.valueOf(value.toString())` will be `true` and the new condition `""1"".equals(value)` will not be evaluated due to short-circuiting of logical OR. If `value.toString()` is not ""true"" and is ""1"" instead, the new condition will return `true` where the previous implementation would have returned `false`. However, this change is consistent with the generalized intent of converting string representations of booleans to their corresponding boolean values, so it does not constitute a compatibility issue; it is a permissible clarification or bug fix. As a result, based on the defined rules, this does not lead to a compatibility issue because `getAsBoolean` is expected to interpret strings like ""1"" as `true`, which is a common practice in many data type conversions. This doesn't make the API behave differently in an unexpected manner relative to its original contract; it would just fix a potential unexpected behavior."
229,"<android.app.backup.BackupAgent.BackupServiceBinder: void doRestore(ParcelFileDescriptor,int,ParcelFileDescriptor,int,IBackupManager)>",25,26,"<android.app.backup.BackupAgent.BackupServiceBinder: void doRestore(ParcelFileDescriptor,int,ParcelFileDescriptor,int,IBackupManager)>","<android.app.backup.BackupAgent.BackupServiceBinder: void doRestore(ParcelFileDescriptor,int,ParcelFileDescriptor,int,IBackupManager)>",0,"{
    // Ensure that we're running with the app's normal permission level
    long ident = Binder.clearCallingIdentity();
    if (DEBUG)
        Log.v(TAG, ""doRestore() invoked"");
    BackupDataInput input = new BackupDataInput(data.getFileDescriptor());
    try {
        BackupAgent.this.onRestore(input, appVersionCode, newState);
    } catch (IOException ex) {
        Log.d(TAG, ""onRestore ("" + BackupAgent.this.getClass().getName() + "") threw"", ex);
        throw new RuntimeException(ex);
    } catch (RuntimeException ex) {
        Log.d(TAG, ""onRestore ("" + BackupAgent.this.getClass().getName() + "") threw"", ex);
        throw ex;
    } finally {
        // Ensure that any side-effect SharedPreferences writes have landed
        waitForSharedPrefs();
        Binder.restoreCallingIdentity(ident);
        try {
            callbackBinder.opComplete(token, 0);
        } catch (RemoteException e) {
        // we'll time out anyway, so we're safe
        }
    }
}","{
    // Ensure that we're running with the app's normal permission level
    long ident = Binder.clearCallingIdentity();
    if (DEBUG)
        Log.v(TAG, ""doRestore() invoked"");
    BackupDataInput input = new BackupDataInput(data.getFileDescriptor());
    try {
        BackupAgent.this.onRestore(input, appVersionCode, newState);
    } catch (IOException ex) {
        Log.d(TAG, ""onRestore ("" + BackupAgent.this.getClass().getName() + "") threw"", ex);
        throw new RuntimeException(ex);
    } catch (RuntimeException ex) {
        Log.d(TAG, ""onRestore ("" + BackupAgent.this.getClass().getName() + "") threw"", ex);
        throw ex;
    } finally {
        // Ensure that any side-effect SharedPreferences writes have landed
        waitForSharedPrefs();
        Binder.restoreCallingIdentity(ident);
        try {
            callbackBinder.opComplete(token, 0);
        } catch (RemoteException e) {
        // we'll time out anyway, so we're safe
        }
        if (Binder.getCallingPid() != Process.myPid()) {
            IoUtils.closeQuietly(data);
            IoUtils.closeQuietly(newState);
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The code change involves the addition of two lines to close resources `IoUtils.closeQuietly(data)` and `IoUtils.closeQuietly(newState)` within a conditional block that checks if the calling process is not the same as the process running the method, before the closing braces of the `finally` block. Therefore, this is an ""Other statement changed"" case, type 4.","The addition of closing resources does not affect the return values or exception handling of the method, as these lines are called in a `finally` block after all other operations have concluded and are only cleaning up resources before the method exits. Thus, there is no Compatibility Issue, 0."
232,<android.widget.TextView: void sendAfterTextChanged(Editable)>,25,26,<android.widget.TextView: void sendAfterTextChanged(Editable)>,<android.widget.TextView: void sendAfterTextChanged(Editable)>,0,"{
    if (mListeners != null) {
        final ArrayList<TextWatcher> list = mListeners;
        final int count = list.size();
        for (int i = 0; i < count; i++) {
            list.get(i).afterTextChanged(text);
        }
    }
    hideErrorIfUnchanged();
}","{
    if (mListeners != null) {
        final ArrayList<TextWatcher> list = mListeners;
        final int count = list.size();
        for (int i = 0; i < count; i++) {
            list.get(i).afterTextChanged(text);
        }
    }
    // Always notify AutoFillManager - it will return right away if autofill is disabled.
    notifyAutoFillManagerAfterTextChangedIfNeeded();
    hideErrorIfUnchanged();
}",1,"/**
 * Not private so it can be called from an inner class without going
 * through a thunk.
 */
","/**
 * Not private so it can be called from an inner class without going
 * through a thunk.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"A new method call notifyAutoFillManagerAfterTextChangedIfNeeded() is added before hideErrorIfUnchanged(). This is an additional operation which does not change the return type, the exception handling, or control flow, so the change type is 4.","The additional operation does not affect any existing behavior related to return values or exception handling, and is designed to return immediately if not applicable. It doesn't cause the method to return a different value or throw a new exception, so no Compatibility Issue arises, thus CI type is 0."
233,<android.content.ClipData.Item: CharSequence coerceToText(Context)>,25,26,<android.content.ClipData.Item: CharSequence coerceToText(Context)>,<android.content.ClipData.Item: CharSequence coerceToText(Context)>,0,"{
    // If this Item has an explicit textual value, simply return that.
    CharSequence text = getText();
    if (text != null) {
        return text;
    }
    // If this Item has a URI value, try using that.
    Uri uri = getUri();
    if (uri != null) {
        // First see if the URI can be opened as a plain text stream
        // (of any sub-type).  If so, this is the best textual
        // representation for it.
        FileInputStream stream = null;
        try {
            // Ask for a stream of the desired type.
            AssetFileDescriptor descr = context.getContentResolver().openTypedAssetFileDescriptor(uri, ""text/*"", null);
            stream = descr.createInputStream();
            InputStreamReader reader = new InputStreamReader(stream, ""UTF-8"");
            // Got it...  copy the stream into a local string and return it.
            StringBuilder builder = new StringBuilder(128);
            char[] buffer = new char[8192];
            int len;
            while ((len = reader.read(buffer)) > 0) {
                builder.append(buffer, 0, len);
            }
            return builder.toString();
        } catch (FileNotFoundException e) {
        // Unable to open content URI as text...  not really an
        // error, just something to ignore.
        } catch (IOException e) {
            // Something bad has happened.
            Log.w(""ClipData"", ""Failure loading text"", e);
            return e.toString();
        } finally {
            if (stream != null) {
                try {
                    stream.close();
                } catch (IOException e) {
                }
            }
        }
        // probably serves fairly well as a textual representation.
        return uri.toString();
    }
    // Finally, if all we have is an Intent, then we can just turn that
    // into text.  Not the most user-friendly thing, but it's something.
    Intent intent = getIntent();
    if (intent != null) {
        return intent.toUri(Intent.URI_INTENT_SCHEME);
    }
    // Shouldn't get here, but just in case...
    return """";
}","{
    // If this Item has an explicit textual value, simply return that.
    CharSequence text = getText();
    if (text != null) {
        return text;
    }
    // If this Item has a URI value, try using that.
    Uri uri = getUri();
    if (uri != null) {
        // First see if the URI can be opened as a plain text stream
        // (of any sub-type).  If so, this is the best textual
        // representation for it.
        FileInputStream stream = null;
        try {
            // Ask for a stream of the desired type.
            AssetFileDescriptor descr = context.getContentResolver().openTypedAssetFileDescriptor(uri, ""text/*"", null);
            stream = descr.createInputStream();
            InputStreamReader reader = new InputStreamReader(stream, ""UTF-8"");
            // Got it...  copy the stream into a local string and return it.
            StringBuilder builder = new StringBuilder(128);
            char[] buffer = new char[8192];
            int len;
            while ((len = reader.read(buffer)) > 0) {
                builder.append(buffer, 0, len);
            }
            return builder.toString();
        } catch (SecurityException e) {
            Log.w(""ClipData"", ""Failure opening stream"", e);
        } catch (FileNotFoundException e) {
        // Unable to open content URI as text...  not really an
        // error, just something to ignore.
        } catch (IOException e) {
            // Something bad has happened.
            Log.w(""ClipData"", ""Failure loading text"", e);
            return e.toString();
        } finally {
            if (stream != null) {
                try {
                    stream.close();
                } catch (IOException e) {
                }
            }
        }
        // If we couldn't open the URI as a stream, use the URI itself as a textual
        // representation (but not for ""content"", ""android.resource"" or ""file"" schemes).
        final String scheme = uri.getScheme();
        if (SCHEME_CONTENT.equals(scheme) || SCHEME_ANDROID_RESOURCE.equals(scheme) || SCHEME_FILE.equals(scheme)) {
            return """";
        }
        return uri.toString();
    }
    // Finally, if all we have is an Intent, then we can just turn that
    // into text.  Not the most user-friendly thing, but it's something.
    Intent intent = getIntent();
    if (intent != null) {
        return intent.toUri(Intent.URI_INTENT_SCHEME);
    }
    // Shouldn't get here, but just in case...
    return """";
}",1,"// BEGIN_INCLUDE(coerceToText)
","// BEGIN_INCLUDE(coerceToText)
",-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"The early version catches a FileNotFoundException and IOException without catching a SecurityException, while the late version introduces catching a SecurityException and changed the order of exceptions being caught. Additionally, there is now an extra conditional check on the URI's scheme before returning uri.toString() or an empty string, which marks it as a control dependency change as well. Thus the code change type includes 2 and 3.","The newly introduced catch for SecurityException which logs a warning and does not return from the method could potentially lead to different exception behaviors compared to the early version. If a SecurityException occurs now, it no longer returns an empty string directly as the last version did for IOException, instead, the function continues which could lead to a different return value based on the following code. Also, the new conditional check on the URI's scheme that returns an empty string for certain schemes where previously it would return uri.toString() could lead to different return values. This means the CI type includes 2 due to the different exception handling and potentially 1 since the return value can be different when the URI scheme is one of the specified ones. However, since this change is due to a control structure modification and based on the functionality logic rather than a direct change in return statements, type 1 is not marked directly. Hence, the predominant CI type is 2."
234,"<android.hardware.camera2.impl.CameraDeviceImpl: void createConstrainedHighSpeedCaptureSession(List<Surface>,StateCallback,Handler)>",25,26,"<android.hardware.camera2.impl.CameraDeviceImpl: void createConstrainedHighSpeedCaptureSession(List<Surface>,StateCallback,Handler)>","<android.hardware.camera2.impl.CameraDeviceImpl: void createConstrainedHighSpeedCaptureSession(List<Surface>,StateCallback,Handler)>",0,"{
    if (outputs == null || outputs.size() == 0 || outputs.size() > 2) {
        throw new IllegalArgumentException(""Output surface list must not be null and the size must be no more than 2"");
    }
    StreamConfigurationMap config = getCharacteristics().get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);
    SurfaceUtils.checkConstrainedHighSpeedSurfaces(outputs, /*fpsRange*/
    null, config);
    List<OutputConfiguration> outConfigurations = new ArrayList<>(outputs.size());
    for (Surface surface : outputs) {
        outConfigurations.add(new OutputConfiguration(surface));
    }
    createCaptureSessionInternal(null, outConfigurations, callback, handler, /*isConstrainedHighSpeed*/
    true);
}","{
    if (outputs == null || outputs.size() == 0 || outputs.size() > 2) {
        throw new IllegalArgumentException(""Output surface list must not be null and the size must be no more than 2"");
    }
    StreamConfigurationMap config = getCharacteristics().get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);
    SurfaceUtils.checkConstrainedHighSpeedSurfaces(outputs, /*fpsRange*/
    null, config);
    List<OutputConfiguration> outConfigurations = new ArrayList<>(outputs.size());
    for (Surface surface : outputs) {
        outConfigurations.add(new OutputConfiguration(surface));
    }
    createCaptureSessionInternal(null, outConfigurations, callback, handler, /*operatingMode*/
    ICameraDeviceUser.CONSTRAINED_HIGH_SPEED_MODE);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The changes are in the parameter passed to the method createCaptureSessionInternal() from true to ICameraDeviceUser.CONSTRAINED_HIGH_SPEED_MODE, which seems to be a constant integer value representing the operating mode. Since there are no return statements, control flow changes, or exception handling changes directly in the code, the related change is classified as 4 for other statement changes, and 5 because it changes the argument which may be defined in an API outside this method (dependent API changed) if the value of ICameraDeviceUser.CONSTRAINED_HIGH_SPEED_MODE is different from a plain true boolean value.","No Compatibility Issue should arise due to this change if ICameraDeviceUser.CONSTRAINED_HIGH_SPEED_MODE is semantically equivalent to the boolean value true. Since true was probably used as a flag indicating the operation is in high-speed mode, and the new constant is also expected to represent the same mode, there is no change in functionality. Thus the CI type is 0."
235,"<android.text.Layout: float getDesiredWidth(CharSequence,int,int,TextPaint)>",25,26,"<android.text.Layout: float getDesiredWidth(CharSequence,int,int,TextPaint)>","<android.text.Layout: float getDesiredWidth(CharSequence,int,int,TextPaint)>",0,"{
    float need = 0;
    int next;
    for (int i = start; i <= end; i = next) {
        next = TextUtils.indexOf(source, '\n', i, end);
        if (next < 0)
            next = end;
        // note, omits trailing paragraph char
        float w = measurePara(paint, source, i, next);
        if (w > need)
            need = w;
        next++;
    }
    return need;
}","{
    return getDesiredWidth(source, start, end, paint, TextDirectionHeuristics.FIRSTSTRONG_LTR);
}",1,"/**
 * Return how wide a layout must be in order to display the
 * specified text slice with one line per paragraph.
 */
","/**
 * Return how wide a layout must be in order to display the specified text slice with one
 * line per paragraph.
 *
 * <p>As of O, Uses
 * {@link TextDirectionHeuristics#FIRSTSTRONG_LTR} as the default text direction heuristics. In
 * the earlier versions uses {@link TextDirectionHeuristics#LTR} as the default.</p>
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The entire implementation of the method has changed from a loop that measures paragraphs within a CharSequence to a single call to another method getDesiredWidth with additional parameters, so the code change type is 1,5.","The change in implementation means the API can potentially return different values due to the new method and additional parameter (TextDirectionHeuristics.FIRSTSTRONG_LTR). This indicates a potential for different return values or types, so the CI type is 1."
237,"<android.view.View: boolean isOnScrollbar(float,float)>",25,26,"<android.view.View: boolean isOnScrollbar(float,float)>","<android.view.View: boolean isOnScrollbar(float,float)>",0,"{
    if (mScrollCache == null) {
        return false;
    }
    x += getScrollX();
    y += getScrollY();
    if (isVerticalScrollBarEnabled() && !isVerticalScrollBarHidden()) {
        final Rect bounds = mScrollCache.mScrollBarBounds;
        getVerticalScrollBarBounds(bounds);
        if (bounds.contains((int) x, (int) y)) {
            return true;
        }
    }
    if (isHorizontalScrollBarEnabled()) {
        final Rect bounds = mScrollCache.mScrollBarBounds;
        getHorizontalScrollBarBounds(bounds);
        if (bounds.contains((int) x, (int) y)) {
            return true;
        }
    }
    return false;
}","{
    if (mScrollCache == null) {
        return false;
    }
    x += getScrollX();
    y += getScrollY();
    if (isVerticalScrollBarEnabled() && !isVerticalScrollBarHidden()) {
        final Rect touchBounds = mScrollCache.mScrollBarTouchBounds;
        getVerticalScrollBarBounds(null, touchBounds);
        if (touchBounds.contains((int) x, (int) y)) {
            return true;
        }
    }
    if (isHorizontalScrollBarEnabled()) {
        final Rect touchBounds = mScrollCache.mScrollBarTouchBounds;
        getHorizontalScrollBarBounds(null, touchBounds);
        if (touchBounds.contains((int) x, (int) y)) {
            return true;
        }
    }
    return false;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The method calls to getVerticalScrollBarBounds and getHorizontalScrollBarBounds have changed by introducing a new null parameter, and the variable name changed from 'bounds' to 'touchBounds'. These are other statement changes and changes potentially affecting the dependent API type, hence the code change type is 4,5.","Since the dependent API getVerticalScrollBarBounds and getHorizontalScrollBarBounds may have changed behavior due to the new parameter, this could potentially lead to a different return value in the conditions checking if the bounds contain the given x and y. Therefore, the CI type is 1."
238,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getChild(int)>,25,26,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getChild(int)>,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getChild(int)>,0,"{
    enforceSealed();
    if (mChildNodeIds == null) {
        return null;
    }
    if (!canPerformRequestOverConnection(mSourceNodeId)) {
        return null;
    }
    final long childId = mChildNodeIds.get(index);
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mWindowId, childId, false, FLAG_PREFETCH_DESCENDANTS);
}","{
    enforceSealed();
    if (mChildNodeIds == null) {
        return null;
    }
    if (!canPerformRequestOverConnection(mSourceNodeId)) {
        return null;
    }
    final long childId = mChildNodeIds.get(index);
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mWindowId, childId, false, FLAG_PREFETCH_DESCENDANTS, null);
}",1,"/**
 * Get the child at given index.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @param index The child index.
 * @return The child node.
 *
 * @throws IllegalStateException If called outside of an AccessibilityService.
 */
","/**
 * Get the child at given index.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @param index The child index.
 * @return The child node.
 *
 * @throws IllegalStateException If called outside of an AccessibilityService.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The dependent API findAccessibilityNodeInfoByAccessibilityId(...) has added a new parameter, but the overall logic of the method remained unchanged. So the code change type is 4,5.","However, adding an extra parameter to the call to findAccessibilityNodeInfoByAccessibilityId(...) does not necessarily lead to a compatibility issue. The additional parameter does not alter the return type or value that the API provides to its callers in a way that would cause a change in behavior, assuming this new parameter is handled in a backward-compatible way within the findAccessibilityNodeInfoByAccessibilityId method itself. Therefore, there is no CI, and the CI type is 0."
239,"<android.view.ThreadedRenderer.ProcessInitializer: void init(Context,long)>",25,26,"<android.view.ThreadedRenderer.ProcessInitializer: void init(Context,long)>","<android.view.ThreadedRenderer.ProcessInitializer: void init(Context,long)>",0,"{
    if (mInitialized)
        return;
    mInitialized = true;
    initSched(context, renderProxy);
    initGraphicsStats(context, renderProxy);
    initAssetAtlas(context, renderProxy);
}","{
    if (mInitialized)
        return;
    mInitialized = true;
    mAppContext = context.getApplicationContext();
    initSched(context, renderProxy);
    initGraphicsStats();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,4",0,"Added a new assignment statement 'mAppContext = context.getApplicationContext();', a removed call to 'initAssetAtlas(context, renderProxy)', and a modification in the 'initGraphicsStats()' (removing the parameters), so the code change type is 1,4.","Although there are changes in the method, none of these changes result in different return values (since the method returns void) or different exception handlings. Since the early implementation does not throw any exceptions and neither does the late implementation, the changes don't introduce any differences in the exceptions thrown. Hence, there is no Compatibility Issue (CI type is 0)."
241,<android.app.Notification.WearableExtender: Builder extend(Builder)>,25,26,<android.app.Notification.WearableExtender: Builder extend(Builder)>,<android.app.Notification.WearableExtender: Builder extend(Builder)>,0,"{
    Bundle wearableBundle = new Bundle();
    if (!mActions.isEmpty()) {
        wearableBundle.putParcelableArrayList(KEY_ACTIONS, mActions);
    }
    if (mFlags != DEFAULT_FLAGS) {
        wearableBundle.putInt(KEY_FLAGS, mFlags);
    }
    if (mDisplayIntent != null) {
        wearableBundle.putParcelable(KEY_DISPLAY_INTENT, mDisplayIntent);
    }
    if (!mPages.isEmpty()) {
        wearableBundle.putParcelableArray(KEY_PAGES, mPages.toArray(new Notification[mPages.size()]));
    }
    if (mBackground != null) {
        wearableBundle.putParcelable(KEY_BACKGROUND, mBackground);
    }
    if (mContentIcon != 0) {
        wearableBundle.putInt(KEY_CONTENT_ICON, mContentIcon);
    }
    if (mContentIconGravity != DEFAULT_CONTENT_ICON_GRAVITY) {
        wearableBundle.putInt(KEY_CONTENT_ICON_GRAVITY, mContentIconGravity);
    }
    if (mContentActionIndex != UNSET_ACTION_INDEX) {
        wearableBundle.putInt(KEY_CONTENT_ACTION_INDEX, mContentActionIndex);
    }
    if (mCustomSizePreset != SIZE_DEFAULT) {
        wearableBundle.putInt(KEY_CUSTOM_SIZE_PRESET, mCustomSizePreset);
    }
    if (mCustomContentHeight != 0) {
        wearableBundle.putInt(KEY_CUSTOM_CONTENT_HEIGHT, mCustomContentHeight);
    }
    if (mGravity != DEFAULT_GRAVITY) {
        wearableBundle.putInt(KEY_GRAVITY, mGravity);
    }
    if (mHintScreenTimeout != 0) {
        wearableBundle.putInt(KEY_HINT_SCREEN_TIMEOUT, mHintScreenTimeout);
    }
    if (mDismissalId != null) {
        wearableBundle.putString(KEY_DISMISSAL_ID, mDismissalId);
    }
    builder.getExtras().putBundle(EXTRA_WEARABLE_EXTENSIONS, wearableBundle);
    return builder;
}","{
    Bundle wearableBundle = new Bundle();
    if (!mActions.isEmpty()) {
        wearableBundle.putParcelableArrayList(KEY_ACTIONS, mActions);
    }
    if (mFlags != DEFAULT_FLAGS) {
        wearableBundle.putInt(KEY_FLAGS, mFlags);
    }
    if (mDisplayIntent != null) {
        wearableBundle.putParcelable(KEY_DISPLAY_INTENT, mDisplayIntent);
    }
    if (!mPages.isEmpty()) {
        wearableBundle.putParcelableArray(KEY_PAGES, mPages.toArray(new Notification[mPages.size()]));
    }
    if (mBackground != null) {
        wearableBundle.putParcelable(KEY_BACKGROUND, mBackground);
    }
    if (mContentIcon != 0) {
        wearableBundle.putInt(KEY_CONTENT_ICON, mContentIcon);
    }
    if (mContentIconGravity != DEFAULT_CONTENT_ICON_GRAVITY) {
        wearableBundle.putInt(KEY_CONTENT_ICON_GRAVITY, mContentIconGravity);
    }
    if (mContentActionIndex != UNSET_ACTION_INDEX) {
        wearableBundle.putInt(KEY_CONTENT_ACTION_INDEX, mContentActionIndex);
    }
    if (mCustomSizePreset != SIZE_DEFAULT) {
        wearableBundle.putInt(KEY_CUSTOM_SIZE_PRESET, mCustomSizePreset);
    }
    if (mCustomContentHeight != 0) {
        wearableBundle.putInt(KEY_CUSTOM_CONTENT_HEIGHT, mCustomContentHeight);
    }
    if (mGravity != DEFAULT_GRAVITY) {
        wearableBundle.putInt(KEY_GRAVITY, mGravity);
    }
    if (mHintScreenTimeout != 0) {
        wearableBundle.putInt(KEY_HINT_SCREEN_TIMEOUT, mHintScreenTimeout);
    }
    if (mDismissalId != null) {
        wearableBundle.putString(KEY_DISMISSAL_ID, mDismissalId);
    }
    if (mBridgeTag != null) {
        wearableBundle.putString(KEY_BRIDGE_TAG, mBridgeTag);
    }
    builder.getExtras().putBundle(EXTRA_WEARABLE_EXTENSIONS, wearableBundle);
    return builder;
}",1,"/**
 * Apply wearable extensions to a notification that is being built. This is typically
 * called by the {@link android.app.Notification.Builder#extend} method of
 * {@link android.app.Notification.Builder}.
 */
","/**
 * Apply wearable extensions to a notification that is being built. This is typically
 * called by the {@link android.app.Notification.Builder#extend} method of
 * {@link android.app.Notification.Builder}.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",0,"The code change involves an addition of a conditional block with a `putString` invocation on `wearableBundle`. This constitutes another statement changed which is code change type 4. However, since change is an addition of a new field in a Bundle which doesn't alter the control flow, existing fields' values, or the final return, it can also be considered as a return statement changed given that the return value (`builder`) could now contain additional information: `putBundle(EXTRA_WEARABLE_EXTENSIONS, wearableBundle);` where `wearableBundle` has an additional key-value pair. Thus, the change also falls under type 1.","There is no Compatibility Issue because the additional data `mBridgeTag` is provided in a way that is backward-compatible. Older applications that are unaware of the new `KEY_BRIDGE_TAG` will ignore it, while newer applications can make use of it. Hence, it does not lead to a different behavior for existing clients that do not expect this new field. The return type (the builder) and the manner in which it operates remain the same, and there are no changes in exception handling. Therefore, this change should not cause a CI."
245,<android.app.Notification.Builder: Notification build()>,25,26,<android.app.Notification.Builder: Notification build()>,<android.app.Notification.Builder: Notification build()>,0,"{
    // first, add any extras from the calling code
    if (mUserExtras != null) {
        mN.extras = getAllExtras();
    }
    mN.creationTime = System.currentTimeMillis();
    // lazy stuff from mContext; see comment in Builder(Context, Notification)
    Notification.addFieldsFromContext(mContext, mN);
    buildUnstyled();
    if (mStyle != null) {
        mStyle.buildStyled(mN);
    }
    if (mContext.getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.N && (mStyle == null || !mStyle.displayCustomViewInline())) {
        if (mN.contentView == null) {
            mN.contentView = createContentView();
            mN.extras.putInt(EXTRA_REBUILD_CONTENT_VIEW_ACTION_COUNT, mN.contentView.getSequenceNumber());
        }
        if (mN.bigContentView == null) {
            mN.bigContentView = createBigContentView();
            if (mN.bigContentView != null) {
                mN.extras.putInt(EXTRA_REBUILD_BIG_CONTENT_VIEW_ACTION_COUNT, mN.bigContentView.getSequenceNumber());
            }
        }
        if (mN.headsUpContentView == null) {
            mN.headsUpContentView = createHeadsUpContentView();
            if (mN.headsUpContentView != null) {
                mN.extras.putInt(EXTRA_REBUILD_HEADS_UP_CONTENT_VIEW_ACTION_COUNT, mN.headsUpContentView.getSequenceNumber());
            }
        }
    }
    if ((mN.defaults & DEFAULT_LIGHTS) != 0) {
        mN.flags |= FLAG_SHOW_LIGHTS;
    }
    return mN;
}","{
    // first, add any extras from the calling code
    if (mUserExtras != null) {
        mN.extras = getAllExtras();
    }
    mN.creationTime = System.currentTimeMillis();
    // lazy stuff from mContext; see comment in Builder(Context, Notification)
    Notification.addFieldsFromContext(mContext, mN);
    buildUnstyled();
    if (mStyle != null) {
        mStyle.buildStyled(mN);
    }
    if (mContext.getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.N && (useExistingRemoteView())) {
        if (mN.contentView == null) {
            mN.contentView = createContentView();
            mN.extras.putInt(EXTRA_REBUILD_CONTENT_VIEW_ACTION_COUNT, mN.contentView.getSequenceNumber());
        }
        if (mN.bigContentView == null) {
            mN.bigContentView = createBigContentView();
            if (mN.bigContentView != null) {
                mN.extras.putInt(EXTRA_REBUILD_BIG_CONTENT_VIEW_ACTION_COUNT, mN.bigContentView.getSequenceNumber());
            }
        }
        if (mN.headsUpContentView == null) {
            mN.headsUpContentView = createHeadsUpContentView();
            if (mN.headsUpContentView != null) {
                mN.extras.putInt(EXTRA_REBUILD_HEADS_UP_CONTENT_VIEW_ACTION_COUNT, mN.headsUpContentView.getSequenceNumber());
            }
        }
    }
    if ((mN.defaults & DEFAULT_LIGHTS) != 0) {
        mN.flags |= FLAG_SHOW_LIGHTS;
    }
    return mN;
}",1,"/**
 * Combine all of the options that have been set and return a new {@link Notification}
 * object.
 */
","/**
 * Combine all of the options that have been set and return a new {@link Notification}
 * object.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method useExistingRemoteView() replaced the condition mStyle == null || !mStyle.displayCustomViewInline(), so the code change type is 5 (Dependent API changed).",There is no Compatibility Issue because the modification changes the condition by which it is decided whether to use existing RemoteViews or to create new ones. This doesn't affect the behavior of 'build()' method externally; it's an internal change which should be consistent with the previous implementation objective.
246,<android.app.Activity: ComponentName getCallingActivity()>,25,26,<android.app.Activity: ComponentName getCallingActivity()>,<android.app.Activity: ComponentName getCallingActivity()>,0,"{
    try {
        return ActivityManagerNative.getDefault().getCallingActivity(mToken);
    } catch (RemoteException e) {
        return null;
    }
}","{
    try {
        return ActivityManager.getService().getCallingActivity(mToken);
    } catch (RemoteException e) {
        return null;
    }
}",1,"/**
 * Return the name of the activity that invoked this activity.  This is
 * who the data in {@link #setResult setResult()} will be sent to.  You
 * can use this information to validate that the recipient is allowed to
 * receive the data.
 *
 * <p class=""note"">Note: if the calling activity is not expecting a result (that is it
 * did not use the {@link #startActivityForResult}
 * form that includes a request code), then the calling package will be
 * null.
 *
 * @return The ComponentName of the activity that will receive your
 * reply, or null if none.
 */
","/**
 * Return the name of the activity that invoked this activity.  This is
 * who the data in {@link #setResult setResult()} will be sent to.  You
 * can use this information to validate that the recipient is allowed to
 * receive the data.
 *
 * <p class=""note"">Note: if the calling activity is not expecting a result (that is it
 * did not use the {@link #startActivityForResult}
 * form that includes a request code), then the calling package will be
 * null.
 *
 * @return The ComponentName of the activity that will receive your
 * reply, or null if none.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,5,0,"The method used to get the service instance changed from ActivityManagerNative.getDefault() to ActivityManager.getService(), which is a change in the dependent API, so the code change type is 5.","Despite the change in the method used to obtain the service instance, the method signature, the try-catch structure, and the return statements are still the same. There are no additions or deletions of return statements or exception handling statements, and the behaviour of getting the calling activity should remain consistent across both versions. Therefore, this should not lead to a compatibility issue, and the CI type is 0."
247,<android.content.ContentResolver: List<UriPermission> getPersistedUriPermissions()>,25,26,<android.content.ContentResolver: List<UriPermission> getPersistedUriPermissions()>,<android.content.ContentResolver: List<UriPermission> getPersistedUriPermissions()>,0,"{
    try {
        return ActivityManagerNative.getDefault().getPersistedUriPermissions(mPackageName, true).getList();
    } catch (RemoteException e) {
        throw new RuntimeException(""Activity manager has died"", e);
    }
}","{
    try {
        return ActivityManager.getService().getPersistedUriPermissions(mPackageName, true).getList();
    } catch (RemoteException e) {
        throw new RuntimeException(""Activity manager has died"", e);
    }
}",1,"/**
 * Return list of all URI permission grants that have been persisted by the
 * calling app. That is, the returned permissions have been granted
 * <em>to</em> the calling app. Only persistable grants taken with
 * {@link #takePersistableUriPermission(Uri, int)} are returned.
 * <p>Note: Some of the returned URIs may not be usable until after the user is unlocked.
 *
 * @see #takePersistableUriPermission(Uri, int)
 * @see #releasePersistableUriPermission(Uri, int)
 */
","/**
 * Return list of all URI permission grants that have been persisted by the
 * calling app. That is, the returned permissions have been granted
 * <em>to</em> the calling app. Only persistable grants taken with
 * {@link #takePersistableUriPermission(Uri, int)} are returned.
 * <p>Note: Some of the returned URIs may not be usable until after the user is unlocked.
 *
 * @see #takePersistableUriPermission(Uri, int)
 * @see #releasePersistableUriPermission(Uri, int)
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,5,0,"The method invoked has changed from ActivityManagerNative.getDefault().getPersistedUriPermissions() to ActivityManager.getService().getPersistedUriPermissions(), indicating that the dependent API has changed, hence the code change type is 5.","The dependent API method invoked is different, but as the signature and the functionalities of these methods are expected to be the same (as they are both meant to retrieve persisted URI permissions), it does not lead to a compatibility issue in terms of different return types or exception handlings, so the CI type is 0."
248,"<android.content.pm.LauncherApps: List<ShortcutInfo> getShortcuts(ShortcutQuery,UserHandle)>",25,26,"<android.content.pm.LauncherApps: List<ShortcutInfo> getShortcuts(ShortcutQuery,UserHandle)>","<android.content.pm.LauncherApps: List<ShortcutInfo> getShortcuts(ShortcutQuery,UserHandle)>",0,"{
    try {
        return mService.getShortcuts(mContext.getPackageName(), query.mChangedSince, query.mPackage, query.mShortcutIds, query.mActivity, query.mQueryFlags, user).getList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    logErrorForInvalidProfileAccess(user);
    try {
        return mService.getShortcuts(mContext.getPackageName(), query.mChangedSince, query.mPackage, query.mShortcutIds, query.mActivity, query.mQueryFlags, user).getList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns {@link ShortcutInfo}s that match {@code query}.
 *
 * <p>Callers must be allowed to access the shortcut information, as defined in {@link
 * #hasShortcutHostPermission()}.
 *
 * @param query result includes shortcuts matching this query.
 * @param user The UserHandle of the profile.
 *
 * @return the IDs of {@link ShortcutInfo}s that match the query.
 * @throws IllegalStateException when the user is locked, or when the {@code user} user
 * is locked or not running.
 *
 * @see ShortcutManager
 */
","/**
 * Returns {@link ShortcutInfo}s that match {@code query}.
 *
 * <p>Callers must be allowed to access the shortcut information, as defined in {@link
 * #hasShortcutHostPermission()}.
 *
 * @param query result includes shortcuts matching this query.
 * @param user The UserHandle of the profile.
 *
 * @return the IDs of {@link ShortcutInfo}s that match the query.
 * @throws IllegalStateException when the user is locked, or when the {@code user} user
 * is locked or not running.
 *
 * @see ShortcutManager
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,4,0,"The addition of a call to logErrorForInvalidProfileAccess(user) before the try block is the only change and does not alter the control flow or the returned values, and since it's not a change in any return or exception handling statement or control dependency, it's classified as 4.","The added log method call does not change the behavior of how values are returned or exceptions are handled. It merely adds a logging operation before the existing code. This change does not affect how the method behaves from an API consumer's perspective, as far as compatibility is concerned. Therefore, there is no Compatibility Issue in this case."
249,<android.app.Fragment: Transition getExitTransition()>,25,26,<android.app.Fragment: Transition getExitTransition()>,<android.app.Fragment: Transition getExitTransition()>,0,"{
    return mExitTransition;
}","{
    if (mAnimationInfo == null) {
        return null;
    }
    return mAnimationInfo.mExitTransition;
}",1,"/**
 * Returns the Transition that will be used to move Views out of the scene when the
 * fragment is removed, hidden, or detached when not popping the back stack.
 * The exiting Views will be those that are regular Views or ViewGroups that
 * have {@link ViewGroup#isTransitionGroup} return true. Typical Transitions will extend
 * {@link android.transition.Visibility} as exiting is governed by changing visibility
 * from {@link View#VISIBLE} to {@link View#INVISIBLE}. If transition is null, the views will
 * remain unaffected.
 *
 * @return the Transition to use to move Views out of the Scene when the Fragment
 * is being closed not due to popping the back stack.
 * @attr ref android.R.styleable#Fragment_fragmentExitTransition
 */
","/**
 * Returns the Transition that will be used to move Views out of the scene when the
 * fragment is removed, hidden, or detached when not popping the back stack.
 * The exiting Views will be those that are regular Views or ViewGroups that
 * have {@link ViewGroup#isTransitionGroup} return true. Typical Transitions will extend
 * {@link android.transition.Visibility} as exiting is governed by changing visibility
 * from {@link View#VISIBLE} to {@link View#INVISIBLE}. If transition is null, the views will
 * remain unaffected.
 *
 * @return the Transition to use to move Views out of the Scene when the Fragment
 * is being closed not due to popping the back stack.
 * @attr ref android.R.styleable#Fragment_fragmentExitTransition
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The late version added a control dependency (an if statement that checks if mAnimationInfo is null) and a new return statement. The nature of the change is related to both control dependency and the return statement, hence the code change is classified as 1,4.","The addition of a control dependency and a return statement can potentially lead to a different return value, since now there's a condition where null will be returned instead of the mExitTransition member, resulting in a different behavior. Thus, a CI is caused by potentially different return values, which is type 1."
253,<android.app.admin.DevicePolicyManager: boolean isCallerApplicationRestrictionsManagingPackage()>,25,26,<android.app.admin.DevicePolicyManager: boolean isCallerApplicationRestrictionsManagingPackage()>,<android.app.admin.DevicePolicyManager: boolean isCallerApplicationRestrictionsManagingPackage()>,0,"{
    throwIfParentInstance(""isCallerApplicationRestrictionsManagingPackage"");
    if (mService != null) {
        try {
            return mService.isCallerApplicationRestrictionsManagingPackage();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return false;
}","{
    throwIfParentInstance(""isCallerApplicationRestrictionsManagingPackage"");
    if (mService != null) {
        try {
            return mService.isCallerApplicationRestrictionsManagingPackage(mContext.getPackageName());
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return false;
}",1,"/**
 * Called by any application to find out whether it has been granted permission via
 * {@link #setApplicationRestrictionsManagingPackage} to manage application restrictions
 * for the calling user.
 *
 * <p>This is done by comparing the calling Linux uid with the uid of the package specified by
 * that method.
 */
","/**
 * Called by any application to find out whether it has been granted permission via
 * {@link #setApplicationRestrictionsManagingPackage} to manage application restrictions
 * for the calling user.
 *
 * <p>This is done by comparing the calling Linux uid with the uid of the package specified by
 * that method.
 *
 * @deprecated From {@link android.os.Build.VERSION_CODES#O}. Use {@link #getDelegatedScopes}
 * instead.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,5,0,"The dependent API `mService.isCallerApplicationRestrictionsManagingPackage()` has been changed to include an additional parameter `mContext.getPackageName()`. The change is in the arguments passed to the method, thus the code change type is 5.","There is no Compatibility Issue arising from the code changes because the return type remains boolean, and the exception handling remains the same. The addition of `mContext.getPackageName()` as a parameter is an internal change that does not affect the callers of the API `isCallerApplicationRestrictionsManagingPackage()`. The clients invoking this API will pass no arguments and receive the same boolean return type without needing to handle new exceptions or changes. The annotation change to `@Deprecated` is a signal of future deprecation rather than an immediate compatibility issue."
254,"<android.content.pm.LauncherApps: void pinShortcuts(String,List<String>,UserHandle)>",25,26,"<android.content.pm.LauncherApps: void pinShortcuts(String,List<String>,UserHandle)>","<android.content.pm.LauncherApps: void pinShortcuts(String,List<String>,UserHandle)>",0,"{
    try {
        mService.pinShortcuts(mContext.getPackageName(), packageName, shortcutIds, user);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    logErrorForInvalidProfileAccess(user);
    try {
        mService.pinShortcuts(mContext.getPackageName(), packageName, shortcutIds, user);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Pin shortcuts on a package.
 *
 * <p>This API is <b>NOT</b> cumulative; this will replace all pinned shortcuts for the package.
 * However, different launchers may have different set of pinned shortcuts.
 *
 * <p>The calling launcher application must be allowed to access the shortcut information,
 * as defined in {@link #hasShortcutHostPermission()}.
 *
 * @param packageName The target package name.
 * @param shortcutIds The IDs of the shortcut to be pinned.
 * @param user The UserHandle of the profile.
 * @throws IllegalStateException when the user is locked, or when the {@code user} user
 * is locked or not running.
 *
 * @see ShortcutManager
 */
","/**
 * Pin shortcuts on a package.
 *
 * <p>This API is <b>NOT</b> cumulative; this will replace all pinned shortcuts for the package.
 * However, different launchers may have different set of pinned shortcuts.
 *
 * <p>The calling launcher application must be allowed to access the shortcut information,
 * as defined in {@link #hasShortcutHostPermission()}.
 *
 * @param packageName The target package name.
 * @param shortcutIds The IDs of the shortcut to be pinned.
 * @param user The UserHandle of the profile.
 * @throws IllegalStateException when the user is locked, or when the {@code user} user
 * is locked or not running.
 *
 * @see ShortcutManager
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change is the introduction of a new method call 'logErrorForInvalidProfileAccess(user)' before the try block, which is not related to return statements or exception handling and does not change the control flow or change a dependent API, therefore, the code change type is 4.","The newly added method call 'logErrorForInvalidProfileAccess(user)' has no effect on the API's behavior in terms of changing return values or types, nor does it affect the exception handling mechanism of the method. Therefore, there is no Compatibility Issue."
256,"<android.widget.TextView: void setTextAppearance(Context,int)>",25,26,"<android.widget.TextView: void setTextAppearance(Context,int)>","<android.widget.TextView: void setTextAppearance(Context,int)>",0,"{
    final TypedArray ta = context.obtainStyledAttributes(resId, R.styleable.TextAppearance);
    final int textColorHighlight = ta.getColor(R.styleable.TextAppearance_textColorHighlight, 0);
    if (textColorHighlight != 0) {
        setHighlightColor(textColorHighlight);
    }
    final ColorStateList textColor = ta.getColorStateList(R.styleable.TextAppearance_textColor);
    if (textColor != null) {
        setTextColor(textColor);
    }
    final int textSize = ta.getDimensionPixelSize(R.styleable.TextAppearance_textSize, 0);
    if (textSize != 0) {
        setRawTextSize(textSize);
    }
    final ColorStateList textColorHint = ta.getColorStateList(R.styleable.TextAppearance_textColorHint);
    if (textColorHint != null) {
        setHintTextColor(textColorHint);
    }
    final ColorStateList textColorLink = ta.getColorStateList(R.styleable.TextAppearance_textColorLink);
    if (textColorLink != null) {
        setLinkTextColor(textColorLink);
    }
    final String fontFamily = ta.getString(R.styleable.TextAppearance_fontFamily);
    final int typefaceIndex = ta.getInt(R.styleable.TextAppearance_typeface, -1);
    final int styleIndex = ta.getInt(R.styleable.TextAppearance_textStyle, -1);
    setTypefaceFromAttrs(fontFamily, typefaceIndex, styleIndex);
    final int shadowColor = ta.getInt(R.styleable.TextAppearance_shadowColor, 0);
    if (shadowColor != 0) {
        final float dx = ta.getFloat(R.styleable.TextAppearance_shadowDx, 0);
        final float dy = ta.getFloat(R.styleable.TextAppearance_shadowDy, 0);
        final float r = ta.getFloat(R.styleable.TextAppearance_shadowRadius, 0);
        setShadowLayer(r, dx, dy, shadowColor);
    }
    if (ta.getBoolean(R.styleable.TextAppearance_textAllCaps, false)) {
        setTransformationMethod(new AllCapsTransformationMethod(getContext()));
    }
    if (ta.hasValue(R.styleable.TextAppearance_elegantTextHeight)) {
        setElegantTextHeight(ta.getBoolean(R.styleable.TextAppearance_elegantTextHeight, false));
    }
    if (ta.hasValue(R.styleable.TextAppearance_letterSpacing)) {
        setLetterSpacing(ta.getFloat(R.styleable.TextAppearance_letterSpacing, 0));
    }
    if (ta.hasValue(R.styleable.TextAppearance_fontFeatureSettings)) {
        setFontFeatureSettings(ta.getString(R.styleable.TextAppearance_fontFeatureSettings));
    }
    ta.recycle();
}","{
    final TypedArray ta = context.obtainStyledAttributes(resId, R.styleable.TextAppearance);
    final int textColorHighlight = ta.getColor(R.styleable.TextAppearance_textColorHighlight, 0);
    if (textColorHighlight != 0) {
        setHighlightColor(textColorHighlight);
    }
    final ColorStateList textColor = ta.getColorStateList(R.styleable.TextAppearance_textColor);
    if (textColor != null) {
        setTextColor(textColor);
    }
    final int textSize = ta.getDimensionPixelSize(R.styleable.TextAppearance_textSize, 0);
    if (textSize != 0) {
        setRawTextSize(textSize, true);
    }
    final ColorStateList textColorHint = ta.getColorStateList(R.styleable.TextAppearance_textColorHint);
    if (textColorHint != null) {
        setHintTextColor(textColorHint);
    }
    final ColorStateList textColorLink = ta.getColorStateList(R.styleable.TextAppearance_textColorLink);
    if (textColorLink != null) {
        setLinkTextColor(textColorLink);
    }
    Typeface fontTypeface = null;
    String fontFamily = null;
    if (!context.isRestricted() && context.canLoadUnsafeResources()) {
        try {
            fontTypeface = ta.getFont(R.styleable.TextAppearance_fontFamily);
        } catch (UnsupportedOperationException | Resources.NotFoundException e) {
        // Expected if it is not a font resource.
        }
    }
    if (fontTypeface == null) {
        fontFamily = ta.getString(R.styleable.TextAppearance_fontFamily);
    }
    final int typefaceIndex = ta.getInt(R.styleable.TextAppearance_typeface, -1);
    final int styleIndex = ta.getInt(R.styleable.TextAppearance_textStyle, -1);
    setTypefaceFromAttrs(fontTypeface, fontFamily, typefaceIndex, styleIndex);
    final int shadowColor = ta.getInt(R.styleable.TextAppearance_shadowColor, 0);
    if (shadowColor != 0) {
        final float dx = ta.getFloat(R.styleable.TextAppearance_shadowDx, 0);
        final float dy = ta.getFloat(R.styleable.TextAppearance_shadowDy, 0);
        final float r = ta.getFloat(R.styleable.TextAppearance_shadowRadius, 0);
        setShadowLayer(r, dx, dy, shadowColor);
    }
    if (ta.getBoolean(R.styleable.TextAppearance_textAllCaps, false)) {
        setTransformationMethod(new AllCapsTransformationMethod(getContext()));
    }
    if (ta.hasValue(R.styleable.TextAppearance_elegantTextHeight)) {
        setElegantTextHeight(ta.getBoolean(R.styleable.TextAppearance_elegantTextHeight, false));
    }
    if (ta.hasValue(R.styleable.TextAppearance_letterSpacing)) {
        setLetterSpacing(ta.getFloat(R.styleable.TextAppearance_letterSpacing, 0));
    }
    if (ta.hasValue(R.styleable.TextAppearance_fontFeatureSettings)) {
        setFontFeatureSettings(ta.getString(R.styleable.TextAppearance_fontFeatureSettings));
    }
    ta.recycle();
}",1,"/**
 * Sets the text color, size, style, hint color, and highlight color
 * from the specified TextAppearance resource.
 *
 * @deprecated Use {@link #setTextAppearance(int)} instead.
 */
","/**
 * Sets the text color, size, style, hint color, and highlight color
 * from the specified TextAppearance resource.
 *
 * @deprecated Use {@link #setTextAppearance(int)} instead.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,,,,
257,"<android.app.SharedPreferencesImpl.EditorImpl: Editor putFloat(String,float)>",25,26,"<android.app.SharedPreferencesImpl.EditorImpl: Editor putFloat(String,float)>","<android.app.SharedPreferencesImpl.EditorImpl: Editor putFloat(String,float)>",0,"{
    synchronized (this) {
        mModified.put(key, value);
        return this;
    }
}","{
    synchronized (mLock) {
        mModified.put(key, value);
        return this;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change that has been made is from 'synchronized (this)' to 'synchronized (mLock)', meaning 'this' was previously used as the lock for synchronization, and now a specific lock object 'mLock' is used instead. There are no changes in the return type, exception handling, control structures, or dependencies, so the code change type is 4.","This change does not affect the external behavior of the method, such as return values or exception handling. The change is internal to how the synchronization is performed, which will not be visible to the users of the API. Therefore, there is no Compatibility Issue; the type is 0."
258,<android.hardware.camera2.utils.TaskDrainer: void taskFinished(T)>,25,26,<android.hardware.camera2.utils.TaskDrainer: void taskFinished(T)>,<android.hardware.camera2.utils.TaskDrainer: void taskFinished(T)>,0,"{
    synchronized (mLock) {
        if (DEBUG) {
            Log.v(TAG + ""["" + mName + ""]"", ""taskFinished "" + task);
        }
        if (!mTaskSet.remove(task)) {
            throw new IllegalStateException(""Task "" + task + "" was already finished"");
        }
        // If this is the last finished task and draining has already begun, fire #onDrained
        checkIfDrainFinished();
    }
}","{
    synchronized (mLock) {
        if (DEBUG) {
            Log.v(TAG + ""["" + mName + ""]"", ""taskFinished "" + task);
        }
        // Try to remove the task from started set.
        if (!mTaskSet.remove(task)) {
            // Task is not started yet. Add it to the early finished set.
            if (!mEarlyFinishedTaskSet.add(task)) {
                throw new IllegalStateException(""Task "" + task + "" was already finished"");
            }
        }
        // If this is the last finished task and draining has already begun, fire #onDrained
        checkIfDrainFinished();
    }
}",1,"/**
 * Mark an asynchronous task as having finished.
 *
 * <p>A task cannot be finished if it hasn't started. Once finished, a task
 * cannot be finished again (unless it's started again).</p>
 *
 * @param task a key to identify a task
 *
 * @see #taskStarted
 * @see #beginDrain
 *
 * @throws IllegalStateException
 * If attempting to start a task which is already finished (and not re-started),
 */
","/**
 * Mark an asynchronous task as having finished.
 *
 * <p>A task cannot be finished more than once without first having started.</p>
 *
 * @param task a key to identify a task
 *
 * @see #taskStarted
 * @see #beginDrain
 *
 * @throws IllegalStateException
 * If attempting to finish a task which is already finished (and not started),
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation contains a new statement which adds a task to the 'mEarlyFinishedTaskSet' if it cannot be removed from 'mTaskSet', and also a dependent API `add` method is called on 'mEarlyFinishedTaskSet'. Since the control flow related to the task removal and exception throwing remains the same, only the handling of a task that cannot be removed has changed, so the type of change is 4,5.","There is no compatibility issue in this change, as the new code does not alter the existing behavior in a way that would cause the API to return a different variable or throw a different exception in the situations that the previous API version could handle. It only adds an extra set where the task is stored if it was finished before it was added to 'mTaskSet'. The conditions for the exception being thrown remain the same as well; it will still be thrown if the task is already finished in both cases, though through different sets in the late version. As the primary outward-facing behavior of the method does not change, the result is 0 for no compatibility issue."
259,"<android.hardware.usb.UsbRequest: boolean initialize(UsbDeviceConnection,UsbEndpoint)>",25,26,"<android.hardware.usb.UsbRequest: boolean initialize(UsbDeviceConnection,UsbEndpoint)>","<android.hardware.usb.UsbRequest: boolean initialize(UsbDeviceConnection,UsbEndpoint)>",0,"{
    mEndpoint = endpoint;
    return native_init(connection, endpoint.getAddress(), endpoint.getAttributes(), endpoint.getMaxPacketSize(), endpoint.getInterval());
}","{
    mEndpoint = endpoint;
    mConnection = Preconditions.checkNotNull(connection, ""connection"");
    boolean wasInitialized = native_init(connection, endpoint.getAddress(), endpoint.getAttributes(), endpoint.getMaxPacketSize(), endpoint.getInterval());
    if (wasInitialized) {
        mCloseGuard.open(""close"");
    }
    return wasInitialized;
}",1,"/**
 * Initializes the request so it can read or write data on the given endpoint.
 * Whether the request allows reading or writing depends on the direction of the endpoint.
 *
 * @param endpoint the endpoint to be used for this request.
 * @return true if the request was successfully opened.
 */
","/**
 * Initializes the request so it can read or write data on the given endpoint.
 * Whether the request allows reading or writing depends on the direction of the endpoint.
 *
 * @param endpoint the endpoint to be used for this request.
 * @return true if the request was successfully opened.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The late version introduces additional operations including a check for null connection, the assignment to the `mConnection` variable, a conditional block for calling `mCloseGuard.open(""close"")`, and a changed return statement pattern. This introduces a control dependency change (3) and an other statement change (4), as there are new assignments and control flow operations. Additionally, there is a change in the return statement because the value that will be returned (`wasInitialized`) is now being used in a control flow operation before being returned, which classifies as a return statement changed (1).","The late version adds a null check that could throw a NullPointerException, and the handling of initialization success with `mCloseGuard.open(""close"")` before returning the result, which affects the function's return value. This potentially leads to different return values or even an exception being thrown whereas previously there would have been none. Therefore, the CI type is 1 due to the potential different return behavior."
260,<android.app.Fragment: Transition getSharedElementReturnTransition()>,25,26,<android.app.Fragment: Transition getSharedElementReturnTransition()>,<android.app.Fragment: Transition getSharedElementReturnTransition()>,0,"{
    return mSharedElementReturnTransition == USE_DEFAULT_TRANSITION ? getSharedElementEnterTransition() : mSharedElementReturnTransition;
}","{
    if (mAnimationInfo == null) {
        return null;
    }
    return mAnimationInfo.mSharedElementReturnTransition == USE_DEFAULT_TRANSITION ? getSharedElementEnterTransition() : mAnimationInfo.mSharedElementReturnTransition;
}",1,"/**
 * Return the Transition that will be used for shared elements transferred back during a
 * pop of the back stack. This Transition acts in the leaving Fragment.
 * Typical Transitions will affect size and location, such as
 * {@link android.transition.ChangeBounds}. A null
 * value will cause transferred shared elements to blink to the final position.
 * If no value is set, the default will be to use the same value as
 * {@link #setSharedElementEnterTransition(android.transition.Transition)}.
 *
 * @return The Transition to use for shared elements transferred out of the content
 * Scene.
 * @attr ref android.R.styleable#Fragment_fragmentSharedElementReturnTransition
 */
","/**
 * Return the Transition that will be used for shared elements transferred back during a
 * pop of the back stack. This Transition acts in the leaving Fragment.
 * Typical Transitions will affect size and location, such as
 * {@link android.transition.ChangeBounds}. A null
 * value will cause transferred shared elements to blink to the final position.
 * If no value is set, the default will be to use the same value as
 * {@link #setSharedElementEnterTransition(android.transition.Transition)}.
 *
 * @return The Transition to use for shared elements transferred out of the content
 * Scene.
 * @attr ref android.R.styleable#Fragment_fragmentSharedElementReturnTransition
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,5",1,"The implementation has a control dependency change; an if-statement has been added checking whether mAnimationInfo is null. The return statement also changed to accommodate this new null check, retrieving the transition directly from the mAnimationInfo if it's not null. Lastly, there is a dependent API change because the new return statements are referencing mAnimationInfo which didn't appear in the earlier version. Therefore, the code change includes types 1, 3 and 5.","The late version introduces a new scenario where null could be returned if mAnimationInfo is null. Thus, it's a potential different return value, and CI type is 1."
261,<android.app.MediaRouteActionProvider: View onCreateActionView(MenuItem)>,25,26,<android.app.MediaRouteActionProvider: View onCreateActionView(MenuItem)>,<android.app.MediaRouteActionProvider: View onCreateActionView(MenuItem)>,0,"{
    if (mButton != null) {
        Log.e(TAG, ""onCreateActionView: this ActionProvider is already associated "" + ""with a menu item. Don't reuse MediaRouteActionProvider instances! "" + ""Abandoning the old one..."");
    }
    mButton = new MediaRouteButton(mContext);
    mButton.setCheatSheetEnabled(true);
    mButton.setRouteTypes(mRouteTypes);
    mButton.setExtendedSettingsClickListener(mExtendedSettingsListener);
    mButton.setLayoutParams(new ViewGroup.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.MATCH_PARENT));
    return mButton;
}","{
    if (mButton != null) {
        Log.e(TAG, ""onCreateActionView: this ActionProvider is already associated "" + ""with a menu item. Don't reuse MediaRouteActionProvider instances! "" + ""Abandoning the old one..."");
    }
    mButton = new MediaRouteButton(mContext);
    mButton.setRouteTypes(mRouteTypes);
    mButton.setExtendedSettingsClickListener(mExtendedSettingsListener);
    mButton.setLayoutParams(new ViewGroup.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.MATCH_PARENT));
    return mButton;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The method mButton.setCheatSheetEnabled(true); is deleted in the late version, which is an instance method but does not affect the return type or value, so the change type is 4.","The deletion of the method call to mButton.setCheatSheetEnabled(true); does not cause the API to return a different value or throw a new exception, so there is no compatibility issue. The behavior associated with showing a cheat sheet (help text) when long pressing the button will be absent, but the main functionality and the returned object type remain unchanged."
264,<android.content.res.AssetManager: CharSequence[] getResourceTextArray(int)>,25,26,<android.content.res.AssetManager: CharSequence[] getResourceTextArray(int)>,<android.content.res.AssetManager: CharSequence[] getResourceTextArray(int)>,0,"{
    final int[] rawInfoArray = getArrayStringInfo(resId);
    final int rawInfoArrayLen = rawInfoArray.length;
    final int infoArrayLen = rawInfoArrayLen / 2;
    int block;
    int index;
    final CharSequence[] retArray = new CharSequence[infoArrayLen];
    for (int i = 0, j = 0; i < rawInfoArrayLen; i = i + 2, j++) {
        block = rawInfoArray[i];
        index = rawInfoArray[i + 1];
        retArray[j] = index >= 0 ? mStringBlocks[block].get(index) : null;
    }
    return retArray;
}","{
    synchronized (this) {
        final int[] rawInfoArray = getArrayStringInfo(resId);
        if (rawInfoArray == null) {
            return null;
        }
        final int rawInfoArrayLen = rawInfoArray.length;
        final int infoArrayLen = rawInfoArrayLen / 2;
        int block;
        int index;
        final CharSequence[] retArray = new CharSequence[infoArrayLen];
        for (int i = 0, j = 0; i < rawInfoArrayLen; i = i + 2, j++) {
            block = rawInfoArray[i];
            index = rawInfoArray[i + 1];
            retArray[j] = index >= 0 ? mStringBlocks[block].get(index) : null;
        }
        return retArray;
    }
}",1,"/**
 * Retrieve the text array associated with a particular resource
 * identifier.
 *
 * @param resId the resource id of the string array
 */
","/**
 * Retrieve the text array associated with a particular resource
 * identifier.
 *
 * @param resId the resource id of the string array
 */
",-1,,[@Nullable],-1,-1,-1,-1,-1,-1,"1,3,4","0,1","The late version introduces a synchronized block, a new null check condition for rawInfoArray, and it is also annotated with @Nullable. This results in changes classified as 1 (new return statement if check fails), 3 (control dependency due to synchronized block and if condition), and 4 (annotation change).","There is no Compatibility Issue for the synchronized block since it does not affect the API's output. However, introducing a null check for the rawInfoArray may result in the method returning null where previously it would have attempted to process the array and potentially thrown a RuntimeException, which leads to a potential CI for return values (1). The annotation change does not directly contribute to a CI since it only provides additional information about the potential for a null value, which aligns with the code change."
266,"<android.animation.ArgbEvaluator: Object evaluate(float,Object,Object)>",25,26,"<android.animation.ArgbEvaluator: Object evaluate(float,Object,Object)>","<android.animation.ArgbEvaluator: Object evaluate(float,Object,Object)>",0,"{
    int startInt = (Integer) startValue;
    int startA = (startInt >> 24) & 0xff;
    int startR = (startInt >> 16) & 0xff;
    int startG = (startInt >> 8) & 0xff;
    int startB = startInt & 0xff;
    int endInt = (Integer) endValue;
    int endA = (endInt >> 24) & 0xff;
    int endR = (endInt >> 16) & 0xff;
    int endG = (endInt >> 8) & 0xff;
    int endB = endInt & 0xff;
    return (int) ((startA + (int) (fraction * (endA - startA))) << 24) | (int) ((startR + (int) (fraction * (endR - startR))) << 16) | (int) ((startG + (int) (fraction * (endG - startG))) << 8) | (int) ((startB + (int) (fraction * (endB - startB))));
}","{
    int startInt = (Integer) startValue;
    float startA = ((startInt >> 24) & 0xff) / 255.0f;
    float startR = ((startInt >> 16) & 0xff) / 255.0f;
    float startG = ((startInt >> 8) & 0xff) / 255.0f;
    float startB = (startInt & 0xff) / 255.0f;
    int endInt = (Integer) endValue;
    float endA = ((endInt >> 24) & 0xff) / 255.0f;
    float endR = ((endInt >> 16) & 0xff) / 255.0f;
    float endG = ((endInt >> 8) & 0xff) / 255.0f;
    float endB = (endInt & 0xff) / 255.0f;
    // convert from sRGB to linear
    startR = (float) Math.pow(startR, 2.2);
    startG = (float) Math.pow(startG, 2.2);
    startB = (float) Math.pow(startB, 2.2);
    endR = (float) Math.pow(endR, 2.2);
    endG = (float) Math.pow(endG, 2.2);
    endB = (float) Math.pow(endB, 2.2);
    // compute the interpolated color in linear space
    float a = startA + fraction * (endA - startA);
    float r = startR + fraction * (endR - startR);
    float g = startG + fraction * (endG - startG);
    float b = startB + fraction * (endB - startB);
    // convert back to sRGB in the [0..255] range
    a = a * 255.0f;
    r = (float) Math.pow(r, 1.0 / 2.2) * 255.0f;
    g = (float) Math.pow(g, 1.0 / 2.2) * 255.0f;
    b = (float) Math.pow(b, 1.0 / 2.2) * 255.0f;
    return Math.round(a) << 24 | Math.round(r) << 16 | Math.round(g) << 8 | Math.round(b);
}",1,"/**
 * This function returns the calculated in-between value for a color
 * given integers that represent the start and end values in the four
 * bytes of the 32-bit int. Each channel is separately linearly interpolated
 * and the resulting calculated values are recombined into the return value.
 *
 * @param fraction The fraction from the starting to the ending values
 * @param startValue A 32-bit int value representing colors in the
 * separate bytes of the parameter
 * @param endValue A 32-bit int value representing colors in the
 * separate bytes of the parameter
 * @return A value that is calculated to be the linearly interpolated
 * result, derived by separating the start and end values into separate
 * color channels and interpolating each one separately, recombining the
 * resulting values in the same way.
 */
","/**
 * This function returns the calculated in-between value for a color
 * given integers that represent the start and end values in the four
 * bytes of the 32-bit int. Each channel is separately linearly interpolated
 * and the resulting calculated values are recombined into the return value.
 *
 * @param fraction The fraction from the starting to the ending values
 * @param startValue A 32-bit int value representing colors in the
 * separate bytes of the parameter
 * @param endValue A 32-bit int value representing colors in the
 * separate bytes of the parameter
 * @return A value that is calculated to be the linearly interpolated
 * result, derived by separating the start and end values into separate
 * color channels and interpolating each one separately, recombining the
 * resulting values in the same way.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The implementation changed from using integer types directly for color components to converting them to float and applying a power function for gamma correction before interpolating. Values are also normalized and denormalized by dividing and multiplying by 255.0f, respectively. Variable declarations were added, and the return statement is modified to use newly introduced variables and Math functions, resulting in a change of type 1 and 4 (changes related to other statements besides control flow and exception handling).","The API's behavior has changed since the color calculation has been altered, introducing a more accurate color interpolation through gamma correction. This results in potentially different return values, so the Compatibility Issue type is 1."
268,"<android.hardware.camera2.params.OutputConfiguration: void writeToParcel(Parcel,int)>",25,26,"<android.hardware.camera2.params.OutputConfiguration: void writeToParcel(Parcel,int)>","<android.hardware.camera2.params.OutputConfiguration: void writeToParcel(Parcel,int)>",0,"{
    if (dest == null) {
        throw new IllegalArgumentException(""dest must not be null"");
    }
    dest.writeInt(mRotation);
    dest.writeInt(mSurfaceGroupId);
    dest.writeInt(mSurfaceType);
    dest.writeInt(mConfiguredSize.getWidth());
    dest.writeInt(mConfiguredSize.getHeight());
    if (mSurface != null) {
        mSurface.writeToParcel(dest, flags);
    }
}","{
    if (dest == null) {
        throw new IllegalArgumentException(""dest must not be null"");
    }
    dest.writeInt(mRotation);
    dest.writeInt(mSurfaceGroupId);
    dest.writeInt(mSurfaceType);
    dest.writeInt(mConfiguredSize.getWidth());
    dest.writeInt(mConfiguredSize.getHeight());
    dest.writeInt(mIsDeferredConfig ? 1 : 0);
    dest.writeInt(mIsShared ? 1 : 0);
    dest.writeTypedList(mSurfaces);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"New statements have been added for writing additional fields to the Parcel (`mIsDeferredConfig` and `mIsShared`) and the way surfaces are written to the parcel has changed (from `mSurface.writeToParcel(dest, flags)` to `dest.writeTypedList(mSurfaces)`). These changes fall under the category of 'Other statement changed'.","These changes do not introduce a compatibility issue because the method `writeToParcel` is meant to serialize the object state to a parcel, and adding extra data fields does not change the API's behavior as observed by the calling code. The calling code for serialization will still invoke this method without needing to consider internal data structure changes for serialization. Hence, there is no compatibility issue."
269,"<android.app.FragmentManagerImpl: View onCreateView(View,String,Context,AttributeSet)>",25,26,"<android.app.FragmentManagerImpl: View onCreateView(View,String,Context,AttributeSet)>","<android.app.FragmentManagerImpl: View onCreateView(View,String,Context,AttributeSet)>",0,"{
    if (!""fragment"".equals(name)) {
        return null;
    }
    String fname = attrs.getAttributeValue(null, ""class"");
    TypedArray a = context.obtainStyledAttributes(attrs, com.android.internal.R.styleable.Fragment);
    if (fname == null) {
        fname = a.getString(com.android.internal.R.styleable.Fragment_name);
    }
    int id = a.getResourceId(com.android.internal.R.styleable.Fragment_id, View.NO_ID);
    String tag = a.getString(com.android.internal.R.styleable.Fragment_tag);
    a.recycle();
    int containerId = parent != null ? parent.getId() : 0;
    if (containerId == View.NO_ID && id == View.NO_ID && tag == null) {
        throw new IllegalArgumentException(attrs.getPositionDescription() + "": Must specify unique android:id, android:tag, or have a parent with"" + "" an id for "" + fname);
    }
    // If we restored from a previous state, we may already have
    // instantiated this fragment from the state and should use
    // that instance instead of making a new one.
    Fragment fragment = id != View.NO_ID ? findFragmentById(id) : null;
    if (fragment == null && tag != null) {
        fragment = findFragmentByTag(tag);
    }
    if (fragment == null && containerId != View.NO_ID) {
        fragment = findFragmentById(containerId);
    }
    if (FragmentManagerImpl.DEBUG)
        Log.v(TAG, ""onCreateView: id=0x"" + Integer.toHexString(id) + "" fname="" + fname + "" existing="" + fragment);
    if (fragment == null) {
        fragment = Fragment.instantiate(context, fname);
        fragment.mFromLayout = true;
        fragment.mFragmentId = id != 0 ? id : containerId;
        fragment.mContainerId = containerId;
        fragment.mTag = tag;
        fragment.mInLayout = true;
        fragment.mFragmentManager = this;
        fragment.mHost = mHost;
        fragment.onInflate(mHost.getContext(), attrs, fragment.mSavedFragmentState);
        addFragment(fragment, true);
    } else if (fragment.mInLayout) {
        // previous state.
        throw new IllegalArgumentException(attrs.getPositionDescription() + "": Duplicate id 0x"" + Integer.toHexString(id) + "", tag "" + tag + "", or parent id 0x"" + Integer.toHexString(containerId) + "" with another fragment for "" + fname);
    } else {
        // This fragment was retained from a previous instance; get it
        // going now.
        fragment.mInLayout = true;
        fragment.mHost = mHost;
        // initialize itself.
        if (!fragment.mRetaining) {
            fragment.onInflate(mHost.getContext(), attrs, fragment.mSavedFragmentState);
        }
    }
    // push the inflated child fragment along.
    if (mCurState < Fragment.CREATED && fragment.mFromLayout) {
        moveToState(fragment, Fragment.CREATED, 0, 0, false);
    } else {
        moveToState(fragment);
    }
    if (fragment.mView == null) {
        throw new IllegalStateException(""Fragment "" + fname + "" did not create a view."");
    }
    if (id != 0) {
        fragment.mView.setId(id);
    }
    if (fragment.mView.getTag() == null) {
        fragment.mView.setTag(tag);
    }
    return fragment.mView;
}","{
    if (!""fragment"".equals(name)) {
        return null;
    }
    String fname = attrs.getAttributeValue(null, ""class"");
    TypedArray a = context.obtainStyledAttributes(attrs, com.android.internal.R.styleable.Fragment);
    if (fname == null) {
        fname = a.getString(com.android.internal.R.styleable.Fragment_name);
    }
    int id = a.getResourceId(com.android.internal.R.styleable.Fragment_id, View.NO_ID);
    String tag = a.getString(com.android.internal.R.styleable.Fragment_tag);
    a.recycle();
    int containerId = parent != null ? parent.getId() : 0;
    if (containerId == View.NO_ID && id == View.NO_ID && tag == null) {
        throw new IllegalArgumentException(attrs.getPositionDescription() + "": Must specify unique android:id, android:tag, or have a parent with"" + "" an id for "" + fname);
    }
    // If we restored from a previous state, we may already have
    // instantiated this fragment from the state and should use
    // that instance instead of making a new one.
    Fragment fragment = id != View.NO_ID ? findFragmentById(id) : null;
    if (fragment == null && tag != null) {
        fragment = findFragmentByTag(tag);
    }
    if (fragment == null && containerId != View.NO_ID) {
        fragment = findFragmentById(containerId);
    }
    if (FragmentManagerImpl.DEBUG)
        Log.v(TAG, ""onCreateView: id=0x"" + Integer.toHexString(id) + "" fname="" + fname + "" existing="" + fragment);
    if (fragment == null) {
        fragment = mContainer.instantiate(context, fname, null);
        fragment.mFromLayout = true;
        fragment.mFragmentId = id != 0 ? id : containerId;
        fragment.mContainerId = containerId;
        fragment.mTag = tag;
        fragment.mInLayout = true;
        fragment.mFragmentManager = this;
        fragment.mHost = mHost;
        fragment.onInflate(mHost.getContext(), attrs, fragment.mSavedFragmentState);
        addFragment(fragment, true);
    } else if (fragment.mInLayout) {
        // previous state.
        throw new IllegalArgumentException(attrs.getPositionDescription() + "": Duplicate id 0x"" + Integer.toHexString(id) + "", tag "" + tag + "", or parent id 0x"" + Integer.toHexString(containerId) + "" with another fragment for "" + fname);
    } else {
        // This fragment was retained from a previous instance; get it
        // going now.
        fragment.mInLayout = true;
        fragment.mHost = mHost;
        // initialize itself.
        if (!fragment.mRetaining) {
            fragment.onInflate(mHost.getContext(), attrs, fragment.mSavedFragmentState);
        }
    }
    // for compliant fragments below.
    if (mCurState < Fragment.CREATED && fragment.mFromLayout) {
        moveToState(fragment, Fragment.CREATED, 0, 0, false);
    } else {
        moveToState(fragment);
    }
    if (fragment.mView == null) {
        throw new IllegalStateException(""Fragment "" + fname + "" did not create a view."");
    }
    if (id != 0) {
        fragment.mView.setId(id);
    }
    if (fragment.mView.getTag() == null) {
        fragment.mView.setTag(tag);
    }
    return fragment.mView;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
270,<android.util.LongSparseArray: int indexOfValue(E)>,25,26,<android.util.LongSparseArray: int indexOfValue(E)>,<android.util.LongSparseArray: int indexOfValue(E)>,0,"{
    if (mGarbage) {
        gc();
    }
    for (int i = 0; i < mSize; i++) if (mValues[i] == value)
        return i;
    return -1;
}","{
    if (mGarbage) {
        gc();
    }
    for (int i = 0; i < mSize; i++) {
        if (mValues[i] == value) {
            return i;
        }
    }
    return -1;
}",1,"/**
 * Returns an index for which {@link #valueAt} would return the
 * specified key, or a negative number if no keys map to the
 * specified value.
 * Beware that this is a linear search, unlike lookups by key,
 * and that multiple keys can map to the same value and this will
 * find only one of them.
 */
","/**
 * Returns an index for which {@link #valueAt} would return the
 * specified key, or a negative number if no keys map to the
 * specified value.
 * Beware that this is a linear search, unlike lookups by key,
 * and that multiple keys can map to the same value and this will
 * find only one of them.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"The change is only related to code formatting (the addition of curly braces around the if statement body), there's no change in the logic or behavior of the code.","As there are no changes in the code's logic or behavior, there are no Compatibility Issues between the two versions."
271,<android.hardware.camera2.CameraManager: CameraCharacteristics getCameraCharacteristics(String)>,25,26,<android.hardware.camera2.CameraManager: CameraCharacteristics getCameraCharacteristics(String)>,<android.hardware.camera2.CameraManager: CameraCharacteristics getCameraCharacteristics(String)>,0,"{
    CameraCharacteristics characteristics = null;
    synchronized (mLock) {
        if (!getOrCreateDeviceIdListLocked().contains(cameraId)) {
            throw new IllegalArgumentException(String.format(""Camera id %s does not match any"" + "" currently connected camera device"", cameraId));
        }
        int id = Integer.parseInt(cameraId);
        /*
             * Get the camera characteristics from the camera service directly if it supports it,
             * otherwise get them from the legacy shim instead.
             */
        ICameraService cameraService = CameraManagerGlobal.get().getCameraService();
        if (cameraService == null) {
            throw new CameraAccessException(CameraAccessException.CAMERA_DISCONNECTED, ""Camera service is currently unavailable"");
        }
        try {
            if (!supportsCamera2ApiLocked(cameraId)) {
                // Legacy backwards compatibility path; build static info from the camera
                // parameters
                String parameters = cameraService.getLegacyParameters(id);
                CameraInfo info = cameraService.getCameraInfo(id);
                characteristics = LegacyMetadataMapper.createCharacteristics(parameters, info);
            } else {
                // Normal path: Get the camera characteristics directly from the camera service
                CameraMetadataNative info = cameraService.getCameraCharacteristics(id);
                characteristics = new CameraCharacteristics(info);
            }
        } catch (ServiceSpecificException e) {
            throwAsPublicException(e);
        } catch (RemoteException e) {
            // Camera service died - act as if the camera was disconnected
            throw new CameraAccessException(CameraAccessException.CAMERA_DISCONNECTED, ""Camera service is currently unavailable"", e);
        }
    }
    return characteristics;
}","{
    CameraCharacteristics characteristics = null;
    synchronized (mLock) {
        /*
             * Get the camera characteristics from the camera service directly if it supports it,
             * otherwise get them from the legacy shim instead.
             */
        ICameraService cameraService = CameraManagerGlobal.get().getCameraService();
        if (cameraService == null) {
            throw new CameraAccessException(CameraAccessException.CAMERA_DISCONNECTED, ""Camera service is currently unavailable"");
        }
        try {
            if (!supportsCamera2ApiLocked(cameraId)) {
                // Legacy backwards compatibility path; build static info from the camera
                // parameters
                int id = Integer.parseInt(cameraId);
                String parameters = cameraService.getLegacyParameters(id);
                CameraInfo info = cameraService.getCameraInfo(id);
                characteristics = LegacyMetadataMapper.createCharacteristics(parameters, info);
            } else {
                // Normal path: Get the camera characteristics directly from the camera service
                CameraMetadataNative info = cameraService.getCameraCharacteristics(cameraId);
                characteristics = new CameraCharacteristics(info);
            }
        } catch (ServiceSpecificException e) {
            throwAsPublicException(e);
        } catch (RemoteException e) {
            // Camera service died - act as if the camera was disconnected
            throw new CameraAccessException(CameraAccessException.CAMERA_DISCONNECTED, ""Camera service is currently unavailable"", e);
        }
    }
    return characteristics;
}",1,"/**
 * <p>Query the capabilities of a camera device. These capabilities are
 * immutable for a given camera.</p>
 *
 * @param cameraId The id of the camera device to query
 * @return The properties of the given camera
 *
 * @throws IllegalArgumentException if the cameraId does not match any
 * known camera device.
 * @throws CameraAccessException if the camera device has been disconnected.
 *
 * @see #getCameraIdList
 * @see android.app.admin.DevicePolicyManager#setCameraDisabled
 */
","/**
 * <p>Query the capabilities of a camera device. These capabilities are
 * immutable for a given camera.</p>
 *
 * @param cameraId The id of the camera device to query
 * @return The properties of the given camera
 *
 * @throws IllegalArgumentException if the cameraId does not match any
 * known camera device.
 * @throws CameraAccessException if the camera device has been disconnected.
 *
 * @see #getCameraIdList
 * @see android.app.admin.DevicePolicyManager#setCameraDisabled
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"3,4",0,"The check for cameraId's existence in the connected devices list and the associated IllegalArgumentException have been removed, along with the parsing of the cameraId to an integer early in the code (this is now done inside the condition check for legacy path). Further, getCameraCharacteristics() now accepts a String rather than an integer id directly in the late version. These changes are related to the other statement changed and control dependency change due to the altered structure of the code and removal of a condition, which falls under types 3 and 4.","Despite the change in code structure and removal of an error check, these changes do not affect the potential behavior of the API in terms of what it returns or the exceptions it might throw. In both versions, the method ultimately returns the CameraCharacteristics object or throws CameraAccessException or the exception from throwAsPublicException() method. The operation and the exceptions that this method can throw remain functionally equivalent, despite some internal control changes, thus no Compatibility Issue should be introduced. The input argument and the output type haven't changed, and the processing of the argument inside the method does not ultimately affect the observable behavior from an API consumer's perspective."
273,"<android.hardware.camera2.dispatch.MethodNameInvoker: K invoke(String,Object)>",25,26,"<android.hardware.camera2.dispatch.MethodNameInvoker: K invoke(String,Object)>","<android.hardware.camera2.dispatch.MethodNameInvoker: K invoke(String,Object)>",0,"{
    checkNotNull(methodName, ""methodName must not be null"");
    Method targetMethod = mMethods.get(methodName);
    if (targetMethod == null) {
        for (Method method : mTargetClass.getMethods()) {
            // TODO future: match types of params if possible
            if (method.getName().equals(methodName) && (params.length == method.getParameterTypes().length)) {
                targetMethod = method;
                mMethods.put(methodName, targetMethod);
                break;
            }
        }
        if (targetMethod == null) {
            throw new IllegalArgumentException(""Method "" + methodName + "" does not exist on class "" + mTargetClass);
        }
    }
    try {
        return (K) mTarget.dispatch(targetMethod, params);
    } catch (Throwable e) {
        UncheckedThrow.throwAnyException(e);
        // unreachable
        return null;
    }
}","{
    checkNotNull(methodName, ""methodName must not be null"");
    Method targetMethod = mMethods.get(methodName);
    if (targetMethod == null) {
        for (Method method : mTargetClassMethods) {
            // TODO future: match types of params if possible
            if (method.getName().equals(methodName) && (params.length == method.getParameterTypes().length)) {
                targetMethod = method;
                mMethods.put(methodName, targetMethod);
                break;
            }
        }
        if (targetMethod == null) {
            throw new IllegalArgumentException(""Method "" + methodName + "" does not exist on class "" + mTargetClass);
        }
    }
    try {
        return (K) mTarget.dispatch(targetMethod, params);
    } catch (Throwable e) {
        UncheckedThrow.throwAnyException(e);
        // unreachable
        return null;
    }
}",1,"/**
 * Invoke a method by its name.
 *
 * <p>If more than one method exists in {@code targetClass}, the first method with the right
 * number of arguments will be used, and later calls will all use that method.</p>
 *
 * @param methodName
 * The name of the method, which will be matched 1:1 to the destination method
 * @param params
 * Variadic parameter list.
 * @return
 * The same kind of value that would normally be returned by calling {@code methodName}
 * statically.
 *
 * @throws IllegalArgumentException if {@code methodName} does not exist on the target class
 * @throws Throwable will rethrow anything that the target method would normally throw
 */
","/**
 * Invoke a method by its name.
 *
 * <p>If more than one method exists in {@code targetClass}, the first method with the right
 * number of arguments will be used, and later calls will all use that method.</p>
 *
 * @param methodName
 * The name of the method, which will be matched 1:1 to the destination method
 * @param params
 * Variadic parameter list.
 * @return
 * The same kind of value that would normally be returned by calling {@code methodName}
 * statically.
 *
 * @throws IllegalArgumentException if {@code methodName} does not exist on the target class
 * @throws Throwable will rethrow anything that the target method would normally throw
 */
",-1,"[@SuppressWarnings(""unchecked"")]","[@SuppressWarnings(""unchecked"")]",-1,-1,-1,-1,-1,-1,0,0,"There are no functional changes in the code between these two versions. It just appears that the member variable `mTargetClass.getMethods()` has been replaced with `mTargetClassMethods`, which seems like an internal refactoring that does not affect the behavior of the code as long as `mTargetClassMethods` is appropriately initialized to `mTargetClass.getMethods()`. ",There are no Compatibility Issues as there are no changes in the behavior of the API.
274,<android.widget.TextView: CharSequence removeSuggestionSpans(CharSequence)>,25,26,<android.widget.TextView: CharSequence removeSuggestionSpans(CharSequence)>,<android.widget.TextView: CharSequence removeSuggestionSpans(CharSequence)>,0,"{
    if (text instanceof Spanned) {
        Spannable spannable;
        if (text instanceof Spannable) {
            spannable = (Spannable) text;
        } else {
            spannable = new SpannableString(text);
            text = spannable;
        }
        SuggestionSpan[] spans = spannable.getSpans(0, text.length(), SuggestionSpan.class);
        for (int i = 0; i < spans.length; i++) {
            spannable.removeSpan(spans[i]);
        }
    }
    return text;
}","{
    if (text instanceof Spanned) {
        Spannable spannable;
        if (text instanceof Spannable) {
            spannable = (Spannable) text;
        } else {
            spannable = mSpannableFactory.newSpannable(text);
            text = spannable;
        }
        SuggestionSpan[] spans = spannable.getSpans(0, text.length(), SuggestionSpan.class);
        for (int i = 0; i < spans.length; i++) {
            spannable.removeSpan(spans[i]);
        }
    }
    return text;
}",1,"/**
 * Removes the suggestion spans.
 */
","/**
 * Removes the suggestion spans.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The only change in the method implementation is the way the `Spannable` instance is created. In the early version, it is directly created using `new SpannableString(text)`, but in the late version `mSpannableFactory.newSpannable(text)` is used instead. This means a dependent API (`newSpannable`) is invoked which could have a different implementation. Therefore, the code change type is 5.","There is no Compatibility Issue here because the change does not affect the return value or the exception handling of the method. The method's behavior still results in the removal of `SuggestionSpan` objects from the `CharSequence` and returns the altered text. The underlying creation process of the `Spannable` object is an internal detail that does not affect the method's contract or outward behavior. Moreover, there are no changes to how exceptions are handled within the method or what values it might return. Thus, there are no potential different return values or exception handlings introduced by this change."
275,"<android.app.admin.DevicePolicyManager: boolean isPackageSuspended(ComponentName,String)>",25,26,"<android.app.admin.DevicePolicyManager: boolean isPackageSuspended(ComponentName,String)>","<android.app.admin.DevicePolicyManager: boolean isPackageSuspended(ComponentName,String)>",0,"{
    throwIfParentInstance(""isPackageSuspended"");
    if (mService != null) {
        try {
            return mService.isPackageSuspended(admin, packageName);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        } catch (IllegalArgumentException ex) {
            throw new NameNotFoundException(packageName);
        }
    }
    return false;
}","{
    throwIfParentInstance(""isPackageSuspended"");
    if (mService != null) {
        try {
            return mService.isPackageSuspended(admin, mContext.getPackageName(), packageName);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        } catch (IllegalArgumentException ex) {
            throw new NameNotFoundException(packageName);
        }
    }
    return false;
}",1,"/**
 * Called by device or profile owners to determine if a package is suspended.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param packageName The name of the package to retrieve the suspended status of.
 * @return {@code true} if the package is suspended or {@code false} if the package is not
 * suspended, could not be found or an error occurred.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 * @throws NameNotFoundException if the package could not be found.
 */
","/**
 * Determine if a package is suspended. This function can be called by a device owner, profile
 * owner, or by a delegate given the {@link #DELEGATION_PACKAGE_ACCESS} scope via
 * {@link #setDelegatedScopes}.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or
 * {@code null} if the caller is a package access delegate.
 * @param packageName The name of the package to retrieve the suspended status of.
 * @return {@code true} if the package is suspended or {@code false} if the package is not
 * suspended, could not be found or an error occurred.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 * @throws NameNotFoundException if the package could not be found.
 * @see #setDelegatedScopes
 * @see #DELEGATION_PACKAGE_ACCESS
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,The dependent method `isPackageSuspended`'s parameter list has changed by adding `mContext.getPackageName()` as an additional argument. This is the change type 5.,"As the `isPackageSuspended` method call is updated with an additional parameter, but the additional parameter is obtained from the context (`mContext.getPackageName()`), this most likely represents a change to pass the caller's package name as an argument to the method. If this method is designed to handle backwards compatibility internally and the added argument does not alter the method's return value or exception handling for calls of this API, there would be no compatibility issue. Therefore, the compatibility issue is classified as 0 because the outward contract of the method does not appear to be altered for the clients of this API."
276,<android.os.UserManager: boolean isUserRunningOrStopping(UserHandle)>,25,26,<android.os.UserManager: boolean isUserRunningOrStopping(UserHandle)>,<android.os.UserManager: boolean isUserRunningOrStopping(UserHandle)>,0,"{
    try {
        // TODO: reconcile stopped vs stopping?
        return ActivityManagerNative.getDefault().isUserRunning(user.getIdentifier(), ActivityManager.FLAG_OR_STOPPED);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}","{
    try {
        // TODO: reconcile stopped vs stopping?
        return ActivityManager.getService().isUserRunning(user.getIdentifier(), ActivityManager.FLAG_OR_STOPPED);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}",1,"/**
 * Return whether the given user is actively running <em>or</em> stopping.
 * This is like {@link #isUserRunning(UserHandle)}, but will also return
 * true if the user had been running but is in the process of being stopped
 * (but is not yet fully stopped, and still running some code).
 * @param user The user to retrieve the running state for.
 */
","// Note this requires either INTERACT_ACROSS_USERS or MANAGE_USERS.
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method used to get the ActivityManager service has changed from ActivityManagerNative.getDefault() to ActivityManager.getService(). The change affects the dependent API that is being called, thus making it a code change type 5.","There is no Compatibility Issue since the method signature and return type remain the same, and the behavior of the API is meant to remain unchanged from the caller's perspective despite the internal change to how the service is accessed. Therefore, the CI type is 0."
277,<android.widget.TextView: int getVerticalOffset(boolean)>,25,26,<android.widget.TextView: int getVerticalOffset(boolean)>,<android.widget.TextView: int getVerticalOffset(boolean)>,0,"{
    int voffset = 0;
    final int gravity = mGravity & Gravity.VERTICAL_GRAVITY_MASK;
    Layout l = mLayout;
    if (!forceNormal && mText.length() == 0 && mHintLayout != null) {
        l = mHintLayout;
    }
    if (gravity != Gravity.TOP) {
        int boxht = getBoxHeight(l);
        int textht = l.getHeight();
        if (textht < boxht) {
            if (gravity == Gravity.BOTTOM)
                voffset = boxht - textht;
            else
                // (gravity == Gravity.CENTER_VERTICAL)
                voffset = (boxht - textht) >> 1;
        }
    }
    return voffset;
}","{
    int voffset = 0;
    final int gravity = mGravity & Gravity.VERTICAL_GRAVITY_MASK;
    Layout l = mLayout;
    if (!forceNormal && mText.length() == 0 && mHintLayout != null) {
        l = mHintLayout;
    }
    if (gravity != Gravity.TOP) {
        int boxht = getBoxHeight(l);
        int textht = l.getHeight();
        if (textht < boxht) {
            if (gravity == Gravity.BOTTOM) {
                voffset = boxht - textht;
            } else {
                // (gravity == Gravity.CENTER_VERTICAL)
                voffset = (boxht - textht) >> 1;
            }
        }
    }
    return voffset;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change is only in the formatting where braces are added to the 'if' and 'else' blocks for clarity. There is no change in the logic or the flow of execution, so the change type is 4.","There is no change in the behavior of the API, as the underlying code logic and return statements remain the same. The brackets do not alter the execution path or the outcome, therefore there is no compatibility issue; the CI type is 0."
278,<android.view.GestureDetector: boolean onTouchEvent(MotionEvent)>,25,26,<android.view.GestureDetector: boolean onTouchEvent(MotionEvent)>,<android.view.GestureDetector: boolean onTouchEvent(MotionEvent)>,0,"{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(ev, 0);
    }
    final int action = ev.getAction();
    if (mVelocityTracker == null) {
        mVelocityTracker = VelocityTracker.obtain();
    }
    mVelocityTracker.addMovement(ev);
    final boolean pointerUp = (action & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_POINTER_UP;
    final int skipIndex = pointerUp ? ev.getActionIndex() : -1;
    // Determine focal point
    float sumX = 0, sumY = 0;
    final int count = ev.getPointerCount();
    for (int i = 0; i < count; i++) {
        if (skipIndex == i)
            continue;
        sumX += ev.getX(i);
        sumY += ev.getY(i);
    }
    final int div = pointerUp ? count - 1 : count;
    final float focusX = sumX / div;
    final float focusY = sumY / div;
    boolean handled = false;
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_POINTER_DOWN:
            mDownFocusX = mLastFocusX = focusX;
            mDownFocusY = mLastFocusY = focusY;
            // Cancel long press and taps
            cancelTaps();
            break;
        case MotionEvent.ACTION_POINTER_UP:
            mDownFocusX = mLastFocusX = focusX;
            mDownFocusY = mLastFocusY = focusY;
            // Check the dot product of current velocities.
            // If the pointer that left was opposing another velocity vector, clear.
            mVelocityTracker.computeCurrentVelocity(1000, mMaximumFlingVelocity);
            final int upIndex = ev.getActionIndex();
            final int id1 = ev.getPointerId(upIndex);
            final float x1 = mVelocityTracker.getXVelocity(id1);
            final float y1 = mVelocityTracker.getYVelocity(id1);
            for (int i = 0; i < count; i++) {
                if (i == upIndex)
                    continue;
                final int id2 = ev.getPointerId(i);
                final float x = x1 * mVelocityTracker.getXVelocity(id2);
                final float y = y1 * mVelocityTracker.getYVelocity(id2);
                final float dot = x + y;
                if (dot < 0) {
                    mVelocityTracker.clear();
                    break;
                }
            }
            break;
        case MotionEvent.ACTION_DOWN:
            if (mDoubleTapListener != null) {
                boolean hadTapMessage = mHandler.hasMessages(TAP);
                if (hadTapMessage)
                    mHandler.removeMessages(TAP);
                if ((mCurrentDownEvent != null) && (mPreviousUpEvent != null) && hadTapMessage && isConsideredDoubleTap(mCurrentDownEvent, mPreviousUpEvent, ev)) {
                    // This is a second tap
                    mIsDoubleTapping = true;
                    // Give a callback with the first tap of the double-tap
                    handled |= mDoubleTapListener.onDoubleTap(mCurrentDownEvent);
                    // Give a callback with down event of the double-tap
                    handled |= mDoubleTapListener.onDoubleTapEvent(ev);
                } else {
                    // This is a first tap
                    mHandler.sendEmptyMessageDelayed(TAP, DOUBLE_TAP_TIMEOUT);
                }
            }
            mDownFocusX = mLastFocusX = focusX;
            mDownFocusY = mLastFocusY = focusY;
            if (mCurrentDownEvent != null) {
                mCurrentDownEvent.recycle();
            }
            mCurrentDownEvent = MotionEvent.obtain(ev);
            mAlwaysInTapRegion = true;
            mAlwaysInBiggerTapRegion = true;
            mStillDown = true;
            mInLongPress = false;
            mDeferConfirmSingleTap = false;
            if (mIsLongpressEnabled) {
                mHandler.removeMessages(LONG_PRESS);
                mHandler.sendEmptyMessageAtTime(LONG_PRESS, mCurrentDownEvent.getDownTime() + TAP_TIMEOUT + LONGPRESS_TIMEOUT);
            }
            mHandler.sendEmptyMessageAtTime(SHOW_PRESS, mCurrentDownEvent.getDownTime() + TAP_TIMEOUT);
            handled |= mListener.onDown(ev);
            break;
        case MotionEvent.ACTION_MOVE:
            if (mInLongPress || mInContextClick) {
                break;
            }
            final float scrollX = mLastFocusX - focusX;
            final float scrollY = mLastFocusY - focusY;
            if (mIsDoubleTapping) {
                // Give the move events of the double-tap
                handled |= mDoubleTapListener.onDoubleTapEvent(ev);
            } else if (mAlwaysInTapRegion) {
                final int deltaX = (int) (focusX - mDownFocusX);
                final int deltaY = (int) (focusY - mDownFocusY);
                int distance = (deltaX * deltaX) + (deltaY * deltaY);
                if (distance > mTouchSlopSquare) {
                    handled = mListener.onScroll(mCurrentDownEvent, ev, scrollX, scrollY);
                    mLastFocusX = focusX;
                    mLastFocusY = focusY;
                    mAlwaysInTapRegion = false;
                    mHandler.removeMessages(TAP);
                    mHandler.removeMessages(SHOW_PRESS);
                    mHandler.removeMessages(LONG_PRESS);
                }
                if (distance > mDoubleTapTouchSlopSquare) {
                    mAlwaysInBiggerTapRegion = false;
                }
            } else if ((Math.abs(scrollX) >= 1) || (Math.abs(scrollY) >= 1)) {
                handled = mListener.onScroll(mCurrentDownEvent, ev, scrollX, scrollY);
                mLastFocusX = focusX;
                mLastFocusY = focusY;
            }
            break;
        case MotionEvent.ACTION_UP:
            mStillDown = false;
            MotionEvent currentUpEvent = MotionEvent.obtain(ev);
            if (mIsDoubleTapping) {
                // Finally, give the up event of the double-tap
                handled |= mDoubleTapListener.onDoubleTapEvent(ev);
            } else if (mInLongPress) {
                mHandler.removeMessages(TAP);
                mInLongPress = false;
            } else if (mAlwaysInTapRegion && !mIgnoreNextUpEvent) {
                handled = mListener.onSingleTapUp(ev);
                if (mDeferConfirmSingleTap && mDoubleTapListener != null) {
                    mDoubleTapListener.onSingleTapConfirmed(ev);
                }
            } else if (!mIgnoreNextUpEvent) {
                // A fling must travel the minimum tap distance
                final VelocityTracker velocityTracker = mVelocityTracker;
                final int pointerId = ev.getPointerId(0);
                velocityTracker.computeCurrentVelocity(1000, mMaximumFlingVelocity);
                final float velocityY = velocityTracker.getYVelocity(pointerId);
                final float velocityX = velocityTracker.getXVelocity(pointerId);
                if ((Math.abs(velocityY) > mMinimumFlingVelocity) || (Math.abs(velocityX) > mMinimumFlingVelocity)) {
                    handled = mListener.onFling(mCurrentDownEvent, ev, velocityX, velocityY);
                }
            }
            if (mPreviousUpEvent != null) {
                mPreviousUpEvent.recycle();
            }
            // Hold the event we obtained above - listeners may have changed the original.
            mPreviousUpEvent = currentUpEvent;
            if (mVelocityTracker != null) {
                // This may have been cleared when we called out to the
                // application above.
                mVelocityTracker.recycle();
                mVelocityTracker = null;
            }
            mIsDoubleTapping = false;
            mDeferConfirmSingleTap = false;
            mIgnoreNextUpEvent = false;
            mHandler.removeMessages(SHOW_PRESS);
            mHandler.removeMessages(LONG_PRESS);
            break;
        case MotionEvent.ACTION_CANCEL:
            cancel();
            break;
    }
    if (!handled && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 0);
    }
    return handled;
}","{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(ev, 0);
    }
    final int action = ev.getAction();
    if (mVelocityTracker == null) {
        mVelocityTracker = VelocityTracker.obtain();
    }
    mVelocityTracker.addMovement(ev);
    final boolean pointerUp = (action & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_POINTER_UP;
    final int skipIndex = pointerUp ? ev.getActionIndex() : -1;
    final boolean isGeneratedGesture = (ev.getFlags() & MotionEvent.FLAG_IS_GENERATED_GESTURE) != 0;
    // Determine focal point
    float sumX = 0, sumY = 0;
    final int count = ev.getPointerCount();
    for (int i = 0; i < count; i++) {
        if (skipIndex == i)
            continue;
        sumX += ev.getX(i);
        sumY += ev.getY(i);
    }
    final int div = pointerUp ? count - 1 : count;
    final float focusX = sumX / div;
    final float focusY = sumY / div;
    boolean handled = false;
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_POINTER_DOWN:
            mDownFocusX = mLastFocusX = focusX;
            mDownFocusY = mLastFocusY = focusY;
            // Cancel long press and taps
            cancelTaps();
            break;
        case MotionEvent.ACTION_POINTER_UP:
            mDownFocusX = mLastFocusX = focusX;
            mDownFocusY = mLastFocusY = focusY;
            // Check the dot product of current velocities.
            // If the pointer that left was opposing another velocity vector, clear.
            mVelocityTracker.computeCurrentVelocity(1000, mMaximumFlingVelocity);
            final int upIndex = ev.getActionIndex();
            final int id1 = ev.getPointerId(upIndex);
            final float x1 = mVelocityTracker.getXVelocity(id1);
            final float y1 = mVelocityTracker.getYVelocity(id1);
            for (int i = 0; i < count; i++) {
                if (i == upIndex)
                    continue;
                final int id2 = ev.getPointerId(i);
                final float x = x1 * mVelocityTracker.getXVelocity(id2);
                final float y = y1 * mVelocityTracker.getYVelocity(id2);
                final float dot = x + y;
                if (dot < 0) {
                    mVelocityTracker.clear();
                    break;
                }
            }
            break;
        case MotionEvent.ACTION_DOWN:
            if (mDoubleTapListener != null) {
                boolean hadTapMessage = mHandler.hasMessages(TAP);
                if (hadTapMessage)
                    mHandler.removeMessages(TAP);
                if ((mCurrentDownEvent != null) && (mPreviousUpEvent != null) && hadTapMessage && isConsideredDoubleTap(mCurrentDownEvent, mPreviousUpEvent, ev)) {
                    // This is a second tap
                    mIsDoubleTapping = true;
                    // Give a callback with the first tap of the double-tap
                    handled |= mDoubleTapListener.onDoubleTap(mCurrentDownEvent);
                    // Give a callback with down event of the double-tap
                    handled |= mDoubleTapListener.onDoubleTapEvent(ev);
                } else {
                    // This is a first tap
                    mHandler.sendEmptyMessageDelayed(TAP, DOUBLE_TAP_TIMEOUT);
                }
            }
            mDownFocusX = mLastFocusX = focusX;
            mDownFocusY = mLastFocusY = focusY;
            if (mCurrentDownEvent != null) {
                mCurrentDownEvent.recycle();
            }
            mCurrentDownEvent = MotionEvent.obtain(ev);
            mAlwaysInTapRegion = true;
            mAlwaysInBiggerTapRegion = true;
            mStillDown = true;
            mInLongPress = false;
            mDeferConfirmSingleTap = false;
            if (mIsLongpressEnabled) {
                mHandler.removeMessages(LONG_PRESS);
                mHandler.sendEmptyMessageAtTime(LONG_PRESS, mCurrentDownEvent.getDownTime() + LONGPRESS_TIMEOUT);
            }
            mHandler.sendEmptyMessageAtTime(SHOW_PRESS, mCurrentDownEvent.getDownTime() + TAP_TIMEOUT);
            handled |= mListener.onDown(ev);
            break;
        case MotionEvent.ACTION_MOVE:
            if (mInLongPress || mInContextClick) {
                break;
            }
            final float scrollX = mLastFocusX - focusX;
            final float scrollY = mLastFocusY - focusY;
            if (mIsDoubleTapping) {
                // Give the move events of the double-tap
                handled |= mDoubleTapListener.onDoubleTapEvent(ev);
            } else if (mAlwaysInTapRegion) {
                final int deltaX = (int) (focusX - mDownFocusX);
                final int deltaY = (int) (focusY - mDownFocusY);
                int distance = (deltaX * deltaX) + (deltaY * deltaY);
                int slopSquare = isGeneratedGesture ? 0 : mTouchSlopSquare;
                if (distance > slopSquare) {
                    handled = mListener.onScroll(mCurrentDownEvent, ev, scrollX, scrollY);
                    mLastFocusX = focusX;
                    mLastFocusY = focusY;
                    mAlwaysInTapRegion = false;
                    mHandler.removeMessages(TAP);
                    mHandler.removeMessages(SHOW_PRESS);
                    mHandler.removeMessages(LONG_PRESS);
                }
                int doubleTapSlopSquare = isGeneratedGesture ? 0 : mDoubleTapTouchSlopSquare;
                if (distance > doubleTapSlopSquare) {
                    mAlwaysInBiggerTapRegion = false;
                }
            } else if ((Math.abs(scrollX) >= 1) || (Math.abs(scrollY) >= 1)) {
                handled = mListener.onScroll(mCurrentDownEvent, ev, scrollX, scrollY);
                mLastFocusX = focusX;
                mLastFocusY = focusY;
            }
            break;
        case MotionEvent.ACTION_UP:
            mStillDown = false;
            MotionEvent currentUpEvent = MotionEvent.obtain(ev);
            if (mIsDoubleTapping) {
                // Finally, give the up event of the double-tap
                handled |= mDoubleTapListener.onDoubleTapEvent(ev);
            } else if (mInLongPress) {
                mHandler.removeMessages(TAP);
                mInLongPress = false;
            } else if (mAlwaysInTapRegion && !mIgnoreNextUpEvent) {
                handled = mListener.onSingleTapUp(ev);
                if (mDeferConfirmSingleTap && mDoubleTapListener != null) {
                    mDoubleTapListener.onSingleTapConfirmed(ev);
                }
            } else if (!mIgnoreNextUpEvent) {
                // A fling must travel the minimum tap distance
                final VelocityTracker velocityTracker = mVelocityTracker;
                final int pointerId = ev.getPointerId(0);
                velocityTracker.computeCurrentVelocity(1000, mMaximumFlingVelocity);
                final float velocityY = velocityTracker.getYVelocity(pointerId);
                final float velocityX = velocityTracker.getXVelocity(pointerId);
                if ((Math.abs(velocityY) > mMinimumFlingVelocity) || (Math.abs(velocityX) > mMinimumFlingVelocity)) {
                    handled = mListener.onFling(mCurrentDownEvent, ev, velocityX, velocityY);
                }
            }
            if (mPreviousUpEvent != null) {
                mPreviousUpEvent.recycle();
            }
            // Hold the event we obtained above - listeners may have changed the original.
            mPreviousUpEvent = currentUpEvent;
            if (mVelocityTracker != null) {
                // This may have been cleared when we called out to the
                // application above.
                mVelocityTracker.recycle();
                mVelocityTracker = null;
            }
            mIsDoubleTapping = false;
            mDeferConfirmSingleTap = false;
            mIgnoreNextUpEvent = false;
            mHandler.removeMessages(SHOW_PRESS);
            mHandler.removeMessages(LONG_PRESS);
            break;
        case MotionEvent.ACTION_CANCEL:
            cancel();
            break;
    }
    if (!handled && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 0);
    }
    return handled;
}",1,"/**
 * Analyzes the given motion event and if applicable triggers the
 * appropriate callbacks on the {@link OnGestureListener} supplied.
 *
 * @param ev The current motion event.
 * @return true if the {@link OnGestureListener} consumed the event,
 * else false.
 */
","/**
 * Analyzes the given motion event and if applicable triggers the
 * appropriate callbacks on the {@link OnGestureListener} supplied.
 *
 * @param ev The current motion event.
 * @return true if the {@link OnGestureListener} consumed the event,
 * else false.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
279,"<android.util.ArrayMap: int indexOf(Object,int)>",25,26,"<android.util.ArrayMap: int indexOf(Object,int)>","<android.util.ArrayMap: int indexOf(Object,int)>",0,"{
    final int N = mSize;
    // Important fast case: if nothing is in here, nothing to look for.
    if (N == 0) {
        return ~0;
    }
    int index = ContainerHelpers.binarySearch(mHashes, N, hash);
    // If the hash code wasn't found, then we have no entry for this key.
    if (index < 0) {
        return index;
    }
    // If the key at the returned index matches, that's what we want.
    if (key.equals(mArray[index << 1])) {
        return index;
    }
    // Search for a matching key after the index.
    int end;
    for (end = index + 1; end < N && mHashes[end] == hash; end++) {
        if (key.equals(mArray[end << 1]))
            return end;
    }
    // Search for a matching key before the index.
    for (int i = index - 1; i >= 0 && mHashes[i] == hash; i--) {
        if (key.equals(mArray[i << 1]))
            return i;
    }
    // need to be copied when inserting.
    return ~end;
}","{
    final int N = mSize;
    // Important fast case: if nothing is in here, nothing to look for.
    if (N == 0) {
        return ~0;
    }
    int index = binarySearchHashes(mHashes, N, hash);
    // If the hash code wasn't found, then we have no entry for this key.
    if (index < 0) {
        return index;
    }
    // If the key at the returned index matches, that's what we want.
    if (key.equals(mArray[index << 1])) {
        return index;
    }
    // Search for a matching key after the index.
    int end;
    for (end = index + 1; end < N && mHashes[end] == hash; end++) {
        if (key.equals(mArray[end << 1]))
            return end;
    }
    // Search for a matching key before the index.
    for (int i = index - 1; i >= 0 && mHashes[i] == hash; i--) {
        if (key.equals(mArray[i << 1]))
            return i;
    }
    // need to be copied when inserting.
    return ~end;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method used for the binary search has changed from ContainerHelpers.binarySearch() to binarySearchHashes(). This change does not affect the control flow or any other part of the method logic, but reflects an update in the method called for the binary search operation, so the change type is 4,5.","Despite the change in the method used for binary search, there is no actual change to the logic of how the method computes the index, and therefore no change in the behavior of the API that would lead to different return values or exceptions between the two versions. Thus, there is no compatibility issue."
280,<android.inputmethodservice.IInputMethodWrapper: void executeMessage(Message)>,25,26,<android.inputmethodservice.IInputMethodWrapper: void executeMessage(Message)>,<android.inputmethodservice.IInputMethodWrapper: void executeMessage(Message)>,0,"{
    InputMethod inputMethod = mInputMethod.get();
    // Need a valid reference to the inputMethod for everything except a dump.
    if (inputMethod == null && msg.what != DO_DUMP) {
        Log.w(TAG, ""Input method reference was null, ignoring message: "" + msg.what);
        return;
    }
    switch(msg.what) {
        case DO_DUMP:
            {
                AbstractInputMethodService target = mTarget.get();
                if (target == null) {
                    return;
                }
                SomeArgs args = (SomeArgs) msg.obj;
                try {
                    target.dump((FileDescriptor) args.arg1, (PrintWriter) args.arg2, (String[]) args.arg3);
                } catch (RuntimeException e) {
                    ((PrintWriter) args.arg2).println(""Exception: "" + e);
                }
                synchronized (args.arg4) {
                    ((CountDownLatch) args.arg4).countDown();
                }
                args.recycle();
                return;
            }
        case DO_ATTACH_TOKEN:
            {
                inputMethod.attachToken((IBinder) msg.obj);
                return;
            }
        case DO_SET_INPUT_CONTEXT:
            {
                inputMethod.bindInput((InputBinding) msg.obj);
                return;
            }
        case DO_UNSET_INPUT_CONTEXT:
            inputMethod.unbindInput();
            return;
        case DO_START_INPUT:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                int missingMethods = msg.arg1;
                IInputContext inputContext = (IInputContext) args.arg1;
                InputConnection ic = inputContext != null ? new InputConnectionWrapper(mTarget, inputContext, missingMethods) : null;
                EditorInfo info = (EditorInfo) args.arg2;
                info.makeCompatible(mTargetSdkVersion);
                inputMethod.startInput(ic, info);
                args.recycle();
                return;
            }
        case DO_RESTART_INPUT:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                int missingMethods = msg.arg1;
                IInputContext inputContext = (IInputContext) args.arg1;
                InputConnection ic = inputContext != null ? new InputConnectionWrapper(mTarget, inputContext, missingMethods) : null;
                EditorInfo info = (EditorInfo) args.arg2;
                info.makeCompatible(mTargetSdkVersion);
                inputMethod.restartInput(ic, info);
                args.recycle();
                return;
            }
        case DO_CREATE_SESSION:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                inputMethod.createSession(new InputMethodSessionCallbackWrapper(mContext, (InputChannel) args.arg1, (IInputSessionCallback) args.arg2));
                args.recycle();
                return;
            }
        case DO_SET_SESSION_ENABLED:
            inputMethod.setSessionEnabled((InputMethodSession) msg.obj, msg.arg1 != 0);
            return;
        case DO_REVOKE_SESSION:
            inputMethod.revokeSession((InputMethodSession) msg.obj);
            return;
        case DO_SHOW_SOFT_INPUT:
            inputMethod.showSoftInput(msg.arg1, (ResultReceiver) msg.obj);
            return;
        case DO_HIDE_SOFT_INPUT:
            inputMethod.hideSoftInput(msg.arg1, (ResultReceiver) msg.obj);
            return;
        case DO_CHANGE_INPUTMETHOD_SUBTYPE:
            inputMethod.changeInputMethodSubtype((InputMethodSubtype) msg.obj);
            return;
    }
    Log.w(TAG, ""Unhandled message code: "" + msg.what);
}","{
    InputMethod inputMethod = mInputMethod.get();
    // Need a valid reference to the inputMethod for everything except a dump.
    if (inputMethod == null && msg.what != DO_DUMP) {
        Log.w(TAG, ""Input method reference was null, ignoring message: "" + msg.what);
        return;
    }
    switch(msg.what) {
        case DO_DUMP:
            {
                AbstractInputMethodService target = mTarget.get();
                if (target == null) {
                    return;
                }
                SomeArgs args = (SomeArgs) msg.obj;
                try {
                    target.dump((FileDescriptor) args.arg1, (PrintWriter) args.arg2, (String[]) args.arg3);
                } catch (RuntimeException e) {
                    ((PrintWriter) args.arg2).println(""Exception: "" + e);
                }
                synchronized (args.arg4) {
                    ((CountDownLatch) args.arg4).countDown();
                }
                args.recycle();
                return;
            }
        case DO_ATTACH_TOKEN:
            {
                inputMethod.attachToken((IBinder) msg.obj);
                return;
            }
        case DO_SET_INPUT_CONTEXT:
            {
                inputMethod.bindInput((InputBinding) msg.obj);
                return;
            }
        case DO_UNSET_INPUT_CONTEXT:
            inputMethod.unbindInput();
            return;
        case DO_START_INPUT:
            {
                final SomeArgs args = (SomeArgs) msg.obj;
                final int missingMethods = msg.arg1;
                final boolean restarting = msg.arg2 != 0;
                final IBinder startInputToken = (IBinder) args.arg1;
                final IInputContext inputContext = (IInputContext) args.arg2;
                final EditorInfo info = (EditorInfo) args.arg3;
                final InputConnection ic = inputContext != null ? new InputConnectionWrapper(mTarget, inputContext, missingMethods) : null;
                info.makeCompatible(mTargetSdkVersion);
                inputMethod.dispatchStartInputWithToken(ic, info, restarting, /* restarting */
                startInputToken);
                args.recycle();
                return;
            }
        case DO_CREATE_SESSION:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                inputMethod.createSession(new InputMethodSessionCallbackWrapper(mContext, (InputChannel) args.arg1, (IInputSessionCallback) args.arg2));
                args.recycle();
                return;
            }
        case DO_SET_SESSION_ENABLED:
            inputMethod.setSessionEnabled((InputMethodSession) msg.obj, msg.arg1 != 0);
            return;
        case DO_REVOKE_SESSION:
            inputMethod.revokeSession((InputMethodSession) msg.obj);
            return;
        case DO_SHOW_SOFT_INPUT:
            inputMethod.showSoftInput(msg.arg1, (ResultReceiver) msg.obj);
            return;
        case DO_HIDE_SOFT_INPUT:
            inputMethod.hideSoftInput(msg.arg1, (ResultReceiver) msg.obj);
            return;
        case DO_CHANGE_INPUTMETHOD_SUBTYPE:
            inputMethod.changeInputMethodSubtype((InputMethodSubtype) msg.obj);
            return;
    }
    Log.w(TAG, ""Unhandled message code: "" + msg.what);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
281,<android.app.Fragment: Transition getReturnTransition()>,25,26,<android.app.Fragment: Transition getReturnTransition()>,<android.app.Fragment: Transition getReturnTransition()>,0,"{
    return mReturnTransition == USE_DEFAULT_TRANSITION ? getEnterTransition() : mReturnTransition;
}","{
    if (mAnimationInfo == null) {
        return null;
    }
    return mAnimationInfo.mReturnTransition == USE_DEFAULT_TRANSITION ? getEnterTransition() : mAnimationInfo.mReturnTransition;
}",1,"/**
 * Returns the Transition that will be used to move Views out of the scene when the Fragment is
 * preparing to be removed, hidden, or detached because of popping the back stack. The exiting
 * Views will be those that are regular Views or ViewGroups that have
 * {@link ViewGroup#isTransitionGroup} return true. Typical Transitions will extend
 * {@link android.transition.Visibility} as entering is governed by changing visibility from
 * {@link View#VISIBLE} to {@link View#INVISIBLE}. If <code>transition</code> is null,
 * entering Views will remain unaffected.
 *
 * @return the Transition to use to move Views out of the Scene when the Fragment
 * is preparing to close.
 * @attr ref android.R.styleable#Fragment_fragmentExitTransition
 */
","/**
 * Returns the Transition that will be used to move Views out of the scene when the Fragment is
 * preparing to be removed, hidden, or detached because of popping the back stack. The exiting
 * Views will be those that are regular Views or ViewGroups that have
 * {@link ViewGroup#isTransitionGroup} return true. Typical Transitions will extend
 * {@link android.transition.Visibility} as entering is governed by changing visibility from
 * {@link View#VISIBLE} to {@link View#INVISIBLE}. If <code>transition</code> is null,
 * entering Views will remain unaffected.
 *
 * @return the Transition to use to move Views out of the Scene when the Fragment
 * is preparing to close.
 * @attr ref android.R.styleable#Fragment_fragmentExitTransition
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The implementation was changed to include a new control dependency that checks if `mAnimationInfo` is null before returning a value, and the reference to the `mReturnTransition` was changed to `mAnimationInfo.mReturnTransition`. This leads to a change in both return statement and control dependency, so the code change type is 1,3.","The return value of the method can be different. In the early version, the method directly returns either `getEnterTransition()` or `mReturnTransition`. In the late version, it checks if `mAnimationInfo` is null first, which could potentially lead to the method returning null when it would not have done so previously. Therefore, the potential for a different return value exists, which is a CI type of 1."
282,<android.app.ActivityManager: MemoryInfo[] getProcessMemoryInfo(int[])>,25,26,<android.app.ActivityManager: MemoryInfo[] getProcessMemoryInfo(int[])>,<android.app.ActivityManager: MemoryInfo[] getProcessMemoryInfo(int[])>,0,"{
    try {
        return ActivityManagerNative.getDefault().getProcessMemoryInfo(pids);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        return getService().getProcessMemoryInfo(pids);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Return information about the memory usage of one or more processes.
 *
 * <p><b>Note: this method is only intended for debugging or building
 * a user-facing process management UI.</b></p>
 *
 * @param pids The pids of the processes whose memory usage is to be
 * retrieved.
 * @return Returns an array of memory information, one for each
 * requested pid.
 */
","/**
 * Return information about the memory usage of one or more processes.
 *
 * <p><b>Note: this method is only intended for debugging or building
 * a user-facing process management UI.</b></p>
 *
 * @param pids The pids of the processes whose memory usage is to be
 * retrieved.
 * @return Returns an array of memory information, one for each
 * requested pid.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"There's a change from directly calling ActivityManagerNative.getDefault() to calling getService(), which implicitly calls something that has the same function but through a different method. This is a Dependent API changed, so the code change type is 5.","There's no change in the logic that could lead to an alteration in the returned value or a different exception being thrown. The method call has just been routed through a different method, likely as part of an internal refactor for cleaner code organization or similar. Given that the semantics of getting the service reference and invoking getProcessMemoryInfo remain the same, there is no Compatibility Issue here, so the CI type is 0."
284,"<android.view.NotificationHeaderView.HeaderTouchListener: boolean onTouch(View,MotionEvent)>",25,26,"<android.view.NotificationHeaderView.HeaderTouchListener: boolean onTouch(View,MotionEvent)>","<android.view.NotificationHeaderView.HeaderTouchListener: boolean onTouch(View,MotionEvent)>",0,"{
    float x = event.getX();
    float y = event.getY();
    switch(event.getActionMasked() & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_DOWN:
            mTrackGesture = false;
            if (isInside(x, y)) {
                mTrackGesture = true;
                return true;
            }
            break;
        case MotionEvent.ACTION_MOVE:
            if (mTrackGesture) {
                if (Math.abs(mDownX - x) > mTouchSlop || Math.abs(mDownY - y) > mTouchSlop) {
                    mTrackGesture = false;
                }
            }
            break;
        case MotionEvent.ACTION_UP:
            if (mTrackGesture) {
                mExpandClickListener.onClick(NotificationHeaderView.this);
            }
            break;
    }
    return mTrackGesture;
}","{
    float x = event.getX();
    float y = event.getY();
    switch(event.getActionMasked() & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_DOWN:
            mTrackGesture = false;
            if (isInside(x, y)) {
                mDownX = x;
                mDownY = y;
                mTrackGesture = true;
                return true;
            }
            break;
        case MotionEvent.ACTION_MOVE:
            if (mTrackGesture) {
                if (Math.abs(mDownX - x) > mTouchSlop || Math.abs(mDownY - y) > mTouchSlop) {
                    mTrackGesture = false;
                }
            }
            break;
        case MotionEvent.ACTION_UP:
            if (mTrackGesture) {
                mExpandButton.performClick();
            }
            break;
    }
    return mTrackGesture;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The variable assignments mDownX = x; and mDownY = y; are added, and mExpandClickListener.onClick(NotificationHeaderView.this); is changed to mExpandButton.performClick();. These constitute Other statement changes, so the code change type is 4.","There is no change in the return value type or control flow that would affect the output of the method. The change in the onClick implementation to performClick does not inherently affect the onTouch() return value or exception handling. Thus, no Compatibility Issue arises from these changes."
285,<android.app.SharedPreferencesImpl: boolean contains(String)>,25,26,<android.app.SharedPreferencesImpl: boolean contains(String)>,<android.app.SharedPreferencesImpl: boolean contains(String)>,0,"{
    synchronized (this) {
        awaitLoadedLocked();
        return mMap.containsKey(key);
    }
}","{
    synchronized (mLock) {
        awaitLoadedLocked();
        return mMap.containsKey(key);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change that has been made is synchronization object from 'this' to 'mLock', which is the change type 4 (Other statement changed).","The change in synchronization lock object does not affect the behavior of the method in terms of what is returned or the exceptions thrown; the method still performs a containsKey check on mMap. Therefore, there is no Compatibility Issue and the CI type is 0."
286,"<android.content.pm.LauncherApps: void startMainActivity(ComponentName,UserHandle,Rect,Bundle)>",25,26,"<android.content.pm.LauncherApps: void startMainActivity(ComponentName,UserHandle,Rect,Bundle)>","<android.content.pm.LauncherApps: void startMainActivity(ComponentName,UserHandle,Rect,Bundle)>",0,"{
    if (DEBUG) {
        Log.i(TAG, ""StartMainActivity "" + component + "" "" + user.getIdentifier());
    }
    try {
        mService.startActivityAsUser(component, sourceBounds, opts, user);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}","{
    logErrorForInvalidProfileAccess(user);
    if (DEBUG) {
        Log.i(TAG, ""StartMainActivity "" + component + "" "" + user.getIdentifier());
    }
    try {
        mService.startActivityAsUser(mContext.getPackageName(), component, sourceBounds, opts, user);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}",1,"/**
 * Starts a Main activity in the specified profile.
 *
 * @param component The ComponentName of the activity to launch
 * @param user The UserHandle of the profile
 * @param sourceBounds The Rect containing the source bounds of the clicked icon
 * @param opts Options to pass to startActivity
 */
","/**
 * Starts a Main activity in the specified profile.
 *
 * @param component The ComponentName of the activity to launch
 * @param user The UserHandle of the profile
 * @param sourceBounds The Rect containing the source bounds of the clicked icon
 * @param opts Options to pass to startActivity
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method logErrorForInvalidProfileAccess(user) has been added, and the method signature of mService.startActivityAsUser has been changed by adding an extra argument: mContext.getPackageName(). Therefore, the changes are of the type 4 and 5.","The added method logErrorForInvalidProfileAccess(user) does not affect the behavior of the API in terms of the output or exceptions thrown (assuming it's for logging only and does not throw exceptions). The change in mService.startActivityAsUser to include another argument does not affect the caller as this extra argument mContext.getPackageName() is an internal change to how the API implements the request. However, without knowing the implementation of mService.startActivityAsUser, we cannot definitively say whether it introduces a change in behavior or exceptions thrown. Given the information presented, it appears that this change would not introduce a compatibility issue for the caller of startMainActivity. Thus, the CI is 0."
288,<android.app.ActivityManager: ConfigurationInfo getDeviceConfigurationInfo()>,25,26,<android.app.ActivityManager: ConfigurationInfo getDeviceConfigurationInfo()>,<android.app.ActivityManager: ConfigurationInfo getDeviceConfigurationInfo()>,0,"{
    try {
        return ActivityManagerNative.getDefault().getDeviceConfigurationInfo();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        return getService().getDeviceConfigurationInfo();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Get the device configuration attributes.
 */
","/**
 * Get the device configuration attributes.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method used to retrieve the service instance has changed from ActivityManagerNative.getDefault() to getService(), indicating the dependent API has changed, so the code change type is 5.","Despite the change, there's nothing in the change that directly affects the behavior of the API regarding its return value or exception handling. The API still returns the result of getDeviceConfigurationInfo() or throws rethrown RemoteException, so there is no Compatibility Issue, hence CI type is 0."
289,<android.view.accessibility.AccessibilityNodeInfo: boolean refresh()>,25,26,<android.view.accessibility.AccessibilityNodeInfo: boolean refresh()>,<android.view.accessibility.AccessibilityNodeInfo: boolean refresh()>,0,"{
    return refresh(true);
}","{
    return refresh(null, true);
}",1,"/**
 * Refreshes this info with the latest state of the view it represents.
 * <p>
 * <strong>Note:</strong> If this method returns false this info is obsolete
 * since it represents a view that is no longer in the view tree and should
 * be recycled.
 * </p>
 * @return Whether the refresh succeeded.
 */
","/**
 * Refreshes this info with the latest state of the view it represents.
 *
 * @return {@code true} if the refresh succeeded. {@code false} if the {@link View} represented
 * by this node is no longer in the view tree (and thus this node is obsolete and should be
 * recycled).
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method call within the 'refresh' method has changed from refresh(true) to refresh(null, true), which means the signature of the called method within refresh has been modified. Therefore, the change is of type 5.","There is no Compatibility Issue identified here because the change is internal to the method and does not affect the method's contract. The return type and the behavior of the 'refresh' method as seen by the code calling this method do not change as a result of this modification. Thus, the CI type is 0."
292,<android.app.FragmentManagerImpl: boolean executePendingTransactions()>,25,26,<android.app.FragmentManagerImpl: boolean executePendingTransactions()>,<android.app.FragmentManagerImpl: boolean executePendingTransactions()>,0,"{
    return execPendingActions();
}","{
    boolean updates = execPendingActions();
    forcePostponedTransactions();
    return updates;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The late implementation introduced a new method call (forcePostponedTransactions()) before the return statement and stored the result of execPendingActions() in a variable before returning it, thus the change type is 1,4.","The addition of the forcePostponedTransactions() method call potentially affects the final return value of the method since there could be state changes in the transaction execution. Because the return value can be different due to these updates, the CI type is 1."
293,<android.app.PendingIntent: String getCreatorPackage()>,25,26,<android.app.PendingIntent: String getCreatorPackage()>,<android.app.PendingIntent: String getCreatorPackage()>,0,"{
    try {
        return ActivityManagerNative.getDefault().getPackageForIntentSender(mTarget);
    } catch (RemoteException e) {
        // Should never happen.
        return null;
    }
}","{
    try {
        return ActivityManager.getService().getPackageForIntentSender(mTarget);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Return the package name of the application that created this
 * PendingIntent, that is the identity under which you will actually be
 * sending the Intent.  The returned string is supplied by the system, so
 * that an application can not spoof its package.
 *
 * <p class=""note"">Be careful about how you use this.  All this tells you is
 * who created the PendingIntent.  It does <strong>not</strong> tell you who
 * handed the PendingIntent to you: that is, PendingIntent objects are intended to be
 * passed between applications, so the PendingIntent you receive from an application
 * could actually be one it received from another application, meaning the result
 * you get here will identify the original application.  Because of this, you should
 * only use this information to identify who you expect to be interacting with
 * through a {@link #send} call, not who gave you the PendingIntent.</p>
 *
 * @return The package name of the PendingIntent, or null if there is
 * none associated with it.
 */
","/**
 * Return the package name of the application that created this
 * PendingIntent, that is the identity under which you will actually be
 * sending the Intent.  The returned string is supplied by the system, so
 * that an application can not spoof its package.
 *
 * <p class=""note"">Be careful about how you use this.  All this tells you is
 * who created the PendingIntent.  It does <strong>not</strong> tell you who
 * handed the PendingIntent to you: that is, PendingIntent objects are intended to be
 * passed between applications, so the PendingIntent you receive from an application
 * could actually be one it received from another application, meaning the result
 * you get here will identify the original application.  Because of this, you should
 * only use this information to identify who you expect to be interacting with
 * through a {@link #send} call, not who gave you the PendingIntent.</p>
 *
 * @return The package name of the PendingIntent, or null if there is
 * none associated with it.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,"2,5",2,"The implementation of how the service is accessed changed from ActivityManagerNative.getDefault() to ActivityManager.getService() and the exception handling has also changed from returning null to throwing an exception. Although the nullability of the return value remains the same (as denoted by the @Nullable annotation), the method used to get the service has changed and what happens during a RemoteException has changed, so the change types are 2,5.","The change in exception handling will lead to a different behavior when an exception occurs. Instead of returning 'null' as in the early version, the late version will now throw an exception, so the CI type is 2."
294,<android.app.Fragment: Transition getSharedElementEnterTransition()>,25,26,<android.app.Fragment: Transition getSharedElementEnterTransition()>,<android.app.Fragment: Transition getSharedElementEnterTransition()>,0,"{
    return mSharedElementEnterTransition;
}","{
    if (mAnimationInfo == null) {
        return null;
    }
    return mAnimationInfo.mSharedElementEnterTransition;
}",1,"/**
 * Returns the Transition that will be used for shared elements transferred into the content
 * Scene. Typical Transitions will affect size and location, such as
 * {@link android.transition.ChangeBounds}. A null
 * value will cause transferred shared elements to blink to the final position.
 *
 * @return The Transition to use for shared elements transferred into the content
 * Scene.
 * @attr ref android.R.styleable#Fragment_fragmentSharedElementEnterTransition
 */
","/**
 * Returns the Transition that will be used for shared elements transferred into the content
 * Scene. Typical Transitions will affect size and location, such as
 * {@link android.transition.ChangeBounds}. A null
 * value will cause transferred shared elements to blink to the final position.
 *
 * @return The Transition to use for shared elements transferred into the content
 * Scene.
 * @attr ref android.R.styleable#Fragment_fragmentSharedElementEnterTransition
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,The late version of the method introduces a control dependency (an if statement checking if mAnimationInfo is null) and changes the manner in which the value of mSharedElementEnterTransition is accessed and potentially returned. This is a change in both the control flow and the return statement.,"Since the newly introduced 'if' statement checks for a scenario (mAnimationInfo being null) that was not previously checked, this change allows for a new potential return value (null) that was not possible in the early version of the API. Therefore, the API could potentially return different values, leading to a compatibility issue of type 1."
296,<android.app.Activity: boolean isInPictureInPictureMode()>,25,26,<android.app.Activity: boolean isInPictureInPictureMode()>,<android.app.Activity: boolean isInPictureInPictureMode()>,0,"{
    try {
        return ActivityManagerNative.getDefault().isInPictureInPictureMode(mToken);
    } catch (RemoteException e) {
    }
    return false;
}","{
    try {
        return ActivityManager.getService().isInPictureInPictureMode(mToken);
    } catch (RemoteException e) {
    }
    return false;
}",1,"/**
 * Returns true if the activity is currently in picture-in-picture mode.
 * @see android.R.attr#supportsPictureInPicture
 *
 * @return True if the activity is in picture-in-picture mode.
 */
","/**
 * Returns true if the activity is currently in picture-in-picture mode.
 * @see android.R.attr#supportsPictureInPicture
 *
 * @return True if the activity is in picture-in-picture mode.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation has changed the method being called from ActivityManagerNative.getDefault().isInPictureInPictureMode(mToken) to ActivityManager.getService().isInPictureInPictureMode(mToken), reflecting a change in the dependent API, hence the code change type is 5.","Although the method used to get the ActivityManager has changed, there is no indication that the semantics of the isInPictureInPictureMode method have changed. Also, the return value on exception handling (`RemoteException`) has not changed, which continues to be `false`. Therefore, there is no compatibility issue, and the CI type is 0."
297,<android.view.accessibility.AccessibilityManager: boolean addAccessibilityStateChangeListener(AccessibilityStateChangeListener)>,25,26,<android.view.accessibility.AccessibilityManager: boolean addAccessibilityStateChangeListener(AccessibilityStateChangeListener)>,<android.view.accessibility.AccessibilityManager: boolean addAccessibilityStateChangeListener(AccessibilityStateChangeListener)>,0,"{
    // Final CopyOnWriteArrayList - no lock needed.
    return mAccessibilityStateChangeListeners.add(listener);
}","{
    addAccessibilityStateChangeListener(listener, null);
    return true;
}",1,"/**
 * Registers an {@link AccessibilityStateChangeListener} for changes in
 * the global accessibility state of the system.
 *
 * @param listener The listener.
 * @return True if successfully registered.
 */
","/**
 * Registers an {@link AccessibilityStateChangeListener} for changes in
 * the global accessibility state of the system. Equivalent to calling
 * {@link #addAccessibilityStateChangeListener(AccessibilityStateChangeListener, Handler)}
 * with a null handler.
 *
 * @param listener The listener.
 * @return Always returns {@code true}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The implementation has changed from returning the result of mAccessibilityStateChangeListeners.add(listener) to always returning true after calling addAccessibilityStateChangeListener(listener, null), which signifies a change not only in other statements but also a guaranteed change in the return value, so the code change types are 1 and 4.","There is a potential Compatibility Issue because the different return value: the early version returns the result of the add operation which could be true or false, whereas the late version always returns true regardless of the success of the operation, so the CI type is 1."
298,<android.widget.TextView: boolean onTouchEvent(MotionEvent)>,25,26,<android.widget.TextView: boolean onTouchEvent(MotionEvent)>,<android.widget.TextView: boolean onTouchEvent(MotionEvent)>,0,"{
    final int action = event.getActionMasked();
    if (mEditor != null) {
        mEditor.onTouchEvent(event);
        if (mEditor.mSelectionModifierCursorController != null && mEditor.mSelectionModifierCursorController.isDragAcceleratorActive()) {
            return true;
        }
    }
    final boolean superResult = super.onTouchEvent(event);
    /*
         * Don't handle the release after a long press, because it will move the selection away from
         * whatever the menu action was trying to affect. If the long press should have triggered an
         * insertion action mode, we can now actually show it.
         */
    if (mEditor != null && mEditor.mDiscardNextActionUp && action == MotionEvent.ACTION_UP) {
        mEditor.mDiscardNextActionUp = false;
        if (mEditor.mIsInsertionActionModeStartPending) {
            mEditor.startInsertionActionMode();
            mEditor.mIsInsertionActionModeStartPending = false;
        }
        return superResult;
    }
    final boolean touchIsFinished = (action == MotionEvent.ACTION_UP) && (mEditor == null || !mEditor.mIgnoreActionUpEvent) && isFocused();
    if ((mMovement != null || onCheckIsTextEditor()) && isEnabled() && mText instanceof Spannable && mLayout != null) {
        boolean handled = false;
        if (mMovement != null) {
            handled |= mMovement.onTouchEvent(this, (Spannable) mText, event);
        }
        final boolean textIsSelectable = isTextSelectable();
        if (touchIsFinished && mLinksClickable && mAutoLinkMask != 0 && textIsSelectable) {
            // The LinkMovementMethod which should handle taps on links has not been installed
            // on non editable text that support text selection.
            // We reproduce its behavior here to open links for these.
            ClickableSpan[] links = ((Spannable) mText).getSpans(getSelectionStart(), getSelectionEnd(), ClickableSpan.class);
            if (links.length > 0) {
                links[0].onClick(this);
                handled = true;
            }
        }
        if (touchIsFinished && (isTextEditable() || textIsSelectable)) {
            // Show the IME, except when selecting in read-only text.
            final InputMethodManager imm = InputMethodManager.peekInstance();
            viewClicked(imm);
            if (!textIsSelectable && mEditor.mShowSoftInputOnFocus) {
                handled |= imm != null && imm.showSoftInput(this, 0);
            }
            // The above condition ensures that the mEditor is not null
            mEditor.onTouchUpEvent(event);
            handled = true;
        }
        if (handled) {
            return true;
        }
    }
    return superResult;
}","{
    final int action = event.getActionMasked();
    if (mEditor != null) {
        mEditor.onTouchEvent(event);
        if (mEditor.mSelectionModifierCursorController != null && mEditor.mSelectionModifierCursorController.isDragAcceleratorActive()) {
            return true;
        }
    }
    final boolean superResult = super.onTouchEvent(event);
    /*
         * Don't handle the release after a long press, because it will move the selection away from
         * whatever the menu action was trying to affect. If the long press should have triggered an
         * insertion action mode, we can now actually show it.
         */
    if (mEditor != null && mEditor.mDiscardNextActionUp && action == MotionEvent.ACTION_UP) {
        mEditor.mDiscardNextActionUp = false;
        if (mEditor.mIsInsertionActionModeStartPending) {
            mEditor.startInsertionActionMode();
            mEditor.mIsInsertionActionModeStartPending = false;
        }
        return superResult;
    }
    final boolean touchIsFinished = (action == MotionEvent.ACTION_UP) && (mEditor == null || !mEditor.mIgnoreActionUpEvent) && isFocused();
    if ((mMovement != null || onCheckIsTextEditor()) && isEnabled() && mText instanceof Spannable && mLayout != null) {
        boolean handled = false;
        if (mMovement != null) {
            handled |= mMovement.onTouchEvent(this, (Spannable) mText, event);
        }
        final boolean textIsSelectable = isTextSelectable();
        if (touchIsFinished && mLinksClickable && mAutoLinkMask != 0 && textIsSelectable) {
            // The LinkMovementMethod which should handle taps on links has not been installed
            // on non editable text that support text selection.
            // We reproduce its behavior here to open links for these.
            ClickableSpan[] links = ((Spannable) mText).getSpans(getSelectionStart(), getSelectionEnd(), ClickableSpan.class);
            if (links.length > 0) {
                links[0].onClick(this);
                handled = true;
            }
        }
        if (touchIsFinished && (isTextEditable() || textIsSelectable)) {
            // Show the IME, except when selecting in read-only text.
            final InputMethodManager imm = InputMethodManager.peekInstance();
            viewClicked(imm);
            if (isTextEditable() && mEditor.mShowSoftInputOnFocus && imm != null) {
                imm.showSoftInput(this, 0);
            }
            // The above condition ensures that the mEditor is not null
            mEditor.onTouchUpEvent(event);
            handled = true;
        }
        if (handled) {
            return true;
        }
    }
    return superResult;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
299,"<android.app.LocalActivityManager: Window startActivity(String,Intent)>",25,26,"<android.app.LocalActivityManager: Window startActivity(String,Intent)>","<android.app.LocalActivityManager: Window startActivity(String,Intent)>",0,"{
    if (mCurState == INITIALIZING) {
        throw new IllegalStateException(""Activities can't be added until the containing group has been created."");
    }
    boolean adding = false;
    boolean sameIntent = false;
    ActivityInfo aInfo = null;
    // Already have information about the new activity id?
    LocalActivityRecord r = mActivities.get(id);
    if (r == null) {
        // Need to create it...
        r = new LocalActivityRecord(id, intent);
        adding = true;
    } else if (r.intent != null) {
        sameIntent = r.intent.filterEquals(intent);
        if (sameIntent) {
            // We are starting the same activity.
            aInfo = r.activityInfo;
        }
    }
    if (aInfo == null) {
        aInfo = mActivityThread.resolveActivityInfo(intent);
    }
    // activity is allowed to be running at a time.
    if (mSingleMode) {
        LocalActivityRecord old = mResumed;
        // activity, we need to stop it.
        if (old != null && old != r && mCurState == RESUMED) {
            moveToState(old, STARTED);
        }
    }
    if (adding) {
        // It's a brand new world.
        mActivities.put(id, r);
        mActivityArray.add(r);
    } else if (r.activityInfo != null) {
        // we may be able to reuse it.
        if (aInfo == r.activityInfo || (aInfo.name.equals(r.activityInfo.name) && aInfo.packageName.equals(r.activityInfo.packageName))) {
            if (aInfo.launchMode != ActivityInfo.LAUNCH_MULTIPLE || (intent.getFlags() & Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0) {
                // The activity wants onNewIntent() called.
                ArrayList<ReferrerIntent> intents = new ArrayList<>(1);
                intents.add(new ReferrerIntent(intent, mParent.getPackageName()));
                if (localLOGV)
                    Log.v(TAG, r.id + "": new intent"");
                mActivityThread.performNewIntents(r, intents);
                r.intent = intent;
                moveToState(r, mCurState);
                if (mSingleMode) {
                    mResumed = r;
                }
                return r.window;
            }
            if (sameIntent && (intent.getFlags() & Intent.FLAG_ACTIVITY_CLEAR_TOP) == 0) {
                // We are showing the same thing, so this activity is
                // just resumed and stays as-is.
                r.intent = intent;
                moveToState(r, mCurState);
                if (mSingleMode) {
                    mResumed = r;
                }
                return r.window;
            }
        }
        // The new activity is different than the current one, or it
        // is a multiple launch activity, so we need to destroy what
        // is currently there.
        performDestroy(r, true);
    }
    r.intent = intent;
    r.curState = INITIALIZING;
    r.activityInfo = aInfo;
    moveToState(r, mCurState);
    // When in single mode keep track of the current activity
    if (mSingleMode) {
        mResumed = r;
    }
    return r.window;
}","{
    if (mCurState == INITIALIZING) {
        throw new IllegalStateException(""Activities can't be added until the containing group has been created."");
    }
    boolean adding = false;
    boolean sameIntent = false;
    ActivityInfo aInfo = null;
    // Already have information about the new activity id?
    LocalActivityRecord r = mActivities.get(id);
    if (r == null) {
        // Need to create it...
        r = new LocalActivityRecord(id, intent);
        adding = true;
    } else if (r.intent != null) {
        sameIntent = r.intent.filterEquals(intent);
        if (sameIntent) {
            // We are starting the same activity.
            aInfo = r.activityInfo;
        }
    }
    if (aInfo == null) {
        aInfo = mActivityThread.resolveActivityInfo(intent);
    }
    // activity is allowed to be running at a time.
    if (mSingleMode) {
        LocalActivityRecord old = mResumed;
        // activity, we need to stop it.
        if (old != null && old != r && mCurState == RESUMED) {
            moveToState(old, STARTED);
        }
    }
    if (adding) {
        // It's a brand new world.
        mActivities.put(id, r);
        mActivityArray.add(r);
    } else if (r.activityInfo != null) {
        // we may be able to reuse it.
        if (aInfo == r.activityInfo || (aInfo.name.equals(r.activityInfo.name) && aInfo.packageName.equals(r.activityInfo.packageName))) {
            if (aInfo.launchMode != ActivityInfo.LAUNCH_MULTIPLE || (intent.getFlags() & Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0) {
                // The activity wants onNewIntent() called.
                ArrayList<ReferrerIntent> intents = new ArrayList<>(1);
                intents.add(new ReferrerIntent(intent, mParent.getPackageName()));
                if (localLOGV)
                    Log.v(TAG, r.id + "": new intent"");
                mActivityThread.performNewIntents(r, intents, false);
                r.intent = intent;
                moveToState(r, mCurState);
                if (mSingleMode) {
                    mResumed = r;
                }
                return r.window;
            }
            if (sameIntent && (intent.getFlags() & Intent.FLAG_ACTIVITY_CLEAR_TOP) == 0) {
                // We are showing the same thing, so this activity is
                // just resumed and stays as-is.
                r.intent = intent;
                moveToState(r, mCurState);
                if (mSingleMode) {
                    mResumed = r;
                }
                return r.window;
            }
        }
        // The new activity is different than the current one, or it
        // is a multiple launch activity, so we need to destroy what
        // is currently there.
        performDestroy(r, true);
    }
    r.intent = intent;
    r.curState = INITIALIZING;
    r.activityInfo = aInfo;
    moveToState(r, mCurState);
    // When in single mode keep track of the current activity
    if (mSingleMode) {
        mResumed = r;
    }
    return r.window;
}",1,"/**
 * Start a new activity running in the group.  Every activity you start
 * must have a unique string ID associated with it -- this is used to keep
 * track of the activity, so that if you later call startActivity() again
 * on it the same activity object will be retained.
 *
 * <p>When there had previously been an activity started under this id,
 * it may either be destroyed and a new one started, or the current
 * one re-used, based on these conditions, in order:</p>
 *
 * <ul>
 * <li> If the Intent maps to a different activity component than is
 * currently running, the current activity is finished and a new one
 * started.
 * <li> If the current activity uses a non-multiple launch mode (such
 * as singleTop), or the Intent has the
 * {@link Intent#FLAG_ACTIVITY_SINGLE_TOP} flag set, then the current
 * activity will remain running and its
 * {@link Activity#onNewIntent(Intent) Activity.onNewIntent()} method
 * called.
 * <li> If the new Intent is the same (excluding extras) as the previous
 * one, and the new Intent does not have the
 * {@link Intent#FLAG_ACTIVITY_CLEAR_TOP} set, then the current activity
 * will remain running as-is.
 * <li> Otherwise, the current activity will be finished and a new
 * one started.
 * </ul>
 *
 * <p>If the given Intent can not be resolved to an available Activity,
 * this method throws {@link android.content.ActivityNotFoundException}.
 *
 * <p>Warning: There is an issue where, if the Intent does not
 * include an explicit component, we can restore the state for a different
 * activity class than was previously running when the state was saved (if
 * the set of available activities changes between those points).
 *
 * @param id Unique identifier of the activity to be started
 * @param intent The Intent describing the activity to be started
 *
 * @return Returns the window of the activity.  The caller needs to take
 * care of adding this window to a view hierarchy, and likewise dealing
 * with removing the old window if the activity has changed.
 *
 * @throws android.content.ActivityNotFoundException
 */
","/**
 * Start a new activity running in the group.  Every activity you start
 * must have a unique string ID associated with it -- this is used to keep
 * track of the activity, so that if you later call startActivity() again
 * on it the same activity object will be retained.
 *
 * <p>When there had previously been an activity started under this id,
 * it may either be destroyed and a new one started, or the current
 * one re-used, based on these conditions, in order:</p>
 *
 * <ul>
 * <li> If the Intent maps to a different activity component than is
 * currently running, the current activity is finished and a new one
 * started.
 * <li> If the current activity uses a non-multiple launch mode (such
 * as singleTop), or the Intent has the
 * {@link Intent#FLAG_ACTIVITY_SINGLE_TOP} flag set, then the current
 * activity will remain running and its
 * {@link Activity#onNewIntent(Intent) Activity.onNewIntent()} method
 * called.
 * <li> If the new Intent is the same (excluding extras) as the previous
 * one, and the new Intent does not have the
 * {@link Intent#FLAG_ACTIVITY_CLEAR_TOP} set, then the current activity
 * will remain running as-is.
 * <li> Otherwise, the current activity will be finished and a new
 * one started.
 * </ul>
 *
 * <p>If the given Intent can not be resolved to an available Activity,
 * this method throws {@link android.content.ActivityNotFoundException}.
 *
 * <p>Warning: There is an issue where, if the Intent does not
 * include an explicit component, we can restore the state for a different
 * activity class than was previously running when the state was saved (if
 * the set of available activities changes between those points).
 *
 * @param id Unique identifier of the activity to be started
 * @param intent The Intent describing the activity to be started
 *
 * @return Returns the window of the activity.  The caller needs to take
 * care of adding this window to a view hierarchy, and likewise dealing
 * with removing the old window if the activity has changed.
 *
 * @throws android.content.ActivityNotFoundException
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
300,<android.content.ClipboardManager: ClipDescription getPrimaryClipDescription()>,25,26,<android.content.ClipboardManager: ClipDescription getPrimaryClipDescription()>,<android.content.ClipboardManager: ClipDescription getPrimaryClipDescription()>,0,"{
    try {
        return getService().getPrimaryClipDescription(mContext.getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        return mService.getPrimaryClipDescription(mContext.getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns a description of the current primary clip on the clipboard
 * but not a copy of its data.
 */
","/**
 * Returns a description of the current primary clip on the clipboard
 * but not a copy of its data.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method getService() is replaced with the direct use of the variable mService, indicating a simple refactoring that does not affect the return type or value, hence the code change type is 4.","Refactoring in this context does not affect how the method behaves externally; it still throws the same exception for the same reasons, and returns the same type of value, therefore there is no compatibility issue, so the CI type is 0."
302,<android.preference.Preference: boolean persistStringSet(Set<String>)>,25,26,<android.preference.Preference: boolean persistStringSet(Set<String>)>,<android.preference.Preference: boolean persistStringSet(Set<String>)>,0,"{
    if (shouldPersist()) {
        // Shouldn't store null
        if (values.equals(getPersistedStringSet(null))) {
            // It's already there, so the same as persisting
            return true;
        }
        SharedPreferences.Editor editor = mPreferenceManager.getEditor();
        editor.putStringSet(mKey, values);
        tryCommit(editor);
        return true;
    }
    return false;
}","{
    if (!shouldPersist()) {
        return false;
    }
    // Shouldn't store null
    if (values.equals(getPersistedStringSet(null))) {
        // It's already there, so the same as persisting
        return true;
    }
    PreferenceDataStore dataStore = getPreferenceDataStore();
    if (dataStore != null) {
        dataStore.putStringSet(mKey, values);
    } else {
        SharedPreferences.Editor editor = mPreferenceManager.getEditor();
        editor.putStringSet(mKey, values);
        tryCommit(editor);
    }
    return true;
}",1,"/**
 * Attempts to persist a set of Strings to the {@link android.content.SharedPreferences}.
 * <p>
 * This will check if this Preference is persistent, get an editor from
 * the {@link PreferenceManager}, put in the strings, and check if we should commit (and
 * commit if so).
 *
 * @param values The values to persist.
 * @return True if the Preference is persistent. (This is not whether the
 * value was persisted, since we may not necessarily commit if there
 * will be a batch commit later.)
 * @see #getPersistedStringSet(Set)
 */
","/**
 * Attempts to persist a set of Strings if this Preference is persistent.
 *
 * @param values The values to persist.
 * @return True if this Preference is persistent. (This is not whether the
 * value was persisted, since we may not necessarily commit if there
 * will be a batch commit later.)
 * @see #getPersistedStringSet(Set)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,5","1,2","The early implementation has a return statement within the if shouldPersist() block and another return false at the end, whereas the late implementation has a return false at the beginning if not shouldPersist() and reconstructs the other conditions. Additionally, the late implementation introduces a new control dependency for PreferenceDataStore and alters the logic by removing the SharedPreferences.Editor when dataStore is not null. The late implementation also includes use of a new method getPreferenceDataStore which is a change to a Dependent API. This means the code change types are 1 for the change in return statements, 3 for the changes in control flow, and 5 for the use of the new Dependent API.","The potential incompatibilities could be caused by the altered control flow including the early return and introduction of the new PreferenceDataStore logic (CI type 1). Additionally, the introduction of PreferenceDataStore without a corresponding if-null check could result in exceptions not being handled if the dataStore is null and its methods are accessed—this constitutes an Exception handling statement changed (CI type 2)."
303,<android.content.IntentSender: String getCreatorPackage()>,25,26,<android.content.IntentSender: String getCreatorPackage()>,<android.content.IntentSender: String getCreatorPackage()>,0,"{
    try {
        return ActivityManagerNative.getDefault().getPackageForIntentSender(mTarget);
    } catch (RemoteException e) {
        // Should never happen.
        return null;
    }
}","{
    try {
        return ActivityManager.getService().getPackageForIntentSender(mTarget);
    } catch (RemoteException e) {
        // Should never happen.
        return null;
    }
}",1,"/**
 * Return the package name of the application that created this
 * IntentSender, that is the identity under which you will actually be
 * sending the Intent.  The returned string is supplied by the system, so
 * that an application can not spoof its package.
 *
 * @return The package name of the PendingIntent, or null if there is
 * none associated with it.
 */
","/**
 * Return the package name of the application that created this
 * IntentSender, that is the identity under which you will actually be
 * sending the Intent.  The returned string is supplied by the system, so
 * that an application can not spoof its package.
 *
 * @return The package name of the PendingIntent, or null if there is
 * none associated with it.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation has changed the method used to acquire the ActivityManager service, from `ActivityManagerNative.getDefault()` to `ActivityManager.getService()`. However, the rest of the code remains the same, including the try-catch block. Therefore, the code change type is 5, as this is a change to a Dependent API.","Despite the change in how the ActivityManager service is acquired, the method `getPackageForIntentSender(mTarget)` is still called the same way, and the surrounding control flow has not changed. The try-catch block catches the same `RemoteException` and returns null as before. Hence, there is no Compatibility Issue, therefore CI type is 0."
304,"<android.text.TextUtils: boolean doesNotNeedBidi(char[],int,int)>",25,26,"<android.text.TextUtils: boolean doesNotNeedBidi(char[],int,int)>","<android.text.TextUtils: boolean doesNotNeedBidi(char[],int,int)>",0,"{
    for (int i = start, e = i + len; i < e; i++) {
        if (text[i] >= FIRST_RIGHT_TO_LEFT) {
            return false;
        }
    }
    return true;
}","{
    final int end = start + len;
    for (int i = start; i < end; i++) {
        if (couldAffectRtl(text[i])) {
            return false;
        }
    }
    return true;
}",1,"/* package */
","/* package */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,5",1,"The implementation change includes a control dependency change where the loop's end condition is stored in a variable before the loop (from 'i < e' to 'i < end') and a new final variable is introduced. There's also a change in return statement's condition, replacing `text[i] >= FIRST_RIGHT_TO_LEFT` with a call to a possibly new method `couldAffectRtl(text[i])`. This also suggests that a dependent API, the 'couldAffectRtl' method, is being used which did not exist in the earlier version or its behavior may have changed. Thus, we have a change type of 1,3,5.","The change in the condition within the return statement to a distinct method `couldAffectRtl` could lead to different behavior as the criteria for returning `false` might have changed. Thus, the API may now return a different value for the same input than before, introducing a potential Compatibility Issue of type 1."
305,"<android.app.ContextImpl: void startIntentSender(IntentSender,Intent,int,int,int,Bundle)>",25,26,"<android.app.ContextImpl: void startIntentSender(IntentSender,Intent,int,int,int,Bundle)>","<android.app.ContextImpl: void startIntentSender(IntentSender,Intent,int,int,int,Bundle)>",0,"{
    try {
        String resolvedType = null;
        if (fillInIntent != null) {
            fillInIntent.migrateExtraStreamToClipData();
            fillInIntent.prepareToLeaveProcess(this);
            resolvedType = fillInIntent.resolveTypeIfNeeded(getContentResolver());
        }
        int result = ActivityManagerNative.getDefault().startActivityIntentSender(mMainThread.getApplicationThread(), intent, fillInIntent, resolvedType, null, null, 0, flagsMask, flagsValues, options);
        if (result == ActivityManager.START_CANCELED) {
            throw new IntentSender.SendIntentException();
        }
        Instrumentation.checkStartActivityResult(result, null);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        String resolvedType = null;
        if (fillInIntent != null) {
            fillInIntent.migrateExtraStreamToClipData();
            fillInIntent.prepareToLeaveProcess(this);
            resolvedType = fillInIntent.resolveTypeIfNeeded(getContentResolver());
        }
        int result = ActivityManager.getService().startActivityIntentSender(mMainThread.getApplicationThread(), intent != null ? intent.getTarget() : null, intent != null ? intent.getWhitelistToken() : null, fillInIntent, resolvedType, null, null, 0, flagsMask, flagsValues, options);
        if (result == ActivityManager.START_CANCELED) {
            throw new IntentSender.SendIntentException();
        }
        Instrumentation.checkStartActivityResult(result, null);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4,5",1,"The method `ActivityManagerNative.getDefault().startActivityIntentSender` has changed to `ActivityManager.getService().startActivityIntentSender`. Additionally, the parameters for the method call have also been changed. It now includes a null check on `intent` and conditionally passes `intent.getTarget()` and `intent.getWhitelistToken()` as arguments instead of directly passing `intent`. These alterations indicate changes to a dependent API and other statements, so the code change types are 1, 4, and 5.","The changes to the dependent API (`ActivityManagerNative.getDefault().startActivityIntentSender` to `ActivityManager.getService().startActivityIntentSender`) and the parameters, including the addition of null checks and the use of `intent.getTarget()` and `intent.getWhitelistToken()`, could affect the behavior of the method. Specifically, if `intent` is `null`, the late version calls the method with `null` values for certain parameters, while the early version would have passed `intent` directly which would potentially throw a `NullPointerException`. This could potentially cause the method to return different values, thus leading to a CI type of 1."
306,<android.app.usage.UsageStats: void add(UsageStats)>,25,26,<android.app.usage.UsageStats: void add(UsageStats)>,<android.app.usage.UsageStats: void add(UsageStats)>,0,"{
    if (!mPackageName.equals(right.mPackageName)) {
        throw new IllegalArgumentException(""Can't merge UsageStats for package '"" + mPackageName + ""' with UsageStats for package '"" + right.mPackageName + ""'."");
    }
    if (right.mBeginTimeStamp > mBeginTimeStamp) {
        // The incoming UsageStat begins after this one, so use its last time used fields
        // as the source of truth.
        // We use the mBeginTimeStamp due to a bug where UsageStats files can overlap with
        // regards to their mEndTimeStamp.
        mLastEvent = right.mLastEvent;
        mLastTimeUsed = right.mLastTimeUsed;
    }
    mBeginTimeStamp = Math.min(mBeginTimeStamp, right.mBeginTimeStamp);
    mEndTimeStamp = Math.max(mEndTimeStamp, right.mEndTimeStamp);
    mTotalTimeInForeground += right.mTotalTimeInForeground;
    mLaunchCount += right.mLaunchCount;
}","{
    if (!mPackageName.equals(right.mPackageName)) {
        throw new IllegalArgumentException(""Can't merge UsageStats for package '"" + mPackageName + ""' with UsageStats for package '"" + right.mPackageName + ""'."");
    }
    // regards to their mEndTimeStamp.
    if (right.mBeginTimeStamp > mBeginTimeStamp) {
        // Even though incoming UsageStat begins after this one, its last time used fields
        // may somehow be empty or chronologically preceding the older UsageStat.
        mLastEvent = Math.max(mLastEvent, right.mLastEvent);
        mLastTimeUsed = Math.max(mLastTimeUsed, right.mLastTimeUsed);
    }
    mBeginTimeStamp = Math.min(mBeginTimeStamp, right.mBeginTimeStamp);
    mEndTimeStamp = Math.max(mEndTimeStamp, right.mEndTimeStamp);
    mTotalTimeInForeground += right.mTotalTimeInForeground;
    mLaunchCount += right.mLaunchCount;
    if (mChooserCounts == null) {
        mChooserCounts = right.mChooserCounts;
    } else if (right.mChooserCounts != null) {
        final int chooserCountsSize = right.mChooserCounts.size();
        for (int i = 0; i < chooserCountsSize; i++) {
            String action = right.mChooserCounts.keyAt(i);
            ArrayMap<String, Integer> counts = right.mChooserCounts.valueAt(i);
            if (!mChooserCounts.containsKey(action) || mChooserCounts.get(action) == null) {
                mChooserCounts.put(action, counts);
                continue;
            }
            final int annotationSize = counts.size();
            for (int j = 0; j < annotationSize; j++) {
                String key = counts.keyAt(j);
                int rightValue = counts.valueAt(j);
                int leftValue = mChooserCounts.get(action).getOrDefault(key, 0);
                mChooserCounts.get(action).put(key, leftValue + rightValue);
            }
        }
    }
}",1,"/**
 * Add the statistics from the right {@link UsageStats} to the left. The package name for
 * both {@link UsageStats} objects must be the same.
 * @param right The {@link UsageStats} object to merge into this one.
 * @throws java.lang.IllegalArgumentException if the package names of the two
 * {@link UsageStats} objects are different.
 */
","/**
 * Add the statistics from the right {@link UsageStats} to the left. The package name for
 * both {@link UsageStats} objects must be the same.
 * @param right The {@link UsageStats} object to merge into this one.
 * @throws java.lang.IllegalArgumentException if the package names of the two
 * {@link UsageStats} objects are different.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"There are changes in the control dependency within the 'if' block, and other statements have been introduced at the end of the method to handle 'mChooserCounts'. So the changes are in categories 3 and 4.","Despite the changes in implementation, they do not lead to a Compatibility Issue since the method's signature and its expected behavior remain the same, and it doesn't return a value or throw a new exception. The method is void and thus no return value could be affected, and exception handling has not changed; the IllegalArgumentException is thrown under the same condition as before. The changes pertain to the internal state and should not affect external behavior in terms of API contract."
307,<android.os.storage.StorageManager: boolean isObbMounted(String)>,25,26,<android.os.storage.StorageManager: boolean isObbMounted(String)>,<android.os.storage.StorageManager: boolean isObbMounted(String)>,0,"{
    Preconditions.checkNotNull(rawPath, ""rawPath cannot be null"");
    try {
        return mMountService.isObbMounted(rawPath);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    Preconditions.checkNotNull(rawPath, ""rawPath cannot be null"");
    try {
        return mStorageManager.isObbMounted(rawPath);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Check whether an Opaque Binary Blob (OBB) is mounted or not.
 *
 * @param rawPath path to OBB image
 * @return true if OBB is mounted; false if not mounted or on error
 */
","/**
 * Check whether an Opaque Binary Blob (OBB) is mounted or not.
 *
 * @param rawPath path to OBB image
 * @return true if OBB is mounted; false if not mounted or on error
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method called within the return statement has changed from mMountService.isObbMounted(rawPath) to mStorageManager.isObbMounted(rawPath), so the change type is 5.","There's no Compatibility Issue here since the signature of the method being called remains the same, and the replacement of mMountService with mStorageManager does not signify a change in behavior. Assuming mStorageManager.isObbMounted(rawPath) has the same contract and side effects as mMountService.isObbMounted(rawPath), it won't cause a Compatibility Issue."
308,"<android.app.ContextImpl: void grantUriPermission(String,Uri,int)>",25,26,"<android.app.ContextImpl: void grantUriPermission(String,Uri,int)>","<android.app.ContextImpl: void grantUriPermission(String,Uri,int)>",0,"{
    try {
        ActivityManagerNative.getDefault().grantUriPermission(mMainThread.getApplicationThread(), toPackage, ContentProvider.getUriWithoutUserId(uri), modeFlags, resolveUserId(uri));
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        ActivityManager.getService().grantUriPermission(mMainThread.getApplicationThread(), toPackage, ContentProvider.getUriWithoutUserId(uri), modeFlags, resolveUserId(uri));
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The API used within the method body, ActivityManagerNative.getDefault(), has been changed to ActivityManager.getService(), which implies that the dependent API has changed. Therefore, the code change type is 5.","The underlying implementation of `ActivityManager.getService()` is intended to maintain the same behavior as the old `ActivityManagerNative.getDefault()`, despite being a different method. This is a common practice in Android framework development where internal refactoring aims to keep the public facing APIs and their behaviors unchanged. Unless there is a fundamental change in the behavior of the new method, which is not indicated, it would not lead to a Compatibility Issue, and thus, the CI type is 0."
309,<android.accessibilityservice.AccessibilityServiceInfo: boolean equals(Object)>,25,26,<android.accessibilityservice.AccessibilityServiceInfo: boolean equals(Object)>,<android.accessibilityservice.AccessibilityServiceInfo: boolean equals(Object)>,0,"{
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    AccessibilityServiceInfo other = (AccessibilityServiceInfo) obj;
    if (mId == null) {
        if (other.mId != null) {
            return false;
        }
    } else if (!mId.equals(other.mId)) {
        return false;
    }
    return true;
}","{
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    AccessibilityServiceInfo other = (AccessibilityServiceInfo) obj;
    if (mComponentName == null) {
        if (other.mComponentName != null) {
            return false;
        }
    } else if (!mComponentName.equals(other.mComponentName)) {
        return false;
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The field used in the comparison has changed from mId to mComponentName which affects the equals method's logic, so the change type is 1,4.","This change in the field used for comparison can lead to a difference in the boolean result of the equals method. Hence, a CI is caused by potentially different return values (type 1)."
310,"<android.hardware.camera2.impl.CameraDeviceImpl.CameraDeviceCallbacks: void onResultReceived(CameraMetadataNative,CaptureResultExtras)>",25,26,"<android.hardware.camera2.impl.CameraDeviceImpl.CameraDeviceCallbacks: void onResultReceived(CameraMetadataNative,CaptureResultExtras)>","<android.hardware.camera2.impl.CameraDeviceImpl.CameraDeviceCallbacks: void onResultReceived(CameraMetadataNative,CaptureResultExtras)>",0,"{
    int requestId = resultExtras.getRequestId();
    long frameNumber = resultExtras.getFrameNumber();
    if (DEBUG) {
        Log.v(TAG, ""Received result frame "" + frameNumber + "" for id "" + requestId);
    }
    synchronized (mInterfaceLock) {
        // Camera already closed
        if (mRemoteDevice == null)
            return;
        // TODO: Handle CameraCharacteristics access from CaptureResult correctly.
        result.set(CameraCharacteristics.LENS_INFO_SHADING_MAP_SIZE, getCharacteristics().get(CameraCharacteristics.LENS_INFO_SHADING_MAP_SIZE));
        final CaptureCallbackHolder holder = CameraDeviceImpl.this.mCaptureCallbackMap.get(requestId);
        final CaptureRequest request = holder.getRequest(resultExtras.getSubsequenceId());
        boolean isPartialResult = (resultExtras.getPartialResultCount() < mTotalPartialCount);
        boolean isReprocess = request.isReprocess();
        // Check if we have a callback for this
        if (holder == null) {
            if (DEBUG) {
                Log.d(TAG, ""holder is null, early return at frame "" + frameNumber);
            }
            mFrameNumberTracker.updateTracker(frameNumber, /*result*/
            null, isPartialResult, isReprocess);
            return;
        }
        if (isClosed()) {
            if (DEBUG) {
                Log.d(TAG, ""camera is closed, early return at frame "" + frameNumber);
            }
            mFrameNumberTracker.updateTracker(frameNumber, /*result*/
            null, isPartialResult, isReprocess);
            return;
        }
        Runnable resultDispatch = null;
        CaptureResult finalResult;
        // Either send a partial result or the final capture completed result
        if (isPartialResult) {
            final CaptureResult resultAsCapture = new CaptureResult(result, request, resultExtras);
            // Partial result
            resultDispatch = new Runnable() {

                @Override
                public void run() {
                    if (!CameraDeviceImpl.this.isClosed()) {
                        holder.getCallback().onCaptureProgressed(CameraDeviceImpl.this, request, resultAsCapture);
                    }
                }
            };
            finalResult = resultAsCapture;
        } else {
            List<CaptureResult> partialResults = mFrameNumberTracker.popPartialResults(frameNumber);
            final TotalCaptureResult resultAsCapture = new TotalCaptureResult(result, request, resultExtras, partialResults, holder.getSessionId());
            // Final capture result
            resultDispatch = new Runnable() {

                @Override
                public void run() {
                    if (!CameraDeviceImpl.this.isClosed()) {
                        holder.getCallback().onCaptureCompleted(CameraDeviceImpl.this, request, resultAsCapture);
                    }
                }
            };
            finalResult = resultAsCapture;
        }
        holder.getHandler().post(resultDispatch);
        // Collect the partials for a total result; or mark the frame as totally completed
        mFrameNumberTracker.updateTracker(frameNumber, finalResult, isPartialResult, isReprocess);
        // Fire onCaptureSequenceCompleted
        if (!isPartialResult) {
            checkAndFireSequenceComplete();
        }
    }
}","{
    int requestId = resultExtras.getRequestId();
    long frameNumber = resultExtras.getFrameNumber();
    if (DEBUG) {
        Log.v(TAG, ""Received result frame "" + frameNumber + "" for id "" + requestId);
    }
    synchronized (mInterfaceLock) {
        // Camera already closed
        if (mRemoteDevice == null)
            return;
        // TODO: Handle CameraCharacteristics access from CaptureResult correctly.
        result.set(CameraCharacteristics.LENS_INFO_SHADING_MAP_SIZE, getCharacteristics().get(CameraCharacteristics.LENS_INFO_SHADING_MAP_SIZE));
        final CaptureCallbackHolder holder = CameraDeviceImpl.this.mCaptureCallbackMap.get(requestId);
        final CaptureRequest request = holder.getRequest(resultExtras.getSubsequenceId());
        boolean isPartialResult = (resultExtras.getPartialResultCount() < mTotalPartialCount);
        boolean isReprocess = request.isReprocess();
        // Check if we have a callback for this
        if (holder == null) {
            if (DEBUG) {
                Log.d(TAG, ""holder is null, early return at frame "" + frameNumber);
            }
            mFrameNumberTracker.updateTracker(frameNumber, /*result*/
            null, isPartialResult, isReprocess);
            return;
        }
        if (isClosed()) {
            if (DEBUG) {
                Log.d(TAG, ""camera is closed, early return at frame "" + frameNumber);
            }
            mFrameNumberTracker.updateTracker(frameNumber, /*result*/
            null, isPartialResult, isReprocess);
            return;
        }
        Runnable resultDispatch = null;
        CaptureResult finalResult;
        // Make a copy of the native metadata before it gets moved to a CaptureResult
        // object.
        final CameraMetadataNative resultCopy;
        if (holder.hasBatchedOutputs()) {
            resultCopy = new CameraMetadataNative(result);
        } else {
            resultCopy = null;
        }
        // Either send a partial result or the final capture completed result
        if (isPartialResult) {
            final CaptureResult resultAsCapture = new CaptureResult(result, request, resultExtras);
            // Partial result
            resultDispatch = new Runnable() {

                @Override
                public void run() {
                    if (!CameraDeviceImpl.this.isClosed()) {
                        if (holder.hasBatchedOutputs()) {
                            // the batch.
                            for (int i = 0; i < holder.getRequestCount(); i++) {
                                CameraMetadataNative resultLocal = new CameraMetadataNative(resultCopy);
                                CaptureResult resultInBatch = new CaptureResult(resultLocal, holder.getRequest(i), resultExtras);
                                holder.getCallback().onCaptureProgressed(CameraDeviceImpl.this, holder.getRequest(i), resultInBatch);
                            }
                        } else {
                            holder.getCallback().onCaptureProgressed(CameraDeviceImpl.this, request, resultAsCapture);
                        }
                    }
                }
            };
            finalResult = resultAsCapture;
        } else {
            List<CaptureResult> partialResults = mFrameNumberTracker.popPartialResults(frameNumber);
            final long sensorTimestamp = result.get(CaptureResult.SENSOR_TIMESTAMP);
            final Range<Integer> fpsRange = request.get(CaptureRequest.CONTROL_AE_TARGET_FPS_RANGE);
            final int subsequenceId = resultExtras.getSubsequenceId();
            final TotalCaptureResult resultAsCapture = new TotalCaptureResult(result, request, resultExtras, partialResults, holder.getSessionId());
            // Final capture result
            resultDispatch = new Runnable() {

                @Override
                public void run() {
                    if (!CameraDeviceImpl.this.isClosed()) {
                        if (holder.hasBatchedOutputs()) {
                            // the batch.
                            for (int i = 0; i < holder.getRequestCount(); i++) {
                                resultCopy.set(CaptureResult.SENSOR_TIMESTAMP, sensorTimestamp - (subsequenceId - i) * NANO_PER_SECOND / fpsRange.getUpper());
                                CameraMetadataNative resultLocal = new CameraMetadataNative(resultCopy);
                                TotalCaptureResult resultInBatch = new TotalCaptureResult(resultLocal, holder.getRequest(i), resultExtras, partialResults, holder.getSessionId());
                                holder.getCallback().onCaptureCompleted(CameraDeviceImpl.this, holder.getRequest(i), resultInBatch);
                            }
                        } else {
                            holder.getCallback().onCaptureCompleted(CameraDeviceImpl.this, request, resultAsCapture);
                        }
                    }
                }
            };
            finalResult = resultAsCapture;
        }
        holder.getHandler().post(resultDispatch);
        // Collect the partials for a total result; or mark the frame as totally completed
        mFrameNumberTracker.updateTracker(frameNumber, finalResult, isPartialResult, isReprocess);
        // Fire onCaptureSequenceCompleted
        if (!isPartialResult) {
            checkAndFireSequenceComplete();
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
311,<android.hardware.camera2.impl.CameraDeviceImpl.CameraDeviceCallbacks: void onPrepared(int)>,25,26,<android.hardware.camera2.impl.CameraDeviceImpl.CameraDeviceCallbacks: void onPrepared(int)>,<android.hardware.camera2.impl.CameraDeviceImpl.CameraDeviceCallbacks: void onPrepared(int)>,0,"{
    final OutputConfiguration output;
    final StateCallbackKK sessionCallback;
    if (DEBUG) {
        Log.v(TAG, ""Stream "" + streamId + "" is prepared"");
    }
    synchronized (mInterfaceLock) {
        output = mConfiguredOutputs.get(streamId);
        sessionCallback = mSessionStateCallback;
    }
    if (sessionCallback == null)
        return;
    if (output == null) {
        Log.w(TAG, ""onPrepared invoked for unknown output Surface"");
        return;
    }
    final Surface surface = output.getSurface();
    sessionCallback.onSurfacePrepared(surface);
}","{
    final OutputConfiguration output;
    final StateCallbackKK sessionCallback;
    if (DEBUG) {
        Log.v(TAG, ""Stream "" + streamId + "" is prepared"");
    }
    synchronized (mInterfaceLock) {
        output = mConfiguredOutputs.get(streamId);
        sessionCallback = mSessionStateCallback;
    }
    if (sessionCallback == null)
        return;
    if (output == null) {
        Log.w(TAG, ""onPrepared invoked for unknown output Surface"");
        return;
    }
    final List<Surface> surfaces = output.getSurfaces();
    for (Surface surface : surfaces) {
        sessionCallback.onSurfacePrepared(surface);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The method now iterates over a list of surfaces instead of using a single surface, and invokes the callback method on each surface in the list, so the change type is 3,4 due to the addition of a for loop and change in method call from operation on a single Surface to multiple Surfaces.","Although the implementation has changed, it does not represent a Compatibility Issue because the method's signature has remained the same and the behavior is consistent with its intent; it is now just calling the callback on each Surface in a list instead of a single Surface. There will be no change in how the method is used by the clients, as long as they expect the callback to be called for each prepared surface, which seems implied by the use of a list in the updated version. Therefore, there is no Compatibility Issue."
312,"<android.app.ContextImpl: void sendBroadcastAsUser(Intent,UserHandle)>",25,26,"<android.app.ContextImpl: void sendBroadcastAsUser(Intent,UserHandle)>","<android.app.ContextImpl: void sendBroadcastAsUser(Intent,UserHandle)>",0,"{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, false, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, false, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The method getActivityManager().broadcastIntent() has been replaced with ActivityManager.getService().broadcastIntent(), which indicates that the dependent API used for broadcasting intents has changed. This means that the code change type is 5.","There's no indication that the signature or behavior of the broadcastIntent method has changed, only the way to get the instance of the service. This is a typical example of refactoring to use a different instance-getting method (likely due to a change in best practice or API cleanup). As long as the broadcastIntent method in ActivityManager maintains the same contract, there should be no Compatibility Issue for clients of the sendBroadcastAsUser API. So, the CI type is 0."
314,"<android.app.admin.DevicePolicyManager: boolean installCaCert(ComponentName,byte[])>",25,26,"<android.app.admin.DevicePolicyManager: boolean installCaCert(ComponentName,byte[])>","<android.app.admin.DevicePolicyManager: boolean installCaCert(ComponentName,byte[])>",0,"{
    throwIfParentInstance(""installCaCert"");
    if (mService != null) {
        try {
            return mService.installCaCert(admin, certBuffer);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return false;
}","{
    throwIfParentInstance(""installCaCert"");
    if (mService != null) {
        try {
            return mService.installCaCert(admin, mContext.getPackageName(), certBuffer);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return false;
}",1,"/**
 * Installs the given certificate as a user CA.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or
 * {@code null} if calling from a delegated certificate installer.
 * @param certBuffer encoded form of the certificate to install.
 *
 * @return false if the certBuffer cannot be parsed or installation is
 * interrupted, true otherwise.
 * @throws SecurityException if {@code admin} is not {@code null} and not a device or profile
 * owner.
 */
","/**
 * Installs the given certificate as a user CA.
 *
 * The caller must be a profile or device owner on that user, or a delegate package given the
 * {@link #DELEGATION_CERT_INSTALL} scope via {@link #setDelegatedScopes}; otherwise a
 * security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or
 * {@code null} if calling from a delegated certificate installer.
 * @param certBuffer encoded form of the certificate to install.
 *
 * @return false if the certBuffer cannot be parsed or installation is
 * interrupted, true otherwise.
 * @throws SecurityException if {@code admin} is not {@code null} and not a device or profile
 * owner.
 * @see #setDelegatedScopes
 * @see #DELEGATION_CERT_INSTALL
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method that is called within the try block has changed from mService.installCaCert(admin, certBuffer) to mService.installCaCert(admin, mContext.getPackageName(), certBuffer). The dependent API has changed because the method signature now includes an additional parameter, so the change type is 5.","While the dependent API within the implementation has changed, there is no indication of a change in behavior for this method from the perspective of return values or exception handling (both versions throw the same exception and return false in the same case). Therefore, no Compatibility Issue arises from this change, and the CI type is 0."
315,<android.app.AppOpsManager: String permissionToOp(String)>,25,26,<android.app.AppOpsManager: String permissionToOp(String)>,<android.app.AppOpsManager: String permissionToOp(String)>,0,"{
    final Integer opCode = sRuntimePermToOp.get(permission);
    if (opCode == null) {
        return null;
    }
    return sOpToString[opCode];
}","{
    final Integer opCode = sPermToOp.get(permission);
    if (opCode == null) {
        return null;
    }
    return sOpToString[opCode];
}",1,"/**
 * Gets the app op name associated with a given permission.
 * The app op name is one of the public constants defined
 * in this class such as {@link #OPSTR_COARSE_LOCATION}.
 * This API is intended to be used for mapping runtime
 * permissions to the corresponding app op.
 *
 * @param permission The permission.
 * @return The app op associated with the permission or null.
 */
","/**
 * Gets the app op name associated with a given permission.
 * The app op name is one of the public constants defined
 * in this class such as {@link #OPSTR_COARSE_LOCATION}.
 * This API is intended to be used for mapping runtime
 * permissions to the corresponding app op.
 *
 * @param permission The permission.
 * @return The app op associated with the permission or null.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent map for retrieving the operation code has changed from sRuntimePermToOp to sPermToOp, so the change type is 5.","The alteration in the map used doesn't create a compatibility issue as long as `sPermToOp` holds the same set of mappings from permissions to op codes as `sRuntimePermToOp` did. Since there's no indication the semantics or behavior of the mapping have changed, no compatibility issue is anticipated in this case."
316,<android.app.EnterTransitionCoordinator: void prepareEnter()>,25,26,<android.app.EnterTransitionCoordinator: void prepareEnter()>,<android.app.EnterTransitionCoordinator: void prepareEnter()>,0,"{
    ViewGroup decorView = getDecor();
    if (mActivity == null || decorView == null) {
        return;
    }
    if (!isCrossTask()) {
        mActivity.overridePendingTransition(0, 0);
    }
    if (!mIsReturning) {
        mWasOpaque = mActivity.convertToTranslucent(null, null);
        Drawable background = decorView.getBackground();
        if (background != null) {
            getWindow().setBackgroundDrawable(null);
            background = background.mutate();
            background.setAlpha(0);
            getWindow().setBackgroundDrawable(background);
        }
    } else {
        // all done with it now.
        mActivity = null;
    }
}","{
    ViewGroup decorView = getDecor();
    if (mActivity == null || decorView == null) {
        return;
    }
    if (!isCrossTask()) {
        mActivity.overridePendingTransition(0, 0);
    }
    if (!mIsReturning) {
        mWasOpaque = mActivity.convertToTranslucent(null, null);
        Drawable background = decorView.getBackground();
        if (background == null) {
            background = new ColorDrawable(Color.TRANSPARENT);
            mReplacedBackground = background;
        } else {
            getWindow().setBackgroundDrawable(null);
            background = background.mutate();
            background.setAlpha(0);
        }
        getWindow().setBackgroundDrawable(background);
    } else {
        // all done with it now.
        mActivity = null;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The change occurs inside the if (!mIsReturning) block, where the handling of the 'background' variable is different. There's a new object creation of a ColorDrawable when 'background' is null in the late implementation, and assignment to a previously undeclared field mReplacedBackground. Additionally, the call to `getWindow().setBackgroundDrawable(background);` has been changed in the control flow; it is now outside of the latter 'if' block and will get executed for both null and non-null 'background'. These changes include a new return variable instantiation (ColorDrawable), a change in the control dependency (relocation of setBackgroundDrawable), and other statement changes (new variable assignment). So, the code change type is 1,3,4.","The API can return different behaviors due to the control flow changes and the newly introduced statements. Specifically, the introduction of a default transparent background drawable when the background is null could result in a new drawable being set as the window background where there would have been none in the early version, which means the perceived UI (drawables) could be different. This qualifies as a potential change in return values (visually, as it affects the UI even if the method return type is void), so the CI type is 1."
317,<android.view.MotionEvent: void transform(Matrix)>,25,26,<android.view.MotionEvent: void transform(Matrix)>,<android.view.MotionEvent: void transform(Matrix)>,0,"{
    if (matrix == null) {
        throw new IllegalArgumentException(""matrix must not be null"");
    }
    nativeTransform(mNativePtr, matrix);
}","{
    if (matrix == null) {
        throw new IllegalArgumentException(""matrix must not be null"");
    }
    nativeTransform(mNativePtr, matrix.native_instance);
}",1,"/**
 * Applies a transformation matrix to all of the points in the event.
 *
 * @param matrix The transformation matrix to apply.
 */
","/**
 * Applies a transformation matrix to all of the points in the event.
 *
 * @param matrix The transformation matrix to apply.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"There is a change in the parameter passed to the nativeTransform method, from 'matrix' to 'matrix.native_instance'. This indicates a change in how the input is processed before being passed to the nativeTransform method. Therefore, the code change type is 4 (Other statement changed) and 5 (Dependent API changed).","Although there is a change in the implementation, it does not result in a Compatibility Issue since it does not affect the behavior of the method visible to the end user calling transform(Matrix). The method still performs the same operation from the API user's perspective and would not cause the method to return a different variable (value or type) or throw a different exception. Thus, no Compatibility Issue exists, indicated by 0."
318,<android.app.FragmentManagerImpl: Fragment findFragmentById(int)>,25,26,<android.app.FragmentManagerImpl: Fragment findFragmentById(int)>,<android.app.FragmentManagerImpl: Fragment findFragmentById(int)>,0,"{
    if (mAdded != null) {
        // First look through added fragments.
        for (int i = mAdded.size() - 1; i >= 0; i--) {
            Fragment f = mAdded.get(i);
            if (f != null && f.mFragmentId == id) {
                return f;
            }
        }
    }
    if (mActive != null) {
        // Now for any known fragment.
        for (int i = mActive.size() - 1; i >= 0; i--) {
            Fragment f = mActive.get(i);
            if (f != null && f.mFragmentId == id) {
                return f;
            }
        }
    }
    return null;
}","{
    if (mAdded != null) {
        // First look through added fragments.
        for (int i = mAdded.size() - 1; i >= 0; i--) {
            Fragment f = mAdded.get(i);
            if (f != null && f.mFragmentId == id) {
                return f;
            }
        }
    }
    if (mActive != null) {
        // Now for any known fragment.
        for (int i = mActive.size() - 1; i >= 0; i--) {
            Fragment f = mActive.valueAt(i);
            if (f != null && f.mFragmentId == id) {
                return f;
            }
        }
    }
    return null;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,5,1,"The method for accessing elements of mActive has changed from get(i) to valueAt(i), indicating that the underlying data structure of mActive might have changed between the versions, hence the change type is 5.","Since the underlying data structure of mActive likely has changed, which could alter the logic of how fragments are found by their id, there is a potential for a different fragment to be returned. Therefore, the type of Compatibility Issue is 1, as it may return a different value."
319,"<android.app.Notification.Builder: Builder setSound(Uri,int)>",25,26,"<android.app.Notification.Builder: Builder setSound(Uri,int)>","<android.app.Notification.Builder: Builder setSound(Uri,int)>",0,"{
    mN.sound = sound;
    mN.audioStreamType = streamType;
    return this;
}","{
    PlayerBase.deprecateStreamTypeForPlayback(streamType, ""Notification"", ""setSound()"");
    mN.sound = sound;
    mN.audioStreamType = streamType;
    return this;
}",1,"/**
 * Set the sound to play, along with a specific stream on which to play it.
 *
 * See {@link android.media.AudioManager} for the <code>STREAM_</code> constants.
 *
 * <p>
 * A notification that is noisy is more likely to be presented as a heads-up notification.
 * </p>
 * @deprecated use {@link #setSound(Uri, AudioAttributes)} instead.
 * @see Notification#sound
 */
","/**
 * Set the sound to play, along with a specific stream on which to play it.
 *
 * See {@link android.media.AudioManager} for the <code>STREAM_</code> constants.
 *
 * @deprecated use {@link NotificationChannel#setSound(Uri, AudioAttributes)}.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,4,0,"An additional method call PlayerBase.deprecateStreamTypeForPlayback(streamType, ""Notification"", ""setSound()"") has been added that does not alter the control flow or change the return value of the late implementation. Thus, the change type is 4.","Since the added method call is merely a notification of deprecation without changing the behavior of the API or the return type/value, it does not lead to a Compatibility Issue. Therefore, CI type is 0."
321,<android.app.RemoteInput.Builder: Builder setAllowFreeFormInput(boolean)>,25,26,<android.app.RemoteInput.Builder: Builder setAllowFreeFormInput(boolean)>,<android.app.RemoteInput.Builder: Builder setAllowFreeFormInput(boolean)>,0,"{
    setFlag(mFlags, allowFreeFormInput);
    return this;
}","{
    setFlag(mFlags, allowFreeFormTextInput);
    return this;
}",1,"/**
 * Specifies whether the user can provide arbitrary values.
 *
 * @param allowFreeFormInput The default is {@code true}.
 * If you specify {@code false}, you must provide a non-null
 * and non-empty array to {@link #setChoices} or an
 * {@link IllegalArgumentException} is thrown.
 * @return this object for method chaining
 */
","/**
 * Specifies whether the user can provide arbitrary text values.
 *
 * @param allowFreeFormTextInput The default is {@code true}.
 * If you specify {@code false}, you must either provide a non-null
 * and non-empty array to {@link #setChoices}, or enable a data result
 * in {@code setAllowDataType}. Otherwise an
 * {@link IllegalArgumentException} is thrown.
 * @return this object for method chaining
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The setFlag method is invoked with a different parameter (from allowFreeFormInput to allowFreeFormTextInput), but the setFlag method's code is not provided to determine if the behavior of setFlag has changed as a result of this parameter change. Hence, based only on what is available, we categorize the code change as 5 (Dependent API changed).","Without additional context on how the setFlag method handles the two different parameters (allowFreeFormInput and allowFreeFormTextInput), it's not possible to accurately predict if a different behavior or a compatibility issue would arise. Therefore, we cannot assume a compatibility issue based on the provided information. The CI is classified as 0 (No Compatibility Issue)."
322,<android.app.PendingIntent: String getTargetPackage()>,25,26,<android.app.PendingIntent: String getTargetPackage()>,<android.app.PendingIntent: String getTargetPackage()>,0,"{
    try {
        return ActivityManagerNative.getDefault().getPackageForIntentSender(mTarget);
    } catch (RemoteException e) {
        // Should never happen.
        return null;
    }
}","{
    try {
        return ActivityManager.getService().getPackageForIntentSender(mTarget);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * @deprecated Renamed to {@link #getCreatorPackage()}.
 */
","/**
 * @deprecated Renamed to {@link #getCreatorPackage()}.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,"2,5",2,"The method used to retrieve the service has changed from `ActivityManagerNative.getDefault()` to `ActivityManager.getService()`, and the exception handling statement has changed from returning null to throwing the exception. Thus the changes are related to both dependent API change and exception handling statement change, so the code change types are 2 and 5.","The exception handling has changed from swallowing the exception and returning null to throwing the exception, potentially resulting in different exception handling behavior. Therefore, the CI type is 2."
323,<android.app.Activity: void setRequestedOrientation(int)>,25,26,<android.app.Activity: void setRequestedOrientation(int)>,<android.app.Activity: void setRequestedOrientation(int)>,0,"{
    if (mParent == null) {
        try {
            ActivityManagerNative.getDefault().setRequestedOrientation(mToken, requestedOrientation);
        } catch (RemoteException e) {
        // Empty
        }
    } else {
        mParent.setRequestedOrientation(requestedOrientation);
    }
}","{
    if (mParent == null) {
        try {
            ActivityManager.getService().setRequestedOrientation(mToken, requestedOrientation);
        } catch (RemoteException e) {
        // Empty
        }
    } else {
        mParent.setRequestedOrientation(requestedOrientation);
    }
}",1,"/**
 * Change the desired orientation of this activity.  If the activity
 * is currently in the foreground or otherwise impacting the screen
 * orientation, the screen will immediately be changed (possibly causing
 * the activity to be restarted). Otherwise, this will be used the next
 * time the activity is visible.
 *
 * @param requestedOrientation An orientation constant as used in
 * {@link ActivityInfo#screenOrientation ActivityInfo.screenOrientation}.
 */
","/**
 * Change the desired orientation of this activity.  If the activity
 * is currently in the foreground or otherwise impacting the screen
 * orientation, the screen will immediately be changed (possibly causing
 * the activity to be restarted). Otherwise, this will be used the next
 * time the activity is visible.
 *
 * @param requestedOrientation An orientation constant as used in
 * {@link ActivityInfo#screenOrientation ActivityInfo.screenOrientation}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,5",0,"The method name that is being called to set the requested orientation has changed from ActivityManagerNative.getDefault().setRequestedOrientation to ActivityManager.getService().setRequestedOrientation. Besides the method change, no other code has been altered, therefore the code change type is 3 (for the change within try block) and 5 for the use of a different dependent API.","Since only the method used to set the orientation has changed and there is no change in the behavior of the API (e.g., it does not throw a new exception or return a different value), there is no compatibility issue according to the provided definitions. Therefore, the CI type is 0."
325,<android.os.Looper: void loop()>,25,26,<android.os.Looper: void loop()>,<android.os.Looper: void loop()>,0,"{
    final Looper me = myLooper();
    if (me == null) {
        throw new RuntimeException(""No Looper; Looper.prepare() wasn't called on this thread."");
    }
    final MessageQueue queue = me.mQueue;
    // Make sure the identity of this thread is that of the local process,
    // and keep track of what that identity token actually is.
    Binder.clearCallingIdentity();
    final long ident = Binder.clearCallingIdentity();
    for (; ; ) {
        // might block
        Message msg = queue.next();
        if (msg == null) {
            // No message indicates that the message queue is quitting.
            return;
        }
        // This must be in a local variable, in case a UI event sets the logger
        final Printer logging = me.mLogging;
        if (logging != null) {
            logging.println("">>>>> Dispatching to "" + msg.target + "" "" + msg.callback + "": "" + msg.what);
        }
        final long traceTag = me.mTraceTag;
        if (traceTag != 0 && Trace.isTagEnabled(traceTag)) {
            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));
        }
        try {
            msg.target.dispatchMessage(msg);
        } finally {
            if (traceTag != 0) {
                Trace.traceEnd(traceTag);
            }
        }
        if (logging != null) {
            logging.println(""<<<<< Finished to "" + msg.target + "" "" + msg.callback);
        }
        // Make sure that during the course of dispatching the
        // identity of the thread wasn't corrupted.
        final long newIdent = Binder.clearCallingIdentity();
        if (ident != newIdent) {
            Log.wtf(TAG, ""Thread identity changed from 0x"" + Long.toHexString(ident) + "" to 0x"" + Long.toHexString(newIdent) + "" while dispatching to "" + msg.target.getClass().getName() + "" "" + msg.callback + "" what="" + msg.what);
        }
        msg.recycleUnchecked();
    }
}","{
    final Looper me = myLooper();
    if (me == null) {
        throw new RuntimeException(""No Looper; Looper.prepare() wasn't called on this thread."");
    }
    final MessageQueue queue = me.mQueue;
    // Make sure the identity of this thread is that of the local process,
    // and keep track of what that identity token actually is.
    Binder.clearCallingIdentity();
    final long ident = Binder.clearCallingIdentity();
    for (; ; ) {
        // might block
        Message msg = queue.next();
        if (msg == null) {
            // No message indicates that the message queue is quitting.
            return;
        }
        // This must be in a local variable, in case a UI event sets the logger
        final Printer logging = me.mLogging;
        if (logging != null) {
            logging.println("">>>>> Dispatching to "" + msg.target + "" "" + msg.callback + "": "" + msg.what);
        }
        final long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;
        final long traceTag = me.mTraceTag;
        if (traceTag != 0 && Trace.isTagEnabled(traceTag)) {
            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));
        }
        final long start = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();
        final long end;
        try {
            msg.target.dispatchMessage(msg);
            end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();
        } finally {
            if (traceTag != 0) {
                Trace.traceEnd(traceTag);
            }
        }
        if (slowDispatchThresholdMs > 0) {
            final long time = end - start;
            if (time > slowDispatchThresholdMs) {
                Slog.w(TAG, ""Dispatch took "" + time + ""ms on "" + Thread.currentThread().getName() + "", h="" + msg.target + "" cb="" + msg.callback + "" msg="" + msg.what);
            }
        }
        if (logging != null) {
            logging.println(""<<<<< Finished to "" + msg.target + "" "" + msg.callback);
        }
        // Make sure that during the course of dispatching the
        // identity of the thread wasn't corrupted.
        final long newIdent = Binder.clearCallingIdentity();
        if (ident != newIdent) {
            Log.wtf(TAG, ""Thread identity changed from 0x"" + Long.toHexString(ident) + "" to 0x"" + Long.toHexString(newIdent) + "" while dispatching to "" + msg.target.getClass().getName() + "" "" + msg.callback + "" what="" + msg.what);
        }
        msg.recycleUnchecked();
    }
}",1,"/**
 * Run the message queue in this thread. Be sure to call
 * {@link #quit()} to end the loop.
 */
","/**
 * Run the message queue in this thread. Be sure to call
 * {@link #quit()} to end the loop.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"There are new statements added to the late version which calculate the dispatch time and log it if it's above a certain threshold. These statements are additions that do not change the control flow, so the code change is classified as 4 (Other statement changed).","The added statements for logging slow dispatch do not affect the existing control flow or outcome of the method, and they cannot cause a Compatibility Issue with respect to return values or exceptions. The method behavior in terms of functionality observed by a calling code remains the same, so there is no Compatibility Issue detected, and therefore, the CI type is 0 (No Compatibility Issue)."
327,<android.webkit.CookieSyncManager: CookieSyncManager createInstance(Context)>,25,26,<android.webkit.CookieSyncManager: CookieSyncManager createInstance(Context)>,<android.webkit.CookieSyncManager: CookieSyncManager createInstance(Context)>,0,"{
    if (context == null) {
        throw new IllegalArgumentException(""Invalid context argument"");
    }
    setGetInstanceIsAllowed();
    return getInstance();
}","{
    synchronized (sLock) {
        if (context == null) {
            throw new IllegalArgumentException(""Invalid context argument"");
        }
        setGetInstanceIsAllowed();
        return getInstance();
    }
}",1,"/**
 * Create a singleton CookieSyncManager within a context
 * @param context
 * @return CookieSyncManager
 */
","/**
 * Create a singleton CookieSyncManager within a context
 * @param context
 * @return CookieSyncManager
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The late version added a synchronized block with lock on the sLock object surrounding the current implementation; therefore, the change type is 3.","The addition of a synchronized block does not affect the behavior of the code in terms of the output. It only affects how the code is executed in a multithreaded environment, but does not impact the return values or the exceptions thrown. Hence, it does not constitute a compatibility issue."
328,<android.app.job.JobInfo: long getIntervalMillis()>,25,26,<android.app.job.JobInfo: long getIntervalMillis()>,<android.app.job.JobInfo: long getIntervalMillis()>,0,"{
    return intervalMillis >= getMinPeriodMillis() ? intervalMillis : getMinPeriodMillis();
}","{
    final long minInterval = getMinPeriodMillis();
    return intervalMillis >= minInterval ? intervalMillis : minInterval;
}",1,"/**
 * Set to the interval between occurrences of this job. This value is <b>not</b> set if the
 * job does not recur periodically.
 */
","/**
 * Set to the interval between occurrences of this job. This value is <b>not</b> set if the
 * job does not recur periodically.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,The logic of the return statement and the functionality remain exactly the same in the late version; the change is just a refactoring to store the value of getMinPeriodMillis() in a local variable (minInterval) before using it in the conditional operator.,There is no compatibility issue because the behavior of the method remains the same; the returned value will be the same as before for the same input. The refactoring does not alter the method's external behavior.
329,<android.app.Activity: void finishActivity(int)>,25,26,<android.app.Activity: void finishActivity(int)>,<android.app.Activity: void finishActivity(int)>,0,"{
    if (mParent == null) {
        try {
            ActivityManagerNative.getDefault().finishSubActivity(mToken, mEmbeddedID, requestCode);
        } catch (RemoteException e) {
        // Empty
        }
    } else {
        mParent.finishActivityFromChild(this, requestCode);
    }
}","{
    if (mParent == null) {
        try {
            ActivityManager.getService().finishSubActivity(mToken, mEmbeddedID, requestCode);
        } catch (RemoteException e) {
        // Empty
        }
    } else {
        mParent.finishActivityFromChild(this, requestCode);
    }
}",1,"/**
 * Force finish another activity that you had previously started with
 * {@link #startActivityForResult}.
 *
 * @param requestCode The request code of the activity that you had
 * given to startActivityForResult().  If there are multiple
 * activities started with this request code, they
 * will all be finished.
 */
","/**
 * Force finish another activity that you had previously started with
 * {@link #startActivityForResult}.
 *
 * @param requestCode The request code of the activity that you had
 * given to startActivityForResult().  If there are multiple
 * activities started with this request code, they
 * will all be finished.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,The method has changed from ActivityManagerNative.getDefault().finishSubActivity(...) to ActivityManager.getService().finishSubActivity(...) which indicates a Dependent API changed. No other code changes are observed.,"There is no Compatibility Issue, provided that the behavioral contract of ActivityManager.getService().finishSubActivity(...) remains the same as ActivityManagerNative.getDefault().finishSubActivity(...). The change in method invocation seems to reflect an internal refactor without altering the external behavior."
330,<android.app.ContextImpl: ClassLoader getClassLoader()>,25,26,<android.app.ContextImpl: ClassLoader getClassLoader()>,<android.app.ContextImpl: ClassLoader getClassLoader()>,0,"{
    return mPackageInfo != null ? mPackageInfo.getClassLoader() : ClassLoader.getSystemClassLoader();
}","{
    return mClassLoader != null ? mClassLoader : (mPackageInfo != null ? mPackageInfo.getClassLoader() : ClassLoader.getSystemClassLoader());
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"An additional conditional check is introduced in the return statement (checking `mClassLoader` before `mPackageInfo.getClassLoader()`) and the logic to determine which ClassLoader to return is modified, so the code change type is 1 and 4.","Given there's another possible return value introduced (`mClassLoader`), the API can potentially return different ClassLoader instances after the modification which can affect the caller who expects the previous behavior, hence the CI type is 1."
331,<android.content.ClipboardManager: void setPrimaryClip(ClipData)>,25,26,<android.content.ClipboardManager: void setPrimaryClip(ClipData)>,<android.content.ClipboardManager: void setPrimaryClip(ClipData)>,0,"{
    try {
        if (clip != null) {
            clip.prepareToLeaveProcess(true);
        }
        getService().setPrimaryClip(clip, mContext.getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        if (clip != null) {
            clip.prepareToLeaveProcess(true);
        }
        mService.setPrimaryClip(clip, mContext.getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Sets the current primary clip on the clipboard.  This is the clip that
 * is involved in normal cut and paste operations.
 *
 * @param clip The clipped data item to set.
 */
","/**
 * Sets the current primary clip on the clipboard.  This is the clip that
 * is involved in normal cut and paste operations.
 *
 * @param clip The clipped data item to set.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method getService() is replaced by direct usage of the member variable mService, which implies that the logic to obtain the service reference has changed (different ways to access the service), making it a change type 4.","This change does not affect the behavior as seen from the API consumer's point of view; it's an internal change that should not affect the outcome of the method's execution or its contract. Therefore, there is no compatibility issue, so the CI type is 0."
334,<android.animation.AnimatorSet.Builder: Builder before(Animator)>,25,26,<android.animation.AnimatorSet.Builder: Builder before(Animator)>,<android.animation.AnimatorSet.Builder: Builder before(Animator)>,0,"{
    mReversible = false;
    Node node = getNodeForAnimation(anim);
    mCurrentNode.addChild(node);
    return this;
}","{
    Node node = getNodeForAnimation(anim);
    mCurrentNode.addChild(node);
    return this;
}",1,"/**
 * Sets up the given animation to play when the animation supplied in the
 * {@link AnimatorSet#play(Animator)} call that created this <code>Builder</code> object
 * ends.
 *
 * @param anim The animation that will play when the animation supplied to the
 * {@link AnimatorSet#play(Animator)} method ends.
 */
","/**
 * Sets up the given animation to play when the animation supplied in the
 * {@link AnimatorSet#play(Animator)} call that created this <code>Builder</code> object
 * ends.
 *
 * @param anim The animation that will play when the animation supplied to the
 * {@link AnimatorSet#play(Animator)} method ends.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,The early version contains a statement 'mReversible = false;' which is missing in the late version. This is an Other statement changed type.,"The removal of the statement 'mReversible = false;' from the method body does not change the method's return type or value, nor does it alter exception handling. Hence, it does not introduce a Compatibility Issue."
336,<android.widget.RemoteViews.ViewTree: void createTree()>,25,26,<android.widget.RemoteViews.ViewTree: void createTree()>,<android.widget.RemoteViews.ViewTree: void createTree()>,0,"{
    if (mChildren != null) {
        return;
    }
    mChildren = new ArrayList<>();
    if (mRoot instanceof ViewGroup && mRoot.isRootNamespace()) {
        ViewGroup vg = (ViewGroup) mRoot;
        int count = vg.getChildCount();
        for (int i = 0; i < count; i++) {
            addViewChild(vg.getChildAt(i));
        }
    }
}","{
    if (mChildren != null) {
        return;
    }
    mChildren = new ArrayList<>();
    if (mRoot instanceof ViewGroup) {
        ViewGroup vg = (ViewGroup) mRoot;
        int count = vg.getChildCount();
        for (int i = 0; i < count; i++) {
            addViewChild(vg.getChildAt(i));
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,0,"The condition in the if statement has changed by removing the ""&& mRoot.isRootNamespace()"" check, so the code change type is 3.","There is no Compatibility Issue because the method does not return any value or throw any exceptions, and the change does not introduce any changes to the behavior related to return values or exception handling; it only broadens the condition under which children are added to the mChildren list."
337,<android.app.ActivityTransitionCoordinator.GhostViewListeners: boolean onPreDraw()>,25,26,<android.app.ActivityTransitionCoordinator.GhostViewListeners: boolean onPreDraw()>,<android.app.ActivityTransitionCoordinator.GhostViewListeners: boolean onPreDraw()>,0,"{
    GhostView ghostView = GhostView.getGhost(mView);
    if (ghostView == null) {
        mParent.getViewTreeObserver().removeOnPreDrawListener(this);
    } else {
        GhostView.calculateMatrix(mView, mDecor, mMatrix);
        ghostView.setMatrix(mMatrix);
    }
    return true;
}","{
    GhostView ghostView = GhostView.getGhost(mView);
    if (ghostView == null || !mView.isAttachedToWindow()) {
        removeListener();
    } else {
        GhostView.calculateMatrix(mView, mDecor, mMatrix);
        ghostView.setMatrix(mMatrix);
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,"The condition in the if statement has changed by adding another condition (|| !mView.isAttachedToWindow()), so the code change type is 3.","Although there is a change in the control flow (additional check for mView.isAttachedToWindow()), this change does not lead to a Compatibility Issue, because the method still consistently returns a boolean value true, hence no difference in return values or exception handling behaviour. Therefore, the CI type is 0."
338,<android.content.pm.LauncherActivityInfo: Drawable getIcon(int)>,25,26,<android.content.pm.LauncherActivityInfo: Drawable getIcon(int)>,<android.content.pm.LauncherActivityInfo: Drawable getIcon(int)>,0,"{
    final int iconRes = mActivityInfo.getIconResource();
    Drawable icon = null;
    // Get the preferred density icon from the app's resources
    if (density != 0 && iconRes != 0) {
        try {
            final Resources resources = mPm.getResourcesForApplication(mActivityInfo.applicationInfo);
            icon = resources.getDrawableForDensity(iconRes, density);
        } catch (NameNotFoundException | Resources.NotFoundException exc) {
        }
    }
    // Get the default density icon
    if (icon == null) {
        icon = mActivityInfo.loadIcon(mPm);
    }
    return icon;
}","{
    // TODO: Go through LauncherAppsService
    final int iconRes = mActivityInfo.getIconResource();
    Drawable icon = null;
    // Get the preferred density icon from the app's resources
    if (density != 0 && iconRes != 0) {
        try {
            final Resources resources = mPm.getResourcesForApplication(mActivityInfo.applicationInfo);
            icon = resources.getDrawableForDensity(iconRes, density);
        } catch (NameNotFoundException | Resources.NotFoundException exc) {
        }
    }
    // Get the default density icon
    if (icon == null) {
        icon = mActivityInfo.loadIcon(mPm);
    }
    return icon;
}",1,"/**
 * Returns the icon for this activity, without any badging for the profile.
 * @param density The preferred density of the icon, zero for default density. Use
 * density DPI values from {@link DisplayMetrics}.
 * @see #getBadgedIcon(int)
 * @see DisplayMetrics
 * @return The drawable associated with the activity.
 */
","/**
 * Returns the icon for this activity, without any badging for the profile.
 * @param density The preferred density of the icon, zero for default density. Use
 * density DPI values from {@link DisplayMetrics}.
 * @see #getBadgedIcon(int)
 * @see DisplayMetrics
 * @return The drawable associated with the activity.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"No actual code changes are present between the two versions. The only difference is a comment added ""// TODO: Go through LauncherAppsService"", which does not affect the implementation. Comments do not change the behavior of the code.","There is no Compatibility Issue since there are no changes in the code that could potentially lead to different return values, types, or exceptions thrown."
340,<android.accessibilityservice.AccessibilityServiceInfo: String toString()>,25,26,<android.accessibilityservice.AccessibilityServiceInfo: String toString()>,<android.accessibilityservice.AccessibilityServiceInfo: String toString()>,0,"{
    StringBuilder stringBuilder = new StringBuilder();
    appendEventTypes(stringBuilder, eventTypes);
    stringBuilder.append("", "");
    appendPackageNames(stringBuilder, packageNames);
    stringBuilder.append("", "");
    appendFeedbackTypes(stringBuilder, feedbackType);
    stringBuilder.append("", "");
    stringBuilder.append(""notificationTimeout: "").append(notificationTimeout);
    stringBuilder.append("", "");
    appendFlags(stringBuilder, flags);
    stringBuilder.append("", "");
    stringBuilder.append(""id: "").append(mId);
    stringBuilder.append("", "");
    stringBuilder.append(""resolveInfo: "").append(mResolveInfo);
    stringBuilder.append("", "");
    stringBuilder.append(""settingsActivityName: "").append(mSettingsActivityName);
    stringBuilder.append("", "");
    appendCapabilities(stringBuilder, mCapabilities);
    return stringBuilder.toString();
}","{
    StringBuilder stringBuilder = new StringBuilder();
    appendEventTypes(stringBuilder, eventTypes);
    stringBuilder.append("", "");
    appendPackageNames(stringBuilder, packageNames);
    stringBuilder.append("", "");
    appendFeedbackTypes(stringBuilder, feedbackType);
    stringBuilder.append("", "");
    stringBuilder.append(""notificationTimeout: "").append(notificationTimeout);
    stringBuilder.append("", "");
    appendFlags(stringBuilder, flags);
    stringBuilder.append("", "");
    stringBuilder.append(""id: "").append(getId());
    stringBuilder.append("", "");
    stringBuilder.append(""resolveInfo: "").append(mResolveInfo);
    stringBuilder.append("", "");
    stringBuilder.append(""settingsActivityName: "").append(mSettingsActivityName);
    stringBuilder.append("", "");
    stringBuilder.append(""summary: "").append(mNonLocalizedSummary);
    stringBuilder.append("", "");
    appendCapabilities(stringBuilder, mCapabilities);
    return stringBuilder.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The method `getId()` is used instead of directly accessing the field `mId`, and there is a new field `mNonLocalizedSummary` being appended to the `StringBuilder`. These changes in how the string is constructed mean there are new strings being included and potentially the access method could have changed logic, which corresponds to types 1 (Return statement changed) and 4 (Other statement changed).","These changes to the `toString()` method can potentially alter the return value, as the information being converted into a string format has changed. Specifically, the inclusion of `mNonLocalizedSummary` and the replacement of `mId` with `getId()` could result in a different final string being returned. This is a potential Compatibility Issue of type 1, caused by potentially different return values."
341,"<android.content.ContentResolver: Cursor query(Uri,String[],String,String[],String,CancellationSignal)>",25,26,"<android.content.ContentResolver: Cursor query(Uri,String[],String,String[],String,CancellationSignal)>","<android.content.ContentResolver: Cursor query(Uri,String[],String,String[],String,CancellationSignal)>",0,"{
    Preconditions.checkNotNull(uri, ""uri"");
    IContentProvider unstableProvider = acquireUnstableProvider(uri);
    if (unstableProvider == null) {
        return null;
    }
    IContentProvider stableProvider = null;
    Cursor qCursor = null;
    try {
        long startTime = SystemClock.uptimeMillis();
        ICancellationSignal remoteCancellationSignal = null;
        if (cancellationSignal != null) {
            cancellationSignal.throwIfCanceled();
            remoteCancellationSignal = unstableProvider.createCancellationSignal();
            cancellationSignal.setRemote(remoteCancellationSignal);
        }
        try {
            qCursor = unstableProvider.query(mPackageName, uri, projection, selection, selectionArgs, sortOrder, remoteCancellationSignal);
        } catch (DeadObjectException e) {
            // The remote process has died...  but we only hold an unstable
            // reference though, so we might recover!!!  Let's try!!!!
            // This is exciting!!1!!1!!!!1
            unstableProviderDied(unstableProvider);
            stableProvider = acquireProvider(uri);
            if (stableProvider == null) {
                return null;
            }
            qCursor = stableProvider.query(mPackageName, uri, projection, selection, selectionArgs, sortOrder, remoteCancellationSignal);
        }
        if (qCursor == null) {
            return null;
        }
        // Force query execution.  Might fail and throw a runtime exception here.
        qCursor.getCount();
        long durationMillis = SystemClock.uptimeMillis() - startTime;
        maybeLogQueryToEventLog(durationMillis, uri, projection, selection, sortOrder);
        // Wrap the cursor object into CursorWrapperInner object.
        final IContentProvider provider = (stableProvider != null) ? stableProvider : acquireProvider(uri);
        final CursorWrapperInner wrapper = new CursorWrapperInner(qCursor, provider);
        stableProvider = null;
        qCursor = null;
        return wrapper;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        if (qCursor != null) {
            qCursor.close();
        }
        if (cancellationSignal != null) {
            cancellationSignal.setRemote(null);
        }
        if (unstableProvider != null) {
            releaseUnstableProvider(unstableProvider);
        }
        if (stableProvider != null) {
            releaseProvider(stableProvider);
        }
    }
}","{
    Bundle queryArgs = createSqlQueryBundle(selection, selectionArgs, sortOrder);
    return query(uri, projection, queryArgs, cancellationSignal);
}",1,"/**
 * Query the given URI, returning a {@link Cursor} over the result set
 * with optional support for cancellation.
 * <p>
 * For best performance, the caller should follow these guidelines:
 * <ul>
 * <li>Provide an explicit projection, to prevent
 * reading data from storage that aren't going to be used.</li>
 * <li>Use question mark parameter markers such as 'phone=?' instead of
 * explicit values in the {@code selection} parameter, so that queries
 * that differ only by those values will be recognized as the same
 * for caching purposes.</li>
 * </ul>
 * </p>
 *
 * @param uri The URI, using the content:// scheme, for the content to
 * retrieve.
 * @param projection A list of which columns to return. Passing null will
 * return all columns, which is inefficient.
 * @param selection A filter declaring which rows to return, formatted as an
 * SQL WHERE clause (excluding the WHERE itself). Passing null will
 * return all rows for the given URI.
 * @param selectionArgs You may include ?s in selection, which will be
 * replaced by the values from selectionArgs, in the order that they
 * appear in the selection. The values will be bound as Strings.
 * @param sortOrder How to order the rows, formatted as an SQL ORDER BY
 * clause (excluding the ORDER BY itself). Passing null will use the
 * default sort order, which may be unordered.
 * @param cancellationSignal A signal to cancel the operation in progress, or null if none.
 * If the operation is canceled, then {@link OperationCanceledException} will be thrown
 * when the query is executed.
 * @return A Cursor object, which is positioned before the first entry, or null
 * @see Cursor
 */
","/**
 * Query the given URI, returning a {@link Cursor} over the result set
 * with optional support for cancellation.
 * <p>
 * For best performance, the caller should follow these guidelines:
 * <ul>
 * <li>Provide an explicit projection, to prevent
 * reading data from storage that aren't going to be used.</li>
 * <li>Use question mark parameter markers such as 'phone=?' instead of
 * explicit values in the {@code selection} parameter, so that queries
 * that differ only by those values will be recognized as the same
 * for caching purposes.</li>
 * </ul>
 * </p>
 *
 * @param uri The URI, using the content:// scheme, for the content to
 * retrieve.
 * @param projection A list of which columns to return. Passing null will
 * return all columns, which is inefficient.
 * @param selection A filter declaring which rows to return, formatted as an
 * SQL WHERE clause (excluding the WHERE itself). Passing null will
 * return all rows for the given URI.
 * @param selectionArgs You may include ?s in selection, which will be
 * replaced by the values from selectionArgs, in the order that they
 * appear in the selection. The values will be bound as Strings.
 * @param sortOrder How to order the rows, formatted as an SQL ORDER BY
 * clause (excluding the ORDER BY itself). Passing null will use the
 * default sort order, which may be unordered.
 * @param cancellationSignal A signal to cancel the operation in progress, or null if none.
 * If the operation is canceled, then {@link OperationCanceledException} will be thrown
 * when the query is executed.
 * @return A Cursor object, which is positioned before the first entry, or null
 * @see Cursor
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,"1,4,5",1,"The late implementation of the method has completely changed; it delegates the operation to another internal `query` method with different parameters. Also, the method createSqlQueryBundle() is a new dependent API that constructs the query arguments. The entire try-catch structure, exception handling, and local variables from the early version are gone. The code change involves return statement, other statement (whole method logic), and dependent API, thus the change type is 1,4,5.","Since the implementation has changed entirely and delegates to another method, it's possible that the return values could be different either due to changes in how the delegation is performed, or how the overloaded query method operates. This could cause the API to return different results when given the same input, indicating a CI type of 1."
342,<android.widget.AdapterViewAnimator: void setRemoteViewsAdapter(Intent)>,25,26,<android.widget.AdapterViewAnimator: void setRemoteViewsAdapter(Intent)>,<android.widget.AdapterViewAnimator: void setRemoteViewsAdapter(Intent)>,0,"{
    // service handling the specified intent.
    if (mRemoteViewsAdapter != null) {
        Intent.FilterComparison fcNew = new Intent.FilterComparison(intent);
        Intent.FilterComparison fcOld = new Intent.FilterComparison(mRemoteViewsAdapter.getRemoteViewsServiceIntent());
        if (fcNew.equals(fcOld)) {
            return;
        }
    }
    mDeferNotifyDataSetChanged = false;
    // Otherwise, create a new RemoteViewsAdapter for binding
    mRemoteViewsAdapter = new RemoteViewsAdapter(getContext(), intent, this);
    if (mRemoteViewsAdapter.isDataReady()) {
        setAdapter(mRemoteViewsAdapter);
    }
}","{
    setRemoteViewsAdapter(intent, false);
}",1,"/**
 * Sets up this AdapterViewAnimator to use a remote views adapter which connects to a
 * RemoteViewsService through the specified intent.
 *
 * @param intent the intent used to identify the RemoteViewsService for the adapter to
 * connect to.
 */
","/**
 * Sets up this AdapterViewAnimator to use a remote views adapter which connects to a
 * RemoteViewsService through the specified intent.
 *
 * @param intent the intent used to identify the RemoteViewsService for the adapter to
 * connect to.
 */
",-1,[@android.view.RemotableViewMethod],"[@android.view.RemotableViewMethod(asyncImpl = ""setRemoteViewsAdapterAsync"")]",-1,-1,-1,-1,-1,-1,"1,4,5",1,"The implementation of the method completely changed to calling another method setRemoteViewsAdapter(intent, false), which means we have a Return statement changed (since the original return paths in the method logic are not present in the new implementation), Dependent API changed (since it now depends on a new method setRemoteViewsAdapter with different parameters), and Other statement changed because the logic and other operations are entirely different in the late version.","Given that the original version of the method contains multiple operations and a call to a constructor with logic that is now entirely encapsulated into a different method, it's almost certain that the behavior has changed: the logic comparison to decide whether to proceed or return earlier, the changes on mDeferNotifyDataSetChanged, and the condition to set the adapter. All those behaviors are no longer explicit in the new version, hence, the late version might return different results compared to the early version due to the changes in how it operates, thus resulting in a Compatibility Issue of type 1."
344,<android.hardware.camera2.params.OutputConfiguration: int hashCode()>,25,26,<android.hardware.camera2.params.OutputConfiguration: int hashCode()>,<android.hardware.camera2.params.OutputConfiguration: int hashCode()>,0,"{
    // surface is set.
    if (mIsDeferredConfig) {
        return HashCodeHelpers.hashCode(mRotation, mConfiguredSize.hashCode(), mConfiguredFormat, mConfiguredDataspace, mSurfaceGroupId, mSurfaceType);
    }
    return HashCodeHelpers.hashCode(mRotation, mSurface.hashCode(), mConfiguredGenerationId, mConfiguredSize.hashCode(), mConfiguredFormat, mConfiguredDataspace, mSurfaceGroupId);
}","{
    // surface is set.
    if (mIsDeferredConfig) {
        return HashCodeHelpers.hashCode(mRotation, mConfiguredSize.hashCode(), mConfiguredFormat, mConfiguredDataspace, mSurfaceGroupId, mSurfaceType, mIsShared ? 1 : 0);
    }
    return HashCodeHelpers.hashCode(mRotation, mSurfaces.hashCode(), mConfiguredGenerationId, mConfiguredSize.hashCode(), mConfiguredFormat, mConfiguredDataspace, mSurfaceGroupId, mIsShared ? 1 : 0);
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"There is a change in the arguments passed to HashCodeHelpers.hashCode method. In the 'if' block, a new parameter 'mIsShared ? 1 : 0' is added. In the 'else' block, there is not only the addition of 'mIsShared ? 1 : 0' but also a change from 'mSurface.hashCode()' to 'mSurfaces.hashCode()'. This alteration is an internal state change and parameter change in method invocations, which is classified as an 'Other statement changed' type 4.","There is no Compatibility Issue because the hashCode method's contract typically allows for different values to be produced as long as the general contract of hashCode (that equal objects must produce the same hashCode value) is preserved. Therefore, even though the hashCode calculation logic is changed between versions, it does not violate the contract and hence does not cause a Compatibility Issue. This is a standard change when altering hashCode implementations to include new fields or attributes."
345,<android.app.ActivityManager: List<ProcessErrorStateInfo> getProcessesInErrorState()>,25,26,<android.app.ActivityManager: List<ProcessErrorStateInfo> getProcessesInErrorState()>,<android.app.ActivityManager: List<ProcessErrorStateInfo> getProcessesInErrorState()>,0,"{
    try {
        return ActivityManagerNative.getDefault().getProcessesInErrorState();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        return getService().getProcessesInErrorState();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns a list of any processes that are currently in an error condition.  The result
 * will be null if all processes are running properly at this time.
 *
 * @return Returns a list of ProcessErrorStateInfo records, or null if there are no
 * current error conditions (it will not return an empty list).  This list ordering is not
 * specified.
 */
","/**
 * Returns a list of any processes that are currently in an error condition.  The result
 * will be null if all processes are running properly at this time.
 *
 * @return Returns a list of ProcessErrorStateInfo records, or null if there are no
 * current error conditions (it will not return an empty list).  This list ordering is not
 * specified.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The code change is the replacement of ActivityManagerNative.getDefault() with getService() in the return statement, which is a change in the dependent API invocation but neither the return value nor the type is directly changed by this modification, so the code change type is 4,5.","There is no Compatibility Issue since the modification is a refactoring that does not affect the returned value or type, nor does it alter the exceptions thrown. The behavior of the method is intended to remain the same assuming getService() is functionally equivalent to ActivityManagerNative.getDefault(). Therefore, CI type is 0."
346,"<android.widget.RemoteViews.TextViewDrawableColorFilterAction: void apply(View,ViewGroup,OnClickHandler)>",25,26,"<android.widget.RemoteViews.TextViewDrawableColorFilterAction: void apply(View,ViewGroup,OnClickHandler)>","<android.widget.RemoteViews.TextViewDrawableColorFilterAction: void apply(View,ViewGroup,OnClickHandler)>",0,"{
    final TextView target = (TextView) root.findViewById(viewId);
    if (target == null)
        return;
    Drawable[] drawables = isRelative ? target.getCompoundDrawablesRelative() : target.getCompoundDrawables();
    if (index < 0 || index >= 4) {
        throw new IllegalStateException(""index must be in range [0, 3]."");
    }
    Drawable d = drawables[index];
    if (d != null) {
        d.mutate();
        d.setColorFilter(color, mode);
    }
}","{
    final TextView target = root.findViewById(viewId);
    if (target == null)
        return;
    Drawable[] drawables = isRelative ? target.getCompoundDrawablesRelative() : target.getCompoundDrawables();
    if (index < 0 || index >= 4) {
        throw new IllegalStateException(""index must be in range [0, 3]."");
    }
    Drawable d = drawables[index];
    if (d != null) {
        d.mutate();
        d.setColorFilter(color, mode);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,0,0,"There is no actual code change between the two versions, only the casting to TextView was removed because it was redundant (root.findViewById automatically returns a view of the specific requested type), which does not affect the functionality.","As there are no changes in the functionality or behavior of the API, there is no Compatibility Issue between the two versions."
347,<android.hardware.camera2.CameraCharacteristics: List<Key<?>> getKeys()>,25,26,<android.hardware.camera2.CameraCharacteristics: List<Key<?>> getKeys()>,<android.hardware.camera2.CameraCharacteristics: List<Key<?>> getKeys()>,0,"{
    // List of keys is immutable; cache the results after we calculate them
    if (mKeys != null) {
        return mKeys;
    }
    int[] filterTags = get(REQUEST_AVAILABLE_CHARACTERISTICS_KEYS);
    if (filterTags == null) {
        throw new AssertionError(""android.request.availableCharacteristicsKeys must be non-null"" + "" in the characteristics"");
    }
    mKeys = Collections.unmodifiableList(getKeysStatic(getClass(), getKeyClass(), this, filterTags));
    return mKeys;
}","{
    // List of keys is immutable; cache the results after we calculate them
    if (mKeys != null) {
        return mKeys;
    }
    int[] filterTags = get(REQUEST_AVAILABLE_CHARACTERISTICS_KEYS);
    if (filterTags == null) {
        throw new AssertionError(""android.request.availableCharacteristicsKeys must be non-null"" + "" in the characteristics"");
    }
    mKeys = Collections.unmodifiableList(getKeys(getClass(), getKeyClass(), this, filterTags));
    return mKeys;
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,"[@NonNull, @Override]","[@NonNull, @Override]",-1,-1,-1,-1,-1,-1,5,0,"The method name called has changed from getKeysStatic(...) to getKeys(...), indicating a modification to a dependent API, which classifies as code change type 5.","There is no compatibility issue since the method's intended functionality and return type remain the same. It's an internal implementation detail which the caller would not be aware of, assuming the semantics of getKeys(...) remains consistent with what getKeysStatic(...) was providing."
349,"<android.content.IntentSender: void sendIntent(Context,int,Intent,OnFinished,Handler,String)>",25,26,"<android.content.IntentSender: void sendIntent(Context,int,Intent,OnFinished,Handler,String)>","<android.content.IntentSender: void sendIntent(Context,int,Intent,OnFinished,Handler,String)>",0,"{
    try {
        String resolvedType = intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
        int res = ActivityManagerNative.getDefault().sendIntentSender(mTarget, code, intent, resolvedType, onFinished != null ? new FinishedDispatcher(this, onFinished, handler) : null, requiredPermission, null);
        if (res < 0) {
            throw new SendIntentException();
        }
    } catch (RemoteException e) {
        throw new SendIntentException();
    }
}","{
    try {
        String resolvedType = intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
        int res = ActivityManager.getService().sendIntentSender(mTarget, mWhitelistToken, code, intent, resolvedType, onFinished != null ? new FinishedDispatcher(this, onFinished, handler) : null, requiredPermission, null);
        if (res < 0) {
            throw new SendIntentException();
        }
    } catch (RemoteException e) {
        throw new SendIntentException();
    }
}",1,"/**
 * Perform the operation associated with this IntentSender, allowing the
 * caller to specify information about the Intent to use and be notified
 * when the send has completed.
 *
 * @param context The Context of the caller.  This may be null if
 * <var>intent</var> is also null.
 * @param code Result code to supply back to the IntentSender's target.
 * @param intent Additional Intent data.  See {@link Intent#fillIn
 * Intent.fillIn()} for information on how this is applied to the
 * original Intent.  Use null to not modify the original Intent.
 * @param onFinished The object to call back on when the send has
 * completed, or null for no callback.
 * @param handler Handler identifying the thread on which the callback
 * should happen.  If null, the callback will happen from the thread
 * pool of the process.
 * @param requiredPermission Name of permission that a recipient of the PendingIntent
 * is required to hold.  This is only valid for broadcast intents, and
 * corresponds to the permission argument in
 * {@link Context#sendBroadcast(Intent, String) Context.sendOrderedBroadcast(Intent, String)}.
 * If null, no permission is required.
 *
 * @throws SendIntentException Throws CanceledIntentException if the IntentSender
 * is no longer allowing more intents to be sent through it.
 */
","/**
 * Perform the operation associated with this IntentSender, allowing the
 * caller to specify information about the Intent to use and be notified
 * when the send has completed.
 *
 * @param context The Context of the caller.  This may be null if
 * <var>intent</var> is also null.
 * @param code Result code to supply back to the IntentSender's target.
 * @param intent Additional Intent data.  See {@link Intent#fillIn
 * Intent.fillIn()} for information on how this is applied to the
 * original Intent.  Use null to not modify the original Intent.
 * @param onFinished The object to call back on when the send has
 * completed, or null for no callback.
 * @param handler Handler identifying the thread on which the callback
 * should happen.  If null, the callback will happen from the thread
 * pool of the process.
 * @param requiredPermission Name of permission that a recipient of the PendingIntent
 * is required to hold.  This is only valid for broadcast intents, and
 * corresponds to the permission argument in
 * {@link Context#sendBroadcast(Intent, String) Context.sendOrderedBroadcast(Intent, String)}.
 * If null, no permission is required.
 *
 * @throws SendIntentException Throws CanceledIntentException if the IntentSender
 * is no longer allowing more intents to be sent through it.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,The dependent API used has been updated from ActivityManagerNative.getDefault().sendIntentSender() to ActivityManager.getService().sendIntentSender(); thus the code change type is 5.,"Even though there's a change in the dependent API, the caller method's signature, behavior and the exceptions thrown are not altered. Hence, there's no Compatibility Issue, which means the CI type is 0."
352,<android.app.job.JobInfo.Builder: Builder setRequiresDeviceIdle(boolean)>,25,26,<android.app.job.JobInfo.Builder: Builder setRequiresDeviceIdle(boolean)>,<android.app.job.JobInfo.Builder: Builder setRequiresDeviceIdle(boolean)>,0,"{
    mRequiresDeviceIdle = requiresDeviceIdle;
    return this;
}","{
    mConstraintFlags = (mConstraintFlags & ~CONSTRAINT_FLAG_DEVICE_IDLE) | (requiresDeviceIdle ? CONSTRAINT_FLAG_DEVICE_IDLE : 0);
    return this;
}",1,"/**
 * Specify that to run, the job needs the device to be in idle mode. This defaults to
 * false.
 * <p>Idle mode is a loose definition provided by the system, which means that the device
 * is not in use, and has not been in use for some time. As such, it is a good time to
 * perform resource heavy jobs. Bear in mind that battery usage will still be attributed
 * to your application, and surfaced to the user in battery stats.</p>
 * @param requiresDeviceIdle Whether or not the device need be within an idle maintenance
 * window.
 */
","/**
 * Specify that to run, the job needs the device to be in idle mode. This defaults to
 * false.
 * <p>Idle mode is a loose definition provided by the system, which means that the device
 * is not in use, and has not been in use for some time. As such, it is a good time to
 * perform resource heavy jobs. Bear in mind that battery usage will still be attributed
 * to your application, and surfaced to the user in battery stats.</p>
 * @param requiresDeviceIdle Whether or not the device need be within an idle maintenance
 * window.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The implementation has only changed in terms of how the requirement for the device being idle is stored internally, from a direct boolean assignment to using bitwise operations. So the change is considered as 4 (other statement changed).","This internal change in the way the variable is set does not affect the public behavior or API contract as the property being set remains the same, just the internal representation has changed. Therefore, there is no compatibility issue, the CI type is 0."
353,"<android.app.ContextImpl: Context createApplicationContext(ApplicationInfo,int)>",25,26,"<android.app.ContextImpl: Context createApplicationContext(ApplicationInfo,int)>","<android.app.ContextImpl: Context createApplicationContext(ApplicationInfo,int)>",0,"{
    LoadedApk pi = mMainThread.getPackageInfo(application, mResources.getCompatibilityInfo(), flags | CONTEXT_REGISTER_PACKAGE);
    if (pi != null) {
        ContextImpl c = new ContextImpl(this, mMainThread, pi, mActivityToken, new UserHandle(UserHandle.getUserId(application.uid)), flags, mDisplay, null, Display.INVALID_DISPLAY);
        if (c.mResources != null) {
            return c;
        }
    }
    throw new PackageManager.NameNotFoundException(""Application package "" + application.packageName + "" not found"");
}","{
    LoadedApk pi = mMainThread.getPackageInfo(application, mResources.getCompatibilityInfo(), flags | CONTEXT_REGISTER_PACKAGE);
    if (pi != null) {
        ContextImpl c = new ContextImpl(this, mMainThread, pi, null, mActivityToken, new UserHandle(UserHandle.getUserId(application.uid)), flags, null);
        final int displayId = mDisplay != null ? mDisplay.getDisplayId() : Display.DEFAULT_DISPLAY;
        c.setResources(createResources(mActivityToken, pi, null, displayId, null, getDisplayAdjustments(displayId).getCompatibilityInfo()));
        if (c.mResources != null) {
            return c;
        }
    }
    throw new PackageManager.NameNotFoundException(""Application package "" + application.packageName + "" not found"");
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,"There are changes to the ContextImpl constructor's arguments and the introduction of new method calls like createResources and getDisplayAdjustments, which indicates changes in control dependencies and other statements. So the change type is a combination of 1, 3, 4.","As the instantiation of 'ContextImpl' and creation of its 'Resources' have been changed, it may lead to a different Context being returned with potentially different Resources, so the CI type is 1."
354,"<android.widget.Toast: Toast makeText(Context,CharSequence,int)>",25,26,"<android.widget.Toast: Toast makeText(Context,CharSequence,int)>","<android.widget.Toast: Toast makeText(Context,CharSequence,int)>",0,"{
    Toast result = new Toast(context);
    LayoutInflater inflate = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    View v = inflate.inflate(com.android.internal.R.layout.transient_notification, null);
    TextView tv = (TextView) v.findViewById(com.android.internal.R.id.message);
    tv.setText(text);
    result.mNextView = v;
    result.mDuration = duration;
    return result;
}","{
    return makeText(context, null, text, duration);
}",1,"/**
 * Make a standard toast that just contains a text view.
 *
 * @param context  The context to use.  Usually your {@link android.app.Application}
 * or {@link android.app.Activity} object.
 * @param text     The text to show.  Can be formatted text.
 * @param duration How long to display the message.  Either {@link #LENGTH_SHORT} or
 * {@link #LENGTH_LONG}
 */
","/**
 * Make a standard toast that just contains a text view.
 *
 * @param context  The context to use.  Usually your {@link android.app.Application}
 * or {@link android.app.Activity} object.
 * @param text     The text to show.  Can be formatted text.
 * @param duration How long to display the message.  Either {@link #LENGTH_SHORT} or
 * {@link #LENGTH_LONG}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The early version directly creates and returns a new Toast object with specified configuration, while the late version delegates the creation to another overloaded makeText method. The return statement has been changed, and this also indicates a dependent API changed (5), which is the overload of the makeText method being called in the late version.","Since the implementation in the late version is delegating to a different method, there's a potential Compatibility Issue due to dependency on how that method constructs and returns the Toast. Therefore, the CI type is 1, indicating that the return value may be different depending on the implementation of the overloaded method."
355,"<android.app.ContextImpl: void sendOrderedBroadcastAsUser(Intent,UserHandle,String,int,Bundle,BroadcastReceiver,Handler,int,String,Bundle)>",25,26,"<android.app.ContextImpl: void sendOrderedBroadcastAsUser(Intent,UserHandle,String,int,Bundle,BroadcastReceiver,Handler,int,String,Bundle)>","<android.app.ContextImpl: void sendOrderedBroadcastAsUser(Intent,UserHandle,String,int,Bundle,BroadcastReceiver,Handler,int,String,Bundle)>",0,"{
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, rd, initialCode, initialData, initialExtras, receiverPermissions, appOp, options, true, false, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, rd, initialCode, initialData, initialExtras, receiverPermissions, appOp, options, true, false, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The dependent API used within the method has changed: `ActivityManagerNative.getDefault().broadcastIntent(...)` has been replaced with `ActivityManager.getService().broadcastIntent(...)`. Thus, the code change is of type 5.","There doesn't seem to be an observable Compatibility Issue here as the replacement seems to be an internal implementation detail and its signature and expected behavior remain unchanged. Therefore, no CI has been detected."
356,<android.app.ActivityTransitionCoordinator: void scheduleSetSharedElementEnd(ArrayList<View>)>,25,26,<android.app.ActivityTransitionCoordinator: void scheduleSetSharedElementEnd(ArrayList<View>)>,<android.app.ActivityTransitionCoordinator: void scheduleSetSharedElementEnd(ArrayList<View>)>,0,"{
    final View decorView = getDecor();
    if (decorView != null) {
        decorView.getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {

            @Override
            public boolean onPreDraw() {
                decorView.getViewTreeObserver().removeOnPreDrawListener(this);
                notifySharedElementEnd(snapshots);
                return true;
            }
        });
    }
}","{
    final View decorView = getDecor();
    if (decorView != null) {
        OneShotPreDrawListener.add(decorView, () -> {
            notifySharedElementEnd(snapshots);
        });
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation of adding an OnPreDrawListener has changed to use OneShotPreDrawListener.add, which is a different class/method, so the change type is 4 (Other statement changed) and 5 (Dependent API changed).","The change in the method of adding a pre-draw listener does not affect the eventual behavior of scheduling the end of shared element transitions, as the listener's task (calling notifySharedElementEnd) remains the same. Hence, there is no Compatibility Issue (CI type is 0)."
358,<android.app.Activity: void stopLockTask()>,25,26,<android.app.Activity: void stopLockTask()>,<android.app.Activity: void stopLockTask()>,0,"{
    try {
        ActivityManagerNative.getDefault().stopLockTaskMode();
    } catch (RemoteException e) {
    }
}","{
    try {
        ActivityManager.getService().stopLockTaskMode();
    } catch (RemoteException e) {
    }
}",1,"/**
 * Allow the user to switch away from the current task.
 *
 * Called to end the mode started by {@link Activity#startLockTask}. This
 * can only be called by activities that have successfully called
 * startLockTask previously.
 *
 * This will allow the user to exit this app and move onto other activities.
 * <p>Note: This method should only be called when the activity is user-facing. That is,
 * between onResume() and onPause().
 * <p>Note: If there are other tasks below this one that are also locked then calling this
 * method will immediately finish this task and resume the previous locked one, remaining in
 * lockTask mode.
 *
 * @see android.R.attr#lockTaskMode
 * @see ActivityManager#getLockTaskModeState()
 */
","/**
 * Allow the user to switch away from the current task.
 *
 * Called to end the mode started by {@link Activity#startLockTask}. This
 * can only be called by activities that have successfully called
 * startLockTask previously.
 *
 * This will allow the user to exit this app and move onto other activities.
 * <p>Note: This method should only be called when the activity is user-facing. That is,
 * between onResume() and onPause().
 * <p>Note: If there are other tasks below this one that are also locked then calling this
 * method will immediately finish this task and resume the previous locked one, remaining in
 * lockTask mode.
 *
 * @see android.R.attr#lockTaskMode
 * @see ActivityManager#getLockTaskModeState()
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"There's a change in the method invoked to stop lock task mode: from ActivityManagerNative.getDefault().stopLockTaskMode() to ActivityManager.getService().stopLockTaskMode(). This indicates the change type is 4,5 (Other statement changed, Dependent API changed).","The method to stop the lock task mode has been changed, however, the behaviour and the exception handling of the API remain the same. All exceptions are caught and no action is taken, therefore, there's no Compatibility Issue with respect to change in return value or exception handling. The Compatibility Issue situation is 0 (No Compatibility Issue)."
362,<android.hardware.display.DisplayManagerInternal.DisplayPowerRequest: boolean equals(DisplayPowerRequest)>,25,26,<android.hardware.display.DisplayManagerInternal.DisplayPowerRequest: boolean equals(DisplayPowerRequest)>,<android.hardware.display.DisplayManagerInternal.DisplayPowerRequest: boolean equals(DisplayPowerRequest)>,0,"{
    return other != null && policy == other.policy && useProximitySensor == other.useProximitySensor && screenBrightness == other.screenBrightness && screenAutoBrightnessAdjustment == other.screenAutoBrightnessAdjustment && brightnessSetByUser == other.brightnessSetByUser && useAutoBrightness == other.useAutoBrightness && blockScreenOn == other.blockScreenOn && lowPowerMode == other.lowPowerMode && boostScreenBrightness == other.boostScreenBrightness && dozeScreenBrightness == other.dozeScreenBrightness && dozeScreenState == other.dozeScreenState && useTwilight == other.useTwilight;
}","{
    return other != null && policy == other.policy && useProximitySensor == other.useProximitySensor && screenBrightness == other.screenBrightness && screenAutoBrightnessAdjustment == other.screenAutoBrightnessAdjustment && screenLowPowerBrightnessFactor == other.screenLowPowerBrightnessFactor && brightnessSetByUser == other.brightnessSetByUser && useAutoBrightness == other.useAutoBrightness && blockScreenOn == other.blockScreenOn && lowPowerMode == other.lowPowerMode && boostScreenBrightness == other.boostScreenBrightness && dozeScreenBrightness == other.dozeScreenBrightness && dozeScreenState == other.dozeScreenState;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The code change involves modifying the return statement by removing the check for 'useTwilight' and adding 'screenLowPowerBrightnessFactor == other.screenLowPowerBrightnessFactor', which indicates that both return statement and other statements have changed. Therefore, the change types are 1 and 4.","Since the conditions checked in the return statement have been altered, the return value of the method could potentially differ between the two versions if the states of the newly added or removed fields differ. Thus, a CI due to potentially different return values arises. Therefore, the CI type is 1."
363,<android.app.SystemServiceRegistry.StaticApplicationContextServiceFetcher: T getService(ContextImpl)>,25,26,<android.app.SystemServiceRegistry.StaticApplicationContextServiceFetcher: T getService(ContextImpl)>,<android.app.SystemServiceRegistry.StaticApplicationContextServiceFetcher: T getService(ContextImpl)>,0,"{
    synchronized (StaticApplicationContextServiceFetcher.this) {
        if (mCachedInstance == null) {
            Context appContext = ctx.getApplicationContext();
            // If the application context is null, we're either in the system process or
            // it's the application context very early in app initialization. In both these
            // cases, the passed-in ContextImpl will not be freed, so it's safe to pass it
            // to the service. http://b/27532714 .
            mCachedInstance = createService(appContext != null ? appContext : ctx);
        }
        return mCachedInstance;
    }
}","{
    synchronized (StaticApplicationContextServiceFetcher.this) {
        if (mCachedInstance == null) {
            Context appContext = ctx.getApplicationContext();
            // to the service. http://b/27532714 .
            try {
                mCachedInstance = createService(appContext != null ? appContext : ctx);
            } catch (ServiceNotFoundException e) {
                onServiceNotFound(e);
            }
        }
        return mCachedInstance;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,2","1,2","The late implementation introduces a try-catch block around the createService call, which could throw a ServiceNotFoundException, and an exception handling method onServiceNotFound(e) is called in the catch block. So, the change type includes both exception handling statement changed (2) and other statement changed (4) due to the addition of the try-catch block.","Since the late version includes a new try-catch block that handles a specific exception (ServiceNotFoundException) that was not present in the early version, the late version of the API could potentially throw a different exception (by calling onServiceNotFound within the catch block). This results in a potential CI with different exception handling (2). Additionally, if onServiceNotFound modifies the state or has other side effects, it could also lead to different return values, contributing to a CI with different return values or types (1)."
364,<android.service.voice.VoiceInteractionSession: Dialog getWindow()>,25,26,<android.service.voice.VoiceInteractionSession: Dialog getWindow()>,<android.service.voice.VoiceInteractionSession: Dialog getWindow()>,0,"{
    return mWindow;
}","{
    ensureWindowCreated();
    return mWindow;
}",1,"/**
 * Retrieve the window being used to show the session's UI.
 */
","/**
 * Retrieve the window being used to show the session's UI.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"An extra method call ensureWindowCreated() has been introduced before the return statement, so the change type is 4.","The addition of ensureWindowCreated() before returning mWindow does not change the variable being returned or introduce new exception handling; therefore, there is no compatibility issue, and the CI type is 0."
366,"<android.os.RecoverySystem: void verifyPackage(File,ProgressListener,File)>",25,26,"<android.os.RecoverySystem: void verifyPackage(File,ProgressListener,File)>","<android.os.RecoverySystem: void verifyPackage(File,ProgressListener,File)>",0,"{
    final long fileLen = packageFile.length();
    final RandomAccessFile raf = new RandomAccessFile(packageFile, ""r"");
    try {
        final long startTimeMillis = System.currentTimeMillis();
        if (listener != null) {
            listener.onProgress(0);
        }
        raf.seek(fileLen - 6);
        byte[] footer = new byte[6];
        raf.readFully(footer);
        if (footer[2] != (byte) 0xff || footer[3] != (byte) 0xff) {
            throw new SignatureException(""no signature in file (no footer)"");
        }
        final int commentSize = (footer[4] & 0xff) | ((footer[5] & 0xff) << 8);
        final int signatureStart = (footer[0] & 0xff) | ((footer[1] & 0xff) << 8);
        byte[] eocd = new byte[commentSize + 22];
        raf.seek(fileLen - (commentSize + 22));
        raf.readFully(eocd);
        // end-of-central-directory record.
        if (eocd[0] != (byte) 0x50 || eocd[1] != (byte) 0x4b || eocd[2] != (byte) 0x05 || eocd[3] != (byte) 0x06) {
            throw new SignatureException(""no signature in file (bad footer)"");
        }
        for (int i = 4; i < eocd.length - 3; ++i) {
            if (eocd[i] == (byte) 0x50 && eocd[i + 1] == (byte) 0x4b && eocd[i + 2] == (byte) 0x05 && eocd[i + 3] == (byte) 0x06) {
                throw new SignatureException(""EOCD marker found after start of EOCD"");
            }
        }
        // Parse the signature
        PKCS7 block = new PKCS7(new ByteArrayInputStream(eocd, commentSize + 22 - signatureStart, signatureStart));
        // Take the first certificate from the signature (packages
        // should contain only one).
        X509Certificate[] certificates = block.getCertificates();
        if (certificates == null || certificates.length == 0) {
            throw new SignatureException(""signature contains no certificates"");
        }
        X509Certificate cert = certificates[0];
        PublicKey signatureKey = cert.getPublicKey();
        SignerInfo[] signerInfos = block.getSignerInfos();
        if (signerInfos == null || signerInfos.length == 0) {
            throw new SignatureException(""signature contains no signedData"");
        }
        SignerInfo signerInfo = signerInfos[0];
        // Check that the public key of the certificate contained
        // in the package equals one of our trusted public keys.
        boolean verified = false;
        HashSet<X509Certificate> trusted = getTrustedCerts(deviceCertsZipFile == null ? DEFAULT_KEYSTORE : deviceCertsZipFile);
        for (X509Certificate c : trusted) {
            if (c.getPublicKey().equals(signatureKey)) {
                verified = true;
                break;
            }
        }
        if (!verified) {
            throw new SignatureException(""signature doesn't match any trusted key"");
        }
        // The signature cert matches a trusted key.  Now verify that
        // the digest in the cert matches the actual file data.
        raf.seek(0);
        final ProgressListener listenerForInner = listener;
        SignerInfo verifyResult = block.verify(signerInfo, new InputStream() {

            // The signature covers all of the OTA package except the
            // archive comment and its 2-byte length.
            long toRead = fileLen - commentSize - 2;

            long soFar = 0;

            int lastPercent = 0;

            long lastPublishTime = startTimeMillis;

            @Override
            public int read() throws IOException {
                throw new UnsupportedOperationException();
            }

            @Override
            public int read(byte[] b, int off, int len) throws IOException {
                if (soFar >= toRead) {
                    return -1;
                }
                if (Thread.currentThread().isInterrupted()) {
                    return -1;
                }
                int size = len;
                if (soFar + size > toRead) {
                    size = (int) (toRead - soFar);
                }
                int read = raf.read(b, off, size);
                soFar += read;
                if (listenerForInner != null) {
                    long now = System.currentTimeMillis();
                    int p = (int) (soFar * 100 / toRead);
                    if (p > lastPercent && now - lastPublishTime > PUBLISH_PROGRESS_INTERVAL_MS) {
                        lastPercent = p;
                        lastPublishTime = now;
                        listenerForInner.onProgress(lastPercent);
                    }
                }
                return read;
            }
        });
        final boolean interrupted = Thread.interrupted();
        if (listener != null) {
            listener.onProgress(100);
        }
        if (interrupted) {
            throw new SignatureException(""verification was interrupted"");
        }
        if (verifyResult == null) {
            throw new SignatureException(""signature digest verification failed"");
        }
    } finally {
        raf.close();
    }
}","{
    final long fileLen = packageFile.length();
    final RandomAccessFile raf = new RandomAccessFile(packageFile, ""r"");
    try {
        final long startTimeMillis = System.currentTimeMillis();
        if (listener != null) {
            listener.onProgress(0);
        }
        raf.seek(fileLen - 6);
        byte[] footer = new byte[6];
        raf.readFully(footer);
        if (footer[2] != (byte) 0xff || footer[3] != (byte) 0xff) {
            throw new SignatureException(""no signature in file (no footer)"");
        }
        final int commentSize = (footer[4] & 0xff) | ((footer[5] & 0xff) << 8);
        final int signatureStart = (footer[0] & 0xff) | ((footer[1] & 0xff) << 8);
        byte[] eocd = new byte[commentSize + 22];
        raf.seek(fileLen - (commentSize + 22));
        raf.readFully(eocd);
        // end-of-central-directory record.
        if (eocd[0] != (byte) 0x50 || eocd[1] != (byte) 0x4b || eocd[2] != (byte) 0x05 || eocd[3] != (byte) 0x06) {
            throw new SignatureException(""no signature in file (bad footer)"");
        }
        for (int i = 4; i < eocd.length - 3; ++i) {
            if (eocd[i] == (byte) 0x50 && eocd[i + 1] == (byte) 0x4b && eocd[i + 2] == (byte) 0x05 && eocd[i + 3] == (byte) 0x06) {
                throw new SignatureException(""EOCD marker found after start of EOCD"");
            }
        }
        // Parse the signature
        PKCS7 block = new PKCS7(new ByteArrayInputStream(eocd, commentSize + 22 - signatureStart, signatureStart));
        // Take the first certificate from the signature (packages
        // should contain only one).
        X509Certificate[] certificates = block.getCertificates();
        if (certificates == null || certificates.length == 0) {
            throw new SignatureException(""signature contains no certificates"");
        }
        X509Certificate cert = certificates[0];
        PublicKey signatureKey = cert.getPublicKey();
        SignerInfo[] signerInfos = block.getSignerInfos();
        if (signerInfos == null || signerInfos.length == 0) {
            throw new SignatureException(""signature contains no signedData"");
        }
        SignerInfo signerInfo = signerInfos[0];
        // Check that the public key of the certificate contained
        // in the package equals one of our trusted public keys.
        boolean verified = false;
        HashSet<X509Certificate> trusted = getTrustedCerts(deviceCertsZipFile == null ? DEFAULT_KEYSTORE : deviceCertsZipFile);
        for (X509Certificate c : trusted) {
            if (c.getPublicKey().equals(signatureKey)) {
                verified = true;
                break;
            }
        }
        if (!verified) {
            throw new SignatureException(""signature doesn't match any trusted key"");
        }
        // The signature cert matches a trusted key.  Now verify that
        // the digest in the cert matches the actual file data.
        raf.seek(0);
        final ProgressListener listenerForInner = listener;
        SignerInfo verifyResult = block.verify(signerInfo, new InputStream() {

            // The signature covers all of the OTA package except the
            // archive comment and its 2-byte length.
            long toRead = fileLen - commentSize - 2;

            long soFar = 0;

            int lastPercent = 0;

            long lastPublishTime = startTimeMillis;

            @Override
            public int read() throws IOException {
                throw new UnsupportedOperationException();
            }

            @Override
            public int read(byte[] b, int off, int len) throws IOException {
                if (soFar >= toRead) {
                    return -1;
                }
                if (Thread.currentThread().isInterrupted()) {
                    return -1;
                }
                int size = len;
                if (soFar + size > toRead) {
                    size = (int) (toRead - soFar);
                }
                int read = raf.read(b, off, size);
                soFar += read;
                if (listenerForInner != null) {
                    long now = System.currentTimeMillis();
                    int p = (int) (soFar * 100 / toRead);
                    if (p > lastPercent && now - lastPublishTime > PUBLISH_PROGRESS_INTERVAL_MS) {
                        lastPercent = p;
                        lastPublishTime = now;
                        listenerForInner.onProgress(lastPercent);
                    }
                }
                return read;
            }
        });
        final boolean interrupted = Thread.interrupted();
        if (listener != null) {
            listener.onProgress(100);
        }
        if (interrupted) {
            throw new SignatureException(""verification was interrupted"");
        }
        if (verifyResult == null) {
            throw new SignatureException(""signature digest verification failed"");
        }
    } finally {
        raf.close();
    }
    // Additionally verify the package compatibility.
    if (!readAndVerifyPackageCompatibilityEntry(packageFile)) {
        throw new SignatureException(""package compatibility verification failed"");
    }
}",1,"/**
 * Verify the cryptographic signature of a system update package
 * before installing it.  Note that the package is also verified
 * separately by the installer once the device is rebooted into
 * the recovery system.  This function will return only if the
 * package was successfully verified; otherwise it will throw an
 * exception.
 *
 * Verification of a package can take significant time, so this
 * function should not be called from a UI thread.  Interrupting
 * the thread while this function is in progress will result in a
 * SecurityException being thrown (and the thread's interrupt flag
 * will be cleared).
 *
 * @param packageFile  the package to be verified
 * @param listener     an object to receive periodic progress
 * updates as verification proceeds.  May be null.
 * @param deviceCertsZipFile  the zip file of certificates whose
 * public keys we will accept.  Verification succeeds if the
 * package is signed by the private key corresponding to any
 * public key in this file.  May be null to use the system default
 * file (currently ""/system/etc/security/otacerts.zip"").
 *
 * @throws IOException if there were any errors reading the
 * package or certs files.
 * @throws GeneralSecurityException if verification failed
 */
","/**
 * Verify the cryptographic signature of a system update package
 * before installing it.  Note that the package is also verified
 * separately by the installer once the device is rebooted into
 * the recovery system.  This function will return only if the
 * package was successfully verified; otherwise it will throw an
 * exception.
 *
 * Verification of a package can take significant time, so this
 * function should not be called from a UI thread.  Interrupting
 * the thread while this function is in progress will result in a
 * SecurityException being thrown (and the thread's interrupt flag
 * will be cleared).
 *
 * @param packageFile  the package to be verified
 * @param listener     an object to receive periodic progress
 * updates as verification proceeds.  May be null.
 * @param deviceCertsZipFile  the zip file of certificates whose
 * public keys we will accept.  Verification succeeds if the
 * package is signed by the private key corresponding to any
 * public key in this file.  May be null to use the system default
 * file (currently ""/system/etc/security/otacerts.zip"").
 *
 * @throws IOException if there were any errors reading the
 * package or certs files.
 * @throws GeneralSecurityException if verification failed
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
367,"<android.text.method.LinkMovementMethod: boolean onTouchEvent(TextView,Spannable,MotionEvent)>",25,26,"<android.text.method.LinkMovementMethod: boolean onTouchEvent(TextView,Spannable,MotionEvent)>","<android.text.method.LinkMovementMethod: boolean onTouchEvent(TextView,Spannable,MotionEvent)>",0,"{
    int action = event.getAction();
    if (action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_DOWN) {
        int x = (int) event.getX();
        int y = (int) event.getY();
        x -= widget.getTotalPaddingLeft();
        y -= widget.getTotalPaddingTop();
        x += widget.getScrollX();
        y += widget.getScrollY();
        Layout layout = widget.getLayout();
        int line = layout.getLineForVertical(y);
        int off = layout.getOffsetForHorizontal(line, x);
        ClickableSpan[] link = buffer.getSpans(off, off, ClickableSpan.class);
        if (link.length != 0) {
            if (action == MotionEvent.ACTION_UP) {
                link[0].onClick(widget);
            } else if (action == MotionEvent.ACTION_DOWN) {
                Selection.setSelection(buffer, buffer.getSpanStart(link[0]), buffer.getSpanEnd(link[0]));
            }
            return true;
        } else {
            Selection.removeSelection(buffer);
        }
    }
    return super.onTouchEvent(widget, buffer, event);
}","{
    int action = event.getAction();
    if (action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_DOWN) {
        int x = (int) event.getX();
        int y = (int) event.getY();
        x -= widget.getTotalPaddingLeft();
        y -= widget.getTotalPaddingTop();
        x += widget.getScrollX();
        y += widget.getScrollY();
        Layout layout = widget.getLayout();
        int line = layout.getLineForVertical(y);
        int off = layout.getOffsetForHorizontal(line, x);
        ClickableSpan[] links = buffer.getSpans(off, off, ClickableSpan.class);
        if (links.length != 0) {
            if (action == MotionEvent.ACTION_UP) {
                links[0].onClick(widget);
            } else if (action == MotionEvent.ACTION_DOWN) {
                Selection.setSelection(buffer, buffer.getSpanStart(links[0]), buffer.getSpanEnd(links[0]));
            }
            return true;
        } else {
            Selection.removeSelection(buffer);
        }
    }
    return super.onTouchEvent(widget, buffer, event);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,0,0,"There is only a difference in the name of the variable (from ""link"" to ""links"") which does not affect the functionality, actual implementation logic, or the control flow of the method; thus there is no code change in terms of behaviour.","Since the renaming of the variable does not change the behavior of the code, there is no Compatibility Issue between these two versions of the method."
369,"<android.service.notification.NotificationListenerService.RankingMap: boolean getRanking(String,Ranking)>",25,26,"<android.service.notification.NotificationListenerService.RankingMap: boolean getRanking(String,Ranking)>","<android.service.notification.NotificationListenerService.RankingMap: boolean getRanking(String,Ranking)>",0,"{
    int rank = getRank(key);
    outRanking.populate(key, rank, !isIntercepted(key), getVisibilityOverride(key), getSuppressedVisualEffects(key), getImportance(key), getImportanceExplanation(key), getOverrideGroupKey(key));
    return rank >= 0;
}","{
    int rank = getRank(key);
    outRanking.populate(key, rank, !isIntercepted(key), getVisibilityOverride(key), getSuppressedVisualEffects(key), getImportance(key), getImportanceExplanation(key), getOverrideGroupKey(key), getChannel(key), getOverridePeople(key), getSnoozeCriteria(key), getShowBadge(key));
    return rank >= 0;
}",1,"/**
 * Populates outRanking with ranking information for the notification
 * with the given key.
 *
 * @return true if a valid key has been passed and outRanking has
 * been populated; false otherwise
 */
","/**
 * Populates outRanking with ranking information for the notification
 * with the given key.
 *
 * @return true if a valid key has been passed and outRanking has
 * been populated; false otherwise
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method outRanking.populate() is called with additional parameters in the new version. This means there is a change in the implementation details, but the method signature and the return statement remain unchanged.","There is no compatibility issue as the return value for the API method remains conditioned upon 'rank >= 0' which is unchanged between the early and late versions. Despite the extra parameters being used in the method call, how the result is calculated and returned by 'getRanking' itself does not change, meaning the API behaves the same way from the caller's perspective."
370,<android.widget.Editor.EditOperation: void forceMergeWith(EditOperation)>,25,26,<android.widget.Editor.EditOperation: void forceMergeWith(EditOperation)>,<android.widget.Editor.EditOperation: void forceMergeWith(EditOperation)>,0,"{
    if (DEBUG_UNDO)
        Log.d(TAG, ""forceMerge"");
    Editor editor = getOwnerData();
    // Copy the text of the current field.
    // NOTE: Using StringBuilder instead of SpannableStringBuilder would be somewhat faster,
    // but would require two parallel implementations of modifyText() because Editable and
    // StringBuilder do not share an interface for replace/delete/insert.
    Editable editable = (Editable) editor.mTextView.getText();
    Editable originalText = new SpannableStringBuilder(editable.toString());
    // Roll back the last operation.
    modifyText(originalText, mNewTextStart, getNewTextEnd(), mOldText, mOldTextStart, mOldCursorPos);
    // Clone the text again and apply the new operation.
    Editable finalText = new SpannableStringBuilder(editable.toString());
    modifyText(finalText, edit.mOldTextStart, edit.getOldTextEnd(), edit.mNewText, edit.mNewTextStart, edit.mNewCursorPos);
    // Convert this operation into a non-mergeable replacement of the entire string.
    mType = TYPE_REPLACE;
    mNewText = finalText.toString();
    mNewTextStart = 0;
    mOldText = originalText.toString();
    mOldTextStart = 0;
    mNewCursorPos = edit.mNewCursorPos;
// mOldCursorPos is unchanged.
}","{
    if (DEBUG_UNDO)
        Log.d(TAG, ""forceMerge"");
    if (mergeWith(edit)) {
        return;
    }
    Editor editor = getOwnerData();
    // Copy the text of the current field.
    // NOTE: Using StringBuilder instead of SpannableStringBuilder would be somewhat faster,
    // but would require two parallel implementations of modifyText() because Editable and
    // StringBuilder do not share an interface for replace/delete/insert.
    Editable editable = (Editable) editor.mTextView.getText();
    Editable originalText = new SpannableStringBuilder(editable.toString());
    // Roll back the last operation.
    modifyText(originalText, mStart, getNewTextEnd(), mOldText, mStart, mOldCursorPos);
    // Clone the text again and apply the new operation.
    Editable finalText = new SpannableStringBuilder(editable.toString());
    modifyText(finalText, edit.mStart, edit.getOldTextEnd(), edit.mNewText, edit.mStart, edit.mNewCursorPos);
    // Convert this operation into a replace operation.
    mType = TYPE_REPLACE;
    mNewText = finalText.toString();
    mOldText = originalText.toString();
    mStart = 0;
    mNewCursorPos = edit.mNewCursorPos;
    mIsComposition = edit.mIsComposition;
// mOldCursorPos is unchanged.
}",1,"/**
 * Forcibly creates a single merged edit operation by simulating the entire text
 * contents being replaced.
 */
","/**
 * Forcibly creates a single merged edit operation by simulating the entire text
 * contents being replaced.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The method implementation has introduced a new mergeWith() method call at the beginning of the method and changes from mNewTextStart and mOldTextStart to mStart and mIsComposition field which didn't exist before. Therefore, the change types are 3 and 4.","With the introduction of the mergeWith() method and the changes in which the text start positions are tracked, the end result text (mNewText and mOldText) has the potential to change, causing the API to have different behavior (different return value or side effect). Hence, the CI type is 1."
372,"<android.app.admin.DevicePolicyManager: boolean isApplicationHidden(ComponentName,String)>",25,26,"<android.app.admin.DevicePolicyManager: boolean isApplicationHidden(ComponentName,String)>","<android.app.admin.DevicePolicyManager: boolean isApplicationHidden(ComponentName,String)>",0,"{
    throwIfParentInstance(""isApplicationHidden"");
    if (mService != null) {
        try {
            return mService.isApplicationHidden(admin, packageName);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return false;
}","{
    throwIfParentInstance(""isApplicationHidden"");
    if (mService != null) {
        try {
            return mService.isApplicationHidden(admin, mContext.getPackageName(), packageName);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return false;
}",1,"/**
 * Called by profile or device owners to determine if a package is hidden.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param packageName The name of the package to retrieve the hidden status of.
 * @return boolean {@code true} if the package is hidden, {@code false} otherwise.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 */
","/**
 * Determine if a package is hidden. This function can be called by a device owner, profile
 * owner, or by a delegate given the {@link #DELEGATION_PACKAGE_ACCESS} scope via
 * {@link #setDelegatedScopes}.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or
 * {@code null} if the caller is a package access delegate.
 * @param packageName The name of the package to retrieve the hidden status of.
 * @return boolean {@code true} if the package is hidden, {@code false} otherwise.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 * @see #setDelegatedScopes
 * @see #DELEGATION_PACKAGE_ACCESS
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method `mService.isApplicationHidden` parameters have changed. An additional mContext.getPackageName() is added to the call in the late version. This change is a Dependent API change, so the code change type is 5.","The new parameter added to the method call (mContext.getPackageName()) does not lead to a change in the method's behavior because it is likely intended to provide additional context to the existing API call without altering its contract or functionality. Hence, there is no Compatibility Issue, and the CI type is 0."
373,<android.preference.Preference: int getPersistedInt(int)>,25,26,<android.preference.Preference: int getPersistedInt(int)>,<android.preference.Preference: int getPersistedInt(int)>,0,"{
    if (!shouldPersist()) {
        return defaultReturnValue;
    }
    return mPreferenceManager.getSharedPreferences().getInt(mKey, defaultReturnValue);
}","{
    if (!shouldPersist()) {
        return defaultReturnValue;
    }
    PreferenceDataStore dataStore = getPreferenceDataStore();
    if (dataStore != null) {
        return dataStore.getInt(mKey, defaultReturnValue);
    }
    return mPreferenceManager.getSharedPreferences().getInt(mKey, defaultReturnValue);
}",1,"/**
 * Attempts to get a persisted int from the {@link android.content.SharedPreferences}.
 *
 * @param defaultReturnValue The default value to return if either this
 * Preference is not persistent or this Preference is not in the
 * SharedPreferences.
 * @return The value from the SharedPreferences or the default return
 * value.
 * @see #getPersistedString(String)
 * @see #persistInt(int)
 */
","/**
 * Attempts to get a persisted int if this Preference is persistent.
 *
 * @param defaultReturnValue The default value to return if either this
 * Preference is not persistent or this Preference is not present.
 * @return The value from the data store or the default return
 * value.
 * @see #getPersistedString(String)
 * @see #persistInt(int)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,5",1,"The condition checking for a non-null data store and using it if available has been introduced, and the dependent API getPreferenceDataStore() is a new dependency, so the code change type is 3,5.","The potentially different source of data (dataStore vs. shared preferences) for persisted value retrieval implies the API could return different values due to the introduction of a new control dependency on the PreferenceDataStore, hence CI type 1."
374,<android.view.View: ViewTreeObserver getViewTreeObserver()>,25,26,<android.view.View: ViewTreeObserver getViewTreeObserver()>,<android.view.View: ViewTreeObserver getViewTreeObserver()>,0,"{
    if (mAttachInfo != null) {
        return mAttachInfo.mTreeObserver;
    }
    if (mFloatingTreeObserver == null) {
        mFloatingTreeObserver = new ViewTreeObserver();
    }
    return mFloatingTreeObserver;
}","{
    if (mAttachInfo != null) {
        return mAttachInfo.mTreeObserver;
    }
    if (mFloatingTreeObserver == null) {
        mFloatingTreeObserver = new ViewTreeObserver(mContext);
    }
    return mFloatingTreeObserver;
}",1,"/**
 * Returns the ViewTreeObserver for this view's hierarchy. The view tree
 * observer can be used to get notifications when global events, like
 * layout, happen.
 *
 * The returned ViewTreeObserver observer is not guaranteed to remain
 * valid for the lifetime of this View. If the caller of this method keeps
 * a long-lived reference to ViewTreeObserver, it should always check for
 * the return value of {@link ViewTreeObserver#isAlive()}.
 *
 * @return The ViewTreeObserver for this view's hierarchy.
 */
","/**
 * Returns the ViewTreeObserver for this view's hierarchy. The view tree
 * observer can be used to get notifications when global events, like
 * layout, happen.
 *
 * The returned ViewTreeObserver observer is not guaranteed to remain
 * valid for the lifetime of this View. If the caller of this method keeps
 * a long-lived reference to ViewTreeObserver, it should always check for
 * the return value of {@link ViewTreeObserver#isAlive()}.
 *
 * @return The ViewTreeObserver for this view's hierarchy.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"There is a new parameter added to the constructor of ViewTreeObserver in the condition where mFloatingTreeObserver is null. This change on the new object creation implies that a dependent API (ViewTreeObserver's constructor) has been changed, so the code change type is 4,5.","Despite the change in how the ViewTreeObserver instance is created (now with a context), since mFloatingTreeObserver is always returned when mAttachInfo is null and it's not affecting how exceptions are thrown or caught, there's no change in return variable or exception handling from the API perspective. The internal state of the ViewTreeObserver may be different due to the inclusion of the context, but as far as the outward behavior of the `getViewTreeObserver()` API is concerned, this is not causing a compatibility issue. Hence, no CI is detected."
375,<android.content.ClipDescription: boolean hasMimeType(String)>,25,26,<android.content.ClipDescription: boolean hasMimeType(String)>,<android.content.ClipDescription: boolean hasMimeType(String)>,0,"{
    for (int i = 0; i < mMimeTypes.length; i++) {
        if (compareMimeTypes(mMimeTypes[i], mimeType)) {
            return true;
        }
    }
    return false;
}","{
    final int size = mMimeTypes.size();
    for (int i = 0; i < size; i++) {
        if (compareMimeTypes(mMimeTypes.get(i), mimeType)) {
            return true;
        }
    }
    return false;
}",1,"/**
 * Check whether the clip description contains the given MIME type.
 *
 * @param mimeType The desired MIME type.  May be a pattern.
 * @return Returns true if one of the MIME types in the clip description
 * matches the desired MIME type, else false.
 */
","/**
 * Check whether the clip description contains the given MIME type.
 *
 * @param mimeType The desired MIME type.  May be a pattern.
 * @return Returns true if one of the MIME types in the clip description
 * matches the desired MIME type, else false.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,5",0,"The way of accessing mMimeTypes has changed from an array access to a List get method along with a variable pre-storing the size of the list; thus, the code change types are 3 (control dependency change) and 5 (dependent API changed due to the change in how the mMimeTypes are accessed).","While there is a change in the implementation, the semantics of the method remain unchanged between versions. The order of iteration and the comparison logic are the same; thus, there's no Compatibility Issue expected here."
376,<android.app.Notification.Builder: Builder setActions(Action)>,25,26,<android.app.Notification.Builder: Builder setActions(Action)>,<android.app.Notification.Builder: Builder setActions(Action)>,0,"{
    mActions.clear();
    for (int i = 0; i < actions.length; i++) {
        mActions.add(actions[i]);
    }
    return this;
}","{
    mActions.clear();
    for (int i = 0; i < actions.length; i++) {
        if (actions[i] != null) {
            mActions.add(actions[i]);
        }
    }
    return this;
}",1,"/**
 * Alter the complete list of actions attached to this notification.
 * @see #addAction(Action).
 *
 * @param actions
 * @return
 */
","/**
 * Alter the complete list of actions attached to this notification.
 * @see #addAction(Action).
 *
 * @param actions
 * @return
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The change is in the control dependency where an if condition is added to check if each action is not null before adding it to mActions. Therefore, the code change type is 3.","The addition of the null check before adding actions to mActions does not constitute a compatibility issue as it prevents potential null elements from being added. Existing functionality will not be affected by avoiding NullPointerExceptions, thus no CI is detected."
377,<android.app.ActivityThread.H: void handleMessage(Message)>,25,26,<android.app.ActivityThread.H: void handleMessage(Message)>,<android.app.ActivityThread.H: void handleMessage(Message)>,0,"{
    if (DEBUG_MESSAGES)
        Slog.v(TAG, "">>> handling: "" + codeToString(msg.what));
    switch(msg.what) {
        case LAUNCH_ACTIVITY:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityStart"");
                final ActivityClientRecord r = (ActivityClientRecord) msg.obj;
                r.packageInfo = getPackageInfoNoCheck(r.activityInfo.applicationInfo, r.compatInfo);
                handleLaunchActivity(r, null, ""LAUNCH_ACTIVITY"");
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case RELAUNCH_ACTIVITY:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityRestart"");
                ActivityClientRecord r = (ActivityClientRecord) msg.obj;
                handleRelaunchActivity(r);
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case PAUSE_ACTIVITY:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityPause"");
                SomeArgs args = (SomeArgs) msg.obj;
                handlePauseActivity((IBinder) args.arg1, false, (args.argi1 & USER_LEAVING) != 0, args.argi2, (args.argi1 & DONT_REPORT) != 0, args.argi3);
                maybeSnapshot();
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case PAUSE_ACTIVITY_FINISHING:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityPause"");
                SomeArgs args = (SomeArgs) msg.obj;
                handlePauseActivity((IBinder) args.arg1, true, (args.argi1 & USER_LEAVING) != 0, args.argi2, (args.argi1 & DONT_REPORT) != 0, args.argi3);
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case STOP_ACTIVITY_SHOW:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityStop"");
                SomeArgs args = (SomeArgs) msg.obj;
                handleStopActivity((IBinder) args.arg1, true, args.argi2, args.argi3);
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case STOP_ACTIVITY_HIDE:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityStop"");
                SomeArgs args = (SomeArgs) msg.obj;
                handleStopActivity((IBinder) args.arg1, false, args.argi2, args.argi3);
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case SHOW_WINDOW:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityShowWindow"");
            handleWindowVisibility((IBinder) msg.obj, true);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case HIDE_WINDOW:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityHideWindow"");
            handleWindowVisibility((IBinder) msg.obj, false);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case RESUME_ACTIVITY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityResume"");
            SomeArgs args = (SomeArgs) msg.obj;
            handleResumeActivity((IBinder) args.arg1, true, args.argi1 != 0, true, args.argi3, ""RESUME_ACTIVITY"");
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SEND_RESULT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityDeliverResult"");
            handleSendResult((ResultData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case DESTROY_ACTIVITY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityDestroy"");
            handleDestroyActivity((IBinder) msg.obj, msg.arg1 != 0, msg.arg2, false);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case BIND_APPLICATION:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""bindApplication"");
            AppBindData data = (AppBindData) msg.obj;
            handleBindApplication(data);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case EXIT_APPLICATION:
            if (mInitialApplication != null) {
                mInitialApplication.onTerminate();
            }
            Looper.myLooper().quit();
            break;
        case NEW_INTENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityNewIntent"");
            handleNewIntent((NewIntentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case RECEIVER:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastReceiveComp"");
            handleReceiver((ReceiverData) msg.obj);
            maybeSnapshot();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CREATE_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (""serviceCreate: "" + String.valueOf(msg.obj)));
            handleCreateService((CreateServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case BIND_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceBind"");
            handleBindService((BindServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UNBIND_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceUnbind"");
            handleUnbindService((BindServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SERVICE_ARGS:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (""serviceStart: "" + String.valueOf(msg.obj)));
            handleServiceArgs((ServiceArgsData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case STOP_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceStop"");
            handleStopService((IBinder) msg.obj);
            maybeSnapshot();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CONFIGURATION_CHANGED:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""configChanged"");
            mCurDefaultDisplayDpi = ((Configuration) msg.obj).densityDpi;
            mUpdatingSystemConfig = true;
            handleConfigurationChanged((Configuration) msg.obj, null);
            mUpdatingSystemConfig = false;
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CLEAN_UP_CONTEXT:
            ContextCleanupInfo cci = (ContextCleanupInfo) msg.obj;
            cci.context.performFinalCleanup(cci.who, cci.what);
            break;
        case GC_WHEN_IDLE:
            scheduleGcIdler();
            break;
        case DUMP_SERVICE:
            handleDumpService((DumpComponentInfo) msg.obj);
            break;
        case LOW_MEMORY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""lowMemory"");
            handleLowMemory();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case ACTIVITY_CONFIGURATION_CHANGED:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityConfigChanged"");
            handleActivityConfigurationChanged((ActivityConfigChangeData) msg.obj, msg.arg1 == 1 ? REPORT_TO_ACTIVITY : !REPORT_TO_ACTIVITY);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case PROFILER_CONTROL:
            handleProfilerControl(msg.arg1 != 0, (ProfilerInfo) msg.obj, msg.arg2);
            break;
        case CREATE_BACKUP_AGENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""backupCreateAgent"");
            handleCreateBackupAgent((CreateBackupAgentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case DESTROY_BACKUP_AGENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""backupDestroyAgent"");
            handleDestroyBackupAgent((CreateBackupAgentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SUICIDE:
            Process.killProcess(Process.myPid());
            break;
        case REMOVE_PROVIDER:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""providerRemove"");
            completeRemoveProvider((ProviderRefCount) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case ENABLE_JIT:
            ensureJitEnabled();
            break;
        case DISPATCH_PACKAGE_BROADCAST:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastPackage"");
            handleDispatchPackageBroadcast(msg.arg1, (String[]) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SCHEDULE_CRASH:
            throw new RemoteServiceException((String) msg.obj);
        case DUMP_HEAP:
            handleDumpHeap(msg.arg1 != 0, (DumpHeapData) msg.obj);
            break;
        case DUMP_ACTIVITY:
            handleDumpActivity((DumpComponentInfo) msg.obj);
            break;
        case DUMP_PROVIDER:
            handleDumpProvider((DumpComponentInfo) msg.obj);
            break;
        case SLEEPING:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""sleeping"");
            handleSleeping((IBinder) msg.obj, msg.arg1 != 0);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SET_CORE_SETTINGS:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""setCoreSettings"");
            handleSetCoreSettings((Bundle) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UPDATE_PACKAGE_COMPATIBILITY_INFO:
            handleUpdatePackageCompatibilityInfo((UpdateCompatibilityData) msg.obj);
            break;
        case TRIM_MEMORY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""trimMemory"");
            handleTrimMemory(msg.arg1);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UNSTABLE_PROVIDER_DIED:
            handleUnstableProviderDied((IBinder) msg.obj, false);
            break;
        case REQUEST_ASSIST_CONTEXT_EXTRAS:
            handleRequestAssistContextExtras((RequestAssistContextExtras) msg.obj);
            break;
        case TRANSLUCENT_CONVERSION_COMPLETE:
            handleTranslucentConversionComplete((IBinder) msg.obj, msg.arg1 == 1);
            break;
        case INSTALL_PROVIDER:
            handleInstallProvider((ProviderInfo) msg.obj);
            break;
        case ON_NEW_ACTIVITY_OPTIONS:
            Pair<IBinder, ActivityOptions> pair = (Pair<IBinder, ActivityOptions>) msg.obj;
            onNewActivityOptions(pair.first, pair.second);
            break;
        case CANCEL_VISIBLE_BEHIND:
            handleCancelVisibleBehind((IBinder) msg.obj);
            break;
        case BACKGROUND_VISIBLE_BEHIND_CHANGED:
            handleOnBackgroundVisibleBehindChanged((IBinder) msg.obj, msg.arg1 > 0);
            break;
        case ENTER_ANIMATION_COMPLETE:
            handleEnterAnimationComplete((IBinder) msg.obj);
            break;
        case START_BINDER_TRACKING:
            handleStartBinderTracking();
            break;
        case STOP_BINDER_TRACKING_AND_DUMP:
            handleStopBinderTrackingAndDump((ParcelFileDescriptor) msg.obj);
            break;
        case MULTI_WINDOW_MODE_CHANGED:
            handleMultiWindowModeChanged((IBinder) msg.obj, msg.arg1 == 1);
            break;
        case PICTURE_IN_PICTURE_MODE_CHANGED:
            handlePictureInPictureModeChanged((IBinder) msg.obj, msg.arg1 == 1);
            break;
        case LOCAL_VOICE_INTERACTION_STARTED:
            handleLocalVoiceInteractionStarted((IBinder) ((SomeArgs) msg.obj).arg1, (IVoiceInteractor) ((SomeArgs) msg.obj).arg2);
            break;
    }
    Object obj = msg.obj;
    if (obj instanceof SomeArgs) {
        ((SomeArgs) obj).recycle();
    }
    if (DEBUG_MESSAGES)
        Slog.v(TAG, ""<<< done: "" + codeToString(msg.what));
}","{
    if (DEBUG_MESSAGES)
        Slog.v(TAG, "">>> handling: "" + codeToString(msg.what));
    switch(msg.what) {
        case LAUNCH_ACTIVITY:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityStart"");
                final ActivityClientRecord r = (ActivityClientRecord) msg.obj;
                r.packageInfo = getPackageInfoNoCheck(r.activityInfo.applicationInfo, r.compatInfo);
                handleLaunchActivity(r, null, ""LAUNCH_ACTIVITY"");
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case RELAUNCH_ACTIVITY:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityRestart"");
                ActivityClientRecord r = (ActivityClientRecord) msg.obj;
                handleRelaunchActivity(r);
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case PAUSE_ACTIVITY:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityPause"");
                SomeArgs args = (SomeArgs) msg.obj;
                handlePauseActivity((IBinder) args.arg1, false, (args.argi1 & USER_LEAVING) != 0, args.argi2, (args.argi1 & DONT_REPORT) != 0, args.argi3);
                maybeSnapshot();
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case PAUSE_ACTIVITY_FINISHING:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityPause"");
                SomeArgs args = (SomeArgs) msg.obj;
                handlePauseActivity((IBinder) args.arg1, true, (args.argi1 & USER_LEAVING) != 0, args.argi2, (args.argi1 & DONT_REPORT) != 0, args.argi3);
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case STOP_ACTIVITY_SHOW:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityStop"");
                SomeArgs args = (SomeArgs) msg.obj;
                handleStopActivity((IBinder) args.arg1, true, args.argi2, args.argi3);
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case STOP_ACTIVITY_HIDE:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityStop"");
                SomeArgs args = (SomeArgs) msg.obj;
                handleStopActivity((IBinder) args.arg1, false, args.argi2, args.argi3);
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case SHOW_WINDOW:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityShowWindow"");
            handleWindowVisibility((IBinder) msg.obj, true);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case HIDE_WINDOW:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityHideWindow"");
            handleWindowVisibility((IBinder) msg.obj, false);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case RESUME_ACTIVITY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityResume"");
            SomeArgs args = (SomeArgs) msg.obj;
            handleResumeActivity((IBinder) args.arg1, true, args.argi1 != 0, true, args.argi3, ""RESUME_ACTIVITY"");
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SEND_RESULT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityDeliverResult"");
            handleSendResult((ResultData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case DESTROY_ACTIVITY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityDestroy"");
            handleDestroyActivity((IBinder) msg.obj, msg.arg1 != 0, msg.arg2, false);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case BIND_APPLICATION:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""bindApplication"");
            AppBindData data = (AppBindData) msg.obj;
            handleBindApplication(data);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case EXIT_APPLICATION:
            if (mInitialApplication != null) {
                mInitialApplication.onTerminate();
            }
            Looper.myLooper().quit();
            break;
        case NEW_INTENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityNewIntent"");
            handleNewIntent((NewIntentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case RECEIVER:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastReceiveComp"");
            handleReceiver((ReceiverData) msg.obj);
            maybeSnapshot();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CREATE_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (""serviceCreate: "" + String.valueOf(msg.obj)));
            handleCreateService((CreateServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case BIND_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceBind"");
            handleBindService((BindServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UNBIND_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceUnbind"");
            handleUnbindService((BindServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SERVICE_ARGS:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (""serviceStart: "" + String.valueOf(msg.obj)));
            handleServiceArgs((ServiceArgsData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case STOP_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceStop"");
            handleStopService((IBinder) msg.obj);
            maybeSnapshot();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CONFIGURATION_CHANGED:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""configChanged"");
            mCurDefaultDisplayDpi = ((Configuration) msg.obj).densityDpi;
            mUpdatingSystemConfig = true;
            try {
                handleConfigurationChanged((Configuration) msg.obj, null);
            } finally {
                mUpdatingSystemConfig = false;
            }
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CLEAN_UP_CONTEXT:
            ContextCleanupInfo cci = (ContextCleanupInfo) msg.obj;
            cci.context.performFinalCleanup(cci.who, cci.what);
            break;
        case GC_WHEN_IDLE:
            scheduleGcIdler();
            break;
        case DUMP_SERVICE:
            handleDumpService((DumpComponentInfo) msg.obj);
            break;
        case LOW_MEMORY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""lowMemory"");
            handleLowMemory();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case ACTIVITY_CONFIGURATION_CHANGED:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityConfigChanged"");
            handleActivityConfigurationChanged((ActivityConfigChangeData) msg.obj, INVALID_DISPLAY);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case ACTIVITY_MOVED_TO_DISPLAY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityMovedToDisplay"");
            handleActivityConfigurationChanged((ActivityConfigChangeData) msg.obj, msg.arg1);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case PROFILER_CONTROL:
            handleProfilerControl(msg.arg1 != 0, (ProfilerInfo) msg.obj, msg.arg2);
            break;
        case CREATE_BACKUP_AGENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""backupCreateAgent"");
            handleCreateBackupAgent((CreateBackupAgentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case DESTROY_BACKUP_AGENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""backupDestroyAgent"");
            handleDestroyBackupAgent((CreateBackupAgentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SUICIDE:
            Process.killProcess(Process.myPid());
            break;
        case REMOVE_PROVIDER:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""providerRemove"");
            completeRemoveProvider((ProviderRefCount) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case ENABLE_JIT:
            ensureJitEnabled();
            break;
        case DISPATCH_PACKAGE_BROADCAST:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastPackage"");
            handleDispatchPackageBroadcast(msg.arg1, (String[]) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SCHEDULE_CRASH:
            throw new RemoteServiceException((String) msg.obj);
        case DUMP_HEAP:
            handleDumpHeap(msg.arg1 != 0, (DumpHeapData) msg.obj);
            break;
        case DUMP_ACTIVITY:
            handleDumpActivity((DumpComponentInfo) msg.obj);
            break;
        case DUMP_PROVIDER:
            handleDumpProvider((DumpComponentInfo) msg.obj);
            break;
        case SLEEPING:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""sleeping"");
            handleSleeping((IBinder) msg.obj, msg.arg1 != 0);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SET_CORE_SETTINGS:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""setCoreSettings"");
            handleSetCoreSettings((Bundle) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UPDATE_PACKAGE_COMPATIBILITY_INFO:
            handleUpdatePackageCompatibilityInfo((UpdateCompatibilityData) msg.obj);
            break;
        case TRIM_MEMORY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""trimMemory"");
            handleTrimMemory(msg.arg1);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UNSTABLE_PROVIDER_DIED:
            handleUnstableProviderDied((IBinder) msg.obj, false);
            break;
        case REQUEST_ASSIST_CONTEXT_EXTRAS:
            handleRequestAssistContextExtras((RequestAssistContextExtras) msg.obj);
            break;
        case TRANSLUCENT_CONVERSION_COMPLETE:
            handleTranslucentConversionComplete((IBinder) msg.obj, msg.arg1 == 1);
            break;
        case INSTALL_PROVIDER:
            handleInstallProvider((ProviderInfo) msg.obj);
            break;
        case ON_NEW_ACTIVITY_OPTIONS:
            Pair<IBinder, ActivityOptions> pair = (Pair<IBinder, ActivityOptions>) msg.obj;
            onNewActivityOptions(pair.first, pair.second);
            break;
        case CANCEL_VISIBLE_BEHIND:
            handleCancelVisibleBehind((IBinder) msg.obj);
            break;
        case BACKGROUND_VISIBLE_BEHIND_CHANGED:
            handleOnBackgroundVisibleBehindChanged((IBinder) msg.obj, msg.arg1 > 0);
            break;
        case ENTER_ANIMATION_COMPLETE:
            handleEnterAnimationComplete((IBinder) msg.obj);
            break;
        case START_BINDER_TRACKING:
            handleStartBinderTracking();
            break;
        case STOP_BINDER_TRACKING_AND_DUMP:
            handleStopBinderTrackingAndDump((ParcelFileDescriptor) msg.obj);
            break;
        case MULTI_WINDOW_MODE_CHANGED:
            handleMultiWindowModeChanged((IBinder) ((SomeArgs) msg.obj).arg1, ((SomeArgs) msg.obj).argi1 == 1, (Configuration) ((SomeArgs) msg.obj).arg2);
            break;
        case PICTURE_IN_PICTURE_MODE_CHANGED:
            handlePictureInPictureModeChanged((IBinder) ((SomeArgs) msg.obj).arg1, ((SomeArgs) msg.obj).argi1 == 1, (Configuration) ((SomeArgs) msg.obj).arg2);
            break;
        case LOCAL_VOICE_INTERACTION_STARTED:
            handleLocalVoiceInteractionStarted((IBinder) ((SomeArgs) msg.obj).arg1, (IVoiceInteractor) ((SomeArgs) msg.obj).arg2);
            break;
        case ATTACH_AGENT:
            handleAttachAgent((String) msg.obj);
            break;
        case APPLICATION_INFO_CHANGED:
            mUpdatingSystemConfig = true;
            try {
                handleApplicationInfoChanged((ApplicationInfo) msg.obj);
            } finally {
                mUpdatingSystemConfig = false;
            }
            break;
    }
    Object obj = msg.obj;
    if (obj instanceof SomeArgs) {
        ((SomeArgs) obj).recycle();
    }
    if (DEBUG_MESSAGES)
        Slog.v(TAG, ""<<< done: "" + codeToString(msg.what));
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
378,<android.widget.ScrollView.SavedState: String toString()>,25,26,<android.widget.ScrollView.SavedState: String toString()>,<android.widget.ScrollView.SavedState: String toString()>,0,"{
    return ""HorizontalScrollView.SavedState{"" + Integer.toHexString(System.identityHashCode(this)) + "" scrollPosition="" + scrollPosition + ""}"";
}","{
    return ""ScrollView.SavedState{"" + Integer.toHexString(System.identityHashCode(this)) + "" scrollPosition="" + scrollPosition + ""}"";
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The code change only involves a literal string within the return statement, and no actual logic or return type is modified, so the code change type is 4.","The string returned by the method is different, but since only the text that makes up the string is changed, and it doesn't affect the behavior of the program using this API, there is no Compatibility Issue. The method would still return a String type, so the CI type is 0."
380,<android.view.SurfaceView: boolean gatherTransparentRegion(Region)>,25,26,<android.view.SurfaceView: boolean gatherTransparentRegion(Region)>,<android.view.SurfaceView: boolean gatherTransparentRegion(Region)>,0,"{
    if (mWindowType == WindowManager.LayoutParams.TYPE_APPLICATION_PANEL) {
        return super.gatherTransparentRegion(region);
    }
    boolean opaque = true;
    if ((mPrivateFlags & PFLAG_SKIP_DRAW) == 0) {
        // this view draws, remove it from the transparent region
        opaque = super.gatherTransparentRegion(region);
    } else if (region != null) {
        int w = getWidth();
        int h = getHeight();
        if (w > 0 && h > 0) {
            getLocationInWindow(mLocation);
            // otherwise, punch a hole in the whole hierarchy
            int l = mLocation[0];
            int t = mLocation[1];
            region.op(l, t, l + w, t + h, Region.Op.UNION);
        }
    }
    if (PixelFormat.formatHasAlpha(mRequestedFormat)) {
        opaque = false;
    }
    return opaque;
}","{
    if (isAboveParent() || !mDrawFinished) {
        return super.gatherTransparentRegion(region);
    }
    boolean opaque = true;
    if ((mPrivateFlags & PFLAG_SKIP_DRAW) == 0) {
        // this view draws, remove it from the transparent region
        opaque = super.gatherTransparentRegion(region);
    } else if (region != null) {
        int w = getWidth();
        int h = getHeight();
        if (w > 0 && h > 0) {
            getLocationInWindow(mLocation);
            // otherwise, punch a hole in the whole hierarchy
            int l = mLocation[0];
            int t = mLocation[1];
            region.op(l, t, l + w, t + h, Region.Op.UNION);
        }
    }
    if (PixelFormat.formatHasAlpha(mRequestedFormat)) {
        opaque = false;
    }
    return opaque;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,1,"There is a control dependency change; the condition of the first `if` statement has changed from checking `mWindowType` to checking `isAboveParent()` or `!mDrawFinished`, so the code change type is 3.","Since the `if` condition has changed, this can lead to the `super.gatherTransparentRegion(region);` method being called under different circumstances, potentially returning a different value. This constitutes a compatibility issue of type 1 (different return values)."
382,<android.nfc.NdefRecord: int getByteLength()>,25,26,<android.nfc.NdefRecord: int getByteLength()>,<android.nfc.NdefRecord: int getByteLength()>,0,"{
    int length = 3 + mType.length + mId.length + mPayload.length;
    boolean sr = mPayload.length < 256;
    boolean il = mId.length > 0;
    if (!sr)
        length += 3;
    if (il)
        length += 1;
    return length;
}","{
    int length = 3 + mType.length + mId.length + mPayload.length;
    boolean sr = mPayload.length < 256;
    boolean il = mTnf == TNF_EMPTY ? true : mId.length > 0;
    if (!sr)
        length += 3;
    if (il)
        length += 1;
    return length;
}",1,"/**
 * Get byte length of serialized record.
 */
","/**
 * Get byte length of serialized record.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The condition for assigning 'il' has been modified to include a check for mTnf being equal to TNF_EMPTY, thus it is a control dependency change, so the code change type is 3.","The modification in the condition for 'il' will not cause a compatibility issue if mTnf is not TNF_EMPTY because the rest of the condition remains the same (mId.length > 0). If mTnf is TNF_EMPTY, the logic now sets 'il' to true unconditionally, which means length will always be incremented by 1 in this case. However, since TNF_EMPTY dictates that the NDEF record is empty and should have no type, id, or payload, the case where mTnf is TNF_EMPTY with a non-zero mId.length would be an illegal state of an NdefRecord. Given this context, it is unlikely that a well-formed NdefRecord with mTnf being TNF_EMPTY would have a non-zero mId.length value, and as such, this would not constitute a commonly encountered compatibility issue. Therefore, no compatibility issue is expected, and the CI type is 0."
383,<android.app.UiAutomation: AccessibilityNodeInfo findFocus(int)>,25,26,<android.app.UiAutomation: AccessibilityNodeInfo findFocus(int)>,<android.app.UiAutomation: AccessibilityNodeInfo findFocus(int)>,0,"{
    return AccessibilityInteractionClient.getInstance().findFocus(mConnectionId, AccessibilityNodeInfo.ANY_WINDOW_ID, AccessibilityNodeInfo.ROOT_NODE_ID, focus);
}","{
    return AccessibilityInteractionClient.getInstance().findFocus(mConnectionId, AccessibilityWindowInfo.ANY_WINDOW_ID, AccessibilityNodeInfo.ROOT_NODE_ID, focus);
}",1,"/**
 * Find the view that has the specified focus type. The search is performed
 * across all windows.
 * <p>
 * <strong>Note:</strong> In order to access the windows you have to opt-in
 * to retrieve the interactive windows by setting the
 * {@link AccessibilityServiceInfo#FLAG_RETRIEVE_INTERACTIVE_WINDOWS} flag.
 * Otherwise, the search will be performed only in the active window.
 * </p>
 *
 * @param focus The focus to find. One of {@link AccessibilityNodeInfo#FOCUS_INPUT} or
 * {@link AccessibilityNodeInfo#FOCUS_ACCESSIBILITY}.
 * @return The node info of the focused view or null.
 *
 * @see AccessibilityNodeInfo#FOCUS_INPUT
 * @see AccessibilityNodeInfo#FOCUS_ACCESSIBILITY
 */
","/**
 * Find the view that has the specified focus type. The search is performed
 * across all windows.
 * <p>
 * <strong>Note:</strong> In order to access the windows you have to opt-in
 * to retrieve the interactive windows by setting the
 * {@link AccessibilityServiceInfo#FLAG_RETRIEVE_INTERACTIVE_WINDOWS} flag.
 * Otherwise, the search will be performed only in the active window.
 * </p>
 *
 * @param focus The focus to find. One of {@link AccessibilityNodeInfo#FOCUS_INPUT} or
 * {@link AccessibilityNodeInfo#FOCUS_ACCESSIBILITY}.
 * @return The node info of the focused view or null.
 *
 * @see AccessibilityNodeInfo#FOCUS_INPUT
 * @see AccessibilityNodeInfo#FOCUS_ACCESSIBILITY
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The change from `AccessibilityNodeInfo.ANY_WINDOW_ID` to `AccessibilityWindowInfo.ANY_WINDOW_ID` indicates a changed reference to a constant value which belongs to a different class, so the code change type is 5.","Because the change is about a change of reference from one constant to another within the same implementation, it does not cause a return statement change or an exception handling change. Constants like `ANY_WINDOW_ID` are typically used to represent a specific predefined value (likely the same value), implying the behaviour of the method won't change and hence no compatibility issue arises. Therefore, the CI type is 0."
384,"<android.view.ViewGroup: PointerIcon onResolvePointerIcon(MotionEvent,int)>",25,26,"<android.view.ViewGroup: PointerIcon onResolvePointerIcon(MotionEvent,int)>","<android.view.ViewGroup: PointerIcon onResolvePointerIcon(MotionEvent,int)>",0,"{
    final float x = event.getX(pointerIndex);
    final float y = event.getY(pointerIndex);
    if (isOnScrollbarThumb(x, y) || isDraggingScrollBar()) {
        return PointerIcon.getSystemIcon(mContext, PointerIcon.TYPE_ARROW);
    }
    // Check what the child under the pointer says about the pointer.
    final int childrenCount = mChildrenCount;
    if (childrenCount != 0) {
        final ArrayList<View> preorderedList = buildOrderedChildList();
        final boolean customOrder = preorderedList == null && isChildrenDrawingOrderEnabled();
        final View[] children = mChildren;
        for (int i = childrenCount - 1; i >= 0; i--) {
            final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);
            final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);
            final PointF point = getLocalPoint();
            if (isTransformedTouchPointInView(x, y, child, point)) {
                final PointerIcon pointerIcon = dispatchResolvePointerIcon(event, pointerIndex, child);
                if (pointerIcon != null) {
                    if (preorderedList != null)
                        preorderedList.clear();
                    return pointerIcon;
                }
                break;
            }
        }
        if (preorderedList != null)
            preorderedList.clear();
    }
    // implementation.
    return super.onResolvePointerIcon(event, pointerIndex);
}","{
    final float x = event.getX(pointerIndex);
    final float y = event.getY(pointerIndex);
    if (isOnScrollbarThumb(x, y) || isDraggingScrollBar()) {
        return PointerIcon.getSystemIcon(mContext, PointerIcon.TYPE_ARROW);
    }
    // Check what the child under the pointer says about the pointer.
    final int childrenCount = mChildrenCount;
    if (childrenCount != 0) {
        final ArrayList<View> preorderedList = buildOrderedChildList();
        final boolean customOrder = preorderedList == null && isChildrenDrawingOrderEnabled();
        final View[] children = mChildren;
        for (int i = childrenCount - 1; i >= 0; i--) {
            final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);
            final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);
            if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) {
                continue;
            }
            final PointerIcon pointerIcon = dispatchResolvePointerIcon(event, pointerIndex, child);
            if (pointerIcon != null) {
                if (preorderedList != null)
                    preorderedList.clear();
                return pointerIcon;
            }
        }
        if (preorderedList != null)
            preorderedList.clear();
    }
    // implementation.
    return super.onResolvePointerIcon(event, pointerIndex);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"There is a control dependency change involving the addition of a new check `!canViewReceivePointerEvents(child)` inside the loop and the `isTransformedTouchPointInView` method no longer receives a non-null `PointF` object argument (passing `null` instead), which indicates both control dependency change and other statement changes. So the code change type is 3,4.","This change in control flow can lead to a different view being chosen for resolving the pointer icon. Also, the change in method `isTransformedTouchPointInView` parameter could potentially affect which child view is considered to have the pointer over it, which in turn could result in a different `PointerIcon` being returned. Thus, the CI type is 1 due to the potential change in the return value."
388,"<android.app.ContextImpl: ContextImpl createAppContext(ActivityThread,LoadedApk)>",25,26,"<android.app.ContextImpl: ContextImpl createAppContext(ActivityThread,LoadedApk)>","<android.app.ContextImpl: ContextImpl createAppContext(ActivityThread,LoadedApk)>",0,"{
    if (packageInfo == null)
        throw new IllegalArgumentException(""packageInfo"");
    return new ContextImpl(null, mainThread, packageInfo, null, null, 0, null, null, Display.INVALID_DISPLAY);
}","{
    if (packageInfo == null)
        throw new IllegalArgumentException(""packageInfo"");
    ContextImpl context = new ContextImpl(null, mainThread, packageInfo, null, null, null, 0, null);
    context.setResources(packageInfo.getResources());
    return context;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"Changes from the early to the late version include addition of method calls to setResources() and a change in the arguments passed to the constructor of ContextImpl. The number of parameters passed to the ContextImpl constructor has decreased and a new method setResources() is called on the context object. This suggests changes in both the return statement (construction of the object now includes a separate method call to setResources()) and other statements (changes in constructor parameters and addition of a method call), so the code change types are 1,3,4.","The late version sets the resources for the context explicitly which could result in different behavior if, for example, packageInfo.getResources() behaves differently than the previous implicit setting. Therefore, the code change potentially leads to a different return value, and the CI type is 1."
389,<android.widget.AbsListView: void keyPressed()>,25,26,<android.widget.AbsListView: void keyPressed()>,<android.widget.AbsListView: void keyPressed()>,0,"{
    if (!isEnabled() || !isClickable()) {
        return;
    }
    Drawable selector = mSelector;
    Rect selectorRect = mSelectorRect;
    if (selector != null && (isFocused() || touchModeDrawsInPressedState()) && !selectorRect.isEmpty()) {
        final View v = getChildAt(mSelectedPosition - mFirstPosition);
        if (v != null) {
            if (v.hasFocusable())
                return;
            v.setPressed(true);
        }
        setPressed(true);
        final boolean longClickable = isLongClickable();
        Drawable d = selector.getCurrent();
        if (d != null && d instanceof TransitionDrawable) {
            if (longClickable) {
                ((TransitionDrawable) d).startTransition(ViewConfiguration.getLongPressTimeout());
            } else {
                ((TransitionDrawable) d).resetTransition();
            }
        }
        if (longClickable && !mDataChanged) {
            if (mPendingCheckForKeyLongPress == null) {
                mPendingCheckForKeyLongPress = new CheckForKeyLongPress();
            }
            mPendingCheckForKeyLongPress.rememberWindowAttachCount();
            postDelayed(mPendingCheckForKeyLongPress, ViewConfiguration.getLongPressTimeout());
        }
    }
}","{
    if (!isEnabled() || !isClickable()) {
        return;
    }
    Drawable selector = mSelector;
    Rect selectorRect = mSelectorRect;
    if (selector != null && (isFocused() || touchModeDrawsInPressedState()) && !selectorRect.isEmpty()) {
        final View v = getChildAt(mSelectedPosition - mFirstPosition);
        if (v != null) {
            if (v.hasExplicitFocusable())
                return;
            v.setPressed(true);
        }
        setPressed(true);
        final boolean longClickable = isLongClickable();
        Drawable d = selector.getCurrent();
        if (d != null && d instanceof TransitionDrawable) {
            if (longClickable) {
                ((TransitionDrawable) d).startTransition(ViewConfiguration.getLongPressTimeout());
            } else {
                ((TransitionDrawable) d).resetTransition();
            }
        }
        if (longClickable && !mDataChanged) {
            if (mPendingCheckForKeyLongPress == null) {
                mPendingCheckForKeyLongPress = new CheckForKeyLongPress();
            }
            mPendingCheckForKeyLongPress.rememberWindowAttachCount();
            postDelayed(mPendingCheckForKeyLongPress, ViewConfiguration.getLongPressTimeout());
        }
    }
}",1,"/**
 * Sets the selector state to ""pressed"" and posts a CheckForKeyLongPress to see if
 * this is a long press.
 */
","/**
 * Sets the selector state to ""pressed"" and posts a CheckForKeyLongPress to see if
 * this is a long press.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method hasExplicitFocusable() is called instead of hasFocusable(). This represents a change in a method call within a conditional check, which is considered as other statement changed, so the code change type is 4.","Although there is a change in which method is called, it does not result in a change in the control flow or the data flow that would affect the behavior observable to the calling code in terms of different returned values or different exceptions thrown. The replacement method likely performs a similar check with possibly additional conditions. Without evidence of behavioral difference that would lead to a different execution flow, we cannot assume a compatibility issue, so the CI type is 0."
390,"<android.app.admin.DevicePolicyManager: Bundle getApplicationRestrictions(ComponentName,String)>",25,26,"<android.app.admin.DevicePolicyManager: Bundle getApplicationRestrictions(ComponentName,String)>","<android.app.admin.DevicePolicyManager: Bundle getApplicationRestrictions(ComponentName,String)>",0,"{
    throwIfParentInstance(""getApplicationRestrictions"");
    if (mService != null) {
        try {
            return mService.getApplicationRestrictions(admin, packageName);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return null;
}","{
    throwIfParentInstance(""getApplicationRestrictions"");
    if (mService != null) {
        try {
            return mService.getApplicationRestrictions(admin, mContext.getPackageName(), packageName);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return null;
}",1,"/**
 * Retrieves the application restrictions for a given target application running in the calling
 * user.
 * <p>
 * The caller must be a profile or device owner on that user, or the package allowed to manage
 * application restrictions via {@link #setApplicationRestrictionsManagingPackage}; otherwise a
 * security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or
 * {@code null} if called by the application restrictions managing package.
 * @param packageName The name of the package to fetch restricted settings of.
 * @return {@link Bundle} of settings corresponding to what was set last time
 * {@link DevicePolicyManager#setApplicationRestrictions} was called, or an empty
 * {@link Bundle} if no restrictions have been set.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 * @see {@link #setApplicationRestrictionsManagingPackage}
 */
","/**
 * Retrieves the application restrictions for a given target application running in the calling
 * user.
 * <p>
 * The caller must be a profile or device owner on that user, or the package allowed to manage
 * application restrictions via {@link #setDelegatedScopes} with the
 * {@link #DELEGATION_APP_RESTRICTIONS} scope; otherwise a security exception will be thrown.
 *
 * <p>NOTE: The method performs disk I/O and shouldn't be called on the main thread
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or
 * {@code null} if called by the application restrictions managing package.
 * @param packageName The name of the package to fetch restricted settings of.
 * @return {@link Bundle} of settings corresponding to what was set last time
 * {@link DevicePolicyManager#setApplicationRestrictions} was called, or an empty
 * {@link Bundle} if no restrictions have been set.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 * @see #setDelegatedScopes
 * @see #DELEGATION_APP_RESTRICTIONS
 */
",-1,,"[@WorkerThread, @NonNull]",-1,-1,-1,-1,-1,-1,"1,5",1,"The method call within return statement has an additional parameter 'mContext.getPackageName()' in the late implementation compared to the early version, which indicates that a dependent API change occurred, and the return statement changed because of this added parameter. Thus, the code change type is 1,5.","Since there is a change in the parameters passed to the dependent method mService.getApplicationRestrictions, it may alter the return value of the API. Therefore, a potential Compatibility Issue could arise due to possibly different return values. The CI type is 1."
391,<android.view.DragAndDropPermissions: void release()>,25,26,<android.view.DragAndDropPermissions: void release()>,<android.view.DragAndDropPermissions: void release()>,0,"{
    try {
        mDragAndDropPermissions.release();
        mPermissionOwnerToken = null;
    } catch (RemoteException e) {
    }
}","{
    try {
        mDragAndDropPermissions.release();
        mTransientToken = null;
    } catch (RemoteException e) {
    }
}",1,"/**
 * Revoke permissions explicitly.
 */
","/**
 * Revoke permissions explicitly.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,The only change is the assignment of null to a different field; mPermissionOwnerToken changed to mTransientToken.,"Changing the field that is being nulled does not affect the method's behavior in terms of return value or exceptions thrown. The method does not return any value (void), and the exception handling has not changed. Hence, there is no compatibility issue."
393,<android.app.UiAutomation: void setRunAsMonkey(boolean)>,25,26,<android.app.UiAutomation: void setRunAsMonkey(boolean)>,<android.app.UiAutomation: void setRunAsMonkey(boolean)>,0,"{
    synchronized (mLock) {
        throwIfNotConnectedLocked();
    }
    try {
        ActivityManagerNative.getDefault().setUserIsMonkey(enable);
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error while setting run as monkey!"", re);
    }
}","{
    synchronized (mLock) {
        throwIfNotConnectedLocked();
    }
    try {
        ActivityManager.getService().setUserIsMonkey(enable);
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error while setting run as monkey!"", re);
    }
}",1,"/**
 * Sets whether this UiAutomation to run in a ""monkey"" mode. Applications can query whether
 * they are executed in a ""monkey"" mode, i.e. run by a test framework, and avoid doing
 * potentially undesirable actions such as calling 911 or posting on public forums etc.
 *
 * @param enable whether to run in a ""monkey"" mode or not. Default is not.
 * @see ActivityManager#isUserAMonkey()
 */
","/**
 * Sets whether this UiAutomation to run in a ""monkey"" mode. Applications can query whether
 * they are executed in a ""monkey"" mode, i.e. run by a test framework, and avoid doing
 * potentially undesirable actions such as calling 911 or posting on public forums etc.
 *
 * @param enable whether to run in a ""monkey"" mode or not. Default is not.
 * @see ActivityManager#isUserAMonkey()
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method ActivityManagerNative.getDefault() has been changed to ActivityManager.getService() which indicates a change in the dependent API, so the code change type is 5.","Although there's a change in the dependent API, the overall behavior of setRunAsMonkey remains consistent assuming the functionality of ActivityManager.getService().setUserIsMonkey(enable) is the same as ActivityManagerNative.getDefault().setUserIsMonkey(enable). The way how the method is accessed changed, but not the functionality, hence there's no compatibility issue, hence the CI type is 0."
394,<android.os.StatFs: long getFreeBytes()>,25,26,<android.os.StatFs: long getFreeBytes()>,<android.os.StatFs: long getFreeBytes()>,0,"{
    return mStat.f_bfree * mStat.f_bsize;
}","{
    return mStat.f_bfree * mStat.f_frsize;
}",1,"/**
 * The number of bytes that are free on the file system, including reserved
 * blocks (that are not available to normal applications). Most applications
 * will want to use {@link #getAvailableBytes()} instead.
 */
","/**
 * The number of bytes that are free on the file system, including reserved
 * blocks (that are not available to normal applications). Most applications
 * will want to use {@link #getAvailableBytes()} instead.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"There is a change in the multiplier from mStat.f_bsize to mStat.f_frsize, which is not a control statement, a return statement, or an exception handling statement change, so the change type is 4.","Since the multiplier used for the calculation of free bytes has changed, the resulting value returned by the API can potentially be different, which could lead to a different behavior. Therefore, the CI type is 1."
395,<android.view.ViewTreeObserver: void removeOnDrawListener(OnDrawListener)>,25,26,<android.view.ViewTreeObserver: void removeOnDrawListener(OnDrawListener)>,<android.view.ViewTreeObserver: void removeOnDrawListener(OnDrawListener)>,0,"{
    checkIsAlive();
    if (mOnDrawListeners == null) {
        return;
    }
    mOnDrawListeners.remove(victim);
}","{
    checkIsAlive();
    if (mOnDrawListeners == null) {
        return;
    }
    if (mInDispatchOnDraw) {
        IllegalStateException ex = new IllegalStateException(""Cannot call removeOnDrawListener inside of onDraw"");
        if (sIllegalOnDrawModificationIsFatal) {
            throw ex;
        } else {
            Log.e(""ViewTreeObserver"", ex.getMessage(), ex);
        }
    }
    mOnDrawListeners.remove(victim);
}",1,"/**
 * <p>Remove a previously installed pre-draw callback.</p>
 * <p><strong>Note:</strong> this method <strong>cannot</strong> be invoked from
 * {@link android.view.ViewTreeObserver.OnDrawListener#onDraw()}.</p>
 *
 * @param victim The callback to remove
 *
 * @throws IllegalStateException If {@link #isAlive()} returns false
 *
 * @see #addOnDrawListener(OnDrawListener)
 */
","/**
 * <p>Remove a previously installed pre-draw callback.</p>
 * <p><strong>Note:</strong> this method <strong>cannot</strong> be invoked from
 * {@link android.view.ViewTreeObserver.OnDrawListener#onDraw()}.</p>
 *
 * @param victim The callback to remove
 *
 * @throws IllegalStateException If {@link #isAlive()} returns false
 *
 * @see #addOnDrawListener(OnDrawListener)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3","1,2","The late version has a new 'if' control dependency which checks if `mInDispatchOnDraw` is true, in which case it throws an IllegalStateException, so the code change type is 2,3.","The introduction of new exception handling inside a control statement (the 'if' block) means there's a potential change in behavior where the late version can throw an exception. Additionally, there is a potential change in when the method returns since now it can return without removing the listener if `mInDispatchOnDraw` is true and `sIllegalOnDrawModificationIsFatal` is false, which is a deviation from the previous behavior. Therefore, the potential CI types are 1,2."
396,<android.view.WindowManager.LayoutParams: int copyFrom(LayoutParams)>,25,26,<android.view.WindowManager.LayoutParams: int copyFrom(LayoutParams)>,<android.view.WindowManager.LayoutParams: int copyFrom(LayoutParams)>,0,"{
    int changes = 0;
    if (width != o.width) {
        width = o.width;
        changes |= LAYOUT_CHANGED;
    }
    if (height != o.height) {
        height = o.height;
        changes |= LAYOUT_CHANGED;
    }
    if (x != o.x) {
        x = o.x;
        changes |= LAYOUT_CHANGED;
    }
    if (y != o.y) {
        y = o.y;
        changes |= LAYOUT_CHANGED;
    }
    if (horizontalWeight != o.horizontalWeight) {
        horizontalWeight = o.horizontalWeight;
        changes |= LAYOUT_CHANGED;
    }
    if (verticalWeight != o.verticalWeight) {
        verticalWeight = o.verticalWeight;
        changes |= LAYOUT_CHANGED;
    }
    if (horizontalMargin != o.horizontalMargin) {
        horizontalMargin = o.horizontalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (verticalMargin != o.verticalMargin) {
        verticalMargin = o.verticalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (type != o.type) {
        type = o.type;
        changes |= TYPE_CHANGED;
    }
    if (flags != o.flags) {
        final int diff = flags ^ o.flags;
        if ((diff & (FLAG_TRANSLUCENT_STATUS | FLAG_TRANSLUCENT_NAVIGATION)) != 0) {
            changes |= TRANSLUCENT_FLAGS_CHANGED;
        }
        flags = o.flags;
        changes |= FLAGS_CHANGED;
    }
    if (privateFlags != o.privateFlags) {
        privateFlags = o.privateFlags;
        changes |= PRIVATE_FLAGS_CHANGED;
    }
    if (softInputMode != o.softInputMode) {
        softInputMode = o.softInputMode;
        changes |= SOFT_INPUT_MODE_CHANGED;
    }
    if (gravity != o.gravity) {
        gravity = o.gravity;
        changes |= LAYOUT_CHANGED;
    }
    if (format != o.format) {
        format = o.format;
        changes |= FORMAT_CHANGED;
    }
    if (windowAnimations != o.windowAnimations) {
        windowAnimations = o.windowAnimations;
        changes |= ANIMATION_CHANGED;
    }
    if (token == null) {
        // NOTE: token only copied if the recipient doesn't
        // already have one.
        token = o.token;
    }
    if (packageName == null) {
        // NOTE: packageName only copied if the recipient doesn't
        // already have one.
        packageName = o.packageName;
    }
    if (!Objects.equals(mTitle, o.mTitle) && o.mTitle != null) {
        // NOTE: mTitle only copied if the originator set one.
        mTitle = o.mTitle;
        changes |= TITLE_CHANGED;
    }
    if (alpha != o.alpha) {
        alpha = o.alpha;
        changes |= ALPHA_CHANGED;
    }
    if (dimAmount != o.dimAmount) {
        dimAmount = o.dimAmount;
        changes |= DIM_AMOUNT_CHANGED;
    }
    if (screenBrightness != o.screenBrightness) {
        screenBrightness = o.screenBrightness;
        changes |= SCREEN_BRIGHTNESS_CHANGED;
    }
    if (buttonBrightness != o.buttonBrightness) {
        buttonBrightness = o.buttonBrightness;
        changes |= BUTTON_BRIGHTNESS_CHANGED;
    }
    if (rotationAnimation != o.rotationAnimation) {
        rotationAnimation = o.rotationAnimation;
        changes |= ROTATION_ANIMATION_CHANGED;
    }
    if (screenOrientation != o.screenOrientation) {
        screenOrientation = o.screenOrientation;
        changes |= SCREEN_ORIENTATION_CHANGED;
    }
    if (preferredRefreshRate != o.preferredRefreshRate) {
        preferredRefreshRate = o.preferredRefreshRate;
        changes |= PREFERRED_REFRESH_RATE_CHANGED;
    }
    if (preferredDisplayModeId != o.preferredDisplayModeId) {
        preferredDisplayModeId = o.preferredDisplayModeId;
        changes |= PREFERRED_DISPLAY_MODE_ID;
    }
    if (systemUiVisibility != o.systemUiVisibility || subtreeSystemUiVisibility != o.subtreeSystemUiVisibility) {
        systemUiVisibility = o.systemUiVisibility;
        subtreeSystemUiVisibility = o.subtreeSystemUiVisibility;
        changes |= SYSTEM_UI_VISIBILITY_CHANGED;
    }
    if (hasSystemUiListeners != o.hasSystemUiListeners) {
        hasSystemUiListeners = o.hasSystemUiListeners;
        changes |= SYSTEM_UI_LISTENER_CHANGED;
    }
    if (inputFeatures != o.inputFeatures) {
        inputFeatures = o.inputFeatures;
        changes |= INPUT_FEATURES_CHANGED;
    }
    if (userActivityTimeout != o.userActivityTimeout) {
        userActivityTimeout = o.userActivityTimeout;
        changes |= USER_ACTIVITY_TIMEOUT_CHANGED;
    }
    if (!surfaceInsets.equals(o.surfaceInsets)) {
        surfaceInsets.set(o.surfaceInsets);
        changes |= SURFACE_INSETS_CHANGED;
    }
    if (hasManualSurfaceInsets != o.hasManualSurfaceInsets) {
        hasManualSurfaceInsets = o.hasManualSurfaceInsets;
        changes |= SURFACE_INSETS_CHANGED;
    }
    if (preservePreviousSurfaceInsets != o.preservePreviousSurfaceInsets) {
        preservePreviousSurfaceInsets = o.preservePreviousSurfaceInsets;
        changes |= SURFACE_INSETS_CHANGED;
    }
    if (needsMenuKey != o.needsMenuKey) {
        needsMenuKey = o.needsMenuKey;
        changes |= NEEDS_MENU_KEY_CHANGED;
    }
    if (accessibilityIdOfAnchor != o.accessibilityIdOfAnchor) {
        accessibilityIdOfAnchor = o.accessibilityIdOfAnchor;
        changes |= ACCESSIBILITY_ANCHOR_CHANGED;
    }
    if (!Objects.equals(accessibilityTitle, o.accessibilityTitle) && o.accessibilityTitle != null) {
        // NOTE: accessibilityTitle only copied if the originator set one.
        accessibilityTitle = o.accessibilityTitle;
        changes |= ACCESSIBILITY_TITLE_CHANGED;
    }
    // This can't change, it's only set at window creation time.
    removeTimeoutMilliseconds = o.removeTimeoutMilliseconds;
    return changes;
}","{
    int changes = 0;
    if (width != o.width) {
        width = o.width;
        changes |= LAYOUT_CHANGED;
    }
    if (height != o.height) {
        height = o.height;
        changes |= LAYOUT_CHANGED;
    }
    if (x != o.x) {
        x = o.x;
        changes |= LAYOUT_CHANGED;
    }
    if (y != o.y) {
        y = o.y;
        changes |= LAYOUT_CHANGED;
    }
    if (horizontalWeight != o.horizontalWeight) {
        horizontalWeight = o.horizontalWeight;
        changes |= LAYOUT_CHANGED;
    }
    if (verticalWeight != o.verticalWeight) {
        verticalWeight = o.verticalWeight;
        changes |= LAYOUT_CHANGED;
    }
    if (horizontalMargin != o.horizontalMargin) {
        horizontalMargin = o.horizontalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (verticalMargin != o.verticalMargin) {
        verticalMargin = o.verticalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (type != o.type) {
        type = o.type;
        changes |= TYPE_CHANGED;
    }
    if (flags != o.flags) {
        final int diff = flags ^ o.flags;
        if ((diff & (FLAG_TRANSLUCENT_STATUS | FLAG_TRANSLUCENT_NAVIGATION)) != 0) {
            changes |= TRANSLUCENT_FLAGS_CHANGED;
        }
        flags = o.flags;
        changes |= FLAGS_CHANGED;
    }
    if (privateFlags != o.privateFlags) {
        privateFlags = o.privateFlags;
        changes |= PRIVATE_FLAGS_CHANGED;
    }
    if (softInputMode != o.softInputMode) {
        softInputMode = o.softInputMode;
        changes |= SOFT_INPUT_MODE_CHANGED;
    }
    if (gravity != o.gravity) {
        gravity = o.gravity;
        changes |= LAYOUT_CHANGED;
    }
    if (format != o.format) {
        format = o.format;
        changes |= FORMAT_CHANGED;
    }
    if (windowAnimations != o.windowAnimations) {
        windowAnimations = o.windowAnimations;
        changes |= ANIMATION_CHANGED;
    }
    if (token == null) {
        // NOTE: token only copied if the recipient doesn't
        // already have one.
        token = o.token;
    }
    if (packageName == null) {
        // NOTE: packageName only copied if the recipient doesn't
        // already have one.
        packageName = o.packageName;
    }
    if (!Objects.equals(mTitle, o.mTitle) && o.mTitle != null) {
        // NOTE: mTitle only copied if the originator set one.
        mTitle = o.mTitle;
        changes |= TITLE_CHANGED;
    }
    if (alpha != o.alpha) {
        alpha = o.alpha;
        changes |= ALPHA_CHANGED;
    }
    if (dimAmount != o.dimAmount) {
        dimAmount = o.dimAmount;
        changes |= DIM_AMOUNT_CHANGED;
    }
    if (screenBrightness != o.screenBrightness) {
        screenBrightness = o.screenBrightness;
        changes |= SCREEN_BRIGHTNESS_CHANGED;
    }
    if (buttonBrightness != o.buttonBrightness) {
        buttonBrightness = o.buttonBrightness;
        changes |= BUTTON_BRIGHTNESS_CHANGED;
    }
    if (rotationAnimation != o.rotationAnimation) {
        rotationAnimation = o.rotationAnimation;
        changes |= ROTATION_ANIMATION_CHANGED;
    }
    if (screenOrientation != o.screenOrientation) {
        screenOrientation = o.screenOrientation;
        changes |= SCREEN_ORIENTATION_CHANGED;
    }
    if (preferredRefreshRate != o.preferredRefreshRate) {
        preferredRefreshRate = o.preferredRefreshRate;
        changes |= PREFERRED_REFRESH_RATE_CHANGED;
    }
    if (preferredDisplayModeId != o.preferredDisplayModeId) {
        preferredDisplayModeId = o.preferredDisplayModeId;
        changes |= PREFERRED_DISPLAY_MODE_ID;
    }
    if (systemUiVisibility != o.systemUiVisibility || subtreeSystemUiVisibility != o.subtreeSystemUiVisibility) {
        systemUiVisibility = o.systemUiVisibility;
        subtreeSystemUiVisibility = o.subtreeSystemUiVisibility;
        changes |= SYSTEM_UI_VISIBILITY_CHANGED;
    }
    if (hasSystemUiListeners != o.hasSystemUiListeners) {
        hasSystemUiListeners = o.hasSystemUiListeners;
        changes |= SYSTEM_UI_LISTENER_CHANGED;
    }
    if (inputFeatures != o.inputFeatures) {
        inputFeatures = o.inputFeatures;
        changes |= INPUT_FEATURES_CHANGED;
    }
    if (userActivityTimeout != o.userActivityTimeout) {
        userActivityTimeout = o.userActivityTimeout;
        changes |= USER_ACTIVITY_TIMEOUT_CHANGED;
    }
    if (!surfaceInsets.equals(o.surfaceInsets)) {
        surfaceInsets.set(o.surfaceInsets);
        changes |= SURFACE_INSETS_CHANGED;
    }
    if (hasManualSurfaceInsets != o.hasManualSurfaceInsets) {
        hasManualSurfaceInsets = o.hasManualSurfaceInsets;
        changes |= SURFACE_INSETS_CHANGED;
    }
    if (preservePreviousSurfaceInsets != o.preservePreviousSurfaceInsets) {
        preservePreviousSurfaceInsets = o.preservePreviousSurfaceInsets;
        changes |= SURFACE_INSETS_CHANGED;
    }
    if (needsMenuKey != o.needsMenuKey) {
        needsMenuKey = o.needsMenuKey;
        changes |= NEEDS_MENU_KEY_CHANGED;
    }
    if (accessibilityIdOfAnchor != o.accessibilityIdOfAnchor) {
        accessibilityIdOfAnchor = o.accessibilityIdOfAnchor;
        changes |= ACCESSIBILITY_ANCHOR_CHANGED;
    }
    if (!Objects.equals(accessibilityTitle, o.accessibilityTitle) && o.accessibilityTitle != null) {
        // NOTE: accessibilityTitle only copied if the originator set one.
        accessibilityTitle = o.accessibilityTitle;
        changes |= ACCESSIBILITY_TITLE_CHANGED;
    }
    // This can't change, it's only set at window creation time.
    hideTimeoutMilliseconds = o.hideTimeoutMilliseconds;
    return changes;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
399,<android.view.WindowManager.LayoutParams: String toString()>,25,26,<android.view.WindowManager.LayoutParams: String toString()>,<android.view.WindowManager.LayoutParams: String toString()>,0,"{
    StringBuilder sb = new StringBuilder(256);
    sb.append(""WM.LayoutParams{"");
    sb.append(""("");
    sb.append(x);
    sb.append(',');
    sb.append(y);
    sb.append("")("");
    sb.append((width == MATCH_PARENT ? ""fill"" : (width == WRAP_CONTENT ? ""wrap"" : width)));
    sb.append('x');
    sb.append((height == MATCH_PARENT ? ""fill"" : (height == WRAP_CONTENT ? ""wrap"" : height)));
    sb.append("")"");
    if (horizontalMargin != 0) {
        sb.append("" hm="");
        sb.append(horizontalMargin);
    }
    if (verticalMargin != 0) {
        sb.append("" vm="");
        sb.append(verticalMargin);
    }
    if (gravity != 0) {
        sb.append("" gr=#"");
        sb.append(Integer.toHexString(gravity));
    }
    if (softInputMode != 0) {
        sb.append("" sim=#"");
        sb.append(Integer.toHexString(softInputMode));
    }
    sb.append("" ty="");
    sb.append(type);
    sb.append("" fl=#"");
    sb.append(Integer.toHexString(flags));
    if (privateFlags != 0) {
        if ((privateFlags & PRIVATE_FLAG_COMPATIBLE_WINDOW) != 0) {
            sb.append("" compatible=true"");
        }
        sb.append("" pfl=0x"").append(Integer.toHexString(privateFlags));
    }
    if (format != PixelFormat.OPAQUE) {
        sb.append("" fmt="");
        sb.append(format);
    }
    if (windowAnimations != 0) {
        sb.append("" wanim=0x"");
        sb.append(Integer.toHexString(windowAnimations));
    }
    if (screenOrientation != ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED) {
        sb.append("" or="");
        sb.append(screenOrientation);
    }
    if (alpha != 1.0f) {
        sb.append("" alpha="");
        sb.append(alpha);
    }
    if (screenBrightness != BRIGHTNESS_OVERRIDE_NONE) {
        sb.append("" sbrt="");
        sb.append(screenBrightness);
    }
    if (buttonBrightness != BRIGHTNESS_OVERRIDE_NONE) {
        sb.append("" bbrt="");
        sb.append(buttonBrightness);
    }
    if (rotationAnimation != ROTATION_ANIMATION_ROTATE) {
        sb.append("" rotAnim="");
        sb.append(rotationAnimation);
    }
    if (preferredRefreshRate != 0) {
        sb.append("" preferredRefreshRate="");
        sb.append(preferredRefreshRate);
    }
    if (preferredDisplayModeId != 0) {
        sb.append("" preferredDisplayMode="");
        sb.append(preferredDisplayModeId);
    }
    if (systemUiVisibility != 0) {
        sb.append("" sysui=0x"");
        sb.append(Integer.toHexString(systemUiVisibility));
    }
    if (subtreeSystemUiVisibility != 0) {
        sb.append("" vsysui=0x"");
        sb.append(Integer.toHexString(subtreeSystemUiVisibility));
    }
    if (hasSystemUiListeners) {
        sb.append("" sysuil="");
        sb.append(hasSystemUiListeners);
    }
    if (inputFeatures != 0) {
        sb.append("" if=0x"").append(Integer.toHexString(inputFeatures));
    }
    if (userActivityTimeout >= 0) {
        sb.append("" userActivityTimeout="").append(userActivityTimeout);
    }
    if (surfaceInsets.left != 0 || surfaceInsets.top != 0 || surfaceInsets.right != 0 || surfaceInsets.bottom != 0 || hasManualSurfaceInsets || !preservePreviousSurfaceInsets) {
        sb.append("" surfaceInsets="").append(surfaceInsets);
        if (hasManualSurfaceInsets) {
            sb.append("" (manual)"");
        }
        if (!preservePreviousSurfaceInsets) {
            sb.append("" (!preservePreviousSurfaceInsets)"");
        }
    }
    if (needsMenuKey != NEEDS_MENU_UNSET) {
        sb.append("" needsMenuKey="");
        sb.append(needsMenuKey);
    }
    sb.append('}');
    return sb.toString();
}","{
    StringBuilder sb = new StringBuilder(256);
    sb.append(""WM.LayoutParams{"");
    sb.append(""("");
    sb.append(x);
    sb.append(',');
    sb.append(y);
    sb.append("")("");
    sb.append((width == MATCH_PARENT ? ""fill"" : (width == WRAP_CONTENT ? ""wrap"" : String.valueOf(width))));
    sb.append('x');
    sb.append((height == MATCH_PARENT ? ""fill"" : (height == WRAP_CONTENT ? ""wrap"" : String.valueOf(height))));
    sb.append("")"");
    if (horizontalMargin != 0) {
        sb.append("" hm="");
        sb.append(horizontalMargin);
    }
    if (verticalMargin != 0) {
        sb.append("" vm="");
        sb.append(verticalMargin);
    }
    if (gravity != 0) {
        sb.append("" gr=#"");
        sb.append(Integer.toHexString(gravity));
    }
    if (softInputMode != 0) {
        sb.append("" sim=#"");
        sb.append(Integer.toHexString(softInputMode));
    }
    sb.append("" ty="");
    sb.append(type);
    sb.append("" fl=#"");
    sb.append(Integer.toHexString(flags));
    if (privateFlags != 0) {
        if ((privateFlags & PRIVATE_FLAG_COMPATIBLE_WINDOW) != 0) {
            sb.append("" compatible=true"");
        }
        sb.append("" pfl=0x"").append(Integer.toHexString(privateFlags));
    }
    if (format != PixelFormat.OPAQUE) {
        sb.append("" fmt="");
        sb.append(format);
    }
    if (windowAnimations != 0) {
        sb.append("" wanim=0x"");
        sb.append(Integer.toHexString(windowAnimations));
    }
    if (screenOrientation != ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED) {
        sb.append("" or="");
        sb.append(screenOrientation);
    }
    if (alpha != 1.0f) {
        sb.append("" alpha="");
        sb.append(alpha);
    }
    if (screenBrightness != BRIGHTNESS_OVERRIDE_NONE) {
        sb.append("" sbrt="");
        sb.append(screenBrightness);
    }
    if (buttonBrightness != BRIGHTNESS_OVERRIDE_NONE) {
        sb.append("" bbrt="");
        sb.append(buttonBrightness);
    }
    if (rotationAnimation != ROTATION_ANIMATION_ROTATE) {
        sb.append("" rotAnim="");
        sb.append(rotationAnimation);
    }
    if (preferredRefreshRate != 0) {
        sb.append("" preferredRefreshRate="");
        sb.append(preferredRefreshRate);
    }
    if (preferredDisplayModeId != 0) {
        sb.append("" preferredDisplayMode="");
        sb.append(preferredDisplayModeId);
    }
    if (systemUiVisibility != 0) {
        sb.append("" sysui=0x"");
        sb.append(Integer.toHexString(systemUiVisibility));
    }
    if (subtreeSystemUiVisibility != 0) {
        sb.append("" vsysui=0x"");
        sb.append(Integer.toHexString(subtreeSystemUiVisibility));
    }
    if (hasSystemUiListeners) {
        sb.append("" sysuil="");
        sb.append(hasSystemUiListeners);
    }
    if (inputFeatures != 0) {
        sb.append("" if=0x"").append(Integer.toHexString(inputFeatures));
    }
    if (userActivityTimeout >= 0) {
        sb.append("" userActivityTimeout="").append(userActivityTimeout);
    }
    if (surfaceInsets.left != 0 || surfaceInsets.top != 0 || surfaceInsets.right != 0 || surfaceInsets.bottom != 0 || hasManualSurfaceInsets || !preservePreviousSurfaceInsets) {
        sb.append("" surfaceInsets="").append(surfaceInsets);
        if (hasManualSurfaceInsets) {
            sb.append("" (manual)"");
        }
        if (!preservePreviousSurfaceInsets) {
            sb.append("" (!preservePreviousSurfaceInsets)"");
        }
    }
    if (needsMenuKey != NEEDS_MENU_UNSET) {
        sb.append("" needsMenuKey="");
        sb.append(needsMenuKey);
    }
    sb.append("" colorMode="").append(mColorMode);
    sb.append('}');
    return sb.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
401,<android.content.pm.LauncherActivityInfo: Drawable getBadgedIcon(int)>,25,26,<android.content.pm.LauncherActivityInfo: Drawable getBadgedIcon(int)>,<android.content.pm.LauncherActivityInfo: Drawable getBadgedIcon(int)>,0,"{
    Drawable originalIcon = getIcon(density);
    if (originalIcon instanceof BitmapDrawable) {
        return mPm.getUserBadgedIcon(originalIcon, mUser);
    } else {
        Log.e(TAG, ""Unable to create badged icon for "" + mActivityInfo);
    }
    return originalIcon;
}","{
    Drawable originalIcon = getIcon(density);
    return mPm.getUserBadgedIcon(originalIcon, mUser);
}",1,"/**
 * Returns the activity icon with badging appropriate for the profile.
 * @param density Optional density for the icon, or 0 to use the default density. Use
 * {@link DisplayMetrics} for DPI values.
 * @see DisplayMetrics
 * @return A badged icon for the activity.
 */
","/**
 * Returns the activity icon with badging appropriate for the profile.
 * @param density Optional density for the icon, or 0 to use the default density. Use
 * {@link DisplayMetrics} for DPI values.
 * @see DisplayMetrics
 * @return A badged icon for the activity.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The early version contained a conditional check to see if 'originalIcon' is an instance of BitmapDrawable before attempting to badge it, and there is a log statement for the else condition. In the late version, this conditional check and the corresponding log statement have been removed, which is classified under ""Other statement changed"".","Even though an additional log statement has been removed and the conditional instance check no longer exists in the late version, the logic strictly related to what the API returns has not been modified. 'originalIcon' will be badged regardless of being an instance of BitmapDrawable or not in the late version implementation. This does not constitute a compatibility issue since the return type and potential return values remain the same, assuming 'mPm.getUserBadgedIcon()' behaves consistently despite the icon drawable type. Therefore, there is no compatibility issue since the API's functional behavior has not changed in terms of its return value."
402,<android.widget.HorizontalScrollView: boolean onGenericMotionEvent(MotionEvent)>,25,26,<android.widget.HorizontalScrollView: boolean onGenericMotionEvent(MotionEvent)>,<android.widget.HorizontalScrollView: boolean onGenericMotionEvent(MotionEvent)>,0,"{
    if ((event.getSource() & InputDevice.SOURCE_CLASS_POINTER) != 0) {
        switch(event.getAction()) {
            case MotionEvent.ACTION_SCROLL:
                {
                    if (!mIsBeingDragged) {
                        final float hscroll;
                        if ((event.getMetaState() & KeyEvent.META_SHIFT_ON) != 0) {
                            hscroll = -event.getAxisValue(MotionEvent.AXIS_VSCROLL);
                        } else {
                            hscroll = event.getAxisValue(MotionEvent.AXIS_HSCROLL);
                        }
                        if (hscroll != 0) {
                            final int delta = (int) (hscroll * getHorizontalScrollFactor());
                            final int range = getScrollRange();
                            int oldScrollX = mScrollX;
                            int newScrollX = oldScrollX + delta;
                            if (newScrollX < 0) {
                                newScrollX = 0;
                            } else if (newScrollX > range) {
                                newScrollX = range;
                            }
                            if (newScrollX != oldScrollX) {
                                super.scrollTo(newScrollX, mScrollY);
                                return true;
                            }
                        }
                    }
                }
        }
    }
    return super.onGenericMotionEvent(event);
}","{
    switch(event.getAction()) {
        case MotionEvent.ACTION_SCROLL:
            {
                if (!mIsBeingDragged) {
                    final float axisValue;
                    if (event.isFromSource(InputDevice.SOURCE_CLASS_POINTER)) {
                        if ((event.getMetaState() & KeyEvent.META_SHIFT_ON) != 0) {
                            axisValue = -event.getAxisValue(MotionEvent.AXIS_VSCROLL);
                        } else {
                            axisValue = event.getAxisValue(MotionEvent.AXIS_HSCROLL);
                        }
                    } else if (event.isFromSource(InputDevice.SOURCE_ROTARY_ENCODER)) {
                        axisValue = event.getAxisValue(MotionEvent.AXIS_SCROLL);
                    } else {
                        axisValue = 0;
                    }
                    final int delta = Math.round(axisValue * mHorizontalScrollFactor);
                    if (delta != 0) {
                        final int range = getScrollRange();
                        int oldScrollX = mScrollX;
                        int newScrollX = oldScrollX + delta;
                        if (newScrollX < 0) {
                            newScrollX = 0;
                        } else if (newScrollX > range) {
                            newScrollX = range;
                        }
                        if (newScrollX != oldScrollX) {
                            super.scrollTo(newScrollX, mScrollY);
                            return true;
                        }
                    }
                }
            }
    }
    return super.onGenericMotionEvent(event);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"The control dependency has changed by removing the condition check for pointers at the start of the method, and integrating it in a different way within the switch statement. There's also a change to include a new source check for `InputDevice.SOURCE_ROTARY_ENCODER`. Moreover, the factor used for horizontal scroll calculation has been changed. The method now uses `Math.round(axisValue * mHorizontalScrollFactor)` instead of `(int) (hscroll * getHorizontalScrollFactor())`. This is considered as a return statement change and a control dependency change, hence, the types are 1,3.","Since the way the scroll factor is computed has changed, as well as the device input source handling within the control flow, this could potentially lead to different return values (true versus false concerning the gesture being handled), resulting in a CI type 1."
403,"<android.app.admin.DevicePolicyManager: int enableSystemApp(ComponentName,Intent)>",25,26,"<android.app.admin.DevicePolicyManager: int enableSystemApp(ComponentName,Intent)>","<android.app.admin.DevicePolicyManager: int enableSystemApp(ComponentName,Intent)>",0,"{
    throwIfParentInstance(""enableSystemApp"");
    if (mService != null) {
        try {
            return mService.enableSystemAppWithIntent(admin, intent);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return 0;
}","{
    throwIfParentInstance(""enableSystemApp"");
    if (mService != null) {
        try {
            return mService.enableSystemAppWithIntent(admin, mContext.getPackageName(), intent);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return 0;
}",1,"/**
 * Called by profile or device owners to re-enable system apps by intent that were disabled by
 * default when the user was initialized.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param intent An intent matching the app(s) to be installed. All apps that resolve for this
 * intent will be re-enabled in the calling profile.
 * @return int The number of activities that matched the intent and were installed.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 */
","/**
 * Re-enable system apps by intent that were disabled by default when the user was initialized.
 * This function can be called by a device owner, profile owner, or by a delegate given the
 * {@link #DELEGATION_ENABLE_SYSTEM_APP} scope via {@link #setDelegatedScopes}.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or
 * {@code null} if the caller is an enable system app delegate.
 * @param intent An intent matching the app(s) to be installed. All apps that resolve for this
 * intent will be re-enabled in the calling profile.
 * @return int The number of activities that matched the intent and were installed.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 * @see #setDelegatedScopes
 * @see #DELEGATION_PACKAGE_ACCESS
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The dependent API enableSystemAppWithIntent has an additional parameter mContext.getPackageName() in the late version, which indicates a change in the method signature that the current API depends on. Therefore, the code change type is 4 for the added parameter and 5 for the change in the dependent API.","Since the dependent API enableSystemAppWithIntent now takes an additional parameter, the behavior of the current API could be different because it would be enabling a system app in the context of the calling package specifically. This means a different outcome could be possible based on the added package context, and hence there's a potential for compatibility issues due to different return values. The CI type is 1."
404,"<android.transition.ArcMotion: Path getPath(float,float,float,float)>",25,26,"<android.transition.ArcMotion: Path getPath(float,float,float,float)>","<android.transition.ArcMotion: Path getPath(float,float,float,float)>",0,"{
    // Here's a little ascii art to show how this is calculated:
    // c---------- b
    // \        / |
    // \     d  |
    // \  /   e
    // a----f
    // This diagram assumes that the horizontal distance is less than the vertical
    // distance between The start point (a) and end point (b).
    // d is the midpoint between a and b. c is the center point of the circle with
    // This path is formed by assuming that start and end points are in
    // an arc on a circle. The end point is centered in the circle vertically
    // and start is a point on the circle.
    // Triangles bfa and bde form similar right triangles. The control points
    // for the cubic Bezier arc path are the midpoints between a and e and e and b.
    Path path = new Path();
    path.moveTo(startX, startY);
    float ex;
    float ey;
    if (startY == endY) {
        ex = (startX + endX) / 2;
        ey = startY + mMinimumHorizontalTangent * Math.abs(endX - startX) / 2;
    } else if (startX == endX) {
        ex = startX + mMinimumVerticalTangent * Math.abs(endY - startY) / 2;
        ey = (startY + endY) / 2;
    } else {
        float deltaX = endX - startX;
        float deltaY = endY - startY;
        // hypotenuse squared.
        float h2 = deltaX * deltaX + deltaY * deltaY;
        // Midpoint between start and end
        float dx = (startX + endX) / 2;
        float dy = (startY + endY) / 2;
        // Distance squared between end point and mid point is (1/2 hypotenuse)^2
        float midDist2 = h2 * 0.25f;
        float minimumArcDist2 = 0;
        boolean isQuadrant1Or3 = (deltaX * deltaY) > 0;
        if ((Math.abs(deltaX) < Math.abs(deltaY))) {
            // Similar triangles bfa and bde mean that (ab/fb = eb/bd)
            // Therefore, eb = ab * bd / fb
            // ab = hypotenuse
            // bd = hypotenuse/2
            // fb = deltaY
            float eDistY = h2 / (2 * deltaY);
            if (isQuadrant1Or3) {
                ey = startY + eDistY;
                ex = startX;
            } else {
                ey = endY - eDistY;
                ex = endX;
            }
            minimumArcDist2 = midDist2 * mMinimumVerticalTangent * mMinimumVerticalTangent;
        } else {
            // Same as above, but flip X & Y
            float eDistX = h2 / (2 * deltaX);
            if (isQuadrant1Or3) {
                ex = endX - eDistX;
                ey = endY;
            } else {
                ex = startX + eDistX;
                ey = startY;
            }
            minimumArcDist2 = midDist2 * mMinimumHorizontalTangent * mMinimumHorizontalTangent;
        }
        float arcDistX = dx - ex;
        float arcDistY = dy - ey;
        float arcDist2 = arcDistX * arcDistX + arcDistY * arcDistY;
        float maximumArcDist2 = midDist2 * mMaximumTangent * mMaximumTangent;
        float newArcDistance2 = 0;
        if (arcDist2 < minimumArcDist2) {
            newArcDistance2 = minimumArcDist2;
        } else if (arcDist2 > maximumArcDist2) {
            newArcDistance2 = maximumArcDist2;
        }
        if (newArcDistance2 != 0) {
            float ratio2 = newArcDistance2 / arcDist2;
            float ratio = (float) Math.sqrt(ratio2);
            ex = dx + (ratio * (ex - dx));
            ey = dy + (ratio * (ey - dy));
        }
    }
    float controlX1 = (startX + ex) / 2;
    float controlY1 = (startY + ey) / 2;
    float controlX2 = (ex + endX) / 2;
    float controlY2 = (ey + endY) / 2;
    path.cubicTo(controlX1, controlY1, controlX2, controlY2, endX, endY);
    return path;
}","{
    // Here's a little ascii art to show how this is calculated:
    // c---------- b
    // \        / |
    // \     d  |
    // \  /   e
    // a----f
    // This diagram assumes that the horizontal distance is less than the vertical
    // distance between The start point (a) and end point (b).
    // d is the midpoint between a and b. c is the center point of the circle with
    // This path is formed by assuming that start and end points are in
    // an arc on a circle. The end point is centered in the circle vertically
    // and start is a point on the circle.
    // Triangles bfa and bde form similar right triangles. The control points
    // for the cubic Bezier arc path are the midpoints between a and e and e and b.
    Path path = new Path();
    path.moveTo(startX, startY);
    float ex;
    float ey;
    float deltaX = endX - startX;
    float deltaY = endY - startY;
    // hypotenuse squared.
    float h2 = deltaX * deltaX + deltaY * deltaY;
    // Midpoint between start and end
    float dx = (startX + endX) / 2;
    float dy = (startY + endY) / 2;
    // Distance squared between end point and mid point is (1/2 hypotenuse)^2
    float midDist2 = h2 * 0.25f;
    float minimumArcDist2 = 0;
    boolean isMovingUpwards = startY > endY;
    if ((Math.abs(deltaX) < Math.abs(deltaY))) {
        // Similar triangles bfa and bde mean that (ab/fb = eb/bd)
        // Therefore, eb = ab * bd / fb
        // ab = hypotenuse
        // bd = hypotenuse/2
        // fb = deltaY
        float eDistY = Math.abs(h2 / (2 * deltaY));
        if (isMovingUpwards) {
            ey = endY + eDistY;
            ex = endX;
        } else {
            ey = startY + eDistY;
            ex = startX;
        }
        minimumArcDist2 = midDist2 * mMinimumVerticalTangent * mMinimumVerticalTangent;
    } else {
        // Same as above, but flip X & Y and account for negative eDist
        float eDistX = h2 / (2 * deltaX);
        if (isMovingUpwards) {
            ex = startX + eDistX;
            ey = startY;
        } else {
            ex = endX - eDistX;
            ey = endY;
        }
        minimumArcDist2 = midDist2 * mMinimumHorizontalTangent * mMinimumHorizontalTangent;
    }
    float arcDistX = dx - ex;
    float arcDistY = dy - ey;
    float arcDist2 = arcDistX * arcDistX + arcDistY * arcDistY;
    float maximumArcDist2 = midDist2 * mMaximumTangent * mMaximumTangent;
    float newArcDistance2 = 0;
    if (arcDist2 < minimumArcDist2) {
        newArcDistance2 = minimumArcDist2;
    } else if (arcDist2 > maximumArcDist2) {
        newArcDistance2 = maximumArcDist2;
    }
    if (newArcDistance2 != 0) {
        float ratio2 = newArcDistance2 / arcDist2;
        float ratio = (float) Math.sqrt(ratio2);
        ex = dx + (ratio * (ex - dx));
        ey = dy + (ratio * (ey - dy));
    }
    float control1X = (startX + ex) / 2;
    float control1Y = (startY + ey) / 2;
    float control2X = (ex + endX) / 2;
    float control2Y = (ey + endY) / 2;
    path.cubicTo(control1X, control1Y, control2X, control2Y, endX, endY);
    return path;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
405,<android.inputmethodservice.InputMethodService: boolean enableHardwareAcceleration()>,25,26,<android.inputmethodservice.InputMethodService: boolean enableHardwareAcceleration()>,<android.inputmethodservice.InputMethodService: boolean enableHardwareAcceleration()>,0,"{
    if (mWindow != null) {
        throw new IllegalStateException(""Must be called before onCreate()"");
    }
    if (ActivityManager.isHighEndGfx()) {
        mHardwareAccelerated = true;
        return true;
    }
    return false;
}","{
    if (mWindow != null) {
        throw new IllegalStateException(""Must be called before onCreate()"");
    }
    return ActivityManager.isHighEndGfx();
}",1,"/**
 * You can call this to try to enable hardware accelerated drawing for
 * your IME. This must be set before {@link #onCreate}, so you
 * will typically call it in your constructor.  It is not always possible
 * to use hardware accelerated drawing in an IME (for example on low-end
 * devices that do not have the resources to support this), so the call
 * returns true if it succeeds otherwise false if you will need to draw
 * in software.  You must be able to handle either case.
 *
 * @deprecated Starting in API 21, hardware acceleration is always enabled
 * on capable devices.
 */
","/**
 * You can call this to try to enable accelerated drawing for your IME. This must be set before
 * {@link #onCreate()}, so you will typically call it in your constructor.  It is not always
 * possible to use hardware accelerated drawing in an IME (for example on low-end devices that
 * do not have the resources to support this), so the call {@code true} if it succeeds otherwise
 * {@code false} if you will need to draw in software.  You must be able to handle either case.
 *
 * <p>In API 21 and later, system may automatically enable hardware accelerated drawing for your
 * IME on capable devices even if this method is not explicitly called. Make sure that your IME
 * is able to handle either case.</p>
 *
 * @return {@code true} if accelerated drawing is successfully enabled otherwise {@code false}.
 * On API 21 and later devices the return value is basically just a hint and your IME
 * does not need to change the behavior based on the it
 * @deprecated Starting in API 21, hardware acceleration is always enabled on capable devices
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"1,4",1,"The assignment to mHardwareAccelerated has been removed, and the return statement has been simplified from a conditional block to a direct return of the method call result. The code change types are 1 for the change in the return statement and 4 for the removal of the assignment statement.","The return value of the method could potentially be different because in the early implementation, there is an explicit assignment to a variable before returning, while in the late version, it returns the result of the method call directly. This could be a Compatibility Issue if the 'mHardwareAccelerated' variable was used later in the code, affecting the behavior of other methods or the state of the object. Hence, the CI type is 1."
407,<android.view.ViewGroup: boolean shouldBlockFocusForTouchscreen()>,25,26,<android.view.ViewGroup: boolean shouldBlockFocusForTouchscreen()>,<android.view.ViewGroup: boolean shouldBlockFocusForTouchscreen()>,0,"{
    return getTouchscreenBlocksFocus() && mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_TOUCHSCREEN);
}","{
    // cluster, focus is free to move around within it.
    return getTouchscreenBlocksFocus() && mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_TOUCHSCREEN) && !(isKeyboardNavigationCluster() && (hasFocus() || (findKeyboardNavigationCluster() != this)));
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The late version of the method adds additional condition checks involving 'isKeyboardNavigationCluster()', 'hasFocus()' and 'findKeyboardNavigationCluster()'. These changes constitute a control dependency change, as well as a change to the return statement, hence, the change type is 1,3.","The added conditions impact the potential return value of the method. If the new conditions evaluate differently, the method can now potentially return false where it previously would have returned true, or vice versa; thus, the CI type is 1 due to the change in the return statement leading to different potential return values."
408,<android.hardware.camera2.utils.TaskDrainer: void taskStarted(T)>,25,26,<android.hardware.camera2.utils.TaskDrainer: void taskStarted(T)>,<android.hardware.camera2.utils.TaskDrainer: void taskStarted(T)>,0,"{
    synchronized (mLock) {
        if (DEBUG) {
            Log.v(TAG + ""["" + mName + ""]"", ""taskStarted "" + task);
        }
        if (mDraining) {
            throw new IllegalStateException(""Can't start more tasks after draining has begun"");
        }
        if (!mTaskSet.add(task)) {
            throw new IllegalStateException(""Task "" + task + "" was already started"");
        }
    }
}","{
    synchronized (mLock) {
        if (DEBUG) {
            Log.v(TAG + ""["" + mName + ""]"", ""taskStarted "" + task);
        }
        if (mDraining) {
            throw new IllegalStateException(""Can't start more tasks after draining has begun"");
        }
        // Try to remove the task from the early finished set.
        if (!mEarlyFinishedTaskSet.remove(task)) {
            // The task is not finished early. Add it to the started set.
            if (!mTaskSet.add(task)) {
                throw new IllegalStateException(""Task "" + task + "" was already started"");
            }
        }
    }
}",1,"/**
 * Mark an asynchronous task as having started.
 *
 * <p>A task cannot be started more than once without first having finished. Once
 * draining begins with {@link #beginDrain}, no new tasks can be started.</p>
 *
 * @param task a key to identify a task
 *
 * @see #taskFinished
 * @see #beginDrain
 *
 * @throws IllegalStateException
 * If attempting to start a task which is already started (and not finished),
 * or if attempting to start a task after draining has begun.
 */
","/**
 * Mark an asynchronous task as having started.
 *
 * <p>A task cannot be started more than once without first having finished. Once
 * draining begins with {@link #beginDrain}, no new tasks can be started.</p>
 *
 * @param task a key to identify a task
 *
 * @see #taskFinished
 * @see #beginDrain
 *
 * @throws IllegalStateException
 * If attempting to start a task which is already started (and not finished),
 * or if attempting to start a task after draining has begun.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",2,"The late implementation includes new statements for handling tasks that might have been finished early, which were not present in the early version. This is categorized as Other statement changed (4). Additionally, the control flow has changed because tasks might be now removed from the `mEarlyFinishedTaskSet` before checking if they can be added to `mTaskSet`, which involves Control dependency change (3).","The inclusion of this new logic to remove the task from the `mEarlyFinishedTaskSet` cannot lead to a different return value or type because the method is void type and there is no change in the types of exceptions thrown or how they are handled. However, there is a change in the conditions under which these exceptions are thrown due to the new control flow. Previously a task would unconditionally cause an IllegalStateException if it had already been added; now it will only throw if the task was neither previously finished early nor already started, hence the CI type is 2 for potential different exception handlings."
409,"<android.provider.DocumentsContract: Uri copyDocument(ContentResolver,Uri,Uri)>",25,26,"<android.provider.DocumentsContract: Uri copyDocument(ContentResolver,Uri,Uri)>","<android.provider.DocumentsContract: Uri copyDocument(ContentResolver,Uri,Uri)>",0,"{
    final ContentProviderClient client = resolver.acquireUnstableContentProviderClient(sourceDocumentUri.getAuthority());
    try {
        return copyDocument(client, sourceDocumentUri, targetParentDocumentUri);
    } catch (Exception e) {
        Log.w(TAG, ""Failed to copy document"", e);
        return null;
    } finally {
        ContentProviderClient.releaseQuietly(client);
    }
}","{
    final ContentProviderClient client = resolver.acquireUnstableContentProviderClient(sourceDocumentUri.getAuthority());
    try {
        return copyDocument(client, sourceDocumentUri, targetParentDocumentUri);
    } catch (Exception e) {
        Log.w(TAG, ""Failed to copy document"", e);
        rethrowIfNecessary(resolver, e);
        return null;
    } finally {
        ContentProviderClient.releaseQuietly(client);
    }
}",1,"/**
 * Copies the given document.
 *
 * @param sourceDocumentUri document with {@link Document#FLAG_SUPPORTS_COPY}
 * @param targetParentDocumentUri document which will become a parent of the source
 * document's copy.
 * @return the copied document, or {@code null} if failed.
 */
","/**
 * Copies the given document.
 *
 * @param sourceDocumentUri document with {@link Document#FLAG_SUPPORTS_COPY}
 * @param targetParentDocumentUri document which will become a parent of the source
 * document's copy.
 * @return the copied document, or {@code null} if failed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,2,"An additional method call (rethrowIfNecessary(resolver, e)) was added to the catch block, which does not change the return type but potentially changes the exception handling behavior, so the code change type is 4.","Since there is no change to the return statements, but there is a change in how exceptions are handled, the CI type is 2. The new method call within the catch block could potentially throw a different exception than what was originally caught, altering the API's exception handling behavior."
410,<android.widget.PopupWindow: void update()>,25,26,<android.widget.PopupWindow: void update()>,<android.widget.PopupWindow: void update()>,0,"{
    if (!isShowing() || mContentView == null) {
        return;
    }
    final WindowManager.LayoutParams p = (WindowManager.LayoutParams) mDecorView.getLayoutParams();
    boolean update = false;
    final int newAnim = computeAnimationResource();
    if (newAnim != p.windowAnimations) {
        p.windowAnimations = newAnim;
        update = true;
    }
    final int newFlags = computeFlags(p.flags);
    if (newFlags != p.flags) {
        p.flags = newFlags;
        update = true;
    }
    final int newGravity = computeGravity();
    if (newGravity != p.gravity) {
        p.gravity = newGravity;
        update = true;
    }
    if (update) {
        setLayoutDirectionFromAnchor();
        mWindowManager.updateViewLayout(mDecorView, p);
    }
}","{
    if (!isShowing() || !hasContentView()) {
        return;
    }
    final WindowManager.LayoutParams p = getDecorViewLayoutParams();
    boolean update = false;
    final int newAnim = computeAnimationResource();
    if (newAnim != p.windowAnimations) {
        p.windowAnimations = newAnim;
        update = true;
    }
    final int newFlags = computeFlags(p.flags);
    if (newFlags != p.flags) {
        p.flags = newFlags;
        update = true;
    }
    final int newGravity = computeGravity();
    if (newGravity != p.gravity) {
        p.gravity = newGravity;
        update = true;
    }
    if (update) {
        update(mAnchor != null ? mAnchor.get() : null, p);
    }
}",1,"/**
 * Updates the state of the popup window, if it is currently being displayed,
 * from the currently set state.
 * <p>
 * This includes:
 * <ul>
 * <li>{@link #setClippingEnabled(boolean)}</li>
 * <li>{@link #setFocusable(boolean)}</li>
 * <li>{@link #setIgnoreCheekPress()}</li>
 * <li>{@link #setInputMethodMode(int)}</li>
 * <li>{@link #setTouchable(boolean)}</li>
 * <li>{@link #setAnimationStyle(int)}</li>
 * </ul>
 */
","/**
 * Updates the state of the popup window, if it is currently being displayed,
 * from the currently set state.
 * <p>
 * This includes:
 * <ul>
 * <li>{@link #setClippingEnabled(boolean)}</li>
 * <li>{@link #setFocusable(boolean)}</li>
 * <li>{@link #setIgnoreCheekPress()}</li>
 * <li>{@link #setInputMethodMode(int)}</li>
 * <li>{@link #setTouchable(boolean)}</li>
 * <li>{@link #setAnimationStyle(int)}</li>
 * </ul>
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"There are changes in control dependency, other statements, and dependent APIs. A new condition 'hasContentView()' has replaced the old check 'mContentView == null' in the if statement, so there is a control dependency change. The method call 'mDecorView.getLayoutParams()' is replaced with 'getDecorViewLayoutParams()', and 'mWindowManager.updateViewLayout(mDecorView, p)' is replaced with 'update(mAnchor != null ? mAnchor.get() : null, p)', indicating changes in both the method calls and the logic on how 'update' is performed, and implying changes in other statements and dependent APIs.","The changes in the control dependency logic, update to the 'update' method and condition checks, could lead to the 'update' method behaving differently when calling 'return', as well as potential different objects being passed to the updated function. This introduces a Compatibility Issue caused by potentially different return types or values."
413,<android.app.FragmentManagerImpl: boolean popBackStackImmediate()>,25,26,<android.app.FragmentManagerImpl: boolean popBackStackImmediate()>,<android.app.FragmentManagerImpl: boolean popBackStackImmediate()>,0,"{
    checkStateLoss();
    executePendingTransactions();
    return popBackStackState(mHost.getHandler(), null, -1, 0);
}","{
    checkStateLoss();
    return popBackStackImmediate(null, -1, 0);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,1,"In the early implementation, there is a call to executePendingTransactions() followed by a call to popBackStackState(), but in the late version, these calls have been replaced by a single call to popBackStackImmediate(). This indicates a change in the dependent API.","The change in the dependent API could lead to a different return behavior of the method, because popBackStackImmediate() may have a different implementation than the combination of executePendingTransactions() and popBackStackState(). This can therefore potentially return different results, constituting a compatibility issue of type 1."
414,<android.view.textservice.SpellCheckerSession.SpellCheckerSessionListenerImpl: void onServiceConnected(ISpellCheckerSession)>,25,26,<android.view.textservice.SpellCheckerSession.SpellCheckerSessionListenerImpl: void onServiceConnected(ISpellCheckerSession)>,<android.view.textservice.SpellCheckerSession.SpellCheckerSessionListenerImpl: void onServiceConnected(ISpellCheckerSession)>,0,"{
    synchronized (this) {
        switch(mState) {
            case STATE_WAIT_CONNECTION:
                // OK, go ahead.
                break;
            case STATE_CLOSED_BEFORE_CONNECTION:
                // in this connection. OK to ignore.
                if (DBG)
                    Log.i(TAG, ""ignoring onServiceConnected since the session is"" + "" already closed."");
                return;
            default:
                Log.e(TAG, ""ignoring onServiceConnected due to unexpected mState="" + stateToString(mState));
                return;
        }
        if (session == null) {
            Log.e(TAG, ""ignoring onServiceConnected due to session=null"");
            return;
        }
        mISpellCheckerSession = session;
        if (session.asBinder() instanceof Binder && mThread == null) {
            if (DBG)
                Log.d(TAG, ""starting HandlerThread in onServiceConnected."");
            // If this is a local object, we need to do our own threading
            // to make sure we handle it asynchronously.
            mThread = new HandlerThread(""SpellCheckerSession"", Process.THREAD_PRIORITY_BACKGROUND);
            mThread.start();
            mAsyncHandler = new Handler(mThread.getLooper()) {

                @Override
                public void handleMessage(Message msg) {
                    SpellCheckerParams scp = (SpellCheckerParams) msg.obj;
                    processTask(scp.mSession, scp, true);
                }
            };
        }
        mState = STATE_CONNECTED;
        if (DBG) {
            Log.d(TAG, ""processed onServiceConnected: mISpellCheckerSession.hashCode()=#"" + Integer.toHexString(mISpellCheckerSession.hashCode()) + "" mPendingTasks.size()="" + mPendingTasks.size());
        }
    }
    while (!mPendingTasks.isEmpty()) {
        processTask(session, mPendingTasks.poll(), false);
    }
}","{
    synchronized (this) {
        switch(mState) {
            case STATE_WAIT_CONNECTION:
                // OK, go ahead.
                break;
            case STATE_CLOSED_BEFORE_CONNECTION:
                // in this connection. OK to ignore.
                if (DBG)
                    Log.i(TAG, ""ignoring onServiceConnected since the session is"" + "" already closed."");
                return;
            default:
                Log.e(TAG, ""ignoring onServiceConnected due to unexpected mState="" + stateToString(mState));
                return;
        }
        if (session == null) {
            Log.e(TAG, ""ignoring onServiceConnected due to session=null"");
            return;
        }
        mISpellCheckerSession = session;
        if (session.asBinder() instanceof Binder && mThread == null) {
            if (DBG)
                Log.d(TAG, ""starting HandlerThread in onServiceConnected."");
            // If this is a local object, we need to do our own threading
            // to make sure we handle it asynchronously.
            mThread = new HandlerThread(""SpellCheckerSession"", Process.THREAD_PRIORITY_BACKGROUND);
            mThread.start();
            mAsyncHandler = new Handler(mThread.getLooper()) {

                @Override
                public void handleMessage(Message msg) {
                    SpellCheckerParams scp = (SpellCheckerParams) msg.obj;
                    processTask(scp.mSession, scp, true);
                }
            };
        }
        mState = STATE_CONNECTED;
        if (DBG) {
            Log.d(TAG, ""processed onServiceConnected: mISpellCheckerSession.hashCode()=#"" + Integer.toHexString(mISpellCheckerSession.hashCode()) + "" mPendingTasks.size()="" + mPendingTasks.size());
        }
        while (!mPendingTasks.isEmpty()) {
            processTask(session, mPendingTasks.poll(), false);
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,0,0,There are no changes between the early and late implementation of the method.,"Since there are no changes in the implementation, there is no Compatibility Issue."
415,"<android.net.LocalSocketImpl: void setOption(int,Object)>",25,26,"<android.net.LocalSocketImpl: void setOption(int,Object)>","<android.net.LocalSocketImpl: void setOption(int,Object)>",0,"{
    if (fd == null) {
        throw new IOException(""socket not created"");
    }
    /*
         * Boolean.FALSE is used to disable some options, so it
         * is important to distinguish between FALSE and unset.
         * We define it here that -1 is unset, 0 is FALSE, and 1
         * is TRUE.
         */
    int boolValue = -1;
    int intValue = 0;
    if (value instanceof Integer) {
        intValue = (Integer) value;
    } else if (value instanceof Boolean) {
        boolValue = ((Boolean) value) ? 1 : 0;
    } else {
        throw new IOException(""bad value: "" + value);
    }
    try {
        switch(optID) {
            case SocketOptions.SO_LINGER:
                StructLinger linger = new StructLinger(boolValue, intValue);
                Os.setsockoptLinger(fd, OsConstants.SOL_SOCKET, OsConstants.SO_LINGER, linger);
                break;
            case SocketOptions.SO_TIMEOUT:
                /*
                     * SO_TIMEOUT from the core library gets converted to
                     * SO_SNDTIMEO, but the option is supposed to set both
                     * send and receive timeouts. Note: The incoming timeout
                     * value is in milliseconds.
                     */
                StructTimeval timeval = StructTimeval.fromMillis(intValue);
                Os.setsockoptTimeval(fd, OsConstants.SOL_SOCKET, OsConstants.SO_SNDTIMEO, timeval);
                break;
            case SocketOptions.SO_RCVBUF:
            case SocketOptions.SO_SNDBUF:
            case SocketOptions.SO_REUSEADDR:
                int osOpt = javaSoToOsOpt(optID);
                Os.setsockoptInt(fd, OsConstants.SOL_SOCKET, osOpt, intValue);
                break;
            case SocketOptions.TCP_NODELAY:
                Os.setsockoptInt(fd, OsConstants.IPPROTO_TCP, OsConstants.TCP_NODELAY, intValue);
                break;
            default:
                throw new IOException(""Unknown option: "" + optID);
        }
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}","{
    if (fd == null) {
        throw new IOException(""socket not created"");
    }
    /*
         * Boolean.FALSE is used to disable some options, so it
         * is important to distinguish between FALSE and unset.
         * We define it here that -1 is unset, 0 is FALSE, and 1
         * is TRUE.
         */
    int boolValue = -1;
    int intValue = 0;
    if (value instanceof Integer) {
        intValue = (Integer) value;
    } else if (value instanceof Boolean) {
        boolValue = ((Boolean) value) ? 1 : 0;
    } else {
        throw new IOException(""bad value: "" + value);
    }
    try {
        switch(optID) {
            case SocketOptions.SO_LINGER:
                StructLinger linger = new StructLinger(boolValue, intValue);
                Os.setsockoptLinger(fd, OsConstants.SOL_SOCKET, OsConstants.SO_LINGER, linger);
                break;
            case SocketOptions.SO_TIMEOUT:
                // The option must set both send and receive timeouts.
                // Note: The incoming timeout value is in milliseconds.
                StructTimeval timeval = StructTimeval.fromMillis(intValue);
                Os.setsockoptTimeval(fd, OsConstants.SOL_SOCKET, OsConstants.SO_RCVTIMEO, timeval);
                Os.setsockoptTimeval(fd, OsConstants.SOL_SOCKET, OsConstants.SO_SNDTIMEO, timeval);
                break;
            case SocketOptions.SO_RCVBUF:
            case SocketOptions.SO_SNDBUF:
            case SocketOptions.SO_REUSEADDR:
                int osOpt = javaSoToOsOpt(optID);
                Os.setsockoptInt(fd, OsConstants.SOL_SOCKET, osOpt, intValue);
                break;
            case SocketOptions.TCP_NODELAY:
                Os.setsockoptInt(fd, OsConstants.IPPROTO_TCP, OsConstants.TCP_NODELAY, intValue);
                break;
            default:
                throw new IOException(""Unknown option: "" + optID);
        }
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"In the case for SocketOptions.SO_TIMEOUT, there is an additional call to Os.setsockoptTimeval for SO_RCVTIMEO. This reflects a call to a dependent API with a modified usage (additional method call with same arguments). Hence, the changes are in category 4 and 5.","The additional method call for setting SO_RCVTIMEO can potentially alter the behavior of setting the socket timeout, which could lead to the API having a different behavior when setting the SO_TIMEOUT option. The existing code configured only the send timeout, whereas the new code configures both send and receive timeouts. Therefore, this could potentially lead to a different return behavior since the state of the socket could be affected differently, thus, falling under CI type 1."
416,<android.view.inputmethod.InputMethodManager: InputMethodSubtype getCurrentInputMethodSubtype()>,25,26,<android.view.inputmethod.InputMethodManager: InputMethodSubtype getCurrentInputMethodSubtype()>,<android.view.inputmethod.InputMethodManager: InputMethodSubtype getCurrentInputMethodSubtype()>,0,"{
    synchronized (mH) {
        try {
            return mService.getCurrentInputMethodSubtype();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}","{
    try {
        return mService.getCurrentInputMethodSubtype();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns the current input method subtype. This subtype is one of the subtypes in
 * the current input method. This method returns null when the current input method doesn't
 * have any input method subtype.
 */
","/**
 * Returns the current input method subtype. This subtype is one of the subtypes in
 * the current input method. This method returns null when the current input method doesn't
 * have any input method subtype.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The change in the code involves the removal of the synchronized block around the try-catch, so there are changes in the control dependency and other statements, which are classified as types 3 and 4.","Despite the removal of the synchronized block, the synchronization is related to thread safety rather than changing the behavior of the value returned or exceptions thrown by the API. Therefore, no Compatibility Issue arises, as the return value and exception handling remain consistent with the previous version, thus the CI type is 0."
418,<android.app.admin.DevicePolicyManager: List<byte[]> getInstalledCaCerts(ComponentName)>,25,26,<android.app.admin.DevicePolicyManager: List<byte[]> getInstalledCaCerts(ComponentName)>,<android.app.admin.DevicePolicyManager: List<byte[]> getInstalledCaCerts(ComponentName)>,0,"{
    List<byte[]> certs = new ArrayList<byte[]>();
    throwIfParentInstance(""getInstalledCaCerts"");
    if (mService != null) {
        try {
            mService.enforceCanManageCaCerts(admin);
            final TrustedCertificateStore certStore = new TrustedCertificateStore();
            for (String alias : certStore.userAliases()) {
                try {
                    certs.add(certStore.getCertificate(alias).getEncoded());
                } catch (CertificateException ce) {
                    Log.w(TAG, ""Could not encode certificate: "" + alias, ce);
                }
            }
        } catch (RemoteException re) {
            throw re.rethrowFromSystemServer();
        }
    }
    return certs;
}","{
    final List<byte[]> certs = new ArrayList<byte[]>();
    throwIfParentInstance(""getInstalledCaCerts"");
    if (mService != null) {
        try {
            mService.enforceCanManageCaCerts(admin, mContext.getPackageName());
            final TrustedCertificateStore certStore = new TrustedCertificateStore();
            for (String alias : certStore.userAliases()) {
                try {
                    certs.add(certStore.getCertificate(alias).getEncoded());
                } catch (CertificateException ce) {
                    Log.w(TAG, ""Could not encode certificate: "" + alias, ce);
                }
            }
        } catch (RemoteException re) {
            throw re.rethrowFromSystemServer();
        }
    }
    return certs;
}",1,"/**
 * Returns all CA certificates that are currently trusted, excluding system CA certificates.
 * If a user has installed any certificates by other means than device policy these will be
 * included too.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or
 * {@code null} if calling from a delegated certificate installer.
 * @return a List of byte[] arrays, each encoding one user CA certificate.
 * @throws SecurityException if {@code admin} is not {@code null} and not a device or profile
 * owner.
 */
","/**
 * Returns all CA certificates that are currently trusted, excluding system CA certificates.
 * If a user has installed any certificates by other means than device policy these will be
 * included too.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or
 * {@code null} if calling from a delegated certificate installer.
 * @return a List of byte[] arrays, each encoding one user CA certificate.
 * @throws SecurityException if {@code admin} is not {@code null} and not a device or profile
 * owner.
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,5,1,"The dependent API 'mService.enforceCanManageCaCerts' method call changed by adding 'mContext.getPackageName()' as a parameter, so the code change type is 5.","Adding an argument to the call 'mService.enforceCanManageCaCerts' could potentially lead to a different behavior if that method's implementation depends on the new argument. Therefore, it could cause the API to return a different value, and the CI type is 1."
420,<android.bluetooth.BluetoothAdapter: int getState()>,25,26,<android.bluetooth.BluetoothAdapter: int getState()>,<android.bluetooth.BluetoothAdapter: int getState()>,0,"{
    int state = BluetoothAdapter.STATE_OFF;
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            state = mService.getState();
        }
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    // Consider all internal states as OFF
    if (state == BluetoothAdapter.STATE_BLE_ON || state == BluetoothAdapter.STATE_BLE_TURNING_ON || state == BluetoothAdapter.STATE_BLE_TURNING_OFF) {
        if (VDBG)
            Log.d(TAG, ""Consider internal state as OFF"");
        state = BluetoothAdapter.STATE_OFF;
    }
    if (VDBG)
        Log.d(TAG, """" + hashCode() + "": getState(). Returning "" + state);
    return state;
}","{
    int state = BluetoothAdapter.STATE_OFF;
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            state = mService.getState();
        }
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    // Consider all internal states as OFF
    if (state == BluetoothAdapter.STATE_BLE_ON || state == BluetoothAdapter.STATE_BLE_TURNING_ON || state == BluetoothAdapter.STATE_BLE_TURNING_OFF) {
        if (VDBG)
            Log.d(TAG, ""Consider "" + BluetoothAdapter.nameForState(state) + "" state as OFF"");
        state = BluetoothAdapter.STATE_OFF;
    }
    if (VDBG)
        Log.d(TAG, """" + hashCode() + "": getState(). Returning "" + BluetoothAdapter.nameForState(state));
    return state;
}",1,"/**
 * Get the current state of the local Bluetooth adapter.
 * <p>Possible return values are
 * {@link #STATE_OFF},
 * {@link #STATE_TURNING_ON},
 * {@link #STATE_ON},
 * {@link #STATE_TURNING_OFF}.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
 *
 * @return current state of Bluetooth adapter
 */
","/**
 * Get the current state of the local Bluetooth adapter.
 * <p>Possible return values are
 * {@link #STATE_OFF},
 * {@link #STATE_TURNING_ON},
 * {@link #STATE_ON},
 * {@link #STATE_TURNING_OFF}.
 *
 * @return current state of Bluetooth adapter
 */
",-1,"[@RequiresPermission(Manifest.permission.BLUETOOTH), @AdapterState]","[@RequiresPermission(Manifest.permission.BLUETOOTH), @AdapterState]",-1,-1,-1,-1,-1,-1,4,0,"The only change present is the addition of state conversion to a string for the log message using `BluetoothAdapter.nameForState(state)`. Since it is only affecting log messages and does no change the actual behavior of the method or its return value, the change type is 4.",There is no Compatibility Issue since the returned value of the method and the behavior of the method remain unchanged. The modification only affects debug log output which is not relevant to the API's functional contract.
423,"<android.provider.DocumentsProvider: Cursor query(Uri,String[],String,String[],String)>",25,26,"<android.provider.DocumentsProvider: Cursor query(Uri,String[],String,String[],String)>","<android.provider.DocumentsProvider: Cursor query(Uri,String[],String,String[],String)>",0,"{
    try {
        switch(mMatcher.match(uri)) {
            case MATCH_ROOTS:
                return queryRoots(projection);
            case MATCH_RECENT:
                return queryRecentDocuments(getRootId(uri), projection);
            case MATCH_SEARCH:
                return querySearchDocuments(getRootId(uri), getSearchDocumentsQuery(uri), projection);
            case MATCH_DOCUMENT:
            case MATCH_DOCUMENT_TREE:
                enforceTree(uri);
                return queryDocument(getDocumentId(uri), projection);
            case MATCH_CHILDREN:
            case MATCH_CHILDREN_TREE:
                enforceTree(uri);
                if (DocumentsContract.isManageMode(uri)) {
                    return queryChildDocumentsForManage(getDocumentId(uri), projection, sortOrder);
                } else {
                    return queryChildDocuments(getDocumentId(uri), projection, sortOrder);
                }
            default:
                throw new UnsupportedOperationException(""Unsupported Uri "" + uri);
        }
    } catch (FileNotFoundException e) {
        Log.w(TAG, ""Failed during query"", e);
        return null;
    }
}","{
    // transport method. We override that, and don't ever delegate to this method.
    throw new UnsupportedOperationException(""Pre-Android-O query format not supported."");
}",1,"/**
 * Implementation is provided by the parent class. Cannot be overriden.
 *
 * @see #queryRoots(String[])
 * @see #queryRecentDocuments(String, String[])
 * @see #queryDocument(String, String[])
 * @see #queryChildDocuments(String, String[], String)
 * @see #querySearchDocuments(String, String, String[])
 */
",,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,2,3,4","1,2","The entire body of the method has been replaced with a simple throw statement, causing changes to return statements, exception handling, control dependencies, and other statements. Therefore, the changes are of type 1,2,3,4.","There is a Compatibility Issue due to the complete change of the method body. The early version could return various Cursors based on the cases or null in the event of a FileNotFoundException, but the late version always throws an UnsupportedOperationException regardless of the input. Therefore, the CI is of type 1 (different values or types returned) and 2 (different exception handling)."
425,"<android.app.FragmentManagerImpl: void attachController(FragmentHostCallback<?>,FragmentContainer,Fragment)>",25,26,"<android.app.FragmentManagerImpl: void attachController(FragmentHostCallback<?>,FragmentContainer,Fragment)>","<android.app.FragmentManagerImpl: void attachController(FragmentHostCallback<?>,FragmentContainer,Fragment)>",0,"{
    if (mHost != null)
        throw new IllegalStateException(""Already attached"");
    mHost = host;
    mContainer = container;
    mParent = parent;
}","{
    if (mHost != null)
        throw new IllegalStateException(""Already attached"");
    mHost = host;
    mContainer = container;
    mParent = parent;
    mAllowOldReentrantBehavior = getTargetSdk() <= Build.VERSION_CODES.N_MR1;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change is an addition of an assignment statement for the 'mAllowOldReentrantBehavior' field, so the code change type is 4.","The addition of this assignment does not alter the return type or value, nor does it change the exception handling of the method. Therefore, no compatibility issue is expected from this change."
426,<android.view.accessibility.AccessibilityManager: void interrupt()>,25,26,<android.view.accessibility.AccessibilityManager: void interrupt()>,<android.view.accessibility.AccessibilityManager: void interrupt()>,0,"{
    final IAccessibilityManager service;
    final int userId;
    synchronized (mLock) {
        service = getServiceLocked();
        if (service == null) {
            return;
        }
        if (!mIsEnabled) {
            throw new IllegalStateException(""Accessibility off. Did you forget to check that?"");
        }
        userId = mUserId;
    }
    try {
        service.interrupt(userId);
        if (DEBUG) {
            Log.i(LOG_TAG, ""Requested interrupt from all services"");
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error while requesting interrupt from all services. "", re);
    }
}","{
    final IAccessibilityManager service;
    final int userId;
    synchronized (mLock) {
        service = getServiceLocked();
        if (service == null) {
            return;
        }
        if (!mIsEnabled) {
            Looper myLooper = Looper.myLooper();
            if (myLooper == Looper.getMainLooper()) {
                throw new IllegalStateException(""Accessibility off. Did you forget to check that?"");
            } else {
                // If we're not running on the thread with the main looper, it's possible for
                // the state of accessibility to change between checking isEnabled and
                // calling this method. So just log the error rather than throwing the
                // exception.
                Log.e(LOG_TAG, ""Interrupt called with accessibility disabled"");
                return;
            }
        }
        userId = mUserId;
    }
    try {
        service.interrupt(userId);
        if (DEBUG) {
            Log.i(LOG_TAG, ""Requested interrupt from all services"");
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error while requesting interrupt from all services. "", re);
    }
}",1,"/**
 * Requests feedback interruption from all accessibility services.
 */
","/**
 * Requests feedback interruption from all accessibility services.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The control dependency has changed with the addition of a new 'if' condition that checks whether the current thread's Looper is the main Looper and alters the exception handling logic accordingly. This change modifies the branch where the exception is thrown, replacing it with logging an error and returning early for non-main threads.","Although there is a change in the control flow, this does not cause a Compatibility Issue because it only affects the internal handling of a situation where mIsEnabled is false. In the early version, an IllegalStateException is thrown regardless of the thread context whenever mIsEnabled is false. In the late version, if the same condition is met but the call is made on a non-main thread, the exception is not thrown; instead, an error is logged and the method returns early. However, the contract of the method remains functionally the same, and there is no difference in the method's behavior concerning actual interrupts on the state of accessibility services. The return value and exception contract of the method are not affected in cases where the method is expected to function (i.e., when mIsEnabled is true and the service is non-null)."
427,"<android.app.FragmentManagerImpl: Animator loadAnimator(Fragment,int,boolean,int)>",25,26,"<android.app.FragmentManagerImpl: Animator loadAnimator(Fragment,int,boolean,int)>","<android.app.FragmentManagerImpl: Animator loadAnimator(Fragment,int,boolean,int)>",0,"{
    Animator animObj = fragment.onCreateAnimator(transit, enter, fragment.mNextAnim);
    if (animObj != null) {
        return animObj;
    }
    if (fragment.mNextAnim != 0) {
        Animator anim = AnimatorInflater.loadAnimator(mHost.getContext(), fragment.mNextAnim);
        if (anim != null) {
            return anim;
        }
    }
    if (transit == 0) {
        return null;
    }
    int styleIndex = transitToStyleIndex(transit, enter);
    if (styleIndex < 0) {
        return null;
    }
    if (transitionStyle == 0 && mHost.onHasWindowAnimations()) {
        transitionStyle = mHost.onGetWindowAnimations();
    }
    if (transitionStyle == 0) {
        return null;
    }
    TypedArray attrs = mHost.getContext().obtainStyledAttributes(transitionStyle, com.android.internal.R.styleable.FragmentAnimation);
    int anim = attrs.getResourceId(styleIndex, 0);
    attrs.recycle();
    if (anim == 0) {
        return null;
    }
    return AnimatorInflater.loadAnimator(mHost.getContext(), anim);
}","{
    Animator animObj = fragment.onCreateAnimator(transit, enter, fragment.getNextAnim());
    if (animObj != null) {
        return animObj;
    }
    if (fragment.getNextAnim() != 0) {
        Animator anim = AnimatorInflater.loadAnimator(mHost.getContext(), fragment.getNextAnim());
        if (anim != null) {
            return anim;
        }
    }
    if (transit == 0) {
        return null;
    }
    int styleIndex = transitToStyleIndex(transit, enter);
    if (styleIndex < 0) {
        return null;
    }
    if (transitionStyle == 0 && mHost.onHasWindowAnimations()) {
        transitionStyle = mHost.onGetWindowAnimations();
    }
    if (transitionStyle == 0) {
        return null;
    }
    TypedArray attrs = mHost.getContext().obtainStyledAttributes(transitionStyle, com.android.internal.R.styleable.FragmentAnimation);
    int anim = attrs.getResourceId(styleIndex, 0);
    attrs.recycle();
    if (anim == 0) {
        return null;
    }
    return AnimatorInflater.loadAnimator(mHost.getContext(), anim);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,5,0,"The API calls were changed from `fragment.mNextAnim` to `fragment.getNextAnim()`, which indicates a change in the method used to retrieve values, classifying it as dependent API changed 5.","Since the change from `fragment.mNextAnim` to `fragment.getNextAnim()` is an internal change to the use of a getter method, rather than a field access, and assuming the getter method returns the same value as the field, this would not lead to a compatibility issue."
429,<android.hardware.camera2.impl.CameraDeviceImpl: Builder createCaptureRequest(int)>,25,26,<android.hardware.camera2.impl.CameraDeviceImpl: Builder createCaptureRequest(int)>,<android.hardware.camera2.impl.CameraDeviceImpl: Builder createCaptureRequest(int)>,0,"{
    synchronized (mInterfaceLock) {
        checkIfCameraClosedOrInError();
        CameraMetadataNative templatedRequest = null;
        templatedRequest = mRemoteDevice.createDefaultRequest(templateType);
        CaptureRequest.Builder builder = new CaptureRequest.Builder(templatedRequest, /*reprocess*/
        false, CameraCaptureSession.SESSION_ID_NONE);
        return builder;
    }
}","{
    synchronized (mInterfaceLock) {
        checkIfCameraClosedOrInError();
        CameraMetadataNative templatedRequest = null;
        templatedRequest = mRemoteDevice.createDefaultRequest(templateType);
        // must be false in the default request.
        if (mAppTargetSdkVersion < Build.VERSION_CODES.O || templateType != TEMPLATE_STILL_CAPTURE) {
            overrideEnableZsl(templatedRequest, false);
        }
        CaptureRequest.Builder builder = new CaptureRequest.Builder(templatedRequest, /*reprocess*/
        false, CameraCaptureSession.SESSION_ID_NONE);
        return builder;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The late version introduces a new if-statement that calls 'overrideEnableZsl()' based on conditions which did not exist in the early version, which is a control dependency change, and it also introduces a new method call 'overrideEnableZsl()', which is an other statement change. Hence, the change types are 3 and 4.","Despite the modifications, there is no change related to the return value or the exception handling. Both versions end with the return of the same `CaptureRequest.Builder` object under the same conditions, and there are no changes regarding exceptions; thus, there is no Compatibility Issue. The new conditional logic and the method it calls do not have an impact on the outcome of the method visible to the caller. Therefore, the CI type is 0."
430,"<android.app.SharedPreferencesImpl.EditorImpl: Editor putString(String,String)>",25,26,"<android.app.SharedPreferencesImpl.EditorImpl: Editor putString(String,String)>","<android.app.SharedPreferencesImpl.EditorImpl: Editor putString(String,String)>",0,"{
    synchronized (this) {
        mModified.put(key, value);
        return this;
    }
}","{
    synchronized (mLock) {
        mModified.put(key, value);
        return this;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code change is that the synchronization is now being done on a different object (`mLock` instead of `this`). The synchronized block's body, which contains the actual logic of the method, remains unchanged. No other changes are made to the return statement or exception handling, so the code change type is 4.","There is no change that affects the API behavior seen by the client. The Editor object being returned is still the same, and the put operation on `mModified` is the same. The method's external behavior remains consistent between versions, so there is no CI."
431,"<android.app.Notification: void writeToParcel(Parcel,int)>",25,26,"<android.app.Notification: void writeToParcel(Parcel,int)>","<android.app.Notification: void writeToParcel(Parcel,int)>",0,"{
    // We need to mark all pending intents getting into the notification
    // system as being put there to later allow the notification ranker
    // to launch them and by doing so add the app to the battery saver white
    // list for a short period of time. The problem is that the system
    // cannot look into the extras as there may be parcelables there that
    // the platform does not know how to handle. To go around that we have
    // an explicit list of the pending intents in the extras bundle.
    final boolean collectPendingIntents = (allPendingIntents == null);
    if (collectPendingIntents) {
        PendingIntent.setOnMarshaledListener((PendingIntent intent, Parcel out, int outFlags) -> {
            if (parcel == out) {
                if (allPendingIntents == null) {
                    allPendingIntents = new ArraySet<>();
                }
                allPendingIntents.add(intent);
            }
        });
    }
    try {
        // IMPORTANT: Add marshaling code in writeToParcelImpl as we
        // want to intercept all pending events written to the pacel.
        writeToParcelImpl(parcel, flags);
        // Must be written last!
        parcel.writeArraySet(allPendingIntents);
    } finally {
        if (collectPendingIntents) {
            PendingIntent.setOnMarshaledListener(null);
        }
    }
}","{
    // We need to mark all pending intents getting into the notification
    // system as being put there to later allow the notification ranker
    // to launch them and by doing so add the app to the battery saver white
    // list for a short period of time. The problem is that the system
    // cannot look into the extras as there may be parcelables there that
    // the platform does not know how to handle. To go around that we have
    // an explicit list of the pending intents in the extras bundle.
    final boolean collectPendingIntents = (allPendingIntents == null);
    if (collectPendingIntents) {
        PendingIntent.setOnMarshaledListener((PendingIntent intent, Parcel out, int outFlags) -> {
            if (parcel == out) {
                if (allPendingIntents == null) {
                    allPendingIntents = new ArraySet<>();
                }
                allPendingIntents.add(intent);
            }
        });
    }
    try {
        // IMPORTANT: Add marshaling code in writeToParcelImpl as we
        // want to intercept all pending events written to the parcel.
        writeToParcelImpl(parcel, flags);
        // Must be written last!
        parcel.writeArraySet(allPendingIntents);
    } finally {
        if (collectPendingIntents) {
            PendingIntent.setOnMarshaledListener(null);
        }
    }
}",1,"/**
 * Flatten this notification into a parcel.
 */
","/**
 * Flatten this notification into a parcel.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"There is no actual code change apart from a comment typo fix (from ""pacel"" to ""parcel""), so the code change type is 0.","Since no code has changed, there can't be any compatibility issues. Therefore, the CI type is 0."
432,"<android.bluetooth.BluetoothDevice: BluetoothGatt connectGatt(Context,boolean,BluetoothGattCallback,int)>",25,26,"<android.bluetooth.BluetoothDevice: BluetoothGatt connectGatt(Context,boolean,BluetoothGattCallback,int)>","<android.bluetooth.BluetoothDevice: BluetoothGatt connectGatt(Context,boolean,BluetoothGattCallback,int)>",0,"{
    // TODO(Bluetooth) check whether platform support BLE
    // Do the check here or in GattServer?
    BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
    IBluetoothManager managerService = adapter.getBluetoothManager();
    try {
        IBluetoothGatt iGatt = managerService.getBluetoothGatt();
        if (iGatt == null) {
            // BLE is not supported
            return null;
        }
        BluetoothGatt gatt = new BluetoothGatt(context, iGatt, this, transport);
        gatt.connect(autoConnect, callback);
        return gatt;
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return null;
}","{
    return (connectGatt(context, autoConnect, callback, transport, PHY_LE_1M_MASK));
}",1,"/**
 * Connect to GATT Server hosted by this device. Caller acts as GATT client.
 * The callback is used to deliver results to Caller, such as connection status as well
 * as any further GATT client operations.
 * The method returns a BluetoothGatt instance. You can use BluetoothGatt to conduct
 * GATT client operations.
 * @param callback GATT callback handler that will receive asynchronous callbacks.
 * @param autoConnect Whether to directly connect to the remote device (false)
 * or to automatically connect as soon as the remote
 * device becomes available (true).
 * @param transport preferred transport for GATT connections to remote dual-mode devices
 * {@link BluetoothDevice#TRANSPORT_AUTO} or
 * {@link BluetoothDevice#TRANSPORT_BREDR} or {@link BluetoothDevice#TRANSPORT_LE}
 * @throws IllegalArgumentException if callback is null
 */
","/**
 * Connect to GATT Server hosted by this device. Caller acts as GATT client.
 * The callback is used to deliver results to Caller, such as connection status as well
 * as any further GATT client operations.
 * The method returns a BluetoothGatt instance. You can use BluetoothGatt to conduct
 * GATT client operations.
 * @param callback GATT callback handler that will receive asynchronous callbacks.
 * @param autoConnect Whether to directly connect to the remote device (false)
 * or to automatically connect as soon as the remote
 * device becomes available (true).
 * @param transport preferred transport for GATT connections to remote dual-mode devices
 * {@link BluetoothDevice#TRANSPORT_AUTO} or
 * {@link BluetoothDevice#TRANSPORT_BREDR} or {@link BluetoothDevice#TRANSPORT_LE}
 * @throws IllegalArgumentException if callback is null
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation of the method has changed entirely, from multiple lines of code including a try-catch block to a single return statement that calls a different internal method, presumably an overloaded version of 'connectGatt'. The implementation relies on a new dependent API 'connectGatt' with a different signature, indicating the change type is 1 and 5.","The change indicates that the behavior of the method might be entirely different in the late version. The original method's code contains logic to handle null values and a try-catch block to catch potential RemoteExceptions, but the late version's code does not. This lack of check could introduce a regression or different behavior for any client using this API, so it potentially returns a different value. Hence, the CI type is 1."
434,"<android.view.ViewGroup: void addFocusables(ArrayList<View>,int,int)>",25,26,"<android.view.ViewGroup: void addFocusables(ArrayList<View>,int,int)>","<android.view.ViewGroup: void addFocusables(ArrayList<View>,int,int)>",0,"{
    final int focusableCount = views.size();
    final int descendantFocusability = getDescendantFocusability();
    if (descendantFocusability != FOCUS_BLOCK_DESCENDANTS) {
        if (shouldBlockFocusForTouchscreen()) {
            focusableMode |= FOCUSABLES_TOUCH_MODE;
        }
        final int count = mChildrenCount;
        final View[] children = mChildren;
        for (int i = 0; i < count; i++) {
            final View child = children[i];
            if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE) {
                child.addFocusables(views, direction, focusableMode);
            }
        }
    }
    // among the focusable children would be more interesting.
    if ((descendantFocusability != FOCUS_AFTER_DESCENDANTS || // No focusable descendants
    (focusableCount == views.size())) && (isFocusableInTouchMode() || !shouldBlockFocusForTouchscreen())) {
        super.addFocusables(views, direction, focusableMode);
    }
}","{
    final int focusableCount = views.size();
    final int descendantFocusability = getDescendantFocusability();
    final boolean blockFocusForTouchscreen = shouldBlockFocusForTouchscreen();
    final boolean focusSelf = (isFocusableInTouchMode() || !blockFocusForTouchscreen);
    if (descendantFocusability == FOCUS_BLOCK_DESCENDANTS) {
        if (focusSelf) {
            super.addFocusables(views, direction, focusableMode);
        }
        return;
    }
    if (blockFocusForTouchscreen) {
        focusableMode |= FOCUSABLES_TOUCH_MODE;
    }
    if ((descendantFocusability == FOCUS_BEFORE_DESCENDANTS) && focusSelf) {
        super.addFocusables(views, direction, focusableMode);
    }
    int count = 0;
    final View[] children = new View[mChildrenCount];
    for (int i = 0; i < mChildrenCount; ++i) {
        View child = mChildren[i];
        if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE) {
            children[count++] = child;
        }
    }
    FocusFinder.sort(children, 0, count, this, isLayoutRtl());
    for (int i = 0; i < count; ++i) {
        children[i].addFocusables(views, direction, focusableMode);
    }
    // among the focusable children would be more interesting.
    if ((descendantFocusability == FOCUS_AFTER_DESCENDANTS) && focusSelf && focusableCount == views.size()) {
        super.addFocusables(views, direction, focusableMode);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,Changes include:,  - A new if condition checking 'descendantFocusability' against 'FOCUS_BLOCK_DESCENDANTS' early in the method.
435,"<android.provider.Settings.NameValueCache: String getStringForUser(ContentResolver,String,int)>",25,26,"<android.provider.Settings.NameValueCache: String getStringForUser(ContentResolver,String,int)>","<android.provider.Settings.NameValueCache: String getStringForUser(ContentResolver,String,int)>",0,"{
    final boolean isSelf = (userHandle == UserHandle.myUserId());
    if (isSelf) {
        synchronized (NameValueCache.this) {
            if (mGenerationTracker != null) {
                if (mGenerationTracker.isGenerationChanged()) {
                    if (DEBUG) {
                        Log.i(TAG, ""Generation changed for type:"" + mUri.getPath() + "" in package:"" + cr.getPackageName() + "" and user:"" + userHandle);
                    }
                    mValues.clear();
                } else if (mValues.containsKey(name)) {
                    return mValues.get(name);
                }
            }
        }
    } else {
        if (LOCAL_LOGV)
            Log.v(TAG, ""get setting for user "" + userHandle + "" by user "" + UserHandle.myUserId() + "" so skipping cache"");
    }
    IContentProvider cp = lazyGetProvider(cr);
    // interface.
    if (mCallGetCommand != null) {
        try {
            Bundle args = null;
            if (!isSelf) {
                args = new Bundle();
                args.putInt(CALL_METHOD_USER_KEY, userHandle);
            }
            boolean needsGenerationTracker = false;
            synchronized (NameValueCache.this) {
                if (isSelf && mGenerationTracker == null) {
                    needsGenerationTracker = true;
                    if (args == null) {
                        args = new Bundle();
                    }
                    args.putString(CALL_METHOD_TRACK_GENERATION_KEY, null);
                    if (DEBUG) {
                        Log.i(TAG, ""Requested generation tracker for type: "" + mUri.getPath() + "" in package:"" + cr.getPackageName() + "" and user:"" + userHandle);
                    }
                }
            }
            Bundle b = cp.call(cr.getPackageName(), mCallGetCommand, name, args);
            if (b != null) {
                String value = b.getString(Settings.NameValueTable.VALUE);
                // Don't update our cache for reads of other users' data
                if (isSelf) {
                    synchronized (NameValueCache.this) {
                        if (needsGenerationTracker) {
                            MemoryIntArray array = b.getParcelable(CALL_METHOD_TRACK_GENERATION_KEY);
                            final int index = b.getInt(CALL_METHOD_GENERATION_INDEX_KEY, -1);
                            if (array != null && index >= 0) {
                                final int generation = b.getInt(CALL_METHOD_GENERATION_KEY, 0);
                                if (DEBUG) {
                                    Log.i(TAG, ""Received generation tracker for type:"" + mUri.getPath() + "" in package:"" + cr.getPackageName() + "" and user:"" + userHandle + "" with index:"" + index);
                                }
                                mGenerationTracker = new GenerationTracker(array, index, generation, () -> {
                                    synchronized (NameValueCache.this) {
                                        Log.e(TAG, ""Error accessing generation"" + "" tracker - removing"");
                                        if (mGenerationTracker != null) {
                                            GenerationTracker generationTracker = mGenerationTracker;
                                            mGenerationTracker = null;
                                            generationTracker.destroy();
                                            mValues.clear();
                                        }
                                    }
                                });
                            }
                        }
                        mValues.put(name, value);
                    }
                } else {
                    if (LOCAL_LOGV)
                        Log.i(TAG, ""call-query of user "" + userHandle + "" by "" + UserHandle.myUserId() + "" so not updating cache"");
                }
                return value;
            }
        // If the response Bundle is null, we fall through
        // to the query interface below.
        } catch (RemoteException e) {
        // Not supported by the remote side?  Fall through
        // to query().
        }
    }
    Cursor c = null;
    try {
        c = cp.query(cr.getPackageName(), mUri, SELECT_VALUE, NAME_EQ_PLACEHOLDER, new String[] { name }, null, null);
        if (c == null) {
            Log.w(TAG, ""Can't get key "" + name + "" from "" + mUri);
            return null;
        }
        String value = c.moveToNext() ? c.getString(0) : null;
        synchronized (NameValueCache.this) {
            mValues.put(name, value);
        }
        if (LOCAL_LOGV) {
            Log.v(TAG, ""cache miss ["" + mUri.getLastPathSegment() + ""]: "" + name + "" = "" + (value == null ? ""(null)"" : value));
        }
        return value;
    } catch (RemoteException e) {
        Log.w(TAG, ""Can't get key "" + name + "" from "" + mUri, e);
        // Return null, but don't cache it.
        return null;
    } finally {
        if (c != null)
            c.close();
    }
}","{
    final boolean isSelf = (userHandle == UserHandle.myUserId());
    if (isSelf) {
        synchronized (NameValueCache.this) {
            if (mGenerationTracker != null) {
                if (mGenerationTracker.isGenerationChanged()) {
                    if (DEBUG) {
                        Log.i(TAG, ""Generation changed for type:"" + mUri.getPath() + "" in package:"" + cr.getPackageName() + "" and user:"" + userHandle);
                    }
                    mValues.clear();
                } else if (mValues.containsKey(name)) {
                    return mValues.get(name);
                }
            }
        }
    } else {
        if (LOCAL_LOGV)
            Log.v(TAG, ""get setting for user "" + userHandle + "" by user "" + UserHandle.myUserId() + "" so skipping cache"");
    }
    IContentProvider cp = mProviderHolder.getProvider(cr);
    // interface.
    if (mCallGetCommand != null) {
        try {
            Bundle args = null;
            if (!isSelf) {
                args = new Bundle();
                args.putInt(CALL_METHOD_USER_KEY, userHandle);
            }
            boolean needsGenerationTracker = false;
            synchronized (NameValueCache.this) {
                if (isSelf && mGenerationTracker == null) {
                    needsGenerationTracker = true;
                    if (args == null) {
                        args = new Bundle();
                    }
                    args.putString(CALL_METHOD_TRACK_GENERATION_KEY, null);
                    if (DEBUG) {
                        Log.i(TAG, ""Requested generation tracker for type: "" + mUri.getPath() + "" in package:"" + cr.getPackageName() + "" and user:"" + userHandle);
                    }
                }
            }
            Bundle b;
            // clearCallingIdentity or use a ContentResolver from the caller as needed.
            if (Settings.isInSystemServer() && Binder.getCallingUid() != Process.myUid()) {
                final long token = Binder.clearCallingIdentity();
                try {
                    b = cp.call(cr.getPackageName(), mCallGetCommand, name, args);
                } finally {
                    Binder.restoreCallingIdentity(token);
                }
            } else {
                b = cp.call(cr.getPackageName(), mCallGetCommand, name, args);
            }
            if (b != null) {
                String value = b.getString(Settings.NameValueTable.VALUE);
                // Don't update our cache for reads of other users' data
                if (isSelf) {
                    synchronized (NameValueCache.this) {
                        if (needsGenerationTracker) {
                            MemoryIntArray array = b.getParcelable(CALL_METHOD_TRACK_GENERATION_KEY);
                            final int index = b.getInt(CALL_METHOD_GENERATION_INDEX_KEY, -1);
                            if (array != null && index >= 0) {
                                final int generation = b.getInt(CALL_METHOD_GENERATION_KEY, 0);
                                if (DEBUG) {
                                    Log.i(TAG, ""Received generation tracker for type:"" + mUri.getPath() + "" in package:"" + cr.getPackageName() + "" and user:"" + userHandle + "" with index:"" + index);
                                }
                                if (mGenerationTracker != null) {
                                    mGenerationTracker.destroy();
                                }
                                mGenerationTracker = new GenerationTracker(array, index, generation, () -> {
                                    synchronized (NameValueCache.this) {
                                        Log.e(TAG, ""Error accessing generation"" + "" tracker - removing"");
                                        if (mGenerationTracker != null) {
                                            GenerationTracker generationTracker = mGenerationTracker;
                                            mGenerationTracker = null;
                                            generationTracker.destroy();
                                            mValues.clear();
                                        }
                                    }
                                });
                            }
                        }
                        mValues.put(name, value);
                    }
                } else {
                    if (LOCAL_LOGV)
                        Log.i(TAG, ""call-query of user "" + userHandle + "" by "" + UserHandle.myUserId() + "" so not updating cache"");
                }
                return value;
            }
        // If the response Bundle is null, we fall through
        // to the query interface below.
        } catch (RemoteException e) {
        // Not supported by the remote side?  Fall through
        // to query().
        }
    }
    Cursor c = null;
    try {
        Bundle queryArgs = ContentResolver.createSqlQueryBundle(NAME_EQ_PLACEHOLDER, new String[] { name }, null);
        // Same workaround as above.
        if (Settings.isInSystemServer() && Binder.getCallingUid() != Process.myUid()) {
            final long token = Binder.clearCallingIdentity();
            try {
                c = cp.query(cr.getPackageName(), mUri, SELECT_VALUE_PROJECTION, queryArgs, null);
            } finally {
                Binder.restoreCallingIdentity(token);
            }
        } else {
            c = cp.query(cr.getPackageName(), mUri, SELECT_VALUE_PROJECTION, queryArgs, null);
        }
        if (c == null) {
            Log.w(TAG, ""Can't get key "" + name + "" from "" + mUri);
            return null;
        }
        String value = c.moveToNext() ? c.getString(0) : null;
        synchronized (NameValueCache.this) {
            mValues.put(name, value);
        }
        if (LOCAL_LOGV) {
            Log.v(TAG, ""cache miss ["" + mUri.getLastPathSegment() + ""]: "" + name + "" = "" + (value == null ? ""(null)"" : value));
        }
        return value;
    } catch (RemoteException e) {
        Log.w(TAG, ""Can't get key "" + name + "" from "" + mUri, e);
        // Return null, but don't cache it.
        return null;
    } finally {
        if (c != null)
            c.close();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
436,<android.net.NetworkCapabilities: String toString()>,25,26,<android.net.NetworkCapabilities: String toString()>,<android.net.NetworkCapabilities: String toString()>,0,"{
    int[] types = getTransportTypes();
    String transports = (types.length > 0) ? "" Transports: "" + transportNamesOf(types) : """";
    types = getCapabilities();
    String capabilities = (types.length > 0 ? "" Capabilities: "" : """");
    for (int i = 0; i < types.length; ) {
        switch(types[i]) {
            case NET_CAPABILITY_MMS:
                capabilities += ""MMS"";
                break;
            case NET_CAPABILITY_SUPL:
                capabilities += ""SUPL"";
                break;
            case NET_CAPABILITY_DUN:
                capabilities += ""DUN"";
                break;
            case NET_CAPABILITY_FOTA:
                capabilities += ""FOTA"";
                break;
            case NET_CAPABILITY_IMS:
                capabilities += ""IMS"";
                break;
            case NET_CAPABILITY_CBS:
                capabilities += ""CBS"";
                break;
            case NET_CAPABILITY_WIFI_P2P:
                capabilities += ""WIFI_P2P"";
                break;
            case NET_CAPABILITY_IA:
                capabilities += ""IA"";
                break;
            case NET_CAPABILITY_RCS:
                capabilities += ""RCS"";
                break;
            case NET_CAPABILITY_XCAP:
                capabilities += ""XCAP"";
                break;
            case NET_CAPABILITY_EIMS:
                capabilities += ""EIMS"";
                break;
            case NET_CAPABILITY_NOT_METERED:
                capabilities += ""NOT_METERED"";
                break;
            case NET_CAPABILITY_INTERNET:
                capabilities += ""INTERNET"";
                break;
            case NET_CAPABILITY_NOT_RESTRICTED:
                capabilities += ""NOT_RESTRICTED"";
                break;
            case NET_CAPABILITY_TRUSTED:
                capabilities += ""TRUSTED"";
                break;
            case NET_CAPABILITY_NOT_VPN:
                capabilities += ""NOT_VPN"";
                break;
            case NET_CAPABILITY_VALIDATED:
                capabilities += ""VALIDATED"";
                break;
            case NET_CAPABILITY_CAPTIVE_PORTAL:
                capabilities += ""CAPTIVE_PORTAL"";
                break;
        }
        if (++i < types.length)
            capabilities += ""&"";
    }
    String upBand = ((mLinkUpBandwidthKbps > 0) ? "" LinkUpBandwidth>="" + mLinkUpBandwidthKbps + ""Kbps"" : """");
    String dnBand = ((mLinkDownBandwidthKbps > 0) ? "" LinkDnBandwidth>="" + mLinkDownBandwidthKbps + ""Kbps"" : """");
    String specifier = (mNetworkSpecifier == null ? """" : "" Specifier: <"" + mNetworkSpecifier + "">"");
    String signalStrength = (hasSignalStrength() ? "" SignalStrength: "" + mSignalStrength : """");
    return ""["" + transports + capabilities + upBand + dnBand + specifier + signalStrength + ""]"";
}","{
    int[] types = getTransportTypes();
    String transports = (types.length > 0) ? "" Transports: "" + transportNamesOf(types) : """";
    types = getCapabilities();
    String capabilities = (types.length > 0 ? "" Capabilities: "" : """");
    for (int i = 0; i < types.length; ) {
        switch(types[i]) {
            case NET_CAPABILITY_MMS:
                capabilities += ""MMS"";
                break;
            case NET_CAPABILITY_SUPL:
                capabilities += ""SUPL"";
                break;
            case NET_CAPABILITY_DUN:
                capabilities += ""DUN"";
                break;
            case NET_CAPABILITY_FOTA:
                capabilities += ""FOTA"";
                break;
            case NET_CAPABILITY_IMS:
                capabilities += ""IMS"";
                break;
            case NET_CAPABILITY_CBS:
                capabilities += ""CBS"";
                break;
            case NET_CAPABILITY_WIFI_P2P:
                capabilities += ""WIFI_P2P"";
                break;
            case NET_CAPABILITY_IA:
                capabilities += ""IA"";
                break;
            case NET_CAPABILITY_RCS:
                capabilities += ""RCS"";
                break;
            case NET_CAPABILITY_XCAP:
                capabilities += ""XCAP"";
                break;
            case NET_CAPABILITY_EIMS:
                capabilities += ""EIMS"";
                break;
            case NET_CAPABILITY_NOT_METERED:
                capabilities += ""NOT_METERED"";
                break;
            case NET_CAPABILITY_INTERNET:
                capabilities += ""INTERNET"";
                break;
            case NET_CAPABILITY_NOT_RESTRICTED:
                capabilities += ""NOT_RESTRICTED"";
                break;
            case NET_CAPABILITY_TRUSTED:
                capabilities += ""TRUSTED"";
                break;
            case NET_CAPABILITY_NOT_VPN:
                capabilities += ""NOT_VPN"";
                break;
            case NET_CAPABILITY_VALIDATED:
                capabilities += ""VALIDATED"";
                break;
            case NET_CAPABILITY_CAPTIVE_PORTAL:
                capabilities += ""CAPTIVE_PORTAL"";
                break;
            case NET_CAPABILITY_FOREGROUND:
                capabilities += ""FOREGROUND"";
                break;
        }
        if (++i < types.length)
            capabilities += ""&"";
    }
    String upBand = ((mLinkUpBandwidthKbps > 0) ? "" LinkUpBandwidth>="" + mLinkUpBandwidthKbps + ""Kbps"" : """");
    String dnBand = ((mLinkDownBandwidthKbps > 0) ? "" LinkDnBandwidth>="" + mLinkDownBandwidthKbps + ""Kbps"" : """");
    String specifier = (mNetworkSpecifier == null ? """" : "" Specifier: <"" + mNetworkSpecifier + "">"");
    String signalStrength = (hasSignalStrength() ? "" SignalStrength: "" + mSignalStrength : """");
    return ""["" + transports + capabilities + upBand + dnBand + specifier + signalStrength + ""]"";
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
437,"<android.bluetooth.BluetoothGattServer: boolean notifyCharacteristicChanged(BluetoothDevice,BluetoothGattCharacteristic,boolean)>",25,26,"<android.bluetooth.BluetoothGattServer: boolean notifyCharacteristicChanged(BluetoothDevice,BluetoothGattCharacteristic,boolean)>","<android.bluetooth.BluetoothGattServer: boolean notifyCharacteristicChanged(BluetoothDevice,BluetoothGattCharacteristic,boolean)>",0,"{
    if (VDBG)
        Log.d(TAG, ""notifyCharacteristicChanged() - device: "" + device.getAddress());
    if (mService == null || mServerIf == 0)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    if (characteristic.getValue() == null) {
        throw new IllegalArgumentException(""Chracteristic value is empty. Use "" + ""BluetoothGattCharacteristic#setvalue to update"");
    }
    try {
        mService.sendNotification(mServerIf, device.getAddress(), service.getType(), service.getInstanceId(), new ParcelUuid(service.getUuid()), characteristic.getInstanceId(), new ParcelUuid(characteristic.getUuid()), confirm, characteristic.getValue());
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        return false;
    }
    return true;
}","{
    if (VDBG)
        Log.d(TAG, ""notifyCharacteristicChanged() - device: "" + device.getAddress());
    if (mService == null || mServerIf == 0)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    if (characteristic.getValue() == null) {
        throw new IllegalArgumentException(""Chracteristic value is empty. Use "" + ""BluetoothGattCharacteristic#setvalue to update"");
    }
    try {
        mService.sendNotification(mServerIf, device.getAddress(), characteristic.getInstanceId(), confirm, characteristic.getValue());
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        return false;
    }
    return true;
}",1,"/**
 * Send a notification or indication that a local characteristic has been
 * updated.
 *
 * <p>A notification or indication is sent to the remote device to signal
 * that the characteristic has been updated. This function should be invoked
 * for every client that requests notifications/indications by writing
 * to the ""Client Configuration"" descriptor for the given characteristic.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param device The remote device to receive the notification/indication
 * @param characteristic The local characteristic that has been updated
 * @param confirm true to request confirmation from the client (indication),
 * false to send a notification
 * @throws IllegalArgumentException
 * @return true, if the notification has been triggered successfully
 */
","/**
 * Send a notification or indication that a local characteristic has been
 * updated.
 *
 * <p>A notification or indication is sent to the remote device to signal
 * that the characteristic has been updated. This function should be invoked
 * for every client that requests notifications/indications by writing
 * to the ""Client Configuration"" descriptor for the given characteristic.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param device The remote device to receive the notification/indication
 * @param characteristic The local characteristic that has been updated
 * @param confirm true to request confirmation from the client (indication),
 * false to send a notification
 * @throws IllegalArgumentException
 * @return true, if the notification has been triggered successfully
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The signature of the method sendNotification within notifyCharacteristicChanged has changed. In the early version, it takes seven parameters, but in the late version, it only takes five, eliminating the service type, service instance ID, and the UUID. Thus, the change type is 1,5 (Return statement change and Dependent API change).","Since the dependent method sendNotification has fewer parameters in the late version, the method behavior might be different, which could potentially result in a different return value. This constitutes a compatibility issue of type 1 (CI caused by potential different return values or types)."
438,<android.widget.SlidingDrawer: boolean onTouchEvent(MotionEvent)>,25,26,<android.widget.SlidingDrawer: boolean onTouchEvent(MotionEvent)>,<android.widget.SlidingDrawer: boolean onTouchEvent(MotionEvent)>,0,"{
    if (mLocked) {
        return true;
    }
    if (mTracking) {
        mVelocityTracker.addMovement(event);
        final int action = event.getAction();
        switch(action) {
            case MotionEvent.ACTION_MOVE:
                moveHandle((int) (mVertical ? event.getY() : event.getX()) - mTouchDelta);
                break;
            case MotionEvent.ACTION_UP:
            case MotionEvent.ACTION_CANCEL:
                {
                    final VelocityTracker velocityTracker = mVelocityTracker;
                    velocityTracker.computeCurrentVelocity(mVelocityUnits);
                    float yVelocity = velocityTracker.getYVelocity();
                    float xVelocity = velocityTracker.getXVelocity();
                    boolean negative;
                    final boolean vertical = mVertical;
                    if (vertical) {
                        negative = yVelocity < 0;
                        if (xVelocity < 0) {
                            xVelocity = -xVelocity;
                        }
                        if (xVelocity > mMaximumMinorVelocity) {
                            xVelocity = mMaximumMinorVelocity;
                        }
                    } else {
                        negative = xVelocity < 0;
                        if (yVelocity < 0) {
                            yVelocity = -yVelocity;
                        }
                        if (yVelocity > mMaximumMinorVelocity) {
                            yVelocity = mMaximumMinorVelocity;
                        }
                    }
                    float velocity = (float) Math.hypot(xVelocity, yVelocity);
                    if (negative) {
                        velocity = -velocity;
                    }
                    final int top = mHandle.getTop();
                    final int left = mHandle.getLeft();
                    if (Math.abs(velocity) < mMaximumTapVelocity) {
                        if (vertical ? (mExpanded && top < mTapThreshold + mTopOffset) || (!mExpanded && top > mBottomOffset + mBottom - mTop - mHandleHeight - mTapThreshold) : (mExpanded && left < mTapThreshold + mTopOffset) || (!mExpanded && left > mBottomOffset + mRight - mLeft - mHandleWidth - mTapThreshold)) {
                            if (mAllowSingleTap) {
                                playSoundEffect(SoundEffectConstants.CLICK);
                                if (mExpanded) {
                                    animateClose(vertical ? top : left);
                                } else {
                                    animateOpen(vertical ? top : left);
                                }
                            } else {
                                performFling(vertical ? top : left, velocity, false);
                            }
                        } else {
                            performFling(vertical ? top : left, velocity, false);
                        }
                    } else {
                        performFling(vertical ? top : left, velocity, false);
                    }
                }
                break;
        }
    }
    return mTracking || mAnimating || super.onTouchEvent(event);
}","{
    if (mLocked) {
        return true;
    }
    if (mTracking) {
        mVelocityTracker.addMovement(event);
        final int action = event.getAction();
        switch(action) {
            case MotionEvent.ACTION_MOVE:
                moveHandle((int) (mVertical ? event.getY() : event.getX()) - mTouchDelta);
                break;
            case MotionEvent.ACTION_UP:
            case MotionEvent.ACTION_CANCEL:
                {
                    final VelocityTracker velocityTracker = mVelocityTracker;
                    velocityTracker.computeCurrentVelocity(mVelocityUnits);
                    float yVelocity = velocityTracker.getYVelocity();
                    float xVelocity = velocityTracker.getXVelocity();
                    boolean negative;
                    final boolean vertical = mVertical;
                    if (vertical) {
                        negative = yVelocity < 0;
                        if (xVelocity < 0) {
                            xVelocity = -xVelocity;
                        }
                        if (xVelocity > mMaximumMinorVelocity) {
                            xVelocity = mMaximumMinorVelocity;
                        }
                    } else {
                        negative = xVelocity < 0;
                        if (yVelocity < 0) {
                            yVelocity = -yVelocity;
                        }
                        if (yVelocity > mMaximumMinorVelocity) {
                            yVelocity = mMaximumMinorVelocity;
                        }
                    }
                    float velocity = (float) Math.hypot(xVelocity, yVelocity);
                    if (negative) {
                        velocity = -velocity;
                    }
                    final int top = mHandle.getTop();
                    final int left = mHandle.getLeft();
                    if (Math.abs(velocity) < mMaximumTapVelocity) {
                        if (vertical ? (mExpanded && top < mTapThreshold + mTopOffset) || (!mExpanded && top > mBottomOffset + mBottom - mTop - mHandleHeight - mTapThreshold) : (mExpanded && left < mTapThreshold + mTopOffset) || (!mExpanded && left > mBottomOffset + mRight - mLeft - mHandleWidth - mTapThreshold)) {
                            if (mAllowSingleTap) {
                                playSoundEffect(SoundEffectConstants.CLICK);
                                if (mExpanded) {
                                    animateClose(vertical ? top : left, true);
                                } else {
                                    animateOpen(vertical ? top : left, true);
                                }
                            } else {
                                performFling(vertical ? top : left, velocity, false, true);
                            }
                        } else {
                            performFling(vertical ? top : left, velocity, false, true);
                        }
                    } else {
                        performFling(vertical ? top : left, velocity, false, true);
                    }
                }
                break;
        }
    }
    return mTracking || mAnimating || super.onTouchEvent(event);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
439,<android.widget.TextView: boolean moveCursorToVisibleOffset()>,25,26,<android.widget.TextView: boolean moveCursorToVisibleOffset()>,<android.widget.TextView: boolean moveCursorToVisibleOffset()>,0,"{
    if (!(mText instanceof Spannable)) {
        return false;
    }
    int start = getSelectionStart();
    int end = getSelectionEnd();
    if (start != end) {
        return false;
    }
    // First: make sure the line is visible on screen:
    int line = mLayout.getLineForOffset(start);
    final int top = mLayout.getLineTop(line);
    final int bottom = mLayout.getLineTop(line + 1);
    final int vspace = mBottom - mTop - getExtendedPaddingTop() - getExtendedPaddingBottom();
    int vslack = (bottom - top) / 2;
    if (vslack > vspace / 4)
        vslack = vspace / 4;
    final int vs = mScrollY;
    if (top < (vs + vslack)) {
        line = mLayout.getLineForVertical(vs + vslack + (bottom - top));
    } else if (bottom > (vspace + vs - vslack)) {
        line = mLayout.getLineForVertical(vspace + vs - vslack - (bottom - top));
    }
    // Next: make sure the character is visible on screen:
    final int hspace = mRight - mLeft - getCompoundPaddingLeft() - getCompoundPaddingRight();
    final int hs = mScrollX;
    final int leftChar = mLayout.getOffsetForHorizontal(line, hs);
    final int rightChar = mLayout.getOffsetForHorizontal(line, hspace + hs);
    // line might contain bidirectional text
    final int lowChar = leftChar < rightChar ? leftChar : rightChar;
    final int highChar = leftChar > rightChar ? leftChar : rightChar;
    int newStart = start;
    if (newStart < lowChar) {
        newStart = lowChar;
    } else if (newStart > highChar) {
        newStart = highChar;
    }
    if (newStart != start) {
        Selection.setSelection((Spannable) mText, newStart);
        return true;
    }
    return false;
}","{
    if (!(mText instanceof Spannable)) {
        return false;
    }
    int start = getSelectionStart();
    int end = getSelectionEnd();
    if (start != end) {
        return false;
    }
    // First: make sure the line is visible on screen:
    int line = mLayout.getLineForOffset(start);
    final int top = mLayout.getLineTop(line);
    final int bottom = mLayout.getLineTop(line + 1);
    final int vspace = mBottom - mTop - getExtendedPaddingTop() - getExtendedPaddingBottom();
    int vslack = (bottom - top) / 2;
    if (vslack > vspace / 4) {
        vslack = vspace / 4;
    }
    final int vs = mScrollY;
    if (top < (vs + vslack)) {
        line = mLayout.getLineForVertical(vs + vslack + (bottom - top));
    } else if (bottom > (vspace + vs - vslack)) {
        line = mLayout.getLineForVertical(vspace + vs - vslack - (bottom - top));
    }
    // Next: make sure the character is visible on screen:
    final int hspace = mRight - mLeft - getCompoundPaddingLeft() - getCompoundPaddingRight();
    final int hs = mScrollX;
    final int leftChar = mLayout.getOffsetForHorizontal(line, hs);
    final int rightChar = mLayout.getOffsetForHorizontal(line, hspace + hs);
    // line might contain bidirectional text
    final int lowChar = leftChar < rightChar ? leftChar : rightChar;
    final int highChar = leftChar > rightChar ? leftChar : rightChar;
    int newStart = start;
    if (newStart < lowChar) {
        newStart = lowChar;
    } else if (newStart > highChar) {
        newStart = highChar;
    }
    if (newStart != start) {
        Selection.setSelection((Spannable) mText, newStart);
        return true;
    }
    return false;
}",1,"/**
 * Move the cursor, if needed, so that it is at an offset that is visible
 * to the user.  This will not move the cursor if it represents more than
 * one character (a selection range).  This will only work if the
 * TextView contains spannable text; otherwise it will do nothing.
 *
 * @return True if the cursor was actually moved, false otherwise.
 */
","/**
 * Move the cursor, if needed, so that it is at an offset that is visible
 * to the user.  This will not move the cursor if it represents more than
 * one character (a selection range).  This will only work if the
 * TextView contains spannable text; otherwise it will do nothing.
 *
 * @return True if the cursor was actually moved, false otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"There is no difference between the early and late version implementations of the method, so there is no change.","Since there is no code change between the versions, no Compatibility Issue could arise."
440,"<android.content.ContentResolver: void releasePersistableUriPermission(Uri,int)>",25,26,"<android.content.ContentResolver: void releasePersistableUriPermission(Uri,int)>","<android.content.ContentResolver: void releasePersistableUriPermission(Uri,int)>",0,"{
    Preconditions.checkNotNull(uri, ""uri"");
    try {
        ActivityManagerNative.getDefault().releasePersistableUriPermission(ContentProvider.getUriWithoutUserId(uri), modeFlags, resolveUserId(uri));
    } catch (RemoteException e) {
    }
}","{
    Preconditions.checkNotNull(uri, ""uri"");
    try {
        ActivityManager.getService().releasePersistableUriPermission(ContentProvider.getUriWithoutUserId(uri), modeFlags, resolveUserId(uri));
    } catch (RemoteException e) {
    }
}",1,"/**
 * Relinquish a persisted URI permission grant. The URI must have been
 * previously made persistent with
 * {@link #takePersistableUriPermission(Uri, int)}. Any non-persistent
 * grants to the calling package will remain intact.
 *
 * @see #getPersistedUriPermissions()
 */
","/**
 * Relinquish a persisted URI permission grant. The URI must have been
 * previously made persistent with
 * {@link #takePersistableUriPermission(Uri, int)}. Any non-persistent
 * grants to the calling package will remain intact.
 *
 * @see #getPersistedUriPermissions()
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent API call within the try block has changed from ActivityManagerNative.getDefault() to ActivityManager.getService(), so the code change type is 5.","The change in the dependent API call does not affect how the method behaves in terms of returns or exception throwing; thus, there is no compatibility issue introduced by this change. The method body's control flow and exception handling remain unaltered, guaranteeing that clients expecting a certain behavior will not encounter any compatibility issues due solely to this modification. Therefore, there is no CI."
441,<android.widget.ListView: void layoutChildren()>,25,26,<android.widget.ListView: void layoutChildren()>,<android.widget.ListView: void layoutChildren()>,0,"{
    final boolean blockLayoutRequests = mBlockLayoutRequests;
    if (blockLayoutRequests) {
        return;
    }
    mBlockLayoutRequests = true;
    try {
        super.layoutChildren();
        invalidate();
        if (mAdapter == null) {
            resetList();
            invokeOnItemScrollListener();
            return;
        }
        final int childrenTop = mListPadding.top;
        final int childrenBottom = mBottom - mTop - mListPadding.bottom;
        final int childCount = getChildCount();
        int index = 0;
        int delta = 0;
        View sel;
        View oldSel = null;
        View oldFirst = null;
        View newSel = null;
        // Remember stuff we will need down below
        switch(mLayoutMode) {
            case LAYOUT_SET_SELECTION:
                index = mNextSelectedPosition - mFirstPosition;
                if (index >= 0 && index < childCount) {
                    newSel = getChildAt(index);
                }
                break;
            case LAYOUT_FORCE_TOP:
            case LAYOUT_FORCE_BOTTOM:
            case LAYOUT_SPECIFIC:
            case LAYOUT_SYNC:
                break;
            case LAYOUT_MOVE_SELECTION:
            default:
                // Remember the previously selected view
                index = mSelectedPosition - mFirstPosition;
                if (index >= 0 && index < childCount) {
                    oldSel = getChildAt(index);
                }
                // Remember the previous first child
                oldFirst = getChildAt(0);
                if (mNextSelectedPosition >= 0) {
                    delta = mNextSelectedPosition - mSelectedPosition;
                }
                // Caution: newSel might be null
                newSel = getChildAt(index + delta);
        }
        boolean dataChanged = mDataChanged;
        if (dataChanged) {
            handleDataChanged();
        }
        // and calling it a day
        if (mItemCount == 0) {
            resetList();
            invokeOnItemScrollListener();
            return;
        } else if (mItemCount != mAdapter.getCount()) {
            throw new IllegalStateException(""The content of the adapter has changed but "" + ""ListView did not receive a notification. Make sure the content of "" + ""your adapter is not modified from a background thread, but only from "" + ""the UI thread. Make sure your adapter calls notifyDataSetChanged() "" + ""when its content changes. [in ListView("" + getId() + "", "" + getClass() + "") with Adapter("" + mAdapter.getClass() + "")]"");
        }
        setSelectedPositionInt(mNextSelectedPosition);
        AccessibilityNodeInfo accessibilityFocusLayoutRestoreNode = null;
        View accessibilityFocusLayoutRestoreView = null;
        int accessibilityFocusPosition = INVALID_POSITION;
        // Remember which child, if any, had accessibility focus. This must
        // occur before recycling any views, since that will clear
        // accessibility focus.
        final ViewRootImpl viewRootImpl = getViewRootImpl();
        if (viewRootImpl != null) {
            final View focusHost = viewRootImpl.getAccessibilityFocusedHost();
            if (focusHost != null) {
                final View focusChild = getAccessibilityFocusedChild(focusHost);
                if (focusChild != null) {
                    if (!dataChanged || isDirectChildHeaderOrFooter(focusChild) || focusChild.hasTransientState() || mAdapterHasStableIds) {
                        // The views won't be changing, so try to maintain
                        // focus on the current host and virtual view.
                        accessibilityFocusLayoutRestoreView = focusHost;
                        accessibilityFocusLayoutRestoreNode = viewRootImpl.getAccessibilityFocusedVirtualView();
                    }
                    // If all else fails, maintain focus at the same
                    // position.
                    accessibilityFocusPosition = getPositionForView(focusChild);
                }
            }
        }
        View focusLayoutRestoreDirectChild = null;
        View focusLayoutRestoreView = null;
        // Take focus back to us temporarily to avoid the eventual call to
        // clear focus when removing the focused child below from messing
        // things up when ViewAncestor assigns focus back to someone else.
        final View focusedChild = getFocusedChild();
        if (focusedChild != null) {
            // header or footer.
            if (!dataChanged || isDirectChildHeaderOrFooter(focusedChild) || focusedChild.hasTransientState() || mAdapterHasStableIds) {
                focusLayoutRestoreDirectChild = focusedChild;
                // Remember the specific view that had focus.
                focusLayoutRestoreView = findFocus();
                if (focusLayoutRestoreView != null) {
                    // Tell it we are going to mess with it.
                    focusLayoutRestoreView.dispatchStartTemporaryDetach();
                }
            }
            requestFocus();
        }
        // Pull all children into the RecycleBin.
        // These views will be reused if possible
        final int firstPosition = mFirstPosition;
        final RecycleBin recycleBin = mRecycler;
        if (dataChanged) {
            for (int i = 0; i < childCount; i++) {
                recycleBin.addScrapView(getChildAt(i), firstPosition + i);
            }
        } else {
            recycleBin.fillActiveViews(childCount, firstPosition);
        }
        // Clear out old views
        detachAllViewsFromParent();
        recycleBin.removeSkippedScrap();
        switch(mLayoutMode) {
            case LAYOUT_SET_SELECTION:
                if (newSel != null) {
                    sel = fillFromSelection(newSel.getTop(), childrenTop, childrenBottom);
                } else {
                    sel = fillFromMiddle(childrenTop, childrenBottom);
                }
                break;
            case LAYOUT_SYNC:
                sel = fillSpecific(mSyncPosition, mSpecificTop);
                break;
            case LAYOUT_FORCE_BOTTOM:
                sel = fillUp(mItemCount - 1, childrenBottom);
                adjustViewsUpOrDown();
                break;
            case LAYOUT_FORCE_TOP:
                mFirstPosition = 0;
                sel = fillFromTop(childrenTop);
                adjustViewsUpOrDown();
                break;
            case LAYOUT_SPECIFIC:
                final int selectedPosition = reconcileSelectedPosition();
                sel = fillSpecific(selectedPosition, mSpecificTop);
                /**
                 * When ListView is resized, FocusSelector requests an async selection for the
                 * previously focused item to make sure it is still visible. If the item is not
                 * selectable, it won't regain focus so instead we call FocusSelector
                 * to directly request focus on the view after it is visible.
                 */
                if (sel == null && mFocusSelector != null) {
                    final Runnable focusRunnable = mFocusSelector.setupFocusIfValid(selectedPosition);
                    if (focusRunnable != null) {
                        post(focusRunnable);
                    }
                }
                break;
            case LAYOUT_MOVE_SELECTION:
                sel = moveSelection(oldSel, newSel, delta, childrenTop, childrenBottom);
                break;
            default:
                if (childCount == 0) {
                    if (!mStackFromBottom) {
                        final int position = lookForSelectablePosition(0, true);
                        setSelectedPositionInt(position);
                        sel = fillFromTop(childrenTop);
                    } else {
                        final int position = lookForSelectablePosition(mItemCount - 1, false);
                        setSelectedPositionInt(position);
                        sel = fillUp(mItemCount - 1, childrenBottom);
                    }
                } else {
                    if (mSelectedPosition >= 0 && mSelectedPosition < mItemCount) {
                        sel = fillSpecific(mSelectedPosition, oldSel == null ? childrenTop : oldSel.getTop());
                    } else if (mFirstPosition < mItemCount) {
                        sel = fillSpecific(mFirstPosition, oldFirst == null ? childrenTop : oldFirst.getTop());
                    } else {
                        sel = fillSpecific(0, childrenTop);
                    }
                }
                break;
        }
        // Flush any cached views that did not get reused above
        recycleBin.scrapActiveViews();
        // remove any header/footer that has been temp detached and not re-attached
        removeUnusedFixedViews(mHeaderViewInfos);
        removeUnusedFixedViews(mFooterViewInfos);
        if (sel != null) {
            // focusable.
            if (mItemsCanFocus && hasFocus() && !sel.hasFocus()) {
                final boolean focusWasTaken = (sel == focusLayoutRestoreDirectChild && focusLayoutRestoreView != null && focusLayoutRestoreView.requestFocus()) || sel.requestFocus();
                if (!focusWasTaken) {
                    // Selected item didn't take focus, but we still want to
                    // make sure something else outside of the selected view
                    // has focus.
                    final View focused = getFocusedChild();
                    if (focused != null) {
                        focused.clearFocus();
                    }
                    positionSelector(INVALID_POSITION, sel);
                } else {
                    sel.setSelected(false);
                    mSelectorRect.setEmpty();
                }
            } else {
                positionSelector(INVALID_POSITION, sel);
            }
            mSelectedTop = sel.getTop();
        } else {
            final boolean inTouchMode = mTouchMode == TOUCH_MODE_TAP || mTouchMode == TOUCH_MODE_DONE_WAITING;
            if (inTouchMode) {
                // If the user's finger is down, select the motion position.
                final View child = getChildAt(mMotionPosition - mFirstPosition);
                if (child != null) {
                    positionSelector(mMotionPosition, child);
                }
            } else if (mSelectorPosition != INVALID_POSITION) {
                // If we had previously positioned the selector somewhere,
                // put it back there. It might not match up with the data,
                // but it's transitioning out so it's not a big deal.
                final View child = getChildAt(mSelectorPosition - mFirstPosition);
                if (child != null) {
                    positionSelector(mSelectorPosition, child);
                }
            } else {
                // Otherwise, clear selection.
                mSelectedTop = 0;
                mSelectorRect.setEmpty();
            }
            // restore focus (i.e. something focusable in touch mode).
            if (hasFocus() && focusLayoutRestoreView != null) {
                focusLayoutRestoreView.requestFocus();
            }
        }
        // Attempt to restore accessibility focus, if necessary.
        if (viewRootImpl != null) {
            final View newAccessibilityFocusedView = viewRootImpl.getAccessibilityFocusedHost();
            if (newAccessibilityFocusedView == null) {
                if (accessibilityFocusLayoutRestoreView != null && accessibilityFocusLayoutRestoreView.isAttachedToWindow()) {
                    final AccessibilityNodeProvider provider = accessibilityFocusLayoutRestoreView.getAccessibilityNodeProvider();
                    if (accessibilityFocusLayoutRestoreNode != null && provider != null) {
                        final int virtualViewId = AccessibilityNodeInfo.getVirtualDescendantId(accessibilityFocusLayoutRestoreNode.getSourceNodeId());
                        provider.performAction(virtualViewId, AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS, null);
                    } else {
                        accessibilityFocusLayoutRestoreView.requestAccessibilityFocus();
                    }
                } else if (accessibilityFocusPosition != INVALID_POSITION) {
                    // Bound the position within the visible children.
                    final int position = MathUtils.constrain(accessibilityFocusPosition - mFirstPosition, 0, getChildCount() - 1);
                    final View restoreView = getChildAt(position);
                    if (restoreView != null) {
                        restoreView.requestAccessibilityFocus();
                    }
                }
            }
        }
        // our view hierarchy.
        if (focusLayoutRestoreView != null && focusLayoutRestoreView.getWindowToken() != null) {
            focusLayoutRestoreView.dispatchFinishTemporaryDetach();
        }
        mLayoutMode = LAYOUT_NORMAL;
        mDataChanged = false;
        if (mPositionScrollAfterLayout != null) {
            post(mPositionScrollAfterLayout);
            mPositionScrollAfterLayout = null;
        }
        mNeedSync = false;
        setNextSelectedPositionInt(mSelectedPosition);
        updateScrollIndicators();
        if (mItemCount > 0) {
            checkSelectionChanged();
        }
        invokeOnItemScrollListener();
    } finally {
        if (mFocusSelector != null) {
            mFocusSelector.onLayoutComplete();
        }
        if (!blockLayoutRequests) {
            mBlockLayoutRequests = false;
        }
    }
}","{
    final boolean blockLayoutRequests = mBlockLayoutRequests;
    if (blockLayoutRequests) {
        return;
    }
    mBlockLayoutRequests = true;
    try {
        super.layoutChildren();
        invalidate();
        if (mAdapter == null) {
            resetList();
            invokeOnItemScrollListener();
            return;
        }
        final int childrenTop = mListPadding.top;
        final int childrenBottom = mBottom - mTop - mListPadding.bottom;
        final int childCount = getChildCount();
        int index = 0;
        int delta = 0;
        View sel;
        View oldSel = null;
        View oldFirst = null;
        View newSel = null;
        // Remember stuff we will need down below
        switch(mLayoutMode) {
            case LAYOUT_SET_SELECTION:
                index = mNextSelectedPosition - mFirstPosition;
                if (index >= 0 && index < childCount) {
                    newSel = getChildAt(index);
                }
                break;
            case LAYOUT_FORCE_TOP:
            case LAYOUT_FORCE_BOTTOM:
            case LAYOUT_SPECIFIC:
            case LAYOUT_SYNC:
                break;
            case LAYOUT_MOVE_SELECTION:
            default:
                // Remember the previously selected view
                index = mSelectedPosition - mFirstPosition;
                if (index >= 0 && index < childCount) {
                    oldSel = getChildAt(index);
                }
                // Remember the previous first child
                oldFirst = getChildAt(0);
                if (mNextSelectedPosition >= 0) {
                    delta = mNextSelectedPosition - mSelectedPosition;
                }
                // Caution: newSel might be null
                newSel = getChildAt(index + delta);
        }
        boolean dataChanged = mDataChanged;
        if (dataChanged) {
            handleDataChanged();
        }
        // and calling it a day
        if (mItemCount == 0) {
            resetList();
            invokeOnItemScrollListener();
            return;
        } else if (mItemCount != mAdapter.getCount()) {
            throw new IllegalStateException(""The content of the adapter has changed but "" + ""ListView did not receive a notification. Make sure the content of "" + ""your adapter is not modified from a background thread, but only from "" + ""the UI thread. Make sure your adapter calls notifyDataSetChanged() "" + ""when its content changes. [in ListView("" + getId() + "", "" + getClass() + "") with Adapter("" + mAdapter.getClass() + "")]"");
        }
        setSelectedPositionInt(mNextSelectedPosition);
        AccessibilityNodeInfo accessibilityFocusLayoutRestoreNode = null;
        View accessibilityFocusLayoutRestoreView = null;
        int accessibilityFocusPosition = INVALID_POSITION;
        // Remember which child, if any, had accessibility focus. This must
        // occur before recycling any views, since that will clear
        // accessibility focus.
        final ViewRootImpl viewRootImpl = getViewRootImpl();
        if (viewRootImpl != null) {
            final View focusHost = viewRootImpl.getAccessibilityFocusedHost();
            if (focusHost != null) {
                final View focusChild = getAccessibilityFocusedChild(focusHost);
                if (focusChild != null) {
                    if (!dataChanged || isDirectChildHeaderOrFooter(focusChild) || (focusChild.hasTransientState() && mAdapterHasStableIds)) {
                        // The views won't be changing, so try to maintain
                        // focus on the current host and virtual view.
                        accessibilityFocusLayoutRestoreView = focusHost;
                        accessibilityFocusLayoutRestoreNode = viewRootImpl.getAccessibilityFocusedVirtualView();
                    }
                    // If all else fails, maintain focus at the same
                    // position.
                    accessibilityFocusPosition = getPositionForView(focusChild);
                }
            }
        }
        View focusLayoutRestoreDirectChild = null;
        View focusLayoutRestoreView = null;
        // Take focus back to us temporarily to avoid the eventual call to
        // clear focus when removing the focused child below from messing
        // things up when ViewAncestor assigns focus back to someone else.
        final View focusedChild = getFocusedChild();
        if (focusedChild != null) {
            // header or footer.
            if (!dataChanged || isDirectChildHeaderOrFooter(focusedChild) || focusedChild.hasTransientState() || mAdapterHasStableIds) {
                focusLayoutRestoreDirectChild = focusedChild;
                // Remember the specific view that had focus.
                focusLayoutRestoreView = findFocus();
                if (focusLayoutRestoreView != null) {
                    // Tell it we are going to mess with it.
                    focusLayoutRestoreView.dispatchStartTemporaryDetach();
                }
            }
            requestFocus();
        }
        // Pull all children into the RecycleBin.
        // These views will be reused if possible
        final int firstPosition = mFirstPosition;
        final RecycleBin recycleBin = mRecycler;
        if (dataChanged) {
            for (int i = 0; i < childCount; i++) {
                recycleBin.addScrapView(getChildAt(i), firstPosition + i);
            }
        } else {
            recycleBin.fillActiveViews(childCount, firstPosition);
        }
        // Clear out old views
        detachAllViewsFromParent();
        recycleBin.removeSkippedScrap();
        switch(mLayoutMode) {
            case LAYOUT_SET_SELECTION:
                if (newSel != null) {
                    sel = fillFromSelection(newSel.getTop(), childrenTop, childrenBottom);
                } else {
                    sel = fillFromMiddle(childrenTop, childrenBottom);
                }
                break;
            case LAYOUT_SYNC:
                sel = fillSpecific(mSyncPosition, mSpecificTop);
                break;
            case LAYOUT_FORCE_BOTTOM:
                sel = fillUp(mItemCount - 1, childrenBottom);
                adjustViewsUpOrDown();
                break;
            case LAYOUT_FORCE_TOP:
                mFirstPosition = 0;
                sel = fillFromTop(childrenTop);
                adjustViewsUpOrDown();
                break;
            case LAYOUT_SPECIFIC:
                final int selectedPosition = reconcileSelectedPosition();
                sel = fillSpecific(selectedPosition, mSpecificTop);
                /**
                 * When ListView is resized, FocusSelector requests an async selection for the
                 * previously focused item to make sure it is still visible. If the item is not
                 * selectable, it won't regain focus so instead we call FocusSelector
                 * to directly request focus on the view after it is visible.
                 */
                if (sel == null && mFocusSelector != null) {
                    final Runnable focusRunnable = mFocusSelector.setupFocusIfValid(selectedPosition);
                    if (focusRunnable != null) {
                        post(focusRunnable);
                    }
                }
                break;
            case LAYOUT_MOVE_SELECTION:
                sel = moveSelection(oldSel, newSel, delta, childrenTop, childrenBottom);
                break;
            default:
                if (childCount == 0) {
                    if (!mStackFromBottom) {
                        final int position = lookForSelectablePosition(0, true);
                        setSelectedPositionInt(position);
                        sel = fillFromTop(childrenTop);
                    } else {
                        final int position = lookForSelectablePosition(mItemCount - 1, false);
                        setSelectedPositionInt(position);
                        sel = fillUp(mItemCount - 1, childrenBottom);
                    }
                } else {
                    if (mSelectedPosition >= 0 && mSelectedPosition < mItemCount) {
                        sel = fillSpecific(mSelectedPosition, oldSel == null ? childrenTop : oldSel.getTop());
                    } else if (mFirstPosition < mItemCount) {
                        sel = fillSpecific(mFirstPosition, oldFirst == null ? childrenTop : oldFirst.getTop());
                    } else {
                        sel = fillSpecific(0, childrenTop);
                    }
                }
                break;
        }
        // Flush any cached views that did not get reused above
        recycleBin.scrapActiveViews();
        // remove any header/footer that has been temp detached and not re-attached
        removeUnusedFixedViews(mHeaderViewInfos);
        removeUnusedFixedViews(mFooterViewInfos);
        if (sel != null) {
            // focusable.
            if (mItemsCanFocus && hasFocus() && !sel.hasFocus()) {
                final boolean focusWasTaken = (sel == focusLayoutRestoreDirectChild && focusLayoutRestoreView != null && focusLayoutRestoreView.requestFocus()) || sel.requestFocus();
                if (!focusWasTaken) {
                    // Selected item didn't take focus, but we still want to
                    // make sure something else outside of the selected view
                    // has focus.
                    final View focused = getFocusedChild();
                    if (focused != null) {
                        focused.clearFocus();
                    }
                    positionSelector(INVALID_POSITION, sel);
                } else {
                    sel.setSelected(false);
                    mSelectorRect.setEmpty();
                }
            } else {
                positionSelector(INVALID_POSITION, sel);
            }
            mSelectedTop = sel.getTop();
        } else {
            final boolean inTouchMode = mTouchMode == TOUCH_MODE_TAP || mTouchMode == TOUCH_MODE_DONE_WAITING;
            if (inTouchMode) {
                // If the user's finger is down, select the motion position.
                final View child = getChildAt(mMotionPosition - mFirstPosition);
                if (child != null) {
                    positionSelector(mMotionPosition, child);
                }
            } else if (mSelectorPosition != INVALID_POSITION) {
                // If we had previously positioned the selector somewhere,
                // put it back there. It might not match up with the data,
                // but it's transitioning out so it's not a big deal.
                final View child = getChildAt(mSelectorPosition - mFirstPosition);
                if (child != null) {
                    positionSelector(mSelectorPosition, child);
                }
            } else {
                // Otherwise, clear selection.
                mSelectedTop = 0;
                mSelectorRect.setEmpty();
            }
            // restore focus (i.e. something focusable in touch mode).
            if (hasFocus() && focusLayoutRestoreView != null) {
                focusLayoutRestoreView.requestFocus();
            }
        }
        // Attempt to restore accessibility focus, if necessary.
        if (viewRootImpl != null) {
            final View newAccessibilityFocusedView = viewRootImpl.getAccessibilityFocusedHost();
            if (newAccessibilityFocusedView == null) {
                if (accessibilityFocusLayoutRestoreView != null && accessibilityFocusLayoutRestoreView.isAttachedToWindow()) {
                    final AccessibilityNodeProvider provider = accessibilityFocusLayoutRestoreView.getAccessibilityNodeProvider();
                    if (accessibilityFocusLayoutRestoreNode != null && provider != null) {
                        final int virtualViewId = AccessibilityNodeInfo.getVirtualDescendantId(accessibilityFocusLayoutRestoreNode.getSourceNodeId());
                        provider.performAction(virtualViewId, AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS, null);
                    } else {
                        accessibilityFocusLayoutRestoreView.requestAccessibilityFocus();
                    }
                } else if (accessibilityFocusPosition != INVALID_POSITION) {
                    // Bound the position within the visible children.
                    final int position = MathUtils.constrain(accessibilityFocusPosition - mFirstPosition, 0, getChildCount() - 1);
                    final View restoreView = getChildAt(position);
                    if (restoreView != null) {
                        restoreView.requestAccessibilityFocus();
                    }
                }
            }
        }
        // our view hierarchy.
        if (focusLayoutRestoreView != null && focusLayoutRestoreView.getWindowToken() != null) {
            focusLayoutRestoreView.dispatchFinishTemporaryDetach();
        }
        mLayoutMode = LAYOUT_NORMAL;
        mDataChanged = false;
        if (mPositionScrollAfterLayout != null) {
            post(mPositionScrollAfterLayout);
            mPositionScrollAfterLayout = null;
        }
        mNeedSync = false;
        setNextSelectedPositionInt(mSelectedPosition);
        updateScrollIndicators();
        if (mItemCount > 0) {
            checkSelectionChanged();
        }
        invokeOnItemScrollListener();
    } finally {
        if (mFocusSelector != null) {
            mFocusSelector.onLayoutComplete();
        }
        if (!blockLayoutRequests) {
            mBlockLayoutRequests = false;
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
442,<android.app.ActivityTransitionState: boolean startExitBackTransition(Activity)>,25,26,<android.app.ActivityTransitionState: boolean startExitBackTransition(Activity)>,<android.app.ActivityTransitionState: boolean startExitBackTransition(Activity)>,0,"{
    if (mEnteringNames == null || mCalledExitCoordinator != null) {
        return false;
    } else {
        if (!mHasExited) {
            mHasExited = true;
            Transition enterViewsTransition = null;
            ViewGroup decor = null;
            boolean delayExitBack = false;
            if (mEnterTransitionCoordinator != null) {
                enterViewsTransition = mEnterTransitionCoordinator.getEnterViewsTransition();
                decor = mEnterTransitionCoordinator.getDecor();
                delayExitBack = mEnterTransitionCoordinator.cancelEnter();
                mEnterTransitionCoordinator = null;
                if (enterViewsTransition != null && decor != null) {
                    enterViewsTransition.pause(decor);
                }
            }
            mReturnExitCoordinator = new ExitTransitionCoordinator(activity, activity.getWindow(), activity.mEnterTransitionListener, mEnteringNames, null, null, true);
            if (enterViewsTransition != null && decor != null) {
                enterViewsTransition.resume(decor);
            }
            if (delayExitBack && decor != null) {
                final ViewGroup finalDecor = decor;
                decor.getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {

                    @Override
                    public boolean onPreDraw() {
                        finalDecor.getViewTreeObserver().removeOnPreDrawListener(this);
                        if (mReturnExitCoordinator != null) {
                            mReturnExitCoordinator.startExit(activity.mResultCode, activity.mResultData);
                        }
                        return true;
                    }
                });
            } else {
                mReturnExitCoordinator.startExit(activity.mResultCode, activity.mResultData);
            }
        }
        return true;
    }
}","{
    if (mEnteringNames == null || mCalledExitCoordinator != null) {
        return false;
    } else {
        if (!mHasExited) {
            mHasExited = true;
            Transition enterViewsTransition = null;
            ViewGroup decor = null;
            boolean delayExitBack = false;
            if (mEnterTransitionCoordinator != null) {
                enterViewsTransition = mEnterTransitionCoordinator.getEnterViewsTransition();
                decor = mEnterTransitionCoordinator.getDecor();
                delayExitBack = mEnterTransitionCoordinator.cancelEnter();
                mEnterTransitionCoordinator = null;
                if (enterViewsTransition != null && decor != null) {
                    enterViewsTransition.pause(decor);
                }
            }
            mReturnExitCoordinator = new ExitTransitionCoordinator(activity, activity.getWindow(), activity.mEnterTransitionListener, mEnteringNames, null, null, true);
            if (enterViewsTransition != null && decor != null) {
                enterViewsTransition.resume(decor);
            }
            if (delayExitBack && decor != null) {
                final ViewGroup finalDecor = decor;
                OneShotPreDrawListener.add(decor, () -> {
                    if (mReturnExitCoordinator != null) {
                        mReturnExitCoordinator.startExit(activity.mResultCode, activity.mResultData);
                    }
                });
            } else {
                mReturnExitCoordinator.startExit(activity.mResultCode, activity.mResultData);
            }
        }
        return true;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The statement change is related to setting up a one-shot pre-draw listener. In the early version, a ViewTreeObserver.OnPreDrawListener anonymous class is implemented and added as a pre-draw listener which will start exit when the view is about to be drawn. In the late version, a lambda expression is used with the OneShotPreDrawListener.add method to achieve the same effect. The control flow has not actually changed, so this is categorized as ""Other statement changed"" (4) and ""Control dependency changed"" (3) because of the change in setting up the listener, which is under the 'if' control structure.","There is no Compatibility Issue as the pre-draw listener setup change does not affect the behavior of the API. Both implementations aim to execute mReturnExitCoordinator.startExit() under the same conditions, with the same outcome. The replacement of the anonymous class with a lambda expression and the use of a utility method for adding the listener doesn't alter the fundamental logic or flow; it simply uses a different, and possibly cleaner, syntax to set up a one-time operation that will be performed before the next view drawing. No exceptions are added or taken away, and no return values are changed or newly introduced. Therefore, the potential behavior that the API will exhibit remains the same across the versions."
443,"<android.provider.DocumentsProvider: Bundle call(String,String,Bundle)>",25,26,"<android.provider.DocumentsProvider: Bundle call(String,String,Bundle)>","<android.provider.DocumentsProvider: Bundle call(String,String,Bundle)>",0,"{
    if (!method.startsWith(""android:"")) {
        // Ignore non-platform methods
        return super.call(method, arg, extras);
    }
    try {
        return callUnchecked(method, arg, extras);
    } catch (FileNotFoundException e) {
        throw new IllegalStateException(""Failed call "" + method, e);
    }
}","{
    if (!method.startsWith(""android:"")) {
        // Ignore non-platform methods
        return super.call(method, arg, extras);
    }
    try {
        return callUnchecked(method, arg, extras);
    } catch (FileNotFoundException e) {
        throw new ParcelableException(e);
    }
}",1,"/**
 * Implementation is provided by the parent class. Can be overridden to
 * provide additional functionality, but subclasses <em>must</em> always
 * call the superclass. If the superclass returns {@code null}, the subclass
 * may implement custom behavior.
 */
","/**
 * Implementation is provided by the parent class. Can be overridden to
 * provide additional functionality, but subclasses <em>must</em> always
 * call the superclass. If the superclass returns {@code null}, the subclass
 * may implement custom behavior.
 */
",-1,"[@CallSuper, @Override]","[@CallSuper, @Override]",-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed from throwing an IllegalStateException to throwing a ParcelableException, so the code change type is 2.","The change from IllegalStateException to ParcelableException means that the method now throws a different type of exception than before, which signifies a compatibility issue as clients catching the old exception will not catch the new one, thus the CI type is 2."
444,"<android.service.wallpaper.WallpaperService.Engine: void updateSurface(boolean,boolean,boolean)>",25,26,"<android.service.wallpaper.WallpaperService.Engine: void updateSurface(boolean,boolean,boolean)>","<android.service.wallpaper.WallpaperService.Engine: void updateSurface(boolean,boolean,boolean)>",0,"{
    if (mDestroyed) {
        Log.w(TAG, ""Ignoring updateSurface: destroyed"");
    }
    boolean fixedSize = false;
    int myWidth = mSurfaceHolder.getRequestedWidth();
    if (myWidth <= 0)
        myWidth = ViewGroup.LayoutParams.MATCH_PARENT;
    else
        fixedSize = true;
    int myHeight = mSurfaceHolder.getRequestedHeight();
    if (myHeight <= 0)
        myHeight = ViewGroup.LayoutParams.MATCH_PARENT;
    else
        fixedSize = true;
    final boolean creating = !mCreated;
    final boolean surfaceCreating = !mSurfaceCreated;
    final boolean formatChanged = mFormat != mSurfaceHolder.getRequestedFormat();
    boolean sizeChanged = mWidth != myWidth || mHeight != myHeight;
    boolean insetsChanged = !mCreated;
    final boolean typeChanged = mType != mSurfaceHolder.getRequestedType();
    final boolean flagsChanged = mCurWindowFlags != mWindowFlags || mCurWindowPrivateFlags != mWindowPrivateFlags;
    if (forceRelayout || creating || surfaceCreating || formatChanged || sizeChanged || typeChanged || flagsChanged || redrawNeeded || !mIWallpaperEngine.mShownReported) {
        if (DEBUG)
            Log.v(TAG, ""Changes: creating="" + creating + "" format="" + formatChanged + "" size="" + sizeChanged);
        try {
            mWidth = myWidth;
            mHeight = myHeight;
            mFormat = mSurfaceHolder.getRequestedFormat();
            mType = mSurfaceHolder.getRequestedType();
            mLayout.x = 0;
            mLayout.y = 0;
            mLayout.width = myWidth;
            mLayout.height = myHeight;
            mLayout.format = mFormat;
            mCurWindowFlags = mWindowFlags;
            mLayout.flags = mWindowFlags | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
            mCurWindowPrivateFlags = mWindowPrivateFlags;
            mLayout.privateFlags = mWindowPrivateFlags;
            mLayout.memoryType = mType;
            mLayout.token = mWindowToken;
            if (!mCreated) {
                // Retrieve watch round info
                TypedArray windowStyle = obtainStyledAttributes(com.android.internal.R.styleable.Window);
                windowStyle.recycle();
                // Add window
                mLayout.type = mIWallpaperEngine.mWindowType;
                mLayout.gravity = Gravity.START | Gravity.TOP;
                mLayout.setTitle(WallpaperService.this.getClass().getName());
                mLayout.windowAnimations = com.android.internal.R.style.Animation_Wallpaper;
                mInputChannel = new InputChannel();
                if (mSession.addToDisplay(mWindow, mWindow.mSeq, mLayout, View.VISIBLE, Display.DEFAULT_DISPLAY, mContentInsets, mStableInsets, mOutsets, mInputChannel) < 0) {
                    Log.w(TAG, ""Failed to add window while updating wallpaper surface."");
                    return;
                }
                mCreated = true;
                mInputEventReceiver = new WallpaperInputEventReceiver(mInputChannel, Looper.myLooper());
            }
            mSurfaceHolder.mSurfaceLock.lock();
            mDrawingAllowed = true;
            if (!fixedSize) {
                mLayout.surfaceInsets.set(mIWallpaperEngine.mDisplayPadding);
                mLayout.surfaceInsets.left += mOutsets.left;
                mLayout.surfaceInsets.top += mOutsets.top;
                mLayout.surfaceInsets.right += mOutsets.right;
                mLayout.surfaceInsets.bottom += mOutsets.bottom;
            } else {
                mLayout.surfaceInsets.set(0, 0, 0, 0);
            }
            final int relayoutResult = mSession.relayout(mWindow, mWindow.mSeq, mLayout, mWidth, mHeight, View.VISIBLE, 0, mWinFrame, mOverscanInsets, mContentInsets, mVisibleInsets, mStableInsets, mOutsets, mBackdropFrame, mConfiguration, mSurfaceHolder.mSurface);
            if (DEBUG)
                Log.v(TAG, ""New surface: "" + mSurfaceHolder.mSurface + "", frame="" + mWinFrame);
            int w = mWinFrame.width();
            int h = mWinFrame.height();
            if (!fixedSize) {
                final Rect padding = mIWallpaperEngine.mDisplayPadding;
                w += padding.left + padding.right + mOutsets.left + mOutsets.right;
                h += padding.top + padding.bottom + mOutsets.top + mOutsets.bottom;
                mOverscanInsets.left += padding.left;
                mOverscanInsets.top += padding.top;
                mOverscanInsets.right += padding.right;
                mOverscanInsets.bottom += padding.bottom;
                mContentInsets.left += padding.left;
                mContentInsets.top += padding.top;
                mContentInsets.right += padding.right;
                mContentInsets.bottom += padding.bottom;
                mStableInsets.left += padding.left;
                mStableInsets.top += padding.top;
                mStableInsets.right += padding.right;
                mStableInsets.bottom += padding.bottom;
            }
            if (mCurWidth != w) {
                sizeChanged = true;
                mCurWidth = w;
            }
            if (mCurHeight != h) {
                sizeChanged = true;
                mCurHeight = h;
            }
            if (DEBUG) {
                Log.v(TAG, ""Wallpaper size has changed: ("" + mCurWidth + "", "" + mCurHeight);
            }
            insetsChanged |= !mDispatchedOverscanInsets.equals(mOverscanInsets);
            insetsChanged |= !mDispatchedContentInsets.equals(mContentInsets);
            insetsChanged |= !mDispatchedStableInsets.equals(mStableInsets);
            insetsChanged |= !mDispatchedOutsets.equals(mOutsets);
            mSurfaceHolder.setSurfaceFrameSize(w, h);
            mSurfaceHolder.mSurfaceLock.unlock();
            if (!mSurfaceHolder.mSurface.isValid()) {
                reportSurfaceDestroyed();
                if (DEBUG)
                    Log.v(TAG, ""Layout: Surface destroyed"");
                return;
            }
            boolean didSurface = false;
            try {
                mSurfaceHolder.ungetCallbacks();
                if (surfaceCreating) {
                    mIsCreating = true;
                    didSurface = true;
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceCreated("" + mSurfaceHolder + ""): "" + this);
                    onSurfaceCreated(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceCreated(mSurfaceHolder);
                        }
                    }
                }
                redrawNeeded |= creating || (relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0;
                if (forceReport || creating || surfaceCreating || formatChanged || sizeChanged) {
                    if (DEBUG) {
                        RuntimeException e = new RuntimeException();
                        e.fillInStackTrace();
                        Log.w(TAG, ""forceReport="" + forceReport + "" creating="" + creating + "" formatChanged="" + formatChanged + "" sizeChanged="" + sizeChanged, e);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceChanged("" + mSurfaceHolder + "", "" + mFormat + "", "" + mCurWidth + "", "" + mCurHeight + ""): "" + this);
                    didSurface = true;
                    onSurfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                        }
                    }
                }
                if (insetsChanged) {
                    mDispatchedOverscanInsets.set(mOverscanInsets);
                    mDispatchedOverscanInsets.left += mOutsets.left;
                    mDispatchedOverscanInsets.top += mOutsets.top;
                    mDispatchedOverscanInsets.right += mOutsets.right;
                    mDispatchedOverscanInsets.bottom += mOutsets.bottom;
                    mDispatchedContentInsets.set(mContentInsets);
                    mDispatchedStableInsets.set(mStableInsets);
                    mDispatchedOutsets.set(mOutsets);
                    mFinalSystemInsets.set(mDispatchedOverscanInsets);
                    mFinalStableInsets.set(mDispatchedStableInsets);
                    WindowInsets insets = new WindowInsets(mFinalSystemInsets, null, mFinalStableInsets, getResources().getConfiguration().isScreenRound(), false);
                    if (DEBUG) {
                        Log.v(TAG, ""dispatching insets="" + insets);
                    }
                    onApplyWindowInsets(insets);
                }
                if (redrawNeeded) {
                    onSurfaceRedrawNeeded(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            if (c instanceof SurfaceHolder.Callback2) {
                                ((SurfaceHolder.Callback2) c).surfaceRedrawNeeded(mSurfaceHolder);
                            }
                        }
                    }
                }
                if (didSurface && !mReportedVisible) {
                    // don't want wallpapers running when not visible.
                    if (mIsCreating) {
                        // the state to get them to notice.
                        if (DEBUG)
                            Log.v(TAG, ""onVisibilityChanged(true) at surface: "" + this);
                        onVisibilityChanged(true);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onVisibilityChanged(false) at surface: "" + this);
                    onVisibilityChanged(false);
                }
            } finally {
                mIsCreating = false;
                mSurfaceCreated = true;
                if (redrawNeeded) {
                    mSession.finishDrawing(mWindow);
                }
                mIWallpaperEngine.reportShown();
            }
        } catch (RemoteException ex) {
        }
        if (DEBUG)
            Log.v(TAG, ""Layout: x="" + mLayout.x + "" y="" + mLayout.y + "" w="" + mLayout.width + "" h="" + mLayout.height);
    }
}","{
    if (mDestroyed) {
        Log.w(TAG, ""Ignoring updateSurface: destroyed"");
    }
    boolean fixedSize = false;
    int myWidth = mSurfaceHolder.getRequestedWidth();
    if (myWidth <= 0)
        myWidth = ViewGroup.LayoutParams.MATCH_PARENT;
    else
        fixedSize = true;
    int myHeight = mSurfaceHolder.getRequestedHeight();
    if (myHeight <= 0)
        myHeight = ViewGroup.LayoutParams.MATCH_PARENT;
    else
        fixedSize = true;
    final boolean creating = !mCreated;
    final boolean surfaceCreating = !mSurfaceCreated;
    final boolean formatChanged = mFormat != mSurfaceHolder.getRequestedFormat();
    boolean sizeChanged = mWidth != myWidth || mHeight != myHeight;
    boolean insetsChanged = !mCreated;
    final boolean typeChanged = mType != mSurfaceHolder.getRequestedType();
    final boolean flagsChanged = mCurWindowFlags != mWindowFlags || mCurWindowPrivateFlags != mWindowPrivateFlags;
    if (forceRelayout || creating || surfaceCreating || formatChanged || sizeChanged || typeChanged || flagsChanged || redrawNeeded || !mIWallpaperEngine.mShownReported) {
        if (DEBUG)
            Log.v(TAG, ""Changes: creating="" + creating + "" format="" + formatChanged + "" size="" + sizeChanged);
        try {
            mWidth = myWidth;
            mHeight = myHeight;
            mFormat = mSurfaceHolder.getRequestedFormat();
            mType = mSurfaceHolder.getRequestedType();
            mLayout.x = 0;
            mLayout.y = 0;
            mLayout.width = myWidth;
            mLayout.height = myHeight;
            mLayout.format = mFormat;
            mCurWindowFlags = mWindowFlags;
            mLayout.flags = mWindowFlags | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
            mCurWindowPrivateFlags = mWindowPrivateFlags;
            mLayout.privateFlags = mWindowPrivateFlags;
            mLayout.memoryType = mType;
            mLayout.token = mWindowToken;
            if (!mCreated) {
                // Retrieve watch round info
                TypedArray windowStyle = obtainStyledAttributes(com.android.internal.R.styleable.Window);
                windowStyle.recycle();
                // Add window
                mLayout.type = mIWallpaperEngine.mWindowType;
                mLayout.gravity = Gravity.START | Gravity.TOP;
                mLayout.setTitle(WallpaperService.this.getClass().getName());
                mLayout.windowAnimations = com.android.internal.R.style.Animation_Wallpaper;
                mInputChannel = new InputChannel();
                if (mSession.addToDisplay(mWindow, mWindow.mSeq, mLayout, View.VISIBLE, Display.DEFAULT_DISPLAY, mContentInsets, mStableInsets, mOutsets, mInputChannel) < 0) {
                    Log.w(TAG, ""Failed to add window while updating wallpaper surface."");
                    return;
                }
                mCreated = true;
                mInputEventReceiver = new WallpaperInputEventReceiver(mInputChannel, Looper.myLooper());
            }
            mSurfaceHolder.mSurfaceLock.lock();
            mDrawingAllowed = true;
            if (!fixedSize) {
                mLayout.surfaceInsets.set(mIWallpaperEngine.mDisplayPadding);
                mLayout.surfaceInsets.left += mOutsets.left;
                mLayout.surfaceInsets.top += mOutsets.top;
                mLayout.surfaceInsets.right += mOutsets.right;
                mLayout.surfaceInsets.bottom += mOutsets.bottom;
            } else {
                mLayout.surfaceInsets.set(0, 0, 0, 0);
            }
            final int relayoutResult = mSession.relayout(mWindow, mWindow.mSeq, mLayout, mWidth, mHeight, View.VISIBLE, 0, mWinFrame, mOverscanInsets, mContentInsets, mVisibleInsets, mStableInsets, mOutsets, mBackdropFrame, mMergedConfiguration, mSurfaceHolder.mSurface);
            if (DEBUG)
                Log.v(TAG, ""New surface: "" + mSurfaceHolder.mSurface + "", frame="" + mWinFrame);
            int w = mWinFrame.width();
            int h = mWinFrame.height();
            if (!fixedSize) {
                final Rect padding = mIWallpaperEngine.mDisplayPadding;
                w += padding.left + padding.right + mOutsets.left + mOutsets.right;
                h += padding.top + padding.bottom + mOutsets.top + mOutsets.bottom;
                mOverscanInsets.left += padding.left;
                mOverscanInsets.top += padding.top;
                mOverscanInsets.right += padding.right;
                mOverscanInsets.bottom += padding.bottom;
                mContentInsets.left += padding.left;
                mContentInsets.top += padding.top;
                mContentInsets.right += padding.right;
                mContentInsets.bottom += padding.bottom;
                mStableInsets.left += padding.left;
                mStableInsets.top += padding.top;
                mStableInsets.right += padding.right;
                mStableInsets.bottom += padding.bottom;
            }
            if (mCurWidth != w) {
                sizeChanged = true;
                mCurWidth = w;
            }
            if (mCurHeight != h) {
                sizeChanged = true;
                mCurHeight = h;
            }
            if (DEBUG) {
                Log.v(TAG, ""Wallpaper size has changed: ("" + mCurWidth + "", "" + mCurHeight);
            }
            insetsChanged |= !mDispatchedOverscanInsets.equals(mOverscanInsets);
            insetsChanged |= !mDispatchedContentInsets.equals(mContentInsets);
            insetsChanged |= !mDispatchedStableInsets.equals(mStableInsets);
            insetsChanged |= !mDispatchedOutsets.equals(mOutsets);
            mSurfaceHolder.setSurfaceFrameSize(w, h);
            mSurfaceHolder.mSurfaceLock.unlock();
            if (!mSurfaceHolder.mSurface.isValid()) {
                reportSurfaceDestroyed();
                if (DEBUG)
                    Log.v(TAG, ""Layout: Surface destroyed"");
                return;
            }
            boolean didSurface = false;
            try {
                mSurfaceHolder.ungetCallbacks();
                if (surfaceCreating) {
                    mIsCreating = true;
                    didSurface = true;
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceCreated("" + mSurfaceHolder + ""): "" + this);
                    onSurfaceCreated(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceCreated(mSurfaceHolder);
                        }
                    }
                }
                redrawNeeded |= creating || (relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0;
                if (forceReport || creating || surfaceCreating || formatChanged || sizeChanged) {
                    if (DEBUG) {
                        RuntimeException e = new RuntimeException();
                        e.fillInStackTrace();
                        Log.w(TAG, ""forceReport="" + forceReport + "" creating="" + creating + "" formatChanged="" + formatChanged + "" sizeChanged="" + sizeChanged, e);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceChanged("" + mSurfaceHolder + "", "" + mFormat + "", "" + mCurWidth + "", "" + mCurHeight + ""): "" + this);
                    didSurface = true;
                    onSurfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                        }
                    }
                }
                if (insetsChanged) {
                    mDispatchedOverscanInsets.set(mOverscanInsets);
                    mDispatchedOverscanInsets.left += mOutsets.left;
                    mDispatchedOverscanInsets.top += mOutsets.top;
                    mDispatchedOverscanInsets.right += mOutsets.right;
                    mDispatchedOverscanInsets.bottom += mOutsets.bottom;
                    mDispatchedContentInsets.set(mContentInsets);
                    mDispatchedStableInsets.set(mStableInsets);
                    mDispatchedOutsets.set(mOutsets);
                    mFinalSystemInsets.set(mDispatchedOverscanInsets);
                    mFinalStableInsets.set(mDispatchedStableInsets);
                    WindowInsets insets = new WindowInsets(mFinalSystemInsets, null, mFinalStableInsets, getResources().getConfiguration().isScreenRound(), false);
                    if (DEBUG) {
                        Log.v(TAG, ""dispatching insets="" + insets);
                    }
                    onApplyWindowInsets(insets);
                }
                if (redrawNeeded) {
                    onSurfaceRedrawNeeded(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            if (c instanceof SurfaceHolder.Callback2) {
                                ((SurfaceHolder.Callback2) c).surfaceRedrawNeeded(mSurfaceHolder);
                            }
                        }
                    }
                }
                if (didSurface && !mReportedVisible) {
                    // don't want wallpapers running when not visible.
                    if (mIsCreating) {
                        // the state to get them to notice.
                        if (DEBUG)
                            Log.v(TAG, ""onVisibilityChanged(true) at surface: "" + this);
                        onVisibilityChanged(true);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onVisibilityChanged(false) at surface: "" + this);
                    onVisibilityChanged(false);
                }
            } finally {
                mIsCreating = false;
                mSurfaceCreated = true;
                if (redrawNeeded) {
                    mSession.finishDrawing(mWindow);
                }
                mIWallpaperEngine.reportShown();
            }
        } catch (RemoteException ex) {
        }
        if (DEBUG)
            Log.v(TAG, ""Layout: x="" + mLayout.x + "" y="" + mLayout.y + "" w="" + mLayout.width + "" h="" + mLayout.height);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
446,<android.view.ViewGroup: void removeAllViewsInLayout()>,25,26,<android.view.ViewGroup: void removeAllViewsInLayout()>,<android.view.ViewGroup: void removeAllViewsInLayout()>,0,"{
    final int count = mChildrenCount;
    if (count <= 0) {
        return;
    }
    final View[] children = mChildren;
    mChildrenCount = 0;
    final View focused = mFocused;
    final boolean detach = mAttachInfo != null;
    boolean clearChildFocus = false;
    needGlobalAttributesUpdate(false);
    for (int i = count - 1; i >= 0; i--) {
        final View view = children[i];
        if (mTransition != null) {
            mTransition.removeChild(this, view);
        }
        if (view == focused) {
            view.unFocus(null);
            clearChildFocus = true;
        }
        view.clearAccessibilityFocus();
        cancelTouchTarget(view);
        cancelHoverTarget(view);
        if (view.getAnimation() != null || (mTransitioningViews != null && mTransitioningViews.contains(view))) {
            addDisappearingView(view);
        } else if (detach) {
            view.dispatchDetachedFromWindow();
        }
        if (view.hasTransientState()) {
            childHasTransientStateChanged(view, false);
        }
        dispatchViewRemoved(view);
        view.mParent = null;
        children[i] = null;
    }
    if (clearChildFocus) {
        clearChildFocus(focused);
        if (!rootViewRequestFocus()) {
            notifyGlobalFocusCleared(focused);
        }
    }
}","{
    final int count = mChildrenCount;
    if (count <= 0) {
        return;
    }
    final View[] children = mChildren;
    mChildrenCount = 0;
    final View focused = mFocused;
    final boolean detach = mAttachInfo != null;
    boolean clearChildFocus = false;
    needGlobalAttributesUpdate(false);
    for (int i = count - 1; i >= 0; i--) {
        final View view = children[i];
        if (mTransition != null) {
            mTransition.removeChild(this, view);
        }
        if (view == focused) {
            view.unFocus(null);
            clearChildFocus = true;
        }
        view.clearAccessibilityFocus();
        cancelTouchTarget(view);
        cancelHoverTarget(view);
        if (view.getAnimation() != null || (mTransitioningViews != null && mTransitioningViews.contains(view))) {
            addDisappearingView(view);
        } else if (detach) {
            view.dispatchDetachedFromWindow();
        }
        if (view.hasTransientState()) {
            childHasTransientStateChanged(view, false);
        }
        dispatchViewRemoved(view);
        view.mParent = null;
        children[i] = null;
    }
    if (mDefaultFocus != null) {
        clearDefaultFocus(mDefaultFocus);
    }
    if (mFocusedInCluster != null) {
        clearFocusedInCluster(mFocusedInCluster);
    }
    if (clearChildFocus) {
        clearChildFocus(focused);
        if (!rootViewRequestFocus()) {
            notifyGlobalFocusCleared(focused);
        }
    }
}",1,"/**
 * Called by a ViewGroup subclass to remove child views from itself,
 * when it must first know its size on screen before it can calculate how many
 * child views it will render. An example is a Gallery or a ListView, which
 * may ""have"" 50 children, but actually only render the number of children
 * that can currently fit inside the object on screen. Do not call
 * this method unless you are extending ViewGroup and understand the
 * view measuring and layout pipeline.
 *
 * <p><strong>Note:</strong> do not invoke this method from
 * {@link #draw(android.graphics.Canvas)}, {@link #onDraw(android.graphics.Canvas)},
 * {@link #dispatchDraw(android.graphics.Canvas)} or any related method.</p>
 */
","/**
 * Called by a ViewGroup subclass to remove child views from itself,
 * when it must first know its size on screen before it can calculate how many
 * child views it will render. An example is a Gallery or a ListView, which
 * may ""have"" 50 children, but actually only render the number of children
 * that can currently fit inside the object on screen. Do not call
 * this method unless you are extending ViewGroup and understand the
 * view measuring and layout pipeline.
 *
 * <p><strong>Note:</strong> do not invoke this method from
 * {@link #draw(android.graphics.Canvas)}, {@link #onDraw(android.graphics.Canvas)},
 * {@link #dispatchDraw(android.graphics.Canvas)} or any related method.</p>
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"Two lines of code are added to clear default focus (clearDefaultFocus(mDefaultFocus)) and focused in cluster (clearFocusedInCluster(mFocusedInCluster)). These changes do not modify the existing control flow or return values, nor do they handle exceptions differently.","Since the new lines of code are additional cleanup steps but don't affect the existing behavior such as return values or thrown exceptions, they don't introduce a Compatibility Issue."
447,<android.accessibilityservice.AccessibilityServiceInfo: String getId()>,25,26,<android.accessibilityservice.AccessibilityServiceInfo: String getId()>,<android.accessibilityservice.AccessibilityServiceInfo: String getId()>,0,"{
    return mId;
}","{
    return mComponentName.flattenToShortString();
}",1,"/**
 * The accessibility service id.
 * <p>
 * <strong>Generated by the system.</strong>
 * </p>
 * @return The id.
 */
","/**
 * The accessibility service id.
 * <p>
 * <strong>Generated by the system.</strong>
 * </p>
 * @return The id.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method body changed from returning mId directly to returning mComponentName.flattenToShortString(), indicating a change in what is returned and also a dependency on a potentially different API, so the code change types are 1,5.","Since the value being returned has changed from mId to mComponentName.flattenToShortString(), which are different representations of the identifier, there will be a Compatibility Issue as the return value has potentially changed, so the CI type is 1."
448,<android.app.job.JobInfo.Builder: Builder setRequiresCharging(boolean)>,25,26,<android.app.job.JobInfo.Builder: Builder setRequiresCharging(boolean)>,<android.app.job.JobInfo.Builder: Builder setRequiresCharging(boolean)>,0,"{
    mRequiresCharging = requiresCharging;
    return this;
}","{
    mConstraintFlags = (mConstraintFlags & ~CONSTRAINT_FLAG_CHARGING) | (requiresCharging ? CONSTRAINT_FLAG_CHARGING : 0);
    return this;
}",1,"/**
 * Specify that to run this job, the device needs to be plugged in. This defaults to
 * false.
 * @param requiresCharging Whether or not the device is plugged in.
 */
","/**
 * Specify that to run this job, the device needs to be plugged in. This defaults to
 * false.
 * @param requiresCharging Whether or not the device is plugged in.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method's implementation has changed from directly setting a boolean field to using bitwise operations on an integer field, so the code change type is 4 (Other statement changed).",No Compatibility Issue is arising here because the method's contract is preserved. It maintains the same input parameter type and returns the same object with only the internal state representation being different. The behavior observed by the method's consumers should remain consistent between the two versions.
454,<android.content.ContentProviderOperation.Builder: ContentProviderOperation build()>,25,26,<android.content.ContentProviderOperation.Builder: ContentProviderOperation build()>,<android.content.ContentProviderOperation.Builder: ContentProviderOperation build()>,0,"{
    if (mType == TYPE_UPDATE) {
        if ((mValues == null || mValues.size() == 0) && (mValuesBackReferences == null || mValuesBackReferences.size() == 0)) {
            throw new IllegalArgumentException(""Empty values"");
        }
    }
    if (mType == TYPE_ASSERT) {
        if ((mValues == null || mValues.size() == 0) && (mValuesBackReferences == null || mValuesBackReferences.size() == 0) && (mExpectedCount == null)) {
            throw new IllegalArgumentException(""Empty values"");
        }
    }
    return new ContentProviderOperation(this);
}","{
    if (mType == TYPE_UPDATE) {
        if ((mValues == null || mValues.isEmpty()) && (mValuesBackReferences == null || mValuesBackReferences.isEmpty())) {
            throw new IllegalArgumentException(""Empty values"");
        }
    }
    if (mType == TYPE_ASSERT) {
        if ((mValues == null || mValues.isEmpty()) && (mValuesBackReferences == null || mValuesBackReferences.isEmpty()) && (mExpectedCount == null)) {
            throw new IllegalArgumentException(""Empty values"");
        }
    }
    return new ContentProviderOperation(this);
}",1,"/**
 * Create a ContentProviderOperation from this {@link Builder}.
 */
","/**
 * Create a ContentProviderOperation from this {@link Builder}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code change is the replacement of `mValues.size() == 0` with `mValues.isEmpty()` and `mValuesBackReferences.size() == 0` with `mValuesBackReferences.isEmpty()`, which are semantically the same. These changes are categorized as 4 (Other statement changed).","Since `mValues.isEmpty()` is just a more concise way to check if a collection is empty and is semantically equivalent to `mValues.size() == 0`, there is no change in the behavior of the code. Therefore, there is no Compatibility Issue, and the CI type is 0."
455,<android.app.Activity: void setImmersive(boolean)>,25,26,<android.app.Activity: void setImmersive(boolean)>,<android.app.Activity: void setImmersive(boolean)>,0,"{
    try {
        ActivityManagerNative.getDefault().setImmersive(mToken, i);
    } catch (RemoteException e) {
    // pass
    }
}","{
    try {
        ActivityManager.getService().setImmersive(mToken, i);
    } catch (RemoteException e) {
    // pass
    }
}",1,"/**
 * Adjust the current immersive mode setting.
 *
 * Note that changing this value will have no effect on the activity's
 * {@link android.content.pm.ActivityInfo} structure; that is, if
 * <code>android:immersive</code> is set to <code>true</code>
 * in the application's manifest entry for this activity, the {@link
 * android.content.pm.ActivityInfo#flags ActivityInfo.flags} member will
 * always have its {@link android.content.pm.ActivityInfo#FLAG_IMMERSIVE
 * FLAG_IMMERSIVE} bit set.
 *
 * @see #isImmersive()
 * @see android.content.pm.ActivityInfo#FLAG_IMMERSIVE
 */
","/**
 * Adjust the current immersive mode setting.
 *
 * Note that changing this value will have no effect on the activity's
 * {@link android.content.pm.ActivityInfo} structure; that is, if
 * <code>android:immersive</code> is set to <code>true</code>
 * in the application's manifest entry for this activity, the {@link
 * android.content.pm.ActivityInfo#flags ActivityInfo.flags} member will
 * always have its {@link android.content.pm.ActivityInfo#FLAG_IMMERSIVE
 * FLAG_IMMERSIVE} bit set.
 *
 * @see #isImmersive()
 * @see android.content.pm.ActivityInfo#FLAG_IMMERSIVE
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The change from ActivityManagerNative.getDefault() to ActivityManager.getService() indicates that a different dependent API is used to set immersive mode. Thus, the code change type is 5.","Despite the change in the dependent API, since the surrounding control flow and the code structure did not change, and assuming the semantics of ActivityManager.getService().setImmersive is intended to be the same as that of ActivityManagerNative.getDefault().setImmersive, there is no change in the observable behavior from the method's perspective (it swallows the RemoteException). Therefore, there is no Compatibility Issue, so the CI type is 0."
457,<android.os.StatFs: long getBlockSizeLong()>,25,26,<android.os.StatFs: long getBlockSizeLong()>,<android.os.StatFs: long getBlockSizeLong()>,0,"{
    return mStat.f_bsize;
}","{
    return mStat.f_frsize;
}",1,"/**
 * The size, in bytes, of a block on the file system. This corresponds to
 * the Unix {@code statvfs.f_bsize} field.
 */
","/**
 * The size, in bytes, of a block on the file system. This corresponds to
 * the Unix {@code statvfs.f_frsize} field.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement has changed from returning mStat.f_bsize to returning mStat.f_frsize, indicating that the method is returning data from a different field, so the code change type is 1.","The return value of the method has changed, as it now returns the value of a different field, which could potentially cause a different value to be returned to the callers of the method. Hence, the CI type is 1."
458,<android.view.View: int getLayoutDirection()>,25,26,<android.view.View: int getLayoutDirection()>,<android.view.View: int getLayoutDirection()>,0,"{
    final int targetSdkVersion = getContext().getApplicationInfo().targetSdkVersion;
    if (targetSdkVersion < JELLY_BEAN_MR1) {
        mPrivateFlags2 |= PFLAG2_LAYOUT_DIRECTION_RESOLVED;
        return LAYOUT_DIRECTION_RESOLVED_DEFAULT;
    }
    return ((mPrivateFlags2 & PFLAG2_LAYOUT_DIRECTION_RESOLVED_RTL) == PFLAG2_LAYOUT_DIRECTION_RESOLVED_RTL) ? LAYOUT_DIRECTION_RTL : LAYOUT_DIRECTION_LTR;
}","{
    final int targetSdkVersion = getContext().getApplicationInfo().targetSdkVersion;
    if (targetSdkVersion < Build.VERSION_CODES.JELLY_BEAN_MR1) {
        mPrivateFlags2 |= PFLAG2_LAYOUT_DIRECTION_RESOLVED;
        return LAYOUT_DIRECTION_RESOLVED_DEFAULT;
    }
    return ((mPrivateFlags2 & PFLAG2_LAYOUT_DIRECTION_RESOLVED_RTL) == PFLAG2_LAYOUT_DIRECTION_RESOLVED_RTL) ? LAYOUT_DIRECTION_RTL : LAYOUT_DIRECTION_LTR;
}",1,"/**
 * Returns the resolved layout direction for this view.
 *
 * @return {@link #LAYOUT_DIRECTION_RTL} if the layout direction is RTL or returns
 * {@link #LAYOUT_DIRECTION_LTR} if the layout direction is not RTL.
 *
 * For compatibility, this will return {@link #LAYOUT_DIRECTION_LTR} if API version
 * is lower than {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1}.
 *
 * @attr ref android.R.styleable#View_layoutDirection
 */
","/**
 * Returns the resolved layout direction for this view.
 *
 * @return {@link #LAYOUT_DIRECTION_RTL} if the layout direction is RTL or returns
 * {@link #LAYOUT_DIRECTION_LTR} if the layout direction is not RTL.
 *
 * For compatibility, this will return {@link #LAYOUT_DIRECTION_LTR} if API version
 * is lower than {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1}.
 *
 * @attr ref android.R.styleable#View_layoutDirection
 */
",-1,"[@ViewDebug.ExportedProperty(category = ""layout"", mapping = { @ViewDebug.IntToString(from = LAYOUT_DIRECTION_LTR, to = ""RESOLVED_DIRECTION_LTR""), @ViewDebug.IntToString(from = LAYOUT_DIRECTION_RTL, to = ""RESOLVED_DIRECTION_RTL"") }), @ResolvedLayoutDir]","[@ViewDebug.ExportedProperty(category = ""layout"", mapping = { @ViewDebug.IntToString(from = LAYOUT_DIRECTION_LTR, to = ""RESOLVED_DIRECTION_LTR""), @ViewDebug.IntToString(from = LAYOUT_DIRECTION_RTL, to = ""RESOLVED_DIRECTION_RTL"") }), @ResolvedLayoutDir]",-1,-1,-1,-1,-1,-1,0,0,There is no change between the early and late version implementations and annotations.,There is no compatibility issue as the method's implementation and annotations remain the same between versions.
459,<android.app.Activity: boolean moveTaskToBack(boolean)>,25,26,<android.app.Activity: boolean moveTaskToBack(boolean)>,<android.app.Activity: boolean moveTaskToBack(boolean)>,0,"{
    try {
        return ActivityManagerNative.getDefault().moveActivityTaskToBack(mToken, nonRoot);
    } catch (RemoteException e) {
    // Empty
    }
    return false;
}","{
    try {
        return ActivityManager.getService().moveActivityTaskToBack(mToken, nonRoot);
    } catch (RemoteException e) {
    // Empty
    }
    return false;
}",1,"/**
 * Move the task containing this activity to the back of the activity
 * stack.  The activity's order within the task is unchanged.
 *
 * @param nonRoot If false then this only works if the activity is the root
 * of a task; if true it will work for any activity in
 * a task.
 *
 * @return If the task was moved (or it was already at the
 * back) true is returned, else false.
 */
","/**
 * Move the task containing this activity to the back of the activity
 * stack.  The activity's order within the task is unchanged.
 *
 * @param nonRoot If false then this only works if the activity is the root
 * of a task; if true it will work for any activity in
 * a task.
 *
 * @return If the task was moved (or it was already at the
 * back) true is returned, else false.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent API `ActivityManagerNative.getDefault()` has been changed to `ActivityManager.getService()`, but the method name `moveActivityTaskToBack` and the passed parameters remain the same. Although the method to retrieve the service instance has changed, this code change only affects the way the service object is obtained, not the behavior of the `moveTaskToBack` API itself, which is why the change type is 5.","There is no Compatibility Issue as the API behavior remains unchanged. The implementation differences do not affect the method's return value or exception handling; therefore, the call to `moveActivityTaskToBack` is expected to behave the same way, as it calls the same method with the same parameters on the resulting service object. Since the method signature, returned value, and exception handling have not been altered (the empty catch block for `RemoteException` exists in both versions, and the default return value is false in both), no CI is expected."
460,<android.view.ViewRootImpl.ViewRootHandler: String getMessageName(Message)>,25,26,<android.view.ViewRootImpl.ViewRootHandler: String getMessageName(Message)>,<android.view.ViewRootImpl.ViewRootHandler: String getMessageName(Message)>,0,"{
    switch(message.what) {
        case MSG_INVALIDATE:
            return ""MSG_INVALIDATE"";
        case MSG_INVALIDATE_RECT:
            return ""MSG_INVALIDATE_RECT"";
        case MSG_DIE:
            return ""MSG_DIE"";
        case MSG_RESIZED:
            return ""MSG_RESIZED"";
        case MSG_RESIZED_REPORT:
            return ""MSG_RESIZED_REPORT"";
        case MSG_WINDOW_FOCUS_CHANGED:
            return ""MSG_WINDOW_FOCUS_CHANGED"";
        case MSG_DISPATCH_INPUT_EVENT:
            return ""MSG_DISPATCH_INPUT_EVENT"";
        case MSG_DISPATCH_APP_VISIBILITY:
            return ""MSG_DISPATCH_APP_VISIBILITY"";
        case MSG_DISPATCH_GET_NEW_SURFACE:
            return ""MSG_DISPATCH_GET_NEW_SURFACE"";
        case MSG_DISPATCH_KEY_FROM_IME:
            return ""MSG_DISPATCH_KEY_FROM_IME"";
        case MSG_CHECK_FOCUS:
            return ""MSG_CHECK_FOCUS"";
        case MSG_CLOSE_SYSTEM_DIALOGS:
            return ""MSG_CLOSE_SYSTEM_DIALOGS"";
        case MSG_DISPATCH_DRAG_EVENT:
            return ""MSG_DISPATCH_DRAG_EVENT"";
        case MSG_DISPATCH_DRAG_LOCATION_EVENT:
            return ""MSG_DISPATCH_DRAG_LOCATION_EVENT"";
        case MSG_DISPATCH_SYSTEM_UI_VISIBILITY:
            return ""MSG_DISPATCH_SYSTEM_UI_VISIBILITY"";
        case MSG_UPDATE_CONFIGURATION:
            return ""MSG_UPDATE_CONFIGURATION"";
        case MSG_PROCESS_INPUT_EVENTS:
            return ""MSG_PROCESS_INPUT_EVENTS"";
        case MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST:
            return ""MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST"";
        case MSG_WINDOW_MOVED:
            return ""MSG_WINDOW_MOVED"";
        case MSG_SYNTHESIZE_INPUT_EVENT:
            return ""MSG_SYNTHESIZE_INPUT_EVENT"";
        case MSG_DISPATCH_WINDOW_SHOWN:
            return ""MSG_DISPATCH_WINDOW_SHOWN"";
        case MSG_UPDATE_POINTER_ICON:
            return ""MSG_UPDATE_POINTER_ICON"";
    }
    return super.getMessageName(message);
}","{
    switch(message.what) {
        case MSG_INVALIDATE:
            return ""MSG_INVALIDATE"";
        case MSG_INVALIDATE_RECT:
            return ""MSG_INVALIDATE_RECT"";
        case MSG_DIE:
            return ""MSG_DIE"";
        case MSG_RESIZED:
            return ""MSG_RESIZED"";
        case MSG_RESIZED_REPORT:
            return ""MSG_RESIZED_REPORT"";
        case MSG_WINDOW_FOCUS_CHANGED:
            return ""MSG_WINDOW_FOCUS_CHANGED"";
        case MSG_DISPATCH_INPUT_EVENT:
            return ""MSG_DISPATCH_INPUT_EVENT"";
        case MSG_DISPATCH_APP_VISIBILITY:
            return ""MSG_DISPATCH_APP_VISIBILITY"";
        case MSG_DISPATCH_GET_NEW_SURFACE:
            return ""MSG_DISPATCH_GET_NEW_SURFACE"";
        case MSG_DISPATCH_KEY_FROM_IME:
            return ""MSG_DISPATCH_KEY_FROM_IME"";
        case MSG_CHECK_FOCUS:
            return ""MSG_CHECK_FOCUS"";
        case MSG_CLOSE_SYSTEM_DIALOGS:
            return ""MSG_CLOSE_SYSTEM_DIALOGS"";
        case MSG_DISPATCH_DRAG_EVENT:
            return ""MSG_DISPATCH_DRAG_EVENT"";
        case MSG_DISPATCH_DRAG_LOCATION_EVENT:
            return ""MSG_DISPATCH_DRAG_LOCATION_EVENT"";
        case MSG_DISPATCH_SYSTEM_UI_VISIBILITY:
            return ""MSG_DISPATCH_SYSTEM_UI_VISIBILITY"";
        case MSG_UPDATE_CONFIGURATION:
            return ""MSG_UPDATE_CONFIGURATION"";
        case MSG_PROCESS_INPUT_EVENTS:
            return ""MSG_PROCESS_INPUT_EVENTS"";
        case MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST:
            return ""MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST"";
        case MSG_WINDOW_MOVED:
            return ""MSG_WINDOW_MOVED"";
        case MSG_SYNTHESIZE_INPUT_EVENT:
            return ""MSG_SYNTHESIZE_INPUT_EVENT"";
        case MSG_DISPATCH_WINDOW_SHOWN:
            return ""MSG_DISPATCH_WINDOW_SHOWN"";
        case MSG_UPDATE_POINTER_ICON:
            return ""MSG_UPDATE_POINTER_ICON"";
        case MSG_POINTER_CAPTURE_CHANGED:
            return ""MSG_POINTER_CAPTURE_CHANGED"";
        case MSG_DRAW_FINISHED:
            return ""MSG_DRAW_FINISHED"";
    }
    return super.getMessageName(message);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,0,"Two new case statements have been added in the switch block (MSG_POINTER_CAPTURE_CHANGED and MSG_DRAW_FINISHED) with their corresponding return values, so the change type is 1.","The addition of new case statements for handling new message types will not cause a compatibility issue for existing message handling; it only extends the functionality to handle new types of messages. Therefore, there is no compatibility issue for the existing behavior, and the CI type is 0."
461,"<android.app.Fragment: void setTargetFragment(Fragment,int)>",25,26,"<android.app.Fragment: void setTargetFragment(Fragment,int)>","<android.app.Fragment: void setTargetFragment(Fragment,int)>",0,"{
    mTarget = fragment;
    mTargetRequestCode = requestCode;
}","{
    // Don't allow a caller to set a target fragment in another FragmentManager,
    // but there's a snag: people do set target fragments before fragments get added.
    // We'll have the FragmentManager check that for validity when we move
    // the fragments to a valid state.
    final FragmentManager mine = getFragmentManager();
    final FragmentManager theirs = fragment != null ? fragment.getFragmentManager() : null;
    if (mine != null && theirs != null && mine != theirs) {
        throw new IllegalArgumentException(""Fragment "" + fragment + "" must share the same FragmentManager to be set as a target fragment"");
    }
    // Don't let someone create a cycle.
    for (Fragment check = fragment; check != null; check = check.getTargetFragment()) {
        if (check == this) {
            throw new IllegalArgumentException(""Setting "" + fragment + "" as the target of "" + this + "" would create a target cycle"");
        }
    }
    mTarget = fragment;
    mTargetRequestCode = requestCode;
}",1,"/**
 * Optional target for this fragment.  This may be used, for example,
 * if this fragment is being started by another, and when done wants to
 * give a result back to the first.  The target set here is retained
 * across instances via {@link FragmentManager#putFragment
 * FragmentManager.putFragment()}.
 *
 * @param fragment The fragment that is the target of this one.
 * @param requestCode Optional request code, for convenience if you
 * are going to call back with {@link #onActivityResult(int, int, Intent)}.
 */
","/**
 * Optional target for this fragment.  This may be used, for example,
 * if this fragment is being started by another, and when done wants to
 * give a result back to the first.  The target set here is retained
 * across instances via {@link FragmentManager#putFragment
 * FragmentManager.putFragment()}.
 *
 * @param fragment The fragment that is the target of this one.
 * @param requestCode Optional request code, for convenience if you
 * are going to call back with {@link #onActivityResult(int, int, Intent)}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,4",2,"The late version introduces several new control statements (if and for loops) and throws new IllegalArgumentExceptions for specific conditions, which were not present in the earlier version. The direct assignments to mTarget and mTargetRequestCode remain the same. Thus, the code change involves exception handling statements (2), control dependency changes (3), and other changes due to the introduction of new variables and logic checks (4).",The new exception handling could lead to the method throwing IllegalArgumentException where it previously would not have thrown any exception. This is an exception handling change that introduces a compatibility issue where clients of the API may encounter unexpected exceptions (CI type 2).
462,<android.content.pm.PackageInstaller.Session: void fsync(OutputStream)>,25,26,<android.content.pm.PackageInstaller.Session: void fsync(OutputStream)>,<android.content.pm.PackageInstaller.Session: void fsync(OutputStream)>,0,"{
    if (out instanceof FileBridge.FileBridgeOutputStream) {
        ((FileBridge.FileBridgeOutputStream) out).fsync();
    } else {
        throw new IllegalArgumentException(""Unrecognized stream"");
    }
}","{
    if (ENABLE_REVOCABLE_FD) {
        if (out instanceof ParcelFileDescriptor.AutoCloseOutputStream) {
            try {
                Os.fsync(((ParcelFileDescriptor.AutoCloseOutputStream) out).getFD());
            } catch (ErrnoException e) {
                throw e.rethrowAsIOException();
            }
        } else {
            throw new IllegalArgumentException(""Unrecognized stream"");
        }
    } else {
        if (out instanceof FileBridge.FileBridgeOutputStream) {
            ((FileBridge.FileBridgeOutputStream) out).fsync();
        } else {
            throw new IllegalArgumentException(""Unrecognized stream"");
        }
    }
}",1,"/**
 * Ensure that any outstanding data for given stream has been committed
 * to disk. This is only valid for streams returned from
 * {@link #openWrite(String, long, long)}.
 */
","/**
 * Ensure that any outstanding data for given stream has been committed
 * to disk. This is only valid for streams returned from
 * {@link #openWrite(String, long, long)}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,5",2,"There is a new control dependency introduced with the `if (ENABLE_REVOCABLE_FD)` condition, and exception handling statements were introduced in the else-case of the internal conditional structure. Additionally, the dependent API usage `Os.fsync(((ParcelFileDescriptor.AutoCloseOutputStream) out).getFD())` within the conditional block represents a change in dependent API behavior. Thus, the change types are 2,3,5.","A new exception handling mechanism is implemented for `ParcelFileDescriptor.AutoCloseOutputStream`, where an `IOException` is now thrown instead of an `IllegalArgumentException`. This could cause the API to throw a different exception than before, so the CI type is 2."
463,<android.widget.Editor.EditOperation: String toString()>,25,26,<android.widget.Editor.EditOperation: String toString()>,<android.widget.Editor.EditOperation: String toString()>,0,"{
    return ""[mType="" + getTypeString() + "", "" + ""mOldText="" + mOldText + "", "" + ""mOldTextStart="" + mOldTextStart + "", "" + ""mNewText="" + mNewText + "", "" + ""mNewTextStart="" + mNewTextStart + "", "" + ""mOldCursorPos="" + mOldCursorPos + "", "" + ""mNewCursorPos="" + mNewCursorPos + ""]"";
}","{
    return ""[mType="" + getTypeString() + "", "" + ""mOldText="" + mOldText + "", "" + ""mNewText="" + mNewText + "", "" + ""mStart="" + mStart + "", "" + ""mOldCursorPos="" + mOldCursorPos + "", "" + ""mNewCursorPos="" + mNewCursorPos + "", "" + ""mFrozen="" + mFrozen + "", "" + ""mIsComposition="" + mIsComposition + ""]"";
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The return statement has been altered by removing ""mOldTextStart"" and ""mNewTextStart"" segments and adding ""mStart"", ""mFrozen"", and ""mIsComposition"" segments, therefore the change types are 1 and 4.","Because the return statement's composition is different between the two versions, leading to different string outputs, the CI type is 1."
467,"<android.hardware.camera2.impl.CameraDeviceImpl: void createReprocessableCaptureSessionByConfigurations(InputConfiguration,List<OutputConfiguration>,StateCallback,Handler)>",25,26,"<android.hardware.camera2.impl.CameraDeviceImpl: void createReprocessableCaptureSessionByConfigurations(InputConfiguration,List<OutputConfiguration>,StateCallback,Handler)>","<android.hardware.camera2.impl.CameraDeviceImpl: void createReprocessableCaptureSessionByConfigurations(InputConfiguration,List<OutputConfiguration>,StateCallback,Handler)>",0,"{
    if (DEBUG) {
        Log.d(TAG, ""createReprocessableCaptureSessionWithConfigurations"");
    }
    if (inputConfig == null) {
        throw new IllegalArgumentException(""inputConfig cannot be null when creating a "" + ""reprocessable capture session"");
    }
    if (outputs == null) {
        throw new IllegalArgumentException(""Output configurations cannot be null when "" + ""creating a reprocessable capture session"");
    }
    // OutputConfiguration objects aren't immutable, make a copy before using.
    List<OutputConfiguration> currentOutputs = new ArrayList<OutputConfiguration>();
    for (OutputConfiguration output : outputs) {
        currentOutputs.add(new OutputConfiguration(output));
    }
    createCaptureSessionInternal(inputConfig, currentOutputs, callback, handler, /*isConstrainedHighSpeed*/
    false);
}","{
    if (DEBUG) {
        Log.d(TAG, ""createReprocessableCaptureSessionWithConfigurations"");
    }
    if (inputConfig == null) {
        throw new IllegalArgumentException(""inputConfig cannot be null when creating a "" + ""reprocessable capture session"");
    }
    if (outputs == null) {
        throw new IllegalArgumentException(""Output configurations cannot be null when "" + ""creating a reprocessable capture session"");
    }
    // OutputConfiguration objects aren't immutable, make a copy before using.
    List<OutputConfiguration> currentOutputs = new ArrayList<OutputConfiguration>();
    for (OutputConfiguration output : outputs) {
        currentOutputs.add(new OutputConfiguration(output));
    }
    createCaptureSessionInternal(inputConfig, currentOutputs, callback, handler, /*operatingMode*/
    ICameraDeviceUser.NORMAL_MODE);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The change is in the last argument passed to the `createCaptureSessionInternal` method: it was `false` and it became `ICameraDeviceUser.NORMAL_MODE`. The call to `createCaptureSessionInternal` is a dependent API call, so the code change is of type 5.","There is no compatibility issue because the change in the argument does not imply different return values or exception handlings exposed to the API users. The abstraction of the API remains the same, and it is expected that `ICameraDeviceUser.NORMAL_MODE` will internally represent the same kind of session as was formerly implied by the `false` flag. The behavior of the `createCaptureSessionInternal` is internal and apparently consistent with the previous API contract."
469,<android.view.accessibility.AccessibilityWindowInfo: AccessibilityWindowInfo getChild(int)>,25,26,<android.view.accessibility.AccessibilityWindowInfo: AccessibilityWindowInfo getChild(int)>,<android.view.accessibility.AccessibilityWindowInfo: AccessibilityWindowInfo getChild(int)>,0,"{
    if (mChildIds == null) {
        throw new IndexOutOfBoundsException();
    }
    if (mConnectionId == UNDEFINED) {
        return null;
    }
    final int childId = (int) mChildIds.get(index);
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.getWindow(mConnectionId, childId);
}","{
    if (mChildIds == null) {
        throw new IndexOutOfBoundsException();
    }
    if (mConnectionId == UNDEFINED_WINDOW_ID) {
        return null;
    }
    final int childId = (int) mChildIds.get(index);
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.getWindow(mConnectionId, childId);
}",1,"/**
 * Gets the child window at a given index.
 *
 * @param index The index.
 * @return The child.
 */
","/**
 * Gets the child window at a given index.
 *
 * @param index The index.
 * @return The child.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change is in a constant value; UNDEFINED has been changed to UNDEFINED_WINDOW_ID. This does not alter the behavior of the method but rather improves code readability or uses a more descriptive name for the constant. Therefore, the code change type is 4.",There is no Compatibility Issue because the change from UNDEFINED to UNDEFINED_WINDOW_ID is only a renaming of the constant and doesn't affect the method's behavior as the value the constant represents has not been changed.
470,<android.preference.Preference: String getPersistedString(String)>,25,26,<android.preference.Preference: String getPersistedString(String)>,<android.preference.Preference: String getPersistedString(String)>,0,"{
    if (!shouldPersist()) {
        return defaultReturnValue;
    }
    return mPreferenceManager.getSharedPreferences().getString(mKey, defaultReturnValue);
}","{
    if (!shouldPersist()) {
        return defaultReturnValue;
    }
    PreferenceDataStore dataStore = getPreferenceDataStore();
    if (dataStore != null) {
        return dataStore.getString(mKey, defaultReturnValue);
    }
    return mPreferenceManager.getSharedPreferences().getString(mKey, defaultReturnValue);
}",1,"/**
 * Attempts to get a persisted String from the {@link android.content.SharedPreferences}.
 * <p>
 * This will check if this Preference is persistent, get the SharedPreferences
 * from the {@link PreferenceManager}, and get the value.
 *
 * @param defaultReturnValue The default value to return if either the
 * Preference is not persistent or the Preference is not in the
 * shared preferences.
 * @return The value from the SharedPreferences or the default return
 * value.
 * @see #persistString(String)
 */
","/**
 * Attempts to get a persisted String if this Preference is persistent.
 *
 * @param defaultReturnValue The default value to return if either this
 * Preference is not persistent or this Preference is not present.
 * @return The value from the data store or the default return
 * value.
 * @see #persistString(String)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,5",1,"The addition of a control statement (an 'if' condition checking if a 'dataStore' is not null) and changing the source of the string being returned in some cases (from shared preferences to a preference data store) have been introduced. It also added a new dependent API call (getPreferenceDataStore()), so the code changes are classified as 1,3,5.","There is a possibility of returning a value from a different source because of the newly added control dependency and the use of a different method to retrieve the preference value (getPreferenceDataStore() instead of getSharedPreferences()), which can potentially lead to different return values. Consequently, the CI type is 1."
471,<android.view.View: void draw(Canvas)>,25,26,<android.view.View: void draw(Canvas)>,<android.view.View: void draw(Canvas)>,0,"{
    final int privateFlags = mPrivateFlags;
    final boolean dirtyOpaque = (privateFlags & PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE && (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState);
    mPrivateFlags = (privateFlags & ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;
    /*
         * Draw traversal performs several drawing steps which must be executed
         * in the appropriate order:
         *
         *      1. Draw the background
         *      2. If necessary, save the canvas' layers to prepare for fading
         *      3. Draw view's content
         *      4. Draw children
         *      5. If necessary, draw the fading edges and restore layers
         *      6. Draw decorations (scrollbars for instance)
         */
    // Step 1, draw the background, if needed
    int saveCount;
    if (!dirtyOpaque) {
        drawBackground(canvas);
    }
    // skip step 2 & 5 if possible (common case)
    final int viewFlags = mViewFlags;
    boolean horizontalEdges = (viewFlags & FADING_EDGE_HORIZONTAL) != 0;
    boolean verticalEdges = (viewFlags & FADING_EDGE_VERTICAL) != 0;
    if (!verticalEdges && !horizontalEdges) {
        // Step 3, draw the content
        if (!dirtyOpaque)
            onDraw(canvas);
        // Step 4, draw the children
        dispatchDraw(canvas);
        // Overlay is part of the content and draws beneath Foreground
        if (mOverlay != null && !mOverlay.isEmpty()) {
            mOverlay.getOverlayView().dispatchDraw(canvas);
        }
        // Step 6, draw decorations (foreground, scrollbars)
        onDrawForeground(canvas);
        // we're done...
        return;
    }
    /*
         * Here we do the full fledged routine...
         * (this is an uncommon case where speed matters less,
         * this is why we repeat some of the tests that have been
         * done above)
         */
    boolean drawTop = false;
    boolean drawBottom = false;
    boolean drawLeft = false;
    boolean drawRight = false;
    float topFadeStrength = 0.0f;
    float bottomFadeStrength = 0.0f;
    float leftFadeStrength = 0.0f;
    float rightFadeStrength = 0.0f;
    // Step 2, save the canvas' layers
    int paddingLeft = mPaddingLeft;
    final boolean offsetRequired = isPaddingOffsetRequired();
    if (offsetRequired) {
        paddingLeft += getLeftPaddingOffset();
    }
    int left = mScrollX + paddingLeft;
    int right = left + mRight - mLeft - mPaddingRight - paddingLeft;
    int top = mScrollY + getFadeTop(offsetRequired);
    int bottom = top + getFadeHeight(offsetRequired);
    if (offsetRequired) {
        right += getRightPaddingOffset();
        bottom += getBottomPaddingOffset();
    }
    final ScrollabilityCache scrollabilityCache = mScrollCache;
    final float fadeHeight = scrollabilityCache.fadingEdgeLength;
    int length = (int) fadeHeight;
    // overlapping fades produce odd-looking artifacts
    if (verticalEdges && (top + length > bottom - length)) {
        length = (bottom - top) / 2;
    }
    // also clip horizontal fades if necessary
    if (horizontalEdges && (left + length > right - length)) {
        length = (right - left) / 2;
    }
    if (verticalEdges) {
        topFadeStrength = Math.max(0.0f, Math.min(1.0f, getTopFadingEdgeStrength()));
        drawTop = topFadeStrength * fadeHeight > 1.0f;
        bottomFadeStrength = Math.max(0.0f, Math.min(1.0f, getBottomFadingEdgeStrength()));
        drawBottom = bottomFadeStrength * fadeHeight > 1.0f;
    }
    if (horizontalEdges) {
        leftFadeStrength = Math.max(0.0f, Math.min(1.0f, getLeftFadingEdgeStrength()));
        drawLeft = leftFadeStrength * fadeHeight > 1.0f;
        rightFadeStrength = Math.max(0.0f, Math.min(1.0f, getRightFadingEdgeStrength()));
        drawRight = rightFadeStrength * fadeHeight > 1.0f;
    }
    saveCount = canvas.getSaveCount();
    int solidColor = getSolidColor();
    if (solidColor == 0) {
        final int flags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG;
        if (drawTop) {
            canvas.saveLayer(left, top, right, top + length, null, flags);
        }
        if (drawBottom) {
            canvas.saveLayer(left, bottom - length, right, bottom, null, flags);
        }
        if (drawLeft) {
            canvas.saveLayer(left, top, left + length, bottom, null, flags);
        }
        if (drawRight) {
            canvas.saveLayer(right - length, top, right, bottom, null, flags);
        }
    } else {
        scrollabilityCache.setFadeColor(solidColor);
    }
    // Step 3, draw the content
    if (!dirtyOpaque)
        onDraw(canvas);
    // Step 4, draw the children
    dispatchDraw(canvas);
    // Step 5, draw the fade effect and restore layers
    final Paint p = scrollabilityCache.paint;
    final Matrix matrix = scrollabilityCache.matrix;
    final Shader fade = scrollabilityCache.shader;
    if (drawTop) {
        matrix.setScale(1, fadeHeight * topFadeStrength);
        matrix.postTranslate(left, top);
        fade.setLocalMatrix(matrix);
        p.setShader(fade);
        canvas.drawRect(left, top, right, top + length, p);
    }
    if (drawBottom) {
        matrix.setScale(1, fadeHeight * bottomFadeStrength);
        matrix.postRotate(180);
        matrix.postTranslate(left, bottom);
        fade.setLocalMatrix(matrix);
        p.setShader(fade);
        canvas.drawRect(left, bottom - length, right, bottom, p);
    }
    if (drawLeft) {
        matrix.setScale(1, fadeHeight * leftFadeStrength);
        matrix.postRotate(-90);
        matrix.postTranslate(left, top);
        fade.setLocalMatrix(matrix);
        p.setShader(fade);
        canvas.drawRect(left, top, left + length, bottom, p);
    }
    if (drawRight) {
        matrix.setScale(1, fadeHeight * rightFadeStrength);
        matrix.postRotate(90);
        matrix.postTranslate(right, top);
        fade.setLocalMatrix(matrix);
        p.setShader(fade);
        canvas.drawRect(right - length, top, right, bottom, p);
    }
    canvas.restoreToCount(saveCount);
    // Overlay is part of the content and draws beneath Foreground
    if (mOverlay != null && !mOverlay.isEmpty()) {
        mOverlay.getOverlayView().dispatchDraw(canvas);
    }
    // Step 6, draw decorations (foreground, scrollbars)
    onDrawForeground(canvas);
}","{
    final int privateFlags = mPrivateFlags;
    final boolean dirtyOpaque = (privateFlags & PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE && (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState);
    mPrivateFlags = (privateFlags & ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;
    /*
         * Draw traversal performs several drawing steps which must be executed
         * in the appropriate order:
         *
         *      1. Draw the background
         *      2. If necessary, save the canvas' layers to prepare for fading
         *      3. Draw view's content
         *      4. Draw children
         *      5. If necessary, draw the fading edges and restore layers
         *      6. Draw decorations (scrollbars for instance)
         */
    // Step 1, draw the background, if needed
    int saveCount;
    if (!dirtyOpaque) {
        drawBackground(canvas);
    }
    // skip step 2 & 5 if possible (common case)
    final int viewFlags = mViewFlags;
    boolean horizontalEdges = (viewFlags & FADING_EDGE_HORIZONTAL) != 0;
    boolean verticalEdges = (viewFlags & FADING_EDGE_VERTICAL) != 0;
    if (!verticalEdges && !horizontalEdges) {
        // Step 3, draw the content
        if (!dirtyOpaque)
            onDraw(canvas);
        // Step 4, draw the children
        dispatchDraw(canvas);
        drawAutofilledHighlight(canvas);
        // Overlay is part of the content and draws beneath Foreground
        if (mOverlay != null && !mOverlay.isEmpty()) {
            mOverlay.getOverlayView().dispatchDraw(canvas);
        }
        // Step 6, draw decorations (foreground, scrollbars)
        onDrawForeground(canvas);
        // Step 7, draw the default focus highlight
        drawDefaultFocusHighlight(canvas);
        if (debugDraw()) {
            debugDrawFocus(canvas);
        }
        // we're done...
        return;
    }
    /*
         * Here we do the full fledged routine...
         * (this is an uncommon case where speed matters less,
         * this is why we repeat some of the tests that have been
         * done above)
         */
    boolean drawTop = false;
    boolean drawBottom = false;
    boolean drawLeft = false;
    boolean drawRight = false;
    float topFadeStrength = 0.0f;
    float bottomFadeStrength = 0.0f;
    float leftFadeStrength = 0.0f;
    float rightFadeStrength = 0.0f;
    // Step 2, save the canvas' layers
    int paddingLeft = mPaddingLeft;
    final boolean offsetRequired = isPaddingOffsetRequired();
    if (offsetRequired) {
        paddingLeft += getLeftPaddingOffset();
    }
    int left = mScrollX + paddingLeft;
    int right = left + mRight - mLeft - mPaddingRight - paddingLeft;
    int top = mScrollY + getFadeTop(offsetRequired);
    int bottom = top + getFadeHeight(offsetRequired);
    if (offsetRequired) {
        right += getRightPaddingOffset();
        bottom += getBottomPaddingOffset();
    }
    final ScrollabilityCache scrollabilityCache = mScrollCache;
    final float fadeHeight = scrollabilityCache.fadingEdgeLength;
    int length = (int) fadeHeight;
    // overlapping fades produce odd-looking artifacts
    if (verticalEdges && (top + length > bottom - length)) {
        length = (bottom - top) / 2;
    }
    // also clip horizontal fades if necessary
    if (horizontalEdges && (left + length > right - length)) {
        length = (right - left) / 2;
    }
    if (verticalEdges) {
        topFadeStrength = Math.max(0.0f, Math.min(1.0f, getTopFadingEdgeStrength()));
        drawTop = topFadeStrength * fadeHeight > 1.0f;
        bottomFadeStrength = Math.max(0.0f, Math.min(1.0f, getBottomFadingEdgeStrength()));
        drawBottom = bottomFadeStrength * fadeHeight > 1.0f;
    }
    if (horizontalEdges) {
        leftFadeStrength = Math.max(0.0f, Math.min(1.0f, getLeftFadingEdgeStrength()));
        drawLeft = leftFadeStrength * fadeHeight > 1.0f;
        rightFadeStrength = Math.max(0.0f, Math.min(1.0f, getRightFadingEdgeStrength()));
        drawRight = rightFadeStrength * fadeHeight > 1.0f;
    }
    saveCount = canvas.getSaveCount();
    int solidColor = getSolidColor();
    if (solidColor == 0) {
        final int flags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG;
        if (drawTop) {
            canvas.saveLayer(left, top, right, top + length, null, flags);
        }
        if (drawBottom) {
            canvas.saveLayer(left, bottom - length, right, bottom, null, flags);
        }
        if (drawLeft) {
            canvas.saveLayer(left, top, left + length, bottom, null, flags);
        }
        if (drawRight) {
            canvas.saveLayer(right - length, top, right, bottom, null, flags);
        }
    } else {
        scrollabilityCache.setFadeColor(solidColor);
    }
    // Step 3, draw the content
    if (!dirtyOpaque)
        onDraw(canvas);
    // Step 4, draw the children
    dispatchDraw(canvas);
    // Step 5, draw the fade effect and restore layers
    final Paint p = scrollabilityCache.paint;
    final Matrix matrix = scrollabilityCache.matrix;
    final Shader fade = scrollabilityCache.shader;
    if (drawTop) {
        matrix.setScale(1, fadeHeight * topFadeStrength);
        matrix.postTranslate(left, top);
        fade.setLocalMatrix(matrix);
        p.setShader(fade);
        canvas.drawRect(left, top, right, top + length, p);
    }
    if (drawBottom) {
        matrix.setScale(1, fadeHeight * bottomFadeStrength);
        matrix.postRotate(180);
        matrix.postTranslate(left, bottom);
        fade.setLocalMatrix(matrix);
        p.setShader(fade);
        canvas.drawRect(left, bottom - length, right, bottom, p);
    }
    if (drawLeft) {
        matrix.setScale(1, fadeHeight * leftFadeStrength);
        matrix.postRotate(-90);
        matrix.postTranslate(left, top);
        fade.setLocalMatrix(matrix);
        p.setShader(fade);
        canvas.drawRect(left, top, left + length, bottom, p);
    }
    if (drawRight) {
        matrix.setScale(1, fadeHeight * rightFadeStrength);
        matrix.postRotate(90);
        matrix.postTranslate(right, top);
        fade.setLocalMatrix(matrix);
        p.setShader(fade);
        canvas.drawRect(right - length, top, right, bottom, p);
    }
    canvas.restoreToCount(saveCount);
    drawAutofilledHighlight(canvas);
    // Overlay is part of the content and draws beneath Foreground
    if (mOverlay != null && !mOverlay.isEmpty()) {
        mOverlay.getOverlayView().dispatchDraw(canvas);
    }
    // Step 6, draw decorations (foreground, scrollbars)
    onDrawForeground(canvas);
    if (debugDraw()) {
        debugDrawFocus(canvas);
    }
}",1,"/**
 * Manually render this view (and all of its children) to the given Canvas.
 * The view must have already done a full layout before this function is
 * called.  When implementing a view, implement
 * {@link #onDraw(android.graphics.Canvas)} instead of overriding this method.
 * If you do need to override this method, call the superclass version.
 *
 * @param canvas The Canvas to which the View is rendered.
 */
","/**
 * Manually render this view (and all of its children) to the given Canvas.
 * The view must have already done a full layout before this function is
 * called.  When implementing a view, implement
 * {@link #onDraw(android.graphics.Canvas)} instead of overriding this method.
 * If you do need to override this method, call the superclass version.
 *
 * @param canvas The Canvas to which the View is rendered.
 */
",-1,[@CallSuper],[@CallSuper],-1,-1,-1,-1,-1,-1,,,,
472,"<android.widget.ListView: View findViewInHeadersOrFooters(ArrayList<FixedViewInfo>,int)>",25,26,"<android.widget.ListView: View findViewInHeadersOrFooters(ArrayList<FixedViewInfo>,int)>","<android.widget.ListView: View findViewInHeadersOrFooters(ArrayList<FixedViewInfo>,int)>",0,"{
    if (where != null) {
        int len = where.size();
        View v;
        for (int i = 0; i < len; i++) {
            v = where.get(i).view;
            if (!v.isRootNamespace()) {
                v = v.findViewById(id);
                if (v != null) {
                    return v;
                }
            }
        }
    }
    return null;
}","{
    // Look in the passed in list of headers or footers for the view.
    if (where != null) {
        int len = where.size();
        View v;
        for (int i = 0; i < len; i++) {
            v = where.get(i).view;
            if (!v.isRootNamespace()) {
                v = v.findViewById(id);
                if (v != null) {
                    return v;
                }
            }
        }
    }
    return null;
}",1,"/* (non-Javadoc)
     *
     * Look in the passed in list of headers or footers for the view.
     */
",,-1,,,-1,-1,-1,-1,-1,-1,0,0,"The implementation and annotations of the early and late versions are identical with no changes detected, so the code change type is 0.","There is no compatibility issue since there are no changes in the API between the two versions, so the CI type is 0."
473,<android.os.PatternMatcher: boolean match(String)>,25,26,<android.os.PatternMatcher: boolean match(String)>,<android.os.PatternMatcher: boolean match(String)>,0,"{
    return matchPattern(mPattern, str, mType);
}","{
    return matchPattern(str, mPattern, mParsedPattern, mType);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation of the matchPattern() method called within the match() method has changed by adding another parameter, mParsedPattern. This indicates the signature of the dependent API, matchPattern(), which is not visibly in the current API signature, could have changed. Therefore, the code change type is 5 (Dependent API changed).","As long as the semantics of the matchPattern() method remains consistent and it doesn't change the way exceptions are thrown or the return type, no CI would be introduced despite the addition of a new parameter. Since we don't have information suggesting changes to the behavior of matchPattern() (other than the parameter list), it's assumed to not lead to a different return value or exception behavior within the context of the match() method. Hence, the CI type is 0 (No Compatibility Issue)."
476,<android.app.ContextImpl: File getCodeCacheDir()>,25,26,<android.app.ContextImpl: File getCodeCacheDir()>,<android.app.ContextImpl: File getCodeCacheDir()>,0,"{
    synchronized (mSync) {
        if (mCodeCacheDir == null) {
            mCodeCacheDir = new File(getDataDir(), ""code_cache"");
        }
        return ensurePrivateDirExists(mCodeCacheDir);
    }
}","{
    synchronized (mSync) {
        if (mCodeCacheDir == null) {
            mCodeCacheDir = new File(getDataDir(), ""code_cache"");
        }
        return ensurePrivateCacheDirExists(mCodeCacheDir, XATTR_INODE_CODE_CACHE);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The method being called has changed from ensurePrivateDirExists(mCodeCacheDir) to ensurePrivateCacheDirExists(mCodeCacheDir, XATTR_INODE_CODE_CACHE), which alters the dependency on a different method that might behave differently and has an additional parameter, so the code change type is 1,5.","The change in the method invocation could lead to a different return value since a different method is being called with an additional parameter, which can affect the result. Thus, the CI type is 1."
477,"<android.content.res.TypedArray: TypedArray obtain(Resources,int)>",25,26,"<android.content.res.TypedArray: TypedArray obtain(Resources,int)>","<android.content.res.TypedArray: TypedArray obtain(Resources,int)>",0,"{
    final TypedArray attrs = res.mTypedArrayPool.acquire();
    if (attrs != null) {
        attrs.mLength = len;
        attrs.mRecycled = false;
        // Reset the assets, which may have changed due to configuration changes
        // or further resource loading.
        attrs.mAssets = res.getAssets();
        final int fullLen = len * AssetManager.STYLE_NUM_ENTRIES;
        if (attrs.mData.length >= fullLen) {
            return attrs;
        }
        attrs.mData = new int[fullLen];
        attrs.mIndices = new int[1 + len];
        return attrs;
    }
    return new TypedArray(res, new int[len * AssetManager.STYLE_NUM_ENTRIES], new int[1 + len], len);
}","{
    TypedArray attrs = res.mTypedArrayPool.acquire();
    if (attrs == null) {
        attrs = new TypedArray(res);
    }
    attrs.mRecycled = false;
    // Reset the assets, which may have changed due to configuration changes
    // or further resource loading.
    attrs.mAssets = res.getAssets();
    attrs.mMetrics = res.getDisplayMetrics();
    attrs.resize(len);
    return attrs;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5","1,5","The return statement has changed as the implementation of obtaining a TypedArray is modified. The length property (mLength) and data property (mData) setting have been replaced by a call to attrs.resize(len), which suggests that not only the return statement but also the internal structure and fields of the TypedArray are being modified within the method. There is also a control dependency change with the condition statement and the control flow is different. Additionally, in the late version, a new line is added that sets the mMetrics of attrs, and the initialization of attrs in the case of a null value from the pool has changed, so the code change type is 1,3,4,5.","The method may return a TypedArray that is initialized differently than before; specifically, the changes to the initialization logic and the new resize method may lead to TypedArray instances with different internal states. Moreover, the introduction of metrics assignment (attrs.mMetrics = res.getDisplayMetrics();) suggests that the returned TypedArray could potentially contain different information related to display metrics which was not present before, leading to different behavior in the late version. Finally, the differences in the initialization of attrs when attrs is `null` also presents a potential difference in the behavior. A Compatibility Issue could arise due to different return values or types, as well as structural differences in the TypedArray due to refactored initialization and resizing processes, so the CI type is 1,5."
479,"<android.content.SyncAdapterType: void writeToParcel(Parcel,int)>",25,26,"<android.content.SyncAdapterType: void writeToParcel(Parcel,int)>","<android.content.SyncAdapterType: void writeToParcel(Parcel,int)>",0,"{
    if (isKey) {
        throw new IllegalStateException(""keys aren't parcelable"");
    }
    dest.writeString(authority);
    dest.writeString(accountType);
    dest.writeInt(userVisible ? 1 : 0);
    dest.writeInt(supportsUploading ? 1 : 0);
    dest.writeInt(isAlwaysSyncable ? 1 : 0);
    dest.writeInt(allowParallelSyncs ? 1 : 0);
    dest.writeString(settingsActivity);
}","{
    if (isKey) {
        throw new IllegalStateException(""keys aren't parcelable"");
    }
    dest.writeString(authority);
    dest.writeString(accountType);
    dest.writeInt(userVisible ? 1 : 0);
    dest.writeInt(supportsUploading ? 1 : 0);
    dest.writeInt(isAlwaysSyncable ? 1 : 0);
    dest.writeInt(allowParallelSyncs ? 1 : 0);
    dest.writeString(settingsActivity);
    dest.writeString(packageName);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"An additional ""dest.writeString(packageName);"" statement has been added, which indicates that an additional value is written to the Parcel object. This is an 'Other statement changed' scenario without changing the behavior of existing code regarding what is returned or exception handling, so the code change type is 4.","There is no Compatibility Issue since the method's core functionality and its exception handling remain unchanged. Additional data is being written to the parcel, but this does not affect how the method operates, it only affects the parcel contents, assuming that the reading side is expecting this new piece of data. Hence, no CI is detected, and the CI type is 0."
480,<android.content.IntentFilter: void writeToXml(XmlSerializer)>,25,26,<android.content.IntentFilter: void writeToXml(XmlSerializer)>,<android.content.IntentFilter: void writeToXml(XmlSerializer)>,0,"{
    if (getAutoVerify()) {
        serializer.attribute(null, AUTO_VERIFY_STR, Boolean.toString(true));
    }
    int N = countActions();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, ACTION_STR);
        serializer.attribute(null, NAME_STR, mActions.get(i));
        serializer.endTag(null, ACTION_STR);
    }
    N = countCategories();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, CAT_STR);
        serializer.attribute(null, NAME_STR, mCategories.get(i));
        serializer.endTag(null, CAT_STR);
    }
    N = countDataTypes();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, TYPE_STR);
        String type = mDataTypes.get(i);
        if (type.indexOf('/') < 0)
            type = type + ""/*"";
        serializer.attribute(null, NAME_STR, type);
        serializer.endTag(null, TYPE_STR);
    }
    N = countDataSchemes();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, SCHEME_STR);
        serializer.attribute(null, NAME_STR, mDataSchemes.get(i));
        serializer.endTag(null, SCHEME_STR);
    }
    N = countDataSchemeSpecificParts();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, SSP_STR);
        PatternMatcher pe = mDataSchemeSpecificParts.get(i);
        switch(pe.getType()) {
            case PatternMatcher.PATTERN_LITERAL:
                serializer.attribute(null, LITERAL_STR, pe.getPath());
                break;
            case PatternMatcher.PATTERN_PREFIX:
                serializer.attribute(null, PREFIX_STR, pe.getPath());
                break;
            case PatternMatcher.PATTERN_SIMPLE_GLOB:
                serializer.attribute(null, SGLOB_STR, pe.getPath());
                break;
        }
        serializer.endTag(null, SSP_STR);
    }
    N = countDataAuthorities();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, AUTH_STR);
        AuthorityEntry ae = mDataAuthorities.get(i);
        serializer.attribute(null, HOST_STR, ae.getHost());
        if (ae.getPort() >= 0) {
            serializer.attribute(null, PORT_STR, Integer.toString(ae.getPort()));
        }
        serializer.endTag(null, AUTH_STR);
    }
    N = countDataPaths();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, PATH_STR);
        PatternMatcher pe = mDataPaths.get(i);
        switch(pe.getType()) {
            case PatternMatcher.PATTERN_LITERAL:
                serializer.attribute(null, LITERAL_STR, pe.getPath());
                break;
            case PatternMatcher.PATTERN_PREFIX:
                serializer.attribute(null, PREFIX_STR, pe.getPath());
                break;
            case PatternMatcher.PATTERN_SIMPLE_GLOB:
                serializer.attribute(null, SGLOB_STR, pe.getPath());
                break;
        }
        serializer.endTag(null, PATH_STR);
    }
}","{
    if (getAutoVerify()) {
        serializer.attribute(null, AUTO_VERIFY_STR, Boolean.toString(true));
    }
    int N = countActions();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, ACTION_STR);
        serializer.attribute(null, NAME_STR, mActions.get(i));
        serializer.endTag(null, ACTION_STR);
    }
    N = countCategories();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, CAT_STR);
        serializer.attribute(null, NAME_STR, mCategories.get(i));
        serializer.endTag(null, CAT_STR);
    }
    N = countDataTypes();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, TYPE_STR);
        String type = mDataTypes.get(i);
        if (type.indexOf('/') < 0)
            type = type + ""/*"";
        serializer.attribute(null, NAME_STR, type);
        serializer.endTag(null, TYPE_STR);
    }
    N = countDataSchemes();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, SCHEME_STR);
        serializer.attribute(null, NAME_STR, mDataSchemes.get(i));
        serializer.endTag(null, SCHEME_STR);
    }
    N = countDataSchemeSpecificParts();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, SSP_STR);
        PatternMatcher pe = mDataSchemeSpecificParts.get(i);
        switch(pe.getType()) {
            case PatternMatcher.PATTERN_LITERAL:
                serializer.attribute(null, LITERAL_STR, pe.getPath());
                break;
            case PatternMatcher.PATTERN_PREFIX:
                serializer.attribute(null, PREFIX_STR, pe.getPath());
                break;
            case PatternMatcher.PATTERN_SIMPLE_GLOB:
                serializer.attribute(null, SGLOB_STR, pe.getPath());
                break;
            case PatternMatcher.PATTERN_ADVANCED_GLOB:
                serializer.attribute(null, AGLOB_STR, pe.getPath());
                break;
        }
        serializer.endTag(null, SSP_STR);
    }
    N = countDataAuthorities();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, AUTH_STR);
        AuthorityEntry ae = mDataAuthorities.get(i);
        serializer.attribute(null, HOST_STR, ae.getHost());
        if (ae.getPort() >= 0) {
            serializer.attribute(null, PORT_STR, Integer.toString(ae.getPort()));
        }
        serializer.endTag(null, AUTH_STR);
    }
    N = countDataPaths();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, PATH_STR);
        PatternMatcher pe = mDataPaths.get(i);
        switch(pe.getType()) {
            case PatternMatcher.PATTERN_LITERAL:
                serializer.attribute(null, LITERAL_STR, pe.getPath());
                break;
            case PatternMatcher.PATTERN_PREFIX:
                serializer.attribute(null, PREFIX_STR, pe.getPath());
                break;
            case PatternMatcher.PATTERN_SIMPLE_GLOB:
                serializer.attribute(null, SGLOB_STR, pe.getPath());
                break;
            case PatternMatcher.PATTERN_ADVANCED_GLOB:
                serializer.attribute(null, AGLOB_STR, pe.getPath());
                break;
        }
        serializer.endTag(null, PATH_STR);
    }
}",1,"/**
 * Write the contents of the IntentFilter as an XML stream.
 */
","/**
 * Write the contents of the IntentFilter as an XML stream.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
481,"<android.app.SharedPreferencesImpl.EditorImpl: Editor putLong(String,long)>",25,26,"<android.app.SharedPreferencesImpl.EditorImpl: Editor putLong(String,long)>","<android.app.SharedPreferencesImpl.EditorImpl: Editor putLong(String,long)>",0,"{
    synchronized (this) {
        mModified.put(key, value);
        return this;
    }
}","{
    synchronized (mLock) {
        mModified.put(key, value);
        return this;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change is the object on which the synchronized block is locking: from 'this' to 'mLock'. This is a synchronization change, but does not affect what is returned, nor does it affect exceptions that may be thrown, hence the change type is 4.","Although there is a change in the synchronization lock, this does not lead to a compatibility issue as the behavior of the method regarding the put operation and the return value does not change. Hence, there is no compatibility issue, CI type is 0."
482,<android.content.pm.permission.RuntimePermissionPresenter.RemoteService: void handleMessage(Message)>,25,26,<android.content.pm.permission.RuntimePermissionPresenter.RemoteService: void handleMessage(Message)>,<android.content.pm.permission.RuntimePermissionPresenter.RemoteService: void handleMessage(Message)>,0,"{
    switch(msg.what) {
        case MSG_GET_APP_PERMISSIONS:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                final String packageName = (String) args.arg1;
                final OnResultCallback callback = (OnResultCallback) args.arg2;
                final Handler handler = (Handler) args.arg3;
                args.recycle();
                final IRuntimePermissionPresenter remoteInstance;
                synchronized (mLock) {
                    remoteInstance = mRemoteInstance;
                }
                if (remoteInstance == null) {
                    return;
                }
                try {
                    remoteInstance.getAppPermissions(packageName, new RemoteCallback(new RemoteCallback.OnResultListener() {

                        @Override
                        public void onResult(Bundle result) {
                            final List<RuntimePermissionPresentationInfo> reportedPermissions;
                            List<RuntimePermissionPresentationInfo> permissions = null;
                            if (result != null) {
                                permissions = result.getParcelableArrayList(KEY_RESULT);
                            }
                            if (permissions == null) {
                                permissions = Collections.emptyList();
                            }
                            reportedPermissions = permissions;
                            if (handler != null) {
                                handler.post(new Runnable() {

                                    @Override
                                    public void run() {
                                        callback.onGetAppPermissions(reportedPermissions);
                                    }
                                });
                            } else {
                                callback.onGetAppPermissions(reportedPermissions);
                            }
                        }
                    }, this));
                } catch (RemoteException re) {
                    Log.e(TAG, ""Error getting app permissions"", re);
                }
                scheduleUnbind();
            }
            break;
        case MSG_GET_APPS_USING_PERMISSIONS:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                final OnResultCallback callback = (OnResultCallback) args.arg1;
                final Handler handler = (Handler) args.arg2;
                final boolean system = args.argi1 == 1;
                args.recycle();
                final IRuntimePermissionPresenter remoteInstance;
                synchronized (mLock) {
                    remoteInstance = mRemoteInstance;
                }
                if (remoteInstance == null) {
                    return;
                }
                try {
                    remoteInstance.getAppsUsingPermissions(system, new RemoteCallback(new RemoteCallback.OnResultListener() {

                        @Override
                        public void onResult(Bundle result) {
                            final List<ApplicationInfo> reportedApps;
                            List<ApplicationInfo> apps = null;
                            if (result != null) {
                                apps = result.getParcelableArrayList(KEY_RESULT);
                            }
                            if (apps == null) {
                                apps = Collections.emptyList();
                            }
                            reportedApps = apps;
                            if (handler != null) {
                                handler.post(new Runnable() {

                                    @Override
                                    public void run() {
                                        callback.getAppsUsingPermissions(system, reportedApps);
                                    }
                                });
                            } else {
                                callback.getAppsUsingPermissions(system, reportedApps);
                            }
                        }
                    }, this));
                } catch (RemoteException re) {
                    Log.e(TAG, ""Error getting apps using permissions"", re);
                }
                scheduleUnbind();
            }
            break;
        case MSG_UNBIND:
            {
                synchronized (mLock) {
                    if (mBound) {
                        mContext.unbindService(this);
                        mBound = false;
                    }
                    mRemoteInstance = null;
                }
            }
            break;
    }
    synchronized (mLock) {
        scheduleNextMessageIfNeededLocked();
    }
}","{
    switch(msg.what) {
        case MSG_GET_APP_PERMISSIONS:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                final String packageName = (String) args.arg1;
                final OnResultCallback callback = (OnResultCallback) args.arg2;
                final Handler handler = (Handler) args.arg3;
                args.recycle();
                final IRuntimePermissionPresenter remoteInstance;
                synchronized (mLock) {
                    remoteInstance = mRemoteInstance;
                }
                if (remoteInstance == null) {
                    return;
                }
                try {
                    remoteInstance.getAppPermissions(packageName, new RemoteCallback(new RemoteCallback.OnResultListener() {

                        @Override
                        public void onResult(Bundle result) {
                            final List<RuntimePermissionPresentationInfo> reportedPermissions;
                            List<RuntimePermissionPresentationInfo> permissions = null;
                            if (result != null) {
                                permissions = result.getParcelableArrayList(KEY_RESULT);
                            }
                            if (permissions == null) {
                                permissions = Collections.emptyList();
                            }
                            reportedPermissions = permissions;
                            if (handler != null) {
                                handler.post(new Runnable() {

                                    @Override
                                    public void run() {
                                        callback.onGetAppPermissions(reportedPermissions);
                                    }
                                });
                            } else {
                                callback.onGetAppPermissions(reportedPermissions);
                            }
                        }
                    }, this));
                } catch (RemoteException re) {
                    Log.e(TAG, ""Error getting app permissions"", re);
                }
                scheduleUnbind();
            }
            break;
        case MSG_UNBIND:
            {
                synchronized (mLock) {
                    if (mBound) {
                        mContext.unbindService(this);
                        mBound = false;
                    }
                    mRemoteInstance = null;
                }
            }
            break;
    }
    synchronized (mLock) {
        scheduleNextMessageIfNeededLocked();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
483,<android.transition.TransitionManager.MultiListener: boolean onPreDraw()>,25,26,<android.transition.TransitionManager.MultiListener: boolean onPreDraw()>,<android.transition.TransitionManager.MultiListener: boolean onPreDraw()>,0,"{
    removeListeners();
    // Don't start the transition if it's no longer pending.
    if (!sPendingTransitions.remove(mSceneRoot)) {
        return true;
    }
    // Add to running list, handle end to remove it
    final ArrayMap<ViewGroup, ArrayList<Transition>> runningTransitions = getRunningTransitions();
    ArrayList<Transition> currentTransitions = runningTransitions.get(mSceneRoot);
    ArrayList<Transition> previousRunningTransitions = null;
    if (currentTransitions == null) {
        currentTransitions = new ArrayList<Transition>();
        runningTransitions.put(mSceneRoot, currentTransitions);
    } else if (currentTransitions.size() > 0) {
        previousRunningTransitions = new ArrayList<Transition>(currentTransitions);
    }
    currentTransitions.add(mTransition);
    mTransition.addListener(new Transition.TransitionListenerAdapter() {

        @Override
        public void onTransitionEnd(Transition transition) {
            ArrayList<Transition> currentTransitions = runningTransitions.get(mSceneRoot);
            currentTransitions.remove(transition);
        }
    });
    mTransition.captureValues(mSceneRoot, false);
    if (previousRunningTransitions != null) {
        for (Transition runningTransition : previousRunningTransitions) {
            runningTransition.resume(mSceneRoot);
        }
    }
    mTransition.playTransition(mSceneRoot);
    return true;
}","{
    removeListeners();
    // Don't start the transition if it's no longer pending.
    if (!sPendingTransitions.remove(mSceneRoot)) {
        return true;
    }
    // Add to running list, handle end to remove it
    final ArrayMap<ViewGroup, ArrayList<Transition>> runningTransitions = getRunningTransitions();
    ArrayList<Transition> currentTransitions = runningTransitions.get(mSceneRoot);
    ArrayList<Transition> previousRunningTransitions = null;
    if (currentTransitions == null) {
        currentTransitions = new ArrayList<Transition>();
        runningTransitions.put(mSceneRoot, currentTransitions);
    } else if (currentTransitions.size() > 0) {
        previousRunningTransitions = new ArrayList<Transition>(currentTransitions);
    }
    currentTransitions.add(mTransition);
    mTransition.addListener(new TransitionListenerAdapter() {

        @Override
        public void onTransitionEnd(Transition transition) {
            ArrayList<Transition> currentTransitions = runningTransitions.get(mSceneRoot);
            currentTransitions.remove(transition);
        }
    });
    mTransition.captureValues(mSceneRoot, false);
    if (previousRunningTransitions != null) {
        for (Transition runningTransition : previousRunningTransitions) {
            runningTransition.resume(mSceneRoot);
        }
    }
    mTransition.playTransition(mSceneRoot);
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,0,0,"There is no actual code change between the early and late implementations of this method. The method bodies are identical, and the annotation has not changed.","Since there are no changes in the implementations between the two versions of the API, no Compatibility Issue could arise."
484,<android.util.ArrayMap: int indexOfNull()>,25,26,<android.util.ArrayMap: int indexOfNull()>,<android.util.ArrayMap: int indexOfNull()>,0,"{
    final int N = mSize;
    // Important fast case: if nothing is in here, nothing to look for.
    if (N == 0) {
        return ~0;
    }
    int index = ContainerHelpers.binarySearch(mHashes, N, 0);
    // If the hash code wasn't found, then we have no entry for this key.
    if (index < 0) {
        return index;
    }
    // If the key at the returned index matches, that's what we want.
    if (null == mArray[index << 1]) {
        return index;
    }
    // Search for a matching key after the index.
    int end;
    for (end = index + 1; end < N && mHashes[end] == 0; end++) {
        if (null == mArray[end << 1])
            return end;
    }
    // Search for a matching key before the index.
    for (int i = index - 1; i >= 0 && mHashes[i] == 0; i--) {
        if (null == mArray[i << 1])
            return i;
    }
    // need to be copied when inserting.
    return ~end;
}","{
    final int N = mSize;
    // Important fast case: if nothing is in here, nothing to look for.
    if (N == 0) {
        return ~0;
    }
    int index = binarySearchHashes(mHashes, N, 0);
    // If the hash code wasn't found, then we have no entry for this key.
    if (index < 0) {
        return index;
    }
    // If the key at the returned index matches, that's what we want.
    if (null == mArray[index << 1]) {
        return index;
    }
    // Search for a matching key after the index.
    int end;
    for (end = index + 1; end < N && mHashes[end] == 0; end++) {
        if (null == mArray[end << 1])
            return end;
    }
    // Search for a matching key before the index.
    for (int i = index - 1; i >= 0 && mHashes[i] == 0; i--) {
        if (null == mArray[i << 1])
            return i;
    }
    // need to be copied when inserting.
    return ~end;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,5,1,"The method name called within the indexOfNull method has been updated from ContainerHelpers.binarySearch to binarySearchHashes, so the code change type is 5.","Even though the internal implementation of the method binarySearchHashes is not shown, the change in the dependent API method name suggests that there has been a change in dependency. This implies that there could be a change in how the indexOfNull method behaves, potentially leading to a different value being returned – hence a Compatibility Issue of type 1."
486,<android.app.ActivityManager: void setVrThread(int)>,25,26,<android.app.ActivityManager: void setVrThread(int)>,<android.app.ActivityManager: void setVrThread(int)>,0,"{
    try {
        ActivityManagerNative.getDefault().setVrThread(tid);
    } catch (RemoteException e) {
    // pass
    }
}","{
    try {
        getService().setVrThread(tid);
    } catch (RemoteException e) {
    // pass
    }
}",1,"/**
 * Enable more aggressive scheduling for latency-sensitive low-runtime VR threads. Only one
 * thread can be a VR thread in a process at a time, and that thread may be subject to
 * restrictions on the amount of time it can run.
 *
 * To reset the VR thread for an application, a tid of 0 can be passed.
 *
 * @see android.os.Process#myTid()
 * @param tid tid of the VR thread
 */
","/**
 * Enable more aggressive scheduling for latency-sensitive low-runtime VR threads. Only one
 * thread can be a VR thread in a process at a time, and that thread may be subject to
 * restrictions on the amount of time it can run.
 *
 * If persistent VR mode is set, whatever thread has been granted aggressive scheduling via this
 * method will return to normal operation, and calling this method will do nothing while
 * persistent VR mode is enabled.
 *
 * To reset the VR thread for an application, a tid of 0 can be passed.
 *
 * @see android.os.Process#myTid()
 * @param tid tid of the VR thread
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method used to get the service instance has changed from `ActivityManagerNative.getDefault()` to `getService()`. However, there is no change in the actual behavior of the method because the try block and the catch block remain the same. Hence, the code change type is 4,5.",There is no Compatibility Issue since the method signature remains the same and there are no changes in the return type or the exception handling which affects the method's behavior. The change in the service acquisition method does not affect the external behavior of the `setVrThread` method.
487,<android.view.View: boolean isFocusable()>,25,26,<android.view.View: boolean isFocusable()>,<android.view.View: boolean isFocusable()>,0,"{
    return FOCUSABLE == (mViewFlags & FOCUSABLE_MASK);
}","{
    return FOCUSABLE == (mViewFlags & FOCUSABLE);
}",1,"/**
 * Returns whether this View is able to take focus.
 *
 * @return True if this view can take focus, or false otherwise.
 * @attr ref android.R.styleable#View_focusable
 */
","/**
 * Returns whether this View is currently able to take focus.
 *
 * @return True if this view can take focus, or false otherwise.
 */
",-1,"[@ViewDebug.ExportedProperty(category = ""focus"")]","[@ViewDebug.ExportedProperty(category = ""focus"")]",-1,-1,-1,-1,-1,-1,4,0,"There is a change in the logic for checking if a view is focusable, specifically in the bitmask operation used. While this is a change in the logic (mViewFlags & FOCUSABLE_MASK to mViewFlags & FOCUSABLE), the outcome should logically remain the same assuming that FOCUSABLE is a correctly defined bit within FOCUSABLE_MASK that represents whether a view is focusable. Therefore, the change type is 4 (Other statement changed).","There should be no compatibility issue as the intended logic appears to remain constant: determining if the view is focusable using the appropriate flag within mViewFlags. The actual value returned by the method should not change between versions, assuming the use of FOCUSABLE_MASK and FOCUSABLE constants are consistent with their purpose. Hence, the CI type is 0 (No Compatibility Issue)."
488,"<android.view.Surface: void writeToParcel(Parcel,int)>",25,26,"<android.view.Surface: void writeToParcel(Parcel,int)>","<android.view.Surface: void writeToParcel(Parcel,int)>",0,"{
    if (dest == null) {
        throw new IllegalArgumentException(""dest must not be null"");
    }
    synchronized (mLock) {
        dest.writeString(mName);
        nativeWriteToParcel(mNativeObject, dest);
    }
    if ((flags & Parcelable.PARCELABLE_WRITE_RETURN_VALUE) != 0) {
        release();
    }
}","{
    if (dest == null) {
        throw new IllegalArgumentException(""dest must not be null"");
    }
    synchronized (mLock) {
        // NOTE: This must be kept synchronized with the native parceling code
        // in frameworks/native/libs/Surface.cpp
        dest.writeString(mName);
        dest.writeInt(mIsSingleBuffered ? 1 : 0);
        nativeWriteToParcel(mNativeObject, dest);
    }
    if ((flags & Parcelable.PARCELABLE_WRITE_RETURN_VALUE) != 0) {
        release();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,The addition of the statement dest.writeInt(mIsSingleBuffered ? 1 : 0); is a change that does not affect any exception being thrown or the return type or value of the method - it adds extra data to the parcel - so the code change type is 4.,"No Compatibility Issue arises from this change, since it does not alter the control flow, exceptions thrown, or return values/types of the method, it simply adds more information to the parcel passed to the method. Hence, the CI type is 0."
489,<android.app.job.JobInfo: boolean isRequireDeviceIdle()>,25,26,<android.app.job.JobInfo: boolean isRequireDeviceIdle()>,<android.app.job.JobInfo: boolean isRequireDeviceIdle()>,0,"{
    return requireDeviceIdle;
}","{
    return (constraintFlags & CONSTRAINT_FLAG_DEVICE_IDLE) != 0;
}",1,"/**
 * Whether this job needs the device to be in an Idle maintenance window.
 */
","/**
 * Whether this job needs the device to be in an Idle maintenance window.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The method of determining the return value has changed from directly returning a variable 'requireDeviceIdle' to evaluating an expression involving 'constraintFlags & CONSTRAINT_FLAG_DEVICE_IDLE'. There is also a change in the logic that determines the boolean value to return, so the code change type is 1,4.","The method no longer returns a simple variable; it now returns the result of a bitwise operation, which could potentially yield a different result compared to the direct variable value in the early version. This constitutes a change that affects the return value, and therefore, the CI type is 1."
490,<android.app.Notification.Builder: RemoteViews createBigContentView()>,25,26,<android.app.Notification.Builder: RemoteViews createBigContentView()>,<android.app.Notification.Builder: RemoteViews createBigContentView()>,0,"{
    RemoteViews result = null;
    if (mN.bigContentView != null && (mStyle == null || !mStyle.displayCustomViewInline())) {
        return mN.bigContentView;
    } else if (mStyle != null) {
        result = mStyle.makeBigContentView();
        hideLine1Text(result);
    } else if (mActions.size() != 0) {
        result = applyStandardTemplateWithActions(getBigBaseLayoutResource());
    }
    adaptNotificationHeaderForBigContentView(result);
    return result;
}","{
    RemoteViews result = null;
    if (mN.bigContentView != null && useExistingRemoteView()) {
        return mN.bigContentView;
    } else if (mStyle != null) {
        result = mStyle.makeBigContentView();
        hideLine1Text(result);
    } else if (mActions.size() != 0) {
        result = applyStandardTemplateWithActions(getBigBaseLayoutResource());
    }
    makeHeaderExpanded(result);
    return result;
}",1,"/**
 * Construct a RemoteViews for the final big notification layout.
 */
","/**
 * Construct a RemoteViews for the final big notification layout.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The condition in the if statement has changed from (mStyle == null || !mStyle.displayCustomViewInline()) to useExistingRemoteView(). Additionally, adaptNotificationHeaderForBigContentView(result) has been replaced by makeHeaderExpanded(result), so the change type is 3,4.","The changes are restricted to the internal implementation details without affecting the method's contract, output value, or exception handling behavior. The logic change in the if condition and the method change from adaptNotificationHeaderForBigContentView to makeHeaderExpanded do not necessarily lead to a compatibility issue since they don't imply returning a different type of value or throwing a new kind of exception. We haven't been told specifics about the implementation of `useExistingRemoteView()` or `makeHeaderExpanded(result)`, hence we can't definitively say they lead to CI; the CI determination would require knowledge about the behavior of these methods and if they maintain the same contracts as their predecessors. Without further information, the presumption is that their behavior aims to be functionally equivalent to the methods they replaced. Therefore, there's no compatibility issue because the returned `RemoteViews` object is expected to be of the same type and hold equivalent content from a user perspective."
493,<android.app.ContextImpl: ContextImpl createSystemContext(ActivityThread)>,25,26,<android.app.ContextImpl: ContextImpl createSystemContext(ActivityThread)>,<android.app.ContextImpl: ContextImpl createSystemContext(ActivityThread)>,0,"{
    LoadedApk packageInfo = new LoadedApk(mainThread);
    ContextImpl context = new ContextImpl(null, mainThread, packageInfo, null, null, 0, null, null, Display.INVALID_DISPLAY);
    context.mResources.updateConfiguration(context.mResourcesManager.getConfiguration(), context.mResourcesManager.getDisplayMetrics());
    return context;
}","{
    LoadedApk packageInfo = new LoadedApk(mainThread);
    ContextImpl context = new ContextImpl(null, mainThread, packageInfo, null, null, null, 0, null);
    context.setResources(packageInfo.getResources());
    context.mResources.updateConfiguration(context.mResourcesManager.getConfiguration(), context.mResourcesManager.getDisplayMetrics());
    return context;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",0,"In the late version implementation, the constructor of ContextImpl has one fewer parameter, and a direct call to `setResources` method on the context object is added. The parameters passed to `ContextImpl` constructor, as well as the overall sequence of method invocations, have changed. Therefore, the code change is a combination of control dependency change (3), other statement change (4), and dependent API change, due to constructor parameter list alteration (5).","While the constructor for ContextImpl and the way resources are set have changed, both versions ultimately set the resources for the context and update its configuration. Assuming that the `LoadedApk.getResources()` method and `ContextImpl` constructor define and initialize the `ContextImpl` instance to be functionally equivalent in terms of resources in both versions, there should be no compatibility issue regarding different return values or types, or different exceptions being thrown. The changes seem aimed at refactoring rather than altering behavior. Hence, there is no compatibility issue (0)."
494,<android.widget.Toast: void cancel()>,25,26,<android.widget.Toast: void cancel()>,<android.widget.Toast: void cancel()>,0,"{
    mTN.hide();
    try {
        getService().cancelToast(mContext.getPackageName(), mTN);
    } catch (RemoteException e) {
    // Empty
    }
}","{
    mTN.cancel();
}",1,"/**
 * Close the view if it's showing, or don't show it if it isn't showing yet.
 * You do not normally have to call this.  Normally view will disappear on its own
 * after the appropriate duration.
 */
","/**
 * Close the view if it's showing, or don't show it if it isn't showing yet.
 * You do not normally have to call this.  Normally view will disappear on its own
 * after the appropriate duration.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method body has been completely replaced from calling mTN.hide() and getService().cancelToast() to only mTN.cancel(), suggesting that a Dependent API has been changed, so the code change type is 5.","Although there's a significant change in the method body, it doesn't necessarily lead to a Compatibility Issue as long as the new `mTN.cancel()` method is designed to encapsulate the previous functionality (hide the toast and cancel it). The internal changes are not exposed to the caller, which means the external behavior (from the caller's perspective) remains unchanged. Thus, the CI type is 0."
495,"<android.app.Activity: void dispatchActivityResult(String,int,int,Intent)>",25,26,"<android.app.Activity: void dispatchActivityResult(String,int,int,Intent)>","<android.app.Activity: void dispatchActivityResult(String,int,int,Intent)>",0,"{
    if (false)
        Log.v(TAG, ""Dispatching result: who="" + who + "", reqCode="" + requestCode + "", resCode="" + resultCode + "", data="" + data);
    mFragments.noteStateNotSaved();
    if (who == null) {
        onActivityResult(requestCode, resultCode, data);
    } else if (who.startsWith(REQUEST_PERMISSIONS_WHO_PREFIX)) {
        who = who.substring(REQUEST_PERMISSIONS_WHO_PREFIX.length());
        if (TextUtils.isEmpty(who)) {
            dispatchRequestPermissionsResult(requestCode, data);
        } else {
            Fragment frag = mFragments.findFragmentByWho(who);
            if (frag != null) {
                dispatchRequestPermissionsResultToFragment(requestCode, data, frag);
            }
        }
    } else if (who.startsWith(""@android:view:"")) {
        ArrayList<ViewRootImpl> views = WindowManagerGlobal.getInstance().getRootViews(getActivityToken());
        for (ViewRootImpl viewRoot : views) {
            if (viewRoot.getView() != null && viewRoot.getView().dispatchActivityResult(who, requestCode, resultCode, data)) {
                return;
            }
        }
    } else {
        Fragment frag = mFragments.findFragmentByWho(who);
        if (frag != null) {
            frag.onActivityResult(requestCode, resultCode, data);
        }
    }
}","{
    if (false)
        Log.v(TAG, ""Dispatching result: who="" + who + "", reqCode="" + requestCode + "", resCode="" + resultCode + "", data="" + data);
    mFragments.noteStateNotSaved();
    if (who == null) {
        onActivityResult(requestCode, resultCode, data);
    } else if (who.startsWith(REQUEST_PERMISSIONS_WHO_PREFIX)) {
        who = who.substring(REQUEST_PERMISSIONS_WHO_PREFIX.length());
        if (TextUtils.isEmpty(who)) {
            dispatchRequestPermissionsResult(requestCode, data);
        } else {
            Fragment frag = mFragments.findFragmentByWho(who);
            if (frag != null) {
                dispatchRequestPermissionsResultToFragment(requestCode, data, frag);
            }
        }
    } else if (who.startsWith(""@android:view:"")) {
        ArrayList<ViewRootImpl> views = WindowManagerGlobal.getInstance().getRootViews(getActivityToken());
        for (ViewRootImpl viewRoot : views) {
            if (viewRoot.getView() != null && viewRoot.getView().dispatchActivityResult(who, requestCode, resultCode, data)) {
                return;
            }
        }
    } else if (who.startsWith(AUTO_FILL_AUTH_WHO_PREFIX)) {
        Intent resultData = (resultCode == Activity.RESULT_OK) ? data : null;
        getAutofillManager().onAuthenticationResult(requestCode, resultData);
    } else {
        Fragment frag = mFragments.findFragmentByWho(who);
        if (frag != null) {
            frag.onActivityResult(requestCode, resultCode, data);
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"A new 'else if' block checking for ""who.startsWith(AUTO_FILL_AUTH_WHO_PREFIX)"" has been added which includes a call to `getAutofillManager().onAuthenticationResult(requestCode, resultData);`. This is a control dependency change as a new condition has been added for execution, and also an other statement change because a new method call has been introduced, which is not tied to changing the control flow. Thus, the change type is 3,4.","Since a new control path has been added which results in a new behavior ('getAutofillManager().onAuthenticationResult(requestCode, resultData)'), the API could potentially return without calling `frag.onActivityResult(requestCode, resultCode, data)` for some inputs where `who.startsWith(AUTO_FILL_AUTH_WHO_PREFIX)` is `true`. This could lead to a different result, so the CI type is 1."
496,<android.app.Fragment: boolean getAllowEnterTransitionOverlap()>,25,26,<android.app.Fragment: boolean getAllowEnterTransitionOverlap()>,<android.app.Fragment: boolean getAllowEnterTransitionOverlap()>,0,"{
    return (mAllowEnterTransitionOverlap == null) ? true : mAllowEnterTransitionOverlap;
}","{
    return (mAnimationInfo == null || mAnimationInfo.mAllowEnterTransitionOverlap == null) ? true : mAnimationInfo.mAllowEnterTransitionOverlap;
}",1,"/**
 * Returns whether the the exit transition and enter transition overlap or not.
 * When true, the enter transition will start as soon as possible. When false, the
 * enter transition will wait until the exit transition completes before starting.
 *
 * @return true when the enter transition should start as soon as possible or false to
 * when it should wait until the exiting transition completes.
 * @attr ref android.R.styleable#Fragment_fragmentAllowEnterTransitionOverlap
 */
","/**
 * Returns whether the the exit transition and enter transition overlap or not.
 * When true, the enter transition will start as soon as possible. When false, the
 * enter transition will wait until the exit transition completes before starting.
 *
 * @return true when the enter transition should start as soon as possible or false to
 * when it should wait until the exiting transition completes.
 * @attr ref android.R.styleable#Fragment_fragmentAllowEnterTransitionOverlap
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"The condition statement in the return expression has changed by checking an additional object (mAnimationInfo) before accessing mAllowEnterTransitionOverlap. This modification affects the control flow, so the code change type is 3.","This change in the control dependency can lead to different behavior. In the early version, the method always directly checks mAllowEnterTransitionOverlap, returning true if it's null, otherwise returning its value. In the late version, it also checks if mAnimationInfo is null before checking mAllowEnterTransitionOverlap. This additional check could potentially lead to a different return value, hence the CI type is 1."
497,"<android.app.ContextImpl: Intent registerReceiverAsUser(BroadcastReceiver,UserHandle,IntentFilter,String,Handler)>",25,26,"<android.app.ContextImpl: Intent registerReceiverAsUser(BroadcastReceiver,UserHandle,IntentFilter,String,Handler)>","<android.app.ContextImpl: Intent registerReceiverAsUser(BroadcastReceiver,UserHandle,IntentFilter,String,Handler)>",0,"{
    return registerReceiverInternal(receiver, user.getIdentifier(), filter, broadcastPermission, scheduler, getOuterContext());
}","{
    return registerReceiverInternal(receiver, user.getIdentifier(), filter, broadcastPermission, scheduler, getOuterContext(), 0);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"A new argument '0' is added to the method call registerReceiverInternal() in the late version. This represents a change in the usage of a dependent API, hence the code change type is 5.","There is an additional parameter ('0') being passed to the method registerReceiverInternal(), but there's no indication that this changes the behaviour of the method in a way that would cause a compatibility issue. Unless the internals of registerReceiverInternal() have changed in such a way that the additional parameter alters its behavior noticeably to the caller of registerReceiverAsUser(), there isn't enough information to claim that a compatibility issue exists. Thus, the CI type is 0."
499,<android.text.TextUtils: CharSequence concat(CharSequence)>,25,26,<android.text.TextUtils: CharSequence concat(CharSequence)>,<android.text.TextUtils: CharSequence concat(CharSequence)>,0,"{
    if (text.length == 0) {
        return """";
    }
    if (text.length == 1) {
        return text[0];
    }
    boolean spanned = false;
    for (int i = 0; i < text.length; i++) {
        if (text[i] instanceof Spanned) {
            spanned = true;
            break;
        }
    }
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < text.length; i++) {
        sb.append(text[i]);
    }
    if (!spanned) {
        return sb.toString();
    }
    SpannableString ss = new SpannableString(sb);
    int off = 0;
    for (int i = 0; i < text.length; i++) {
        int len = text[i].length();
        if (text[i] instanceof Spanned) {
            copySpansFrom((Spanned) text[i], 0, len, Object.class, ss, off);
        }
        off += len;
    }
    return new SpannedString(ss);
}","{
    if (text.length == 0) {
        return """";
    }
    if (text.length == 1) {
        return text[0];
    }
    boolean spanned = false;
    for (CharSequence piece : text) {
        if (piece instanceof Spanned) {
            spanned = true;
            break;
        }
    }
    if (spanned) {
        final SpannableStringBuilder ssb = new SpannableStringBuilder();
        for (CharSequence piece : text) {
            // If a piece is null, we append the string ""null"" for compatibility with the
            // behavior of StringBuilder and the behavior of the concat() method in earlier
            // versions of Android.
            ssb.append(piece == null ? ""null"" : piece);
        }
        return new SpannedString(ssb);
    } else {
        final StringBuilder sb = new StringBuilder();
        for (CharSequence piece : text) {
            sb.append(piece);
        }
        return sb.toString();
    }
}",1,"/**
 * Returns a CharSequence concatenating the specified CharSequences,
 * retaining their spans if any.
 */
","/**
 * Returns a CharSequence concatenating the specified CharSequences,
 * retaining their spans if any.
 *
 * If there are no parameters, an empty string will be returned.
 *
 * If the number of parameters is exactly one, that parameter is returned as output, even if it
 * is null.
 *
 * If the number of parameters is at least two, any null CharSequence among the parameters is
 * treated as if it was the string <code>""null""</code>.
 *
 * If there are paragraph spans in the source CharSequences that satisfy paragraph boundary
 * requirements in the sources but would no longer satisfy them in the concatenated
 * CharSequence, they may get extended in the resulting CharSequence or not retained.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The code has undergone changes in the for loop structure and the logic that decides how to concatenate the text parts. In the early implementation, it uses a traditional for loop with index, while the late implementation utilizes an enhanced for loop. Moreover, the handling of Spanned instances and the logic for building the final result have been significantly refactored. This constitutes a control dependency change (3) and other statement changes (4).","Due to the changes in the logic for building the result and how null text pieces are handled (""null"" is appended in the late version, while it would have caused a NullPointerException in the early version), the behavior and potentially the return value of the method has changed. Therefore, a compatibility issue may arise because the same input can yield a different output in the late version compared to the early version. Hence, a CI is identified as type 1 (Compatibility Issue caused by potential different return values)."
500,<android.appwidget.AppWidgetManager: List<AppWidgetProviderInfo> getInstalledProvidersForProfile(UserHandle)>,25,26,<android.appwidget.AppWidgetManager: List<AppWidgetProviderInfo> getInstalledProvidersForProfile(UserHandle)>,<android.appwidget.AppWidgetManager: List<AppWidgetProviderInfo> getInstalledProvidersForProfile(UserHandle)>,0,"{
    if (mService == null) {
        return Collections.emptyList();
    }
    return getInstalledProvidersForProfile(AppWidgetProviderInfo.WIDGET_CATEGORY_HOME_SCREEN, profile);
}","{
    if (mService == null) {
        return Collections.emptyList();
    }
    return getInstalledProvidersForProfile(AppWidgetProviderInfo.WIDGET_CATEGORY_HOME_SCREEN, profile, null);
}",1,"/**
 * Gets the AppWidget providers for the given user profile. User profile can only
 * be the current user or a profile of the current user. For example, the current
 * user may have a corporate profile. In this case the parent user profile has a
 * child profile, the corporate one.
 *
 * @param profile The profile for which to get providers. Passing null is equivaled
 * to passing only the current user handle.
 * @return The intalled providers.
 *
 * @see android.os.Process#myUserHandle()
 * @see android.os.UserManager#getUserProfiles()
 */
","/**
 * Gets the AppWidget providers for the given user profile. User profile can only
 * be the current user or a profile of the current user. For example, the current
 * user may have a corporate profile. In this case the parent user profile has a
 * child profile, the corporate one.
 *
 * @param profile The profile for which to get providers. Passing null is equivalent
 * to querying for only the calling user.
 * @return The installed providers, or an empty list if none are found for the given user.
 *
 * @see android.os.Process#myUserHandle()
 * @see android.os.UserManager#getUserProfiles()
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,5,0,"The method getInstalledProvidersForProfile() is called with different parameters in the late version: an additional null parameter is passed. The dependent API getInstalledProvidersForProfile() definition is not provided, but it seems to be an overloaded method and this constitutes a change in the dependent API, thus the code change type is 5.","Because the call to getInstalledProvidersForProfile() has been changed to include an additional parameter, the difference in behavior is determined by the implementation of that method. Considering the API signature does not specify that implementation and the type of data returned remains the same (List<AppWidgetProviderInfo>), as long as the additional parameter doesn't change the semantics of the returned value, there will be no compatibility issue. Without the implementation of the overloaded method, we cannot ascertain if the behavior will change, so we assume no compatibility issue unless further context is provided, hence the CI type is 0."
502,"<android.content.pm.LauncherApps: List<LauncherActivityInfo> getActivityList(String,UserHandle)>",25,26,"<android.content.pm.LauncherApps: List<LauncherActivityInfo> getActivityList(String,UserHandle)>","<android.content.pm.LauncherApps: List<LauncherActivityInfo> getActivityList(String,UserHandle)>",0,"{
    ParceledListSlice<ResolveInfo> activities = null;
    try {
        activities = mService.getLauncherActivities(packageName, user);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
    if (activities == null) {
        return Collections.EMPTY_LIST;
    }
    ArrayList<LauncherActivityInfo> lais = new ArrayList<LauncherActivityInfo>();
    for (ResolveInfo ri : activities.getList()) {
        LauncherActivityInfo lai = new LauncherActivityInfo(mContext, ri.activityInfo, user);
        if (DEBUG) {
            Log.v(TAG, ""Returning activity for profile "" + user + "" : "" + lai.getComponentName());
        }
        lais.add(lai);
    }
    return lais;
}","{
    logErrorForInvalidProfileAccess(user);
    try {
        return convertToActivityList(mService.getLauncherActivities(mContext.getPackageName(), packageName, user), user);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}",1,"/**
 * Retrieves a list of launchable activities that match {@link Intent#ACTION_MAIN} and
 * {@link Intent#CATEGORY_LAUNCHER}, for a specified user.
 *
 * @param packageName The specific package to query. If null, it checks all installed packages
 * in the profile.
 * @param user The UserHandle of the profile.
 * @return List of launchable activities. Can be an empty list but will not be null.
 */
","/**
 * Retrieves a list of launchable activities that match {@link Intent#ACTION_MAIN} and
 * {@link Intent#CATEGORY_LAUNCHER}, for a specified user.
 *
 * @param packageName The specific package to query. If null, it checks all installed packages
 * in the profile.
 * @param user The UserHandle of the profile.
 * @return List of launchable activities. Can be an empty list but will not be null.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,Numerous statements have been changed: ,"3. The logic of converting ResolveInfo to LauncherActivityInfo and adding to a list is replaced with a call to `convertToActivityList(...)`, which is a dependent API change."
503,<android.content.ClipboardManager: boolean hasText()>,25,26,<android.content.ClipboardManager: boolean hasText()>,<android.content.ClipboardManager: boolean hasText()>,0,"{
    try {
        return getService().hasClipboardText(mContext.getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        return mService.hasClipboardText(mContext.getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * @deprecated Use {@link #hasPrimaryClip()} instead.
 */
","/**
 * @deprecated Use {@link #hasPrimaryClip()} instead.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,4,0,"The change from getService() to mService has happened within the try block, but both the early and late implementation retain the same functionality regarding exception handling and return values. If getService() and mService are referring to the same service and have no difference in behavior, this change falls into the category of other statement changes, specifically, the variable used to access the service.","There is no Compatibility Issue detected because there's no alteration in the behavior in terms of returned values, thrown exceptions, or control flow."
504,"<android.app.admin.DevicePolicyManager: boolean hasCaCertInstalled(ComponentName,byte[])>",25,26,"<android.app.admin.DevicePolicyManager: boolean hasCaCertInstalled(ComponentName,byte[])>","<android.app.admin.DevicePolicyManager: boolean hasCaCertInstalled(ComponentName,byte[])>",0,"{
    throwIfParentInstance(""hasCaCertInstalled"");
    if (mService != null) {
        try {
            mService.enforceCanManageCaCerts(admin);
            return getCaCertAlias(certBuffer) != null;
        } catch (RemoteException re) {
            throw re.rethrowFromSystemServer();
        } catch (CertificateException ce) {
            Log.w(TAG, ""Could not parse certificate"", ce);
        }
    }
    return false;
}","{
    throwIfParentInstance(""hasCaCertInstalled"");
    if (mService != null) {
        try {
            mService.enforceCanManageCaCerts(admin, mContext.getPackageName());
            return getCaCertAlias(certBuffer) != null;
        } catch (RemoteException re) {
            throw re.rethrowFromSystemServer();
        } catch (CertificateException ce) {
            Log.w(TAG, ""Could not parse certificate"", ce);
        }
    }
    return false;
}",1,"/**
 * Returns whether this certificate is installed as a trusted CA.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or
 * {@code null} if calling from a delegated certificate installer.
 * @param certBuffer encoded form of the certificate to look up.
 * @throws SecurityException if {@code admin} is not {@code null} and not a device or profile
 * owner.
 */
","/**
 * Returns whether this certificate is installed as a trusted CA.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or
 * {@code null} if calling from a delegated certificate installer.
 * @param certBuffer encoded form of the certificate to look up.
 * @throws SecurityException if {@code admin} is not {@code null} and not a device or profile
 * owner.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The change in the method `mService.enforceCanManageCaCerts(admin)` to `mService.enforceCanManageCaCerts(admin, mContext.getPackageName())` indicates that an extra parameter has been added to the method call, which is a dependent API that has changed. The change type is 5.","Since the addition of a new parameter to a method call does not affect the method's control flow or output, it would not necessarily result in a different behavior of the `hasCaCertInstalled` method, assuming the `enforceCanManageCaCerts` method is tolerant of the additional argument and functions as intended. Therefore, as long as the dependent API behaves in a backward-compatible manner, there is no compatibility issue. Hence, CI type is 0."
505,<android.app.Activity: void finishAffinity()>,25,26,<android.app.Activity: void finishAffinity()>,<android.app.Activity: void finishAffinity()>,0,"{
    if (mParent != null) {
        throw new IllegalStateException(""Can not be called from an embedded activity"");
    }
    if (mResultCode != RESULT_CANCELED || mResultData != null) {
        throw new IllegalStateException(""Can not be called to deliver a result"");
    }
    try {
        if (ActivityManagerNative.getDefault().finishActivityAffinity(mToken)) {
            mFinished = true;
        }
    } catch (RemoteException e) {
    // Empty
    }
}","{
    if (mParent != null) {
        throw new IllegalStateException(""Can not be called from an embedded activity"");
    }
    if (mResultCode != RESULT_CANCELED || mResultData != null) {
        throw new IllegalStateException(""Can not be called to deliver a result"");
    }
    try {
        if (ActivityManager.getService().finishActivityAffinity(mToken)) {
            mFinished = true;
        }
    } catch (RemoteException e) {
    // Empty
    }
}",1,"/**
 * Finish this activity as well as all activities immediately below it
 * in the current task that have the same affinity.  This is typically
 * used when an application can be launched on to another task (such as
 * from an ACTION_VIEW of a content type it understands) and the user
 * has used the up navigation to switch out of the current task and in
 * to its own task.  In this case, if the user has navigated down into
 * any other activities of the second application, all of those should
 * be removed from the original task as part of the task switch.
 *
 * <p>Note that this finish does <em>not</em> allow you to deliver results
 * to the previous activity, and an exception will be thrown if you are trying
 * to do so.</p>
 */
","/**
 * Finish this activity as well as all activities immediately below it
 * in the current task that have the same affinity.  This is typically
 * used when an application can be launched on to another task (such as
 * from an ACTION_VIEW of a content type it understands) and the user
 * has used the up navigation to switch out of the current task and in
 * to its own task.  In this case, if the user has navigated down into
 * any other activities of the second application, all of those should
 * be removed from the original task as part of the task switch.
 *
 * <p>Note that this finish does <em>not</em> allow you to deliver results
 * to the previous activity, and an exception will be thrown if you are trying
 * to do so.</p>
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The change is only in calling a different method from a different class for the Activity Manager (ActivityManagerNative.getDefault() vs. ActivityManager.getService()), so the code change type is 5.","Since there's no alteration to the logic or control flow, we have no indication that the behavior of the API would change from the information given. Thus, no compatibility issue is expected, and the CI type is 0."
507,"<android.content.ContentResolver: void takePersistableUriPermission(Uri,int)>",25,26,"<android.content.ContentResolver: void takePersistableUriPermission(Uri,int)>","<android.content.ContentResolver: void takePersistableUriPermission(Uri,int)>",0,"{
    Preconditions.checkNotNull(uri, ""uri"");
    try {
        ActivityManagerNative.getDefault().takePersistableUriPermission(ContentProvider.getUriWithoutUserId(uri), modeFlags, resolveUserId(uri));
    } catch (RemoteException e) {
    }
}","{
    Preconditions.checkNotNull(uri, ""uri"");
    try {
        ActivityManager.getService().takePersistableUriPermission(ContentProvider.getUriWithoutUserId(uri), modeFlags, resolveUserId(uri));
    } catch (RemoteException e) {
    }
}",1,"/**
 * Take a persistable URI permission grant that has been offered. Once
 * taken, the permission grant will be remembered across device reboots.
 * Only URI permissions granted with
 * {@link Intent#FLAG_GRANT_PERSISTABLE_URI_PERMISSION} can be persisted. If
 * the grant has already been persisted, taking it again will touch
 * {@link UriPermission#getPersistedTime()}.
 *
 * @see #getPersistedUriPermissions()
 */
","/**
 * Take a persistable URI permission grant that has been offered. Once
 * taken, the permission grant will be remembered across device reboots.
 * Only URI permissions granted with
 * {@link Intent#FLAG_GRANT_PERSISTABLE_URI_PERMISSION} can be persisted. If
 * the grant has already been persisted, taking it again will touch
 * {@link UriPermission#getPersistedTime()}.
 *
 * @see #getPersistedUriPermissions()
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method called on the ActivityManager object has been changed from ActivityManagerNative.getDefault() to ActivityManager.getService(), leading to a change in the dependent API; thus, code change type is 5.","While there's a change in the dependent API, the overall behavior of the method (taking persistable URI permission) is maintained as the change appears to be an internal refactoring with no impact on the method's contract or behavior. Therefore, there's no Compatibility Issue and CI type is 0."
509,"<android.widget.AbsListView.PositionScroller: void startWithOffset(int,int,int)>",25,26,"<android.widget.AbsListView.PositionScroller: void startWithOffset(int,int,int)>","<android.widget.AbsListView.PositionScroller: void startWithOffset(int,int,int)>",0,"{
    stop();
    if (mDataChanged) {
        // Wait until we're back in a stable state to try this.
        final int postOffset = offset;
        mPositionScrollAfterLayout = new Runnable() {

            @Override
            public void run() {
                startWithOffset(position, postOffset, duration);
            }
        };
        return;
    }
    final int childCount = getChildCount();
    if (childCount == 0) {
        // Can't scroll without children.
        return;
    }
    offset += getPaddingTop();
    mTargetPos = Math.max(0, Math.min(getCount() - 1, position));
    mOffsetFromTop = offset;
    mBoundPos = INVALID_POSITION;
    mLastSeenPos = INVALID_POSITION;
    mMode = MOVE_OFFSET;
    final int firstPos = mFirstPosition;
    final int lastPos = firstPos + childCount - 1;
    int viewTravelCount;
    if (mTargetPos < firstPos) {
        viewTravelCount = firstPos - mTargetPos;
    } else if (mTargetPos > lastPos) {
        viewTravelCount = mTargetPos - lastPos;
    } else {
        // On-screen, just scroll.
        final int targetTop = getChildAt(mTargetPos - firstPos).getTop();
        smoothScrollBy(targetTop - offset, duration, true);
        return;
    }
    // Estimate how many screens we should travel
    final float screenTravelCount = (float) viewTravelCount / childCount;
    mScrollDuration = screenTravelCount < 1 ? duration : (int) (duration / screenTravelCount);
    mLastSeenPos = INVALID_POSITION;
    postOnAnimation(this);
}","{
    stop();
    if (mDataChanged) {
        // Wait until we're back in a stable state to try this.
        final int postOffset = offset;
        mPositionScrollAfterLayout = new Runnable() {

            @Override
            public void run() {
                startWithOffset(position, postOffset, duration);
            }
        };
        return;
    }
    final int childCount = getChildCount();
    if (childCount == 0) {
        // Can't scroll without children.
        return;
    }
    offset += getPaddingTop();
    mTargetPos = Math.max(0, Math.min(getCount() - 1, position));
    mOffsetFromTop = offset;
    mBoundPos = INVALID_POSITION;
    mLastSeenPos = INVALID_POSITION;
    mMode = MOVE_OFFSET;
    final int firstPos = mFirstPosition;
    final int lastPos = firstPos + childCount - 1;
    int viewTravelCount;
    if (mTargetPos < firstPos) {
        viewTravelCount = firstPos - mTargetPos;
    } else if (mTargetPos > lastPos) {
        viewTravelCount = mTargetPos - lastPos;
    } else {
        // On-screen, just scroll.
        final int targetTop = getChildAt(mTargetPos - firstPos).getTop();
        smoothScrollBy(targetTop - offset, duration, true, false);
        return;
    }
    // Estimate how many screens we should travel
    final float screenTravelCount = (float) viewTravelCount / childCount;
    mScrollDuration = screenTravelCount < 1 ? duration : (int) (duration / screenTravelCount);
    mLastSeenPos = INVALID_POSITION;
    postOnAnimation(this);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The only change is in the parameters of the call to `smoothScrollBy`. An additional boolean parameter `false` is added to the late version of the call, and the method signature has been updated accordingly, so the code change type is 4.","The additional boolean parameter `false` appears to control a behavior in `smoothScrollBy`. Since the previous implementation did not specify this value, it can be assumed to be the default behavior for that method. Therefore, it would not necessarily represent a different behavior from the early version of the API, as long as the default for the unspecified parameter in the early version was false as well. Given only the information available, there would be no detected compatibility issue because the API's return type remains unchanged and no new exceptions have been indicated. The change appears to be an internal modification to a method call rather than a change in the API's interface or behavior."
510,<android.util.ArraySet: boolean add(E)>,25,26,<android.util.ArraySet: boolean add(E)>,<android.util.ArraySet: boolean add(E)>,0,"{
    final int hash;
    int index;
    if (value == null) {
        hash = 0;
        index = indexOfNull();
    } else {
        hash = mIdentityHashCode ? System.identityHashCode(value) : value.hashCode();
        index = indexOf(value, hash);
    }
    if (index >= 0) {
        return false;
    }
    index = ~index;
    if (mSize >= mHashes.length) {
        final int n = mSize >= (BASE_SIZE * 2) ? (mSize + (mSize >> 1)) : (mSize >= BASE_SIZE ? (BASE_SIZE * 2) : BASE_SIZE);
        if (DEBUG)
            Log.d(TAG, ""add: grow from "" + mHashes.length + "" to "" + n);
        final int[] ohashes = mHashes;
        final Object[] oarray = mArray;
        allocArrays(n);
        if (mHashes.length > 0) {
            if (DEBUG)
                Log.d(TAG, ""add: copy 0-"" + mSize + "" to 0"");
            System.arraycopy(ohashes, 0, mHashes, 0, ohashes.length);
            System.arraycopy(oarray, 0, mArray, 0, oarray.length);
        }
        freeArrays(ohashes, oarray, mSize);
    }
    if (index < mSize) {
        if (DEBUG)
            Log.d(TAG, ""add: move "" + index + ""-"" + (mSize - index) + "" to "" + (index + 1));
        System.arraycopy(mHashes, index, mHashes, index + 1, mSize - index);
        System.arraycopy(mArray, index, mArray, index + 1, mSize - index);
    }
    mHashes[index] = hash;
    mArray[index] = value;
    mSize++;
    return true;
}","{
    final int hash;
    int index;
    if (value == null) {
        hash = 0;
        index = indexOfNull();
    } else {
        hash = mIdentityHashCode ? System.identityHashCode(value) : value.hashCode();
        index = indexOf(value, hash);
    }
    if (index >= 0) {
        return false;
    }
    index = ~index;
    if (mSize >= mHashes.length) {
        final int n = mSize >= (BASE_SIZE * 2) ? (mSize + (mSize >> 1)) : (mSize >= BASE_SIZE ? (BASE_SIZE * 2) : BASE_SIZE);
        if (DEBUG)
            Log.d(TAG, ""add: grow from "" + mHashes.length + "" to "" + n);
        final int[] ohashes = mHashes;
        final Object[] oarray = mArray;
        allocArrays(n);
        if (mHashes.length > 0) {
            if (DEBUG)
                Log.d(TAG, ""add: copy 0-"" + mSize + "" to 0"");
            System.arraycopy(ohashes, 0, mHashes, 0, ohashes.length);
            System.arraycopy(oarray, 0, mArray, 0, oarray.length);
        }
        freeArrays(ohashes, oarray, mSize);
    }
    if (index < mSize) {
        if (DEBUG) {
            Log.d(TAG, ""add: move "" + index + ""-"" + (mSize - index) + "" to "" + (index + 1));
        }
        System.arraycopy(mHashes, index, mHashes, index + 1, mSize - index);
        System.arraycopy(mArray, index, mArray, index + 1, mSize - index);
    }
    mHashes[index] = hash;
    mArray[index] = value;
    mSize++;
    return true;
}",1,"/**
 * Adds the specified object to this set. The set is not modified if it
 * already contains the object.
 *
 * @param value the object to add.
 * @return {@code true} if this set is modified, {@code false} otherwise.
 * @throws ClassCastException
 * when the class of the object is inappropriate for this set.
 */
","/**
 * Adds the specified object to this set. The set is not modified if it
 * already contains the object.
 *
 * @param value the object to add.
 * @return {@code true} if this set is modified, {@code false} otherwise.
 * @throws ClassCastException
 * when the class of the object is inappropriate for this set.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,0,0,There is no change in the implementation of the method between the early and the late versions of the function.,"Since there is no change in the implementation, there can be no Compatibility Issues arising from this API."
513,<android.app.Notification.MessagingStyle.Message: Message getMessageFromBundle(Bundle)>,25,26,<android.app.Notification.MessagingStyle.Message: Message getMessageFromBundle(Bundle)>,<android.app.Notification.MessagingStyle.Message: Message getMessageFromBundle(Bundle)>,0,"{
    try {
        if (!bundle.containsKey(KEY_TEXT) || !bundle.containsKey(KEY_TIMESTAMP)) {
            return null;
        } else {
            Message message = new Message(bundle.getCharSequence(KEY_TEXT), bundle.getLong(KEY_TIMESTAMP), bundle.getCharSequence(KEY_SENDER));
            if (bundle.containsKey(KEY_DATA_MIME_TYPE) && bundle.containsKey(KEY_DATA_URI)) {
                message.setData(bundle.getString(KEY_DATA_MIME_TYPE), (Uri) bundle.getParcelable(KEY_DATA_URI));
            }
            return message;
        }
    } catch (ClassCastException e) {
        return null;
    }
}","{
    try {
        if (!bundle.containsKey(KEY_TEXT) || !bundle.containsKey(KEY_TIMESTAMP)) {
            return null;
        } else {
            Message message = new Message(bundle.getCharSequence(KEY_TEXT), bundle.getLong(KEY_TIMESTAMP), bundle.getCharSequence(KEY_SENDER));
            if (bundle.containsKey(KEY_DATA_MIME_TYPE) && bundle.containsKey(KEY_DATA_URI)) {
                message.setData(bundle.getString(KEY_DATA_MIME_TYPE), (Uri) bundle.getParcelable(KEY_DATA_URI));
            }
            if (bundle.containsKey(KEY_EXTRAS_BUNDLE)) {
                message.getExtras().putAll(bundle.getBundle(KEY_EXTRAS_BUNDLE));
            }
            return message;
        }
    } catch (ClassCastException e) {
        return null;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The code change is the addition of a new control statement 'if' that checks if the bundle contains the key KEY_EXTRAS_BUNDLE and if so, it puts all the extras from the retrieved bundle into the message. This is a control dependency change (3) and also an other statement changed (4).","Because of the additional data (extras from the bundle) that might be put into the message object, the API can potentially return a Message object with more information in the late version than in the early version, leading to potentially different return values. Thus, the CI type is 1."
514,<android.app.Activity: int getRequestedOrientation()>,25,26,<android.app.Activity: int getRequestedOrientation()>,<android.app.Activity: int getRequestedOrientation()>,0,"{
    if (mParent == null) {
        try {
            return ActivityManagerNative.getDefault().getRequestedOrientation(mToken);
        } catch (RemoteException e) {
        // Empty
        }
    } else {
        return mParent.getRequestedOrientation();
    }
    return ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;
}","{
    if (mParent == null) {
        try {
            return ActivityManager.getService().getRequestedOrientation(mToken);
        } catch (RemoteException e) {
        // Empty
        }
    } else {
        return mParent.getRequestedOrientation();
    }
    return ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;
}",1,"/**
 * Return the current requested orientation of the activity.  This will
 * either be the orientation requested in its component's manifest, or
 * the last requested orientation given to
 * {@link #setRequestedOrientation(int)}.
 *
 * @return Returns an orientation constant as used in
 * {@link ActivityInfo#screenOrientation ActivityInfo.screenOrientation}.
 */
","/**
 * Return the current requested orientation of the activity.  This will
 * either be the orientation requested in its component's manifest, or
 * the last requested orientation given to
 * {@link #setRequestedOrientation(int)}.
 *
 * @return Returns an orientation constant as used in
 * {@link ActivityInfo#screenOrientation ActivityInfo.screenOrientation}.
 */
",-1,[@ActivityInfo.ScreenOrientation],[@ActivityInfo.ScreenOrientation],-1,-1,-1,-1,-1,-1,5,0,"The method called to obtain the default ActivityManager has been changed from ActivityManagerNative.getDefault() to ActivityManager.getService(), so this is a change in a dependent API, and therefor the code change type is 5.","There is no compatibility issue detected as the method signature remains the same, it returns the same data type, and the control flow has not changed. The alteration in obtaining the service should not affect the behavior observed by the end user as long as the getService() method returns an equivalent service to getDefault(). Therefore, the CI type is 0."
516,<android.widget.DateTimeView.ReceiverInfo: long getSoonestUpdateTime()>,25,26,<android.widget.DateTimeView.ReceiverInfo: long getSoonestUpdateTime()>,<android.widget.DateTimeView.ReceiverInfo: long getSoonestUpdateTime()>,0,"{
    long result = Long.MAX_VALUE;
    final int count = mAttachedViews.size();
    for (int i = 0; i < count; i++) {
        final long time = mAttachedViews.get(i).mUpdateTimeMillis;
        if (time < result) {
            result = time;
        }
    }
    return result;
}","{
    long result = Long.MAX_VALUE;
    synchronized (mAttachedViews) {
        final int count = mAttachedViews.size();
        for (int i = 0; i < count; i++) {
            final long time = mAttachedViews.get(i).mUpdateTimeMillis;
            if (time < result) {
                result = time;
            }
        }
    }
    return result;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,0,"The addition of the 'synchronized' block on 'mAttachedViews' suggests a control dependency change to include thread-safety. There is no change in the core logic that determines the 'result' value, therefore only the control dependency has changed, so the code change type is 3.","Given that the synchronization does not alter the semantics of the method (it does not change the result calculation and doesn't introduce a new exception nor returns different values), there should be no compatibility issue. This change will not result in a different behavior from the perspective of the method's return value or exception handling when invoked. Hence, the compatibility issue type is 0."
518,<android.util.DisplayMetrics: void setTo(DisplayMetrics)>,25,26,<android.util.DisplayMetrics: void setTo(DisplayMetrics)>,<android.util.DisplayMetrics: void setTo(DisplayMetrics)>,0,"{
    widthPixels = o.widthPixels;
    heightPixels = o.heightPixels;
    density = o.density;
    densityDpi = o.densityDpi;
    scaledDensity = o.scaledDensity;
    xdpi = o.xdpi;
    ydpi = o.ydpi;
    noncompatWidthPixels = o.noncompatWidthPixels;
    noncompatHeightPixels = o.noncompatHeightPixels;
    noncompatDensity = o.noncompatDensity;
    noncompatDensityDpi = o.noncompatDensityDpi;
    noncompatScaledDensity = o.noncompatScaledDensity;
    noncompatXdpi = o.noncompatXdpi;
    noncompatYdpi = o.noncompatYdpi;
}","{
    if (this == o) {
        return;
    }
    widthPixels = o.widthPixels;
    heightPixels = o.heightPixels;
    density = o.density;
    densityDpi = o.densityDpi;
    scaledDensity = o.scaledDensity;
    xdpi = o.xdpi;
    ydpi = o.ydpi;
    noncompatWidthPixels = o.noncompatWidthPixels;
    noncompatHeightPixels = o.noncompatHeightPixels;
    noncompatDensity = o.noncompatDensity;
    noncompatDensityDpi = o.noncompatDensityDpi;
    noncompatScaledDensity = o.noncompatScaledDensity;
    noncompatXdpi = o.noncompatXdpi;
    noncompatYdpi = o.noncompatYdpi;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,0,"The late version introduces an identity check (if-statement) to see if the object `o` is the same as `this`. If it is, it returns early, which means no fields get changed. Hence, the change type is 3 because of the added control dependency.","Despite the added if-statement, there is no Compatibility Issue because if `this` and `o` are the same object, none of the fields need to be updated since they are already equal. Therefore, the behavior of the method does not change in a way that affects the API contract."
519,<android.app.FragmentManagerImpl: void makeActive(Fragment)>,25,26,<android.app.FragmentManagerImpl: void makeActive(Fragment)>,<android.app.FragmentManagerImpl: void makeActive(Fragment)>,0,"{
    if (f.mIndex >= 0) {
        return;
    }
    if (mAvailIndices == null || mAvailIndices.size() <= 0) {
        if (mActive == null) {
            mActive = new ArrayList<Fragment>();
        }
        f.setIndex(mActive.size(), mParent);
        mActive.add(f);
    } else {
        f.setIndex(mAvailIndices.remove(mAvailIndices.size() - 1), mParent);
        mActive.set(f.mIndex, f);
    }
    if (DEBUG)
        Log.v(TAG, ""Allocated fragment index "" + f);
}","{
    if (f.mIndex >= 0) {
        return;
    }
    f.setIndex(mNextFragmentIndex++, mParent);
    if (mActive == null) {
        mActive = new SparseArray<>();
    }
    mActive.put(f.mIndex, f);
    if (DEBUG)
        Log.v(TAG, ""Allocated fragment index "" + f);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The return statement has not changed, but the control flow and other statements have changed. An if-else block regarding handling of mAvailIndices has been removed, the indexing mechanism has changed with mNextFragmentIndex, and the storage structure for mActive has been changed from ArrayList to SparseArray. Also, the method 'setIndex' and 'put' from mActive have been updated, which impacts dependent APIs. Therefore, the code change types are 3, 4, and 5.","The API could potentially return a different result due to the removal of the previous if-else block, modification of the indexing method via mNextFragmentIndex, and changes in the data structure and method calls for managing active fragments. As the control flow has been modified, the behavior of the API might also change, depending on how the fragments are made active. The change in the data structure from ArrayList to SparseArray also impacts how the fragments are stored and accessed, therefore, this can lead to a different return behavior, and the CI type is 1."
520,<android.app.backup.BackupManager: int requestRestore(RestoreObserver)>,25,26,<android.app.backup.BackupManager: int requestRestore(RestoreObserver)>,<android.app.backup.BackupManager: int requestRestore(RestoreObserver)>,0,"{
    int result = -1;
    checkServiceBinder();
    if (sService != null) {
        RestoreSession session = null;
        try {
            IRestoreSession binder = sService.beginRestoreSession(mContext.getPackageName(), null);
            if (binder != null) {
                session = new RestoreSession(mContext, binder);
                result = session.restorePackage(mContext.getPackageName(), observer);
            }
        } catch (RemoteException e) {
            Log.e(TAG, ""restoreSelf() unable to contact service"");
        } finally {
            if (session != null) {
                session.endRestoreSession();
            }
        }
    }
    return result;
}","{
    return requestRestore(observer, null);
}",1,"/**
 * Restore the calling application from backup.  The data will be restored from the
 * current backup dataset if the application has stored data there, or from
 * the dataset used during the last full device setup operation if the current
 * backup dataset has no matching data.  If no backup data exists for this application
 * in either source, a nonzero value will be returned.
 *
 * <p>If this method returns zero (meaning success), the OS will attempt to retrieve
 * a backed-up dataset from the remote transport, instantiate the application's
 * backup agent, and pass the dataset to the agent's
 * {@link android.app.backup.BackupAgent#onRestore(BackupDataInput, int, android.os.ParcelFileDescriptor) onRestore()}
 * method.
 *
 * @param observer The {@link RestoreObserver} to receive callbacks during the restore
 * operation. This must not be null.
 *
 * @return Zero on success; nonzero on error.
 */
","/**
 * Restore the calling application from backup.  The data will be restored from the
 * current backup dataset if the application has stored data there, or from
 * the dataset used during the last full device setup operation if the current
 * backup dataset has no matching data.  If no backup data exists for this application
 * in either source, a nonzero value will be returned.
 *
 * <p>If this method returns zero (meaning success), the OS will attempt to retrieve
 * a backed-up dataset from the remote transport, instantiate the application's
 * backup agent, and pass the dataset to the agent's
 * {@link android.app.backup.BackupAgent#onRestore(BackupDataInput, int, android.os.ParcelFileDescriptor) onRestore()}
 * method.
 *
 * @param observer The {@link RestoreObserver} to receive callbacks during the restore
 * operation. This must not be null.
 *
 * @return Zero on success; nonzero on error.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The implementation of requestRestore has been entirely changed to call another method with similar functionality. This means the body of the method has changed, thus the change type is 4.","There is no Compatibility Issue due to the internal implementation redirection. The method still respects the same signature and semantics, just with internal delegation to another method. Therefore, based on the given definitions and instructions, this kind of redirection doesn't lead to a different return variable or a different exception being thrown by the 'requestRestore' method itself. Hence, the CI type is 0."
521,"<android.content.IntentFilter: void dump(Printer,String)>",25,26,"<android.content.IntentFilter: void dump(Printer,String)>","<android.content.IntentFilter: void dump(Printer,String)>",0,"{
    StringBuilder sb = new StringBuilder(256);
    if (mActions.size() > 0) {
        Iterator<String> it = mActions.iterator();
        while (it.hasNext()) {
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Action: \"""");
            sb.append(it.next());
            sb.append(""\"""");
            du.println(sb.toString());
        }
    }
    if (mCategories != null) {
        Iterator<String> it = mCategories.iterator();
        while (it.hasNext()) {
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Category: \"""");
            sb.append(it.next());
            sb.append(""\"""");
            du.println(sb.toString());
        }
    }
    if (mDataSchemes != null) {
        Iterator<String> it = mDataSchemes.iterator();
        while (it.hasNext()) {
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Scheme: \"""");
            sb.append(it.next());
            sb.append(""\"""");
            du.println(sb.toString());
        }
    }
    if (mDataSchemeSpecificParts != null) {
        Iterator<PatternMatcher> it = mDataSchemeSpecificParts.iterator();
        while (it.hasNext()) {
            PatternMatcher pe = it.next();
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Ssp: \"""");
            sb.append(pe);
            sb.append(""\"""");
            du.println(sb.toString());
        }
    }
    if (mDataAuthorities != null) {
        Iterator<AuthorityEntry> it = mDataAuthorities.iterator();
        while (it.hasNext()) {
            AuthorityEntry ae = it.next();
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Authority: \"""");
            sb.append(ae.mHost);
            sb.append(""\"": "");
            sb.append(ae.mPort);
            if (ae.mWild)
                sb.append("" WILD"");
            du.println(sb.toString());
        }
    }
    if (mDataPaths != null) {
        Iterator<PatternMatcher> it = mDataPaths.iterator();
        while (it.hasNext()) {
            PatternMatcher pe = it.next();
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Path: \"""");
            sb.append(pe);
            sb.append(""\"""");
            du.println(sb.toString());
        }
    }
    if (mDataTypes != null) {
        Iterator<String> it = mDataTypes.iterator();
        while (it.hasNext()) {
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Type: \"""");
            sb.append(it.next());
            sb.append(""\"""");
            du.println(sb.toString());
        }
    }
    if (mPriority != 0 || mHasPartialTypes) {
        sb.setLength(0);
        sb.append(prefix);
        sb.append(""mPriority="");
        sb.append(mPriority);
        sb.append("", mHasPartialTypes="");
        sb.append(mHasPartialTypes);
        du.println(sb.toString());
    }
    {
        sb.setLength(0);
        sb.append(prefix);
        sb.append(""AutoVerify="");
        sb.append(getAutoVerify());
        du.println(sb.toString());
    }
}","{
    StringBuilder sb = new StringBuilder(256);
    if (mActions.size() > 0) {
        Iterator<String> it = mActions.iterator();
        while (it.hasNext()) {
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Action: \"""");
            sb.append(it.next());
            sb.append(""\"""");
            du.println(sb.toString());
        }
    }
    if (mCategories != null) {
        Iterator<String> it = mCategories.iterator();
        while (it.hasNext()) {
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Category: \"""");
            sb.append(it.next());
            sb.append(""\"""");
            du.println(sb.toString());
        }
    }
    if (mDataSchemes != null) {
        Iterator<String> it = mDataSchemes.iterator();
        while (it.hasNext()) {
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Scheme: \"""");
            sb.append(it.next());
            sb.append(""\"""");
            du.println(sb.toString());
        }
    }
    if (mDataSchemeSpecificParts != null) {
        Iterator<PatternMatcher> it = mDataSchemeSpecificParts.iterator();
        while (it.hasNext()) {
            PatternMatcher pe = it.next();
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Ssp: \"""");
            sb.append(pe);
            sb.append(""\"""");
            du.println(sb.toString());
        }
    }
    if (mDataAuthorities != null) {
        Iterator<AuthorityEntry> it = mDataAuthorities.iterator();
        while (it.hasNext()) {
            AuthorityEntry ae = it.next();
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Authority: \"""");
            sb.append(ae.mHost);
            sb.append(""\"": "");
            sb.append(ae.mPort);
            if (ae.mWild)
                sb.append("" WILD"");
            du.println(sb.toString());
        }
    }
    if (mDataPaths != null) {
        Iterator<PatternMatcher> it = mDataPaths.iterator();
        while (it.hasNext()) {
            PatternMatcher pe = it.next();
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Path: \"""");
            sb.append(pe);
            sb.append(""\"""");
            du.println(sb.toString());
        }
    }
    if (mDataTypes != null) {
        Iterator<String> it = mDataTypes.iterator();
        while (it.hasNext()) {
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Type: \"""");
            sb.append(it.next());
            sb.append(""\"""");
            du.println(sb.toString());
        }
    }
    if (mPriority != 0 || mHasPartialTypes) {
        sb.setLength(0);
        sb.append(prefix);
        sb.append(""mPriority="");
        sb.append(mPriority);
        sb.append("", mHasPartialTypes="");
        sb.append(mHasPartialTypes);
        du.println(sb.toString());
    }
    if (getAutoVerify()) {
        sb.setLength(0);
        sb.append(prefix);
        sb.append(""AutoVerify="");
        sb.append(getAutoVerify());
        du.println(sb.toString());
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
522,<android.net.NetworkCapabilities: int hashCode()>,25,26,<android.net.NetworkCapabilities: int hashCode()>,<android.net.NetworkCapabilities: int hashCode()>,0,"{
    return ((int) (mNetworkCapabilities & 0xFFFFFFFF) + ((int) (mNetworkCapabilities >> 32) * 3) + ((int) (mTransportTypes & 0xFFFFFFFF) * 5) + ((int) (mTransportTypes >> 32) * 7) + (mLinkUpBandwidthKbps * 11) + (mLinkDownBandwidthKbps * 13) + (TextUtils.isEmpty(mNetworkSpecifier) ? 0 : mNetworkSpecifier.hashCode() * 17) + (mSignalStrength * 19));
}","{
    return ((int) (mNetworkCapabilities & 0xFFFFFFFF) + ((int) (mNetworkCapabilities >> 32) * 3) + ((int) (mTransportTypes & 0xFFFFFFFF) * 5) + ((int) (mTransportTypes >> 32) * 7) + (mLinkUpBandwidthKbps * 11) + (mLinkDownBandwidthKbps * 13) + Objects.hashCode(mNetworkSpecifier) * 17 + (mSignalStrength * 19));
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"The method for generating the hash code of mNetworkSpecifier has changed from using TextUtils.isEmpty() with a ternary operator to using Objects.hashCode(), which is a change in a non-control, non-return, non-exception handling statement. This also counts as a change in the dependent API, as Objects.hashCode() is a different method from TextUtils.isEmpty(). So the code change type is 4,5.","The Objects.hashCode() handles null values differently and provides a different hash code for null values compared to the original ternary operation based on TextUtils.isEmpty(), which potentially returns a different value for the hashCode. Therefore, the CI type is 1."
524,"<android.view.textservice.TextServicesManager: SpellCheckerSession newSpellCheckerSession(Bundle,Locale,SpellCheckerSessionListener,boolean)>",25,26,"<android.view.textservice.TextServicesManager: SpellCheckerSession newSpellCheckerSession(Bundle,Locale,SpellCheckerSessionListener,boolean)>","<android.view.textservice.TextServicesManager: SpellCheckerSession newSpellCheckerSession(Bundle,Locale,SpellCheckerSessionListener,boolean)>",0,"{
    if (listener == null) {
        throw new NullPointerException();
    }
    if (!referToSpellCheckerLanguageSettings && locale == null) {
        throw new IllegalArgumentException(""Locale should not be null if you don't refer"" + "" settings."");
    }
    if (referToSpellCheckerLanguageSettings && !isSpellCheckerEnabled()) {
        return null;
    }
    final SpellCheckerInfo sci;
    try {
        sci = sService.getCurrentSpellChecker(null);
    } catch (RemoteException e) {
        return null;
    }
    if (sci == null) {
        return null;
    }
    SpellCheckerSubtype subtypeInUse = null;
    if (referToSpellCheckerLanguageSettings) {
        subtypeInUse = getCurrentSpellCheckerSubtype(true);
        if (subtypeInUse == null) {
            return null;
        }
        if (locale != null) {
            final String subtypeLocale = subtypeInUse.getLocale();
            final String subtypeLanguage = parseLanguageFromLocaleString(subtypeLocale);
            if (subtypeLanguage.length() < 2 || !locale.getLanguage().equals(subtypeLanguage)) {
                return null;
            }
        }
    } else {
        final String localeStr = locale.toString();
        for (int i = 0; i < sci.getSubtypeCount(); ++i) {
            final SpellCheckerSubtype subtype = sci.getSubtypeAt(i);
            final String tempSubtypeLocale = subtype.getLocale();
            final String tempSubtypeLanguage = parseLanguageFromLocaleString(tempSubtypeLocale);
            if (tempSubtypeLocale.equals(localeStr)) {
                subtypeInUse = subtype;
                break;
            } else if (tempSubtypeLanguage.length() >= 2 && locale.getLanguage().equals(tempSubtypeLanguage)) {
                subtypeInUse = subtype;
            }
        }
    }
    if (subtypeInUse == null) {
        return null;
    }
    final SpellCheckerSession session = new SpellCheckerSession(sci, sService, listener, subtypeInUse);
    try {
        sService.getSpellCheckerService(sci.getId(), subtypeInUse.getLocale(), session.getTextServicesSessionListener(), session.getSpellCheckerSessionListener(), bundle);
    } catch (RemoteException e) {
        return null;
    }
    return session;
}","{
    if (listener == null) {
        throw new NullPointerException();
    }
    if (!referToSpellCheckerLanguageSettings && locale == null) {
        throw new IllegalArgumentException(""Locale should not be null if you don't refer"" + "" settings."");
    }
    if (referToSpellCheckerLanguageSettings && !isSpellCheckerEnabled()) {
        return null;
    }
    final SpellCheckerInfo sci;
    try {
        sci = mService.getCurrentSpellChecker(null);
    } catch (RemoteException e) {
        return null;
    }
    if (sci == null) {
        return null;
    }
    SpellCheckerSubtype subtypeInUse = null;
    if (referToSpellCheckerLanguageSettings) {
        subtypeInUse = getCurrentSpellCheckerSubtype(true);
        if (subtypeInUse == null) {
            return null;
        }
        if (locale != null) {
            final String subtypeLocale = subtypeInUse.getLocale();
            final String subtypeLanguage = parseLanguageFromLocaleString(subtypeLocale);
            if (subtypeLanguage.length() < 2 || !locale.getLanguage().equals(subtypeLanguage)) {
                return null;
            }
        }
    } else {
        final String localeStr = locale.toString();
        for (int i = 0; i < sci.getSubtypeCount(); ++i) {
            final SpellCheckerSubtype subtype = sci.getSubtypeAt(i);
            final String tempSubtypeLocale = subtype.getLocale();
            final String tempSubtypeLanguage = parseLanguageFromLocaleString(tempSubtypeLocale);
            if (tempSubtypeLocale.equals(localeStr)) {
                subtypeInUse = subtype;
                break;
            } else if (tempSubtypeLanguage.length() >= 2 && locale.getLanguage().equals(tempSubtypeLanguage)) {
                subtypeInUse = subtype;
            }
        }
    }
    if (subtypeInUse == null) {
        return null;
    }
    final SpellCheckerSession session = new SpellCheckerSession(sci, mService, listener);
    try {
        mService.getSpellCheckerService(sci.getId(), subtypeInUse.getLocale(), session.getTextServicesSessionListener(), session.getSpellCheckerSessionListener(), bundle);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
    return session;
}",1,"/**
 * Get a spell checker session for the specified spell checker
 * @param locale the locale for the spell checker. If {@code locale} is null and
 * referToSpellCheckerLanguageSettings is true, the locale specified in Settings will be
 * returned. If {@code locale} is not null and referToSpellCheckerLanguageSettings is true,
 * the locale specified in Settings will be returned only when it is same as {@code locale}.
 * Exceptionally, when referToSpellCheckerLanguageSettings is true and {@code locale} is
 * only language (e.g. ""en""), the specified locale in Settings (e.g. ""en_US"") will be
 * selected.
 * @param listener a spell checker session lister for getting results from a spell checker.
 * @param referToSpellCheckerLanguageSettings if true, the session for one of enabled
 * languages in settings will be returned.
 * @return the spell checker session of the spell checker
 */
","/**
 * Get a spell checker session for the specified spell checker
 * @param locale the locale for the spell checker. If {@code locale} is null and
 * referToSpellCheckerLanguageSettings is true, the locale specified in Settings will be
 * returned. If {@code locale} is not null and referToSpellCheckerLanguageSettings is true,
 * the locale specified in Settings will be returned only when it is same as {@code locale}.
 * Exceptionally, when referToSpellCheckerLanguageSettings is true and {@code locale} is
 * only language (e.g. ""en""), the specified locale in Settings (e.g. ""en_US"") will be
 * selected.
 * @param listener a spell checker session lister for getting results from a spell checker.
 * @param referToSpellCheckerLanguageSettings if true, the session for one of enabled
 * languages in settings will be returned.
 * @return the spell checker session of the spell checker
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4,5","1,2","The catch block for the RemoteException has been modified from a return null to a throw e.rethrowFromSystemServer(), an exception handling statement is changed. The SpellCheckerSession constructor invocation has been changed, which alters the way of instantiating a SpellCheckerSession object, thus there is a change in other statements. Also, sService has been changed to mService indicating a dependent API has changed, so the code change type is 2,4,5.","The change in the exception handling statement will lead to the late version of the API throwing an exception instead of returning null, which could potentially be a different behavior. In addition, due to the change in instantiation of a SpellCheckerSession object and the use of a different service (sService to mService), there is also a potential for the API to return a different value. The Compatibility Issue type is, therefore, 1,2."
529,"<android.hardware.usb.UsbRequest: boolean queue(ByteBuffer,int)>",25,26,"<android.hardware.usb.UsbRequest: boolean queue(ByteBuffer,int)>","<android.hardware.usb.UsbRequest: boolean queue(ByteBuffer,int)>",0,"{
    boolean out = (mEndpoint.getDirection() == UsbConstants.USB_DIR_OUT);
    boolean result;
    if (buffer.isDirect()) {
        result = native_queue_direct(buffer, length, out);
    } else if (buffer.hasArray()) {
        result = native_queue_array(buffer.array(), length, out);
    } else {
        throw new IllegalArgumentException(""buffer is not direct and has no array"");
    }
    if (result) {
        // save our buffer for when the request has completed
        mBuffer = buffer;
        mLength = length;
    }
    return result;
}","{
    boolean out = (mEndpoint.getDirection() == UsbConstants.USB_DIR_OUT);
    boolean result;
    synchronized (mLock) {
        // save our buffer for when the request has completed
        mBuffer = buffer;
        mLength = length;
        if (buffer.isDirect()) {
            result = native_queue_direct(buffer, length, out);
        } else if (buffer.hasArray()) {
            result = native_queue_array(buffer.array(), length, out);
        } else {
            throw new IllegalArgumentException(""buffer is not direct and has no array"");
        }
        if (!result) {
            mBuffer = null;
            mLength = 0;
        }
    }
    return result;
}",1,"/**
 * Queues the request to send or receive data on its endpoint.
 * For OUT endpoints, the given buffer data will be sent on the endpoint.
 * For IN endpoints, the endpoint will attempt to read the given number of bytes
 * into the specified buffer.
 * If the queueing operation is successful, we return true and the result will be
 * returned via {@link android.hardware.usb.UsbDeviceConnection#requestWait}
 *
 * @param buffer the buffer containing the bytes to write, or location to store
 * the results of a read
 * @param length number of bytes to read or write
 * @return true if the queueing operation succeeded
 */
","/**
 * Queues the request to send or receive data on its endpoint.
 * <p>For OUT endpoints, the given buffer data will be sent on the endpoint. For IN endpoints,
 * the endpoint will attempt to read the given number of bytes into the specified buffer. If the
 * queueing operation is successful, return true. The result will be returned via
 * {@link UsbDeviceConnection#requestWait}</p>
 *
 * @param buffer the buffer containing the bytes to write, or location to store the results of a
 * read. Position and array offset will be ignored and assumed to be 0. Limit and
 * capacity will be ignored. Once the request
 * {@link UsbDeviceConnection#requestWait() is processed} the position will be set
 * to the number of bytes read/written.
 * @param length number of bytes to read or write.
 *
 * @return true if the queueing operation succeeded
 *
 * @deprecated Use {@link #queue(ByteBuffer)} instead.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"3,4",0,"The late version wraps part of the method implementation within a synchronized block using mLock, also the assignment of mBuffer and mLength has been moved inside the synchronized block. Additionally, the behavior when result is false has been modified to set mBuffer to null and mLength to 0. Code change types are 3 for the control dependency change due to synchronization and 4 for the other statement changes.","The behavioral changes within the method do not lead to a Compatibility Issue in terms of returning different results or throwing exceptions differently when considering the expected API contract. The API still takes a ByteBuffer and an integer length as arguments and returns a boolean result. Furthermore, while the internal state changes are subject to a new synchronization strategy and the internal fields mBuffer and mLength are being reset on failure, these internal state changes are not outward-facing effects as far as invoking code is concerned (assuming that the methods are being used correctly and result checks are performed). Thus, no Compatibility Issue is expected."
533,<android.view.View: void onRestoreInstanceState(Parcelable)>,25,26,<android.view.View: void onRestoreInstanceState(Parcelable)>,<android.view.View: void onRestoreInstanceState(Parcelable)>,0,"{
    mPrivateFlags |= PFLAG_SAVE_STATE_CALLED;
    if (state != null && !(state instanceof AbsSavedState)) {
        throw new IllegalArgumentException(""Wrong state class, expecting View State but "" + ""received "" + state.getClass().toString() + "" instead. This usually happens "" + ""when two views of different type have the same id in the same hierarchy. "" + ""This view's id is "" + ViewDebug.resolveId(mContext, getId()) + "". Make sure "" + ""other views do not use the same id."");
    }
    if (state != null && state instanceof BaseSavedState) {
        mStartActivityRequestWho = ((BaseSavedState) state).mStartActivityRequestWhoSaved;
    }
}","{
    mPrivateFlags |= PFLAG_SAVE_STATE_CALLED;
    if (state != null && !(state instanceof AbsSavedState)) {
        throw new IllegalArgumentException(""Wrong state class, expecting View State but "" + ""received "" + state.getClass().toString() + "" instead. This usually happens "" + ""when two views of different type have the same id in the same hierarchy. "" + ""This view's id is "" + ViewDebug.resolveId(mContext, getId()) + "". Make sure "" + ""other views do not use the same id."");
    }
    if (state != null && state instanceof BaseSavedState) {
        BaseSavedState baseState = (BaseSavedState) state;
        if ((baseState.mSavedData & BaseSavedState.START_ACTIVITY_REQUESTED_WHO_SAVED) != 0) {
            mStartActivityRequestWho = baseState.mStartActivityRequestWhoSaved;
        }
        if ((baseState.mSavedData & BaseSavedState.IS_AUTOFILLED) != 0) {
            setAutofilled(baseState.mIsAutofilled);
        }
        if ((baseState.mSavedData & BaseSavedState.AUTOFILL_ID) != 0) {
            mAutofillViewId = baseState.mAutofillViewId;
        }
    }
}",1,"/**
 * Hook allowing a view to re-apply a representation of its internal state that had previously
 * been generated by {@link #onSaveInstanceState}. This function will never be called with a
 * null state.
 *
 * @param state The frozen state that had previously been returned by
 * {@link #onSaveInstanceState}.
 *
 * @see #onSaveInstanceState()
 * @see #restoreHierarchyState(android.util.SparseArray)
 * @see #dispatchRestoreInstanceState(android.util.SparseArray)
 */
","/**
 * Hook allowing a view to re-apply a representation of its internal state that had previously
 * been generated by {@link #onSaveInstanceState}. This function will never be called with a
 * null state.
 *
 * @param state The frozen state that had previously been returned by
 * {@link #onSaveInstanceState}.
 *
 * @see #onSaveInstanceState()
 * @see #restoreHierarchyState(android.util.SparseArray)
 * @see #dispatchRestoreInstanceState(android.util.SparseArray)
 */
",-1,[@CallSuper],[@CallSuper],-1,-1,-1,-1,-1,-1,"3,4",0,"There is an addition of multiple if conditions inside the second if block and assigning new values to fields based on these conditions, which is a control dependency change, and there are also other statement changes adding new logic related to ""BaseSavedState"" processing. So the code change type is 3,4.","Despite the additional if conditions and logic for setting new fields based on the state, these changes do not introduce a situation where the method would return different values or throw new exceptions, which would have been observable to the caller. Since the method's signature indicates it returns void and there are no changes in exception handling from what the caller can observe, there is no Compatibility Issue in terms of different return values or exception handling caused by these changes. Therefore, the CI type is 0."
535,<android.app.Activity: void setTaskDescription(TaskDescription)>,25,26,<android.app.Activity: void setTaskDescription(TaskDescription)>,<android.app.Activity: void setTaskDescription(TaskDescription)>,0,"{
    if (mTaskDescription != taskDescription) {
        mTaskDescription.copyFrom(taskDescription);
        // Scale the icon down to something reasonable if it is provided
        if (taskDescription.getIconFilename() == null && taskDescription.getIcon() != null) {
            final int size = ActivityManager.getLauncherLargeIconSizeInner(this);
            final Bitmap icon = Bitmap.createScaledBitmap(taskDescription.getIcon(), size, size, true);
            mTaskDescription.setIcon(icon);
        }
    }
    try {
        ActivityManagerNative.getDefault().setTaskDescription(mToken, mTaskDescription);
    } catch (RemoteException e) {
    }
}","{
    if (mTaskDescription != taskDescription) {
        mTaskDescription.copyFromPreserveHiddenFields(taskDescription);
        // Scale the icon down to something reasonable if it is provided
        if (taskDescription.getIconFilename() == null && taskDescription.getIcon() != null) {
            final int size = ActivityManager.getLauncherLargeIconSizeInner(this);
            final Bitmap icon = Bitmap.createScaledBitmap(taskDescription.getIcon(), size, size, true);
            mTaskDescription.setIcon(icon);
        }
    }
    try {
        ActivityManager.getService().setTaskDescription(mToken, mTaskDescription);
    } catch (RemoteException e) {
    }
}",1,"/**
 * Sets information describing the task with this activity for presentation inside the Recents
 * System UI. When {@link ActivityManager#getRecentTasks} is called, the activities of each task
 * are traversed in order from the topmost activity to the bottommost. The traversal continues
 * for each property until a suitable value is found. For each task the taskDescription will be
 * returned in {@link android.app.ActivityManager.TaskDescription}.
 *
 * @see ActivityManager#getRecentTasks
 * @see android.app.ActivityManager.TaskDescription
 *
 * @param taskDescription The TaskDescription properties that describe the task with this activity
 */
","/**
 * Sets information describing the task with this activity for presentation inside the Recents
 * System UI. When {@link ActivityManager#getRecentTasks} is called, the activities of each task
 * are traversed in order from the topmost activity to the bottommost. The traversal continues
 * for each property until a suitable value is found. For each task the taskDescription will be
 * returned in {@link android.app.ActivityManager.TaskDescription}.
 *
 * @see ActivityManager#getRecentTasks
 * @see android.app.ActivityManager.TaskDescription
 *
 * @param taskDescription The TaskDescription properties that describe the task with this activity
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The code changes include a method name change from copyFrom() to copyFromPreserveHiddenFields() and the way the ActivityManager service is accessed (from ActivityManagerNative.getDefault() to ActivityManager.getService()). These constitute changes in the dependent APIs being used, which are classified as type 5. Additionally, there is an other statement changed, which is classified as type 4.","There is no apparent Compatibility Issue caused by these changes as neither of them would directly cause a different return value or exception to be thrown by the method setTaskDescription(). The internal implementation details have changed, but the external behavior of the method, in terms of the API contract (how it is called and what it returns), should remain consistent with its previous version."
536,"<android.content.BroadcastReceiver: IBinder peekService(Context,Intent)>",25,26,"<android.content.BroadcastReceiver: IBinder peekService(Context,Intent)>","<android.content.BroadcastReceiver: IBinder peekService(Context,Intent)>",0,"{
    IActivityManager am = ActivityManagerNative.getDefault();
    IBinder binder = null;
    try {
        service.prepareToLeaveProcess(myContext);
        binder = am.peekService(service, service.resolveTypeIfNeeded(myContext.getContentResolver()), myContext.getOpPackageName());
    } catch (RemoteException e) {
    }
    return binder;
}","{
    IActivityManager am = ActivityManager.getService();
    IBinder binder = null;
    try {
        service.prepareToLeaveProcess(myContext);
        binder = am.peekService(service, service.resolveTypeIfNeeded(myContext.getContentResolver()), myContext.getOpPackageName());
    } catch (RemoteException e) {
    }
    return binder;
}",1,"/**
 * Provide a binder to an already-running service.  This method is synchronous
 * and will not start the target service if it is not present, so it is safe
 * to call from {@link #onReceive}.
 *
 * @param myContext The Context that had been passed to {@link #onReceive(Context, Intent)}
 * @param service The Intent indicating the service you wish to use.  See {@link
 * Context#startService(Intent)} for more information.
 */
","/**
 * Provide a binder to an already-bound service.  This method is synchronous
 * and will not start the target service if it is not present, so it is safe
 * to call from {@link #onReceive}.
 *
 * For peekService() to return a non null {@link android.os.IBinder} interface
 * the service must have published it before. In other words some component
 * must have called {@link android.content.Context#bindService(Intent, ServiceConnection, int)} on it.
 *
 * @param myContext The Context that had been passed to {@link #onReceive(Context, Intent)}
 * @param service Identifies the already-bound service you wish to use. See
 * {@link android.content.Context#bindService(Intent, ServiceConnection, int)}
 * for more information.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method call for obtaining the `IActivityManager` instance has changed from `ActivityManagerNative.getDefault()` to `ActivityManager.getService()`, which is the dependent API change, therefore the code change type is 5. Additionally, no other changes have been made that would affect the overall logic or return type of the method, except the way to obtain the ActivityManager service, so it is also marked as 4.","The changes do not affect the potential behavior of the API in a way that would lead to different return values or exception handlings, as the method signature and exception handling stayed the same. The API `peekService` would still return the same `binder` object as it did before. Therefore, there is no Compatibility Issue, so the CI type is 0."
539,<android.view.View: void onProvideStructure(ViewStructure)>,25,26,<android.view.View: void onProvideStructure(ViewStructure)>,<android.view.View: void onProvideStructure(ViewStructure)>,0,"{
    final int id = mID;
    if (id > 0 && (id & 0xff000000) != 0 && (id & 0x00ff0000) != 0 && (id & 0x0000ffff) != 0) {
        String pkg, type, entry;
        try {
            final Resources res = getResources();
            entry = res.getResourceEntryName(id);
            type = res.getResourceTypeName(id);
            pkg = res.getResourcePackageName(id);
        } catch (Resources.NotFoundException e) {
            entry = type = pkg = null;
        }
        structure.setId(id, pkg, type, entry);
    } else {
        structure.setId(id, null, null, null);
    }
    structure.setDimens(mLeft, mTop, mScrollX, mScrollY, mRight - mLeft, mBottom - mTop);
    if (!hasIdentityMatrix()) {
        structure.setTransformation(getMatrix());
    }
    structure.setElevation(getZ());
    structure.setVisibility(getVisibility());
    structure.setEnabled(isEnabled());
    if (isClickable()) {
        structure.setClickable(true);
    }
    if (isFocusable()) {
        structure.setFocusable(true);
    }
    if (isFocused()) {
        structure.setFocused(true);
    }
    if (isAccessibilityFocused()) {
        structure.setAccessibilityFocused(true);
    }
    if (isSelected()) {
        structure.setSelected(true);
    }
    if (isActivated()) {
        structure.setActivated(true);
    }
    if (isLongClickable()) {
        structure.setLongClickable(true);
    }
    if (this instanceof Checkable) {
        structure.setCheckable(true);
        if (((Checkable) this).isChecked()) {
            structure.setChecked(true);
        }
    }
    if (isContextClickable()) {
        structure.setContextClickable(true);
    }
    structure.setClassName(getAccessibilityClassName().toString());
    structure.setContentDescription(getContentDescription());
}","{
    onProvideStructureForAssistOrAutofill(structure, false, 0);
}",1,"/**
 * Called when assist structure is being retrieved from a view as part of
 * {@link android.app.Activity#onProvideAssistData Activity.onProvideAssistData}.
 * @param structure Fill in with structured view data.  The default implementation
 * fills in all data that can be inferred from the view itself.
 */
","/**
 * Called when assist structure is being retrieved from a view as part of
 * {@link android.app.Activity#onProvideAssistData Activity.onProvideAssistData}.
 * @param structure Fill in with structured view data.  The default implementation
 * fills in all data that can be inferred from the view itself.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The entire implementation of the method has been replaced with a call to another method, onProvideStructureForAssistOrAutofill(structure, false, 0), so the code change type is 4,5.","The change redirects the logic to another method that is not shown here. Because the entire implementation is changed, it could lead to different return types or behavior if the new method has a different implementation. Even though there is no return statement to analyze directly within this particular change, the change is substantial enough to assume that it could result in a different outcome for the API's behavior. Hence, without knowing the internal workings of the new method, we err on the side of caution and consider this a CI of type 1."
540,<android.hardware.camera2.CameraMetadata: List<TKey> getKeys()>,25,26,<android.hardware.camera2.CameraMetadata: List<TKey> getKeys()>,<android.hardware.camera2.CameraMetadata: List<TKey> getKeys()>,0,"{
    Class<CameraMetadata<TKey>> thisClass = (Class<CameraMetadata<TKey>>) getClass();
    return Collections.unmodifiableList(getKeysStatic(thisClass, getKeyClass(), this, /*filterTags*/
    null));
}","{
    Class<CameraMetadata<TKey>> thisClass = (Class<CameraMetadata<TKey>>) getClass();
    return Collections.unmodifiableList(getKeys(thisClass, getKeyClass(), this, /*filterTags*/
    null));
}",1,"/**
 * Returns a list of the keys contained in this map.
 *
 * <p>The list returned is not modifiable, so any attempts to modify it will throw
 * a {@code UnsupportedOperationException}.</p>
 *
 * <p>All values retrieved by a key from this list with {@code #get} are guaranteed to be
 * non-{@code null}. Each key is only listed once in the list. The order of the keys
 * is undefined.</p>
 *
 * @return List of the keys contained in this map.
 */
","/**
 * Returns a list of the keys contained in this map.
 *
 * <p>The list returned is not modifiable, so any attempts to modify it will throw
 * a {@code UnsupportedOperationException}.</p>
 *
 * <p>All values retrieved by a key from this list with {@code #get} are guaranteed to be
 * non-{@code null}. Each key is only listed once in the list. The order of the keys
 * is undefined.</p>
 *
 * @return List of the keys contained in this map.
 */
",-1,"[@SuppressWarnings(""unchecked""), @NonNull]","[@SuppressWarnings(""unchecked""), @NonNull]",-1,-1,-1,-1,-1,-1,"1,5",1,"The code change is observed in the method called within the return statement; the method name changed from `getKeysStatic` to `getKeys`. This indicates a change in the dependent API, so the code change type is 1,5.","Since the method that generates the list of keys has changed, the API potentially returns a different list of keys. Thus, the CI type is 1."
541,"<android.app.PendingIntent: PendingIntent getActivity(Context,int,Intent,int,Bundle)>",25,26,"<android.app.PendingIntent: PendingIntent getActivity(Context,int,Intent,int,Bundle)>","<android.app.PendingIntent: PendingIntent getActivity(Context,int,Intent,int,Bundle)>",0,"{
    String packageName = context.getPackageName();
    String resolvedType = intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
    try {
        intent.migrateExtraStreamToClipData();
        intent.prepareToLeaveProcess(context);
        IIntentSender target = ActivityManagerNative.getDefault().getIntentSender(ActivityManager.INTENT_SENDER_ACTIVITY, packageName, null, null, requestCode, new Intent[] { intent }, resolvedType != null ? new String[] { resolvedType } : null, flags, options, UserHandle.myUserId());
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
    }
    return null;
}","{
    String packageName = context.getPackageName();
    String resolvedType = intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
    try {
        intent.migrateExtraStreamToClipData();
        intent.prepareToLeaveProcess(context);
        IIntentSender target = ActivityManager.getService().getIntentSender(ActivityManager.INTENT_SENDER_ACTIVITY, packageName, null, null, requestCode, new Intent[] { intent }, resolvedType != null ? new String[] { resolvedType } : null, flags, options, UserHandle.myUserId());
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Retrieve a PendingIntent that will start a new activity, like calling
 * {@link Context#startActivity(Intent) Context.startActivity(Intent)}.
 * Note that the activity will be started outside of the context of an
 * existing activity, so you must use the {@link Intent#FLAG_ACTIVITY_NEW_TASK
 * Intent.FLAG_ACTIVITY_NEW_TASK} launch flag in the Intent.
 *
 * <p class=""note"">For security reasons, the {@link android.content.Intent}
 * you supply here should almost always be an <em>explicit intent</em>,
 * that is specify an explicit component to be delivered to through
 * {@link Intent#setClass(android.content.Context, Class) Intent.setClass}</p>
 *
 * @param context The Context in which this PendingIntent should start
 * the activity.
 * @param requestCode Private request code for the sender
 * @param intent Intent of the activity to be launched.
 * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},
 * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},
 * or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 * @param options Additional options for how the Activity should be started.
 * May be null if there are no options.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been
 * supplied.
 */
","/**
 * Retrieve a PendingIntent that will start a new activity, like calling
 * {@link Context#startActivity(Intent) Context.startActivity(Intent)}.
 * Note that the activity will be started outside of the context of an
 * existing activity, so you must use the {@link Intent#FLAG_ACTIVITY_NEW_TASK
 * Intent.FLAG_ACTIVITY_NEW_TASK} launch flag in the Intent.
 *
 * <p class=""note"">For security reasons, the {@link android.content.Intent}
 * you supply here should almost always be an <em>explicit intent</em>,
 * that is specify an explicit component to be delivered to through
 * {@link Intent#setClass(android.content.Context, Class) Intent.setClass}</p>
 *
 * @param context The Context in which this PendingIntent should start
 * the activity.
 * @param requestCode Private request code for the sender
 * @param intent Intent of the activity to be launched.
 * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},
 * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},
 * or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 * @param options Additional options for how the Activity should be started.
 * May be null if there are no options.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been
 * supplied.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,5",2,"The method used to get the ActivityManager service changed from `ActivityManagerNative.getDefault()` to `ActivityManager.getService()`, and there's an additional change with new exception handling (`throw e.rethrowFromSystemServer();`), so the change type is 2,5.",The new thrown exception (`e.rethrowFromSystemServer()`) alters how exceptions are handled and potentially affects the client's exception handling code. This constitutes a compatibility issue of type 2.
542,"<android.app.ContextImpl: void sendOrderedBroadcast(Intent,String)>",25,26,"<android.app.ContextImpl: void sendOrderedBroadcast(Intent,String)>","<android.app.ContextImpl: void sendOrderedBroadcast(Intent,String)>",0,"{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, AppOpsManager.OP_NONE, null, true, false, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, AppOpsManager.OP_NONE, null, true, false, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The dependent API has changed from `ActivityManagerNative.getDefault()` to `ActivityManager.getService()`. This reflects a call to a different method of obtaining the `ActivityManager`'s service interface, but not a behavioral change in the context of the method's functionality. Therefore, the code change type is 5.","No Compatibility Issue is detected because the replacement of `ActivityManagerNative.getDefault()` with `ActivityManager.getService()` is an internal change that doesn't affect the contract of the `sendOrderedBroadcast` method. The high-level functionality and interaction with the `ActivityManager`'s service remains the same, and hence would not cause the method to behave differently to the caller. The API call change inside the try block doesn't impact the behavior seen by the caller."
544,<android.app.Fragment: boolean getAllowReturnTransitionOverlap()>,25,26,<android.app.Fragment: boolean getAllowReturnTransitionOverlap()>,<android.app.Fragment: boolean getAllowReturnTransitionOverlap()>,0,"{
    return (mAllowReturnTransitionOverlap == null) ? true : mAllowReturnTransitionOverlap;
}","{
    return (mAnimationInfo == null || mAnimationInfo.mAllowReturnTransitionOverlap == null) ? true : mAnimationInfo.mAllowReturnTransitionOverlap;
}",1,"/**
 * Returns whether the the return transition and reenter transition overlap or not.
 * When true, the reenter transition will start as soon as possible. When false, the
 * reenter transition will wait until the return transition completes before starting.
 *
 * @return true to start the reenter transition when possible or false to wait until the
 * return transition completes.
 * @attr ref android.R.styleable#Fragment_fragmentAllowReturnTransitionOverlap
 */
","/**
 * Returns whether the the return transition and reenter transition overlap or not.
 * When true, the reenter transition will start as soon as possible. When false, the
 * reenter transition will wait until the return transition completes before starting.
 *
 * @return true to start the reenter transition when possible or false to wait until the
 * return transition completes.
 * @attr ref android.R.styleable#Fragment_fragmentAllowReturnTransitionOverlap
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The return expression has changed: in the early version, it checks if mAllowReturnTransitionOverlap is null, while in the late version, it additionally checks if mAnimationInfo is null as part of the condition. This change in control dependency and return statement is categorized as 1 and 3.","The additional null check for mAnimationInfo could potentially alter the outcome of the returned value since there's an added condition that determines when to return the default value (true). The API may behave differently if mAnimationInfo is null, which was not checked in the early version. Therefore, a CI could be caused by potentially different return values, categorized as 1."
545,"<android.app.FragmentManagerImpl: boolean popBackStackImmediate(String,int)>",25,26,"<android.app.FragmentManagerImpl: boolean popBackStackImmediate(String,int)>","<android.app.FragmentManagerImpl: boolean popBackStackImmediate(String,int)>",0,"{
    checkStateLoss();
    executePendingTransactions();
    return popBackStackState(mHost.getHandler(), name, -1, flags);
}","{
    checkStateLoss();
    return popBackStackImmediate(name, -1, flags);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The code change consists of the deletion of the call to executePendingTransactions() and a change in the method used to perform the back stack pop: from using popBackStackState(mHost.getHandler(), name, -1, flags) to using the method popBackStackImmediate(name, -1, flags). This is indicative of a change in a dependent API, which is classified under code change type 5.","The changes do not necessarily lead to a compatibility issue because they appear to be an internal refactoring of the method to use a different way of popping the back stack. Since there is no indication that the behavior of the method has fundamentally changed (as in the method's contract with the caller, what exceptions it may throw or the values it returns), and presuming that popBackStackImmediate(name, -1, flags) internally calls popBackStackState appropriately, there would be no compatibility issue. Thus, CI type is 0."
548,<android.app.admin.DevicePolicyManager: boolean isProvisioningAllowed(String)>,25,26,<android.app.admin.DevicePolicyManager: boolean isProvisioningAllowed(String)>,<android.app.admin.DevicePolicyManager: boolean isProvisioningAllowed(String)>,0,"{
    throwIfParentInstance(""isProvisioningAllowed"");
    try {
        return mService.isProvisioningAllowed(action);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}","{
    throwIfParentInstance(""isProvisioningAllowed"");
    try {
        return mService.isProvisioningAllowed(action, mContext.getPackageName());
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns if provisioning a managed profile or device is possible or not.
 * @param action One of {@link #ACTION_PROVISION_MANAGED_DEVICE},
 * {@link #ACTION_PROVISION_MANAGED_PROFILE}.
 * @return if provisioning a managed profile or device is possible or not.
 * @throws IllegalArgumentException if the supplied action is not valid.
 */
","/**
 * Returns whether it is possible for the caller to initiate provisioning of a managed profile
 * or device, setting itself as the device or profile owner.
 *
 * @param action One of {@link #ACTION_PROVISION_MANAGED_DEVICE},
 * {@link #ACTION_PROVISION_MANAGED_PROFILE}.
 * @return whether provisioning a managed profile or device is possible.
 * @throws IllegalArgumentException if the supplied action is not valid.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method signature of `isProvisioningAllowed` called on `mService` has changed to include an additional parameter, `mContext.getPackageName()`. However, the additional parameter does not alter the return type or exception handling, so the code change type is 5.","There is no Compatibility Issue because the additional parameter does not change the expected behavior of the API. The method still returns the same type of result and handles exceptions in the same way. The underlying implementation in the `mService` may have changed, but as per the information provided, it does not lead to a change in behavior observable by the caller of this function. Thus, there is no CI."
549,<android.widget.TabHost.LabelAndIconIndicatorStrategy: View createIndicatorView()>,25,26,<android.widget.TabHost.LabelAndIconIndicatorStrategy: View createIndicatorView()>,<android.widget.TabHost.LabelAndIconIndicatorStrategy: View createIndicatorView()>,0,"{
    final Context context = getContext();
    LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    View tabIndicator = inflater.inflate(mTabLayoutId, // tab widget is the parent
    mTabWidget, // no inflate params
    false);
    final TextView tv = (TextView) tabIndicator.findViewById(R.id.title);
    final ImageView iconView = (ImageView) tabIndicator.findViewById(R.id.icon);
    // when icon is gone by default, we're in exclusive mode
    final boolean exclusive = iconView.getVisibility() == View.GONE;
    final boolean bindIcon = !exclusive || TextUtils.isEmpty(mLabel);
    tv.setText(mLabel);
    if (bindIcon && mIcon != null) {
        iconView.setImageDrawable(mIcon);
        iconView.setVisibility(VISIBLE);
    }
    if (context.getApplicationInfo().targetSdkVersion <= Build.VERSION_CODES.DONUT) {
        // Donut apps get old color scheme
        tabIndicator.setBackgroundResource(R.drawable.tab_indicator_v4);
        tv.setTextColor(context.getColorStateList(R.color.tab_indicator_text_v4));
    }
    return tabIndicator;
}","{
    final Context context = getContext();
    LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    View tabIndicator = inflater.inflate(mTabLayoutId, // tab widget is the parent
    mTabWidget, // no inflate params
    false);
    final TextView tv = tabIndicator.findViewById(R.id.title);
    final ImageView iconView = tabIndicator.findViewById(R.id.icon);
    // when icon is gone by default, we're in exclusive mode
    final boolean exclusive = iconView.getVisibility() == View.GONE;
    final boolean bindIcon = !exclusive || TextUtils.isEmpty(mLabel);
    tv.setText(mLabel);
    if (bindIcon && mIcon != null) {
        iconView.setImageDrawable(mIcon);
        iconView.setVisibility(VISIBLE);
    }
    if (context.getApplicationInfo().targetSdkVersion <= Build.VERSION_CODES.DONUT) {
        // Donut apps get old color scheme
        tabIndicator.setBackgroundResource(R.drawable.tab_indicator_v4);
        tv.setTextColor(context.getColorStateList(R.color.tab_indicator_text_v4));
    }
    return tabIndicator;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,0,0,"The code between the two versions is identical; there are no changes in the statements or logic, thus the change type is 0.","Since there is no code change, no Compatibility Issue can arise; the CI type is 0."
551,"<android.widget.Editor.CursorAnchorInfoNotifier: void updatePosition(int,int,boolean,boolean)>",25,26,"<android.widget.Editor.CursorAnchorInfoNotifier: void updatePosition(int,int,boolean,boolean)>","<android.widget.Editor.CursorAnchorInfoNotifier: void updatePosition(int,int,boolean,boolean)>",0,"{
    final InputMethodState ims = mInputMethodState;
    if (ims == null || ims.mBatchEditNesting > 0) {
        return;
    }
    final InputMethodManager imm = InputMethodManager.peekInstance();
    if (null == imm) {
        return;
    }
    if (!imm.isActive(mTextView)) {
        return;
    }
    // Skip if the IME has not requested the cursor/anchor position.
    if (!imm.isCursorAnchorInfoEnabled()) {
        return;
    }
    Layout layout = mTextView.getLayout();
    if (layout == null) {
        return;
    }
    final CursorAnchorInfo.Builder builder = mSelectionInfoBuilder;
    builder.reset();
    final int selectionStart = mTextView.getSelectionStart();
    builder.setSelectionRange(selectionStart, mTextView.getSelectionEnd());
    // Construct transformation matrix from view local coordinates to screen coordinates.
    mViewToScreenMatrix.set(mTextView.getMatrix());
    mTextView.getLocationOnScreen(mTmpIntOffset);
    mViewToScreenMatrix.postTranslate(mTmpIntOffset[0], mTmpIntOffset[1]);
    builder.setMatrix(mViewToScreenMatrix);
    final float viewportToContentHorizontalOffset = mTextView.viewportToContentHorizontalOffset();
    final float viewportToContentVerticalOffset = mTextView.viewportToContentVerticalOffset();
    final CharSequence text = mTextView.getText();
    if (text instanceof Spannable) {
        final Spannable sp = (Spannable) text;
        int composingTextStart = EditableInputConnection.getComposingSpanStart(sp);
        int composingTextEnd = EditableInputConnection.getComposingSpanEnd(sp);
        if (composingTextEnd < composingTextStart) {
            final int temp = composingTextEnd;
            composingTextEnd = composingTextStart;
            composingTextStart = temp;
        }
        final boolean hasComposingText = (0 <= composingTextStart) && (composingTextStart < composingTextEnd);
        if (hasComposingText) {
            final CharSequence composingText = text.subSequence(composingTextStart, composingTextEnd);
            builder.setComposingText(composingTextStart, composingText);
            final int minLine = layout.getLineForOffset(composingTextStart);
            final int maxLine = layout.getLineForOffset(composingTextEnd - 1);
            for (int line = minLine; line <= maxLine; ++line) {
                final int lineStart = layout.getLineStart(line);
                final int lineEnd = layout.getLineEnd(line);
                final int offsetStart = Math.max(lineStart, composingTextStart);
                final int offsetEnd = Math.min(lineEnd, composingTextEnd);
                final boolean ltrLine = layout.getParagraphDirection(line) == Layout.DIR_LEFT_TO_RIGHT;
                final float[] widths = new float[offsetEnd - offsetStart];
                layout.getPaint().getTextWidths(text, offsetStart, offsetEnd, widths);
                final float top = layout.getLineTop(line);
                final float bottom = layout.getLineBottom(line);
                for (int offset = offsetStart; offset < offsetEnd; ++offset) {
                    final float charWidth = widths[offset - offsetStart];
                    final boolean isRtl = layout.isRtlCharAt(offset);
                    final float primary = layout.getPrimaryHorizontal(offset);
                    final float secondary = layout.getSecondaryHorizontal(offset);
                    // TODO: This doesn't work perfectly for text with custom styles and
                    // TAB chars.
                    final float left;
                    final float right;
                    if (ltrLine) {
                        if (isRtl) {
                            left = secondary - charWidth;
                            right = secondary;
                        } else {
                            left = primary;
                            right = primary + charWidth;
                        }
                    } else {
                        if (!isRtl) {
                            left = secondary;
                            right = secondary + charWidth;
                        } else {
                            left = primary - charWidth;
                            right = primary;
                        }
                    }
                    // TODO: Check top-right and bottom-left as well.
                    final float localLeft = left + viewportToContentHorizontalOffset;
                    final float localRight = right + viewportToContentHorizontalOffset;
                    final float localTop = top + viewportToContentVerticalOffset;
                    final float localBottom = bottom + viewportToContentVerticalOffset;
                    final boolean isTopLeftVisible = isPositionVisible(localLeft, localTop);
                    final boolean isBottomRightVisible = isPositionVisible(localRight, localBottom);
                    int characterBoundsFlags = 0;
                    if (isTopLeftVisible || isBottomRightVisible) {
                        characterBoundsFlags |= CursorAnchorInfo.FLAG_HAS_VISIBLE_REGION;
                    }
                    if (!isTopLeftVisible || !isBottomRightVisible) {
                        characterBoundsFlags |= CursorAnchorInfo.FLAG_HAS_INVISIBLE_REGION;
                    }
                    if (isRtl) {
                        characterBoundsFlags |= CursorAnchorInfo.FLAG_IS_RTL;
                    }
                    // Here offset is the index in Java chars.
                    builder.addCharacterBounds(offset, localLeft, localTop, localRight, localBottom, characterBoundsFlags);
                }
            }
        }
    }
    // Treat selectionStart as the insertion point.
    if (0 <= selectionStart) {
        final int offset = selectionStart;
        final int line = layout.getLineForOffset(offset);
        final float insertionMarkerX = layout.getPrimaryHorizontal(offset) + viewportToContentHorizontalOffset;
        final float insertionMarkerTop = layout.getLineTop(line) + viewportToContentVerticalOffset;
        final float insertionMarkerBaseline = layout.getLineBaseline(line) + viewportToContentVerticalOffset;
        final float insertionMarkerBottom = layout.getLineBottom(line) + viewportToContentVerticalOffset;
        final boolean isTopVisible = isPositionVisible(insertionMarkerX, insertionMarkerTop);
        final boolean isBottomVisible = isPositionVisible(insertionMarkerX, insertionMarkerBottom);
        int insertionMarkerFlags = 0;
        if (isTopVisible || isBottomVisible) {
            insertionMarkerFlags |= CursorAnchorInfo.FLAG_HAS_VISIBLE_REGION;
        }
        if (!isTopVisible || !isBottomVisible) {
            insertionMarkerFlags |= CursorAnchorInfo.FLAG_HAS_INVISIBLE_REGION;
        }
        if (layout.isRtlCharAt(offset)) {
            insertionMarkerFlags |= CursorAnchorInfo.FLAG_IS_RTL;
        }
        builder.setInsertionMarkerLocation(insertionMarkerX, insertionMarkerTop, insertionMarkerBaseline, insertionMarkerBottom, insertionMarkerFlags);
    }
    imm.updateCursorAnchorInfo(mTextView, builder.build());
}","{
    final InputMethodState ims = mInputMethodState;
    if (ims == null || ims.mBatchEditNesting > 0) {
        return;
    }
    final InputMethodManager imm = InputMethodManager.peekInstance();
    if (null == imm) {
        return;
    }
    if (!imm.isActive(mTextView)) {
        return;
    }
    // Skip if the IME has not requested the cursor/anchor position.
    if (!imm.isCursorAnchorInfoEnabled()) {
        return;
    }
    Layout layout = mTextView.getLayout();
    if (layout == null) {
        return;
    }
    final CursorAnchorInfo.Builder builder = mSelectionInfoBuilder;
    builder.reset();
    final int selectionStart = mTextView.getSelectionStart();
    builder.setSelectionRange(selectionStart, mTextView.getSelectionEnd());
    // Construct transformation matrix from view local coordinates to screen coordinates.
    mViewToScreenMatrix.set(mTextView.getMatrix());
    mTextView.getLocationOnScreen(mTmpIntOffset);
    mViewToScreenMatrix.postTranslate(mTmpIntOffset[0], mTmpIntOffset[1]);
    builder.setMatrix(mViewToScreenMatrix);
    final float viewportToContentHorizontalOffset = mTextView.viewportToContentHorizontalOffset();
    final float viewportToContentVerticalOffset = mTextView.viewportToContentVerticalOffset();
    final CharSequence text = mTextView.getText();
    if (text instanceof Spannable) {
        final Spannable sp = (Spannable) text;
        int composingTextStart = EditableInputConnection.getComposingSpanStart(sp);
        int composingTextEnd = EditableInputConnection.getComposingSpanEnd(sp);
        if (composingTextEnd < composingTextStart) {
            final int temp = composingTextEnd;
            composingTextEnd = composingTextStart;
            composingTextStart = temp;
        }
        final boolean hasComposingText = (0 <= composingTextStart) && (composingTextStart < composingTextEnd);
        if (hasComposingText) {
            final CharSequence composingText = text.subSequence(composingTextStart, composingTextEnd);
            builder.setComposingText(composingTextStart, composingText);
            mTextView.populateCharacterBounds(builder, composingTextStart, composingTextEnd, viewportToContentHorizontalOffset, viewportToContentVerticalOffset);
        }
    }
    // Treat selectionStart as the insertion point.
    if (0 <= selectionStart) {
        final int offset = selectionStart;
        final int line = layout.getLineForOffset(offset);
        final float insertionMarkerX = layout.getPrimaryHorizontal(offset) + viewportToContentHorizontalOffset;
        final float insertionMarkerTop = layout.getLineTop(line) + viewportToContentVerticalOffset;
        final float insertionMarkerBaseline = layout.getLineBaseline(line) + viewportToContentVerticalOffset;
        final float insertionMarkerBottom = layout.getLineBottom(line) + viewportToContentVerticalOffset;
        final boolean isTopVisible = mTextView.isPositionVisible(insertionMarkerX, insertionMarkerTop);
        final boolean isBottomVisible = mTextView.isPositionVisible(insertionMarkerX, insertionMarkerBottom);
        int insertionMarkerFlags = 0;
        if (isTopVisible || isBottomVisible) {
            insertionMarkerFlags |= CursorAnchorInfo.FLAG_HAS_VISIBLE_REGION;
        }
        if (!isTopVisible || !isBottomVisible) {
            insertionMarkerFlags |= CursorAnchorInfo.FLAG_HAS_INVISIBLE_REGION;
        }
        if (layout.isRtlCharAt(offset)) {
            insertionMarkerFlags |= CursorAnchorInfo.FLAG_IS_RTL;
        }
        builder.setInsertionMarkerLocation(insertionMarkerX, insertionMarkerTop, insertionMarkerBaseline, insertionMarkerBottom, insertionMarkerFlags);
    }
    imm.updateCursorAnchorInfo(mTextView, builder.build());
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
552,"<android.app.admin.DevicePolicyManager: int getPermissionGrantState(ComponentName,String,String)>",25,26,"<android.app.admin.DevicePolicyManager: int getPermissionGrantState(ComponentName,String,String)>","<android.app.admin.DevicePolicyManager: int getPermissionGrantState(ComponentName,String,String)>",0,"{
    throwIfParentInstance(""getPermissionGrantState"");
    try {
        return mService.getPermissionGrantState(admin, packageName, permission);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}","{
    throwIfParentInstance(""getPermissionGrantState"");
    try {
        return mService.getPermissionGrantState(admin, mContext.getPackageName(), packageName, permission);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns the current grant state of a runtime permission for a specific application.
 *
 * @param admin Which profile or device owner this request is associated with.
 * @param packageName The application to check the grant state for.
 * @param permission The permission to check for.
 * @return the current grant state specified by device policy. If the profile or device owner
 * has not set a grant state, the return value is
 * {@link #PERMISSION_GRANT_STATE_DEFAULT}. This does not indicate whether or not the
 * permission is currently granted for the package.
 * <p/>
 * If a grant state was set by the profile or device owner, then the return value will
 * be one of {@link #PERMISSION_GRANT_STATE_DENIED} or
 * {@link #PERMISSION_GRANT_STATE_GRANTED}, which indicates if the permission is
 * currently denied or granted.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 * @see #setPermissionGrantState(ComponentName, String, String, int)
 * @see PackageManager#checkPermission(String, String)
 */
","/**
 * Returns the current grant state of a runtime permission for a specific application. This
 * function can be called by a device owner, profile owner, or by a delegate given the
 * {@link #DELEGATION_PERMISSION_GRANT} scope via {@link #setDelegatedScopes}.
 *
 * @param admin Which profile or device owner this request is associated with, or {@code null}
 * if the caller is a permission grant delegate.
 * @param packageName The application to check the grant state for.
 * @param permission The permission to check for.
 * @return the current grant state specified by device policy. If the profile or device owner
 * has not set a grant state, the return value is
 * {@link #PERMISSION_GRANT_STATE_DEFAULT}. This does not indicate whether or not the
 * permission is currently granted for the package.
 * <p/>
 * If a grant state was set by the profile or device owner, then the return value will
 * be one of {@link #PERMISSION_GRANT_STATE_DENIED} or
 * {@link #PERMISSION_GRANT_STATE_GRANTED}, which indicates if the permission is
 * currently denied or granted.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 * @see #setPermissionGrantState(ComponentName, String, String, int)
 * @see PackageManager#checkPermission(String, String)
 * @see #setDelegatedScopes
 * @see #DELEGATION_PERMISSION_GRANT
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The call to method mService.getPermissionGrantState has an additional parameter mContext.getPackageName() in the late version, thus the dependent API getPermissionGrantState signature has changed. This represents the code change type 5.","The nature of the change suggests an addition of a context-related parameter to the method call. However, it does not inherently indicate that behavior has changed because the semantic meaning of the added parameter is not known based solely on this information. Assuming that the underlying method still correctly handles the input parameters, including the new context package name, and that this detail is meant to refine or provide context for the permission request rather than alter the fundamental behavior, the change should be compatible with existing uses where the admin and packageName remain the same. Therefore, we do not have enough evidence that the added parameter leads to a compatibility issue. The CI type is 0."
553,<android.app.ActivityThread.Profiler: void setProfiler(ProfilerInfo)>,25,26,<android.app.ActivityThread.Profiler: void setProfiler(ProfilerInfo)>,<android.app.ActivityThread.Profiler: void setProfiler(ProfilerInfo)>,0,"{
    ParcelFileDescriptor fd = profilerInfo.profileFd;
    if (profiling) {
        if (fd != null) {
            try {
                fd.close();
            } catch (IOException e) {
            // Ignore
            }
        }
        return;
    }
    if (profileFd != null) {
        try {
            profileFd.close();
        } catch (IOException e) {
        // Ignore
        }
    }
    profileFile = profilerInfo.profileFile;
    profileFd = fd;
    samplingInterval = profilerInfo.samplingInterval;
    autoStopProfiler = profilerInfo.autoStopProfiler;
}","{
    ParcelFileDescriptor fd = profilerInfo.profileFd;
    if (profiling) {
        if (fd != null) {
            try {
                fd.close();
            } catch (IOException e) {
            // Ignore
            }
        }
        return;
    }
    if (profileFd != null) {
        try {
            profileFd.close();
        } catch (IOException e) {
        // Ignore
        }
    }
    profileFile = profilerInfo.profileFile;
    profileFd = fd;
    samplingInterval = profilerInfo.samplingInterval;
    autoStopProfiler = profilerInfo.autoStopProfiler;
    streamingOutput = profilerInfo.streamingOutput;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The late version of the code includes one additional assignment statement, `streamingOutput = profilerInfo.streamingOutput;`, which is not present in the early version, so the code change type is 4.","This new statement is an assignment and does not alter the control flow, exception handling, or return value of the method. Therefore, it does not introduce a Compatibility Issue; the API's behavior remains the same with regard to what it returns or the exceptions it might throw."
554,"<android.net.Network: URLConnection openConnection(URL,Proxy)>",25,26,"<android.net.Network: URLConnection openConnection(URL,Proxy)>","<android.net.Network: URLConnection openConnection(URL,Proxy)>",0,"{
    if (proxy == null)
        throw new IllegalArgumentException(""proxy is null"");
    maybeInitHttpClient();
    String protocol = url.getProtocol();
    OkUrlFactory okUrlFactory;
    // Could this cause unexpected behavior?
    if (protocol.equals(""http"")) {
        okUrlFactory = HttpHandler.createHttpOkUrlFactory(proxy);
    } else if (protocol.equals(""https"")) {
        okUrlFactory = HttpsHandler.createHttpsOkUrlFactory(proxy);
    } else {
        // passed another protocol.
        throw new MalformedURLException(""Invalid URL or unrecognized protocol "" + protocol);
    }
    OkHttpClient client = okUrlFactory.client();
    client.setSocketFactory(getSocketFactory()).setConnectionPool(mConnectionPool);
    // Use internal APIs to change the Network.
    Internal.instance.setNetwork(client, mNetwork);
    return okUrlFactory.open(url);
}","{
    if (proxy == null)
        throw new IllegalArgumentException(""proxy is null"");
    maybeInitHttpClient();
    String protocol = url.getProtocol();
    OkUrlFactory okUrlFactory;
    // Could this cause unexpected behavior?
    if (protocol.equals(""http"")) {
        okUrlFactory = HttpHandler.createHttpOkUrlFactory(proxy);
    } else if (protocol.equals(""https"")) {
        okUrlFactory = HttpsHandler.createHttpsOkUrlFactory(proxy);
    } else {
        // passed another protocol.
        throw new MalformedURLException(""Invalid URL or unrecognized protocol "" + protocol);
    }
    OkHttpClient client = okUrlFactory.client();
    client.setSocketFactory(getSocketFactory()).setConnectionPool(mConnectionPool);
    // Let network traffic go via mDns
    client.setDns(mDns);
    return okUrlFactory.open(url);
}",1,"/**
 * Opens the specified {@link URL} on this {@code Network}, such that all traffic will be sent
 * on this Network. The URL protocol must be {@code HTTP} or {@code HTTPS}.
 *
 * @param proxy the proxy through which the connection will be established.
 * @return a {@code URLConnection} to the resource referred to by this URL.
 * @throws MalformedURLException if the URL protocol is not HTTP or HTTPS.
 * @throws IllegalArgumentException if the argument proxy is null.
 * @throws IOException if an error occurs while opening the connection.
 * @see java.net.URL#openConnection()
 */
","/**
 * Opens the specified {@link URL} on this {@code Network}, such that all traffic will be sent
 * on this Network. The URL protocol must be {@code HTTP} or {@code HTTPS}.
 *
 * @param proxy the proxy through which the connection will be established.
 * @return a {@code URLConnection} to the resource referred to by this URL.
 * @throws MalformedURLException if the URL protocol is not HTTP or HTTPS.
 * @throws IllegalArgumentException if the argument proxy is null.
 * @throws IOException if an error occurs while opening the connection.
 * @see java.net.URL#openConnection()
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"A new statement client.setDns(mDns); has been added that sets the DNS for the OkHttpClient object, so the code change type is 4.","The added statement sets the DNS for the network operations performed by the client. This change configures how the network requests are resolved but it does not affect the public behavior of the method in terms of its signature, return type, or exceptions raised. Thus, there will be no Compatibility Issue arising from this change."
555,<android.view.accessibility.AccessibilityNodeInfo: CharSequence getText()>,25,26,<android.view.accessibility.AccessibilityNodeInfo: CharSequence getText()>,<android.view.accessibility.AccessibilityNodeInfo: CharSequence getText()>,0,"{
    return mText;
}","{
    // Attach this node to any spans that need it
    if (mText instanceof Spanned) {
        Spanned spanned = (Spanned) mText;
        AccessibilityClickableSpan[] clickableSpans = spanned.getSpans(0, mText.length(), AccessibilityClickableSpan.class);
        for (int i = 0; i < clickableSpans.length; i++) {
            clickableSpans[i].copyConnectionDataFrom(this);
        }
        AccessibilityURLSpan[] urlSpans = spanned.getSpans(0, mText.length(), AccessibilityURLSpan.class);
        for (int i = 0; i < urlSpans.length; i++) {
            urlSpans[i].copyConnectionDataFrom(this);
        }
    }
    return mText;
}",1,"/**
 * Gets the text of this node.
 *
 * @return The text.
 */
","/**
 * Gets the text of this node.
 * <p>
 * <strong>Note:</strong> If the text contains {@link ClickableSpan}s or {@link URLSpan}s,
 * these spans will have been replaced with ones whose {@link ClickableSpan#onClick(View)}
 * can be called from an {@link AccessibilityService}. When called from a service, the
 * {@link View} argument is ignored and the corresponding span will be found on the view that
 * this {@code AccessibilityNodeInfo} represents and called with that view as its argument.
 * <p>
 * This treatment of {@link ClickableSpan}s means that the text returned from this method may
 * different slightly one passed to {@link #setText(CharSequence)}, although they will be
 * equivalent according to {@link TextUtils#equals(CharSequence, CharSequence)}. The
 * {@link ClickableSpan#onClick(View)} of any spans, however, will generally not work outside
 * of an accessibility service.
 * </p>
 *
 * @return The text.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The late version adds a block of code that processes `Spanned` objects before returning `mText`. The new code does not alter the return value but prepares the `mText` by setting up additional data on spans it may contain. The code changes include control dependency (a new 'if' control statement) and other changes in the form of new operations within the control statement. The code change type is 3,4.","There are no changes to the return value or the types of exceptions potentially thrown by the method. Therefore, the new code does not introduce a Compatibility Issue, so the CI type is 0."
556,<android.widget.RemoteViews.AsyncApplyTask: ViewTree doInBackground(Void)>,25,26,<android.widget.RemoteViews.AsyncApplyTask: ViewTree doInBackground(Void)>,<android.widget.RemoteViews.AsyncApplyTask: ViewTree doInBackground(Void)>,0,"{
    try {
        if (mResult == null) {
            mResult = inflateView(mContext, mRV, mParent);
        }
        mTree = new ViewTree(mResult);
        if (mRV.mActions != null) {
            int count = mRV.mActions.size();
            mActions = new Action[count];
            for (int i = 0; i < count && !isCancelled(); i++) {
                // TODO: check if isCanclled in nested views.
                mActions[i] = mRV.mActions.get(i).initActionAsync(mTree, mParent, mHandler);
            }
        } else {
            mActions = null;
        }
        return mTree;
    } catch (Exception e) {
        mError = e;
        return null;
    }
}","{
    try {
        if (mResult == null) {
            mResult = inflateView(mContext, mRV, mParent);
        }
        mTree = new ViewTree(mResult);
        if (mRV.mActions != null) {
            int count = mRV.mActions.size();
            mActions = new Action[count];
            for (int i = 0; i < count && !isCancelled(); i++) {
                // TODO: check if isCancelled in nested views.
                mActions[i] = mRV.mActions.get(i).initActionAsync(mTree, mParent, mHandler);
            }
        } else {
            mActions = null;
        }
        return mTree;
    } catch (Exception e) {
        mError = e;
        return null;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,0,0,"There are no changes between the early version and the late version of the implementation code, so the code change type is 0.","Since there is no change in the code, there are no potential Compatibility Issues, so the CI type is 0."
557,<android.view.accessibility.AccessibilityNodeInfo: void setText(CharSequence)>,25,26,<android.view.accessibility.AccessibilityNodeInfo: void setText(CharSequence)>,<android.view.accessibility.AccessibilityNodeInfo: void setText(CharSequence)>,0,"{
    enforceNotSealed();
    mText = text;
}","{
    enforceNotSealed();
    mOriginalText = text;
    // Replace any ClickableSpans in mText with placeholders
    if (text instanceof Spanned) {
        ClickableSpan[] spans = ((Spanned) text).getSpans(0, text.length(), ClickableSpan.class);
        if (spans.length > 0) {
            Spannable spannable = new SpannableStringBuilder(text);
            for (int i = 0; i < spans.length; i++) {
                ClickableSpan span = spans[i];
                if ((span instanceof AccessibilityClickableSpan) || (span instanceof AccessibilityURLSpan)) {
                    // We've already done enough
                    break;
                }
                int spanToReplaceStart = spannable.getSpanStart(span);
                int spanToReplaceEnd = spannable.getSpanEnd(span);
                int spanToReplaceFlags = spannable.getSpanFlags(span);
                spannable.removeSpan(span);
                ClickableSpan replacementSpan = (span instanceof URLSpan) ? new AccessibilityURLSpan((URLSpan) span) : new AccessibilityClickableSpan(span.getId());
                spannable.setSpan(replacementSpan, spanToReplaceStart, spanToReplaceEnd, spanToReplaceFlags);
            }
            mText = spannable;
            return;
        }
    }
    mText = (text == null) ? null : text.subSequence(0, text.length());
}",1,"/**
 * Sets the text of this node.
 * <p>
 * <strong>Note:</strong> Cannot be called from an
 * {@link android.accessibilityservice.AccessibilityService}.
 * This class is made immutable before being delivered to an AccessibilityService.
 * </p>
 *
 * @param text The text.
 *
 * @throws IllegalStateException If called from an AccessibilityService.
 */
","/**
 * Sets the text of this node.
 * <p>
 * <strong>Note:</strong> Cannot be called from an
 * {@link android.accessibilityservice.AccessibilityService}.
 * This class is made immutable before being delivered to an AccessibilityService.
 * </p>
 *
 * @param text The text.
 *
 * @throws IllegalStateException If called from an AccessibilityService.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The late version introduces additional logic for handling Spanned text, creating a replacement for ClickableSpans, and assigning values to mOriginalText and mText conditionally. The control dependency has changed due to the new 'if' condition, and other statements have also changed related to processing the spans and setting the mText. The 'mOriginalText' and 'mText' fields are assigned differently in the two versions, which means 'setText' now behaves differently when the text contains spans. Therefore, the code change types are 1, 3, and 4.","Because 'mText' is assigned differently in the late version based on the conditions introduced, the behavior of setText has changed. Clients using this API may expect different outcomes for CharSequence containing ClickableSpan, and there is a potential change in what the 'setText' method does with the input text; thus, a Compatibility Issue due to potential different return values or types may arise, making the CI type 1."
558,"<android.widget.RemoteViewsAdapter.RemoteViewsAdapterServiceConnection: void bind(Context,int,Intent)>",25,26,"<android.widget.RemoteViewsAdapter.RemoteViewsAdapterServiceConnection: void bind(Context,int,Intent)>","<android.widget.RemoteViewsAdapter.RemoteViewsAdapterServiceConnection: void bind(Context,int,Intent)>",0,"{
    if (!mIsConnecting) {
        try {
            RemoteViewsAdapter adapter;
            final AppWidgetManager mgr = AppWidgetManager.getInstance(context);
            if ((adapter = mAdapter.get()) != null) {
                mgr.bindRemoteViewsService(context.getOpPackageName(), appWidgetId, intent, asBinder());
            } else {
                Slog.w(TAG, ""bind: adapter was null"");
            }
            mIsConnecting = true;
        } catch (Exception e) {
            Log.e(""RemoteViewsAdapterServiceConnection"", ""bind(): "" + e.getMessage());
            mIsConnecting = false;
            mIsConnected = false;
        }
    }
}","{
    if (!mIsConnecting) {
        try {
            RemoteViewsAdapter adapter;
            final AppWidgetManager mgr = AppWidgetManager.getInstance(context);
            if ((adapter = mAdapter.get()) != null) {
                mgr.bindRemoteViewsService(context.getOpPackageName(), appWidgetId, intent, asBinder());
            } else {
                Slog.w(TAG, ""bind: adapter was null"");
            }
            mIsConnecting = true;
        } catch (Exception e) {
            Log.e(""RVAServiceConnection"", ""bind(): "" + e.getMessage());
            mIsConnecting = false;
            mIsConnected = false;
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change between the versions is the parameter provided to the Log.e method, where the tag ""RemoteViewsAdapterServiceConnection"" has been shortened to ""RVAServiceConnection"". This alters neither the control flow nor the method’s functional behavior, hence it is an ""Other statement changed"".","No compatibility issue arises from this change, since it doesn't affect the variable returned or the exceptions thrown by the method; it simply affects the logging tag used internally."
559,"<android.provider.DocumentsContract: boolean deleteDocument(ContentResolver,Uri)>",25,26,"<android.provider.DocumentsContract: boolean deleteDocument(ContentResolver,Uri)>","<android.provider.DocumentsContract: boolean deleteDocument(ContentResolver,Uri)>",0,"{
    final ContentProviderClient client = resolver.acquireUnstableContentProviderClient(documentUri.getAuthority());
    try {
        deleteDocument(client, documentUri);
        return true;
    } catch (Exception e) {
        Log.w(TAG, ""Failed to delete document"", e);
        return false;
    } finally {
        ContentProviderClient.releaseQuietly(client);
    }
}","{
    final ContentProviderClient client = resolver.acquireUnstableContentProviderClient(documentUri.getAuthority());
    try {
        deleteDocument(client, documentUri);
        return true;
    } catch (Exception e) {
        Log.w(TAG, ""Failed to delete document"", e);
        rethrowIfNecessary(resolver, e);
        return false;
    } finally {
        ContentProviderClient.releaseQuietly(client);
    }
}",1,"/**
 * Delete the given document.
 *
 * @param documentUri document with {@link Document#FLAG_SUPPORTS_DELETE}
 * @return if the document was deleted successfully.
 */
","/**
 * Delete the given document.
 *
 * @param documentUri document with {@link Document#FLAG_SUPPORTS_DELETE}
 * @return if the document was deleted successfully.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"There is an addition of the method call rethrowIfNecessary(resolver, e); however, this does not affect the return statement or exception handling because it's enclosed within a catch block where any potential exception from rethrowIfNecessary would not change the control flow (it will still return false after logging). Thus, the code change type is 4.","There is no Compatibility Issue introduced as the method call rethrowIfNecessary() inside the catch block does not change the return value on successful execution (which is true) nor alters the exception handling mechanism of the original catch block (it still catches all exceptions and returns false). If rethrowIfNecessary throws an exception, this exception is either a runtime exception that wouldn't change the API contract, or it was an already-existing possible outcome (signalled by the generic catch of Exception). Hence, the CI type is 0."
560,"<android.app.SharedPreferencesImpl.EditorImpl: Editor putBoolean(String,boolean)>",25,26,"<android.app.SharedPreferencesImpl.EditorImpl: Editor putBoolean(String,boolean)>","<android.app.SharedPreferencesImpl.EditorImpl: Editor putBoolean(String,boolean)>",0,"{
    synchronized (this) {
        mModified.put(key, value);
        return this;
    }
}","{
    synchronized (mLock) {
        mModified.put(key, value);
        return this;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The synchronization lock object has changed from `this` to `mLock`. This change might affect how threads access synchronized blocks of code. Additionally, it is an other statement changed since it's not a control dependency, return, or exception handling change. Therefore, the code change types are 3 and 4.","Although the synchronization lock object changed, this does not lead to a compatibility issue since the function's behavior, as seen by the external caller, remains the same. The method still puts a value in a map and returns the same EditorImpl object, regardless of the internal lock object used. Hence, there is no compatibility issue, as the method's contract and return value are unchanged."
561,<android.view.FrameMetrics: long getMetric(int)>,25,26,<android.view.FrameMetrics: long getMetric(int)>,<android.view.FrameMetrics: long getMetric(int)>,0,"{
    if (id < UNKNOWN_DELAY_DURATION || id > FIRST_DRAW_FRAME) {
        return -1;
    }
    if (mTimingData == null) {
        return -1;
    }
    if (id == FIRST_DRAW_FRAME) {
        return (mTimingData[Index.FLAGS] & FRAME_INFO_FLAG_FIRST_DRAW) != 0 ? 1 : 0;
    }
    int durationsIdx = 2 * id;
    return mTimingData[DURATIONS[durationsIdx + 1]] - mTimingData[DURATIONS[durationsIdx]];
}","{
    if (id < UNKNOWN_DELAY_DURATION || id > VSYNC_TIMESTAMP) {
        return -1;
    }
    if (mTimingData == null) {
        return -1;
    }
    if (id == FIRST_DRAW_FRAME) {
        return (mTimingData[Index.FLAGS] & FRAME_INFO_FLAG_FIRST_DRAW) != 0 ? 1 : 0;
    } else if (id == INTENDED_VSYNC_TIMESTAMP) {
        return mTimingData[Index.INTENDED_VSYNC];
    } else if (id == VSYNC_TIMESTAMP) {
        return mTimingData[Index.VSYNC];
    }
    int durationsIdx = 2 * id;
    return mTimingData[DURATIONS[durationsIdx + 1]] - mTimingData[DURATIONS[durationsIdx]];
}",1,"/**
 * Retrieves the value associated with Metric identifier {@code id}
 * for this frame.
 * <p>
 * Boolean metrics are represented in [0,1], with 0 corresponding to
 * false, and 1 corresponding to true.
 * </p>
 * @param id the metric to retrieve
 * @return the value of the metric or -1 if it is not available.
 */
","/**
 * Retrieves the value associated with Metric identifier {@code id}
 * for this frame.
 * <p>
 * Boolean metrics are represented in [0,1], with 0 corresponding to
 * false, and 1 corresponding to true.
 * </p>
 * @param id the metric to retrieve
 * @return the value of the metric or -1 if it is not available.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,5",1,"The control dependency has changed with the altered condition in the if statement and addition of else-if blocks handling new cases (INTENDED_VSYNC_TIMESTAMP and VSYNC_TIMESTAMP). Also, the range of valid 'id' values has been updated, which reflects a change in the constants used. These alterations could lead to accessing different indices of 'mTimingData', thus different return values, so the code change types are 1 and 3. Changes in the constants FIRST_DRAW_FRAME and VSYNC_TIMESTAMP likely come from outside the method, which implies a Dependent API change of type 5.","Due to the changes in the control dependency and handling of additional cases, the API could potentially return different values which were not accounted for previously. The change in the valid range for the parameter 'id' and the handling of new 'id' values with specific return statements would lead to a different return value, making the CI type 1."
562,<android.app.Activity: void stopLocalVoiceInteraction()>,25,26,<android.app.Activity: void stopLocalVoiceInteraction()>,<android.app.Activity: void stopLocalVoiceInteraction()>,0,"{
    try {
        ActivityManagerNative.getDefault().stopLocalVoiceInteraction(mToken);
    } catch (RemoteException re) {
    }
}","{
    try {
        ActivityManager.getService().stopLocalVoiceInteraction(mToken);
    } catch (RemoteException re) {
    }
}",1,"/**
 * Request to terminate the current voice interaction that was previously started
 * using {@link #startLocalVoiceInteraction(Bundle)}. When the interaction is
 * terminated, {@link #onLocalVoiceInteractionStopped()} will be called.
 */
","/**
 * Request to terminate the current voice interaction that was previously started
 * using {@link #startLocalVoiceInteraction(Bundle)}. When the interaction is
 * terminated, {@link #onLocalVoiceInteractionStopped()} will be called.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent API has changed from `ActivityManagerNative.getDefault()` to `ActivityManager.getService()`, so the code change type is 5.","Although the method called on the service object has changed, the API does not exhibit a different behavior from an external point of view because both the early and the late versions catch the RemoteException without handling it, and there is no code change that affects the return type or value. Therefore, there is no Compatibility Issue, and the CI type is 0."
563,<android.widget.AbsListView: void setRemoteViewsAdapter(Intent)>,25,26,<android.widget.AbsListView: void setRemoteViewsAdapter(Intent)>,<android.widget.AbsListView: void setRemoteViewsAdapter(Intent)>,0,"{
    // service handling the specified intent.
    if (mRemoteAdapter != null) {
        Intent.FilterComparison fcNew = new Intent.FilterComparison(intent);
        Intent.FilterComparison fcOld = new Intent.FilterComparison(mRemoteAdapter.getRemoteViewsServiceIntent());
        if (fcNew.equals(fcOld)) {
            return;
        }
    }
    mDeferNotifyDataSetChanged = false;
    // Otherwise, create a new RemoteViewsAdapter for binding
    mRemoteAdapter = new RemoteViewsAdapter(getContext(), intent, this);
    if (mRemoteAdapter.isDataReady()) {
        setAdapter(mRemoteAdapter);
    }
}","{
    setRemoteViewsAdapter(intent, false);
}",1,"/**
 * Sets up this AbsListView to use a remote views adapter which connects to a RemoteViewsService
 * through the specified intent.
 * @param intent the intent used to identify the RemoteViewsService for the adapter to connect to.
 */
","/**
 * Sets up this AbsListView to use a remote views adapter which connects to a RemoteViewsService
 * through the specified intent.
 * @param intent the intent used to identify the RemoteViewsService for the adapter to connect to.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The early implementation contained logic for determining whether to return early and for initializing and setting the mRemoteAdapter. In the late implementation, this logic is replaced by a single call to `setRemoteViewsAdapter(intent, false)`, which implies that the previous code has been refactored or moved into a different method, and the signature for the call to `setRemoteViewsAdapter` has been changed to include a boolean parameter. As such, the changes fall under dependent API changed (because now it calls an overloaded method with a different signature) and other statement changed (because the implementation details have been changed).","Since the actual implementation details including checks and adapter setting have been moved or refactored into another method, it's possible that the behavior of setting the remote views adapter could differ from the previous version. Therefore, this could lead to a Compatibility Issue due to potentially different return values or states."
564,<android.app.SystemServiceRegistry.CachedServiceFetcher: T getService(ContextImpl)>,25,26,<android.app.SystemServiceRegistry.CachedServiceFetcher: T getService(ContextImpl)>,<android.app.SystemServiceRegistry.CachedServiceFetcher: T getService(ContextImpl)>,0,"{
    final Object[] cache = ctx.mServiceCache;
    synchronized (cache) {
        // Fetch or create the service.
        Object service = cache[mCacheIndex];
        if (service == null) {
            service = createService(ctx);
            cache[mCacheIndex] = service;
        }
        return (T) service;
    }
}","{
    final Object[] cache = ctx.mServiceCache;
    synchronized (cache) {
        // Fetch or create the service.
        Object service = cache[mCacheIndex];
        if (service == null) {
            try {
                service = createService(ctx);
                cache[mCacheIndex] = service;
            } catch (ServiceNotFoundException e) {
                onServiceNotFound(e);
            }
        }
        return (T) service;
    }
}",1,,,-1,"[@Override, @SuppressWarnings(""unchecked"")]","[@Override, @SuppressWarnings(""unchecked"")]",-1,-1,-1,-1,-1,-1,"2,3",2,"The change in the implementation introduces an additional try-catch block with exception handling for ServiceNotFoundException within the condition when the service is null. Thus, the change type is 2,3, indicating changes in exception handling statements and control dependency.","The new exception handling for ServiceNotFoundException will modify the behavior of the API — if `createService(ctx)` throws a `ServiceNotFoundException`, the previous version would not handle this and would continue to potentially return a null. In the late version, the exception is handled possibly preventing the returning of a null and instead handling the exception with `onServiceNotFound(e)`. This leads to a CI type of 2, as it potentially causes the API to throw a different exception or handle it differently than before."
565,"<android.app.Activity: void onApplyThemeResource(Theme,int,boolean)>",25,26,"<android.app.Activity: void onApplyThemeResource(Theme,int,boolean)>","<android.app.Activity: void onApplyThemeResource(Theme,int,boolean)>",0,"{
    if (mParent == null) {
        super.onApplyThemeResource(theme, resid, first);
    } else {
        try {
            theme.setTo(mParent.getTheme());
        } catch (Exception e) {
        // Empty
        }
        theme.applyStyle(resid, false);
    }
    // Get the primary color and update the TaskDescription for this activity
    TypedArray a = theme.obtainStyledAttributes(com.android.internal.R.styleable.ActivityTaskDescription);
    if (mTaskDescription.getPrimaryColor() == 0) {
        int colorPrimary = a.getColor(com.android.internal.R.styleable.ActivityTaskDescription_colorPrimary, 0);
        if (colorPrimary != 0 && Color.alpha(colorPrimary) == 0xFF) {
            mTaskDescription.setPrimaryColor(colorPrimary);
        }
    }
    // For dev-preview only.
    if (mTaskDescription.getBackgroundColor() == 0) {
        int colorBackground = a.getColor(com.android.internal.R.styleable.ActivityTaskDescription_colorBackground, 0);
        if (colorBackground != 0 && Color.alpha(colorBackground) == 0xFF) {
            mTaskDescription.setBackgroundColor(colorBackground);
        }
    }
    a.recycle();
    setTaskDescription(mTaskDescription);
}","{
    if (mParent == null) {
        super.onApplyThemeResource(theme, resid, first);
    } else {
        try {
            theme.setTo(mParent.getTheme());
        } catch (Exception e) {
        // Empty
        }
        theme.applyStyle(resid, false);
    }
    // Get the primary color and update the TaskDescription for this activity
    TypedArray a = theme.obtainStyledAttributes(com.android.internal.R.styleable.ActivityTaskDescription);
    if (mTaskDescription.getPrimaryColor() == 0) {
        int colorPrimary = a.getColor(com.android.internal.R.styleable.ActivityTaskDescription_colorPrimary, 0);
        if (colorPrimary != 0 && Color.alpha(colorPrimary) == 0xFF) {
            mTaskDescription.setPrimaryColor(colorPrimary);
        }
    }
    int colorBackground = a.getColor(com.android.internal.R.styleable.ActivityTaskDescription_colorBackground, 0);
    if (colorBackground != 0 && Color.alpha(colorBackground) == 0xFF) {
        mTaskDescription.setBackgroundColor(colorBackground);
    }
    final int statusBarColor = a.getColor(com.android.internal.R.styleable.ActivityTaskDescription_statusBarColor, 0);
    if (statusBarColor != 0) {
        mTaskDescription.setStatusBarColor(statusBarColor);
    }
    final int navigationBarColor = a.getColor(com.android.internal.R.styleable.ActivityTaskDescription_navigationBarColor, 0);
    if (navigationBarColor != 0) {
        mTaskDescription.setNavigationBarColor(navigationBarColor);
    }
    a.recycle();
    setTaskDescription(mTaskDescription);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,The code change includes the removal of the `if` check for `mTaskDescription.getBackgroundColor() == 0` and the addition of obtaining the `statusBarColor` and `navigationBarColor` from the theme's styled attributes and setting them in the `mTaskDescription`. The removed `if` check is a control dependency change (3) and the new code for `statusBarColor` and `navigationBarColor` is an other statement change (4).,"Although the implementation code has changed, there is no Compatibility Issue with this change as the behavior of setting the `colorBackground`, `statusBarColor`, and `navigationBarColor` on the `TaskDescription` will not result in a different behavior from the perspective of the method's signature. It's an internal implementation detail as all the colors are being set unconditionally now, which doesn't change the method's inputs or outputs, and hence does not affect the method's contract."
566,<android.service.notification.NotificationListenerService.MyHandler: void handleMessage(Message)>,25,26,<android.service.notification.NotificationListenerService.MyHandler: void handleMessage(Message)>,<android.service.notification.NotificationListenerService.MyHandler: void handleMessage(Message)>,0,"{
    if (!isConnected) {
        return;
    }
    switch(msg.what) {
        case MSG_ON_NOTIFICATION_POSTED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                StatusBarNotification sbn = (StatusBarNotification) args.arg1;
                RankingMap rankingMap = (RankingMap) args.arg2;
                args.recycle();
                onNotificationPosted(sbn, rankingMap);
            }
            break;
        case MSG_ON_NOTIFICATION_REMOVED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                StatusBarNotification sbn = (StatusBarNotification) args.arg1;
                RankingMap rankingMap = (RankingMap) args.arg2;
                args.recycle();
                onNotificationRemoved(sbn, rankingMap);
            }
            break;
        case MSG_ON_LISTENER_CONNECTED:
            {
                onListenerConnected();
            }
            break;
        case MSG_ON_NOTIFICATION_RANKING_UPDATE:
            {
                RankingMap rankingMap = (RankingMap) msg.obj;
                onNotificationRankingUpdate(rankingMap);
            }
            break;
        case MSG_ON_LISTENER_HINTS_CHANGED:
            {
                final int hints = msg.arg1;
                onListenerHintsChanged(hints);
            }
            break;
        case MSG_ON_INTERRUPTION_FILTER_CHANGED:
            {
                final int interruptionFilter = msg.arg1;
                onInterruptionFilterChanged(interruptionFilter);
            }
            break;
    }
}","{
    if (!isConnected) {
        return;
    }
    switch(msg.what) {
        case MSG_ON_NOTIFICATION_POSTED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                StatusBarNotification sbn = (StatusBarNotification) args.arg1;
                RankingMap rankingMap = (RankingMap) args.arg2;
                args.recycle();
                onNotificationPosted(sbn, rankingMap);
            }
            break;
        case MSG_ON_NOTIFICATION_REMOVED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                StatusBarNotification sbn = (StatusBarNotification) args.arg1;
                RankingMap rankingMap = (RankingMap) args.arg2;
                int reason = (int) args.arg3;
                args.recycle();
                onNotificationRemoved(sbn, rankingMap, reason);
            }
            break;
        case MSG_ON_LISTENER_CONNECTED:
            {
                onListenerConnected();
            }
            break;
        case MSG_ON_NOTIFICATION_RANKING_UPDATE:
            {
                RankingMap rankingMap = (RankingMap) msg.obj;
                onNotificationRankingUpdate(rankingMap);
            }
            break;
        case MSG_ON_LISTENER_HINTS_CHANGED:
            {
                final int hints = msg.arg1;
                onListenerHintsChanged(hints);
            }
            break;
        case MSG_ON_INTERRUPTION_FILTER_CHANGED:
            {
                final int interruptionFilter = msg.arg1;
                onInterruptionFilterChanged(interruptionFilter);
            }
            break;
        case MSG_ON_NOTIFICATION_CHANNEL_MODIFIED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                String pkgName = (String) args.arg1;
                UserHandle user = (UserHandle) args.arg2;
                NotificationChannel channel = (NotificationChannel) args.arg3;
                int modificationType = (int) args.arg4;
                onNotificationChannelModified(pkgName, user, channel, modificationType);
            }
            break;
        case MSG_ON_NOTIFICATION_CHANNEL_GROUP_MODIFIED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                String pkgName = (String) args.arg1;
                UserHandle user = (UserHandle) args.arg2;
                NotificationChannelGroup group = (NotificationChannelGroup) args.arg3;
                int modificationType = (int) args.arg4;
                onNotificationChannelGroupModified(pkgName, user, group, modificationType);
            }
            break;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3, 4, 5",0,"The control dependency has changed due to the addition of new case branches (MSG_ON_NOTIFICATION_CHANNEL_MODIFIED and MSG_ON_NOTIFICATION_CHANNEL_GROUP_MODIFIED) in the switch statement. Additionally, other statements have changed in the 'MSG_ON_NOTIFICATION_REMOVED' case with the inclusion of a new argument 'reason' when calling 'onNotificationRemoved' method. A dependent API has changed because 'onNotificationRemoved' is now being called with an additional parameter, indicating a method signature change. Thus, the code change type is 3, 4, 5.","There's not a new exception being thrown nor are return values or types changed for the existing cases in the switch statement; the handler continues to process messages as it did before, including for the existing message types. The new message types introduce new functionality but do not change how existing messages are handled. Therefore, there is no Compatibility Issue in this case."
568,"<android.app.ContextImpl: void sendStickyOrderedBroadcastAsUser(Intent,UserHandle,BroadcastReceiver,Handler,int,String,Bundle)>",25,26,"<android.app.ContextImpl: void sendStickyOrderedBroadcastAsUser(Intent,UserHandle,BroadcastReceiver,Handler,int,String,Bundle)>","<android.app.ContextImpl: void sendStickyOrderedBroadcastAsUser(Intent,UserHandle,BroadcastReceiver,Handler,int,String,Bundle)>",0,"{
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, rd, initialCode, initialData, initialExtras, null, AppOpsManager.OP_NONE, null, true, true, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, rd, initialCode, initialData, initialExtras, null, AppOpsManager.OP_NONE, null, true, true, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,"[@Override, @Deprecated]","[@Override, @Deprecated]",-1,-1,-1,-1,-1,-1,5,0,"The change occurs in a dependent API call from ActivityManagerNative.getDefault().broadcastIntent(...) to ActivityManager.getService().broadcastIntent(...), indicating a code change type of 5.","Although there is a change in the dependent API, there is no compatibility issue introduced because the modification appears to be a straightforward substitution between two versions of the same method, which indicates that this change is intended and managed within the system’s own framework. Therefore, it should not introduce behavior changes for clients using this API, as the semantic contract of sending a broadcast has not been altered. The way RemoteException is handled hasn't changed either. Hence, the CI type is 0."
569,<android.app.ActivityTransitionCoordinator: void scheduleGhostVisibilityChange(int)>,25,26,<android.app.ActivityTransitionCoordinator: void scheduleGhostVisibilityChange(int)>,<android.app.ActivityTransitionCoordinator: void scheduleGhostVisibilityChange(int)>,0,"{
    final View decorView = getDecor();
    if (decorView != null) {
        decorView.getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {

            @Override
            public boolean onPreDraw() {
                decorView.getViewTreeObserver().removeOnPreDrawListener(this);
                setGhostVisibility(visibility);
                return true;
            }
        });
    }
}","{
    final View decorView = getDecor();
    if (decorView != null) {
        OneShotPreDrawListener.add(decorView, () -> {
            setGhostVisibility(visibility);
        });
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",0,"The control dependency has slightly changed as the implementation now uses OneShotPreDrawListener.add instead of manually adding a listener with an anonymous inner class. There's a change in the method of attaching the listener for pre-draw and executing the visibility change, which constitutes 3). Additionally, the dependency on the OneShotPreDrawListener.add is a change in how the functionality is achieved, indicating that the dependent API has changed (5). The late implementation also does not execute the statement for removing the listener, which is considered as 4).","Although there is a change in code, there's no Compatibility Issue as the behavior of the scheduleGhostVisibilityChange API should remain consistent. The change is simply a refactor to use existing functionality in a simpler way using OneShotPreDrawListener, and should not cause any change in the way that clients of the API expect it to work. Thus, there's no difference in return values or types or in exception handling."
570,"<android.app.SharedPreferencesImpl: boolean getBoolean(String,boolean)>",25,26,"<android.app.SharedPreferencesImpl: boolean getBoolean(String,boolean)>","<android.app.SharedPreferencesImpl: boolean getBoolean(String,boolean)>",0,"{
    synchronized (this) {
        awaitLoadedLocked();
        Boolean v = (Boolean) mMap.get(key);
        return v != null ? v : defValue;
    }
}","{
    synchronized (mLock) {
        awaitLoadedLocked();
        Boolean v = (Boolean) mMap.get(key);
        return v != null ? v : defValue;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code change is related to the synchronization lock object, with 'this' being replaced by 'mLock'. So the code change type is 4.","This change doesn't lead to a Compatibility Issue because it only affects the lock object used for synchronization without altering the actual logic or behavior of the method, meaning that it will return the same values and handle exceptions in the same way as before. Thus, the CI type is 0."
573,"<android.app.admin.DevicePolicyManager: boolean removeKeyPair(ComponentName,String)>",25,26,"<android.app.admin.DevicePolicyManager: boolean removeKeyPair(ComponentName,String)>","<android.app.admin.DevicePolicyManager: boolean removeKeyPair(ComponentName,String)>",0,"{
    throwIfParentInstance(""removeKeyPair"");
    try {
        return mService.removeKeyPair(admin, alias);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    throwIfParentInstance(""removeKeyPair"");
    try {
        return mService.removeKeyPair(admin, mContext.getPackageName(), alias);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Called by a device or profile owner, or delegated certificate installer, to remove a
 * certificate and private key pair installed under a given alias.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or
 * {@code null} if calling from a delegated certificate installer.
 * @param alias The private key alias under which the certificate is installed.
 * @return {@code true} if the private key alias no longer exists, {@code false} otherwise.
 * @throws SecurityException if {@code admin} is not {@code null} and not a device or profile
 * owner.
 */
","/**
 * Called by a device or profile owner, or delegated certificate installer, to remove a
 * certificate and private key pair installed under a given alias.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or
 * {@code null} if calling from a delegated certificate installer.
 * @param alias The private key alias under which the certificate is installed.
 * @return {@code true} if the private key alias no longer exists, {@code false} otherwise.
 * @throws SecurityException if {@code admin} is not {@code null} and not a device or profile
 * owner.
 * @see #setDelegatedScopes
 * @see #DELEGATION_CERT_INSTALL
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"There is an addition of mContext.getPackageName() to the parameters of the method call mService.removeKeyPair(admin, alias) which now has become mService.removeKeyPair(admin, mContext.getPackageName(), alias). The method being called is revised to include the context's package name as an argument. Therefore, the code change type is 5 (Dependent API changed).","Although there is a change in the dependent API, this does not necessarily result in a Compatibility Issue since the method's behavior remains the same with respect to how it handles the input parameters and the exceptions thrown. The outcome of removeKeyPair is still determined by the underlying service method which is assumed to be able to handle the new parameter correctly. Thus, there is no Compatibility Issue, and the CI type is 0."
574,<android.app.EnterTransitionCoordinator: void forceViewsToAppear()>,25,26,<android.app.EnterTransitionCoordinator: void forceViewsToAppear()>,<android.app.EnterTransitionCoordinator: void forceViewsToAppear()>,0,"{
    if (!mIsReturning) {
        return;
    }
    if (!mIsReadyForTransition) {
        mIsReadyForTransition = true;
        final ViewGroup decor = getDecor();
        if (decor != null && mViewsReadyListener != null) {
            decor.getViewTreeObserver().removeOnPreDrawListener(mViewsReadyListener);
            mViewsReadyListener = null;
        }
        showViews(mTransitioningViews, true);
        setTransitioningViewsVisiblity(View.VISIBLE, true);
        mSharedElements.clear();
        mAllSharedElementNames.clear();
        mTransitioningViews.clear();
        mIsReadyForTransition = true;
        viewsTransitionComplete();
        sharedElementTransitionComplete();
    } else {
        if (!mSharedElementTransitionStarted) {
            moveSharedElementsFromOverlay();
            mSharedElementTransitionStarted = true;
            showViews(mSharedElements, true);
            mSharedElements.clear();
            sharedElementTransitionComplete();
        }
        if (!mIsViewsTransitionStarted) {
            mIsViewsTransitionStarted = true;
            showViews(mTransitioningViews, true);
            setTransitioningViewsVisiblity(View.VISIBLE, true);
            mTransitioningViews.clear();
            viewsTransitionComplete();
        }
        cancelPendingTransitions();
    }
    mAreViewsReady = true;
    if (mResultReceiver != null) {
        mResultReceiver.send(MSG_CANCEL, null);
        mResultReceiver = null;
    }
}","{
    if (!mIsReturning) {
        return;
    }
    if (!mIsReadyForTransition) {
        mIsReadyForTransition = true;
        final ViewGroup decor = getDecor();
        if (decor != null && mViewsReadyListener != null) {
            mViewsReadyListener.removeListener();
            mViewsReadyListener = null;
        }
        showViews(mTransitioningViews, true);
        setTransitioningViewsVisiblity(View.VISIBLE, true);
        mSharedElements.clear();
        mAllSharedElementNames.clear();
        mTransitioningViews.clear();
        mIsReadyForTransition = true;
        viewsTransitionComplete();
        sharedElementTransitionComplete();
    } else {
        if (!mSharedElementTransitionStarted) {
            moveSharedElementsFromOverlay();
            mSharedElementTransitionStarted = true;
            showViews(mSharedElements, true);
            mSharedElements.clear();
            sharedElementTransitionComplete();
        }
        if (!mIsViewsTransitionStarted) {
            mIsViewsTransitionStarted = true;
            showViews(mTransitioningViews, true);
            setTransitioningViewsVisiblity(View.VISIBLE, true);
            mTransitioningViews.clear();
            viewsTransitionComplete();
        }
        cancelPendingTransitions();
    }
    mAreViewsReady = true;
    if (mResultReceiver != null) {
        mResultReceiver.send(MSG_CANCEL, null);
        mResultReceiver = null;
    }
}",1,"/**
 * This is called onResume. If an Activity is resuming and the transitions
 * haven't started yet, force the views to appear. This is likely to be
 * caused by the top Activity finishing before the transitions started.
 * In that case, we can finish any transition that was started, but we
 * should cancel any pending transition and just bring those Views visible.
 */
","/**
 * This is called onResume. If an Activity is resuming and the transitions
 * haven't started yet, force the views to appear. This is likely to be
 * caused by the top Activity finishing before the transitions started.
 * In that case, we can finish any transition that was started, but we
 * should cancel any pending transition and just bring those Views visible.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"In the modified segment, the way the listener is removed has changed from using the `decor.getViewTreeObserver().removeOnPreDrawListener(mViewsReadyListener)` method to `mViewsReadyListener.removeListener()`. This is labelled as ""Other statement changed"" since it is neither a control structure change, a dependent API change, an exception handling change, nor a return statement change.","There is no Compatibility Issue as the modification does not affect the behavior visible to the API's clients directly. Both methods serve the purpose of removing the listener, and hence it is unlikely that there would be any difference in the control flow or the outcome seen by the API's consumers."
576,<android.app.Fragment: Transition getEnterTransition()>,25,26,<android.app.Fragment: Transition getEnterTransition()>,<android.app.Fragment: Transition getEnterTransition()>,0,"{
    return mEnterTransition;
}","{
    if (mAnimationInfo == null) {
        return null;
    }
    return mAnimationInfo.mEnterTransition;
}",1,"/**
 * Returns the Transition that will be used to move Views into the initial scene. The entering
 * Views will be those that are regular Views or ViewGroups that have
 * {@link ViewGroup#isTransitionGroup} return true. Typical Transitions will extend
 * {@link android.transition.Visibility} as entering is governed by changing visibility from
 * {@link View#INVISIBLE} to {@link View#VISIBLE}.
 *
 * @return the Transition to use to move Views into the initial Scene.
 * @attr ref android.R.styleable#Fragment_fragmentEnterTransition
 */
","/**
 * Returns the Transition that will be used to move Views into the initial scene. The entering
 * Views will be those that are regular Views or ViewGroups that have
 * {@link ViewGroup#isTransitionGroup} return true. Typical Transitions will extend
 * {@link android.transition.Visibility} as entering is governed by changing visibility from
 * {@link View#INVISIBLE} to {@link View#VISIBLE}.
 *
 * @return the Transition to use to move Views into the initial Scene.
 * @attr ref android.R.styleable#Fragment_fragmentEnterTransition
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The return statement is now wrapped with an if condition that checks if `mAnimationInfo` is null, and if so, it returns null. Additionally, the return statement now accesses `mEnterTransition` through `mAnimationInfo`. These modifications indicate a change in control flow and access path for the enter transition, so both return statement changed (1) and control dependency changed (3) are applicable.","A Compatibility Issue exists because the early version always returns the value of `mEnterTransition`, but the late version may return null if `mAnimationInfo` is null. This indicates a potential difference in return values between the two versions, therefore, the CI type is 1."
578,<android.net.LocalSocketImpl: void create(int)>,25,26,<android.net.LocalSocketImpl: void create(int)>,<android.net.LocalSocketImpl: void create(int)>,0,"{
    // need this for LocalServerSocket.accept()
    if (fd == null) {
        int osType;
        switch(sockType) {
            case LocalSocket.SOCKET_DGRAM:
                osType = OsConstants.SOCK_DGRAM;
                break;
            case LocalSocket.SOCKET_STREAM:
                osType = OsConstants.SOCK_STREAM;
                break;
            case LocalSocket.SOCKET_SEQPACKET:
                osType = OsConstants.SOCK_SEQPACKET;
                break;
            default:
                throw new IllegalStateException(""unknown sockType"");
        }
        try {
            fd = Os.socket(OsConstants.AF_UNIX, osType, 0);
            mFdCreatedInternally = true;
        } catch (ErrnoException e) {
            e.rethrowAsIOException();
        }
    }
}","{
    if (fd != null) {
        throw new IOException(""LocalSocketImpl already has an fd"");
    }
    int osType;
    switch(sockType) {
        case LocalSocket.SOCKET_DGRAM:
            osType = OsConstants.SOCK_DGRAM;
            break;
        case LocalSocket.SOCKET_STREAM:
            osType = OsConstants.SOCK_STREAM;
            break;
        case LocalSocket.SOCKET_SEQPACKET:
            osType = OsConstants.SOCK_SEQPACKET;
            break;
        default:
            throw new IllegalStateException(""unknown sockType"");
    }
    try {
        fd = Os.socket(OsConstants.AF_UNIX, osType, 0);
        mFdCreatedInternally = true;
    } catch (ErrnoException e) {
        e.rethrowAsIOException();
    }
}",1,"/**
 * Creates a socket in the underlying OS.
 *
 * @param sockType either {@link LocalSocket#SOCKET_DGRAM}, {@link LocalSocket#SOCKET_STREAM}
 * or {@link LocalSocket#SOCKET_SEQPACKET}
 * @throws IOException
 */
","/**
 * Creates a socket in the underlying OS.
 *
 * @param sockType either {@link LocalSocket#SOCKET_DGRAM}, {@link LocalSocket#SOCKET_STREAM}
 * or {@link LocalSocket#SOCKET_SEQPACKET}
 * @throws IOException
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4","1,2","The code change includes modification to the if condition check (from if (fd == null) { ... } to if (fd != null) { ... }) and the addition of a new exception handling statement (throw new IOException(""LocalSocketImpl already has an fd"");), so the change type is 3,4.","Due to the inversion of the condition, the API will now throw an IOException where it previously would not have if the file descriptor (fd) was not null. This modification in the control dependency and the addition of the new exception handling statement could lead to a different behavior when the method is invoked—either by not creating a new file descriptor when one already exists or by throwing a new IOException. Therefore, the CI type is 1,2."
580,<android.hardware.SensorManager: Sensor getDefaultSensor(int)>,25,26,<android.hardware.SensorManager: Sensor getDefaultSensor(int)>,<android.hardware.SensorManager: Sensor getDefaultSensor(int)>,0,"{
    // TODO: need to be smarter, for now, just return the 1st sensor
    List<Sensor> l = getSensorList(type);
    boolean wakeUpSensor = false;
    // non_wake-up version.
    if (type == Sensor.TYPE_PROXIMITY || type == Sensor.TYPE_SIGNIFICANT_MOTION || type == Sensor.TYPE_TILT_DETECTOR || type == Sensor.TYPE_WAKE_GESTURE || type == Sensor.TYPE_GLANCE_GESTURE || type == Sensor.TYPE_PICK_UP_GESTURE || type == Sensor.TYPE_WRIST_TILT_GESTURE) {
        wakeUpSensor = true;
    }
    for (Sensor sensor : l) {
        if (sensor.isWakeUpSensor() == wakeUpSensor)
            return sensor;
    }
    return null;
}","{
    // TODO: need to be smarter, for now, just return the 1st sensor
    List<Sensor> l = getSensorList(type);
    boolean wakeUpSensor = false;
    // non_wake-up version.
    if (type == Sensor.TYPE_PROXIMITY || type == Sensor.TYPE_SIGNIFICANT_MOTION || type == Sensor.TYPE_TILT_DETECTOR || type == Sensor.TYPE_WAKE_GESTURE || type == Sensor.TYPE_GLANCE_GESTURE || type == Sensor.TYPE_PICK_UP_GESTURE || type == Sensor.TYPE_WRIST_TILT_GESTURE || type == Sensor.TYPE_DYNAMIC_SENSOR_META) {
        wakeUpSensor = true;
    }
    for (Sensor sensor : l) {
        if (sensor.isWakeUpSensor() == wakeUpSensor)
            return sensor;
    }
    return null;
}",1,"/**
 * Use this method to get the default sensor for a given type. Note that the
 * returned sensor could be a composite sensor, and its data could be
 * averaged or filtered. If you need to access the raw sensors use
 * {@link SensorManager#getSensorList(int) getSensorList}.
 *
 * @param type
 * of sensors requested
 *
 * @return the default sensor matching the requested type if one exists and the application
 * has the necessary permissions, or null otherwise.
 *
 * @see #getSensorList(int)
 * @see Sensor
 */
","/**
 * Use this method to get the default sensor for a given type. Note that the
 * returned sensor could be a composite sensor, and its data could be
 * averaged or filtered. If you need to access the raw sensors use
 * {@link SensorManager#getSensorList(int) getSensorList}.
 *
 * @param type
 * of sensors requested
 *
 * @return the default sensor matching the requested type if one exists and the application
 * has the necessary permissions, or null otherwise.
 *
 * @see #getSensorList(int)
 * @see Sensor
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,5",0,"The condition in the `if` statement has changed by adding an extra condition, `'type == Sensor.TYPE_DYNAMIC_SENSOR_META'`, so the code change type is 3 (Control dependency changed). Furthermore, there is a change in the dependent API; the list of sensor types checked in the condition has been extended, although no direct API method change is visible, the change suggests an update in the constants defined in Sensor class, which could affect the return value of this method, so the code change type is also 5 (Dependent API changed).","Even though a new sensor type has been added to the list of wake-up sensors, this does not necessarily lead to a compatibility issue since the same flow (matching of sensor types and returning the sensor) is preserved; thus, all previous behaviors are maintained alongside the added functionality. Therefore, the CI type is 0 (No Compatibility Issue)."
583,<android.text.BidiFormatter.DirectionalityEstimator: byte dirTypeForward()>,25,26,<android.text.BidiFormatter.DirectionalityEstimator: byte dirTypeForward()>,<android.text.BidiFormatter.DirectionalityEstimator: byte dirTypeForward()>,0,"{
    lastChar = text.charAt(charIndex);
    if (Character.isHighSurrogate(lastChar)) {
        int codePoint = Character.codePointAt(text, charIndex);
        charIndex += Character.charCount(codePoint);
        return Character.getDirectionality(codePoint);
    }
    charIndex++;
    byte dirType = getCachedDirectionality(lastChar);
    if (isHtml) {
        // Process tags and entities.
        if (lastChar == '<') {
            dirType = skipTagForward();
        } else if (lastChar == '&') {
            dirType = skipEntityForward();
        }
    }
    return dirType;
}","{
    lastChar = text.charAt(charIndex);
    if (Character.isHighSurrogate(lastChar)) {
        int codePoint = Character.codePointAt(text, charIndex);
        charIndex += Character.charCount(codePoint);
        return getDirectionality(codePoint);
    }
    charIndex++;
    byte dirType = getCachedDirectionality(lastChar);
    if (isHtml) {
        // Process tags and entities.
        if (lastChar == '<') {
            dirType = skipTagForward();
        } else if (lastChar == '&') {
            dirType = skipEntityForward();
        }
    }
    return dirType;
}",1,"/**
 * Returns the Character.DIRECTIONALITY_... value of the next codepoint and advances
 * charIndex. If isHtml, and the codepoint is '<' or '&', advances through the tag/entity,
 * and returns Character.DIRECTIONALITY_WHITESPACE. For an entity, it would be best to
 * figure out the actual character, and return its dirtype, but treating it as whitespace is
 * good enough for our purposes.
 *
 * @throws java.lang.IndexOutOfBoundsException if called when charIndex >= length or < 0.
 */
","/**
 * Returns the Character.DIRECTIONALITY_... value of the next codepoint and advances
 * charIndex. If isHtml, and the codepoint is '<' or '&', advances through the tag/entity,
 * and returns Character.DIRECTIONALITY_WHITESPACE. For an entity, it would be best to
 * figure out the actual character, and return its dirtype, but treating it as whitespace is
 * good enough for our purposes.
 *
 * @throws java.lang.IndexOutOfBoundsException if called when charIndex >= length or < 0.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"There is only a substitution of the method call ""Character.getDirectionality(codePoint)"" with a local method ""getDirectionality(codePoint)"". Since this change does not affect the control flow or logic of the method and the type of the return value does not change, the change is considered to be of type 4 (Other statement changed).","Since the replacement of ""Character.getDirectionality(codePoint)"" with ""getDirectionality(codePoint)"" is likely an internal refactoring that shouldn't affect the method's behavior from an API user's perspective, no compatibility issues would arise strictly from this change, assuming the internal implementation of ""getDirectionality(codePoint)"" is equivalent to ""Character.getDirectionality(codePoint)"". Therefore, there is no CI (0)."
586,<android.app.Fragment: void performDestroyView()>,25,26,<android.app.Fragment: void performDestroyView()>,<android.app.Fragment: void performDestroyView()>,0,"{
    if (mChildFragmentManager != null) {
        mChildFragmentManager.dispatchDestroyView();
    }
    mState = CREATED;
    mCalled = false;
    onDestroyView();
    if (!mCalled) {
        throw new SuperNotCalledException(""Fragment "" + this + "" did not call through to super.onDestroyView()"");
    }
    if (mLoaderManager != null) {
        mLoaderManager.doReportNextStart();
    }
}","{
    if (mChildFragmentManager != null) {
        mChildFragmentManager.dispatchDestroyView();
    }
    mState = CREATED;
    mCalled = false;
    onDestroyView();
    if (!mCalled) {
        throw new SuperNotCalledException(""Fragment "" + this + "" did not call through to super.onDestroyView()"");
    }
    if (mLoaderManager != null) {
        mLoaderManager.doReportNextStart();
    }
    mPerformedCreateView = false;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The addition of the statement `mPerformedCreateView = false;` at the end of the method doesn't affect the existing control flow or exception handling, so the code change type is 4.","There is no Compatibility Issue since the new statement added at the end of the method does not alter the method's behavior in terms of the exceptions thrown or the return values (since the method is void, it has no return)."
587,"<android.app.Activity: void setVrModeEnabled(boolean,ComponentName)>",25,26,"<android.app.Activity: void setVrModeEnabled(boolean,ComponentName)>","<android.app.Activity: void setVrModeEnabled(boolean,ComponentName)>",0,"{
    try {
        if (ActivityManagerNative.getDefault().setVrMode(mToken, enabled, requestedComponent) != 0) {
            throw new PackageManager.NameNotFoundException(requestedComponent.flattenToString());
        }
    } catch (RemoteException e) {
    // pass
    }
}","{
    try {
        if (ActivityManager.getService().setVrMode(mToken, enabled, requestedComponent) != 0) {
            throw new PackageManager.NameNotFoundException(requestedComponent.flattenToString());
        }
    } catch (RemoteException e) {
    // pass
    }
}",1,"/**
 * Enable or disable virtual reality (VR) mode for this Activity.
 *
 * <p>VR mode is a hint to Android system to switch to a mode optimized for VR applications
 * while this Activity has user focus.</p>
 *
 * <p>It is recommended that applications additionally declare
 * {@link android.R.attr#enableVrMode} in their manifest to allow for smooth activity
 * transitions when switching between VR activities.</p>
 *
 * <p>If the requested {@link android.service.vr.VrListenerService} component is not available,
 * VR mode will not be started.  Developers can handle this case as follows:</p>
 *
 * <pre>
 * String servicePackage = ""com.whatever.app"";
 * String serviceClass = ""com.whatever.app.MyVrListenerService"";
 *
 * // Name of the component of the VrListenerService to start.
 * ComponentName serviceComponent = new ComponentName(servicePackage, serviceClass);
 *
 * try {
 * setVrModeEnabled(true, myComponentName);
 * } catch (PackageManager.NameNotFoundException e) {
 * List&lt;ApplicationInfo> installed = getPackageManager().getInstalledApplications(0);
 * boolean isInstalled = false;
 * for (ApplicationInfo app : installed) {
 * if (app.packageName.equals(servicePackage)) {
 * isInstalled = true;
 * break;
 * }
 * }
 * if (isInstalled) {
 * // Package is installed, but not enabled in Settings.  Let user enable it.
 * startActivity(new Intent(Settings.ACTION_VR_LISTENER_SETTINGS));
 * } else {
 * // Package is not installed.  Send an intent to download this.
 * sentIntentToLaunchAppStore(servicePackage);
 * }
 * }
 * </pre>
 *
 * @param enabled {@code true} to enable this mode.
 * @param requestedComponent the name of the component to use as a
 * {@link android.service.vr.VrListenerService} while VR mode is enabled.
 *
 * @throws android.content.pm.PackageManager.NameNotFoundException if the given component
 * to run as a {@link android.service.vr.VrListenerService} is not installed, or has
 * not been enabled in user settings.
 *
 * @see android.content.pm.PackageManager#FEATURE_VR_MODE
 * @see android.content.pm.PackageManager#FEATURE_VR_MODE_HIGH_PERFORMANCE
 * @see android.service.vr.VrListenerService
 * @see android.provider.Settings#ACTION_VR_LISTENER_SETTINGS
 * @see android.R.attr#enableVrMode
 */
","/**
 * Enable or disable virtual reality (VR) mode for this Activity.
 *
 * <p>VR mode is a hint to Android system to switch to a mode optimized for VR applications
 * while this Activity has user focus.</p>
 *
 * <p>It is recommended that applications additionally declare
 * {@link android.R.attr#enableVrMode} in their manifest to allow for smooth activity
 * transitions when switching between VR activities.</p>
 *
 * <p>If the requested {@link android.service.vr.VrListenerService} component is not available,
 * VR mode will not be started.  Developers can handle this case as follows:</p>
 *
 * <pre>
 * String servicePackage = ""com.whatever.app"";
 * String serviceClass = ""com.whatever.app.MyVrListenerService"";
 *
 * // Name of the component of the VrListenerService to start.
 * ComponentName serviceComponent = new ComponentName(servicePackage, serviceClass);
 *
 * try {
 * setVrModeEnabled(true, myComponentName);
 * } catch (PackageManager.NameNotFoundException e) {
 * List&lt;ApplicationInfo> installed = getPackageManager().getInstalledApplications(0);
 * boolean isInstalled = false;
 * for (ApplicationInfo app : installed) {
 * if (app.packageName.equals(servicePackage)) {
 * isInstalled = true;
 * break;
 * }
 * }
 * if (isInstalled) {
 * // Package is installed, but not enabled in Settings.  Let user enable it.
 * startActivity(new Intent(Settings.ACTION_VR_LISTENER_SETTINGS));
 * } else {
 * // Package is not installed.  Send an intent to download this.
 * sentIntentToLaunchAppStore(servicePackage);
 * }
 * }
 * </pre>
 *
 * @param enabled {@code true} to enable this mode.
 * @param requestedComponent the name of the component to use as a
 * {@link android.service.vr.VrListenerService} while VR mode is enabled.
 *
 * @throws android.content.pm.PackageManager.NameNotFoundException if the given component
 * to run as a {@link android.service.vr.VrListenerService} is not installed, or has
 * not been enabled in user settings.
 *
 * @see android.content.pm.PackageManager#FEATURE_VR_MODE
 * @see android.content.pm.PackageManager#FEATURE_VR_MODE_HIGH_PERFORMANCE
 * @see android.service.vr.VrListenerService
 * @see android.provider.Settings#ACTION_VR_LISTENER_SETTINGS
 * @see android.R.attr#enableVrMode
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The code changes from calling ActivityManagerNative.getDefault().setVrMode() to ActivityManager.getService().setVrMode() which indicates the use of a different method from the ActivityManager class to set the VR mode. This is a change in the dependent API being called, which leads to a code change type 5.","There is no compatibility issue in terms of the return value or exception handling. The method signatures of getDefault() and getService() suggest they may serve the same purpose of obtaining a handle to the service, so this change is likely to be an internal refactoring that does not affect the external behavior of the setVrModeEnabled method. The if condition and exception throwing remain the same, evidencing that the flow of the method should behave as before. Thus, there is no compatibility issue, which makes the CI type 0."
589,<android.content.res.Configuration: int hashCode()>,25,26,<android.content.res.Configuration: int hashCode()>,<android.content.res.Configuration: int hashCode()>,0,"{
    int result = 17;
    result = 31 * result + Float.floatToIntBits(fontScale);
    result = 31 * result + mcc;
    result = 31 * result + mnc;
    result = 31 * result + mLocaleList.hashCode();
    result = 31 * result + touchscreen;
    result = 31 * result + keyboard;
    result = 31 * result + keyboardHidden;
    result = 31 * result + hardKeyboardHidden;
    result = 31 * result + navigation;
    result = 31 * result + navigationHidden;
    result = 31 * result + orientation;
    result = 31 * result + screenLayout;
    result = 31 * result + uiMode;
    result = 31 * result + screenWidthDp;
    result = 31 * result + screenHeightDp;
    result = 31 * result + smallestScreenWidthDp;
    result = 31 * result + densityDpi;
    return result;
}","{
    int result = 17;
    result = 31 * result + Float.floatToIntBits(fontScale);
    result = 31 * result + mcc;
    result = 31 * result + mnc;
    result = 31 * result + mLocaleList.hashCode();
    result = 31 * result + touchscreen;
    result = 31 * result + keyboard;
    result = 31 * result + keyboardHidden;
    result = 31 * result + hardKeyboardHidden;
    result = 31 * result + navigation;
    result = 31 * result + navigationHidden;
    result = 31 * result + orientation;
    result = 31 * result + screenLayout;
    result = 31 * result + colorMode;
    result = 31 * result + uiMode;
    result = 31 * result + screenWidthDp;
    result = 31 * result + screenHeightDp;
    result = 31 * result + smallestScreenWidthDp;
    result = 31 * result + densityDpi;
    result = 31 * result + assetsSeq;
    return result;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"Lines of code have been altered where `colorMode` and `assetsSeq` are being included in the hash code calculation. This is both an addition of other statements and a change in the return value, making the change types 1 and 4.","The change in the hash code calculation can lead to different return values from the `hashCode()` method. Therefore, this is a compatibility issue caused by potential different return values, making the CI type 1."
591,<android.os.storage.StorageManager: String getMountedObbPath(String)>,25,26,<android.os.storage.StorageManager: String getMountedObbPath(String)>,<android.os.storage.StorageManager: String getMountedObbPath(String)>,0,"{
    Preconditions.checkNotNull(rawPath, ""rawPath cannot be null"");
    try {
        return mMountService.getMountedObbPath(rawPath);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    Preconditions.checkNotNull(rawPath, ""rawPath cannot be null"");
    try {
        return mStorageManager.getMountedObbPath(rawPath);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Check the mounted path of an Opaque Binary Blob (OBB) file. This will
 * give you the path to where you can obtain access to the internals of the
 * OBB.
 *
 * @param rawPath path to OBB image
 * @return absolute path to mounted OBB image data or <code>null</code> if
 * not mounted or exception encountered trying to read status
 */
","/**
 * Check the mounted path of an Opaque Binary Blob (OBB) file. This will
 * give you the path to where you can obtain access to the internals of the
 * OBB.
 *
 * @param rawPath path to OBB image
 * @return absolute path to mounted OBB image data or <code>null</code> if
 * not mounted or exception encountered trying to read status
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The only change is from calling 'mMountService.getMountedObbPath(rawPath)' in the early implementation to 'mStorageManager.getMountedObbPath(rawPath)' in the late implementation, indicating the method is now being called on a different object. This is a dependent API change, so the code change type is 5.","There is no Compatibility Issue since the method name and signature remain the same, and the exception handling has not changed. The potential behaviour of the method should still be consistent despite the change in the object on which the method is called. Hence, there's no reason to expect a different return value or different exception handling, so the CI type is 0."
592,<android.app.ActivityManager: List<RunningServiceInfo> getRunningServices(int)>,25,26,<android.app.ActivityManager: List<RunningServiceInfo> getRunningServices(int)>,<android.app.ActivityManager: List<RunningServiceInfo> getRunningServices(int)>,0,"{
    try {
        return ActivityManagerNative.getDefault().getServices(maxNum, 0);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        return getService().getServices(maxNum, 0);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Return a list of the services that are currently running.
 *
 * <p><b>Note: this method is only intended for debugging or implementing
 * service management type user interfaces.</b></p>
 *
 * @param maxNum The maximum number of entries to return in the list.  The
 * actual number returned may be smaller, depending on how many services
 * are running.
 *
 * @return Returns a list of RunningServiceInfo records describing each of
 * the running tasks.
 */
","/**
 * Return a list of the services that are currently running.
 *
 * <p><b>Note: this method is only intended for debugging or implementing
 * service management type user interfaces.</b></p>
 *
 * @deprecated As of {@link android.os.Build.VERSION_CODES#O}, this method
 * is no longer available to third party applications.  For backwards compatibility,
 * it will still return the caller's own services.
 *
 * @param maxNum The maximum number of entries to return in the list.  The
 * actual number returned may be smaller, depending on how many services
 * are running.
 *
 * @return Returns a list of RunningServiceInfo records describing each of
 * the running tasks.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"4,5",0,"The way the service is retrieved has changed from ActivityManagerNative.getDefault() to getService(), but the subsequent method call getServices(maxNum, 0) remains the same. There is also a Dependent API change because the mechanism for obtaining the service object has been altered. The code change type is 4,5.","Even though there's a change in how the service is retrieved, the method getServices(maxNum, 0) is called in the same way. As long as getService() is expected to behave the same way as ActivityManagerNative.getDefault() in terms of providing a service that offers the getServices method with the same signature, there should be no Compatibility Issue, so the CI type is 0."
594,<android.animation.PropertyValuesHolder: void setupSetterAndGetter(Object)>,25,26,<android.animation.PropertyValuesHolder: void setupSetterAndGetter(Object)>,<android.animation.PropertyValuesHolder: void setupSetterAndGetter(Object)>,0,"{
    mKeyframes.invalidateCache();
    if (mProperty != null) {
        // check to make sure that mProperty is on the class of target
        try {
            Object testValue = null;
            List<Keyframe> keyframes = mKeyframes.getKeyframes();
            int keyframeCount = keyframes == null ? 0 : keyframes.size();
            for (int i = 0; i < keyframeCount; i++) {
                Keyframe kf = keyframes.get(i);
                if (!kf.hasValue() || kf.valueWasSetOnStart()) {
                    if (testValue == null) {
                        testValue = convertBack(mProperty.get(target));
                    }
                    kf.setValue(testValue);
                    kf.setValueWasSetOnStart(true);
                }
            }
            return;
        } catch (ClassCastException e) {
            Log.w(""PropertyValuesHolder"", ""No such property ("" + mProperty.getName() + "") on target object "" + target + "". Trying reflection instead"");
            mProperty = null;
        }
    }
    // We can't just say 'else' here because the catch statement sets mProperty to null.
    if (mProperty == null) {
        Class targetClass = target.getClass();
        if (mSetter == null) {
            setupSetter(targetClass);
        }
        List<Keyframe> keyframes = mKeyframes.getKeyframes();
        int keyframeCount = keyframes == null ? 0 : keyframes.size();
        for (int i = 0; i < keyframeCount; i++) {
            Keyframe kf = keyframes.get(i);
            if (!kf.hasValue() || kf.valueWasSetOnStart()) {
                if (mGetter == null) {
                    setupGetter(targetClass);
                    if (mGetter == null) {
                        // Already logged the error - just return to avoid NPE
                        return;
                    }
                }
                try {
                    Object value = convertBack(mGetter.invoke(target));
                    kf.setValue(value);
                    kf.setValueWasSetOnStart(true);
                } catch (InvocationTargetException e) {
                    Log.e(""PropertyValuesHolder"", e.toString());
                } catch (IllegalAccessException e) {
                    Log.e(""PropertyValuesHolder"", e.toString());
                }
            }
        }
    }
}","{
    if (mProperty != null) {
        // check to make sure that mProperty is on the class of target
        try {
            Object testValue = null;
            List<Keyframe> keyframes = mKeyframes.getKeyframes();
            int keyframeCount = keyframes == null ? 0 : keyframes.size();
            for (int i = 0; i < keyframeCount; i++) {
                Keyframe kf = keyframes.get(i);
                if (!kf.hasValue() || kf.valueWasSetOnStart()) {
                    if (testValue == null) {
                        testValue = convertBack(mProperty.get(target));
                    }
                    kf.setValue(testValue);
                    kf.setValueWasSetOnStart(true);
                }
            }
            return;
        } catch (ClassCastException e) {
            Log.w(""PropertyValuesHolder"", ""No such property ("" + mProperty.getName() + "") on target object "" + target + "". Trying reflection instead"");
            mProperty = null;
        }
    }
    // We can't just say 'else' here because the catch statement sets mProperty to null.
    if (mProperty == null) {
        Class targetClass = target.getClass();
        if (mSetter == null) {
            setupSetter(targetClass);
        }
        List<Keyframe> keyframes = mKeyframes.getKeyframes();
        int keyframeCount = keyframes == null ? 0 : keyframes.size();
        for (int i = 0; i < keyframeCount; i++) {
            Keyframe kf = keyframes.get(i);
            if (!kf.hasValue() || kf.valueWasSetOnStart()) {
                if (mGetter == null) {
                    setupGetter(targetClass);
                    if (mGetter == null) {
                        // Already logged the error - just return to avoid NPE
                        return;
                    }
                }
                try {
                    Object value = convertBack(mGetter.invoke(target));
                    kf.setValue(value);
                    kf.setValueWasSetOnStart(true);
                } catch (InvocationTargetException e) {
                    Log.e(""PropertyValuesHolder"", e.toString());
                } catch (IllegalAccessException e) {
                    Log.e(""PropertyValuesHolder"", e.toString());
                }
            }
        }
    }
}",1,"/**
 * Internal function (called from ObjectAnimator) to set up the setter and getter
 * prior to running the animation. If the setter has not been manually set for this
 * object, it will be derived automatically given the property name, target object, and
 * types of values supplied. If no getter has been set, it will be supplied iff any of the
 * supplied values was null. If there is a null value, then the getter (supplied or derived)
 * will be called to set those null values to the current value of the property
 * on the target object.
 * @param target The object on which the setter (and possibly getter) exist.
 */
","/**
 * Internal function (called from ObjectAnimator) to set up the setter and getter
 * prior to running the animation. If the setter has not been manually set for this
 * object, it will be derived automatically given the property name, target object, and
 * types of values supplied. If no getter has been set, it will be supplied iff any of the
 * supplied values was null. If there is a null value, then the getter (supplied or derived)
 * will be called to set those null values to the current value of the property
 * on the target object.
 * @param target The object on which the setter (and possibly getter) exist.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"There are no differences in the early and late implementations of the code; thus, there is no code change.","Since there is no change in the implementation between the two versions, there is no compatibility issue."
595,"<android.content.pm.LauncherApps: LauncherActivityInfo resolveActivity(Intent,UserHandle)>",25,26,"<android.content.pm.LauncherApps: LauncherActivityInfo resolveActivity(Intent,UserHandle)>","<android.content.pm.LauncherApps: LauncherActivityInfo resolveActivity(Intent,UserHandle)>",0,"{
    try {
        ActivityInfo ai = mService.resolveActivity(intent.getComponent(), user);
        if (ai != null) {
            LauncherActivityInfo info = new LauncherActivityInfo(mContext, ai, user);
            return info;
        }
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
    return null;
}","{
    logErrorForInvalidProfileAccess(user);
    try {
        ActivityInfo ai = mService.resolveActivity(mContext.getPackageName(), intent.getComponent(), user);
        if (ai != null) {
            LauncherActivityInfo info = new LauncherActivityInfo(mContext, ai, user);
            return info;
        }
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
    return null;
}",1,"/**
 * Returns the activity info for a given intent and user handle, if it resolves. Otherwise it
 * returns null.
 *
 * @param intent The intent to find a match for.
 * @param user The profile to look in for a match.
 * @return An activity info object if there is a match.
 */
","/**
 * Returns the activity info for a given intent and user handle, if it resolves. Otherwise it
 * returns null.
 *
 * @param intent The intent to find a match for.
 * @param user The profile to look in for a match.
 * @return An activity info object if there is a match.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The dependent API `mService.resolveActivity` has an extra parameter added (`mContext.getPackageName()`) in the late version, a new method `logErrorForInvalidProfileAccess` is introduced before the try block and it is not present in the early version, which is an 'Other statement changed.' These qualify as the code change types 1, 4, and 5.","The introduction of a new call to `logErrorForInvalidProfileAccess` and the change in the signature of the dependent API `resolveActivity` could lead to different behavior of the API if the new method interacts with the state used in the API or checks for certain conditions before proceeding with the existing logic. Additionally, the inclusion of the package name in the `resolveActivity` call could lead to different `ActivityInfo` being returned, especially if there are multiple applications handling the same intent. Hence, there is a potential for a CI caused by potentially different return values, making the CI type 1."
596,<android.app.PendingIntent: UserHandle getCreatorUserHandle()>,25,26,<android.app.PendingIntent: UserHandle getCreatorUserHandle()>,<android.app.PendingIntent: UserHandle getCreatorUserHandle()>,0,"{
    try {
        int uid = ActivityManagerNative.getDefault().getUidForIntentSender(mTarget);
        return uid > 0 ? new UserHandle(UserHandle.getUserId(uid)) : null;
    } catch (RemoteException e) {
        // Should never happen.
        return null;
    }
}","{
    try {
        int uid = ActivityManager.getService().getUidForIntentSender(mTarget);
        return uid > 0 ? new UserHandle(UserHandle.getUserId(uid)) : null;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Return the user handle of the application that created this
 * PendingIntent, that is the user under which you will actually be
 * sending the Intent.  The returned UserHandle is supplied by the system, so
 * that an application can not spoof its user.  See
 * {@link android.os.Process#myUserHandle() Process.myUserHandle()} for
 * more explanation of user handles.
 *
 * <p class=""note"">Be careful about how you use this.  All this tells you is
 * who created the PendingIntent.  It does <strong>not</strong> tell you who
 * handed the PendingIntent to you: that is, PendingIntent objects are intended to be
 * passed between applications, so the PendingIntent you receive from an application
 * could actually be one it received from another application, meaning the result
 * you get here will identify the original application.  Because of this, you should
 * only use this information to identify who you expect to be interacting with
 * through a {@link #send} call, not who gave you the PendingIntent.</p>
 *
 * @return The user handle of the PendingIntent, or null if there is
 * none associated with it.
 */
","/**
 * Return the user handle of the application that created this
 * PendingIntent, that is the user under which you will actually be
 * sending the Intent.  The returned UserHandle is supplied by the system, so
 * that an application can not spoof its user.  See
 * {@link android.os.Process#myUserHandle() Process.myUserHandle()} for
 * more explanation of user handles.
 *
 * <p class=""note"">Be careful about how you use this.  All this tells you is
 * who created the PendingIntent.  It does <strong>not</strong> tell you who
 * handed the PendingIntent to you: that is, PendingIntent objects are intended to be
 * passed between applications, so the PendingIntent you receive from an application
 * could actually be one it received from another application, meaning the result
 * you get here will identify the original application.  Because of this, you should
 * only use this information to identify who you expect to be interacting with
 * through a {@link #send} call, not who gave you the PendingIntent.</p>
 *
 * @return The user handle of the PendingIntent, or null if there is
 * none associated with it.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,"2,5",2,There are two changes observed:,
597,<android.hardware.camera2.legacy.SurfaceTextureRenderer: void drawIntoSurfaces(CaptureCollector)>,25,26,<android.hardware.camera2.legacy.SurfaceTextureRenderer: void drawIntoSurfaces(CaptureCollector)>,<android.hardware.camera2.legacy.SurfaceTextureRenderer: void drawIntoSurfaces(CaptureCollector)>,0,"{
    if ((mSurfaces == null || mSurfaces.size() == 0) && (mConversionSurfaces == null || mConversionSurfaces.size() == 0)) {
        return;
    }
    boolean doTiming = targetCollector.hasPendingPreviewCaptures();
    checkGlError(""before updateTexImage"");
    if (doTiming) {
        beginGlTiming();
    }
    mSurfaceTexture.updateTexImage();
    long timestamp = mSurfaceTexture.getTimestamp();
    Pair<RequestHolder, Long> captureHolder = targetCollector.previewCaptured(timestamp);
    // No preview request queued, drop frame.
    if (captureHolder == null) {
        if (DEBUG) {
            Log.d(TAG, ""Dropping preview frame."");
        }
        if (doTiming) {
            endGlTiming();
        }
        return;
    }
    RequestHolder request = captureHolder.first;
    Collection<Surface> targetSurfaces = request.getHolderTargets();
    if (doTiming) {
        addGlTimestamp(timestamp);
    }
    List<Long> targetSurfaceIds = new ArrayList();
    try {
        targetSurfaceIds = LegacyCameraDevice.getSurfaceIds(targetSurfaces);
    } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
        Log.w(TAG, ""Surface abandoned, dropping frame. "", e);
        request.setOutputAbandoned();
    }
    for (EGLSurfaceHolder holder : mSurfaces) {
        if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)) {
            try {
                LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height);
                makeCurrent(holder.eglSurface);
                LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second);
                drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing == CameraCharacteristics.LENS_FACING_FRONT) ? FLIP_TYPE_HORIZONTAL : FLIP_TYPE_NONE);
                swapBuffers(holder.eglSurface);
            } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
                Log.w(TAG, ""Surface abandoned, dropping frame. "", e);
                request.setOutputAbandoned();
            }
        }
    }
    for (EGLSurfaceHolder holder : mConversionSurfaces) {
        if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)) {
            makeCurrent(holder.eglSurface);
            // glReadPixels reads from the bottom of the buffer, so add an extra vertical flip
            drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing == CameraCharacteristics.LENS_FACING_FRONT) ? FLIP_TYPE_BOTH : FLIP_TYPE_VERTICAL);
            mPBufferPixels.clear();
            GLES20.glReadPixels(/*x*/
            0, /*y*/
            0, holder.width, holder.height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, mPBufferPixels);
            checkGlError(""glReadPixels"");
            try {
                int format = LegacyCameraDevice.detectSurfaceType(holder.surface);
                LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height);
                LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second);
                LegacyCameraDevice.produceFrame(holder.surface, mPBufferPixels.array(), holder.width, holder.height, format);
            } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
                Log.w(TAG, ""Surface abandoned, dropping frame. "", e);
                request.setOutputAbandoned();
            }
        }
    }
    targetCollector.previewProduced();
    if (doTiming) {
        endGlTiming();
    }
}","{
    if ((mSurfaces == null || mSurfaces.size() == 0) && (mConversionSurfaces == null || mConversionSurfaces.size() == 0)) {
        return;
    }
    boolean doTiming = targetCollector.hasPendingPreviewCaptures();
    checkGlError(""before updateTexImage"");
    if (doTiming) {
        beginGlTiming();
    }
    mSurfaceTexture.updateTexImage();
    long timestamp = mSurfaceTexture.getTimestamp();
    Pair<RequestHolder, Long> captureHolder = targetCollector.previewCaptured(timestamp);
    // No preview request queued, drop frame.
    if (captureHolder == null) {
        if (DEBUG) {
            Log.d(TAG, ""Dropping preview frame."");
        }
        if (doTiming) {
            endGlTiming();
        }
        return;
    }
    RequestHolder request = captureHolder.first;
    Collection<Surface> targetSurfaces = request.getHolderTargets();
    if (doTiming) {
        addGlTimestamp(timestamp);
    }
    List<Long> targetSurfaceIds = new ArrayList();
    try {
        targetSurfaceIds = LegacyCameraDevice.getSurfaceIds(targetSurfaces);
    } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
        Log.w(TAG, ""Surface abandoned, dropping frame. "", e);
        request.setOutputAbandoned();
    }
    for (EGLSurfaceHolder holder : mSurfaces) {
        if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)) {
            try {
                LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height);
                makeCurrent(holder.eglSurface);
                LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second);
                drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing == CameraCharacteristics.LENS_FACING_FRONT) ? FLIP_TYPE_HORIZONTAL : FLIP_TYPE_NONE);
                swapBuffers(holder.eglSurface);
            } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
                Log.w(TAG, ""Surface abandoned, dropping frame. "", e);
                request.setOutputAbandoned();
            }
        }
    }
    for (EGLSurfaceHolder holder : mConversionSurfaces) {
        if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)) {
            makeCurrent(holder.eglSurface);
            // glReadPixels reads from the bottom of the buffer, so add an extra vertical flip
            try {
                drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing == CameraCharacteristics.LENS_FACING_FRONT) ? FLIP_TYPE_BOTH : FLIP_TYPE_VERTICAL);
            } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
                // Should never hit this.
                throw new IllegalStateException(""Surface abandoned, skipping drawFrame..."", e);
            }
            mPBufferPixels.clear();
            GLES20.glReadPixels(/*x*/
            0, /*y*/
            0, holder.width, holder.height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, mPBufferPixels);
            checkGlError(""glReadPixels"");
            try {
                int format = LegacyCameraDevice.detectSurfaceType(holder.surface);
                LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height);
                LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second);
                LegacyCameraDevice.produceFrame(holder.surface, mPBufferPixels.array(), holder.width, holder.height, format);
            } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
                Log.w(TAG, ""Surface abandoned, dropping frame. "", e);
                request.setOutputAbandoned();
            }
        }
    }
    targetCollector.previewProduced();
    if (doTiming) {
        endGlTiming();
    }
}",1,"/**
 * Draw the current buffer in the {@link SurfaceTexture} returned from
 * {@link #getSurfaceTexture()} into the set of target {@link Surface}s
 * in the next request from the given {@link CaptureCollector}, or drop
 * the frame if none is available.
 *
 * <p>
 * Any {@link Surface}s targeted must be a subset of the {@link Surface}s
 * set in the last {@link #configureSurfaces(java.util.Collection)} call.
 * </p>
 *
 * @param targetCollector the surfaces to draw to.
 */
","/**
 * Draw the current buffer in the {@link SurfaceTexture} returned from
 * {@link #getSurfaceTexture()} into the set of target {@link Surface}s
 * in the next request from the given {@link CaptureCollector}, or drop
 * the frame if none is available.
 *
 * <p>
 * Any {@link Surface}s targeted must be a subset of the {@link Surface}s
 * set in the last {@link #configureSurfaces(java.util.Collection)} call.
 * </p>
 *
 * @param targetCollector the surfaces to draw to.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
598,<android.hardware.camera2.legacy.CameraDeviceUserShim.CameraCallbackThread.CallbackHandler: void handleMessage(Message)>,25,26,<android.hardware.camera2.legacy.CameraDeviceUserShim.CameraCallbackThread.CallbackHandler: void handleMessage(Message)>,<android.hardware.camera2.legacy.CameraDeviceUserShim.CameraCallbackThread.CallbackHandler: void handleMessage(Message)>,0,"{
    try {
        switch(msg.what) {
            case CAMERA_ERROR:
                {
                    int errorCode = msg.arg1;
                    CaptureResultExtras resultExtras = (CaptureResultExtras) msg.obj;
                    mCallbacks.onDeviceError(errorCode, resultExtras);
                    break;
                }
            case CAMERA_IDLE:
                mCallbacks.onDeviceIdle();
                break;
            case CAPTURE_STARTED:
                {
                    long timestamp = msg.arg2 & 0xFFFFFFFFL;
                    timestamp = (timestamp << 32) | (msg.arg1 & 0xFFFFFFFFL);
                    CaptureResultExtras resultExtras = (CaptureResultExtras) msg.obj;
                    mCallbacks.onCaptureStarted(resultExtras, timestamp);
                    break;
                }
            case RESULT_RECEIVED:
                {
                    Object[] resultArray = (Object[]) msg.obj;
                    CameraMetadataNative result = (CameraMetadataNative) resultArray[0];
                    CaptureResultExtras resultExtras = (CaptureResultExtras) resultArray[1];
                    mCallbacks.onResultReceived(result, resultExtras);
                    break;
                }
            case PREPARED:
                {
                    int streamId = msg.arg1;
                    mCallbacks.onPrepared(streamId);
                    break;
                }
            case REPEATING_REQUEST_ERROR:
                {
                    long lastFrameNumber = msg.arg2 & 0xFFFFFFFFL;
                    lastFrameNumber = (lastFrameNumber << 32) | (msg.arg1 & 0xFFFFFFFFL);
                    mCallbacks.onRepeatingRequestError(lastFrameNumber);
                    break;
                }
            default:
                throw new IllegalArgumentException(""Unknown callback message "" + msg.what);
        }
    } catch (RemoteException e) {
        throw new IllegalStateException(""Received remote exception during camera callback "" + msg.what, e);
    }
}","{
    try {
        switch(msg.what) {
            case CAMERA_ERROR:
                {
                    int errorCode = msg.arg1;
                    CaptureResultExtras resultExtras = (CaptureResultExtras) msg.obj;
                    mCallbacks.onDeviceError(errorCode, resultExtras);
                    break;
                }
            case CAMERA_IDLE:
                mCallbacks.onDeviceIdle();
                break;
            case CAPTURE_STARTED:
                {
                    long timestamp = msg.arg2 & 0xFFFFFFFFL;
                    timestamp = (timestamp << 32) | (msg.arg1 & 0xFFFFFFFFL);
                    CaptureResultExtras resultExtras = (CaptureResultExtras) msg.obj;
                    mCallbacks.onCaptureStarted(resultExtras, timestamp);
                    break;
                }
            case RESULT_RECEIVED:
                {
                    Object[] resultArray = (Object[]) msg.obj;
                    CameraMetadataNative result = (CameraMetadataNative) resultArray[0];
                    CaptureResultExtras resultExtras = (CaptureResultExtras) resultArray[1];
                    mCallbacks.onResultReceived(result, resultExtras);
                    break;
                }
            case PREPARED:
                {
                    int streamId = msg.arg1;
                    mCallbacks.onPrepared(streamId);
                    break;
                }
            case REPEATING_REQUEST_ERROR:
                {
                    long lastFrameNumber = msg.arg2 & 0xFFFFFFFFL;
                    lastFrameNumber = (lastFrameNumber << 32) | (msg.arg1 & 0xFFFFFFFFL);
                    mCallbacks.onRepeatingRequestError(lastFrameNumber);
                    break;
                }
            case REQUEST_QUEUE_EMPTY:
                {
                    mCallbacks.onRequestQueueEmpty();
                    break;
                }
            default:
                throw new IllegalArgumentException(""Unknown callback message "" + msg.what);
        }
    } catch (RemoteException e) {
        throw new IllegalStateException(""Received remote exception during camera callback "" + msg.what, e);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The late version introduced a new case `REQUEST_QUEUE_EMPTY` in the switch statement without altering any existing behaviors. Thus, the code change type is 3 for the control statement change (new case added), and 4 because a new method call `mCallbacks.onRequestQueueEmpty()` was added.","There is no Compatibility Issue since the added case for `REQUEST_QUEUE_EMPTY` does not change any behavior of the existing cases. The added case merely provides a new behavior when a new, previously unhandled message type is received, but it does not affect the handling of previous cases nor does it change any return value or exception handling for those cases. Hence, the CI type is 0."
599,<android.view.SurfaceView: void onDetachedFromWindow()>,25,26,<android.view.SurfaceView: void onDetachedFromWindow()>,<android.view.SurfaceView: void onDetachedFromWindow()>,0,"{
    if (mGlobalListenersAdded) {
        ViewTreeObserver observer = getViewTreeObserver();
        observer.removeOnScrollChangedListener(mScrollChangedListener);
        observer.removeOnPreDrawListener(mDrawListener);
        mGlobalListenersAdded = false;
    }
    mRequestedVisible = false;
    updateWindow(false, false);
    mHaveFrame = false;
    if (mWindow != null) {
        try {
            mSession.remove(mWindow);
        } catch (RemoteException ex) {
        // Not much we can do here...
        }
        mWindow = null;
    }
    mSession = null;
    mLayout.token = null;
    super.onDetachedFromWindow();
}","{
    ViewRootImpl viewRoot = getViewRootImpl();
    // the SurfaceHolder forward, most live wallpapers do it.
    if (viewRoot != null) {
        viewRoot.removeWindowStoppedCallback(this);
    }
    mAttachedToWindow = false;
    if (mGlobalListenersAdded) {
        ViewTreeObserver observer = getViewTreeObserver();
        observer.removeOnScrollChangedListener(mScrollChangedListener);
        observer.removeOnPreDrawListener(mDrawListener);
        mGlobalListenersAdded = false;
    }
    while (mPendingReportDraws > 0) {
        notifyDrawFinished();
    }
    mRequestedVisible = false;
    updateSurface();
    if (mSurfaceControl != null) {
        mSurfaceControl.destroy();
    }
    mSurfaceControl = null;
    mHaveFrame = false;
    super.onDetachedFromWindow();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,3,4","1,2",The late version implementation has several changes compared to the early version: ,"- Other statements have been added or removed such as the introduction of different APIs (getViewRootImpl and notifyDrawFinished) and changes related to 'mSurfaceControl', which is change type 4."
600,<android.net.NetworkStats.Entry: boolean equals(Object)>,25,26,<android.net.NetworkStats.Entry: boolean equals(Object)>,<android.net.NetworkStats.Entry: boolean equals(Object)>,0,"{
    if (o instanceof Entry) {
        final Entry e = (Entry) o;
        return uid == e.uid && set == e.set && tag == e.tag && roaming == e.roaming && rxBytes == e.rxBytes && rxPackets == e.rxPackets && txBytes == e.txBytes && txPackets == e.txPackets && operations == e.operations && iface.equals(e.iface);
    }
    return false;
}","{
    if (o instanceof Entry) {
        final Entry e = (Entry) o;
        return uid == e.uid && set == e.set && tag == e.tag && metered == e.metered && roaming == e.roaming && rxBytes == e.rxBytes && rxPackets == e.rxPackets && txBytes == e.txBytes && txPackets == e.txPackets && operations == e.operations && iface.equals(e.iface);
    }
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The comparison in the return statement has been changed by replacing the check for ""set == e.set"" with ""metered == e.metered"", this constitutes an ""Other statement changed"". The return value can potentially be different because a different field is used in equality check, so the change type is 1,4.","Since the equality check has been modified between the two versions to include ""metered == e.metered"" instead of ""set == e.set"", this might result in the `equals` method returning different results for the same object comparison as in the early version. Hence, there is a potential Compatibility Issue caused by potential different return values, therefore the CI type is 1."
601,<android.view.View: void onDrawScrollBars(Canvas)>,25,26,<android.view.View: void onDrawScrollBars(Canvas)>,<android.view.View: void onDrawScrollBars(Canvas)>,0,"{
    // scrollbars are drawn only when the animation is running
    final ScrollabilityCache cache = mScrollCache;
    if (cache != null) {
        int state = cache.state;
        if (state == ScrollabilityCache.OFF) {
            return;
        }
        boolean invalidate = false;
        if (state == ScrollabilityCache.FADING) {
            // We're fading -- get our fade interpolation
            if (cache.interpolatorValues == null) {
                cache.interpolatorValues = new float[1];
            }
            float[] values = cache.interpolatorValues;
            // Stops the animation if we're done
            if (cache.scrollBarInterpolator.timeToValues(values) == Interpolator.Result.FREEZE_END) {
                cache.state = ScrollabilityCache.OFF;
            } else {
                cache.scrollBar.mutate().setAlpha(Math.round(values[0]));
            }
            // This will make the scroll bars inval themselves after
            // drawing. We only want this when we're fading so that
            // we prevent excessive redraws
            invalidate = true;
        } else {
            // We're just on -- but we may have been fading before so
            // reset alpha
            cache.scrollBar.mutate().setAlpha(255);
        }
        final boolean drawHorizontalScrollBar = isHorizontalScrollBarEnabled();
        final boolean drawVerticalScrollBar = isVerticalScrollBarEnabled() && !isVerticalScrollBarHidden();
        // Fork out the scroll bar drawing for round wearable devices.
        if (mRoundScrollbarRenderer != null) {
            if (drawVerticalScrollBar) {
                final Rect bounds = cache.mScrollBarBounds;
                getVerticalScrollBarBounds(bounds);
                mRoundScrollbarRenderer.drawRoundScrollbars(canvas, (float) cache.scrollBar.getAlpha() / 255f, bounds);
                if (invalidate) {
                    invalidate();
                }
            }
        // Do not draw horizontal scroll bars for round wearable devices.
        } else if (drawVerticalScrollBar || drawHorizontalScrollBar) {
            final ScrollBarDrawable scrollBar = cache.scrollBar;
            if (drawHorizontalScrollBar) {
                scrollBar.setParameters(computeHorizontalScrollRange(), computeHorizontalScrollOffset(), computeHorizontalScrollExtent(), false);
                final Rect bounds = cache.mScrollBarBounds;
                getHorizontalScrollBarBounds(bounds);
                onDrawHorizontalScrollBar(canvas, scrollBar, bounds.left, bounds.top, bounds.right, bounds.bottom);
                if (invalidate) {
                    invalidate(bounds);
                }
            }
            if (drawVerticalScrollBar) {
                scrollBar.setParameters(computeVerticalScrollRange(), computeVerticalScrollOffset(), computeVerticalScrollExtent(), true);
                final Rect bounds = cache.mScrollBarBounds;
                getVerticalScrollBarBounds(bounds);
                onDrawVerticalScrollBar(canvas, scrollBar, bounds.left, bounds.top, bounds.right, bounds.bottom);
                if (invalidate) {
                    invalidate(bounds);
                }
            }
        }
    }
}","{
    // scrollbars are drawn only when the animation is running
    final ScrollabilityCache cache = mScrollCache;
    if (cache != null) {
        int state = cache.state;
        if (state == ScrollabilityCache.OFF) {
            return;
        }
        boolean invalidate = false;
        if (state == ScrollabilityCache.FADING) {
            // We're fading -- get our fade interpolation
            if (cache.interpolatorValues == null) {
                cache.interpolatorValues = new float[1];
            }
            float[] values = cache.interpolatorValues;
            // Stops the animation if we're done
            if (cache.scrollBarInterpolator.timeToValues(values) == Interpolator.Result.FREEZE_END) {
                cache.state = ScrollabilityCache.OFF;
            } else {
                cache.scrollBar.mutate().setAlpha(Math.round(values[0]));
            }
            // This will make the scroll bars inval themselves after
            // drawing. We only want this when we're fading so that
            // we prevent excessive redraws
            invalidate = true;
        } else {
            // We're just on -- but we may have been fading before so
            // reset alpha
            cache.scrollBar.mutate().setAlpha(255);
        }
        final boolean drawHorizontalScrollBar = isHorizontalScrollBarEnabled();
        final boolean drawVerticalScrollBar = isVerticalScrollBarEnabled() && !isVerticalScrollBarHidden();
        // Fork out the scroll bar drawing for round wearable devices.
        if (mRoundScrollbarRenderer != null) {
            if (drawVerticalScrollBar) {
                final Rect bounds = cache.mScrollBarBounds;
                getVerticalScrollBarBounds(bounds, null);
                mRoundScrollbarRenderer.drawRoundScrollbars(canvas, (float) cache.scrollBar.getAlpha() / 255f, bounds);
                if (invalidate) {
                    invalidate();
                }
            }
        // Do not draw horizontal scroll bars for round wearable devices.
        } else if (drawVerticalScrollBar || drawHorizontalScrollBar) {
            final ScrollBarDrawable scrollBar = cache.scrollBar;
            if (drawHorizontalScrollBar) {
                scrollBar.setParameters(computeHorizontalScrollRange(), computeHorizontalScrollOffset(), computeHorizontalScrollExtent(), false);
                final Rect bounds = cache.mScrollBarBounds;
                getHorizontalScrollBarBounds(bounds, null);
                onDrawHorizontalScrollBar(canvas, scrollBar, bounds.left, bounds.top, bounds.right, bounds.bottom);
                if (invalidate) {
                    invalidate(bounds);
                }
            }
            if (drawVerticalScrollBar) {
                scrollBar.setParameters(computeVerticalScrollRange(), computeVerticalScrollOffset(), computeVerticalScrollExtent(), true);
                final Rect bounds = cache.mScrollBarBounds;
                getVerticalScrollBarBounds(bounds, null);
                onDrawVerticalScrollBar(canvas, scrollBar, bounds.left, bounds.top, bounds.right, bounds.bottom);
                if (invalidate) {
                    invalidate(bounds);
                }
            }
        }
    }
}",1,"/**
 * <p>Request the drawing of the horizontal and the vertical scrollbar. The
 * scrollbars are painted only if they have been awakened first.</p>
 *
 * @param canvas the canvas on which to draw the scrollbars
 *
 * @see #awakenScrollBars(int)
 */
","/**
 * <p>Request the drawing of the horizontal and the vertical scrollbar. The
 * scrollbars are painted only if they have been awakened first.</p>
 *
 * @param canvas the canvas on which to draw the scrollbars
 *
 * @see #awakenScrollBars(int)
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
602,"<android.widget.NumberPicker.InputTextFilter: CharSequence filter(CharSequence,int,int,Spanned,int,int)>",25,26,"<android.widget.NumberPicker.InputTextFilter: CharSequence filter(CharSequence,int,int,Spanned,int,int)>","<android.widget.NumberPicker.InputTextFilter: CharSequence filter(CharSequence,int,int,Spanned,int,int)>",0,"{
    if (mDisplayedValues == null) {
        CharSequence filtered = super.filter(source, start, end, dest, dstart, dend);
        if (filtered == null) {
            filtered = source.subSequence(start, end);
        }
        String result = String.valueOf(dest.subSequence(0, dstart)) + filtered + dest.subSequence(dend, dest.length());
        if ("""".equals(result)) {
            return result;
        }
        int val = getSelectedPos(result);
        /*
                 * Ensure the user can't type in a value greater than the max
                 * allowed. We have to allow less than min as the user might
                 * want to delete some numbers and then type a new number.
                 * And prevent multiple-""0"" that exceeds the length of upper
                 * bound number.
                 */
        if (val > mMaxValue || result.length() > String.valueOf(mMaxValue).length()) {
            return """";
        } else {
            return filtered;
        }
    } else {
        CharSequence filtered = String.valueOf(source.subSequence(start, end));
        if (TextUtils.isEmpty(filtered)) {
            return """";
        }
        String result = String.valueOf(dest.subSequence(0, dstart)) + filtered + dest.subSequence(dend, dest.length());
        String str = String.valueOf(result).toLowerCase();
        for (String val : mDisplayedValues) {
            String valLowerCase = val.toLowerCase();
            if (valLowerCase.startsWith(str)) {
                postSetSelectionCommand(result.length(), val.length());
                return val.subSequence(dstart, val.length());
            }
        }
        return """";
    }
}","{
    // pending set selection command.
    if (mSetSelectionCommand != null) {
        mSetSelectionCommand.cancel();
    }
    if (mDisplayedValues == null) {
        CharSequence filtered = super.filter(source, start, end, dest, dstart, dend);
        if (filtered == null) {
            filtered = source.subSequence(start, end);
        }
        String result = String.valueOf(dest.subSequence(0, dstart)) + filtered + dest.subSequence(dend, dest.length());
        if ("""".equals(result)) {
            return result;
        }
        int val = getSelectedPos(result);
        /*
                 * Ensure the user can't type in a value greater than the max
                 * allowed. We have to allow less than min as the user might
                 * want to delete some numbers and then type a new number.
                 * And prevent multiple-""0"" that exceeds the length of upper
                 * bound number.
                 */
        if (val > mMaxValue || result.length() > String.valueOf(mMaxValue).length()) {
            return """";
        } else {
            return filtered;
        }
    } else {
        CharSequence filtered = String.valueOf(source.subSequence(start, end));
        if (TextUtils.isEmpty(filtered)) {
            return """";
        }
        String result = String.valueOf(dest.subSequence(0, dstart)) + filtered + dest.subSequence(dend, dest.length());
        String str = String.valueOf(result).toLowerCase();
        for (String val : mDisplayedValues) {
            String valLowerCase = val.toLowerCase();
            if (valLowerCase.startsWith(str)) {
                postSetSelectionCommand(result.length(), val.length());
                return val.subSequence(dstart, val.length());
            }
        }
        return """";
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,The only change found between the versions is the additional lines for cancelling any pending set selection command at the beginning of the method. There are no changes in the return statements or exception handling.,"The added lines in the late version implementation do not affect how the method returns values or throws exceptions. Therefore, there is no Compatibility Issue arising from this change."
604,"<android.app.admin.DevicePolicyManager: void setUninstallBlocked(ComponentName,String,boolean)>",25,26,"<android.app.admin.DevicePolicyManager: void setUninstallBlocked(ComponentName,String,boolean)>","<android.app.admin.DevicePolicyManager: void setUninstallBlocked(ComponentName,String,boolean)>",0,"{
    throwIfParentInstance(""setUninstallBlocked"");
    if (mService != null) {
        try {
            mService.setUninstallBlocked(admin, packageName, uninstallBlocked);
        } catch (RemoteException re) {
            throw re.rethrowFromSystemServer();
        }
    }
}","{
    throwIfParentInstance(""setUninstallBlocked"");
    if (mService != null) {
        try {
            mService.setUninstallBlocked(admin, mContext.getPackageName(), packageName, uninstallBlocked);
        } catch (RemoteException re) {
            throw re.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Called by profile or device owners to change whether a user can uninstall a package.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param packageName package to change.
 * @param uninstallBlocked true if the user shouldn't be able to uninstall the package.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 */
","/**
 * Change whether a user can uninstall a package. This function can be called by a device owner,
 * profile owner, or by a delegate given the {@link #DELEGATION_BLOCK_UNINSTALL} scope via
 * {@link #setDelegatedScopes}.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or
 * {@code null} if the caller is a block uninstall delegate.
 * @param packageName package to change.
 * @param uninstallBlocked true if the user shouldn't be able to uninstall the package.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 * @see #setDelegatedScopes
 * @see #DELEGATION_BLOCK_UNINSTALL
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method call within `try` has an additional argument, `mContext.getPackageName()`. This indicates that the dependent API `mService.setUninstallBlocked` now requires one more argument, hence reflecting a change in the dependent API. Therefore, the code change type is 5.","Despite the change in the method signature of the dependent `mService.setUninstallBlocked`, there is no inherent Compatibility Issue since the method's external behavior in terms of return value and exception throwing remain the same. So there is no Compatibility Issue i.e., the type is 0."
605,<android.hardware.camera2.legacy.LegacyCameraDevice: int configureOutputs(SparseArray<Surface>)>,25,26,<android.hardware.camera2.legacy.LegacyCameraDevice: int configureOutputs(SparseArray<Surface>)>,<android.hardware.camera2.legacy.LegacyCameraDevice: int configureOutputs(SparseArray<Surface>)>,0,"{
    List<Pair<Surface, Size>> sizedSurfaces = new ArrayList<>();
    if (outputs != null) {
        int count = outputs.size();
        for (int i = 0; i < count; i++) {
            Surface output = outputs.valueAt(i);
            if (output == null) {
                Log.e(TAG, ""configureOutputs - null outputs are not allowed"");
                return BAD_VALUE;
            }
            if (!output.isValid()) {
                Log.e(TAG, ""configureOutputs - invalid output surfaces are not allowed"");
                return BAD_VALUE;
            }
            StreamConfigurationMap streamConfigurations = mStaticCharacteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);
            // Validate surface size and format.
            try {
                Size s = getSurfaceSize(output);
                int surfaceType = detectSurfaceType(output);
                boolean flexibleConsumer = isFlexibleConsumer(output);
                Size[] sizes = streamConfigurations.getOutputSizes(surfaceType);
                if (sizes == null) {
                    // WAR: Override default format to IMPLEMENTATION_DEFINED for b/9487482
                    if ((surfaceType >= LegacyMetadataMapper.HAL_PIXEL_FORMAT_RGBA_8888 && surfaceType <= LegacyMetadataMapper.HAL_PIXEL_FORMAT_BGRA_8888)) {
                        // YUV_420_888 is always present in LEGACY for all
                        // IMPLEMENTATION_DEFINED output sizes, and is publicly visible in the
                        // API (i.e. {@code #getOutputSizes} works here).
                        sizes = streamConfigurations.getOutputSizes(ImageFormat.YUV_420_888);
                    } else if (surfaceType == LegacyMetadataMapper.HAL_PIXEL_FORMAT_BLOB) {
                        sizes = streamConfigurations.getOutputSizes(ImageFormat.JPEG);
                    }
                }
                if (!ArrayUtils.contains(sizes, s)) {
                    if (flexibleConsumer && (s = findClosestSize(s, sizes)) != null) {
                        sizedSurfaces.add(new Pair<>(output, s));
                    } else {
                        String reason = (sizes == null) ? ""format is invalid."" : (""size not in valid set: "" + Arrays.toString(sizes));
                        Log.e(TAG, String.format(""Surface with size (w=%d, h=%d) and format "" + ""0x%x is not valid, %s"", s.getWidth(), s.getHeight(), surfaceType, reason));
                        return BAD_VALUE;
                    }
                } else {
                    sizedSurfaces.add(new Pair<>(output, s));
                }
                // Lock down the size before configuration
                setSurfaceDimens(output, s.getWidth(), s.getHeight());
            } catch (BufferQueueAbandonedException e) {
                Log.e(TAG, ""Surface bufferqueue is abandoned, cannot configure as output: "", e);
                return BAD_VALUE;
            }
        }
    }
    boolean success = false;
    if (mDeviceState.setConfiguring()) {
        mRequestThreadManager.configure(sizedSurfaces);
        success = mDeviceState.setIdle();
    }
    if (success) {
        mConfiguredSurfaces = outputs;
    } else {
        return LegacyExceptionUtils.INVALID_OPERATION;
    }
    return LegacyExceptionUtils.NO_ERROR;
}","{
    List<Pair<Surface, Size>> sizedSurfaces = new ArrayList<>();
    if (outputs != null) {
        int count = outputs.size();
        for (int i = 0; i < count; i++) {
            Surface output = outputs.valueAt(i);
            if (output == null) {
                Log.e(TAG, ""configureOutputs - null outputs are not allowed"");
                return BAD_VALUE;
            }
            if (!output.isValid()) {
                Log.e(TAG, ""configureOutputs - invalid output surfaces are not allowed"");
                return BAD_VALUE;
            }
            StreamConfigurationMap streamConfigurations = mStaticCharacteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);
            // Validate surface size and format.
            try {
                Size s = getSurfaceSize(output);
                int surfaceType = detectSurfaceType(output);
                boolean flexibleConsumer = isFlexibleConsumer(output);
                Size[] sizes = streamConfigurations.getOutputSizes(surfaceType);
                if (sizes == null) {
                    if (surfaceType == ImageFormat.PRIVATE) {
                        // YUV_420_888 is always present in LEGACY for all
                        // IMPLEMENTATION_DEFINED output sizes, and is publicly visible in the
                        // API (i.e. {@code #getOutputSizes} works here).
                        sizes = streamConfigurations.getOutputSizes(ImageFormat.YUV_420_888);
                    } else if (surfaceType == LegacyMetadataMapper.HAL_PIXEL_FORMAT_BLOB) {
                        sizes = streamConfigurations.getOutputSizes(ImageFormat.JPEG);
                    }
                }
                if (!ArrayUtils.contains(sizes, s)) {
                    if (flexibleConsumer && (s = findClosestSize(s, sizes)) != null) {
                        sizedSurfaces.add(new Pair<>(output, s));
                    } else {
                        String reason = (sizes == null) ? ""format is invalid."" : (""size not in valid set: "" + Arrays.toString(sizes));
                        Log.e(TAG, String.format(""Surface with size (w=%d, h=%d) and format "" + ""0x%x is not valid, %s"", s.getWidth(), s.getHeight(), surfaceType, reason));
                        return BAD_VALUE;
                    }
                } else {
                    sizedSurfaces.add(new Pair<>(output, s));
                }
                // Lock down the size before configuration
                setSurfaceDimens(output, s.getWidth(), s.getHeight());
            } catch (BufferQueueAbandonedException e) {
                Log.e(TAG, ""Surface bufferqueue is abandoned, cannot configure as output: "", e);
                return BAD_VALUE;
            }
        }
    }
    boolean success = false;
    if (mDeviceState.setConfiguring()) {
        mRequestThreadManager.configure(sizedSurfaces);
        success = mDeviceState.setIdle();
    }
    if (success) {
        mConfiguredSurfaces = outputs;
    } else {
        return LegacyExceptionUtils.INVALID_OPERATION;
    }
    return LegacyExceptionUtils.NO_ERROR;
}",1,"/**
 * Configure the device with a set of output surfaces.
 *
 * <p>Using empty or {@code null} {@code outputs} is the same as unconfiguring.</p>
 *
 * <p>Every surface in {@code outputs} must be non-{@code null}.</p>
 *
 * @param outputs a list of surfaces to set. LegacyCameraDevice will take ownership of this
 * list; it must not be modified by the caller once it's passed in.
 * @return an error code for this binder operation, or {@link NO_ERROR}
 * on success.
 */
","/**
 * Configure the device with a set of output surfaces.
 *
 * <p>Using empty or {@code null} {@code outputs} is the same as unconfiguring.</p>
 *
 * <p>Every surface in {@code outputs} must be non-{@code null}.</p>
 *
 * @param outputs a list of surfaces to set. LegacyCameraDevice will take ownership of this
 * list; it must not be modified by the caller once it's passed in.
 * @return an error code for this binder operation, or {@link NO_ERROR}
 * on success.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
606,"<android.transition.Visibility: Animator onDisappear(ViewGroup,TransitionValues,int,TransitionValues,int)>",25,26,"<android.transition.Visibility: Animator onDisappear(ViewGroup,TransitionValues,int,TransitionValues,int)>","<android.transition.Visibility: Animator onDisappear(ViewGroup,TransitionValues,int,TransitionValues,int)>",0,"{
    if ((mMode & MODE_OUT) != MODE_OUT) {
        return null;
    }
    View startView = (startValues != null) ? startValues.view : null;
    View endView = (endValues != null) ? endValues.view : null;
    View overlayView = null;
    View viewToKeep = null;
    if (endView == null || endView.getParent() == null) {
        if (endView != null) {
            // endView was removed from its parent - add it to the overlay
            overlayView = endView;
        } else if (startView != null) {
            // it being removed from its current parent
            if (startView.getParent() == null) {
                // no parent - safe to use
                overlayView = startView;
            } else if (startView.getParent() instanceof View) {
                View startParent = (View) startView.getParent();
                TransitionValues startParentValues = getTransitionValues(startParent, true);
                TransitionValues endParentValues = getMatchedTransitionValues(startParent, true);
                VisibilityInfo parentVisibilityInfo = getVisibilityChangeInfo(startParentValues, endParentValues);
                if (!parentVisibilityInfo.visibilityChange) {
                    overlayView = TransitionUtils.copyViewImage(sceneRoot, startView, startParent);
                } else if (startParent.getParent() == null) {
                    int id = startParent.getId();
                    if (id != View.NO_ID && sceneRoot.findViewById(id) != null && mCanRemoveViews) {
                        // no parent, but its parent is unparented  but the parent
                        // hierarchy has been replaced by a new hierarchy with the same id
                        // and it is safe to un-parent startView
                        overlayView = startView;
                    }
                }
            }
        }
    } else {
        // visibility change
        if (endVisibility == View.INVISIBLE) {
            viewToKeep = endView;
        } else {
            // Becoming GONE
            if (startView == endView) {
                viewToKeep = endView;
            } else {
                overlayView = startView;
            }
        }
    }
    final int finalVisibility = endVisibility;
    final ViewGroup finalSceneRoot = sceneRoot;
    if (overlayView != null) {
        // TODO: Need to do this for general case of adding to overlay
        int[] screenLoc = (int[]) startValues.values.get(PROPNAME_SCREEN_LOCATION);
        int screenX = screenLoc[0];
        int screenY = screenLoc[1];
        int[] loc = new int[2];
        sceneRoot.getLocationOnScreen(loc);
        overlayView.offsetLeftAndRight((screenX - loc[0]) - overlayView.getLeft());
        overlayView.offsetTopAndBottom((screenY - loc[1]) - overlayView.getTop());
        sceneRoot.getOverlay().add(overlayView);
        Animator animator = onDisappear(sceneRoot, overlayView, startValues, endValues);
        if (animator == null) {
            sceneRoot.getOverlay().remove(overlayView);
        } else {
            final View finalOverlayView = overlayView;
            addListener(new TransitionListenerAdapter() {

                @Override
                public void onTransitionEnd(Transition transition) {
                    finalSceneRoot.getOverlay().remove(finalOverlayView);
                }
            });
        }
        return animator;
    }
    if (viewToKeep != null) {
        int originalVisibility = viewToKeep.getVisibility();
        viewToKeep.setTransitionVisibility(View.VISIBLE);
        Animator animator = onDisappear(sceneRoot, viewToKeep, startValues, endValues);
        if (animator != null) {
            DisappearListener disappearListener = new DisappearListener(viewToKeep, finalVisibility, mSuppressLayout);
            animator.addListener(disappearListener);
            animator.addPauseListener(disappearListener);
            addListener(disappearListener);
        } else {
            viewToKeep.setTransitionVisibility(originalVisibility);
        }
        return animator;
    }
    return null;
}","{
    if ((mMode & MODE_OUT) != MODE_OUT) {
        return null;
    }
    View startView = (startValues != null) ? startValues.view : null;
    View endView = (endValues != null) ? endValues.view : null;
    View overlayView = null;
    View viewToKeep = null;
    if (endView == null || endView.getParent() == null) {
        if (endView != null) {
            // endView was removed from its parent - add it to the overlay
            overlayView = endView;
        } else if (startView != null) {
            // it being removed from its current parent
            if (startView.getParent() == null) {
                // no parent - safe to use
                overlayView = startView;
            } else if (startView.getParent() instanceof View) {
                View startParent = (View) startView.getParent();
                TransitionValues startParentValues = getTransitionValues(startParent, true);
                TransitionValues endParentValues = getMatchedTransitionValues(startParent, true);
                VisibilityInfo parentVisibilityInfo = getVisibilityChangeInfo(startParentValues, endParentValues);
                if (!parentVisibilityInfo.visibilityChange) {
                    overlayView = TransitionUtils.copyViewImage(sceneRoot, startView, startParent);
                } else if (startParent.getParent() == null) {
                    int id = startParent.getId();
                    if (id != View.NO_ID && sceneRoot.findViewById(id) != null && mCanRemoveViews) {
                        // no parent, but its parent is unparented  but the parent
                        // hierarchy has been replaced by a new hierarchy with the same id
                        // and it is safe to un-parent startView
                        overlayView = startView;
                    }
                }
            }
        }
    } else {
        // visibility change
        if (endVisibility == View.INVISIBLE) {
            viewToKeep = endView;
        } else {
            // Becoming GONE
            if (startView == endView) {
                viewToKeep = endView;
            } else {
                overlayView = startView;
            }
        }
    }
    final int finalVisibility = endVisibility;
    final ViewGroup finalSceneRoot = sceneRoot;
    if (overlayView != null) {
        // TODO: Need to do this for general case of adding to overlay
        int[] screenLoc = (int[]) startValues.values.get(PROPNAME_SCREEN_LOCATION);
        int screenX = screenLoc[0];
        int screenY = screenLoc[1];
        int[] loc = new int[2];
        sceneRoot.getLocationOnScreen(loc);
        overlayView.offsetLeftAndRight((screenX - loc[0]) - overlayView.getLeft());
        overlayView.offsetTopAndBottom((screenY - loc[1]) - overlayView.getTop());
        sceneRoot.getOverlay().add(overlayView);
        Animator animator = onDisappear(sceneRoot, overlayView, startValues, endValues);
        if (animator == null) {
            sceneRoot.getOverlay().remove(overlayView);
        } else {
            final View finalOverlayView = overlayView;
            addListener(new TransitionListenerAdapter() {

                @Override
                public void onTransitionEnd(Transition transition) {
                    finalSceneRoot.getOverlay().remove(finalOverlayView);
                    transition.removeListener(this);
                }
            });
        }
        return animator;
    }
    if (viewToKeep != null) {
        int originalVisibility = viewToKeep.getVisibility();
        viewToKeep.setTransitionVisibility(View.VISIBLE);
        Animator animator = onDisappear(sceneRoot, viewToKeep, startValues, endValues);
        if (animator != null) {
            DisappearListener disappearListener = new DisappearListener(viewToKeep, finalVisibility, mSuppressLayout);
            animator.addListener(disappearListener);
            animator.addPauseListener(disappearListener);
            addListener(disappearListener);
        } else {
            viewToKeep.setTransitionVisibility(originalVisibility);
        }
        return animator;
    }
    return null;
}",1,"/**
 * Subclasses should override this method or
 * {@link #onDisappear(ViewGroup, View, TransitionValues, TransitionValues)}
 * if they need to create an Animator when targets disappear.
 * The method should only be called by the Visibility class; it is
 * not intended to be called from external classes.
 * <p>
 * The default implementation of this method attempts to find a View to use to call
 * {@link #onDisappear(ViewGroup, View, TransitionValues, TransitionValues)},
 * based on the situation of the View in the View hierarchy. For example,
 * if a View was simply removed from its parent, then the View will be added
 * into a {@link android.view.ViewGroupOverlay} and passed as the <code>view</code>
 * parameter in {@link #onDisappear(ViewGroup, View, TransitionValues, TransitionValues)}.
 * If a visible View is changed to be {@link View#GONE} or {@link View#INVISIBLE},
 * then it can be used as the <code>view</code> and the visibility will be changed
 * to {@link View#VISIBLE} for the duration of the animation. However, if a View
 * is in a hierarchy which is also altering its visibility, the situation can be
 * more complicated. In general, if a view that is no longer in the hierarchy in
 * the end scene still has a parent (so its parent hierarchy was removed, but it
 * was not removed from its parent), then it will be left alone to avoid side-effects from
 * improperly removing it from its parent. The only exception to this is if
 * the previous {@link Scene} was {@link Scene#getSceneForLayout(ViewGroup, int,
 * android.content.Context) created from a layout resource file}, then it is considered
 * safe to un-parent the starting scene view in order to make it disappear.</p>
 *
 * @param sceneRoot The root of the transition hierarchy
 * @param startValues The target values in the start scene
 * @param startVisibility The target visibility in the start scene
 * @param endValues The target values in the end scene
 * @param endVisibility The target visibility in the end scene
 * @return An Animator to be started at the appropriate time in the
 * overall transition for this scene change. A null value means no animation
 * should be run.
 */
","/**
 * Subclasses should override this method or
 * {@link #onDisappear(ViewGroup, View, TransitionValues, TransitionValues)}
 * if they need to create an Animator when targets disappear.
 * The method should only be called by the Visibility class; it is
 * not intended to be called from external classes.
 * <p>
 * The default implementation of this method attempts to find a View to use to call
 * {@link #onDisappear(ViewGroup, View, TransitionValues, TransitionValues)},
 * based on the situation of the View in the View hierarchy. For example,
 * if a View was simply removed from its parent, then the View will be added
 * into a {@link android.view.ViewGroupOverlay} and passed as the <code>view</code>
 * parameter in {@link #onDisappear(ViewGroup, View, TransitionValues, TransitionValues)}.
 * If a visible View is changed to be {@link View#GONE} or {@link View#INVISIBLE},
 * then it can be used as the <code>view</code> and the visibility will be changed
 * to {@link View#VISIBLE} for the duration of the animation. However, if a View
 * is in a hierarchy which is also altering its visibility, the situation can be
 * more complicated. In general, if a view that is no longer in the hierarchy in
 * the end scene still has a parent (so its parent hierarchy was removed, but it
 * was not removed from its parent), then it will be left alone to avoid side-effects from
 * improperly removing it from its parent. The only exception to this is if
 * the previous {@link Scene} was {@link Scene#getSceneForLayout(ViewGroup, int,
 * android.content.Context) created from a layout resource file}, then it is considered
 * safe to un-parent the starting scene view in order to make it disappear.</p>
 *
 * @param sceneRoot The root of the transition hierarchy
 * @param startValues The target values in the start scene
 * @param startVisibility The target visibility in the start scene
 * @param endValues The target values in the end scene
 * @param endVisibility The target visibility in the end scene
 * @return An Animator to be started at the appropriate time in the
 * overall transition for this scene change. A null value means no animation
 * should be run.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
607,"<android.view.View: boolean onKeyUp(int,KeyEvent)>",25,26,"<android.view.View: boolean onKeyUp(int,KeyEvent)>","<android.view.View: boolean onKeyUp(int,KeyEvent)>",0,"{
    if (KeyEvent.isConfirmKey(keyCode)) {
        if ((mViewFlags & ENABLED_MASK) == DISABLED) {
            return true;
        }
        if ((mViewFlags & CLICKABLE) == CLICKABLE && isPressed()) {
            setPressed(false);
            if (!mHasPerformedLongPress) {
                // This is a tap, so remove the longpress check
                removeLongPressCallback();
                return performClick();
            }
        }
    }
    return false;
}","{
    if (KeyEvent.isConfirmKey(keyCode)) {
        if ((mViewFlags & ENABLED_MASK) == DISABLED) {
            return true;
        }
        if ((mViewFlags & CLICKABLE) == CLICKABLE && isPressed()) {
            setPressed(false);
            if (!mHasPerformedLongPress) {
                // This is a tap, so remove the longpress check
                removeLongPressCallback();
                if (!event.isCanceled()) {
                    return performClick();
                }
            }
        }
    }
    return false;
}",1,"/**
 * Default implementation of {@link KeyEvent.Callback#onKeyUp(int, KeyEvent)
 * KeyEvent.Callback.onKeyUp()}: perform clicking of the view
 * when {@link KeyEvent#KEYCODE_DPAD_CENTER}, {@link KeyEvent#KEYCODE_ENTER}
 * or {@link KeyEvent#KEYCODE_SPACE} is released.
 * <p>Key presses in software keyboards will generally NOT trigger this listener,
 * although some may elect to do so in some situations. Do not rely on this to
 * catch software key presses.
 *
 * @param keyCode A key code that represents the button pressed, from
 * {@link android.view.KeyEvent}.
 * @param event   The KeyEvent object that defines the button action.
 */
","/**
 * Default implementation of {@link KeyEvent.Callback#onKeyUp(int, KeyEvent)
 * KeyEvent.Callback.onKeyUp()}: perform clicking of the view
 * when {@link KeyEvent#KEYCODE_DPAD_CENTER}, {@link KeyEvent#KEYCODE_ENTER}
 * or {@link KeyEvent#KEYCODE_SPACE} is released.
 * <p>Key presses in software keyboards will generally NOT trigger this listener,
 * although some may elect to do so in some situations. Do not rely on this to
 * catch software key presses.
 *
 * @param keyCode A key code that represents the button pressed, from
 * {@link android.view.KeyEvent}.
 * @param event   The KeyEvent object that defines the button action.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"In the late implementation, a new control dependency check `if (!event.isCanceled())` has been introduced before the `return performClick();`, and the control flow is now also dependent on this new condition. Thereby, it falls under change type 1,3.","Considering the new condition introduced, the outcome of the method could differ based on the state of `event`. If the event is canceled (`event.isCanceled()` is true), the method will now return false instead of potentially returning true in the preceding version, after the `performClick()` call. Thus, the CI type is 1."
608,<android.bluetooth.BluetoothSocket: void connect()>,25,26,<android.bluetooth.BluetoothSocket: void connect()>,<android.bluetooth.BluetoothSocket: void connect()>,0,"{
    if (mDevice == null)
        throw new IOException(""Connect is called on null device"");
    try {
        if (mSocketState == SocketState.CLOSED)
            throw new IOException(""socket closed"");
        IBluetooth bluetoothProxy = BluetoothAdapter.getDefaultAdapter().getBluetoothService(null);
        if (bluetoothProxy == null)
            throw new IOException(""Bluetooth is off"");
        mPfd = bluetoothProxy.connectSocket(mDevice, mType, mUuid, mPort, getSecurityFlags());
        synchronized (this) {
            if (DBG)
                Log.d(TAG, ""connect(), SocketState: "" + mSocketState + "", mPfd: "" + mPfd);
            if (mSocketState == SocketState.CLOSED)
                throw new IOException(""socket closed"");
            if (mPfd == null)
                throw new IOException(""bt socket connect failed"");
            FileDescriptor fd = mPfd.getFileDescriptor();
            mSocket = new LocalSocket(fd);
            mSocketIS = mSocket.getInputStream();
            mSocketOS = mSocket.getOutputStream();
        }
        int channel = readInt(mSocketIS);
        if (channel <= 0)
            throw new IOException(""bt socket connect failed"");
        mPort = channel;
        waitSocketSignal(mSocketIS);
        synchronized (this) {
            if (mSocketState == SocketState.CLOSED)
                throw new IOException(""bt socket closed"");
            mSocketState = SocketState.CONNECTED;
        }
    } catch (RemoteException e) {
        Log.e(TAG, Log.getStackTraceString(new Throwable()));
        throw new IOException(""unable to send RPC: "" + e.getMessage());
    }
}","{
    if (mDevice == null)
        throw new IOException(""Connect is called on null device"");
    try {
        if (mSocketState == SocketState.CLOSED)
            throw new IOException(""socket closed"");
        IBluetooth bluetoothProxy = BluetoothAdapter.getDefaultAdapter().getBluetoothService(null);
        if (bluetoothProxy == null)
            throw new IOException(""Bluetooth is off"");
        mPfd = bluetoothProxy.connectSocket(mDevice, mType, mUuid, mPort, getSecurityFlags());
        synchronized (this) {
            if (DBG)
                Log.d(TAG, ""connect(), SocketState: "" + mSocketState + "", mPfd: "" + mPfd);
            if (mSocketState == SocketState.CLOSED)
                throw new IOException(""socket closed"");
            if (mPfd == null)
                throw new IOException(""bt socket connect failed"");
            FileDescriptor fd = mPfd.getFileDescriptor();
            mSocket = LocalSocket.createConnectedLocalSocket(fd);
            mSocketIS = mSocket.getInputStream();
            mSocketOS = mSocket.getOutputStream();
        }
        int channel = readInt(mSocketIS);
        if (channel <= 0)
            throw new IOException(""bt socket connect failed"");
        mPort = channel;
        waitSocketSignal(mSocketIS);
        synchronized (this) {
            if (mSocketState == SocketState.CLOSED)
                throw new IOException(""bt socket closed"");
            mSocketState = SocketState.CONNECTED;
        }
    } catch (RemoteException e) {
        Log.e(TAG, Log.getStackTraceString(new Throwable()));
        throw new IOException(""unable to send RPC: "" + e.getMessage());
    }
}",1,"/**
 * Attempt to connect to a remote device.
 * <p>This method will block until a connection is made or the connection
 * fails. If this method returns without an exception then this socket
 * is now connected.
 * <p>Creating new connections to
 * remote Bluetooth devices should not be attempted while device discovery
 * is in progress. Device discovery is a heavyweight procedure on the
 * Bluetooth adapter and will significantly slow a device connection.
 * Use {@link BluetoothAdapter#cancelDiscovery()} to cancel an ongoing
 * discovery. Discovery is not managed by the Activity,
 * but is run as a system service, so an application should always call
 * {@link BluetoothAdapter#cancelDiscovery()} even if it
 * did not directly request a discovery, just to be sure.
 * <p>{@link #close} can be used to abort this call from another thread.
 * @throws IOException on error, for example connection failure
 */
","/**
 * Attempt to connect to a remote device.
 * <p>This method will block until a connection is made or the connection
 * fails. If this method returns without an exception then this socket
 * is now connected.
 * <p>Creating new connections to
 * remote Bluetooth devices should not be attempted while device discovery
 * is in progress. Device discovery is a heavyweight procedure on the
 * Bluetooth adapter and will significantly slow a device connection.
 * Use {@link BluetoothAdapter#cancelDiscovery()} to cancel an ongoing
 * discovery. Discovery is not managed by the Activity,
 * but is run as a system service, so an application should always call
 * {@link BluetoothAdapter#cancelDiscovery()} even if it
 * did not directly request a discovery, just to be sure.
 * <p>{@link #close} can be used to abort this call from another thread.
 * @throws IOException on error, for example connection failure
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The only change in the source code is the instantiation of `mSocket` which went from `new LocalSocket(fd)` to `LocalSocket.createConnectedLocalSocket(fd)`. The change is neither a control dependency change nor an exception handling change nor a return statement change. It is an invocation of a different constructor or factory method, which may indicate a change in internal behavior, therefore classified as 4 (Other statement changed). Additionally, since `createConnectedLocalSocket` is a new or different method being called rather than `LocalSocket`'s constructor, it's considered a dependent API change; hence 5 (Dependent API changed) also applies.","There’s no Compatibility Issue according to the provided information because the changes made do not alter the external behavior of the `connect()` method from the standpoint of the method signature or expected outcomes. The object `mSocket` is still created and initialized before use. If `createConnectedLocalSocket` creates an object which behaves in the same way from the perspective of the `BluetoothSocket` class's client code as the object created by the `new` expression used previously, then the change in implementation detail should not affect how client code interacts with the `BluetoothSocket` class. This assumption is based on the premise that `createConnectedLocalSocket` is supposed to be used in this context and should preserve the overall semantics of the socket connection process. Thus, it is classified as 0 (No Compatibility Issue)."
609,<android.view.ViewGroup: boolean notifyChildOfDragStart(View)>,25,26,<android.view.ViewGroup: boolean notifyChildOfDragStart(View)>,<android.view.ViewGroup: boolean notifyChildOfDragStart(View)>,0,"{
    if (ViewDebug.DEBUG_DRAG) {
        Log.d(View.VIEW_LOG_TAG, ""Sending drag-started to view: "" + child);
    }
    final float tx = mCurrentDragStartEvent.mX;
    final float ty = mCurrentDragStartEvent.mY;
    final float[] point = getTempPoint();
    point[0] = tx;
    point[1] = ty;
    transformPointToViewLocal(point, child);
    mCurrentDragStartEvent.mX = point[0];
    mCurrentDragStartEvent.mY = point[1];
    final boolean canAccept = child.dispatchDragEvent(mCurrentDragStartEvent);
    mCurrentDragStartEvent.mX = tx;
    mCurrentDragStartEvent.mY = ty;
    if (canAccept) {
        mChildrenInterestedInDrag.add(child);
        if (!child.canAcceptDrag()) {
            child.mPrivateFlags2 |= View.PFLAG2_DRAG_CAN_ACCEPT;
            child.refreshDrawableState();
        }
    }
    return canAccept;
}","{
    if (ViewDebug.DEBUG_DRAG) {
        Log.d(View.VIEW_LOG_TAG, ""Sending drag-started to view: "" + child);
    }
    final float tx = mCurrentDragStartEvent.mX;
    final float ty = mCurrentDragStartEvent.mY;
    final float[] point = getTempPoint();
    point[0] = tx;
    point[1] = ty;
    transformPointToViewLocal(point, child);
    mCurrentDragStartEvent.mX = point[0];
    mCurrentDragStartEvent.mY = point[1];
    final boolean canAccept = child.dispatchDragEvent(mCurrentDragStartEvent);
    mCurrentDragStartEvent.mX = tx;
    mCurrentDragStartEvent.mY = ty;
    mCurrentDragStartEvent.mEventHandlerWasCalled = false;
    if (canAccept) {
        mChildrenInterestedInDrag.add(child);
        if (!child.canAcceptDrag()) {
            child.mPrivateFlags2 |= View.PFLAG2_DRAG_CAN_ACCEPT;
            child.refreshDrawableState();
        }
    }
    return canAccept;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"There is a new assignment statement `mCurrentDragStartEvent.mEventHandlerWasCalled = false;` added in the late version, which is an addition to other statements without altering the method's control flow or affecting return values. Therefore, the code change type is 4.","The new assignment statement does not affect the method's return value nor does it introduce a new control flow that could result in different behavior observable to the caller. Hence, there's no Compatibility Issue, and the CI type is 0."
611,"<android.view.View: boolean onKeyDown(int,KeyEvent)>",25,26,"<android.view.View: boolean onKeyDown(int,KeyEvent)>","<android.view.View: boolean onKeyDown(int,KeyEvent)>",0,"{
    if (KeyEvent.isConfirmKey(keyCode)) {
        if ((mViewFlags & ENABLED_MASK) == DISABLED) {
            return true;
        }
        // Long clickable items don't necessarily have to be clickable.
        if (((mViewFlags & CLICKABLE) == CLICKABLE || (mViewFlags & LONG_CLICKABLE) == LONG_CLICKABLE) && (event.getRepeatCount() == 0)) {
            // For the purposes of menu anchoring and drawable hotspots,
            // key events are considered to be at the center of the view.
            final float x = getWidth() / 2f;
            final float y = getHeight() / 2f;
            setPressed(true, x, y);
            checkForLongClick(0, x, y);
            return true;
        }
    }
    return false;
}","{
    if (KeyEvent.isConfirmKey(keyCode)) {
        if ((mViewFlags & ENABLED_MASK) == DISABLED) {
            return true;
        }
        if (event.getRepeatCount() == 0) {
            // Long clickable items don't necessarily have to be clickable.
            final boolean clickable = (mViewFlags & CLICKABLE) == CLICKABLE || (mViewFlags & LONG_CLICKABLE) == LONG_CLICKABLE;
            if (clickable || (mViewFlags & TOOLTIP) == TOOLTIP) {
                // For the purposes of menu anchoring and drawable hotspots,
                // key events are considered to be at the center of the view.
                final float x = getWidth() / 2f;
                final float y = getHeight() / 2f;
                if (clickable) {
                    setPressed(true, x, y);
                }
                checkForLongClick(0, x, y);
                return true;
            }
        }
    }
    return false;
}",1,"/**
 * Default implementation of {@link KeyEvent.Callback#onKeyDown(int, KeyEvent)
 * KeyEvent.Callback.onKeyDown()}: perform press of the view
 * when {@link KeyEvent#KEYCODE_DPAD_CENTER} or {@link KeyEvent#KEYCODE_ENTER}
 * is released, if the view is enabled and clickable.
 * <p>
 * Key presses in software keyboards will generally NOT trigger this
 * listener, although some may elect to do so in some situations. Do not
 * rely on this to catch software key presses.
 *
 * @param keyCode a key code that represents the button pressed, from
 * {@link android.view.KeyEvent}
 * @param event the KeyEvent object that defines the button action
 */
","/**
 * Default implementation of {@link KeyEvent.Callback#onKeyDown(int, KeyEvent)
 * KeyEvent.Callback.onKeyDown()}: perform press of the view
 * when {@link KeyEvent#KEYCODE_DPAD_CENTER} or {@link KeyEvent#KEYCODE_ENTER}
 * is released, if the view is enabled and clickable.
 * <p>
 * Key presses in software keyboards will generally NOT trigger this
 * listener, although some may elect to do so in some situations. Do not
 * rely on this to catch software key presses.
 *
 * @param keyCode a key code that represents the button pressed, from
 * {@link android.view.KeyEvent}
 * @param event the KeyEvent object that defines the button action
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The conditional statements have been refactored to separate the long-clickable and clickable logic, and to introduce a check for the TOOLTIP flag. This warrants a change classification of 3 due to altered control structures and 4 because of the introduction of the new local variable 'clickable', and additional logic to enable tooltip support.","Despite the control dependency change, there is no Compatibility Issue, as the method still returns true for the same cases as before, simply with an added condition for TOOLTIP. For any given keyCode and event, the return value will be true or false exactly as it would have been in the previous design, assuming no tooltip flag set. The setPressed and checkForLongClick method calls remain under the same conditions except that setPressed is now guarded by an additional clickable check. This doesn't affect the method return value because the method still eventually returns true as in the early implementation. There are no new scenarios where the method could return a different boolean result, hence no CI for return values. If TOOLTIP flag was not set before, it will not alter the logic of onKeyDown function. Therefore, CI type is 0."
613,<android.hardware.camera2.CameraManager: String[] getCameraIdList()>,25,26,<android.hardware.camera2.CameraManager: String[] getCameraIdList()>,<android.hardware.camera2.CameraManager: String[] getCameraIdList()>,0,"{
    synchronized (mLock) {
        // exceptions it'll throw are unexpected, and should be propagated upward.
        return getOrCreateDeviceIdListLocked().toArray(new String[0]);
    }
}","{
    return CameraManagerGlobal.get().getCameraIdList();
}",1,"/**
 * Return the list of currently connected camera devices by identifier, including
 * cameras that may be in use by other camera API clients.
 *
 * <p>Non-removable cameras use integers starting at 0 for their
 * identifiers, while removable cameras have a unique identifier for each
 * individual device, even if they are the same model.</p>
 *
 * @return The list of currently connected camera devices.
 */
","/**
 * Return the list of currently connected camera devices by identifier, including
 * cameras that may be in use by other camera API clients.
 *
 * <p>Non-removable cameras use integers starting at 0 for their
 * identifiers, while removable cameras have a unique identifier for each
 * individual device, even if they are the same model.</p>
 *
 * @return The list of currently connected camera devices.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,5,0,"The method implementation changed from synchronized block with an internal method call to a direct call to a static method on a different class (CameraManagerGlobal.get().getCameraIdList()), which indicates a dependent API change, so the code change type is 5.","There is no change in the exception handling or return values, as both methods return a String array and no additional exceptions are declared or handled. The annotation @NonNull remains the same in both versions, further indicating that the contract regarding nullability has not changed. Assuming the behavior of CameraManagerGlobal.get().getCameraIdList() is compatible and returns a non-null String array as before, there is no indication that this change would cause a compatibility issue, therefore the CI type is 0."
614,"<android.view.ViewGroup: View focusSearch(View,int)>",25,26,"<android.view.ViewGroup: View focusSearch(View,int)>","<android.view.ViewGroup: View focusSearch(View,int)>",0,"{
    if (isRootNamespace()) {
        // into other tabs.  see LocalActivityManager and TabHost for more info
        return FocusFinder.getInstance().findNextFocus(this, focused, direction);
    } else if (mParent != null) {
        return mParent.focusSearch(focused, direction);
    }
    return null;
}","{
    if (isRootNamespace()) {
        // into other tabs.  see LocalActivityManager and TabHost for more info.
        return FocusFinder.getInstance().findNextFocus(this, focused, direction);
    } else if (mParent != null) {
        return mParent.focusSearch(focused, direction);
    }
    return null;
}",1,"/**
 * Find the nearest view in the specified direction that wants to take
 * focus.
 *
 * @param focused The view that currently has focus
 * @param direction One of FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, and
 * FOCUS_RIGHT, or 0 for not applicable.
 */
","/**
 * Find the nearest view in the specified direction that wants to take
 * focus.
 *
 * @param focused The view that currently has focus
 * @param direction One of FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, and
 * FOCUS_RIGHT, or 0 for not applicable.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,0,0,There's no change in the implementation code; the method body remains identical between the two versions.,"Since there's no change in the implementation code, there is no possibility for a Compatibility Issue."
615,"<android.content.pm.PackageInstaller.Session: OutputStream openWrite(String,long,long)>",25,26,"<android.content.pm.PackageInstaller.Session: OutputStream openWrite(String,long,long)>","<android.content.pm.PackageInstaller.Session: OutputStream openWrite(String,long,long)>",0,"{
    try {
        final ParcelFileDescriptor clientSocket = mSession.openWrite(name, offsetBytes, lengthBytes);
        return new FileBridge.FileBridgeOutputStream(clientSocket);
    } catch (RuntimeException e) {
        ExceptionUtils.maybeUnwrapIOException(e);
        throw e;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        if (ENABLE_REVOCABLE_FD) {
            return new ParcelFileDescriptor.AutoCloseOutputStream(mSession.openWrite(name, offsetBytes, lengthBytes));
        } else {
            final ParcelFileDescriptor clientSocket = mSession.openWrite(name, offsetBytes, lengthBytes);
            return new FileBridge.FileBridgeOutputStream(clientSocket);
        }
    } catch (RuntimeException e) {
        ExceptionUtils.maybeUnwrapIOException(e);
        throw e;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Open a stream to write an APK file into the session.
 * <p>
 * The returned stream will start writing data at the requested offset
 * in the underlying file, which can be used to resume a partially
 * written file. If a valid file length is specified, the system will
 * preallocate the underlying disk space to optimize placement on disk.
 * It's strongly recommended to provide a valid file length when known.
 * <p>
 * You can write data into the returned stream, optionally call
 * {@link #fsync(OutputStream)} as needed to ensure bytes have been
 * persisted to disk, and then close when finished. All streams must be
 * closed before calling {@link #commit(IntentSender)}.
 *
 * @param name arbitrary, unique name of your choosing to identify the
 * APK being written. You can open a file again for
 * additional writes (such as after a reboot) by using the
 * same name. This name is only meaningful within the context
 * of a single install session.
 * @param offsetBytes offset into the file to begin writing at, or 0 to
 * start at the beginning of the file.
 * @param lengthBytes total size of the file being written, used to
 * preallocate the underlying disk space, or -1 if unknown.
 * The system may clear various caches as needed to allocate
 * this space.
 * @throws IOException if trouble opening the file for writing, such as
 * lack of disk space or unavailable media.
 * @throws SecurityException if called after the session has been
 * committed or abandoned.
 */
","/**
 * Open a stream to write an APK file into the session.
 * <p>
 * The returned stream will start writing data at the requested offset
 * in the underlying file, which can be used to resume a partially
 * written file. If a valid file length is specified, the system will
 * preallocate the underlying disk space to optimize placement on disk.
 * It's strongly recommended to provide a valid file length when known.
 * <p>
 * You can write data into the returned stream, optionally call
 * {@link #fsync(OutputStream)} as needed to ensure bytes have been
 * persisted to disk, and then close when finished. All streams must be
 * closed before calling {@link #commit(IntentSender)}.
 *
 * @param name arbitrary, unique name of your choosing to identify the
 * APK being written. You can open a file again for
 * additional writes (such as after a reboot) by using the
 * same name. This name is only meaningful within the context
 * of a single install session.
 * @param offsetBytes offset into the file to begin writing at, or 0 to
 * start at the beginning of the file.
 * @param lengthBytes total size of the file being written, used to
 * preallocate the underlying disk space, or -1 if unknown.
 * The system may clear various caches as needed to allocate
 * this space.
 * @throws IOException if trouble opening the file for writing, such as
 * lack of disk space or unavailable media.
 * @throws SecurityException if called after the session has been
 * committed or abandoned.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"3,4",1,"The late version has introduced a new control statement `if (ENABLE_REVOCABLE_FD)` and a different type of OutputStream is returned based on the condition. Other statements remain unchanged; hence, the code change type is 3 for control dependency change and 4 for other statement changes (introduction of a new variable in the try block `ENABLE_REVOCABLE_FD`).","Depending on the `ENABLE_REVOCABLE_FD` condition's result, the method will return a different type of OutputStream, which leads to different behavior. So this falls under CI type 1 (Compatibility Issue caused by potential different return values or types)."
616,<android.content.pm.LauncherActivityInfo: CharSequence getLabel()>,25,26,<android.content.pm.LauncherActivityInfo: CharSequence getLabel()>,<android.content.pm.LauncherActivityInfo: CharSequence getLabel()>,0,"{
    return mActivityInfo.loadLabel(mPm);
}","{
    // TODO: Go through LauncherAppsService
    return mActivityInfo.loadLabel(mPm);
}",1,"/**
 * Retrieves the label for the activity.
 *
 * @return The label for the activity.
 */
","/**
 * Retrieves the label for the activity.
 *
 * @return The label for the activity.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only code change is the addition of a comment. This does not affect the functional behavior of the code, so the change type is 4.","Adding a comment will not change the behavior of the API or affect compatibility. Thus, there is no Compatibility Issue, and the CI type is 0."
618,<android.animation.ValueAnimator: boolean animateBasedOnTime(long)>,25,26,<android.animation.ValueAnimator: boolean animateBasedOnTime(long)>,<android.animation.ValueAnimator: boolean animateBasedOnTime(long)>,0,"{
    boolean done = false;
    if (mRunning) {
        final long scaledDuration = getScaledDuration();
        final float fraction = scaledDuration > 0 ? (float) (currentTime - mStartTime) / scaledDuration : 1f;
        final float lastFraction = mOverallFraction;
        final boolean newIteration = (int) fraction > (int) lastFraction;
        final boolean lastIterationFinished = (fraction >= mRepeatCount + 1) && (mRepeatCount != INFINITE);
        if (scaledDuration == 0) {
            // 0 duration animator, ignore the repeat count and skip to the end
            done = true;
        } else if (newIteration && !lastIterationFinished) {
            // Time to repeat
            if (mListeners != null) {
                int numListeners = mListeners.size();
                for (int i = 0; i < numListeners; ++i) {
                    mListeners.get(i).onAnimationRepeat(this);
                }
            }
        } else if (lastIterationFinished) {
            done = true;
        }
        mOverallFraction = clampFraction(fraction);
        float currentIterationFraction = getCurrentIterationFraction(mOverallFraction);
        animateValue(currentIterationFraction);
    }
    return done;
}","{
    boolean done = false;
    if (mRunning) {
        final long scaledDuration = getScaledDuration();
        final float fraction = scaledDuration > 0 ? (float) (currentTime - mStartTime) / scaledDuration : 1f;
        final float lastFraction = mOverallFraction;
        final boolean newIteration = (int) fraction > (int) lastFraction;
        final boolean lastIterationFinished = (fraction >= mRepeatCount + 1) && (mRepeatCount != INFINITE);
        if (scaledDuration == 0) {
            // 0 duration animator, ignore the repeat count and skip to the end
            done = true;
        } else if (newIteration && !lastIterationFinished) {
            // Time to repeat
            if (mListeners != null) {
                int numListeners = mListeners.size();
                for (int i = 0; i < numListeners; ++i) {
                    mListeners.get(i).onAnimationRepeat(this);
                }
            }
        } else if (lastIterationFinished) {
            done = true;
        }
        mOverallFraction = clampFraction(fraction);
        float currentIterationFraction = getCurrentIterationFraction(mOverallFraction, mReversing);
        animateValue(currentIterationFraction);
    }
    return done;
}",1,"/**
 * This internal function processes a single animation frame for a given animation. The
 * currentTime parameter is the timing pulse sent by the handler, used to calculate the
 * elapsed duration, and therefore
 * the elapsed fraction, of the animation. The return value indicates whether the animation
 * should be ended (which happens when the elapsed time of the animation exceeds the
 * animation's duration, including the repeatCount).
 *
 * @param currentTime The current time, as tracked by the static timing handler
 * @return true if the animation's duration, including any repetitions due to
 * <code>repeatCount</code> has been exceeded and the animation should be ended.
 */
","/**
 * This internal function processes a single animation frame for a given animation. The
 * currentTime parameter is the timing pulse sent by the handler, used to calculate the
 * elapsed duration, and therefore
 * the elapsed fraction, of the animation. The return value indicates whether the animation
 * should be ended (which happens when the elapsed time of the animation exceeds the
 * animation's duration, including the repeatCount).
 *
 * @param currentTime The current time, as tracked by the static timing handler
 * @return true if the animation's duration, including any repetitions due to
 * <code>repeatCount</code> has been exceeded and the animation should be ended.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The change in the code is the addition of a new parameter (mReversing) to the call to the method getCurrentIterationFraction. This means there has been a change to a dependent API, so the change type is 5.","There are no changes in the code that could lead to potential different return values or exception handlings since the change involved only adding a new parameter to an existing method call. Assuming the method getCurrentIterationFraction handles the additional parameter without affecting the public contract of the animateBasedOnTime method, there would be no Compatibility Issue; thus, the CI type is 0."
621,"<android.app.ContextImpl: int checkUriPermission(Uri,int,int,int)>",25,26,"<android.app.ContextImpl: int checkUriPermission(Uri,int,int,int)>","<android.app.ContextImpl: int checkUriPermission(Uri,int,int,int)>",0,"{
    try {
        return ActivityManagerNative.getDefault().checkUriPermission(ContentProvider.getUriWithoutUserId(uri), pid, uid, modeFlags, resolveUserId(uri), null);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        return ActivityManager.getService().checkUriPermission(ContentProvider.getUriWithoutUserId(uri), pid, uid, modeFlags, resolveUserId(uri), null);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,The dependent API used in the try block has been changed from ActivityManagerNative.getDefault() to ActivityManager.getService(). This constitutes a dependent API change.,"There is no Compatibility Issue in this change because the change is in a dependent API but the method signature remains the same and it is reasonable to assume that the semantics of the dependent API has been maintained across the change. Therefore, the API should still exhibit the same behavior, returning the same values and throwing the same exceptions under the same conditions."
622,"<android.app.ContextImpl: void sendStickyBroadcastAsUser(Intent,UserHandle)>",25,26,"<android.app.ContextImpl: void sendStickyBroadcastAsUser(Intent,UserHandle)>","<android.app.ContextImpl: void sendStickyBroadcastAsUser(Intent,UserHandle)>",0,"{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, true, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, true, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,"[@Override, @Deprecated]","[@Override, @Deprecated]",-1,-1,-1,-1,-1,-1,5,0,"The method called within the try block has changed from `ActivityManagerNative.getDefault().broadcastIntent` to `ActivityManager.getService().broadcastIntent`. This is a change in the dependent API, so the change type is 5.","Although there is a change in the dependent API, it does not necessarily imply that there is a difference in behavior from the perspective of the client code calling `sendStickyBroadcastAsUser` method itself. The internal implementation detail of how the broadcast is sent has been updated, but the method signature, return type, and exception handling of `sendStickyBroadcastAsUser` remain unchanged. There's no indication that these internal changes would lead to a change in the API's contract, so there's no compatibility issue; hence CI is 0."
623,"<android.app.admin.DevicePolicyManager: void enableSystemApp(ComponentName,String)>",25,26,"<android.app.admin.DevicePolicyManager: void enableSystemApp(ComponentName,String)>","<android.app.admin.DevicePolicyManager: void enableSystemApp(ComponentName,String)>",0,"{
    throwIfParentInstance(""enableSystemApp"");
    if (mService != null) {
        try {
            mService.enableSystemApp(admin, packageName);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}","{
    throwIfParentInstance(""enableSystemApp"");
    if (mService != null) {
        try {
            mService.enableSystemApp(admin, mContext.getPackageName(), packageName);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Called by profile or device owners to re-enable a system app that was disabled by default
 * when the user was initialized.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param packageName The package to be re-enabled in the calling profile.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 */
","/**
 * Re-enable a system app that was disabled by default when the user was initialized. This
 * function can be called by a device owner, profile owner, or by a delegate given the
 * {@link #DELEGATION_ENABLE_SYSTEM_APP} scope via {@link #setDelegatedScopes}.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or
 * {@code null} if the caller is an enable system app delegate.
 * @param packageName The package to be re-enabled in the calling profile.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 * @see #setDelegatedScopes
 * @see #DELEGATION_PACKAGE_ACCESS
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent API call mService.enableSystemApp(admin, packageName) has an additional parameter mContext.getPackageName() in the late implementation. Therefore, the code change type is 5.","There is no change in the behavior of the API in terms of return values or exceptions thrown, as the method's signature and the exception handling remain the same. The added parameter is internal to the API implementation and its effects are not exposed to the caller in a way that would cause a Compatibility Issue. Thus, there is no CI present."
624,"<android.app.SharedPreferencesImpl.EditorImpl: Editor putStringSet(String,Set<String>)>",25,26,"<android.app.SharedPreferencesImpl.EditorImpl: Editor putStringSet(String,Set<String>)>","<android.app.SharedPreferencesImpl.EditorImpl: Editor putStringSet(String,Set<String>)>",0,"{
    synchronized (this) {
        mModified.put(key, (values == null) ? null : new HashSet<String>(values));
        return this;
    }
}","{
    synchronized (mLock) {
        mModified.put(key, (values == null) ? null : new HashSet<String>(values));
        return this;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change is in the synchronization lock object. It went from 'this' to 'mLock', which is an internal lock object change. This indicates that the locking strategy was modified, but it does not affect the API's external behavior. The type of the code change is 4.","There is no Compatibility Issue since the change in synchronization block lock object does not alter the method's logic or external behavior. The method's signature, return type, arguments, and the values being put into mModified are the same. Hence, there's no potential for different return values/types or exceptions being thrown due to this change."
625,<android.app.Activity: void startLockTask()>,25,26,<android.app.Activity: void startLockTask()>,<android.app.Activity: void startLockTask()>,0,"{
    try {
        ActivityManagerNative.getDefault().startLockTaskMode(mToken);
    } catch (RemoteException e) {
    }
}","{
    try {
        ActivityManager.getService().startLockTaskModeByToken(mToken);
    } catch (RemoteException e) {
    }
}",1,"/**
 * Request to put this Activity in a mode where the user is locked to the
 * current task.
 *
 * This will prevent the user from launching other apps, going to settings, or reaching the
 * home screen. This does not include those apps whose {@link android.R.attr#lockTaskMode}
 * values permit launching while locked.
 *
 * If {@link DevicePolicyManager#isLockTaskPermitted(String)} returns true or
 * lockTaskMode=lockTaskModeAlways for this component then the app will go directly into
 * Lock Task mode. The user will not be able to exit this mode until
 * {@link Activity#stopLockTask()} is called.
 *
 * If {@link DevicePolicyManager#isLockTaskPermitted(String)} returns false
 * then the system will prompt the user with a dialog requesting permission to enter
 * this mode.  When entered through this method the user can exit at any time through
 * an action described by the request dialog.  Calling stopLockTask will also exit the
 * mode.
 *
 * @see android.R.attr#lockTaskMode
 */
","/**
 * Request to put this Activity in a mode where the user is locked to the
 * current task.
 *
 * This will prevent the user from launching other apps, going to settings, or reaching the
 * home screen. This does not include those apps whose {@link android.R.attr#lockTaskMode}
 * values permit launching while locked.
 *
 * If {@link DevicePolicyManager#isLockTaskPermitted(String)} returns true or
 * lockTaskMode=lockTaskModeAlways for this component then the app will go directly into
 * Lock Task mode. The user will not be able to exit this mode until
 * {@link Activity#stopLockTask()} is called.
 *
 * If {@link DevicePolicyManager#isLockTaskPermitted(String)} returns false
 * then the system will prompt the user with a dialog requesting permission to enter
 * this mode.  When entered through this method the user can exit at any time through
 * an action described by the request dialog.  Calling stopLockTask will also exit the
 * mode.
 *
 * @see android.R.attr#lockTaskMode
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation calls a different method on a different object for starting the lock task mode. The method name has changed from `ActivityManagerNative.getDefault().startLockTaskMode` to `ActivityManager.getService().startLockTaskModeByToken`, which indicates the dependent API has changed, so the code change type is 4,5.","Assuming both methods have the same effect and no semantic change, it does not necessarily introduce a compatibility issue since the exception handling has not been altered, and the return type of the method is void so it does not return a different value. Thus, there is no compatibility issue for this change."
627,"<android.bluetooth.le.BluetoothLeAdvertiser: void startAdvertising(AdvertiseSettings,AdvertiseData,AdvertiseData,AdvertiseCallback)>",25,26,"<android.bluetooth.le.BluetoothLeAdvertiser: void startAdvertising(AdvertiseSettings,AdvertiseData,AdvertiseData,AdvertiseCallback)>","<android.bluetooth.le.BluetoothLeAdvertiser: void startAdvertising(AdvertiseSettings,AdvertiseData,AdvertiseData,AdvertiseCallback)>",0,"{
    synchronized (mLeAdvertisers) {
        BluetoothLeUtils.checkAdapterStateOn(mBluetoothAdapter);
        if (callback == null) {
            throw new IllegalArgumentException(""callback cannot be null"");
        }
        if (!mBluetoothAdapter.isMultipleAdvertisementSupported() && !mBluetoothAdapter.isPeripheralModeSupported()) {
            postStartFailure(callback, AdvertiseCallback.ADVERTISE_FAILED_FEATURE_UNSUPPORTED);
            return;
        }
        boolean isConnectable = settings.isConnectable();
        if (totalBytes(advertiseData, isConnectable) > MAX_ADVERTISING_DATA_BYTES || totalBytes(scanResponse, false) > MAX_ADVERTISING_DATA_BYTES) {
            postStartFailure(callback, AdvertiseCallback.ADVERTISE_FAILED_DATA_TOO_LARGE);
            return;
        }
        if (mLeAdvertisers.containsKey(callback)) {
            postStartFailure(callback, AdvertiseCallback.ADVERTISE_FAILED_ALREADY_STARTED);
            return;
        }
        IBluetoothGatt gatt;
        try {
            gatt = mBluetoothManager.getBluetoothGatt();
        } catch (RemoteException e) {
            Log.e(TAG, ""Failed to get Bluetooth gatt - "", e);
            postStartFailure(callback, AdvertiseCallback.ADVERTISE_FAILED_INTERNAL_ERROR);
            return;
        }
        AdvertiseCallbackWrapper wrapper = new AdvertiseCallbackWrapper(callback, advertiseData, scanResponse, settings, gatt);
        wrapper.startRegisteration();
    }
}","{
    synchronized (mLegacyAdvertisers) {
        BluetoothLeUtils.checkAdapterStateOn(mBluetoothAdapter);
        if (callback == null) {
            throw new IllegalArgumentException(""callback cannot be null"");
        }
        boolean isConnectable = settings.isConnectable();
        if (totalBytes(advertiseData, isConnectable) > MAX_LEGACY_ADVERTISING_DATA_BYTES || totalBytes(scanResponse, false) > MAX_LEGACY_ADVERTISING_DATA_BYTES) {
            postStartFailure(callback, AdvertiseCallback.ADVERTISE_FAILED_DATA_TOO_LARGE);
            return;
        }
        if (mLegacyAdvertisers.containsKey(callback)) {
            postStartFailure(callback, AdvertiseCallback.ADVERTISE_FAILED_ALREADY_STARTED);
            return;
        }
        AdvertisingSetParameters.Builder parameters = new AdvertisingSetParameters.Builder();
        parameters.setLegacyMode(true);
        parameters.setConnectable(isConnectable);
        // legacy advertisements we support are always scannable
        parameters.setScannable(true);
        if (settings.getMode() == AdvertiseSettings.ADVERTISE_MODE_LOW_POWER) {
            // 1s
            parameters.setInterval(1600);
        } else if (settings.getMode() == AdvertiseSettings.ADVERTISE_MODE_BALANCED) {
            // 250ms
            parameters.setInterval(400);
        } else if (settings.getMode() == AdvertiseSettings.ADVERTISE_MODE_LOW_LATENCY) {
            // 100ms
            parameters.setInterval(160);
        }
        if (settings.getTxPowerLevel() == AdvertiseSettings.ADVERTISE_TX_POWER_ULTRA_LOW) {
            parameters.setTxPowerLevel(-21);
        } else if (settings.getTxPowerLevel() == AdvertiseSettings.ADVERTISE_TX_POWER_LOW) {
            parameters.setTxPowerLevel(-15);
        } else if (settings.getTxPowerLevel() == AdvertiseSettings.ADVERTISE_TX_POWER_MEDIUM) {
            parameters.setTxPowerLevel(-7);
        } else if (settings.getTxPowerLevel() == AdvertiseSettings.ADVERTISE_TX_POWER_HIGH) {
            parameters.setTxPowerLevel(1);
        }
        int duration = 0;
        int timeoutMillis = settings.getTimeout();
        if (timeoutMillis > 0) {
            duration = (timeoutMillis < 10) ? 1 : timeoutMillis / 10;
        }
        AdvertisingSetCallback wrapped = wrapOldCallback(callback, settings);
        mLegacyAdvertisers.put(callback, wrapped);
        startAdvertisingSet(parameters.build(), advertiseData, scanResponse, null, null, duration, 0, wrapped);
    }
}",1,"/**
 * Start Bluetooth LE Advertising. The {@code advertiseData} will be broadcasted if the
 * operation succeeds. The {@code scanResponse} is returned when a scanning device sends an
 * active scan request. This method returns immediately, the operation status is delivered
 * through {@code callback}.
 * <p>
 * Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}
 *
 * @param settings Settings for Bluetooth LE advertising.
 * @param advertiseData Advertisement data to be advertised in advertisement packet.
 * @param scanResponse Scan response associated with the advertisement data.
 * @param callback Callback for advertising status.
 */
","/**
 * Start Bluetooth LE Advertising. The {@code advertiseData} will be broadcasted if the
 * operation succeeds. The {@code scanResponse} is returned when a scanning device sends an
 * active scan request. This method returns immediately, the operation status is delivered
 * through {@code callback}.
 * <p>
 * Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}
 *
 * @param settings Settings for Bluetooth LE advertising.
 * @param advertiseData Advertisement data to be advertised in advertisement packet.
 * @param scanResponse Scan response associated with the advertisement data.
 * @param callback Callback for advertising status.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,There are multiple changes:,"- New code blocks have been added for setting the advertising parameters, which implies a change in method execution flow and possibly different objects being manipulated."
628,<android.bluetooth.BluetoothGattServer: boolean addService(BluetoothGattService)>,25,26,<android.bluetooth.BluetoothGattServer: boolean addService(BluetoothGattService)>,<android.bluetooth.BluetoothGattServer: boolean addService(BluetoothGattService)>,0,"{
    if (DBG)
        Log.d(TAG, ""addService() - service: "" + service.getUuid());
    if (mService == null || mServerIf == 0)
        return false;
    mServices.add(service);
    try {
        mService.beginServiceDeclaration(mServerIf, service.getType(), service.getInstanceId(), service.getHandles(), new ParcelUuid(service.getUuid()), service.isAdvertisePreferred());
        List<BluetoothGattService> includedServices = service.getIncludedServices();
        for (BluetoothGattService includedService : includedServices) {
            mService.addIncludedService(mServerIf, includedService.getType(), includedService.getInstanceId(), new ParcelUuid(includedService.getUuid()));
        }
        List<BluetoothGattCharacteristic> characteristics = service.getCharacteristics();
        for (BluetoothGattCharacteristic characteristic : characteristics) {
            int permission = ((characteristic.getKeySize() - 7) << 12) + characteristic.getPermissions();
            mService.addCharacteristic(mServerIf, new ParcelUuid(characteristic.getUuid()), characteristic.getProperties(), permission);
            List<BluetoothGattDescriptor> descriptors = characteristic.getDescriptors();
            for (BluetoothGattDescriptor descriptor : descriptors) {
                permission = ((characteristic.getKeySize() - 7) << 12) + descriptor.getPermissions();
                mService.addDescriptor(mServerIf, new ParcelUuid(descriptor.getUuid()), permission);
            }
        }
        mService.endServiceDeclaration(mServerIf);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        return false;
    }
    return true;
}","{
    if (DBG)
        Log.d(TAG, ""addService() - service: "" + service.getUuid());
    if (mService == null || mServerIf == 0)
        return false;
    mPendingService = service;
    try {
        mService.addService(mServerIf, service);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        return false;
    }
    return true;
}",1,"/**
 * Add a service to the list of services to be hosted.
 *
 * <p>Once a service has been addded to the the list, the service and its
 * included characteristics will be provided by the local device.
 *
 * <p>If the local device has already exposed services when this function
 * is called, a service update notification will be sent to all clients.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param service Service to be added to the list of services provided
 * by this device.
 * @return true, if the service has been added successfully
 */
","/**
 * Add a service to the list of services to be hosted.
 *
 * <p>Once a service has been addded to the the list, the service and its
 * included characteristics will be provided by the local device.
 *
 * <p>If the local device has already exposed services when this function
 * is called, a service update notification will be sent to all clients.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param service Service to be added to the list of services provided
 * by this device.
 * @return true, if the service has been added successfully
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The method implementation has significantly changed, with the deletion of the service declaration logic, the handling of included services, characteristics, and descriptors, and the introduction of a singular call to `mService.addService`. These changes include a return statement change (since the behavior and the conditions to return true might be different), control dependency change (as loops and conditions inside the try block have been removed), other statement changes (due to changes in the logic and processing of the service), and dependent API changed (because it now relies on a different method of the `mService` object, `addService` instead of the `beginServiceDeclaration`, `addIncludedService`, `addCharacteristic`, `addDescriptor`, and `endServiceDeclaration` methods), so the change types are 1,3,4,5.","Due to the change in the implementation method from a detailed step-by-step service declaration to a single `addService` call, the conditions under which the method returns true have changed, which could lead to different return values, potentially causing a Compatibility Issue. The deleted statements and the change in the control flow also indicate potential differences in return values. Therefore, the CI type is 1."
630,"<android.app.WallpaperManager: int setBitmap(Bitmap,Rect,boolean)>",25,26,"<android.app.WallpaperManager: int setBitmap(Bitmap,Rect,boolean)>","<android.app.WallpaperManager: int setBitmap(Bitmap,Rect,boolean)>",0,"{
    return setBitmap(fullImage, visibleCropHint, allowBackup, FLAG_SYSTEM);
}","{
    return setBitmap(fullImage, visibleCropHint, allowBackup, FLAG_SYSTEM | FLAG_LOCK);
}",1,"/**
 * Change the current system wallpaper to a bitmap, specifying a hint about
 * which subrectangle of the full image is to be visible.  The OS will then
 * try to best present the given portion of the full image as the static system
 * wallpaper image.  On success, the intent
 * {@link Intent#ACTION_WALLPAPER_CHANGED} is broadcast.
 *
 * <p>Passing {@code null} as the {@code visibleHint} parameter is equivalent to
 * passing (0, 0, {@code fullImage.getWidth()}, {@code fullImage.getHeight()}).
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#SET_WALLPAPER}.
 *
 * @param fullImage A bitmap that will supply the wallpaper imagery.
 * @param visibleCropHint The rectangular subregion of {@code fullImage} that should be
 * displayed as wallpaper.  Passing {@code null} for this parameter means that
 * the full image should be displayed if possible given the image's and device's
 * aspect ratios, etc.
 * @param allowBackup {@code true} if the OS is permitted to back up this wallpaper
 * image for restore to a future device; {@code false} otherwise.
 *
 * @return An integer ID assigned to the newly active wallpaper; or zero on failure.
 *
 * @throws IOException If an error occurs when attempting to set the wallpaper
 * to the provided image.
 * @throws IllegalArgumentException If the {@code visibleCropHint} rectangle is
 * empty or invalid.
 */
","/**
 * Change the current system wallpaper to a bitmap, specifying a hint about
 * which subrectangle of the full image is to be visible.  The OS will then
 * try to best present the given portion of the full image as the static system
 * wallpaper image.  On success, the intent
 * {@link Intent#ACTION_WALLPAPER_CHANGED} is broadcast.
 *
 * <p>Passing {@code null} as the {@code visibleHint} parameter is equivalent to
 * passing (0, 0, {@code fullImage.getWidth()}, {@code fullImage.getHeight()}).
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#SET_WALLPAPER}.
 *
 * @param fullImage A bitmap that will supply the wallpaper imagery.
 * @param visibleCropHint The rectangular subregion of {@code fullImage} that should be
 * displayed as wallpaper.  Passing {@code null} for this parameter means that
 * the full image should be displayed if possible given the image's and device's
 * aspect ratios, etc.
 * @param allowBackup {@code true} if the OS is permitted to back up this wallpaper
 * image for restore to a future device; {@code false} otherwise.
 *
 * @return An integer ID assigned to the newly active wallpaper; or zero on failure.
 *
 * @throws IOException If an error occurs when attempting to set the wallpaper
 * to the provided image.
 * @throws IllegalArgumentException If the {@code visibleCropHint} rectangle is
 * empty or invalid.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change in the late version of the implementation is the addition of FLAG_LOCK to the existing flags in the argument passed to setBitmap(), so the code change type is 4 (Other statement changed).","This change does not lead to a CI as it alters the flags being passed into an internal method call, assuming that the internal method setBitmap() can handle the new flag being added without changing the way it handles its logic for FLAG_SYSTEM only. Therefore, the behavior of the public API should not change, and it will still return the same result code, as no return value or exception handling is modified directly by this flag alteration. Thus, the CI type is 0 (No Compatibility Issue)."
631,<android.view.ViewStub: View inflate()>,25,26,<android.view.ViewStub: View inflate()>,<android.view.ViewStub: View inflate()>,0,"{
    final ViewParent viewParent = getParent();
    if (viewParent != null && viewParent instanceof ViewGroup) {
        if (mLayoutResource != 0) {
            final ViewGroup parent = (ViewGroup) viewParent;
            final LayoutInflater factory;
            if (mInflater != null) {
                factory = mInflater;
            } else {
                factory = LayoutInflater.from(mContext);
            }
            final View view = factory.inflate(mLayoutResource, parent, false);
            if (mInflatedId != NO_ID) {
                view.setId(mInflatedId);
            }
            final int index = parent.indexOfChild(this);
            parent.removeViewInLayout(this);
            final ViewGroup.LayoutParams layoutParams = getLayoutParams();
            if (layoutParams != null) {
                parent.addView(view, index, layoutParams);
            } else {
                parent.addView(view, index);
            }
            mInflatedViewRef = new WeakReference<View>(view);
            if (mInflateListener != null) {
                mInflateListener.onInflate(this, view);
            }
            return view;
        } else {
            throw new IllegalArgumentException(""ViewStub must have a valid layoutResource"");
        }
    } else {
        throw new IllegalStateException(""ViewStub must have a non-null ViewGroup viewParent"");
    }
}","{
    final ViewParent viewParent = getParent();
    if (viewParent != null && viewParent instanceof ViewGroup) {
        if (mLayoutResource != 0) {
            final ViewGroup parent = (ViewGroup) viewParent;
            final View view = inflateViewNoAdd(parent);
            replaceSelfWithView(view, parent);
            mInflatedViewRef = new WeakReference<>(view);
            if (mInflateListener != null) {
                mInflateListener.onInflate(this, view);
            }
            return view;
        } else {
            throw new IllegalArgumentException(""ViewStub must have a valid layoutResource"");
        }
    } else {
        throw new IllegalStateException(""ViewStub must have a non-null ViewGroup viewParent"");
    }
}",1,"/**
 * Inflates the layout resource identified by {@link #getLayoutResource()}
 * and replaces this StubbedView in its parent by the inflated layout resource.
 *
 * @return The inflated layout resource.
 */
","/**
 * Inflates the layout resource identified by {@link #getLayoutResource()}
 * and replaces this StubbedView in its parent by the inflated layout resource.
 *
 * @return The inflated layout resource.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The late version uses new method calls `inflateViewNoAdd(parent)` and `replaceSelfWithView(view, parent)`, which are not present in the early version code, indicating a change in how the view is inflated and added to the parent. This is an indicator of the dependent API changed (5). Although the overall structure of the method hasn't changed significantly, the implementation details have, and without seeing the implementation of the newly introduced methods, it's clear that they involve significant code portions previously inlined in this method. Hence, there is also an 'Other statement changed' (4).","The changes involve the use of two different methods for parts of the inflation process that were originally inline within the method, potentially altering the behavior of how the View is inflated and added to the parent ViewGroup. Because of these changes, it is possible that the returned 'View' could be different due to the internal changes in the inflation logic, which could therefore lead to different return values for the 'inflate' method. This constitutes a Compatibility Issue due to potential different return values or types (1)."
632,<android.app.Activity: void reportFullyDrawn()>,25,26,<android.app.Activity: void reportFullyDrawn()>,<android.app.Activity: void reportFullyDrawn()>,0,"{
    if (mDoReportFullyDrawn) {
        mDoReportFullyDrawn = false;
        try {
            ActivityManagerNative.getDefault().reportActivityFullyDrawn(mToken);
        } catch (RemoteException e) {
        }
    }
}","{
    if (mDoReportFullyDrawn) {
        mDoReportFullyDrawn = false;
        try {
            ActivityManager.getService().reportActivityFullyDrawn(mToken);
        } catch (RemoteException e) {
        }
    }
}",1,"/**
 * Report to the system that your app is now fully drawn, purely for diagnostic
 * purposes (calling it does not impact the visible behavior of the activity).
 * This is only used to help instrument application launch times, so that the
 * app can report when it is fully in a usable state; without this, the only thing
 * the system itself can determine is the point at which the activity's window
 * is <em>first</em> drawn and displayed.  To participate in app launch time
 * measurement, you should always call this method after first launch (when
 * {@link #onCreate(android.os.Bundle)} is called), at the point where you have
 * entirely drawn your UI and populated with all of the significant data.  You
 * can safely call this method any time after first launch as well, in which case
 * it will simply be ignored.
 */
","/**
 * Report to the system that your app is now fully drawn, purely for diagnostic
 * purposes (calling it does not impact the visible behavior of the activity).
 * This is only used to help instrument application launch times, so that the
 * app can report when it is fully in a usable state; without this, the only thing
 * the system itself can determine is the point at which the activity's window
 * is <em>first</em> drawn and displayed.  To participate in app launch time
 * measurement, you should always call this method after first launch (when
 * {@link #onCreate(android.os.Bundle)} is called), at the point where you have
 * entirely drawn your UI and populated with all of the significant data.  You
 * can safely call this method any time after first launch as well, in which case
 * it will simply be ignored.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The change occurs in a dependent API call: from ActivityManagerNative.getDefault().reportActivityFullyDrawn(mToken) to ActivityManager.getService().reportActivityFullyDrawn(mToken). This is a change in how the service is obtained and used, so the code change type is 5.","No compatibility issue arises from this change because the surrounding control structure has not changed and the try block still catches RemoteException without any change in how the exception is processed. The behavior of the method remains effectively the same from the caller's perspective barring any deeper changes in the behavior of the new getService() method, which isn't evident in the provided code fragment – thus based on the information given, there is no CI, so the CI type is 0."
633,<android.accounts.AccountManager.GetAuthTokenByTypeAndFeaturesTask: void doWork()>,25,26,<android.accounts.AccountManager.GetAuthTokenByTypeAndFeaturesTask: void doWork()>,<android.accounts.AccountManager.GetAuthTokenByTypeAndFeaturesTask: void doWork()>,0,"{
    getAccountsByTypeAndFeatures(mAccountType, mFeatures, new AccountManagerCallback<Account[]>() {

        @Override
        public void run(AccountManagerFuture<Account[]> future) {
            Account[] accounts;
            try {
                accounts = future.getResult();
            } catch (OperationCanceledException e) {
                setException(e);
                return;
            } catch (IOException e) {
                setException(e);
                return;
            } catch (AuthenticatorException e) {
                setException(e);
                return;
            }
            mNumAccounts = accounts.length;
            if (accounts.length == 0) {
                if (mActivity != null) {
                    // no accounts, add one now. pretend that the user directly
                    // made this request
                    mFuture = addAccount(mAccountType, mAuthTokenType, mFeatures, mAddAccountOptions, mActivity, mMyCallback, mHandler);
                } else {
                    // send result since we can't prompt to add an account
                    Bundle result = new Bundle();
                    result.putString(KEY_ACCOUNT_NAME, null);
                    result.putString(KEY_ACCOUNT_TYPE, null);
                    result.putString(KEY_AUTHTOKEN, null);
                    try {
                        mResponse.onResult(result);
                    } catch (RemoteException e) {
                    // this will never happen
                    }
                // we are done
                }
            } else if (accounts.length == 1) {
                // have a single account, return an authtoken for it
                if (mActivity == null) {
                    mFuture = getAuthToken(accounts[0], mAuthTokenType, false, /* notifyAuthFailure */
                    mMyCallback, mHandler);
                } else {
                    mFuture = getAuthToken(accounts[0], mAuthTokenType, mLoginOptions, mActivity, mMyCallback, mHandler);
                }
            } else {
                if (mActivity != null) {
                    IAccountManagerResponse chooseResponse = new IAccountManagerResponse.Stub() {

                        @Override
                        public void onResult(Bundle value) throws RemoteException {
                            Account account = new Account(value.getString(KEY_ACCOUNT_NAME), value.getString(KEY_ACCOUNT_TYPE));
                            mFuture = getAuthToken(account, mAuthTokenType, mLoginOptions, mActivity, mMyCallback, mHandler);
                        }

                        @Override
                        public void onError(int errorCode, String errorMessage) throws RemoteException {
                            mResponse.onError(errorCode, errorMessage);
                        }
                    };
                    // have many accounts, launch the chooser
                    Intent intent = new Intent();
                    ComponentName componentName = ComponentName.unflattenFromString(Resources.getSystem().getString(R.string.config_chooseAccountActivity));
                    intent.setClassName(componentName.getPackageName(), componentName.getClassName());
                    intent.putExtra(KEY_ACCOUNTS, accounts);
                    intent.putExtra(KEY_ACCOUNT_MANAGER_RESPONSE, new AccountManagerResponse(chooseResponse));
                    mActivity.startActivity(intent);
                // the result will arrive via the IAccountManagerResponse
                } else {
                    // send result since we can't prompt to select an account
                    Bundle result = new Bundle();
                    result.putString(KEY_ACCOUNTS, null);
                    try {
                        mResponse.onResult(result);
                    } catch (RemoteException e) {
                    // this will never happen
                    }
                // we are done
                }
            }
        }
    }, mHandler);
}","{
    getAccountByTypeAndFeatures(mAccountType, mFeatures, new AccountManagerCallback<Bundle>() {

        @Override
        public void run(AccountManagerFuture<Bundle> future) {
            String accountName = null;
            String accountType = null;
            try {
                Bundle result = future.getResult();
                accountName = result.getString(AccountManager.KEY_ACCOUNT_NAME);
                accountType = result.getString(AccountManager.KEY_ACCOUNT_TYPE);
            } catch (OperationCanceledException e) {
                setException(e);
                return;
            } catch (IOException e) {
                setException(e);
                return;
            } catch (AuthenticatorException e) {
                setException(e);
                return;
            }
            if (accountName == null) {
                if (mActivity != null) {
                    // no accounts, add one now. pretend that the user directly
                    // made this request
                    mFuture = addAccount(mAccountType, mAuthTokenType, mFeatures, mAddAccountOptions, mActivity, mMyCallback, mHandler);
                } else {
                    // send result since we can't prompt to add an account
                    Bundle result = new Bundle();
                    result.putString(KEY_ACCOUNT_NAME, null);
                    result.putString(KEY_ACCOUNT_TYPE, null);
                    result.putString(KEY_AUTHTOKEN, null);
                    result.putBinder(KEY_ACCOUNT_ACCESS_ID, null);
                    try {
                        mResponse.onResult(result);
                    } catch (RemoteException e) {
                    // this will never happen
                    }
                // we are done
                }
            } else {
                mNumAccounts = 1;
                Account account = new Account(accountName, accountType);
                // have a single account, return an authtoken for it
                if (mActivity == null) {
                    mFuture = getAuthToken(account, mAuthTokenType, false, /* notifyAuthFailure */
                    mMyCallback, mHandler);
                } else {
                    mFuture = getAuthToken(account, mAuthTokenType, mLoginOptions, mActivity, mMyCallback, mHandler);
                }
            }
        }
    }, mHandler);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
634,"<android.bluetooth.BluetoothAdapter: void closeProfileProxy(int,BluetoothProfile)>",25,26,"<android.bluetooth.BluetoothAdapter: void closeProfileProxy(int,BluetoothProfile)>","<android.bluetooth.BluetoothAdapter: void closeProfileProxy(int,BluetoothProfile)>",0,"{
    if (proxy == null)
        return;
    switch(profile) {
        case BluetoothProfile.HEADSET:
            BluetoothHeadset headset = (BluetoothHeadset) proxy;
            headset.close();
            break;
        case BluetoothProfile.A2DP:
            BluetoothA2dp a2dp = (BluetoothA2dp) proxy;
            a2dp.close();
            break;
        case BluetoothProfile.A2DP_SINK:
            BluetoothA2dpSink a2dpSink = (BluetoothA2dpSink) proxy;
            a2dpSink.close();
            break;
        case BluetoothProfile.AVRCP_CONTROLLER:
            BluetoothAvrcpController avrcp = (BluetoothAvrcpController) proxy;
            avrcp.close();
            break;
        case BluetoothProfile.INPUT_DEVICE:
            BluetoothInputDevice iDev = (BluetoothInputDevice) proxy;
            iDev.close();
            break;
        case BluetoothProfile.PAN:
            BluetoothPan pan = (BluetoothPan) proxy;
            pan.close();
            break;
        case BluetoothProfile.HEALTH:
            BluetoothHealth health = (BluetoothHealth) proxy;
            health.close();
            break;
        case BluetoothProfile.GATT:
            BluetoothGatt gatt = (BluetoothGatt) proxy;
            gatt.close();
            break;
        case BluetoothProfile.GATT_SERVER:
            BluetoothGattServer gattServer = (BluetoothGattServer) proxy;
            gattServer.close();
            break;
        case BluetoothProfile.MAP:
            BluetoothMap map = (BluetoothMap) proxy;
            map.close();
            break;
        case BluetoothProfile.HEADSET_CLIENT:
            BluetoothHeadsetClient headsetClient = (BluetoothHeadsetClient) proxy;
            headsetClient.close();
            break;
        case BluetoothProfile.SAP:
            BluetoothSap sap = (BluetoothSap) proxy;
            sap.close();
            break;
        case BluetoothProfile.PBAP_CLIENT:
            BluetoothPbapClient pbapClient = (BluetoothPbapClient) proxy;
            pbapClient.close();
            break;
    }
}","{
    if (proxy == null)
        return;
    switch(profile) {
        case BluetoothProfile.HEADSET:
            BluetoothHeadset headset = (BluetoothHeadset) proxy;
            headset.close();
            break;
        case BluetoothProfile.A2DP:
            BluetoothA2dp a2dp = (BluetoothA2dp) proxy;
            a2dp.close();
            break;
        case BluetoothProfile.A2DP_SINK:
            BluetoothA2dpSink a2dpSink = (BluetoothA2dpSink) proxy;
            a2dpSink.close();
            break;
        case BluetoothProfile.AVRCP_CONTROLLER:
            BluetoothAvrcpController avrcp = (BluetoothAvrcpController) proxy;
            avrcp.close();
            break;
        case BluetoothProfile.INPUT_DEVICE:
            BluetoothInputDevice iDev = (BluetoothInputDevice) proxy;
            iDev.close();
            break;
        case BluetoothProfile.PAN:
            BluetoothPan pan = (BluetoothPan) proxy;
            pan.close();
            break;
        case BluetoothProfile.HEALTH:
            BluetoothHealth health = (BluetoothHealth) proxy;
            health.close();
            break;
        case BluetoothProfile.GATT:
            BluetoothGatt gatt = (BluetoothGatt) proxy;
            gatt.close();
            break;
        case BluetoothProfile.GATT_SERVER:
            BluetoothGattServer gattServer = (BluetoothGattServer) proxy;
            gattServer.close();
            break;
        case BluetoothProfile.MAP:
            BluetoothMap map = (BluetoothMap) proxy;
            map.close();
            break;
        case BluetoothProfile.HEADSET_CLIENT:
            BluetoothHeadsetClient headsetClient = (BluetoothHeadsetClient) proxy;
            headsetClient.close();
            break;
        case BluetoothProfile.SAP:
            BluetoothSap sap = (BluetoothSap) proxy;
            sap.close();
            break;
        case BluetoothProfile.PBAP_CLIENT:
            BluetoothPbapClient pbapClient = (BluetoothPbapClient) proxy;
            pbapClient.close();
            break;
        case BluetoothProfile.MAP_CLIENT:
            BluetoothMapClient mapClient = (BluetoothMapClient) proxy;
            mapClient.close();
            break;
        case BluetoothProfile.INPUT_HOST:
            BluetoothInputHost iHost = (BluetoothInputHost) proxy;
            iHost.close();
            break;
    }
}",1,"/**
 * Close the connection of the profile proxy to the Service.
 *
 * <p> Clients should call this when they are no longer using
 * the proxy obtained from {@link #getProfileProxy}.
 * Profile can be one of  {@link BluetoothProfile#HEALTH}, {@link BluetoothProfile#HEADSET} or
 * {@link BluetoothProfile#A2DP}
 *
 * @param profile
 * @param proxy Profile proxy object
 */
","/**
 * Close the connection of the profile proxy to the Service.
 *
 * <p> Clients should call this when they are no longer using
 * the proxy obtained from {@link #getProfileProxy}.
 * Profile can be one of  {@link BluetoothProfile#HEALTH}, {@link BluetoothProfile#HEADSET} or
 * {@link BluetoothProfile#A2DP}
 *
 * @param profile
 * @param proxy Profile proxy object
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,5",0,"The switch statement has two additional cases in the late version for BluetoothProfile.MAP_CLIENT and BluetoothProfile.INPUT_HOST, so the changes are both control dependency (3) and dependent API change (5), since it now depends on the BluetoothMapClient and BluetoothInputHost which might have been introduced or changed in the new version.","There is no compatibility issue because the existing cases and their behavior have not been altered; new cases are added to handle additional profiles, which should not affect existing functionality when using older profiles. Hence, the old profiles should continue to work without compatibility issues, and this is considered an expansion of functionality rather than a breaking change."
635,<android.hardware.camera2.marshal.impl.MarshalQueryableString.MarshalerString: String unmarshal(ByteBuffer)>,25,26,<android.hardware.camera2.marshal.impl.MarshalQueryableString.MarshalerString: String unmarshal(ByteBuffer)>,<android.hardware.camera2.marshal.impl.MarshalQueryableString.MarshalerString: String unmarshal(ByteBuffer)>,0,"{
    // save the current position
    buffer.mark();
    boolean foundNull = false;
    int stringLength = 0;
    while (buffer.hasRemaining()) {
        if (buffer.get() == NUL) {
            foundNull = true;
            break;
        }
        stringLength++;
    }
    if (DEBUG) {
        Log.v(TAG, ""unmarshal - scanned "" + stringLength + "" characters; found null? "" + foundNull);
    }
    if (!foundNull) {
        throw new UnsupportedOperationException(""Strings must be null-terminated"");
    }
    // go back to the previously marked position
    buffer.reset();
    byte[] strBytes = new byte[stringLength + 1];
    // including null character
    buffer.get(strBytes, /*dstOffset*/
    0, stringLength + 1);
    // not including null character
    return new String(strBytes, /*offset*/
    0, stringLength, UTF8_CHARSET);
}","{
    // save the current position
    buffer.mark();
    boolean foundNull = false;
    int stringLength = 0;
    while (buffer.hasRemaining()) {
        if (buffer.get() == NUL) {
            foundNull = true;
            break;
        }
        stringLength++;
    }
    if (DEBUG) {
        Log.v(TAG, ""unmarshal - scanned "" + stringLength + "" characters; found null? "" + foundNull);
    }
    if (!foundNull) {
        throw new UnsupportedOperationException(""Strings must be null-terminated"");
    }
    // go back to the previously marked position
    buffer.reset();
    byte[] strBytes = new byte[stringLength + 1];
    // including null character
    buffer.get(strBytes, /*dstOffset*/
    0, stringLength + 1);
    // not including null character
    return new String(strBytes, /*offset*/
    0, stringLength, PreloadHolder.UTF8_CHARSET);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The only change between the versions is the reference to `UTF8_CHARSET`, which has been replaced from `UTF8_CHARSET` to `PreloadHolder.UTF8_CHARSET`. This indicates that `UTF8_CHARSET` is possibly extracted to a different class or encapsulated within another class (`PreloadHolder`). However, as long as `PreloadHolder.UTF8_CHARSET` refers to the same charset object, the behavior of the method will not change. So the code change type is 5.","There's no compatibility issue if `PreloadHolder.UTF8_CHARSET` continues to provide the same UTF-8 charset as was used in the early version. Assuming `PreloadHolder.UTF8_CHARSET` is a direct reference to the same charset, the method's behavior does not change, so there's no compatibility issue, which is indicated by 0."
636,"<android.app.AlertDialog: int resolveDialogTheme(Context,int)>",25,26,"<android.app.AlertDialog: int resolveDialogTheme(Context,int)>","<android.app.AlertDialog: int resolveDialogTheme(Context,int)>",0,"{
    if (themeResId == THEME_TRADITIONAL) {
        return R.style.Theme_Dialog_Alert;
    } else if (themeResId == THEME_HOLO_DARK) {
        return R.style.Theme_Holo_Dialog_Alert;
    } else if (themeResId == THEME_HOLO_LIGHT) {
        return R.style.Theme_Holo_Light_Dialog_Alert;
    } else if (themeResId == THEME_DEVICE_DEFAULT_DARK) {
        return R.style.Theme_DeviceDefault_Dialog_Alert;
    } else if (themeResId == THEME_DEVICE_DEFAULT_LIGHT) {
        return R.style.Theme_DeviceDefault_Light_Dialog_Alert;
    } else if (themeResId >= 0x01000000) {
        // start of real resource IDs.
        return themeResId;
    } else {
        final TypedValue outValue = new TypedValue();
        context.getTheme().resolveAttribute(R.attr.alertDialogTheme, outValue, true);
        return outValue.resourceId;
    }
}","{
    if (themeResId == THEME_TRADITIONAL) {
        return R.style.Theme_Dialog_Alert;
    } else if (themeResId == THEME_HOLO_DARK) {
        return R.style.Theme_Holo_Dialog_Alert;
    } else if (themeResId == THEME_HOLO_LIGHT) {
        return R.style.Theme_Holo_Light_Dialog_Alert;
    } else if (themeResId == THEME_DEVICE_DEFAULT_DARK) {
        return R.style.Theme_DeviceDefault_Dialog_Alert;
    } else if (themeResId == THEME_DEVICE_DEFAULT_LIGHT) {
        return R.style.Theme_DeviceDefault_Light_Dialog_Alert;
    } else if (ResourceId.isValid(themeResId)) {
        // start of real resource IDs.
        return themeResId;
    } else {
        final TypedValue outValue = new TypedValue();
        context.getTheme().resolveAttribute(R.attr.alertDialogTheme, outValue, true);
        return outValue.resourceId;
    }
}",1,,,-1,,[@StyleRes],-1,-1,-1,-1,-1,-1,"3,5",1,"The condition 'themeResId >= 0x01000000' has been replaced with a call to ResourceId.isValid(themeResId), indicating a control statement change, and this is also a change in the dependent API, thus the code change type is 3,5.","Since the check for a valid resource ID has been altered to use a different method, this can cause the method to return a different value for some inputs (resource IDs that are considered valid might be different in the new implementation). Therefore, the CI type is 1."
637,<android.app.Notification.WearableExtender: WearableExtender clone()>,25,26,<android.app.Notification.WearableExtender: WearableExtender clone()>,<android.app.Notification.WearableExtender: WearableExtender clone()>,0,"{
    WearableExtender that = new WearableExtender();
    that.mActions = new ArrayList<Action>(this.mActions);
    that.mFlags = this.mFlags;
    that.mDisplayIntent = this.mDisplayIntent;
    that.mPages = new ArrayList<Notification>(this.mPages);
    that.mBackground = this.mBackground;
    that.mContentIcon = this.mContentIcon;
    that.mContentIconGravity = this.mContentIconGravity;
    that.mContentActionIndex = this.mContentActionIndex;
    that.mCustomSizePreset = this.mCustomSizePreset;
    that.mCustomContentHeight = this.mCustomContentHeight;
    that.mGravity = this.mGravity;
    that.mHintScreenTimeout = this.mHintScreenTimeout;
    that.mDismissalId = this.mDismissalId;
    return that;
}","{
    WearableExtender that = new WearableExtender();
    that.mActions = new ArrayList<Action>(this.mActions);
    that.mFlags = this.mFlags;
    that.mDisplayIntent = this.mDisplayIntent;
    that.mPages = new ArrayList<Notification>(this.mPages);
    that.mBackground = this.mBackground;
    that.mContentIcon = this.mContentIcon;
    that.mContentIconGravity = this.mContentIconGravity;
    that.mContentActionIndex = this.mContentActionIndex;
    that.mCustomSizePreset = this.mCustomSizePreset;
    that.mCustomContentHeight = this.mCustomContentHeight;
    that.mGravity = this.mGravity;
    that.mHintScreenTimeout = this.mHintScreenTimeout;
    that.mDismissalId = this.mDismissalId;
    that.mBridgeTag = this.mBridgeTag;
    return that;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,"The assignment statement that.mBridgeTag = this.mBridgeTag is the new line added to the later implementation version. So, there is a change in the code other than return statement, exception handling statement, and control dependency, the type of the change is 4. ","The addition of that.mBridgeTag = this.mBridgeTag means that the clone() method may return an object with an additional piece of state in the late version. This represents a potential difference in behavior when the API is used, which is a potential Compatibility Issue of type 1."
638,<android.appwidget.AppWidgetManager: AppWidgetProviderInfo getAppWidgetInfo(int)>,25,26,<android.appwidget.AppWidgetManager: AppWidgetProviderInfo getAppWidgetInfo(int)>,<android.appwidget.AppWidgetManager: AppWidgetProviderInfo getAppWidgetInfo(int)>,0,"{
    if (mService == null) {
        return null;
    }
    try {
        AppWidgetProviderInfo info = mService.getAppWidgetInfo(mPackageName, appWidgetId);
        if (info != null) {
            // Converting complex to dp.
            convertSizesToPixels(info);
        }
        return info;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    if (mService == null) {
        return null;
    }
    try {
        AppWidgetProviderInfo info = mService.getAppWidgetInfo(mPackageName, appWidgetId);
        if (info != null) {
            // Converting complex to dp.
            info.updateDimensions(mDisplayMetrics);
        }
        return info;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Get the available info about the AppWidget.
 *
 * @return A appWidgetId.  If the appWidgetId has not been bound to a provider yet, or
 * you don't have access to that appWidgetId, null is returned.
 */
","/**
 * Get the available info about the AppWidget.
 *
 * @return A appWidgetId.  If the appWidgetId has not been bound to a provider yet, or
 * you don't have access to that appWidgetId, null is returned.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The method call within the if statement has changed from convertSizesToPixels(info) to info.updateDimensions(mDisplayMetrics), which indicates a change in the implementation of how the AppWidgetProviderInfo sizes are being converted. There is also a change in the dependent API since the `updateDimensions` method is being used instead of `convertSizesToPixels`. Therefore, the changes fall under code change types 4 (Other statement changed) and 5 (Dependent API changed).","This modification in how the dimensions are updated (a change from `convertSizesToPixels` to `updateDimensions`) can result in AppWidgetProviderInfo having different dimension values in the late version compared to the early version. This potentially leads to the API returning a different value because the conversion mechanism for dimensions could be different; thus, the CI is of type 1 (Compatibility Issue caused by potential different return values)."
641,<android.app.Activity: boolean isTaskRoot()>,25,26,<android.app.Activity: boolean isTaskRoot()>,<android.app.Activity: boolean isTaskRoot()>,0,"{
    try {
        return ActivityManagerNative.getDefault().getTaskForActivity(mToken, true) >= 0;
    } catch (RemoteException e) {
        return false;
    }
}","{
    try {
        return ActivityManager.getService().getTaskForActivity(mToken, true) >= 0;
    } catch (RemoteException e) {
        return false;
    }
}",1,"/**
 * Return whether this activity is the root of a task.  The root is the
 * first activity in a task.
 *
 * @return True if this is the root activity, else false.
 */
","/**
 * Return whether this activity is the root of a task.  The root is the
 * first activity in a task.
 *
 * @return True if this is the root activity, else false.
 */
",-1,,[@Override],-1,-1,-1,-1,-1,-1,5,0,"The dependent API has changed from ActivityManagerNative.getDefault() to ActivityManager.getService(), so the code change type is 5.","There is no change in the return statements or exception handling that would alter the behaviour of this API method. Both the early and late versions catch the RemoteException and return false. The change is in the method used to acquire the ActivityManager service, which from a client's perspective does not alter the method's contract, nor the value it returns under normal circumstances or error conditions. Thus, there is no Compatibility Issue, and the CI type is 0."
643,<android.app.Activity: void enterPictureInPictureMode()>,25,26,<android.app.Activity: void enterPictureInPictureMode()>,<android.app.Activity: void enterPictureInPictureMode()>,0,"{
    try {
        ActivityManagerNative.getDefault().enterPictureInPictureMode(mToken);
    } catch (RemoteException e) {
    }
}","{
    enterPictureInPictureMode(new PictureInPictureParams.Builder().build());
}",1,"/**
 * Puts the activity in picture-in-picture mode.
 * @see android.R.attr#supportsPictureInPicture
 */
","/**
 * Puts the activity in picture-in-picture mode if possible in the current system state. Any
 * prior calls to {@link #setPictureInPictureParams(PictureInPictureParams)} will still apply
 * when entering picture-in-picture through this call.
 *
 * @see #enterPictureInPictureMode(PictureInPictureParams)
 * @see android.R.attr#supportsPictureInPicture
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation has changed from making a direct call to ActivityManagerNative.getDefault().enterPictureInPictureMode(mToken) to invoking another overloaded version of the same method enterPictureInPictureMode(new PictureInPictureParams.Builder().build()), making this an example of a dependent API change, so the code change type is 4,5.","Even though there is a change in how the method is called, due to the nature of the change where it simply delegates to another method within the same class that presumably handles the picture-in-picture mode entry logic, and considering the lack of changes to exception handling or return statements, this change does not inherently cause potential different return values or exception handling. Thus, no compatibility issue arises from this change, and the CI type is 0."
648,"<android.app.ContextImpl: void sendBroadcastAsUser(Intent,UserHandle,String,int)>",25,26,"<android.app.ContextImpl: void sendBroadcastAsUser(Intent,UserHandle,String,int)>","<android.app.ContextImpl: void sendBroadcastAsUser(Intent,UserHandle,String,int)>",0,"{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, appOp, null, false, false, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, appOp, null, false, false, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,The dependent API call ActivityManagerNative.getDefault() has been changed to ActivityManager.getService() in the late version. There is no change in the method's parameters or control flow. The code change type is 5 because of the dependent API change.,There is no Compatibility Issue because changing the way how the ActivityManager service is obtained does not affect the behavior of the sendBroadcastAsUser API as long as the semantics of how the service is retrieved and operates remains the same. This means the API interface and contract for the developer is unchanged; only the underlying mechanism for obtaining the service differs.
651,<android.app.SharedPreferencesImpl.EditorImpl: Editor clear()>,25,26,<android.app.SharedPreferencesImpl.EditorImpl: Editor clear()>,<android.app.SharedPreferencesImpl.EditorImpl: Editor clear()>,0,"{
    synchronized (this) {
        mClear = true;
        return this;
    }
}","{
    synchronized (mLock) {
        mClear = true;
        return this;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The synchronization lock object changed from 'this' to 'mLock', therefore the code change type is 4.","Despite the change in the lock object, the behavior of the method itself does not change. The method still sets the 'mClear' flag to true and returns 'this'. Therefore, there is no Compatibility Issue, i.e. the CI type is 0."
653,"<android.hardware.camera2.impl.CameraDeviceImpl: void createReprocessableCaptureSession(InputConfiguration,List<Surface>,StateCallback,Handler)>",25,26,"<android.hardware.camera2.impl.CameraDeviceImpl: void createReprocessableCaptureSession(InputConfiguration,List<Surface>,StateCallback,Handler)>","<android.hardware.camera2.impl.CameraDeviceImpl: void createReprocessableCaptureSession(InputConfiguration,List<Surface>,StateCallback,Handler)>",0,"{
    if (DEBUG) {
        Log.d(TAG, ""createReprocessableCaptureSession"");
    }
    if (inputConfig == null) {
        throw new IllegalArgumentException(""inputConfig cannot be null when creating a "" + ""reprocessable capture session"");
    }
    List<OutputConfiguration> outConfigurations = new ArrayList<>(outputs.size());
    for (Surface surface : outputs) {
        outConfigurations.add(new OutputConfiguration(surface));
    }
    createCaptureSessionInternal(inputConfig, outConfigurations, callback, handler, /*isConstrainedHighSpeed*/
    false);
}","{
    if (DEBUG) {
        Log.d(TAG, ""createReprocessableCaptureSession"");
    }
    if (inputConfig == null) {
        throw new IllegalArgumentException(""inputConfig cannot be null when creating a "" + ""reprocessable capture session"");
    }
    List<OutputConfiguration> outConfigurations = new ArrayList<>(outputs.size());
    for (Surface surface : outputs) {
        outConfigurations.add(new OutputConfiguration(surface));
    }
    createCaptureSessionInternal(inputConfig, outConfigurations, callback, handler, /*operatingMode*/
    ICameraDeviceUser.NORMAL_MODE);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The method `createCaptureSessionInternal` now receives `ICameraDeviceUser.NORMAL_MODE` instead of `false` for the last parameter, indicating a change in a literal value that is used to define the operating mode for the session. The code change type is 4, because of a change in the arguments to a method call, and 5 because this change concerns the behavior of a dependent API (`createCaptureSessionInternal`).","There are no Compatibility Issues detected because the change in operating mode is within the expected behavior of the method, and the method's signature, exception handling, and return type remain the same. This change is internal and likely meant to enhance clarity or functionality without altering the external behavior of the `createReprocessableCaptureSession` method as seen by the API consumer. Thus, the change would not lead to different return values or exceptions being thrown."
654,<android.app.ActivityManager: void setWatchHeapLimit(long)>,25,26,<android.app.ActivityManager: void setWatchHeapLimit(long)>,<android.app.ActivityManager: void setWatchHeapLimit(long)>,0,"{
    try {
        ActivityManagerNative.getDefault().setDumpHeapDebugLimit(null, 0, pssSize, mContext.getPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        getService().setDumpHeapDebugLimit(null, 0, pssSize, mContext.getPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Request that the system start watching for the calling process to exceed a pss
 * size as given here.  Once called, the system will look for any occasions where it
 * sees the associated process with a larger pss size and, when this happens, automatically
 * pull a heap dump from it and allow the user to share the data.  Note that this request
 * continues running even if the process is killed and restarted.  To remove the watch,
 * use {@link #clearWatchHeapLimit()}.
 *
 * <p>This API only work if the calling process has been marked as
 * {@link ApplicationInfo#FLAG_DEBUGGABLE} or this is running on a debuggable
 * (userdebug or eng) build.</p>
 *
 * <p>Callers can optionally implement {@link #ACTION_REPORT_HEAP_LIMIT} to directly
 * handle heap limit reports themselves.</p>
 *
 * @param pssSize The size in bytes to set the limit at.
 */
","/**
 * Request that the system start watching for the calling process to exceed a pss
 * size as given here.  Once called, the system will look for any occasions where it
 * sees the associated process with a larger pss size and, when this happens, automatically
 * pull a heap dump from it and allow the user to share the data.  Note that this request
 * continues running even if the process is killed and restarted.  To remove the watch,
 * use {@link #clearWatchHeapLimit()}.
 *
 * <p>This API only work if the calling process has been marked as
 * {@link ApplicationInfo#FLAG_DEBUGGABLE} or this is running on a debuggable
 * (userdebug or eng) build.</p>
 *
 * <p>Callers can optionally implement {@link #ACTION_REPORT_HEAP_LIMIT} to directly
 * handle heap limit reports themselves.</p>
 *
 * @param pssSize The size in bytes to set the limit at.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method called within the try block has changed from ActivityManagerNative.getDefault().setDumpHeapDebugLimit to getService().setDumpHeapDebugLimit, which is a change in the way the service object is obtained. This is classified as Other statement changed (4) and also as Dependent API changed (5) because it involves a change in the method used to obtain the service instance.","There is no Compatibility Issue because the change from ActivityManagerNative.getDefault() to getService() does not alter the behavior of the setWatchHeapLimit method itself. The interface for invoking the method remains the same, and it is supposed to handle the same functionality. It does not affect the return value or exception handling since the method is void and keeps the same exception handling mechanism."
655,<android.app.ActivityTransitionCoordinator: void stripOffscreenViews()>,25,26,<android.app.ActivityTransitionCoordinator: void stripOffscreenViews()>,<android.app.ActivityTransitionCoordinator: void stripOffscreenViews()>,0,"{
    if (mTransitioningViews == null) {
        return;
    }
    Rect r = new Rect();
    for (int i = mTransitioningViews.size() - 1; i >= 0; i--) {
        View view = mTransitioningViews.get(i);
        if (!view.getGlobalVisibleRect(r)) {
            mTransitioningViews.remove(i);
            showView(view, true);
        }
    }
}","{
    if (mTransitioningViews == null) {
        return;
    }
    Rect r = new Rect();
    for (int i = mTransitioningViews.size() - 1; i >= 0; i--) {
        View view = mTransitioningViews.get(i);
        if (!view.getGlobalVisibleRect(r)) {
            mTransitioningViews.remove(i);
            mStrippedTransitioningViews.add(view);
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The behavior within the 'if' condition has changed; while the early version calls showView(view, true), the late version adds the view to mStrippedTransitioningViews. This is an 'Other statement changed' scenario and falls under code change type 4.","There is no Compatibility Issue because the method does not return any value and the new implementation does not throw any new exceptions or change the return type; it only modifies how a list is handled internally within the method. The list that is modified is neither returned by the method nor does it affect control flow - it is an internal implementation detail which should not affect existing external behavior from an API consumer's viewpoint. Therefore, the CI situation is 0."
656,"<android.content.pm.LauncherApps: void startAppDetailsActivity(ComponentName,UserHandle,Rect,Bundle)>",25,26,"<android.content.pm.LauncherApps: void startAppDetailsActivity(ComponentName,UserHandle,Rect,Bundle)>","<android.content.pm.LauncherApps: void startAppDetailsActivity(ComponentName,UserHandle,Rect,Bundle)>",0,"{
    try {
        mService.showAppDetailsAsUser(component, sourceBounds, opts, user);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}","{
    logErrorForInvalidProfileAccess(user);
    try {
        mService.showAppDetailsAsUser(mContext.getPackageName(), component, sourceBounds, opts, user);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}",1,"/**
 * Starts the settings activity to show the application details for a
 * package in the specified profile.
 *
 * @param component The ComponentName of the package to launch settings for.
 * @param user The UserHandle of the profile
 * @param sourceBounds The Rect containing the source bounds of the clicked icon
 * @param opts Options to pass to startActivity
 */
","/**
 * Starts the settings activity to show the application details for a
 * package in the specified profile.
 *
 * @param component The ComponentName of the package to launch settings for.
 * @param user The UserHandle of the profile
 * @param sourceBounds The Rect containing the source bounds of the clicked icon
 * @param opts Options to pass to startActivity
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"There's an additional method call to `logErrorForInvalidProfileAccess(user)` before the try-catch block, which is not inside any control statement and doesn't change the logic of exception handling or returns. Therefore, the code change type is 4.","This change adds a logging mechanism but doesn't affect the functional behavior regarding return values or exception handling faced by the caller, and as a result, does not pose a compatibility issue. Thus, CI type is 0."
657,"<android.app.ActivityManager: void moveTaskToFront(int,int,Bundle)>",25,26,"<android.app.ActivityManager: void moveTaskToFront(int,int,Bundle)>","<android.app.ActivityManager: void moveTaskToFront(int,int,Bundle)>",0,"{
    try {
        ActivityManagerNative.getDefault().moveTaskToFront(taskId, flags, options);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        getService().moveTaskToFront(taskId, flags, options);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Ask that the task associated with a given task ID be moved to the
 * front of the stack, so it is now visible to the user.  Requires that
 * the caller hold permission {@link android.Manifest.permission#REORDER_TASKS}
 * or a SecurityException will be thrown.
 *
 * @param taskId The identifier of the task to be moved, as found in
 * {@link RunningTaskInfo} or {@link RecentTaskInfo}.
 * @param flags Additional operational flags, 0 or more of
 * {@link #MOVE_TASK_WITH_HOME}, {@link #MOVE_TASK_NO_USER_ACTION}.
 * @param options Additional options for the operation, either null or
 * as per {@link Context#startActivity(Intent, android.os.Bundle)
 * Context.startActivity(Intent, Bundle)}.
 */
","/**
 * Ask that the task associated with a given task ID be moved to the
 * front of the stack, so it is now visible to the user.
 *
 * @param taskId The identifier of the task to be moved, as found in
 * {@link RunningTaskInfo} or {@link RecentTaskInfo}.
 * @param flags Additional operational flags.
 * @param options Additional options for the operation, either null or
 * as per {@link Context#startActivity(Intent, android.os.Bundle)
 * Context.startActivity(Intent, Bundle)}.
 */
",-1,,[@RequiresPermission(android.Manifest.permission.REORDER_TASKS)],-1,-1,-1,-1,-1,-1,5,0,"The method called within the try block changed from `ActivityManagerNative.getDefault().moveTaskToFront(...)` to `getService().moveTaskToFront(...)`, which indicates a change in the dependent API being used; hence the code change type is 5.","There is no indication that the change in the dependent API results in a different behavior regarding return values or exceptions being thrown since the actual implementation of the `moveTaskToFront` method and the surrounding try-catch block remain the same. Therefore, the pred_CI is 0, indicating no compatibility issue."
658,<android.animation.FloatKeyframeSet: float getFloatValue(float)>,25,26,<android.animation.FloatKeyframeSet: float getFloatValue(float)>,<android.animation.FloatKeyframeSet: float getFloatValue(float)>,0,"{
    if (mNumKeyframes == 2) {
        if (firstTime) {
            firstTime = false;
            firstValue = ((FloatKeyframe) mKeyframes.get(0)).getFloatValue();
            lastValue = ((FloatKeyframe) mKeyframes.get(1)).getFloatValue();
            deltaValue = lastValue - firstValue;
        }
        if (mInterpolator != null) {
            fraction = mInterpolator.getInterpolation(fraction);
        }
        if (mEvaluator == null) {
            return firstValue + fraction * deltaValue;
        } else {
            return ((Number) mEvaluator.evaluate(fraction, firstValue, lastValue)).floatValue();
        }
    }
    if (fraction <= 0f) {
        final FloatKeyframe prevKeyframe = (FloatKeyframe) mKeyframes.get(0);
        final FloatKeyframe nextKeyframe = (FloatKeyframe) mKeyframes.get(1);
        float prevValue = prevKeyframe.getFloatValue();
        float nextValue = nextKeyframe.getFloatValue();
        float prevFraction = prevKeyframe.getFraction();
        float nextFraction = nextKeyframe.getFraction();
        final TimeInterpolator interpolator = nextKeyframe.getInterpolator();
        if (interpolator != null) {
            fraction = interpolator.getInterpolation(fraction);
        }
        float intervalFraction = (fraction - prevFraction) / (nextFraction - prevFraction);
        return mEvaluator == null ? prevValue + intervalFraction * (nextValue - prevValue) : ((Number) mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).floatValue();
    } else if (fraction >= 1f) {
        final FloatKeyframe prevKeyframe = (FloatKeyframe) mKeyframes.get(mNumKeyframes - 2);
        final FloatKeyframe nextKeyframe = (FloatKeyframe) mKeyframes.get(mNumKeyframes - 1);
        float prevValue = prevKeyframe.getFloatValue();
        float nextValue = nextKeyframe.getFloatValue();
        float prevFraction = prevKeyframe.getFraction();
        float nextFraction = nextKeyframe.getFraction();
        final TimeInterpolator interpolator = nextKeyframe.getInterpolator();
        if (interpolator != null) {
            fraction = interpolator.getInterpolation(fraction);
        }
        float intervalFraction = (fraction - prevFraction) / (nextFraction - prevFraction);
        return mEvaluator == null ? prevValue + intervalFraction * (nextValue - prevValue) : ((Number) mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).floatValue();
    }
    FloatKeyframe prevKeyframe = (FloatKeyframe) mKeyframes.get(0);
    for (int i = 1; i < mNumKeyframes; ++i) {
        FloatKeyframe nextKeyframe = (FloatKeyframe) mKeyframes.get(i);
        if (fraction < nextKeyframe.getFraction()) {
            final TimeInterpolator interpolator = nextKeyframe.getInterpolator();
            float intervalFraction = (fraction - prevKeyframe.getFraction()) / (nextKeyframe.getFraction() - prevKeyframe.getFraction());
            float prevValue = prevKeyframe.getFloatValue();
            float nextValue = nextKeyframe.getFloatValue();
            // Apply interpolator on the proportional duration.
            if (interpolator != null) {
                intervalFraction = interpolator.getInterpolation(intervalFraction);
            }
            return mEvaluator == null ? prevValue + intervalFraction * (nextValue - prevValue) : ((Number) mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).floatValue();
        }
        prevKeyframe = nextKeyframe;
    }
    // shouldn't get here
    return ((Number) mKeyframes.get(mNumKeyframes - 1).getValue()).floatValue();
}","{
    if (fraction <= 0f) {
        final FloatKeyframe prevKeyframe = (FloatKeyframe) mKeyframes.get(0);
        final FloatKeyframe nextKeyframe = (FloatKeyframe) mKeyframes.get(1);
        float prevValue = prevKeyframe.getFloatValue();
        float nextValue = nextKeyframe.getFloatValue();
        float prevFraction = prevKeyframe.getFraction();
        float nextFraction = nextKeyframe.getFraction();
        final TimeInterpolator interpolator = nextKeyframe.getInterpolator();
        if (interpolator != null) {
            fraction = interpolator.getInterpolation(fraction);
        }
        float intervalFraction = (fraction - prevFraction) / (nextFraction - prevFraction);
        return mEvaluator == null ? prevValue + intervalFraction * (nextValue - prevValue) : ((Number) mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).floatValue();
    } else if (fraction >= 1f) {
        final FloatKeyframe prevKeyframe = (FloatKeyframe) mKeyframes.get(mNumKeyframes - 2);
        final FloatKeyframe nextKeyframe = (FloatKeyframe) mKeyframes.get(mNumKeyframes - 1);
        float prevValue = prevKeyframe.getFloatValue();
        float nextValue = nextKeyframe.getFloatValue();
        float prevFraction = prevKeyframe.getFraction();
        float nextFraction = nextKeyframe.getFraction();
        final TimeInterpolator interpolator = nextKeyframe.getInterpolator();
        if (interpolator != null) {
            fraction = interpolator.getInterpolation(fraction);
        }
        float intervalFraction = (fraction - prevFraction) / (nextFraction - prevFraction);
        return mEvaluator == null ? prevValue + intervalFraction * (nextValue - prevValue) : ((Number) mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).floatValue();
    }
    FloatKeyframe prevKeyframe = (FloatKeyframe) mKeyframes.get(0);
    for (int i = 1; i < mNumKeyframes; ++i) {
        FloatKeyframe nextKeyframe = (FloatKeyframe) mKeyframes.get(i);
        if (fraction < nextKeyframe.getFraction()) {
            final TimeInterpolator interpolator = nextKeyframe.getInterpolator();
            float intervalFraction = (fraction - prevKeyframe.getFraction()) / (nextKeyframe.getFraction() - prevKeyframe.getFraction());
            float prevValue = prevKeyframe.getFloatValue();
            float nextValue = nextKeyframe.getFloatValue();
            // Apply interpolator on the proportional duration.
            if (interpolator != null) {
                intervalFraction = interpolator.getInterpolation(intervalFraction);
            }
            return mEvaluator == null ? prevValue + intervalFraction * (nextValue - prevValue) : ((Number) mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).floatValue();
        }
        prevKeyframe = nextKeyframe;
    }
    // shouldn't get here
    return ((Number) mKeyframes.get(mNumKeyframes - 1).getValue()).floatValue();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
660,<android.widget.ListPopupWindow: void show()>,25,26,<android.widget.ListPopupWindow: void show()>,<android.widget.ListPopupWindow: void show()>,0,"{
    int height = buildDropDown();
    final boolean noInputMethod = isInputMethodNotNeeded();
    mPopup.setAllowScrollingAnchorParent(!noInputMethod);
    mPopup.setWindowLayoutType(mDropDownWindowLayoutType);
    if (mPopup.isShowing()) {
        final int widthSpec;
        if (mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT) {
            // The call to PopupWindow's update method below can accept -1 for any
            // value you do not want to update.
            widthSpec = -1;
        } else if (mDropDownWidth == ViewGroup.LayoutParams.WRAP_CONTENT) {
            widthSpec = getAnchorView().getWidth();
        } else {
            widthSpec = mDropDownWidth;
        }
        final int heightSpec;
        if (mDropDownHeight == ViewGroup.LayoutParams.MATCH_PARENT) {
            // The call to PopupWindow's update method below can accept -1 for any
            // value you do not want to update.
            heightSpec = noInputMethod ? height : ViewGroup.LayoutParams.MATCH_PARENT;
            if (noInputMethod) {
                mPopup.setWidth(mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT ? ViewGroup.LayoutParams.MATCH_PARENT : 0);
                mPopup.setHeight(0);
            } else {
                mPopup.setWidth(mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT ? ViewGroup.LayoutParams.MATCH_PARENT : 0);
                mPopup.setHeight(ViewGroup.LayoutParams.MATCH_PARENT);
            }
        } else if (mDropDownHeight == ViewGroup.LayoutParams.WRAP_CONTENT) {
            heightSpec = height;
        } else {
            heightSpec = mDropDownHeight;
        }
        mPopup.setOutsideTouchable(!mForceIgnoreOutsideTouch && !mDropDownAlwaysVisible);
        mPopup.update(getAnchorView(), mDropDownHorizontalOffset, mDropDownVerticalOffset, (widthSpec < 0) ? -1 : widthSpec, (heightSpec < 0) ? -1 : heightSpec);
    } else {
        final int widthSpec;
        if (mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT) {
            widthSpec = ViewGroup.LayoutParams.MATCH_PARENT;
        } else {
            if (mDropDownWidth == ViewGroup.LayoutParams.WRAP_CONTENT) {
                widthSpec = getAnchorView().getWidth();
            } else {
                widthSpec = mDropDownWidth;
            }
        }
        final int heightSpec;
        if (mDropDownHeight == ViewGroup.LayoutParams.MATCH_PARENT) {
            heightSpec = ViewGroup.LayoutParams.MATCH_PARENT;
        } else {
            if (mDropDownHeight == ViewGroup.LayoutParams.WRAP_CONTENT) {
                heightSpec = height;
            } else {
                heightSpec = mDropDownHeight;
            }
        }
        mPopup.setWidth(widthSpec);
        mPopup.setHeight(heightSpec);
        mPopup.setClipToScreenEnabled(true);
        // use outside touchable to dismiss drop down when touching outside of it, so
        // only set this if the dropdown is not always visible
        mPopup.setOutsideTouchable(!mForceIgnoreOutsideTouch && !mDropDownAlwaysVisible);
        mPopup.setTouchInterceptor(mTouchInterceptor);
        mPopup.setEpicenterBounds(mEpicenterBounds);
        mPopup.showAsDropDown(getAnchorView(), mDropDownHorizontalOffset, mDropDownVerticalOffset, mDropDownGravity);
        mDropDownList.setSelection(ListView.INVALID_POSITION);
        if (!mModal || mDropDownList.isInTouchMode()) {
            clearListSelection();
        }
        if (!mModal) {
            mHandler.post(mHideSelector);
        }
    }
}","{
    int height = buildDropDown();
    final boolean noInputMethod = isInputMethodNotNeeded();
    mPopup.setAllowScrollingAnchorParent(!noInputMethod);
    mPopup.setWindowLayoutType(mDropDownWindowLayoutType);
    if (mPopup.isShowing()) {
        if (!getAnchorView().isAttachedToWindow()) {
            // Don't update position if the anchor view is detached from window.
            return;
        }
        final int widthSpec;
        if (mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT) {
            // The call to PopupWindow's update method below can accept -1 for any
            // value you do not want to update.
            widthSpec = -1;
        } else if (mDropDownWidth == ViewGroup.LayoutParams.WRAP_CONTENT) {
            widthSpec = getAnchorView().getWidth();
        } else {
            widthSpec = mDropDownWidth;
        }
        final int heightSpec;
        if (mDropDownHeight == ViewGroup.LayoutParams.MATCH_PARENT) {
            // The call to PopupWindow's update method below can accept -1 for any
            // value you do not want to update.
            heightSpec = noInputMethod ? height : ViewGroup.LayoutParams.MATCH_PARENT;
            if (noInputMethod) {
                mPopup.setWidth(mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT ? ViewGroup.LayoutParams.MATCH_PARENT : 0);
                mPopup.setHeight(0);
            } else {
                mPopup.setWidth(mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT ? ViewGroup.LayoutParams.MATCH_PARENT : 0);
                mPopup.setHeight(ViewGroup.LayoutParams.MATCH_PARENT);
            }
        } else if (mDropDownHeight == ViewGroup.LayoutParams.WRAP_CONTENT) {
            heightSpec = height;
        } else {
            heightSpec = mDropDownHeight;
        }
        mPopup.setOutsideTouchable(!mForceIgnoreOutsideTouch && !mDropDownAlwaysVisible);
        mPopup.update(getAnchorView(), mDropDownHorizontalOffset, mDropDownVerticalOffset, (widthSpec < 0) ? -1 : widthSpec, (heightSpec < 0) ? -1 : heightSpec);
    } else {
        final int widthSpec;
        if (mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT) {
            widthSpec = ViewGroup.LayoutParams.MATCH_PARENT;
        } else {
            if (mDropDownWidth == ViewGroup.LayoutParams.WRAP_CONTENT) {
                widthSpec = getAnchorView().getWidth();
            } else {
                widthSpec = mDropDownWidth;
            }
        }
        final int heightSpec;
        if (mDropDownHeight == ViewGroup.LayoutParams.MATCH_PARENT) {
            heightSpec = ViewGroup.LayoutParams.MATCH_PARENT;
        } else {
            if (mDropDownHeight == ViewGroup.LayoutParams.WRAP_CONTENT) {
                heightSpec = height;
            } else {
                heightSpec = mDropDownHeight;
            }
        }
        mPopup.setWidth(widthSpec);
        mPopup.setHeight(heightSpec);
        mPopup.setClipToScreenEnabled(true);
        // use outside touchable to dismiss drop down when touching outside of it, so
        // only set this if the dropdown is not always visible
        mPopup.setOutsideTouchable(!mForceIgnoreOutsideTouch && !mDropDownAlwaysVisible);
        mPopup.setTouchInterceptor(mTouchInterceptor);
        mPopup.setEpicenterBounds(mEpicenterBounds);
        if (mOverlapAnchorSet) {
            mPopup.setOverlapAnchor(mOverlapAnchor);
        }
        mPopup.showAsDropDown(getAnchorView(), mDropDownHorizontalOffset, mDropDownVerticalOffset, mDropDownGravity);
        mDropDownList.setSelection(ListView.INVALID_POSITION);
        if (!mModal || mDropDownList.isInTouchMode()) {
            clearListSelection();
        }
        if (!mModal) {
            mHandler.post(mHideSelector);
        }
    }
}",1,"/**
 * Show the popup list. If the list is already showing, this method
 * will recalculate the popup's size and position.
 */
","/**
 * Show the popup list. If the list is already showing, this method
 * will recalculate the popup's size and position.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
661,"<android.app.FragmentManagerImpl: void moveToState(Fragment,int,int,int,boolean)>",25,26,"<android.app.FragmentManagerImpl: void moveToState(Fragment,int,int,int,boolean)>","<android.app.FragmentManagerImpl: void moveToState(Fragment,int,int,int,boolean)>",0,"{
    if (DEBUG && false)
        Log.v(TAG, ""moveToState: "" + f + "" oldState="" + f.mState + "" newState="" + newState + "" mRemoving="" + f.mRemoving + "" Callers="" + Debug.getCallers(5));
    // Fragments that are not currently added will sit in the onCreate() state.
    if ((!f.mAdded || f.mDetached) && newState > Fragment.CREATED) {
        newState = Fragment.CREATED;
    }
    if (f.mRemoving && newState > f.mState) {
        // While removing a fragment, we can't change it to a higher state.
        newState = f.mState;
    }
    // if it's not already started.
    if (f.mDeferStart && f.mState < Fragment.STARTED && newState > Fragment.STOPPED) {
        newState = Fragment.STOPPED;
    }
    if (f.mState < newState) {
        // being reloaded from the layout.
        if (f.mFromLayout && !f.mInLayout) {
            return;
        }
        if (f.mAnimatingAway != null) {
            // The fragment is currently being animated...  but!  Now we
            // want to move our state back up.  Give up on waiting for the
            // animation, move to whatever the final state should be once
            // the animation is done, and then we can proceed from there.
            f.mAnimatingAway = null;
            moveToState(f, f.mStateAfterAnimating, 0, 0, true);
        }
        switch(f.mState) {
            case Fragment.INITIALIZING:
                if (DEBUG)
                    Log.v(TAG, ""moveto CREATED: "" + f);
                if (f.mSavedFragmentState != null) {
                    f.mSavedViewState = f.mSavedFragmentState.getSparseParcelableArray(FragmentManagerImpl.VIEW_STATE_TAG);
                    f.mTarget = getFragment(f.mSavedFragmentState, FragmentManagerImpl.TARGET_STATE_TAG);
                    if (f.mTarget != null) {
                        f.mTargetRequestCode = f.mSavedFragmentState.getInt(FragmentManagerImpl.TARGET_REQUEST_CODE_STATE_TAG, 0);
                    }
                    f.mUserVisibleHint = f.mSavedFragmentState.getBoolean(FragmentManagerImpl.USER_VISIBLE_HINT_TAG, true);
                    if (!f.mUserVisibleHint) {
                        f.mDeferStart = true;
                        if (newState > Fragment.STOPPED) {
                            newState = Fragment.STOPPED;
                        }
                    }
                }
                f.mHost = mHost;
                f.mParentFragment = mParent;
                f.mFragmentManager = mParent != null ? mParent.mChildFragmentManager : mHost.getFragmentManagerImpl();
                f.mCalled = false;
                f.onAttach(mHost.getContext());
                if (!f.mCalled) {
                    throw new SuperNotCalledException(""Fragment "" + f + "" did not call through to super.onAttach()"");
                }
                if (f.mParentFragment == null) {
                    mHost.onAttachFragment(f);
                } else {
                    f.mParentFragment.onAttachFragment(f);
                }
                if (!f.mRetaining) {
                    f.performCreate(f.mSavedFragmentState);
                } else {
                    f.restoreChildFragmentState(f.mSavedFragmentState, true);
                    f.mState = Fragment.CREATED;
                }
                f.mRetaining = false;
                if (f.mFromLayout) {
                    // For fragments that are part of the content view
                    // layout, we need to instantiate the view immediately
                    // and the inflater will take care of adding it.
                    f.mView = f.performCreateView(f.getLayoutInflater(f.mSavedFragmentState), null, f.mSavedFragmentState);
                    if (f.mView != null) {
                        f.mView.setSaveFromParentEnabled(false);
                        if (f.mHidden)
                            f.mView.setVisibility(View.GONE);
                        f.onViewCreated(f.mView, f.mSavedFragmentState);
                    }
                }
            case Fragment.CREATED:
                if (newState > Fragment.CREATED) {
                    if (DEBUG)
                        Log.v(TAG, ""moveto ACTIVITY_CREATED: "" + f);
                    if (!f.mFromLayout) {
                        ViewGroup container = null;
                        if (f.mContainerId != 0) {
                            if (f.mContainerId == View.NO_ID) {
                                throwException(new IllegalArgumentException(""Cannot create fragment "" + f + "" for a container view with no id""));
                            }
                            container = (ViewGroup) mContainer.onFindViewById(f.mContainerId);
                            if (container == null && !f.mRestored) {
                                String resName;
                                try {
                                    resName = f.getResources().getResourceName(f.mContainerId);
                                } catch (NotFoundException e) {
                                    resName = ""unknown"";
                                }
                                throwException(new IllegalArgumentException(""No view found for id 0x"" + Integer.toHexString(f.mContainerId) + "" ("" + resName + "") for fragment "" + f));
                            }
                        }
                        f.mContainer = container;
                        f.mView = f.performCreateView(f.getLayoutInflater(f.mSavedFragmentState), container, f.mSavedFragmentState);
                        if (f.mView != null) {
                            f.mView.setSaveFromParentEnabled(false);
                            if (container != null) {
                                Animator anim = loadAnimator(f, transit, true, transitionStyle);
                                if (anim != null) {
                                    anim.setTarget(f.mView);
                                    setHWLayerAnimListenerIfAlpha(f.mView, anim);
                                    anim.start();
                                }
                                container.addView(f.mView);
                            }
                            if (f.mHidden)
                                f.mView.setVisibility(View.GONE);
                            f.onViewCreated(f.mView, f.mSavedFragmentState);
                        }
                    }
                    f.performActivityCreated(f.mSavedFragmentState);
                    if (f.mView != null) {
                        f.restoreViewState(f.mSavedFragmentState);
                    }
                    f.mSavedFragmentState = null;
                }
            case Fragment.ACTIVITY_CREATED:
                if (newState > Fragment.ACTIVITY_CREATED) {
                    f.mState = Fragment.STOPPED;
                }
            case Fragment.STOPPED:
                if (newState > Fragment.STOPPED) {
                    if (DEBUG)
                        Log.v(TAG, ""moveto STARTED: "" + f);
                    f.performStart();
                }
            case Fragment.STARTED:
                if (newState > Fragment.STARTED) {
                    if (DEBUG)
                        Log.v(TAG, ""moveto RESUMED: "" + f);
                    f.performResume();
                    // Get rid of this in case we saved it and never needed it.
                    f.mSavedFragmentState = null;
                    f.mSavedViewState = null;
                }
        }
    } else if (f.mState > newState) {
        switch(f.mState) {
            case Fragment.RESUMED:
                if (newState < Fragment.RESUMED) {
                    if (DEBUG)
                        Log.v(TAG, ""movefrom RESUMED: "" + f);
                    f.performPause();
                }
            case Fragment.STARTED:
                if (newState < Fragment.STARTED) {
                    if (DEBUG)
                        Log.v(TAG, ""movefrom STARTED: "" + f);
                    f.performStop();
                }
            case Fragment.STOPPED:
            case Fragment.ACTIVITY_CREATED:
                if (newState < Fragment.ACTIVITY_CREATED) {
                    if (DEBUG)
                        Log.v(TAG, ""movefrom ACTIVITY_CREATED: "" + f);
                    if (f.mView != null) {
                        // done already.
                        if (mHost.onShouldSaveFragmentState(f) && f.mSavedViewState == null) {
                            saveFragmentViewState(f);
                        }
                    }
                    f.performDestroyView();
                    if (f.mView != null && f.mContainer != null) {
                        Animator anim = null;
                        if (mCurState > Fragment.INITIALIZING && !mDestroyed) {
                            anim = loadAnimator(f, transit, false, transitionStyle);
                        }
                        if (anim != null) {
                            final ViewGroup container = f.mContainer;
                            final View view = f.mView;
                            final Fragment fragment = f;
                            container.startViewTransition(view);
                            f.mAnimatingAway = anim;
                            f.mStateAfterAnimating = newState;
                            anim.addListener(new AnimatorListenerAdapter() {

                                @Override
                                public void onAnimationEnd(Animator anim) {
                                    container.endViewTransition(view);
                                    if (fragment.mAnimatingAway != null) {
                                        fragment.mAnimatingAway = null;
                                        moveToState(fragment, fragment.mStateAfterAnimating, 0, 0, false);
                                    }
                                }
                            });
                            anim.setTarget(f.mView);
                            setHWLayerAnimListenerIfAlpha(f.mView, anim);
                            anim.start();
                        }
                        f.mContainer.removeView(f.mView);
                    }
                    f.mContainer = null;
                    f.mView = null;
                }
            case Fragment.CREATED:
                if (newState < Fragment.CREATED) {
                    if (mDestroyed) {
                        if (f.mAnimatingAway != null) {
                            // The fragment's containing activity is
                            // being destroyed, but this fragment is
                            // currently animating away.  Stop the
                            // animation right now -- it is not needed,
                            // and we can't wait any more on destroying
                            // the fragment.
                            Animator anim = f.mAnimatingAway;
                            f.mAnimatingAway = null;
                            anim.cancel();
                        }
                    }
                    if (f.mAnimatingAway != null) {
                        // We are waiting for the fragment's view to finish
                        // animating away.  Just make a note of the state
                        // the fragment now should move to once the animation
                        // is done.
                        f.mStateAfterAnimating = newState;
                        newState = Fragment.CREATED;
                    } else {
                        if (DEBUG)
                            Log.v(TAG, ""movefrom CREATED: "" + f);
                        if (!f.mRetaining) {
                            f.performDestroy();
                        } else {
                            f.mState = Fragment.INITIALIZING;
                        }
                        f.performDetach();
                        if (!keepActive) {
                            if (!f.mRetaining) {
                                makeInactive(f);
                            } else {
                                f.mHost = null;
                                f.mParentFragment = null;
                                f.mFragmentManager = null;
                            }
                        }
                    }
                }
        }
    }
    if (f.mState != newState) {
        Log.w(TAG, ""moveToState: Fragment state for "" + f + "" not updated inline; "" + ""expected state "" + newState + "" found "" + f.mState);
        f.mState = newState;
    }
}","{
    if (DEBUG && false)
        Log.v(TAG, ""moveToState: "" + f + "" oldState="" + f.mState + "" newState="" + newState + "" mRemoving="" + f.mRemoving + "" Callers="" + Debug.getCallers(5));
    // Fragments that are not currently added will sit in the onCreate() state.
    if ((!f.mAdded || f.mDetached) && newState > Fragment.CREATED) {
        newState = Fragment.CREATED;
    }
    if (f.mRemoving && newState > f.mState) {
        if (f.mState == Fragment.INITIALIZING && f.isInBackStack()) {
            // Allow the fragment to be created so that it can be saved later.
            newState = Fragment.CREATED;
        } else {
            // While removing a fragment, we can't change it to a higher state.
            newState = f.mState;
        }
    }
    // if it's not already started.
    if (f.mDeferStart && f.mState < Fragment.STARTED && newState > Fragment.STOPPED) {
        newState = Fragment.STOPPED;
    }
    if (f.mState <= newState) {
        // being reloaded from the layout.
        if (f.mFromLayout && !f.mInLayout) {
            return;
        }
        if (f.getAnimatingAway() != null) {
            // The fragment is currently being animated...  but!  Now we
            // want to move our state back up.  Give up on waiting for the
            // animation, move to whatever the final state should be once
            // the animation is done, and then we can proceed from there.
            f.setAnimatingAway(null);
            moveToState(f, f.getStateAfterAnimating(), 0, 0, true);
        }
        switch(f.mState) {
            case Fragment.INITIALIZING:
                if (newState > Fragment.INITIALIZING) {
                    if (DEBUG)
                        Log.v(TAG, ""moveto CREATED: "" + f);
                    if (f.mSavedFragmentState != null) {
                        f.mSavedViewState = f.mSavedFragmentState.getSparseParcelableArray(FragmentManagerImpl.VIEW_STATE_TAG);
                        f.mTarget = getFragment(f.mSavedFragmentState, FragmentManagerImpl.TARGET_STATE_TAG);
                        if (f.mTarget != null) {
                            f.mTargetRequestCode = f.mSavedFragmentState.getInt(FragmentManagerImpl.TARGET_REQUEST_CODE_STATE_TAG, 0);
                        }
                        f.mUserVisibleHint = f.mSavedFragmentState.getBoolean(FragmentManagerImpl.USER_VISIBLE_HINT_TAG, true);
                        if (!f.mUserVisibleHint) {
                            f.mDeferStart = true;
                            if (newState > Fragment.STOPPED) {
                                newState = Fragment.STOPPED;
                            }
                        }
                    }
                    f.mHost = mHost;
                    f.mParentFragment = mParent;
                    f.mFragmentManager = mParent != null ? mParent.mChildFragmentManager : mHost.getFragmentManagerImpl();
                    // so that this one can rely on it as an initialized dependency.
                    if (f.mTarget != null) {
                        if (mActive.get(f.mTarget.mIndex) != f.mTarget) {
                            throw new IllegalStateException(""Fragment "" + f + "" declared target fragment "" + f.mTarget + "" that does not belong to this FragmentManager!"");
                        }
                        if (f.mTarget.mState < Fragment.CREATED) {
                            moveToState(f.mTarget, Fragment.CREATED, 0, 0, true);
                        }
                    }
                    dispatchOnFragmentPreAttached(f, mHost.getContext(), false);
                    f.mCalled = false;
                    f.onAttach(mHost.getContext());
                    if (!f.mCalled) {
                        throw new SuperNotCalledException(""Fragment "" + f + "" did not call through to super.onAttach()"");
                    }
                    if (f.mParentFragment == null) {
                        mHost.onAttachFragment(f);
                    } else {
                        f.mParentFragment.onAttachFragment(f);
                    }
                    dispatchOnFragmentAttached(f, mHost.getContext(), false);
                    if (!f.mRetaining) {
                        dispatchOnFragmentPreCreated(f, f.mSavedFragmentState, false);
                        f.performCreate(f.mSavedFragmentState);
                        dispatchOnFragmentCreated(f, f.mSavedFragmentState, false);
                    } else {
                        f.restoreChildFragmentState(f.mSavedFragmentState, true);
                        f.mState = Fragment.CREATED;
                    }
                    f.mRetaining = false;
                }
            // fall through
            case Fragment.CREATED:
                // This is outside the if statement below on purpose; we want this to run
                // even if we do a moveToState from CREATED => *, CREATED => CREATED, and
                // * => CREATED as part of the case fallthrough above.
                ensureInflatedFragmentView(f);
                if (newState > Fragment.CREATED) {
                    if (DEBUG)
                        Log.v(TAG, ""moveto ACTIVITY_CREATED: "" + f);
                    if (!f.mFromLayout) {
                        ViewGroup container = null;
                        if (f.mContainerId != 0) {
                            if (f.mContainerId == View.NO_ID) {
                                throwException(new IllegalArgumentException(""Cannot create fragment "" + f + "" for a container view with no id""));
                            }
                            container = mContainer.onFindViewById(f.mContainerId);
                            if (container == null && !f.mRestored) {
                                String resName;
                                try {
                                    resName = f.getResources().getResourceName(f.mContainerId);
                                } catch (NotFoundException e) {
                                    resName = ""unknown"";
                                }
                                throwException(new IllegalArgumentException(""No view found for id 0x"" + Integer.toHexString(f.mContainerId) + "" ("" + resName + "") for fragment "" + f));
                            }
                        }
                        f.mContainer = container;
                        f.mView = f.performCreateView(f.performGetLayoutInflater(f.mSavedFragmentState), container, f.mSavedFragmentState);
                        if (f.mView != null) {
                            f.mView.setSaveFromParentEnabled(false);
                            if (container != null) {
                                container.addView(f.mView);
                            }
                            if (f.mHidden) {
                                f.mView.setVisibility(View.GONE);
                            }
                            f.onViewCreated(f.mView, f.mSavedFragmentState);
                            dispatchOnFragmentViewCreated(f, f.mView, f.mSavedFragmentState, false);
                            // Only animate the view if it is visible. This is done after
                            // dispatchOnFragmentViewCreated in case visibility is changed
                            f.mIsNewlyAdded = (f.mView.getVisibility() == View.VISIBLE) && f.mContainer != null;
                        }
                    }
                    f.performActivityCreated(f.mSavedFragmentState);
                    dispatchOnFragmentActivityCreated(f, f.mSavedFragmentState, false);
                    if (f.mView != null) {
                        f.restoreViewState(f.mSavedFragmentState);
                    }
                    f.mSavedFragmentState = null;
                }
            // fall through
            case Fragment.ACTIVITY_CREATED:
                if (newState > Fragment.ACTIVITY_CREATED) {
                    f.mState = Fragment.STOPPED;
                }
            // fall through
            case Fragment.STOPPED:
                if (newState > Fragment.STOPPED) {
                    if (DEBUG)
                        Log.v(TAG, ""moveto STARTED: "" + f);
                    f.performStart();
                    dispatchOnFragmentStarted(f, false);
                }
            // fall through
            case Fragment.STARTED:
                if (newState > Fragment.STARTED) {
                    if (DEBUG)
                        Log.v(TAG, ""moveto RESUMED: "" + f);
                    f.performResume();
                    dispatchOnFragmentResumed(f, false);
                    // Get rid of this in case we saved it and never needed it.
                    f.mSavedFragmentState = null;
                    f.mSavedViewState = null;
                }
        }
    } else if (f.mState > newState) {
        switch(f.mState) {
            case Fragment.RESUMED:
                if (newState < Fragment.RESUMED) {
                    if (DEBUG)
                        Log.v(TAG, ""movefrom RESUMED: "" + f);
                    f.performPause();
                    dispatchOnFragmentPaused(f, false);
                }
            // fall through
            case Fragment.STARTED:
                if (newState < Fragment.STARTED) {
                    if (DEBUG)
                        Log.v(TAG, ""movefrom STARTED: "" + f);
                    f.performStop();
                    dispatchOnFragmentStopped(f, false);
                }
            // fall through
            case Fragment.STOPPED:
            case Fragment.ACTIVITY_CREATED:
                if (newState < Fragment.ACTIVITY_CREATED) {
                    if (DEBUG)
                        Log.v(TAG, ""movefrom ACTIVITY_CREATED: "" + f);
                    if (f.mView != null) {
                        // done already.
                        if (mHost.onShouldSaveFragmentState(f) && f.mSavedViewState == null) {
                            saveFragmentViewState(f);
                        }
                    }
                    f.performDestroyView();
                    dispatchOnFragmentViewDestroyed(f, false);
                    if (f.mView != null && f.mContainer != null) {
                        if (getTargetSdk() >= Build.VERSION_CODES.O) {
                            // Stop any current animations:
                            f.mView.clearAnimation();
                            f.mContainer.endViewTransition(f.mView);
                        }
                        Animator anim = null;
                        if (mCurState > Fragment.INITIALIZING && !mDestroyed && f.mView.getVisibility() == View.VISIBLE && f.mView.getTransitionAlpha() > 0) {
                            anim = loadAnimator(f, transit, false, transitionStyle);
                        }
                        f.mView.setTransitionAlpha(1f);
                        if (anim != null) {
                            final ViewGroup container = f.mContainer;
                            final View view = f.mView;
                            final Fragment fragment = f;
                            container.startViewTransition(view);
                            f.setAnimatingAway(anim);
                            f.setStateAfterAnimating(newState);
                            anim.addListener(new AnimatorListenerAdapter() {

                                @Override
                                public void onAnimationEnd(Animator anim) {
                                    container.endViewTransition(view);
                                    if (fragment.getAnimatingAway() != null) {
                                        fragment.setAnimatingAway(null);
                                        moveToState(fragment, fragment.getStateAfterAnimating(), 0, 0, false);
                                    }
                                }
                            });
                            anim.setTarget(f.mView);
                            setHWLayerAnimListenerIfAlpha(f.mView, anim);
                            anim.start();
                        }
                        f.mContainer.removeView(f.mView);
                    }
                    f.mContainer = null;
                    f.mView = null;
                    f.mInLayout = false;
                }
            // fall through
            case Fragment.CREATED:
                if (newState < Fragment.CREATED) {
                    if (mDestroyed) {
                        if (f.getAnimatingAway() != null) {
                            // The fragment's containing activity is
                            // being destroyed, but this fragment is
                            // currently animating away.  Stop the
                            // animation right now -- it is not needed,
                            // and we can't wait any more on destroying
                            // the fragment.
                            Animator anim = f.getAnimatingAway();
                            f.setAnimatingAway(null);
                            anim.cancel();
                        }
                    }
                    if (f.getAnimatingAway() != null) {
                        // We are waiting for the fragment's view to finish
                        // animating away.  Just make a note of the state
                        // the fragment now should move to once the animation
                        // is done.
                        f.setStateAfterAnimating(newState);
                        newState = Fragment.CREATED;
                    } else {
                        if (DEBUG)
                            Log.v(TAG, ""movefrom CREATED: "" + f);
                        if (!f.mRetaining) {
                            f.performDestroy();
                            dispatchOnFragmentDestroyed(f, false);
                        } else {
                            f.mState = Fragment.INITIALIZING;
                        }
                        f.performDetach();
                        dispatchOnFragmentDetached(f, false);
                        if (!keepActive) {
                            if (!f.mRetaining) {
                                makeInactive(f);
                            } else {
                                f.mHost = null;
                                f.mParentFragment = null;
                                f.mFragmentManager = null;
                            }
                        }
                    }
                }
        }
    }
    if (f.mState != newState) {
        Log.w(TAG, ""moveToState: Fragment state for "" + f + "" not updated inline; "" + ""expected state "" + newState + "" found "" + f.mState);
        f.mState = newState;
    }
}",1,,,-1,,"[@SuppressWarnings(""ReferenceEquality"")]",-1,-1,-1,-1,-1,-1,,,,
662,"<android.app.assist.AssistStructure.ParcelTransferWriter: void writeView(ViewNode,Parcel,PooledStringWriter,int)>",25,26,"<android.app.assist.AssistStructure.ParcelTransferWriter: void writeView(ViewNode,Parcel,PooledStringWriter,int)>","<android.app.assist.AssistStructure.ParcelTransferWriter: void writeView(ViewNode,Parcel,PooledStringWriter,int)>",0,"{
    if (DEBUG_PARCEL)
        Log.d(TAG, ""write view: at "" + out.dataPosition() + "", windows="" + mNumWrittenWindows + "", views="" + mNumWrittenViews + "", level="" + (mCurViewStackPos + levelAdj));
    out.writeInt(VALIDATE_VIEW_TOKEN);
    int flags = child.writeSelfToParcel(out, pwriter, mTmpMatrix);
    mNumWrittenViews++;
    // If the child has children, push it on the stack to write them next.
    if ((flags & ViewNode.FLAGS_HAS_CHILDREN) != 0) {
        if (DEBUG_PARCEL_TREE || DEBUG_PARCEL_CHILDREN)
            Log.d(TAG, ""Preparing to write "" + child.mChildren.length + "" children: @ #"" + mNumWrittenViews + "", level "" + (mCurViewStackPos + levelAdj));
        out.writeInt(child.mChildren.length);
        int pos = ++mCurViewStackPos;
        pushViewStackEntry(child, pos);
    }
}","{
    if (DEBUG_PARCEL)
        Log.d(TAG, ""write view: at "" + out.dataPosition() + "", windows="" + mNumWrittenWindows + "", views="" + mNumWrittenViews + "", level="" + (mCurViewStackPos + levelAdj));
    out.writeInt(VALIDATE_VIEW_TOKEN);
    int flags = child.writeSelfToParcel(out, pwriter, mSanitizeOnWrite, mTmpMatrix);
    mNumWrittenViews++;
    // If the child has children, push it on the stack to write them next.
    if ((flags & ViewNode.FLAGS_HAS_CHILDREN) != 0) {
        if (DEBUG_PARCEL_TREE || DEBUG_PARCEL_CHILDREN)
            Log.d(TAG, ""Preparing to write "" + child.mChildren.length + "" children: @ #"" + mNumWrittenViews + "", level "" + (mCurViewStackPos + levelAdj));
        out.writeInt(child.mChildren.length);
        int pos = ++mCurViewStackPos;
        pushViewStackEntry(child, pos);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"There is an additional parameter 'mSanitizeOnWrite' passed to the method 'writeSelfToParcel' in the late implementation. This change is not tied to a return, exception handling, or control dependency change, so the code change type is 4.","There is no Compatibility Issue introduced since there is no direct alteration to what the method returns or the exceptions it might throw. The additional parameter 'mSanitizeOnWrite' could indicate an internal behavior change on how data is written to the Parcel, depending on what 'mSanitizeOnWrite' entails, but it does not inherently alter the signature or expected outcome of the 'writeView' method itself based on provided details."
663,"<android.widget.RemoteViewsAdapter.RemoteViewsAdapterServiceConnection: void unbind(Context,int,Intent)>",25,26,"<android.widget.RemoteViewsAdapter.RemoteViewsAdapterServiceConnection: void unbind(Context,int,Intent)>","<android.widget.RemoteViewsAdapter.RemoteViewsAdapterServiceConnection: void unbind(Context,int,Intent)>",0,"{
    try {
        RemoteViewsAdapter adapter;
        final AppWidgetManager mgr = AppWidgetManager.getInstance(context);
        if ((adapter = mAdapter.get()) != null) {
            mgr.unbindRemoteViewsService(context.getOpPackageName(), appWidgetId, intent);
        } else {
            Slog.w(TAG, ""unbind: adapter was null"");
        }
        mIsConnecting = false;
    } catch (Exception e) {
        Log.e(""RemoteViewsAdapterServiceConnection"", ""unbind(): "" + e.getMessage());
        mIsConnecting = false;
        mIsConnected = false;
    }
}","{
    try {
        RemoteViewsAdapter adapter;
        final AppWidgetManager mgr = AppWidgetManager.getInstance(context);
        if ((adapter = mAdapter.get()) != null) {
            mgr.unbindRemoteViewsService(context.getOpPackageName(), appWidgetId, intent);
        } else {
            Slog.w(TAG, ""unbind: adapter was null"");
        }
        mIsConnecting = false;
    } catch (Exception e) {
        Log.e(""RVAServiceConnection"", ""unbind(): "" + e.getMessage());
        mIsConnecting = false;
        mIsConnected = false;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change is the log tag string from ""RemoteViewsAdapterServiceConnection"" to ""RVAServiceConnection"". This is a simple string change and does not affect the execution logic, so the change type is 4.","Since the change is just a modification of the string used for logging, it will not cause this API to return a different value or throw a different exception, so there is no Compatibility Issue."
667,<android.widget.TextView: int computeVerticalScrollRange()>,25,26,<android.widget.TextView: int computeVerticalScrollRange()>,<android.widget.TextView: int computeVerticalScrollRange()>,0,"{
    if (mLayout != null)
        return mLayout.getHeight();
    return super.computeVerticalScrollRange();
}","{
    if (mLayout != null) {
        return mLayout.getHeight();
    }
    return super.computeVerticalScrollRange();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,0,0,"There are no significant code changes between the early version and the late version, only whitespace and formatting differences. The actual code execution remains the same.","Since there are no changes in the method's behavior, statements, return values, or exception handling, there is no Compatibility Issue."
668,<android.preference.Preference: float getPersistedFloat(float)>,25,26,<android.preference.Preference: float getPersistedFloat(float)>,<android.preference.Preference: float getPersistedFloat(float)>,0,"{
    if (!shouldPersist()) {
        return defaultReturnValue;
    }
    return mPreferenceManager.getSharedPreferences().getFloat(mKey, defaultReturnValue);
}","{
    if (!shouldPersist()) {
        return defaultReturnValue;
    }
    PreferenceDataStore dataStore = getPreferenceDataStore();
    if (dataStore != null) {
        return dataStore.getFloat(mKey, defaultReturnValue);
    }
    return mPreferenceManager.getSharedPreferences().getFloat(mKey, defaultReturnValue);
}",1,"/**
 * Attempts to get a persisted float from the {@link android.content.SharedPreferences}.
 *
 * @param defaultReturnValue The default value to return if either this
 * Preference is not persistent or this Preference is not in the
 * SharedPreferences.
 * @return The value from the SharedPreferences or the default return
 * value.
 * @see #getPersistedString(String)
 * @see #persistFloat(float)
 */
","/**
 * Attempts to get a persisted float if this Preference is persistent.
 *
 * @param defaultReturnValue The default value to return if either this
 * Preference is not persistent or this Preference is not present.
 * @return The value from the data store or the default return
 * value.
 * @see #getPersistedString(String)
 * @see #persistFloat(float)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"A new control dependency, 'if (dataStore != null)', has been introduced along with a new invocation 'dataStore.getFloat(mKey, defaultReturnValue)'. That is not related to an exception or return type change, but rather a change in the logic and a new method invocation, so the change types are 3,4.","This change adds a new potential return point that depends on whether the 'PreferenceDataStore' is not null, fundamentally altering the flow of the method and possibly the return value. Thus, the change can cause a different return value, and the CI type is 1."
669,<android.content.ClipDescription: int getMimeTypeCount()>,25,26,<android.content.ClipDescription: int getMimeTypeCount()>,<android.content.ClipDescription: int getMimeTypeCount()>,0,"{
    return mMimeTypes.length;
}","{
    return mMimeTypes.size();
}",1,"/**
 * Return the number of MIME types the clip is available in.
 */
","/**
 * Return the number of MIME types the clip is available in.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The code changed from accessing an array's length with `length` to calling the `size()` method on a List object, indicating the underlying data structure might have changed from an array to a List or similar Collection type. No control structure or exception handling changed, and return statement itself stayed intact (returning an ""int"" size in both cases), so the change type is 5.","Since both versions of the API return the count of mime types and both `length` property of an array and `size()` method of a List will return an integer, this change does not alter the return type nor does it introduce a risk of a different exception being thrown (assuming `mMimeTypes` is a properly instantiated List in the late version). Therefore, there is no Compatibility Issue, and the CI type is 0."
671,"<android.os.RemoteCallbackList: boolean register(E,Object)>",25,26,"<android.os.RemoteCallbackList: boolean register(E,Object)>","<android.os.RemoteCallbackList: boolean register(E,Object)>",0,"{
    synchronized (mCallbacks) {
        if (mKilled) {
            return false;
        }
        IBinder binder = callback.asBinder();
        try {
            Callback cb = new Callback(callback, cookie);
            binder.linkToDeath(cb, 0);
            mCallbacks.put(binder, cb);
            return true;
        } catch (RemoteException e) {
            return false;
        }
    }
}","{
    synchronized (mCallbacks) {
        if (mKilled) {
            return false;
        }
        // Flag unusual case that could be caused by a leak. b/36778087
        logExcessiveCallbacks();
        IBinder binder = callback.asBinder();
        try {
            Callback cb = new Callback(callback, cookie);
            binder.linkToDeath(cb, 0);
            mCallbacks.put(binder, cb);
            return true;
        } catch (RemoteException e) {
            return false;
        }
    }
}",1,"/**
 * Add a new callback to the list.  This callback will remain in the list
 * until a corresponding call to {@link #unregister} or its hosting process
 * goes away.  If the callback was already registered (determined by
 * checking to see if the {@link IInterface#asBinder callback.asBinder()}
 * object is already in the list), then it will be left as-is.
 * Registrations are not counted; a single call to {@link #unregister}
 * will remove a callback after any number calls to register it.
 *
 * @param callback The callback interface to be added to the list.  Must
 * not be null -- passing null here will cause a NullPointerException.
 * Most services will want to check for null before calling this with
 * an object given from a client, so that clients can't crash the
 * service with bad data.
 *
 * @param cookie Optional additional data to be associated with this
 * callback.
 *
 * @return Returns true if the callback was successfully added to the list.
 * Returns false if it was not added, either because {@link #kill} had
 * previously been called or the callback's process has gone away.
 *
 * @see #unregister
 * @see #kill
 * @see #onCallbackDied
 */
","/**
 * Add a new callback to the list.  This callback will remain in the list
 * until a corresponding call to {@link #unregister} or its hosting process
 * goes away.  If the callback was already registered (determined by
 * checking to see if the {@link IInterface#asBinder callback.asBinder()}
 * object is already in the list), then it will be left as-is.
 * Registrations are not counted; a single call to {@link #unregister}
 * will remove a callback after any number calls to register it.
 *
 * @param callback The callback interface to be added to the list.  Must
 * not be null -- passing null here will cause a NullPointerException.
 * Most services will want to check for null before calling this with
 * an object given from a client, so that clients can't crash the
 * service with bad data.
 *
 * @param cookie Optional additional data to be associated with this
 * callback.
 *
 * @return Returns true if the callback was successfully added to the list.
 * Returns false if it was not added, either because {@link #kill} had
 * previously been called or the callback's process has gone away.
 *
 * @see #unregister
 * @see #kill
 * @see #onCallbackDied
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The new method call logExcessiveCallbacks(); is inserted, which doesn't affect the method return value or exception handling, so it's considered as 4.","The insertion of a logging method does not affect the method's behavior from the perspective of external code. The method still returns a boolean value based on the same conditions, and there are no changes in exception handling. Therefore, there's no compatibility issue, and the CI type is 0."
673,<android.content.IntentFilter: void readFromXml(XmlPullParser)>,25,26,<android.content.IntentFilter: void readFromXml(XmlPullParser)>,<android.content.IntentFilter: void readFromXml(XmlPullParser)>,0,"{
    String autoVerify = parser.getAttributeValue(null, AUTO_VERIFY_STR);
    setAutoVerify(TextUtils.isEmpty(autoVerify) ? false : Boolean.getBoolean(autoVerify));
    int outerDepth = parser.getDepth();
    int type;
    while ((type = parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
        if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
            continue;
        }
        String tagName = parser.getName();
        if (tagName.equals(ACTION_STR)) {
            String name = parser.getAttributeValue(null, NAME_STR);
            if (name != null) {
                addAction(name);
            }
        } else if (tagName.equals(CAT_STR)) {
            String name = parser.getAttributeValue(null, NAME_STR);
            if (name != null) {
                addCategory(name);
            }
        } else if (tagName.equals(TYPE_STR)) {
            String name = parser.getAttributeValue(null, NAME_STR);
            if (name != null) {
                try {
                    addDataType(name);
                } catch (MalformedMimeTypeException e) {
                }
            }
        } else if (tagName.equals(SCHEME_STR)) {
            String name = parser.getAttributeValue(null, NAME_STR);
            if (name != null) {
                addDataScheme(name);
            }
        } else if (tagName.equals(SSP_STR)) {
            String ssp = parser.getAttributeValue(null, LITERAL_STR);
            if (ssp != null) {
                addDataSchemeSpecificPart(ssp, PatternMatcher.PATTERN_LITERAL);
            } else if ((ssp = parser.getAttributeValue(null, PREFIX_STR)) != null) {
                addDataSchemeSpecificPart(ssp, PatternMatcher.PATTERN_PREFIX);
            } else if ((ssp = parser.getAttributeValue(null, SGLOB_STR)) != null) {
                addDataSchemeSpecificPart(ssp, PatternMatcher.PATTERN_SIMPLE_GLOB);
            }
        } else if (tagName.equals(AUTH_STR)) {
            String host = parser.getAttributeValue(null, HOST_STR);
            String port = parser.getAttributeValue(null, PORT_STR);
            if (host != null) {
                addDataAuthority(host, port);
            }
        } else if (tagName.equals(PATH_STR)) {
            String path = parser.getAttributeValue(null, LITERAL_STR);
            if (path != null) {
                addDataPath(path, PatternMatcher.PATTERN_LITERAL);
            } else if ((path = parser.getAttributeValue(null, PREFIX_STR)) != null) {
                addDataPath(path, PatternMatcher.PATTERN_PREFIX);
            } else if ((path = parser.getAttributeValue(null, SGLOB_STR)) != null) {
                addDataPath(path, PatternMatcher.PATTERN_SIMPLE_GLOB);
            }
        } else {
            Log.w(""IntentFilter"", ""Unknown tag parsing IntentFilter: "" + tagName);
        }
        XmlUtils.skipCurrentTag(parser);
    }
}","{
    String autoVerify = parser.getAttributeValue(null, AUTO_VERIFY_STR);
    setAutoVerify(TextUtils.isEmpty(autoVerify) ? false : Boolean.getBoolean(autoVerify));
    int outerDepth = parser.getDepth();
    int type;
    while ((type = parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
        if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
            continue;
        }
        String tagName = parser.getName();
        if (tagName.equals(ACTION_STR)) {
            String name = parser.getAttributeValue(null, NAME_STR);
            if (name != null) {
                addAction(name);
            }
        } else if (tagName.equals(CAT_STR)) {
            String name = parser.getAttributeValue(null, NAME_STR);
            if (name != null) {
                addCategory(name);
            }
        } else if (tagName.equals(TYPE_STR)) {
            String name = parser.getAttributeValue(null, NAME_STR);
            if (name != null) {
                try {
                    addDataType(name);
                } catch (MalformedMimeTypeException e) {
                }
            }
        } else if (tagName.equals(SCHEME_STR)) {
            String name = parser.getAttributeValue(null, NAME_STR);
            if (name != null) {
                addDataScheme(name);
            }
        } else if (tagName.equals(SSP_STR)) {
            String ssp = parser.getAttributeValue(null, LITERAL_STR);
            if (ssp != null) {
                addDataSchemeSpecificPart(ssp, PatternMatcher.PATTERN_LITERAL);
            } else if ((ssp = parser.getAttributeValue(null, PREFIX_STR)) != null) {
                addDataSchemeSpecificPart(ssp, PatternMatcher.PATTERN_PREFIX);
            } else if ((ssp = parser.getAttributeValue(null, SGLOB_STR)) != null) {
                addDataSchemeSpecificPart(ssp, PatternMatcher.PATTERN_SIMPLE_GLOB);
            } else if ((ssp = parser.getAttributeValue(null, AGLOB_STR)) != null) {
                addDataSchemeSpecificPart(ssp, PatternMatcher.PATTERN_ADVANCED_GLOB);
            }
        } else if (tagName.equals(AUTH_STR)) {
            String host = parser.getAttributeValue(null, HOST_STR);
            String port = parser.getAttributeValue(null, PORT_STR);
            if (host != null) {
                addDataAuthority(host, port);
            }
        } else if (tagName.equals(PATH_STR)) {
            String path = parser.getAttributeValue(null, LITERAL_STR);
            if (path != null) {
                addDataPath(path, PatternMatcher.PATTERN_LITERAL);
            } else if ((path = parser.getAttributeValue(null, PREFIX_STR)) != null) {
                addDataPath(path, PatternMatcher.PATTERN_PREFIX);
            } else if ((path = parser.getAttributeValue(null, SGLOB_STR)) != null) {
                addDataPath(path, PatternMatcher.PATTERN_SIMPLE_GLOB);
            } else if ((path = parser.getAttributeValue(null, AGLOB_STR)) != null) {
                addDataPath(path, PatternMatcher.PATTERN_ADVANCED_GLOB);
            }
        } else {
            Log.w(""IntentFilter"", ""Unknown tag parsing IntentFilter: "" + tagName);
        }
        XmlUtils.skipCurrentTag(parser);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
674,<android.view.ViewRootImpl.QueuedInputEvent: boolean shouldSkipIme()>,25,26,<android.view.ViewRootImpl.QueuedInputEvent: boolean shouldSkipIme()>,<android.view.ViewRootImpl.QueuedInputEvent: boolean shouldSkipIme()>,0,"{
    if ((mFlags & FLAG_DELIVER_POST_IME) != 0) {
        return true;
    }
    return mEvent instanceof MotionEvent && mEvent.isFromSource(InputDevice.SOURCE_CLASS_POINTER);
}","{
    if ((mFlags & FLAG_DELIVER_POST_IME) != 0) {
        return true;
    }
    return mEvent instanceof MotionEvent && (mEvent.isFromSource(InputDevice.SOURCE_CLASS_POINTER) || mEvent.isFromSource(InputDevice.SOURCE_ROTARY_ENCODER));
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement has changed with an additional condition added to the logical OR, so the code change type is 1.","Since there's an additional condition that could change the return value (`mEvent.isFromSource(InputDevice.SOURCE_ROTARY_ENCODER)`), the change could make the API potentially return a different value. Therefore, the CI type is 1."
675,<android.content.res.TypedArray: Drawable getDrawable(int)>,25,26,<android.content.res.TypedArray: Drawable getDrawable(int)>,<android.content.res.TypedArray: Drawable getDrawable(int)>,0,"{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    final TypedValue value = mValue;
    if (getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, value)) {
        if (value.type == TypedValue.TYPE_ATTRIBUTE) {
            throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + index + "": "" + value);
        }
        return mResources.loadDrawable(value, value.resourceId, mTheme);
    }
    return null;
}","{
    return getDrawableForDensity(index, 0);
}",1,"/**
 * Retrieve the Drawable for the attribute at <var>index</var>.
 * <p>
 * This method will throw an exception if the attribute is defined but is
 * not a color or drawable resource.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return Drawable for the attribute, or {@code null} if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not a color or drawable resource.
 */
","/**
 * Retrieve the Drawable for the attribute at <var>index</var>.
 * <p>
 * This method will throw an exception if the attribute is defined but is
 * not a color or drawable resource.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return Drawable for the attribute, or {@code null} if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not a color or drawable resource.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,5,0,"The implementation of the method has completely changed. The method now calls 'getDrawableForDensity(index, 0)' directly instead of using the previous implementation. This represents a change in the dependent API; hence the code change type is 5.","Since the late version of the method delegates to another method 'getDrawableForDensity', which presumably encapsulates the same functionality that was previously directly implemented within the 'getDrawable' method, there should not be a CI as long as 'getDrawableForDensity' maintains the same contractual behavior for resolving and returning the drawable, even when the density is set to 0 (meaning no density specific resource is requested). Thus, the CI type is 0."
676,<android.preference.Preference: SharedPreferences getSharedPreferences()>,25,26,<android.preference.Preference: SharedPreferences getSharedPreferences()>,<android.preference.Preference: SharedPreferences getSharedPreferences()>,0,"{
    if (mPreferenceManager == null) {
        return null;
    }
    return mPreferenceManager.getSharedPreferences();
}","{
    if (mPreferenceManager == null || getPreferenceDataStore() != null) {
        return null;
    }
    return mPreferenceManager.getSharedPreferences();
}",1,"/**
 * Returns the {@link SharedPreferences} where this Preference can read its
 * value(s). Usually, it's easier to use one of the helper read methods:
 * {@link #getPersistedBoolean(boolean)}, {@link #getPersistedFloat(float)},
 * {@link #getPersistedInt(int)}, {@link #getPersistedLong(long)},
 * {@link #getPersistedString(String)}. To save values, see
 * {@link #getEditor()}.
 * <p>
 * In some cases, writes to the {@link #getEditor()} will not be committed
 * right away and hence not show up in the returned
 * {@link SharedPreferences}, this is intended behavior to improve
 * performance.
 *
 * @return The {@link SharedPreferences} where this Preference reads its
 * value(s), or null if it isn't attached to a Preference hierarchy.
 * @see #getEditor()
 */
","/**
 * Returns the {@link SharedPreferences} where this Preference can read its
 * value(s). Usually, it's easier to use one of the helper read methods:
 * {@link #getPersistedBoolean(boolean)}, {@link #getPersistedFloat(float)},
 * {@link #getPersistedInt(int)}, {@link #getPersistedLong(long)},
 * {@link #getPersistedString(String)}. To save values, see
 * {@link #getEditor()}.
 * <p>
 * In some cases, writes to the {@link #getEditor()} will not be committed
 * right away and hence not show up in the returned
 * {@link SharedPreferences}, this is intended behavior to improve
 * performance.
 *
 * @return the {@link SharedPreferences} where this Preference reads its value(s). If
 * this preference isn't attached to a Preference hierarchy or if
 * a {@link PreferenceDataStore} has been set, this method returns {@code null}.
 * @see #getEditor()
 * @see #setPreferenceDataStore(PreferenceDataStore)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The early version's condition for returning null only checks if 'mPreferenceManager' is null, whereas the late version adds an additional condition, checking if 'getPreferenceDataStore()' is not null. This is a control dependency change, and there's an additional condition that can result in a 'null' being returned, so the code change type is 1,3 as it affects the return statement.","Due to the addition of a new condition that leads to a 'null' return value, the late version may return 'null' in cases where the early version did not. Therefore, the compatibility issue is of type 1, due to the potential for returning a different value."
677,<android.preference.Preference: boolean persistInt(int)>,25,26,<android.preference.Preference: boolean persistInt(int)>,<android.preference.Preference: boolean persistInt(int)>,0,"{
    if (shouldPersist()) {
        if (value == getPersistedInt(~value)) {
            // It's already there, so the same as persisting
            return true;
        }
        SharedPreferences.Editor editor = mPreferenceManager.getEditor();
        editor.putInt(mKey, value);
        tryCommit(editor);
        return true;
    }
    return false;
}","{
    if (!shouldPersist()) {
        return false;
    }
    if (value == getPersistedInt(~value)) {
        // It's already there, so the same as persisting
        return true;
    }
    PreferenceDataStore dataStore = getPreferenceDataStore();
    if (dataStore != null) {
        dataStore.putInt(mKey, value);
    } else {
        SharedPreferences.Editor editor = mPreferenceManager.getEditor();
        editor.putInt(mKey, value);
        tryCommit(editor);
    }
    return true;
}",1,"/**
 * Attempts to persist an int to the {@link android.content.SharedPreferences}.
 *
 * @param value The value to persist.
 * @return True if the Preference is persistent. (This is not whether the
 * value was persisted, since we may not necessarily commit if there
 * will be a batch commit later.)
 * @see #persistString(String)
 * @see #getPersistedInt(int)
 */
","/**
 * Attempts to persist an int if this Preference is persistent.
 *
 * @param value The value to persist.
 * @return True if this Preference is persistent. (This is not whether the
 * value was persisted, since we may not necessarily commit if there
 * will be a batch commit later.)
 * @see #persistString(String)
 * @see #getPersistedInt(int)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The control flow has changed with the inversion of the if condition and early return for `!shouldPersist()`. A new control structure to determine where to store the preference (either in a PreferenceDataStore or SharedPreferences) has been added. Therefore, the change types are 3 (control dependency change) and 4 (other statement changed).","Although the code has undergone changes in terms of control flow and where the data is stored, the semantics of persisting the integer value and the return values have not been altered. The method still returns `true` when the value is persisted (either in the PreferenceDataStore or the SharedPreferences) and `false` if the value should not be persisted. Therefore, there are no compatibility issues, as the outcomes observed by the API consumers remain consistent across the two versions. The CI type is 0."
679,<android.text.Layout: int getLineForOffset(int)>,25,26,<android.text.Layout: int getLineForOffset(int)>,<android.text.Layout: int getLineForOffset(int)>,0,"{
    int high = getLineCount(), low = -1, guess;
    while (high - low > 1) {
        guess = (high + low) / 2;
        if (getLineStart(guess) > offset)
            high = guess;
        else
            low = guess;
    }
    if (low < 0)
        return 0;
    else
        return low;
}","{
    int high = getLineCount(), low = -1, guess;
    while (high - low > 1) {
        guess = (high + low) / 2;
        if (getLineStart(guess) > offset)
            high = guess;
        else
            low = guess;
    }
    if (low < 0) {
        return 0;
    } else {
        return low;
    }
}",1,"/**
 * Get the line number on which the specified text offset appears.
 * If you ask for a position before 0, you get 0; if you ask for a position
 * beyond the end of the text, you get the last line.
 */
","/**
 * Get the line number on which the specified text offset appears.
 * If you ask for a position before 0, you get 0; if you ask for a position
 * beyond the end of the text, you get the last line.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"The early version and the late version of the implementation are functionally identical. The change is purely formatting with the addition of braces around if-else blocks, which does not alter the behavior of the code.","There is no Compatibility Issue since there is no change in behavior, return values, exceptions thrown, control flow, or anything that would affect how the API works. The modifications are only stylistic and do not affect the logic or output of the method."
680,"<android.app.FragmentHostCallback: LoaderManagerImpl getLoaderManager(String,boolean,boolean)>",25,26,"<android.app.FragmentHostCallback: LoaderManagerImpl getLoaderManager(String,boolean,boolean)>","<android.app.FragmentHostCallback: LoaderManagerImpl getLoaderManager(String,boolean,boolean)>",0,"{
    if (mAllLoaderManagers == null) {
        mAllLoaderManagers = new ArrayMap<String, LoaderManager>();
    }
    LoaderManagerImpl lm = (LoaderManagerImpl) mAllLoaderManagers.get(who);
    if (lm == null) {
        if (create) {
            lm = new LoaderManagerImpl(who, this, started);
            mAllLoaderManagers.put(who, lm);
        }
    } else {
        lm.updateHostController(this);
    }
    return lm;
}","{
    if (mAllLoaderManagers == null) {
        mAllLoaderManagers = new ArrayMap<String, LoaderManager>();
    }
    LoaderManagerImpl lm = (LoaderManagerImpl) mAllLoaderManagers.get(who);
    if (lm == null && create) {
        lm = new LoaderManagerImpl(who, this, started);
        mAllLoaderManagers.put(who, lm);
    } else if (started && lm != null && !lm.mStarted) {
        lm.doStart();
    }
    return lm;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The late version has an additional if condition that calls `doStart()` on the `LoaderManagerImpl` object. Hence, a control dependency and a return statement type have changed, marked as types 1,3.","Since the new condition can result in the `doStart()` method being called on the `LoaderManagerImpl` object, the state of the object (and potentially its returned value) may change. Therefore, this can lead to the API returning a different object state, which is classified as a Compatibility Issue type 1."
682,<android.preference.Preference: boolean persistString(String)>,25,26,<android.preference.Preference: boolean persistString(String)>,<android.preference.Preference: boolean persistString(String)>,0,"{
    if (shouldPersist()) {
        // Shouldn't store null
        if (TextUtils.equals(value, getPersistedString(null))) {
            // It's already there, so the same as persisting
            return true;
        }
        SharedPreferences.Editor editor = mPreferenceManager.getEditor();
        editor.putString(mKey, value);
        tryCommit(editor);
        return true;
    }
    return false;
}","{
    if (!shouldPersist()) {
        return false;
    }
    // Shouldn't store null
    if (TextUtils.equals(value, getPersistedString(null))) {
        // It's already there, so the same as persisting
        return true;
    }
    PreferenceDataStore dataStore = getPreferenceDataStore();
    if (dataStore != null) {
        dataStore.putString(mKey, value);
    } else {
        SharedPreferences.Editor editor = mPreferenceManager.getEditor();
        editor.putString(mKey, value);
        tryCommit(editor);
    }
    return true;
}",1,"/**
 * Attempts to persist a String to the {@link android.content.SharedPreferences}.
 * <p>
 * This will check if this Preference is persistent, get an editor from
 * the {@link PreferenceManager}, put in the string, and check if we should commit (and
 * commit if so).
 *
 * @param value The value to persist.
 * @return True if the Preference is persistent. (This is not whether the
 * value was persisted, since we may not necessarily commit if there
 * will be a batch commit later.)
 * @see #getPersistedString(String)
 */
","/**
 * Attempts to persist a String if this Preference is persistent.
 *
 * @param value The value to persist.
 * @return True if this Preference is persistent. (This is not whether the
 * value was persisted, since we may not necessarily commit if there
 * will be a batch commit later.)
 * @see #getPersistedString(String)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The control dependency of 'if' condition has changed with ""!shouldPersist()"" from ""if (shouldPersist())"" leading to an early return if the condition fails. Additionally, the late implementation introduces the use of 'PreferenceDataStore' which is a change in the implementation logic that does not directly affect control flow or exception handling related to persistence but does affect how the data is stored. Therefore, the change includes type 3 and 4 changes.","Even though the data storage mechanism has changed, the semantics of the ""persistString"" functionality remain the same—saving a key-value pair to the relevant preference storage. The return value true signifies successful persistence regardless of whether it is via SharedPreferences or PreferenceDataStore. Since there are no changes that would affect the boolean return value in cases where 'shouldPersist()' is true and the new value does not equal the one stored, or in cases where 'shouldPersist()' returns false, we consider no compatibility issue (CI type 0)."
683,<android.bluetooth.BluetoothAdapter: boolean disable()>,25,26,<android.bluetooth.BluetoothAdapter: boolean disable()>,<android.bluetooth.BluetoothAdapter: boolean disable()>,0,"{
    try {
        return mManagerService.disable(true);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}","{
    try {
        return mManagerService.disable(ActivityThread.currentPackageName(), true);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}",1,"/**
 * Turn off the local Bluetooth adapter&mdash;do not use without explicit
 * user action to turn off Bluetooth.
 * <p>This gracefully shuts down all Bluetooth connections, stops Bluetooth
 * system services, and powers down the underlying Bluetooth hardware.
 * <p class=""caution""><strong>Bluetooth should never be disabled without
 * direct user consent</strong>. The {@link #disable()} method is
 * provided only for applications that include a user interface for changing
 * system settings, such as a ""power manager"" app.</p>
 * <p>This is an asynchronous call: it will return immediately, and
 * clients should listen for {@link #ACTION_STATE_CHANGED}
 * to be notified of subsequent adapter state changes. If this call returns
 * true, then the adapter state will immediately transition from {@link
 * #STATE_ON} to {@link #STATE_TURNING_OFF}, and some time
 * later transition to either {@link #STATE_OFF} or {@link
 * #STATE_ON}. If this call returns false then there was an
 * immediate problem that will prevent the adapter from being turned off -
 * such as the adapter already being turned off.
 * <p>Requires the {@link android.Manifest.permission#BLUETOOTH_ADMIN}
 * permission
 *
 * @return true to indicate adapter shutdown has begun, or false on
 * immediate error
 */
","/**
 * Turn off the local Bluetooth adapter&mdash;do not use without explicit
 * user action to turn off Bluetooth.
 * <p>This gracefully shuts down all Bluetooth connections, stops Bluetooth
 * system services, and powers down the underlying Bluetooth hardware.
 * <p class=""caution""><strong>Bluetooth should never be disabled without
 * direct user consent</strong>. The {@link #disable()} method is
 * provided only for applications that include a user interface for changing
 * system settings, such as a ""power manager"" app.</p>
 * <p>This is an asynchronous call: it will return immediately, and
 * clients should listen for {@link #ACTION_STATE_CHANGED}
 * to be notified of subsequent adapter state changes. If this call returns
 * true, then the adapter state will immediately transition from {@link
 * #STATE_ON} to {@link #STATE_TURNING_OFF}, and some time
 * later transition to either {@link #STATE_OFF} or {@link
 * #STATE_ON}. If this call returns false then there was an
 * immediate problem that will prevent the adapter from being turned off -
 * such as the adapter already being turned off.
 *
 * @return true to indicate adapter shutdown has begun, or false on
 * immediate error
 */
",-1,[@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)],[@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)],-1,-1,-1,-1,-1,-1,5,0,"The dependent API mManagerService.disable has changed its signature by adding an additional parameter (ActivityThread.currentPackageName()), which means it has been classified as type 5.","There's no compatibility issue in terms of behavior change as the API still returns 'true' or 'false' based on the result of the mManagerService.disable method, and exception handling hasn't changed. However, because the dependent API call now includes the current package name, client code that relies on permissions certainly related to the package name might behave differently. Still, from the perspective of this API's signature and contract, it does not directly cause a different return value or exception behavior by itself. Therefore, there is no compatibility issue based on the rules provided."
684,<android.content.pm.LauncherActivityInfo: long getFirstInstallTime()>,25,26,<android.content.pm.LauncherActivityInfo: long getFirstInstallTime()>,<android.content.pm.LauncherActivityInfo: long getFirstInstallTime()>,0,"{
    try {
        return mPm.getPackageInfo(mActivityInfo.packageName, PackageManager.GET_UNINSTALLED_PACKAGES).firstInstallTime;
    } catch (NameNotFoundException nnfe) {
        // Sorry, can't find package
        return 0;
    }
}","{
    try {
        // TODO: Go through LauncherAppsService
        return mPm.getPackageInfo(mActivityInfo.packageName, PackageManager.MATCH_UNINSTALLED_PACKAGES).firstInstallTime;
    } catch (NameNotFoundException nnfe) {
        // Sorry, can't find package
        return 0;
    }
}",1,"/**
 * Returns the time at which the package was first installed.
 *
 * @return The time of installation of the package, in milliseconds.
 */
","/**
 * Returns the time at which the package was first installed.
 *
 * @return The time of installation of the package, in milliseconds.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The code change is only in the constant used from GET_UNINSTALLED_PACKAGES to MATCH_UNINSTALLED_PACKAGES. Since these two constants are meant to serve the same purpose and they were just renamed in the PackageManager class, the dependent API has changed. The behavior of the method should remain the same given that the semantics of the flag did not change.",There is no compatibility issue since the change in constant should not affect the behavior of the API as long as the PackageManager's getPackageInfo method interprets MATCH_UNINSTALLED_PACKAGES the same way it did GET_UNINSTALLED_PACKAGES.
685,"<android.content.ContentProviderClient: Cursor query(Uri,String[],String,String[],String,CancellationSignal)>",25,26,"<android.content.ContentProviderClient: Cursor query(Uri,String[],String,String[],String,CancellationSignal)>","<android.content.ContentProviderClient: Cursor query(Uri,String[],String,String[],String,CancellationSignal)>",0,"{
    Preconditions.checkNotNull(url, ""url"");
    beforeRemote();
    try {
        ICancellationSignal remoteCancellationSignal = null;
        if (cancellationSignal != null) {
            cancellationSignal.throwIfCanceled();
            remoteCancellationSignal = mContentProvider.createCancellationSignal();
            cancellationSignal.setRemote(remoteCancellationSignal);
        }
        final Cursor cursor = mContentProvider.query(mPackageName, url, projection, selection, selectionArgs, sortOrder, remoteCancellationSignal);
        if (cursor == null) {
            return null;
        }
        if (""com.google.android.gms"".equals(mPackageName)) {
            // They're casting to a concrete subclass, sigh
            return cursor;
        } else {
            return new CursorWrapperInner(cursor);
        }
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}","{
    Bundle queryArgs = ContentResolver.createSqlQueryBundle(selection, selectionArgs, sortOrder);
    return query(uri, projection, queryArgs, cancellationSignal);
}",1,"/**
 * See {@link ContentProvider#query ContentProvider.query}
 */
","/**
 * See {@link ContentProvider#query ContentProvider.query}
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,"1,5","1,2","The method implementation has completely changed; it now delegates the query to another method with a different signature by creating and passing a `Bundle` containing the query arguments instead of passing them directly. A new method `ContentResolver.createSqlQueryBundle()` and `query()` on `ContentProviderClient` are used. Therefore, this qualifies as a change type 1 (as different return paths could lead to different return types or values) and 5 (dependent API changed).","The new implementation could potentially return a different cursor or throw different exceptions due to the changes in how the query execution is delegates, causing CI type 1 (potential different return values) and CI type 2 (potential different exception handlings)."
686,"<android.os.Parcel: void readException(int,String)>",25,26,"<android.os.Parcel: void readException(int,String)>","<android.os.Parcel: void readException(int,String)>",0,"{
    switch(code) {
        case EX_SECURITY:
            throw new SecurityException(msg);
        case EX_BAD_PARCELABLE:
            throw new BadParcelableException(msg);
        case EX_ILLEGAL_ARGUMENT:
            throw new IllegalArgumentException(msg);
        case EX_NULL_POINTER:
            throw new NullPointerException(msg);
        case EX_ILLEGAL_STATE:
            throw new IllegalStateException(msg);
        case EX_NETWORK_MAIN_THREAD:
            throw new NetworkOnMainThreadException();
        case EX_UNSUPPORTED_OPERATION:
            throw new UnsupportedOperationException(msg);
        case EX_SERVICE_SPECIFIC:
            throw new ServiceSpecificException(readInt(), msg);
    }
    throw new RuntimeException(""Unknown exception code: "" + code + "" msg "" + msg);
}","{
    switch(code) {
        case EX_PARCELABLE:
            if (readInt() > 0) {
                SneakyThrow.sneakyThrow((Exception) readParcelable(Parcelable.class.getClassLoader()));
            } else {
                throw new RuntimeException(msg + "" [missing Parcelable]"");
            }
        case EX_SECURITY:
            throw new SecurityException(msg);
        case EX_BAD_PARCELABLE:
            throw new BadParcelableException(msg);
        case EX_ILLEGAL_ARGUMENT:
            throw new IllegalArgumentException(msg);
        case EX_NULL_POINTER:
            throw new NullPointerException(msg);
        case EX_ILLEGAL_STATE:
            throw new IllegalStateException(msg);
        case EX_NETWORK_MAIN_THREAD:
            throw new NetworkOnMainThreadException();
        case EX_UNSUPPORTED_OPERATION:
            throw new UnsupportedOperationException(msg);
        case EX_SERVICE_SPECIFIC:
            throw new ServiceSpecificException(readInt(), msg);
    }
    throw new RuntimeException(""Unknown exception code: "" + code + "" msg "" + msg);
}",1,"/**
 * Throw an exception with the given message. Not intended for use
 * outside the Parcel class.
 *
 * @param code Used to determine which exception class to throw.
 * @param msg The exception message.
 */
","/**
 * Throw an exception with the given message. Not intended for use
 * outside the Parcel class.
 *
 * @param code Used to determine which exception class to throw.
 * @param msg The exception message.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"A new case (EX_PARCELABLE) with additional logic has been introduced in the switch statement, and one case (EX_SERVICE_SPECIFIC) has been modified to throw a different type of exception involving a new method (sneakyThrow) in case the condition 'if (readInt() > 0)' is true, so the code change types are 2,3.","The introduction of a new case (EX_PARCELABLE) with control dependency on 'if (readInt() > 0)' and the conditional throwing of an exception using a method call to 'sneakyThrow' may lead to different exception handling behavior. The modification in the switch statement has the potential to throw entirely different exceptions or transform how they are thrown, which may not be caught by the same catch blocks as before. Thus, the CI type is 2."
688,"<android.util.MapCollections.MapIterator: Entry<K, V> next()>",25,26,"<android.util.MapCollections.MapIterator: Entry<K, V> next()>","<android.util.MapCollections.MapIterator: Entry<K, V> next()>",0,"{
    mIndex++;
    mEntryValid = true;
    return this;
}","{
    if (!hasNext())
        throw new NoSuchElementException();
    mIndex++;
    mEntryValid = true;
    return this;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,3",2,"The late implementation introduces a new control statement that checks hasNext() and may throw a new exception, NoSuchElementException, so the code change includes an exception handling statement change and a control dependency change, which are type 2 and 3.","The introduction of conditionally throwing a NoSuchElementException where the earlier version did not indicates a possible change in behavior, thus a potential Compatibility Issue due to different exception handling is identified, which is type 2."
690,<android.app.ActivityManager: AppTask> getAppTasks()>,25,26,<android.app.ActivityManager: AppTask> getAppTasks()>,<android.app.ActivityManager: AppTask> getAppTasks()>,0,"{
    ArrayList<AppTask> tasks = new ArrayList<AppTask>();
    List<IAppTask> appTasks;
    try {
        appTasks = ActivityManagerNative.getDefault().getAppTasks(mContext.getPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
    int numAppTasks = appTasks.size();
    for (int i = 0; i < numAppTasks; i++) {
        tasks.add(new AppTask(appTasks.get(i)));
    }
    return tasks;
}","{
    ArrayList<AppTask> tasks = new ArrayList<AppTask>();
    List<IBinder> appTasks;
    try {
        appTasks = getService().getAppTasks(mContext.getPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
    int numAppTasks = appTasks.size();
    for (int i = 0; i < numAppTasks; i++) {
        tasks.add(new AppTask(IAppTask.Stub.asInterface(appTasks.get(i))));
    }
    return tasks;
}",1,"/**
 * Get the list of tasks associated with the calling application.
 *
 * @return The list of tasks associated with the application making this call.
 * @throws SecurityException
 */
","/**
 * Get the list of tasks associated with the calling application.
 *
 * @return The list of tasks associated with the application making this call.
 * @throws SecurityException
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",0,"The type of the list 'appTasks' changed from 'List<IAppTask>' to 'List<IBinder>', also the way of getting 'appTasks' changed from ActivityManagerNative.getDefault().getAppTasks() to getService().getAppTasks(). And in the loop, 'new AppTask(appTasks.get(i))' changed to 'new AppTask(IAppTask.Stub.asInterface(appTasks.get(i)))'. Therefore, there is a change in the control dependency due to the different iteration approach (type 3), and dependent API changes because 'getService()' and 'IAppTask.Stub.asInterface()' method signatures are different (type 5). There's also other statement change because of the different object creation method in the loop (type 4).","There is no Compatibility Issue detected between the two versions. The changes seen do not affect the return values or exception handling of the method. The return type remains 'ArrayList<AppTask>', and it is filled in the same way with AppTask objects. The RemoteException is handled consistently in both versions. Thus, although the implementation has changed, it should not lead to different behavior for the clients of the API."
691,<android.app.ActivityOptions: Bundle toBundle()>,25,26,<android.app.ActivityOptions: Bundle toBundle()>,<android.app.ActivityOptions: Bundle toBundle()>,0,"{
    if (mAnimationType == ANIM_DEFAULT) {
        return null;
    }
    Bundle b = new Bundle();
    if (mPackageName != null) {
        b.putString(KEY_PACKAGE_NAME, mPackageName);
    }
    if (mLaunchBounds != null) {
        b.putParcelable(KEY_LAUNCH_BOUNDS, mLaunchBounds);
    }
    b.putInt(KEY_ANIM_TYPE, mAnimationType);
    if (mUsageTimeReport != null) {
        b.putParcelable(KEY_USAGE_TIME_REPORT, mUsageTimeReport);
    }
    switch(mAnimationType) {
        case ANIM_CUSTOM:
            b.putInt(KEY_ANIM_ENTER_RES_ID, mCustomEnterResId);
            b.putInt(KEY_ANIM_EXIT_RES_ID, mCustomExitResId);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_CUSTOM_IN_PLACE:
            b.putInt(KEY_ANIM_IN_PLACE_RES_ID, mCustomInPlaceResId);
            break;
        case ANIM_SCALE_UP:
        case ANIM_CLIP_REVEAL:
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
        case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
        case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
            b.putParcelable(KEY_ANIM_THUMBNAIL, mThumbnail);
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_SCENE_TRANSITION:
            if (mTransitionReceiver != null) {
                b.putParcelable(KEY_TRANSITION_COMPLETE_LISTENER, mTransitionReceiver);
            }
            b.putBoolean(KEY_TRANSITION_IS_RETURNING, mIsReturning);
            b.putStringArrayList(KEY_TRANSITION_SHARED_ELEMENTS, mSharedElementNames);
            b.putParcelable(KEY_RESULT_DATA, mResultData);
            b.putInt(KEY_RESULT_CODE, mResultCode);
            b.putInt(KEY_EXIT_COORDINATOR_INDEX, mExitCoordinatorIndex);
            break;
    }
    b.putInt(KEY_LAUNCH_STACK_ID, mLaunchStackId);
    b.putInt(KEY_LAUNCH_TASK_ID, mLaunchTaskId);
    b.putBoolean(KEY_TASK_OVERLAY, mTaskOverlay);
    b.putInt(KEY_DOCK_CREATE_MODE, mDockCreateMode);
    if (mAnimSpecs != null) {
        b.putParcelableArray(KEY_ANIM_SPECS, mAnimSpecs);
    }
    if (mAnimationFinishedListener != null) {
        b.putBinder(KEY_ANIMATION_FINISHED_LISTENER, mAnimationFinishedListener.asBinder());
    }
    b.putInt(KEY_ROTATION_ANIMATION_HINT, mRotationAnimationHint);
    return b;
}","{
    Bundle b = new Bundle();
    if (mPackageName != null) {
        b.putString(KEY_PACKAGE_NAME, mPackageName);
    }
    if (mLaunchBounds != null) {
        b.putParcelable(KEY_LAUNCH_BOUNDS, mLaunchBounds);
    }
    b.putInt(KEY_ANIM_TYPE, mAnimationType);
    if (mUsageTimeReport != null) {
        b.putParcelable(KEY_USAGE_TIME_REPORT, mUsageTimeReport);
    }
    switch(mAnimationType) {
        case ANIM_CUSTOM:
            b.putInt(KEY_ANIM_ENTER_RES_ID, mCustomEnterResId);
            b.putInt(KEY_ANIM_EXIT_RES_ID, mCustomExitResId);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_CUSTOM_IN_PLACE:
            b.putInt(KEY_ANIM_IN_PLACE_RES_ID, mCustomInPlaceResId);
            break;
        case ANIM_SCALE_UP:
        case ANIM_CLIP_REVEAL:
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
        case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
        case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
            // the bitmap to a hardware bitmap and pass through the GraphicBuffer
            if (mThumbnail != null) {
                final Bitmap hwBitmap = mThumbnail.copy(Config.HARDWARE, false);
                if (hwBitmap != null) {
                    b.putParcelable(KEY_ANIM_THUMBNAIL, hwBitmap.createGraphicBufferHandle());
                } else {
                    Slog.w(TAG, ""Failed to copy thumbnail"");
                }
            }
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_SCENE_TRANSITION:
            if (mTransitionReceiver != null) {
                b.putParcelable(KEY_TRANSITION_COMPLETE_LISTENER, mTransitionReceiver);
            }
            b.putBoolean(KEY_TRANSITION_IS_RETURNING, mIsReturning);
            b.putStringArrayList(KEY_TRANSITION_SHARED_ELEMENTS, mSharedElementNames);
            b.putParcelable(KEY_RESULT_DATA, mResultData);
            b.putInt(KEY_RESULT_CODE, mResultCode);
            b.putInt(KEY_EXIT_COORDINATOR_INDEX, mExitCoordinatorIndex);
            break;
    }
    b.putInt(KEY_LAUNCH_DISPLAY_ID, mLaunchDisplayId);
    b.putInt(KEY_LAUNCH_STACK_ID, mLaunchStackId);
    b.putInt(KEY_LAUNCH_TASK_ID, mLaunchTaskId);
    b.putBoolean(KEY_TASK_OVERLAY, mTaskOverlay);
    b.putBoolean(KEY_TASK_OVERLAY_CAN_RESUME, mTaskOverlayCanResume);
    b.putInt(KEY_DOCK_CREATE_MODE, mDockCreateMode);
    if (mAnimSpecs != null) {
        b.putParcelableArray(KEY_ANIM_SPECS, mAnimSpecs);
    }
    if (mAnimationFinishedListener != null) {
        b.putBinder(KEY_ANIMATION_FINISHED_LISTENER, mAnimationFinishedListener.asBinder());
    }
    if (mSpecsFuture != null) {
        b.putBinder(KEY_SPECS_FUTURE, mSpecsFuture.asBinder());
    }
    b.putInt(KEY_ROTATION_ANIMATION_HINT, mRotationAnimationHint);
    if (mAppVerificationBundle != null) {
        b.putBundle(KEY_INSTANT_APP_VERIFICATION_BUNDLE, mAppVerificationBundle);
    }
    return b;
}",1,"/**
 * Returns the created options as a Bundle, which can be passed to
 * {@link android.content.Context#startActivity(android.content.Intent, android.os.Bundle)
 * Context.startActivity(Intent, Bundle)} and related methods.
 * Note that the returned Bundle is still owned by the ActivityOptions
 * object; you must not modify it, but can supply it to the startActivity
 * methods that take an options Bundle.
 */
","/**
 * Returns the created options as a Bundle, which can be passed to
 * {@link android.content.Context#startActivity(android.content.Intent, android.os.Bundle)
 * Context.startActivity(Intent, Bundle)} and related methods.
 * Note that the returned Bundle is still owned by the ActivityOptions
 * object; you must not modify it, but can supply it to the startActivity
 * methods that take an options Bundle.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
694,"<android.content.res.Configuration: boolean needNewResources(int,int)>",25,26,"<android.content.res.Configuration: boolean needNewResources(int,int)>","<android.content.res.Configuration: boolean needNewResources(int,int)>",0,"{
    return (configChanges & (interestingChanges | ActivityInfo.CONFIG_FONT_SCALE)) != 0;
}","{
    // CONFIG_ASSETS_PATHS and CONFIG_FONT_SCALE are higher level configuration changes that
    // all resources are subject to change with.
    interestingChanges = interestingChanges | ActivityInfo.CONFIG_ASSETS_PATHS | ActivityInfo.CONFIG_FONT_SCALE;
    return (configChanges & interestingChanges) != 0;
}",1,"/**
 * Determines if a new resource needs to be loaded from the bit set of
 * configuration changes returned by {@link #updateFrom(Configuration)}.
 *
 * @param configChanges the mask of changes configurations as returned by
 * {@link #updateFrom(Configuration)}
 * @param interestingChanges the configuration changes that the resource
 * can handle as given in
 * {@link android.util.TypedValue#changingConfigurations}
 * @return {@code true} if the resource needs to be loaded, {@code false}
 * otherwise
 */
","/**
 * Determines if a new resource needs to be loaded from the bit set of
 * configuration changes returned by {@link #updateFrom(Configuration)}.
 *
 * @param configChanges the mask of changes configurations as returned by
 * {@link #updateFrom(Configuration)}
 * @param interestingChanges the configuration changes that the resource
 * can handle as given in
 * {@link android.util.TypedValue#changingConfigurations}
 * @return {@code true} if the resource needs to be loaded, {@code false}
 * otherwise
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The return statement has an additional bitwise OR operation with `ActivityInfo.CONFIG_ASSETS_PATHS` and `ActivityInfo.CONFIG_FONT_SCALE`, and the calculation for `interestingChanges` variable has also changed within the condition, so the change types are 1 and 3.","The change in how `interestingChanges` is calculated, and the additional bitwise OR operation in the return statement could alter the outcome of the method. This means the late version API is potentially returning different boolean values compared to the early version, making the CI type 1."
696,"<android.app.ActivityTransitionCoordinator: Transition setTargets(Transition,boolean)>",25,26,"<android.app.ActivityTransitionCoordinator: Transition setTargets(Transition,boolean)>","<android.app.ActivityTransitionCoordinator: Transition setTargets(Transition,boolean)>",0,"{
    if (transition == null || (add && (mTransitioningViews == null || mTransitioningViews.isEmpty()))) {
        return null;
    }
    // Add the targets to a set containing transition so that transition
    // remains unaffected. We don't want to modify the targets of transition itself.
    TransitionSet set = new TransitionSet();
    if (mTransitioningViews != null) {
        for (int i = mTransitioningViews.size() - 1; i >= 0; i--) {
            View view = mTransitioningViews.get(i);
            if (add) {
                set.addTarget(view);
            } else {
                set.excludeTarget(view, true);
            }
        }
    }
    // By adding the transition after addTarget, we prevent addTarget from
    // affecting transition.
    set.addTransition(transition);
    if (!add && mTransitioningViews != null && !mTransitioningViews.isEmpty()) {
        // Allow children of excluded transitioning views, but not the views themselves
        set = new TransitionSet().addTransition(set);
    }
    return set;
}","{
    if (transition == null || (add && (mTransitioningViews == null || mTransitioningViews.isEmpty()))) {
        return null;
    }
    // Add the targets to a set containing transition so that transition
    // remains unaffected. We don't want to modify the targets of transition itself.
    TransitionSet set = new TransitionSet();
    if (mTransitioningViews != null) {
        for (int i = mTransitioningViews.size() - 1; i >= 0; i--) {
            View view = mTransitioningViews.get(i);
            if (add) {
                set.addTarget(view);
            } else {
                set.excludeTarget(view, true);
            }
        }
    }
    if (mStrippedTransitioningViews != null) {
        for (int i = mStrippedTransitioningViews.size() - 1; i >= 0; i--) {
            View view = mStrippedTransitioningViews.get(i);
            set.excludeTarget(view, true);
        }
    }
    // By adding the transition after addTarget, we prevent addTarget from
    // affecting transition.
    set.addTransition(transition);
    if (!add && mTransitioningViews != null && !mTransitioningViews.isEmpty()) {
        // Allow children of excluded transitioning views, but not the views themselves
        set = new TransitionSet().addTransition(set);
    }
    return set;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"A new block of code handling `mStrippedTransitioningViews` was added that excludes targets from the `set`. This changes the code under the control statement because it's introducing an additional loop and modification to the `set`. Hence, it is a control dependency change (3). There is also a change in other statements due to the introduction of the new for-loop (4).","Although there is a significant change in the method implementation, there is no Compatibility Issue because the method's contract seems to remain the same. It still returns a TransitionSet object, and the potential behavior alterations are internal with no visible effect on the return type or the exceptions thrown by the method as per the given implementation."
697,"<com.android.server.backup.SystemBackupAgent: void onRestore(BackupDataInput,int,ParcelFileDescriptor)>",25,26,"<com.android.server.backup.SystemBackupAgent: void onRestore(BackupDataInput,int,ParcelFileDescriptor)>","<com.android.server.backup.SystemBackupAgent: void onRestore(BackupDataInput,int,ParcelFileDescriptor)>",0,"{
    // Slot in a restore helper for the older wallpaper backup schema to support restore
    // from devices still generating data in that format.
    mWallpaperHelper = new WallpaperBackupHelper(this, new String[] { WALLPAPER_IMAGE, WALLPAPER_INFO }, new String[] { WALLPAPER_IMAGE_KEY, WALLPAPER_INFO_KEY });
    addHelper(WALLPAPER_HELPER, mWallpaperHelper);
    // On restore, we also support a long-ago wallpaper data schema ""system_files""
    addHelper(""system_files"", new WallpaperBackupHelper(this, new String[] { WALLPAPER_IMAGE }, new String[] { WALLPAPER_IMAGE_KEY }));
    addHelper(SYNC_SETTINGS_HELPER, new AccountSyncSettingsBackupHelper(this));
    addHelper(PREFERRED_HELPER, new PreferredActivityBackupHelper());
    addHelper(NOTIFICATION_HELPER, new NotificationBackupHelper(this));
    addHelper(PERMISSION_HELPER, new PermissionBackupHelper());
    addHelper(USAGE_STATS_HELPER, new UsageStatsBackupHelper(this));
    addHelper(SHORTCUT_MANAGER_HELPER, new ShortcutBackupHelper());
    try {
        super.onRestore(data, appVersionCode, newState);
        IWallpaperManager wallpaper = (IWallpaperManager) ServiceManager.getService(Context.WALLPAPER_SERVICE);
        if (wallpaper != null) {
            try {
                wallpaper.settingsRestored();
            } catch (RemoteException re) {
                Slog.e(TAG, ""Couldn't restore settings\n"" + re);
            }
        }
    } catch (IOException ex) {
        // If there was a failure, delete everything for the wallpaper, this is too aggressive,
        // but this is hopefully a rare failure.
        Slog.d(TAG, ""restore failed"", ex);
        (new File(WALLPAPER_IMAGE)).delete();
        (new File(WALLPAPER_INFO)).delete();
    }
}","{
    // Slot in a restore helper for the older wallpaper backup schema to support restore
    // from devices still generating data in that format.
    mWallpaperHelper = new WallpaperBackupHelper(this, new String[] { WALLPAPER_IMAGE, WALLPAPER_INFO }, new String[] { WALLPAPER_IMAGE_KEY, WALLPAPER_INFO_KEY });
    addHelper(WALLPAPER_HELPER, mWallpaperHelper);
    // On restore, we also support a long-ago wallpaper data schema ""system_files""
    addHelper(""system_files"", new WallpaperBackupHelper(this, new String[] { WALLPAPER_IMAGE }, new String[] { WALLPAPER_IMAGE_KEY }));
    addHelper(SYNC_SETTINGS_HELPER, new AccountSyncSettingsBackupHelper(this));
    addHelper(PREFERRED_HELPER, new PreferredActivityBackupHelper());
    addHelper(NOTIFICATION_HELPER, new NotificationBackupHelper(this));
    addHelper(PERMISSION_HELPER, new PermissionBackupHelper());
    addHelper(USAGE_STATS_HELPER, new UsageStatsBackupHelper(this));
    addHelper(SHORTCUT_MANAGER_HELPER, new ShortcutBackupHelper());
    addHelper(ACCOUNT_MANAGER_HELPER, new AccountManagerBackupHelper());
    try {
        super.onRestore(data, appVersionCode, newState);
        IWallpaperManager wallpaper = (IWallpaperManager) ServiceManager.getService(Context.WALLPAPER_SERVICE);
        if (wallpaper != null) {
            try {
                wallpaper.settingsRestored();
            } catch (RemoteException re) {
                Slog.e(TAG, ""Couldn't restore settings\n"" + re);
            }
        }
    } catch (IOException ex) {
        // If there was a failure, delete everything for the wallpaper, this is too aggressive,
        // but this is hopefully a rare failure.
        Slog.d(TAG, ""restore failed"", ex);
        (new File(WALLPAPER_IMAGE)).delete();
        (new File(WALLPAPER_INFO)).delete();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"There is an addition of a new helper, addHelper(ACCOUNT_MANAGER_HELPER, new AccountManagerBackupHelper()), in the late version of the implementation, so the code change type is 4 (Other statement changed).","The addition of a new helper does not change the method's control flow or exception handling and should not affect its return type or value since it's a void method, so there's no Compatibility Issue."
699,<android.view.View: boolean onTouchEvent(MotionEvent)>,25,26,<android.view.View: boolean onTouchEvent(MotionEvent)>,<android.view.View: boolean onTouchEvent(MotionEvent)>,0,"{
    final float x = event.getX();
    final float y = event.getY();
    final int viewFlags = mViewFlags;
    final int action = event.getAction();
    if ((viewFlags & ENABLED_MASK) == DISABLED) {
        if (action == MotionEvent.ACTION_UP && (mPrivateFlags & PFLAG_PRESSED) != 0) {
            setPressed(false);
        }
        // events, it just doesn't respond to them.
        return (((viewFlags & CLICKABLE) == CLICKABLE || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags & CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE);
    }
    if (mTouchDelegate != null) {
        if (mTouchDelegate.onTouchEvent(event)) {
            return true;
        }
    }
    if (((viewFlags & CLICKABLE) == CLICKABLE || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags & CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) {
        switch(action) {
            case MotionEvent.ACTION_UP:
                boolean prepressed = (mPrivateFlags & PFLAG_PREPRESSED) != 0;
                if ((mPrivateFlags & PFLAG_PRESSED) != 0 || prepressed) {
                    // take focus if we don't have it already and we should in
                    // touch mode.
                    boolean focusTaken = false;
                    if (isFocusable() && isFocusableInTouchMode() && !isFocused()) {
                        focusTaken = requestFocus();
                    }
                    if (prepressed) {
                        // The button is being released before we actually
                        // showed it as pressed.  Make it show the pressed
                        // state now (before scheduling the click) to ensure
                        // the user sees it.
                        setPressed(true, x, y);
                    }
                    if (!mHasPerformedLongPress && !mIgnoreNextUpEvent) {
                        // This is a tap, so remove the longpress check
                        removeLongPressCallback();
                        // Only perform take click actions if we were in the pressed state
                        if (!focusTaken) {
                            // of the view update before click actions start.
                            if (mPerformClick == null) {
                                mPerformClick = new PerformClick();
                            }
                            if (!post(mPerformClick)) {
                                performClick();
                            }
                        }
                    }
                    if (mUnsetPressedState == null) {
                        mUnsetPressedState = new UnsetPressedState();
                    }
                    if (prepressed) {
                        postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration());
                    } else if (!post(mUnsetPressedState)) {
                        // If the post failed, unpress right now
                        mUnsetPressedState.run();
                    }
                    removeTapCallback();
                }
                mIgnoreNextUpEvent = false;
                break;
            case MotionEvent.ACTION_DOWN:
                mHasPerformedLongPress = false;
                if (performButtonActionOnTouchDown(event)) {
                    break;
                }
                // Walk up the hierarchy to determine if we're inside a scrolling container.
                boolean isInScrollingContainer = isInScrollingContainer();
                // a short period in case this is a scroll.
                if (isInScrollingContainer) {
                    mPrivateFlags |= PFLAG_PREPRESSED;
                    if (mPendingCheckForTap == null) {
                        mPendingCheckForTap = new CheckForTap();
                    }
                    mPendingCheckForTap.x = event.getX();
                    mPendingCheckForTap.y = event.getY();
                    postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
                } else {
                    // Not inside a scrolling container, so show the feedback right away
                    setPressed(true, x, y);
                    checkForLongClick(0, x, y);
                }
                break;
            case MotionEvent.ACTION_CANCEL:
                setPressed(false);
                removeTapCallback();
                removeLongPressCallback();
                mInContextButtonPress = false;
                mHasPerformedLongPress = false;
                mIgnoreNextUpEvent = false;
                break;
            case MotionEvent.ACTION_MOVE:
                drawableHotspotChanged(x, y);
                // Be lenient about moving outside of buttons
                if (!pointInView(x, y, mTouchSlop)) {
                    // Outside button
                    removeTapCallback();
                    if ((mPrivateFlags & PFLAG_PRESSED) != 0) {
                        // Remove any future long press/tap checks
                        removeLongPressCallback();
                        setPressed(false);
                    }
                }
                break;
        }
        return true;
    }
    return false;
}","{
    final float x = event.getX();
    final float y = event.getY();
    final int viewFlags = mViewFlags;
    final int action = event.getAction();
    final boolean clickable = ((viewFlags & CLICKABLE) == CLICKABLE || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags & CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;
    if ((viewFlags & ENABLED_MASK) == DISABLED) {
        if (action == MotionEvent.ACTION_UP && (mPrivateFlags & PFLAG_PRESSED) != 0) {
            setPressed(false);
        }
        mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;
        // events, it just doesn't respond to them.
        return clickable;
    }
    if (mTouchDelegate != null) {
        if (mTouchDelegate.onTouchEvent(event)) {
            return true;
        }
    }
    if (clickable || (viewFlags & TOOLTIP) == TOOLTIP) {
        switch(action) {
            case MotionEvent.ACTION_UP:
                mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;
                if ((viewFlags & TOOLTIP) == TOOLTIP) {
                    handleTooltipUp();
                }
                if (!clickable) {
                    removeTapCallback();
                    removeLongPressCallback();
                    mInContextButtonPress = false;
                    mHasPerformedLongPress = false;
                    mIgnoreNextUpEvent = false;
                    break;
                }
                boolean prepressed = (mPrivateFlags & PFLAG_PREPRESSED) != 0;
                if ((mPrivateFlags & PFLAG_PRESSED) != 0 || prepressed) {
                    // take focus if we don't have it already and we should in
                    // touch mode.
                    boolean focusTaken = false;
                    if (isFocusable() && isFocusableInTouchMode() && !isFocused()) {
                        focusTaken = requestFocus();
                    }
                    if (prepressed) {
                        // The button is being released before we actually
                        // showed it as pressed.  Make it show the pressed
                        // state now (before scheduling the click) to ensure
                        // the user sees it.
                        setPressed(true, x, y);
                    }
                    if (!mHasPerformedLongPress && !mIgnoreNextUpEvent) {
                        // This is a tap, so remove the longpress check
                        removeLongPressCallback();
                        // Only perform take click actions if we were in the pressed state
                        if (!focusTaken) {
                            // of the view update before click actions start.
                            if (mPerformClick == null) {
                                mPerformClick = new PerformClick();
                            }
                            if (!post(mPerformClick)) {
                                performClick();
                            }
                        }
                    }
                    if (mUnsetPressedState == null) {
                        mUnsetPressedState = new UnsetPressedState();
                    }
                    if (prepressed) {
                        postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration());
                    } else if (!post(mUnsetPressedState)) {
                        // If the post failed, unpress right now
                        mUnsetPressedState.run();
                    }
                    removeTapCallback();
                }
                mIgnoreNextUpEvent = false;
                break;
            case MotionEvent.ACTION_DOWN:
                if (event.getSource() == InputDevice.SOURCE_TOUCHSCREEN) {
                    mPrivateFlags3 |= PFLAG3_FINGER_DOWN;
                }
                mHasPerformedLongPress = false;
                if (!clickable) {
                    checkForLongClick(0, x, y);
                    break;
                }
                if (performButtonActionOnTouchDown(event)) {
                    break;
                }
                // Walk up the hierarchy to determine if we're inside a scrolling container.
                boolean isInScrollingContainer = isInScrollingContainer();
                // a short period in case this is a scroll.
                if (isInScrollingContainer) {
                    mPrivateFlags |= PFLAG_PREPRESSED;
                    if (mPendingCheckForTap == null) {
                        mPendingCheckForTap = new CheckForTap();
                    }
                    mPendingCheckForTap.x = event.getX();
                    mPendingCheckForTap.y = event.getY();
                    postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
                } else {
                    // Not inside a scrolling container, so show the feedback right away
                    setPressed(true, x, y);
                    checkForLongClick(0, x, y);
                }
                break;
            case MotionEvent.ACTION_CANCEL:
                if (clickable) {
                    setPressed(false);
                }
                removeTapCallback();
                removeLongPressCallback();
                mInContextButtonPress = false;
                mHasPerformedLongPress = false;
                mIgnoreNextUpEvent = false;
                mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;
                break;
            case MotionEvent.ACTION_MOVE:
                if (clickable) {
                    drawableHotspotChanged(x, y);
                }
                // Be lenient about moving outside of buttons
                if (!pointInView(x, y, mTouchSlop)) {
                    // Outside button
                    // Remove any future long press/tap checks
                    removeTapCallback();
                    removeLongPressCallback();
                    if ((mPrivateFlags & PFLAG_PRESSED) != 0) {
                        setPressed(false);
                    }
                    mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;
                }
                break;
        }
        return true;
    }
    return false;
}",1,"/**
 * Implement this method to handle touch screen motion events.
 * <p>
 * If this method is used to detect click actions, it is recommended that
 * the actions be performed by implementing and calling
 * {@link #performClick()}. This will ensure consistent system behavior,
 * including:
 * <ul>
 * <li>obeying click sound preferences
 * <li>dispatching OnClickListener calls
 * <li>handling {@link AccessibilityNodeInfo#ACTION_CLICK ACTION_CLICK} when
 * accessibility features are enabled
 * </ul>
 *
 * @param event The motion event.
 * @return True if the event was handled, false otherwise.
 */
","/**
 * Implement this method to handle touch screen motion events.
 * <p>
 * If this method is used to detect click actions, it is recommended that
 * the actions be performed by implementing and calling
 * {@link #performClick()}. This will ensure consistent system behavior,
 * including:
 * <ul>
 * <li>obeying click sound preferences
 * <li>dispatching OnClickListener calls
 * <li>handling {@link AccessibilityNodeInfo#ACTION_CLICK ACTION_CLICK} when
 * accessibility features are enabled
 * </ul>
 *
 * @param event The motion event.
 * @return True if the event was handled, false otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
700,<android.app.Notification: String toString()>,25,26,<android.app.Notification: String toString()>,<android.app.Notification: String toString()>,0,"{
    StringBuilder sb = new StringBuilder();
    sb.append(""Notification(pri="");
    sb.append(priority);
    sb.append("" contentView="");
    if (contentView != null) {
        sb.append(contentView.getPackage());
        sb.append(""/0x"");
        sb.append(Integer.toHexString(contentView.getLayoutId()));
    } else {
        sb.append(""null"");
    }
    sb.append("" vibrate="");
    if ((this.defaults & DEFAULT_VIBRATE) != 0) {
        sb.append(""default"");
    } else if (this.vibrate != null) {
        int N = this.vibrate.length - 1;
        sb.append(""["");
        for (int i = 0; i < N; i++) {
            sb.append(this.vibrate[i]);
            sb.append(',');
        }
        if (N != -1) {
            sb.append(this.vibrate[N]);
        }
        sb.append(""]"");
    } else {
        sb.append(""null"");
    }
    sb.append("" sound="");
    if ((this.defaults & DEFAULT_SOUND) != 0) {
        sb.append(""default"");
    } else if (this.sound != null) {
        sb.append(this.sound.toString());
    } else {
        sb.append(""null"");
    }
    if (this.tickerText != null) {
        sb.append("" tick"");
    }
    sb.append("" defaults=0x"");
    sb.append(Integer.toHexString(this.defaults));
    sb.append("" flags=0x"");
    sb.append(Integer.toHexString(this.flags));
    sb.append(String.format("" color=0x%08x"", this.color));
    if (this.category != null) {
        sb.append("" category="");
        sb.append(this.category);
    }
    if (this.mGroupKey != null) {
        sb.append("" groupKey="");
        sb.append(this.mGroupKey);
    }
    if (this.mSortKey != null) {
        sb.append("" sortKey="");
        sb.append(this.mSortKey);
    }
    if (actions != null) {
        sb.append("" actions="");
        sb.append(actions.length);
    }
    sb.append("" vis="");
    sb.append(visibilityToString(this.visibility));
    if (this.publicVersion != null) {
        sb.append("" publicVersion="");
        sb.append(publicVersion.toString());
    }
    sb.append("")"");
    return sb.toString();
}","{
    StringBuilder sb = new StringBuilder();
    sb.append(""Notification(channel="");
    sb.append(getChannelId());
    sb.append("" pri="");
    sb.append(priority);
    sb.append("" contentView="");
    if (contentView != null) {
        sb.append(contentView.getPackage());
        sb.append(""/0x"");
        sb.append(Integer.toHexString(contentView.getLayoutId()));
    } else {
        sb.append(""null"");
    }
    sb.append("" vibrate="");
    if ((this.defaults & DEFAULT_VIBRATE) != 0) {
        sb.append(""default"");
    } else if (this.vibrate != null) {
        int N = this.vibrate.length - 1;
        sb.append(""["");
        for (int i = 0; i < N; i++) {
            sb.append(this.vibrate[i]);
            sb.append(',');
        }
        if (N != -1) {
            sb.append(this.vibrate[N]);
        }
        sb.append(""]"");
    } else {
        sb.append(""null"");
    }
    sb.append("" sound="");
    if ((this.defaults & DEFAULT_SOUND) != 0) {
        sb.append(""default"");
    } else if (this.sound != null) {
        sb.append(this.sound.toString());
    } else {
        sb.append(""null"");
    }
    if (this.tickerText != null) {
        sb.append("" tick"");
    }
    sb.append("" defaults=0x"");
    sb.append(Integer.toHexString(this.defaults));
    sb.append("" flags=0x"");
    sb.append(Integer.toHexString(this.flags));
    sb.append(String.format("" color=0x%08x"", this.color));
    if (this.category != null) {
        sb.append("" category="");
        sb.append(this.category);
    }
    if (this.mGroupKey != null) {
        sb.append("" groupKey="");
        sb.append(this.mGroupKey);
    }
    if (this.mSortKey != null) {
        sb.append("" sortKey="");
        sb.append(this.mSortKey);
    }
    if (actions != null) {
        sb.append("" actions="");
        sb.append(actions.length);
    }
    sb.append("" vis="");
    sb.append(visibilityToString(this.visibility));
    if (this.publicVersion != null) {
        sb.append("" publicVersion="");
        sb.append(publicVersion.toString());
    }
    sb.append("")"");
    return sb.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The code adds additional information about the notification channel to the string that is built and returned. Therefore, there is a statement added that includes the getChannelId() method, so the change type is 4.","While there is a change to the string returned by the toString() method, which constitutes an Other statement change, this change does not affect the behavior of how the method operates in any way that would cause a Compatibility Issue. The toString method will still return a String as before, albeit with more information. There are no changes to the logic, control flow, return types, exceptions, or the structure of the data being returned, so there's no Compatibility Issue according to the given definitions."
702,<android.app.ActivityManager: PendingIntent getRunningServiceControlPanel(ComponentName)>,25,26,<android.app.ActivityManager: PendingIntent getRunningServiceControlPanel(ComponentName)>,<android.app.ActivityManager: PendingIntent getRunningServiceControlPanel(ComponentName)>,0,"{
    try {
        return ActivityManagerNative.getDefault().getRunningServiceControlPanel(service);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        return getService().getRunningServiceControlPanel(service);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns a PendingIntent you can start to show a control panel for the
 * given running service.  If the service does not have a control panel,
 * null is returned.
 */
","/**
 * Returns a PendingIntent you can start to show a control panel for the
 * given running service.  If the service does not have a control panel,
 * null is returned.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method used to retrieve the service instance has been changed from a direct call to ActivityManagerNative.getDefault() to a call of a separate method getService(). So there is a change in the non-control statements, categorized as type 4, and there is a change in the dependent API, categorized as type 5.","Since the exception handling and the method's final action (returning the result of getRunningServiceControlPanel) remain the same, despite the change in how the service instance is obtained, there is no change in the behaviour of the API from a caller's perspective. Therefore, there is no compatibility issue, which means pred_CI is 0."
704,<android.view.View: String toString()>,25,26,<android.view.View: String toString()>,<android.view.View: String toString()>,0,"{
    StringBuilder out = new StringBuilder(128);
    out.append(getClass().getName());
    out.append('{');
    out.append(Integer.toHexString(System.identityHashCode(this)));
    out.append(' ');
    switch(mViewFlags & VISIBILITY_MASK) {
        case VISIBLE:
            out.append('V');
            break;
        case INVISIBLE:
            out.append('I');
            break;
        case GONE:
            out.append('G');
            break;
        default:
            out.append('.');
            break;
    }
    out.append((mViewFlags & FOCUSABLE_MASK) == FOCUSABLE ? 'F' : '.');
    out.append((mViewFlags & ENABLED_MASK) == ENABLED ? 'E' : '.');
    out.append((mViewFlags & DRAW_MASK) == WILL_NOT_DRAW ? '.' : 'D');
    out.append((mViewFlags & SCROLLBARS_HORIZONTAL) != 0 ? 'H' : '.');
    out.append((mViewFlags & SCROLLBARS_VERTICAL) != 0 ? 'V' : '.');
    out.append((mViewFlags & CLICKABLE) != 0 ? 'C' : '.');
    out.append((mViewFlags & LONG_CLICKABLE) != 0 ? 'L' : '.');
    out.append((mViewFlags & CONTEXT_CLICKABLE) != 0 ? 'X' : '.');
    out.append(' ');
    out.append((mPrivateFlags & PFLAG_IS_ROOT_NAMESPACE) != 0 ? 'R' : '.');
    out.append((mPrivateFlags & PFLAG_FOCUSED) != 0 ? 'F' : '.');
    out.append((mPrivateFlags & PFLAG_SELECTED) != 0 ? 'S' : '.');
    if ((mPrivateFlags & PFLAG_PREPRESSED) != 0) {
        out.append('p');
    } else {
        out.append((mPrivateFlags & PFLAG_PRESSED) != 0 ? 'P' : '.');
    }
    out.append((mPrivateFlags & PFLAG_HOVERED) != 0 ? 'H' : '.');
    out.append((mPrivateFlags & PFLAG_ACTIVATED) != 0 ? 'A' : '.');
    out.append((mPrivateFlags & PFLAG_INVALIDATED) != 0 ? 'I' : '.');
    out.append((mPrivateFlags & PFLAG_DIRTY_MASK) != 0 ? 'D' : '.');
    out.append(' ');
    out.append(mLeft);
    out.append(',');
    out.append(mTop);
    out.append('-');
    out.append(mRight);
    out.append(',');
    out.append(mBottom);
    final int id = getId();
    if (id != NO_ID) {
        out.append("" #"");
        out.append(Integer.toHexString(id));
        final Resources r = mResources;
        if (id > 0 && Resources.resourceHasPackage(id) && r != null) {
            try {
                String pkgname;
                switch(id & 0xff000000) {
                    case 0x7f000000:
                        pkgname = ""app"";
                        break;
                    case 0x01000000:
                        pkgname = ""android"";
                        break;
                    default:
                        pkgname = r.getResourcePackageName(id);
                        break;
                }
                String typename = r.getResourceTypeName(id);
                String entryname = r.getResourceEntryName(id);
                out.append("" "");
                out.append(pkgname);
                out.append("":"");
                out.append(typename);
                out.append(""/"");
                out.append(entryname);
            } catch (Resources.NotFoundException e) {
            }
        }
    }
    out.append(""}"");
    return out.toString();
}","{
    StringBuilder out = new StringBuilder(128);
    out.append(getClass().getName());
    out.append('{');
    out.append(Integer.toHexString(System.identityHashCode(this)));
    out.append(' ');
    switch(mViewFlags & VISIBILITY_MASK) {
        case VISIBLE:
            out.append('V');
            break;
        case INVISIBLE:
            out.append('I');
            break;
        case GONE:
            out.append('G');
            break;
        default:
            out.append('.');
            break;
    }
    out.append((mViewFlags & FOCUSABLE) == FOCUSABLE ? 'F' : '.');
    out.append((mViewFlags & ENABLED_MASK) == ENABLED ? 'E' : '.');
    out.append((mViewFlags & DRAW_MASK) == WILL_NOT_DRAW ? '.' : 'D');
    out.append((mViewFlags & SCROLLBARS_HORIZONTAL) != 0 ? 'H' : '.');
    out.append((mViewFlags & SCROLLBARS_VERTICAL) != 0 ? 'V' : '.');
    out.append((mViewFlags & CLICKABLE) != 0 ? 'C' : '.');
    out.append((mViewFlags & LONG_CLICKABLE) != 0 ? 'L' : '.');
    out.append((mViewFlags & CONTEXT_CLICKABLE) != 0 ? 'X' : '.');
    out.append(' ');
    out.append((mPrivateFlags & PFLAG_IS_ROOT_NAMESPACE) != 0 ? 'R' : '.');
    out.append((mPrivateFlags & PFLAG_FOCUSED) != 0 ? 'F' : '.');
    out.append((mPrivateFlags & PFLAG_SELECTED) != 0 ? 'S' : '.');
    if ((mPrivateFlags & PFLAG_PREPRESSED) != 0) {
        out.append('p');
    } else {
        out.append((mPrivateFlags & PFLAG_PRESSED) != 0 ? 'P' : '.');
    }
    out.append((mPrivateFlags & PFLAG_HOVERED) != 0 ? 'H' : '.');
    out.append((mPrivateFlags & PFLAG_ACTIVATED) != 0 ? 'A' : '.');
    out.append((mPrivateFlags & PFLAG_INVALIDATED) != 0 ? 'I' : '.');
    out.append((mPrivateFlags & PFLAG_DIRTY_MASK) != 0 ? 'D' : '.');
    out.append(' ');
    out.append(mLeft);
    out.append(',');
    out.append(mTop);
    out.append('-');
    out.append(mRight);
    out.append(',');
    out.append(mBottom);
    final int id = getId();
    if (id != NO_ID) {
        out.append("" #"");
        out.append(Integer.toHexString(id));
        final Resources r = mResources;
        if (id > 0 && Resources.resourceHasPackage(id) && r != null) {
            try {
                String pkgname;
                switch(id & 0xff000000) {
                    case 0x7f000000:
                        pkgname = ""app"";
                        break;
                    case 0x01000000:
                        pkgname = ""android"";
                        break;
                    default:
                        pkgname = r.getResourcePackageName(id);
                        break;
                }
                String typename = r.getResourceTypeName(id);
                String entryname = r.getResourceEntryName(id);
                out.append("" "");
                out.append(pkgname);
                out.append("":"");
                out.append(typename);
                out.append(""/"");
                out.append(entryname);
            } catch (Resources.NotFoundException e) {
            }
        }
    }
    out.append(""}"");
    return out.toString();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
706,<android.hardware.usb.UsbDeviceConnection: UsbRequest requestWait()>,25,26,<android.hardware.usb.UsbDeviceConnection: UsbRequest requestWait()>,<android.hardware.usb.UsbDeviceConnection: UsbRequest requestWait()>,0,"{
    UsbRequest request = native_request_wait();
    if (request != null) {
        request.dequeue();
    }
    return request;
}","{
    UsbRequest request = null;
    try {
        // -1 is special value indicating infinite wait
        request = native_request_wait(-1);
    } catch (TimeoutException e) {
    // Does not happen, infinite timeout
    }
    if (request != null) {
        request.dequeue(mContext.getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.O);
    }
    return request;
}",1,"/**
 * Waits for the result of a {@link android.hardware.usb.UsbRequest#queue} operation
 * Note that this may return requests queued on multiple
 * {@link android.hardware.usb.UsbEndpoint}s.
 * When multiple endpoints are in use, {@link android.hardware.usb.UsbRequest#getEndpoint} and
 * {@link android.hardware.usb.UsbRequest#getClientData} can be useful in determining
 * how to process the result of this function.
 *
 * @return a completed USB request, or null if an error occurred
 */
","/**
 * Waits for the result of a {@link android.hardware.usb.UsbRequest#queue} operation
 * <p>Note that this may return requests queued on multiple
 * {@link android.hardware.usb.UsbEndpoint}s. When multiple endpoints are in use,
 * {@link android.hardware.usb.UsbRequest#getEndpoint} and {@link
 * android.hardware.usb.UsbRequest#getClientData} can be useful in determining how to process
 * the result of this function.</p>
 *
 * @return a completed USB request, or null if an error occurred
 *
 * @throws IllegalArgumentException Before API {@value Build.VERSION_CODES#O}: if the number of
 * bytes read or written is more than the limit of the
 * request's buffer. The number of bytes is determined by the
 * {@code length} parameter of
 * {@link UsbRequest#queue(ByteBuffer, int)}
 * @throws BufferOverflowException In API {@value Build.VERSION_CODES#O} and after: if the
 * number of bytes read or written is more than the limit of the
 * request's buffer. The number of bytes is determined by the
 * {@code length} parameter of
 * {@link UsbRequest#queue(ByteBuffer, int)}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,3,4,5","1,2","The early implementation of `requestWait()` calls `native_request_wait()` with no parameters, while the late version uses a special value `-1` indicating infinite wait as a parameter to the same method. A new 'try' block has been introduced which includes a 'catch' for a `TimeoutException`, which was not present in the previous version. Also, there is a change in the argument passed to `request.dequeue()`, where it now depends on the target SDK version. There are new control dependencies introduced with the `try` block and the 'if' condition inside the `dequeue()` method call. Thus, the code has changed in terms of return statements, exception handling, control dependencies, other statements, and dependent APIs.","The changes to the return statement and exception handling may potentially cause different behavior. The inclusion of a `TimeoutException` in late version implies that an exception might be expected to be thrown under certain conditions, while early version did not tackle any exceptions. The implementation now is tied to the `Context` and `Build.VERSION_CODES.O`, implementing a conditional behavior based on the target SDK version that did not exist previously. This could lead to different exceptions being thrown or different return values, depending on whether the condition inside `dequeue()` evaluates to true or false. Therefore, there are potential Compatibility Issues due to changes in the type of object returned and how exceptions may be handled."
707,"<android.service.voice.VoiceInteractionSession: void doShow(Bundle,int,IVoiceInteractionSessionShowCallback)>",25,26,"<android.service.voice.VoiceInteractionSession: void doShow(Bundle,int,IVoiceInteractionSessionShowCallback)>","<android.service.voice.VoiceInteractionSession: void doShow(Bundle,int,IVoiceInteractionSessionShowCallback)>",0,"{
    if (DEBUG)
        Log.v(TAG, ""Showing window: mWindowAdded="" + mWindowAdded + "" mWindowVisible="" + mWindowVisible);
    if (mInShowWindow) {
        Log.w(TAG, ""Re-entrance in to showWindow"");
        return;
    }
    try {
        mInShowWindow = true;
        if (!mWindowVisible) {
            if (!mWindowAdded) {
                mWindowAdded = true;
                View v = onCreateContentView();
                if (v != null) {
                    setContentView(v);
                }
            }
        }
        onShow(args, flags);
        if (!mWindowVisible) {
            mWindowVisible = true;
            mWindow.show();
        }
        if (showCallback != null) {
            mRootView.invalidate();
            mRootView.getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {

                @Override
                public boolean onPreDraw() {
                    mRootView.getViewTreeObserver().removeOnPreDrawListener(this);
                    try {
                        showCallback.onShown();
                    } catch (RemoteException e) {
                        Log.w(TAG, ""Error calling onShown"", e);
                    }
                    return true;
                }
            });
        }
    } finally {
        mWindowWasVisible = true;
        mInShowWindow = false;
    }
}","{
    if (DEBUG)
        Log.v(TAG, ""Showing window: mWindowAdded="" + mWindowAdded + "" mWindowVisible="" + mWindowVisible);
    if (mInShowWindow) {
        Log.w(TAG, ""Re-entrance in to showWindow"");
        return;
    }
    try {
        mInShowWindow = true;
        onPrepareShow(args, flags);
        if (!mWindowVisible) {
            ensureWindowAdded();
        }
        onShow(args, flags);
        if (!mWindowVisible) {
            mWindowVisible = true;
            if (mUiEnabled) {
                mWindow.show();
            }
        }
        if (showCallback != null) {
            if (mUiEnabled) {
                mRootView.invalidate();
                mRootView.getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {

                    @Override
                    public boolean onPreDraw() {
                        mRootView.getViewTreeObserver().removeOnPreDrawListener(this);
                        try {
                            showCallback.onShown();
                        } catch (RemoteException e) {
                            Log.w(TAG, ""Error calling onShown"", e);
                        }
                        return true;
                    }
                });
            } else {
                try {
                    showCallback.onShown();
                } catch (RemoteException e) {
                    Log.w(TAG, ""Error calling onShown"", e);
                }
            }
        }
    } finally {
        mWindowWasVisible = true;
        mInShowWindow = false;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,The code changes between the two versions include:,- Checking the value of mUiEnabled before calling mWindow.show() and before invalidation and adding a listener to mRootView.
708,<android.os.StrictMode.ThreadPolicy.Builder: Builder detectAll()>,25,26,<android.os.StrictMode.ThreadPolicy.Builder: Builder detectAll()>,<android.os.StrictMode.ThreadPolicy.Builder: Builder detectAll()>,0,"{
    return enable(ALL_THREAD_DETECT_BITS);
}","{
    detectDiskReads();
    detectDiskWrites();
    detectNetwork();
    final int targetSdk = VMRuntime.getRuntime().getTargetSdkVersion();
    if (targetSdk >= Build.VERSION_CODES.HONEYCOMB) {
        detectCustomSlowCalls();
    }
    if (targetSdk >= Build.VERSION_CODES.M) {
        detectResourceMismatches();
    }
    if (targetSdk >= Build.VERSION_CODES.O) {
        detectUnbufferedIo();
    }
    return this;
}",1,"/**
 * Detect everything that's potentially suspect.
 *
 * <p>As of the Gingerbread release this includes network and
 * disk operations but will likely expand in future releases.
 */
","/**
 * Detect everything that's potentially suspect.
 *
 * <p>As of the Gingerbread release this includes network and
 * disk operations but will likely expand in future releases.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",1,"The late implementation contains additional method calls that configure the builder differently based on the target SDK version. Also, there is a change of control dependency due to the inclusion of if statements based on different SDK versions (HONEYCOMB, M, O). The dependent API behavior changed significantly because different methods like detectDiskReads(), detectDiskWrites(), etc., are now being called instead of a single method enable(ALL_THREAD_DETECT_BITS). These changes classify as types 3, 4, and 5.","Each added method call and if check introduces a new behavior that did not exist in the previous version, which can lead to the API returning a differently configured `Builder` object depending on the target SDK version. This is a compatibility issue of type 1 as the return value (type) from the method can be affected."
710,<android.app.Activity: boolean isVoiceInteractionRoot()>,25,26,<android.app.Activity: boolean isVoiceInteractionRoot()>,<android.app.Activity: boolean isVoiceInteractionRoot()>,0,"{
    try {
        return mVoiceInteractor != null && ActivityManagerNative.getDefault().isRootVoiceInteraction(mToken);
    } catch (RemoteException e) {
    }
    return false;
}","{
    try {
        return mVoiceInteractor != null && ActivityManager.getService().isRootVoiceInteraction(mToken);
    } catch (RemoteException e) {
    }
    return false;
}",1,"/**
 * Like {@link #isVoiceInteraction}, but only returns true if this is also the root
 * of a voice interaction.  That is, returns true if this activity was directly
 * started by the voice interaction service as the initiation of a voice interaction.
 * Otherwise, for example if it was started by another activity while under voice
 * interaction, returns false.
 */
","/**
 * Like {@link #isVoiceInteraction}, but only returns true if this is also the root
 * of a voice interaction.  That is, returns true if this activity was directly
 * started by the voice interaction service as the initiation of a voice interaction.
 * Otherwise, for example if it was started by another activity while under voice
 * interaction, returns false.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method call within the try block has changed from ActivityManagerNative.getDefault().isRootVoiceInteraction(mToken) to ActivityManager.getService().isRootVoiceInteraction(mToken), which indicates that a dependent API has undergone changes, hence the code change type is 5.","Both versions of the method catch the same exception and both return false outside of the catch block. Thus, this change preserves the behavior of the API in terms of the return value or exception handling, meaning there's no Compatibility Issue, so the CI type is 0."
711,"<android.app.SharedPreferencesImpl.EditorImpl: Editor putInt(String,int)>",25,26,"<android.app.SharedPreferencesImpl.EditorImpl: Editor putInt(String,int)>","<android.app.SharedPreferencesImpl.EditorImpl: Editor putInt(String,int)>",0,"{
    synchronized (this) {
        mModified.put(key, value);
        return this;
    }
}","{
    synchronized (mLock) {
        mModified.put(key, value);
        return this;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change in the implementation is the object on which the synchronized block is locked; it has been changed from `this` to `mLock`. This is a synchronization lock change and is classified as 'Other statement changed'. It may impact thread safety but the overall behavior of the method, in terms of inputs and outputs alone, remains unchanged because it only affected the way the method achieves thread safety.","There are no Compatibility Issues because the return value and the method's behavior in terms of what it does with the inputs have not changed. It still accepts the same parameters and returns the same object (`this`), and there is no indication of a change in exception handling or contract of the method."
713,<android.view.accessibility.AccessibilityWindowInfo: AccessibilityNodeInfo getRoot()>,25,26,<android.view.accessibility.AccessibilityWindowInfo: AccessibilityNodeInfo getRoot()>,<android.view.accessibility.AccessibilityWindowInfo: AccessibilityNodeInfo getRoot()>,0,"{
    if (mConnectionId == UNDEFINED) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mId, AccessibilityNodeInfo.ROOT_NODE_ID, true, AccessibilityNodeInfo.FLAG_PREFETCH_DESCENDANTS);
}","{
    if (mConnectionId == UNDEFINED_WINDOW_ID) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mId, AccessibilityNodeInfo.ROOT_NODE_ID, true, AccessibilityNodeInfo.FLAG_PREFETCH_DESCENDANTS, null);
}",1,"/**
 * Gets the root node in the window's hierarchy.
 *
 * @return The root node.
 */
","/**
 * Gets the root node in the window's hierarchy.
 *
 * @return The root node.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The constant used in the 'if' condition statement has changed from UNDEFINED to UNDEFINED_WINDOW_ID, and a new parameter (null) has been added to the method call of client.findAccessibilityNodeInfoByAccessibilityId. Therefore, the change types are 1,5.","Since the constant used in the condition is changed, it may alter whether the method returns null or not for some cases. This could potentially result in a different return value, leading to a Compatibility Issue of type 1."
714,<android.widget.TabWidget: void addView(View)>,25,26,<android.widget.TabWidget: void addView(View)>,<android.widget.TabWidget: void addView(View)>,0,"{
    if (child.getLayoutParams() == null) {
        final LinearLayout.LayoutParams lp = new LayoutParams(0, ViewGroup.LayoutParams.MATCH_PARENT, 1.0f);
        lp.setMargins(0, 0, 0, 0);
        child.setLayoutParams(lp);
    }
    // Ensure you can navigate to the tab with the keyboard, and you can touch it
    child.setFocusable(true);
    child.setClickable(true);
    super.addView(child);
    // TODO: detect this via geometry with a tabwidget listener rather
    // than potentially interfere with the view's listener
    child.setOnClickListener(new TabClickListener(getTabCount() - 1));
}","{
    if (child.getLayoutParams() == null) {
        final LinearLayout.LayoutParams lp = new LayoutParams(0, ViewGroup.LayoutParams.MATCH_PARENT, 1.0f);
        lp.setMargins(0, 0, 0, 0);
        child.setLayoutParams(lp);
    }
    // Ensure you can navigate to the tab with the keyboard, and you can touch it
    child.setFocusable(true);
    child.setClickable(true);
    if (child.getPointerIcon() == null) {
        child.setPointerIcon(PointerIcon.getSystemIcon(getContext(), PointerIcon.TYPE_HAND));
    }
    super.addView(child);
    // TODO: detect this via geometry with a tabwidget listener rather
    // than potentially interfere with the view's listener
    child.setOnClickListener(new TabClickListener(getTabCount() - 1));
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The introduction of a new if-statement checking for `child.getPointerIcon() == null`, followed by a call to `child.setPointerIcon()`, represents a new statement added, which is not a return statement, exception handling, or a control dependency change in the context of the existing control structures. Hence, the code change type is 4.","The change in the implementation does not affect the return value (since this is a void method) or the exception handling of the method. The new if-statement and the corresponding call to `setPointerIcon()` are related to UI behavior and do not impact the continuity or functionality of the `addView()` method in a way that could lead to compatibility issues. Therefore, there is no compatibility issue, and the CI type is 0."
715,<android.app.SystemServiceRegistry.StaticServiceFetcher: T getService(ContextImpl)>,25,26,<android.app.SystemServiceRegistry.StaticServiceFetcher: T getService(ContextImpl)>,<android.app.SystemServiceRegistry.StaticServiceFetcher: T getService(ContextImpl)>,0,"{
    synchronized (StaticServiceFetcher.this) {
        if (mCachedInstance == null) {
            mCachedInstance = createService();
        }
        return mCachedInstance;
    }
}","{
    synchronized (StaticServiceFetcher.this) {
        if (mCachedInstance == null) {
            try {
                mCachedInstance = createService();
            } catch (ServiceNotFoundException e) {
                onServiceNotFound(e);
            }
        }
        return mCachedInstance;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,4",2,"The try-catch block has been introduced for the call to createService() and an additional method call onServiceNotFound(e) within the catch block, which are changes of exception handling statement and other statement, so the code change type is 2,4.","The introduction of a new exception handling for ServiceNotFoundException with the call to onServiceNotFound(e) could change the exceptions that the API might throw. Therefore, the CI type is 2."
717,"<android.widget.ActivityChooserView.ActivityChooserViewAdapter: View getView(int,View,ViewGroup)>",25,26,"<android.widget.ActivityChooserView.ActivityChooserViewAdapter: View getView(int,View,ViewGroup)>","<android.widget.ActivityChooserView.ActivityChooserViewAdapter: View getView(int,View,ViewGroup)>",0,"{
    final int itemViewType = getItemViewType(position);
    switch(itemViewType) {
        case ITEM_VIEW_TYPE_FOOTER:
            if (convertView == null || convertView.getId() != ITEM_VIEW_TYPE_FOOTER) {
                convertView = LayoutInflater.from(getContext()).inflate(R.layout.activity_chooser_view_list_item, parent, false);
                convertView.setId(ITEM_VIEW_TYPE_FOOTER);
                TextView titleView = (TextView) convertView.findViewById(R.id.title);
                titleView.setText(mContext.getString(R.string.activity_chooser_view_see_all));
            }
            return convertView;
        case ITEM_VIEW_TYPE_ACTIVITY:
            if (convertView == null || convertView.getId() != R.id.list_item) {
                convertView = LayoutInflater.from(getContext()).inflate(R.layout.activity_chooser_view_list_item, parent, false);
            }
            PackageManager packageManager = mContext.getPackageManager();
            // Set the icon
            ImageView iconView = (ImageView) convertView.findViewById(R.id.icon);
            ResolveInfo activity = (ResolveInfo) getItem(position);
            iconView.setImageDrawable(activity.loadIcon(packageManager));
            // Set the title.
            TextView titleView = (TextView) convertView.findViewById(R.id.title);
            titleView.setText(activity.loadLabel(packageManager));
            // Highlight the default.
            if (mShowDefaultActivity && position == 0 && mHighlightDefaultActivity) {
                convertView.setActivated(true);
            } else {
                convertView.setActivated(false);
            }
            return convertView;
        default:
            throw new IllegalArgumentException();
    }
}","{
    final int itemViewType = getItemViewType(position);
    switch(itemViewType) {
        case ITEM_VIEW_TYPE_FOOTER:
            if (convertView == null || convertView.getId() != ITEM_VIEW_TYPE_FOOTER) {
                convertView = LayoutInflater.from(getContext()).inflate(R.layout.activity_chooser_view_list_item, parent, false);
                convertView.setId(ITEM_VIEW_TYPE_FOOTER);
                TextView titleView = convertView.findViewById(R.id.title);
                titleView.setText(mContext.getString(R.string.activity_chooser_view_see_all));
            }
            return convertView;
        case ITEM_VIEW_TYPE_ACTIVITY:
            if (convertView == null || convertView.getId() != R.id.list_item) {
                convertView = LayoutInflater.from(getContext()).inflate(R.layout.activity_chooser_view_list_item, parent, false);
            }
            PackageManager packageManager = mContext.getPackageManager();
            // Set the icon
            ImageView iconView = convertView.findViewById(R.id.icon);
            ResolveInfo activity = (ResolveInfo) getItem(position);
            iconView.setImageDrawable(activity.loadIcon(packageManager));
            // Set the title.
            TextView titleView = convertView.findViewById(R.id.title);
            titleView.setText(activity.loadLabel(packageManager));
            // Highlight the default.
            if (mShowDefaultActivity && position == 0 && mHighlightDefaultActivity) {
                convertView.setActivated(true);
            } else {
                convertView.setActivated(false);
            }
            return convertView;
        default:
            throw new IllegalArgumentException();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only code changes are the removal of unnecessary casts to `TextView` and `ImageView`. These changes have been made likely to clean up the code, as these casts are redundant due to the fact that the `findViewById` method in newer Android versions automatically infers the type of the view.","These changes do not affect the execution flow, returned values, or thrown exceptions. Hence, these are behavior-preserving and will not introduce a Compatibility Issue."
719,<android.preference.Preference: boolean callChangeListener(Object)>,25,26,<android.preference.Preference: boolean callChangeListener(Object)>,<android.preference.Preference: boolean callChangeListener(Object)>,0,"{
    return mOnChangeListener == null ? true : mOnChangeListener.onPreferenceChange(this, newValue);
}","{
    return mOnChangeListener == null || mOnChangeListener.onPreferenceChange(this, newValue);
}",1,"/**
 * Call this method after the user changes the preference, but before the
 * internal state is set. This allows the client to ignore the user value.
 *
 * @param newValue The new value of this Preference.
 * @return True if the user value should be set as the preference
 * value (and persisted).
 */
","/**
 * Call this method after the user changes the preference, but before the
 * internal state is set. This allows the client to ignore the user value.
 *
 * @param newValue The new value of this Preference.
 * @return True if the user value should be set as the preference
 * value (and persisted).
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement was modified to change the logical condition. The earlier version used a ternary operator, returning true if `mOnChangeListener` is null, or the result of `mOnChangeListener.onPreferenceChange`. The later version directly uses a short-circuiting logical OR, achieving a similar result but with a different approach. Therefore, the change type is 1.","The change in the return statement logic does not alter the method's behavior because both the early and the late implementations will return true if `mOnChangeListener` is null. It only affects the case when `mOnChangeListener` is not null, where both versions return the result of the `onPreferenceChange` call. Therefore, the behavior is consistently the same in both versions and there's no CI, despite the change in the code. Hence, the CI type is 1."
720,"<android.app.ContextImpl: void sendBroadcast(Intent,String,Bundle)>",25,26,"<android.app.ContextImpl: void sendBroadcast(Intent,String,Bundle)>","<android.app.ContextImpl: void sendBroadcast(Intent,String,Bundle)>",0,"{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, AppOpsManager.OP_NONE, options, false, false, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, AppOpsManager.OP_NONE, options, false, false, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The method used to send the broadcast has changed from `ActivityManagerNative.getDefault().broadcastIntent` to `ActivityManager.getService().broadcastIntent`, so the code change type is 5.","There is no change that impacts the behavior of this API from the standpoint of a caller. The change is internal and does not alter the return type or exception handling of the method, therefore there is no Compatibility Issue."
723,<android.app.job.JobInfo: boolean isRequireCharging()>,25,26,<android.app.job.JobInfo: boolean isRequireCharging()>,<android.app.job.JobInfo: boolean isRequireCharging()>,0,"{
    return requireCharging;
}","{
    return (constraintFlags & CONSTRAINT_FLAG_CHARGING) != 0;
}",1,"/**
 * Whether this job needs the device to be plugged in.
 */
","/**
 * Whether this job needs the device to be plugged in.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The method implementation has changed from directly returning a boolean field to returning a boolean expression evaluation, so the change types are 1 and 4, as there is a data access change and the returned result may potentially be different.","Because there is a change in the return statement, the method might return a different value than before, depending on how the constraintFlags variable is set. Thus, there is a potential Compatibility Issue with different returned values, which is type 1."
724,<android.widget.RemoteViews: RemoteViews clone()>,25,26,<android.widget.RemoteViews: RemoteViews clone()>,<android.widget.RemoteViews: RemoteViews clone()>,0,"{
    Preconditions.checkState(mIsRoot, ""RemoteView has been attached to another RemoteView. "" + ""May only clone the root of a RemoteView hierarchy."");
    Parcel p = Parcel.obtain();
    // Do not parcel the Bitmap cache - doing so creates an expensive copy of all bitmaps.
    // Instead pretend we're not owning the cache while parceling.
    mIsRoot = false;
    writeToParcel(p, 0);
    p.setDataPosition(0);
    mIsRoot = true;
    RemoteViews rv = new RemoteViews(p, mBitmapCache.clone());
    rv.mIsRoot = true;
    p.recycle();
    return rv;
}","{
    synchronized (this) {
        Preconditions.checkState(mIsRoot, ""RemoteView has been attached to another RemoteView. "" + ""May only clone the root of a RemoteView hierarchy."");
        Parcel p = Parcel.obtain();
        // Do not parcel the Bitmap cache - doing so creates an expensive copy of all bitmaps.
        // Instead pretend we're not owning the cache while parceling.
        mIsRoot = false;
        writeToParcel(p, PARCELABLE_ELIDE_DUPLICATES);
        p.setDataPosition(0);
        mIsRoot = true;
        RemoteViews rv = new RemoteViews(p, mBitmapCache.clone(), mApplication, 0);
        rv.mIsRoot = true;
        p.recycle();
        return rv;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"A synchronization block has been added around the method body, and a new constructor has been used for RemoteViews with additional parameters. Additionally, a flag constant (PARCELABLE_ELIDE_DUPLICATES) is used instead of a literal value in writeToParcel(). These changes constitute the control dependency change (3) because of the addition of the synchronization block, and other statement change (4) due to the change in constructor usage and writeToParcel parameter.","Despite the changes in implementation, all these changes do not result in a different return type or value because these are optimizations and internal changes that do not affect the overall behavior from the API consumer's perspective. The synchronization block ensures thread safety but does not alter the method's output, while the new parameters and flag constants change only how the object is constructed internally. Hence, there is no compatibility issue (0)."
725,<android.app.ActivityManager: void killBackgroundProcesses(String)>,25,26,<android.app.ActivityManager: void killBackgroundProcesses(String)>,<android.app.ActivityManager: void killBackgroundProcesses(String)>,0,"{
    try {
        ActivityManagerNative.getDefault().killBackgroundProcesses(packageName, UserHandle.myUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        getService().killBackgroundProcesses(packageName, UserHandle.myUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Have the system immediately kill all background processes associated
 * with the given package.  This is the same as the kernel killing those
 * processes to reclaim memory; the system will take care of restarting
 * these processes in the future as needed.
 *
 * <p>You must hold the permission
 * {@link android.Manifest.permission#KILL_BACKGROUND_PROCESSES} to be able to
 * call this method.
 *
 * @param packageName The name of the package whose processes are to
 * be killed.
 */
","/**
 * Have the system immediately kill all background processes associated
 * with the given package.  This is the same as the kernel killing those
 * processes to reclaim memory; the system will take care of restarting
 * these processes in the future as needed.
 *
 * @param packageName The name of the package whose processes are to
 * be killed.
 */
",-1,,[@RequiresPermission(Manifest.permission.KILL_BACKGROUND_PROCESSES)],-1,-1,-1,-1,-1,-1,5,0,"The method used to kill background processes has changed from ActivityManagerNative.getDefault().killBackgroundProcesses(...) to getService().killBackgroundProcesses(...). This indicates a change in the dependent API, so the code change is type 5.","There is no Compatibility Issue since the method signature has not changed, and no new return or exception handling statements were introduced. The change was related to the internal call to get the service which would not affect the outward behavior of the API as it is still performing the same action with the same input and output. Therefore, the CI type is 0."
726,<android.preference.PreferenceActivity: void onCreate(Bundle)>,25,26,<android.preference.PreferenceActivity: void onCreate(Bundle)>,<android.preference.PreferenceActivity: void onCreate(Bundle)>,0,"{
    super.onCreate(savedInstanceState);
    // Theming for the PreferenceActivity layout and for the Preference Header(s) layout
    TypedArray sa = obtainStyledAttributes(null, com.android.internal.R.styleable.PreferenceActivity, com.android.internal.R.attr.preferenceActivityStyle, 0);
    final int layoutResId = sa.getResourceId(com.android.internal.R.styleable.PreferenceActivity_layout, com.android.internal.R.layout.preference_list_content);
    mPreferenceHeaderItemResId = sa.getResourceId(com.android.internal.R.styleable.PreferenceActivity_headerLayout, com.android.internal.R.layout.preference_header_item);
    mPreferenceHeaderRemoveEmptyIcon = sa.getBoolean(com.android.internal.R.styleable.PreferenceActivity_headerRemoveIconIfEmpty, false);
    sa.recycle();
    setContentView(layoutResId);
    mListFooter = (FrameLayout) findViewById(com.android.internal.R.id.list_footer);
    mPrefsContainer = (ViewGroup) findViewById(com.android.internal.R.id.prefs_frame);
    boolean hidingHeaders = onIsHidingHeaders();
    mSinglePane = hidingHeaders || !onIsMultiPane();
    String initialFragment = getIntent().getStringExtra(EXTRA_SHOW_FRAGMENT);
    Bundle initialArguments = getIntent().getBundleExtra(EXTRA_SHOW_FRAGMENT_ARGUMENTS);
    int initialTitle = getIntent().getIntExtra(EXTRA_SHOW_FRAGMENT_TITLE, 0);
    int initialShortTitle = getIntent().getIntExtra(EXTRA_SHOW_FRAGMENT_SHORT_TITLE, 0);
    if (savedInstanceState != null) {
        // We are restarting from a previous saved state; used that to
        // initialize, instead of starting fresh.
        ArrayList<Header> headers = savedInstanceState.getParcelableArrayList(HEADERS_TAG);
        if (headers != null) {
            mHeaders.addAll(headers);
            int curHeader = savedInstanceState.getInt(CUR_HEADER_TAG, (int) HEADER_ID_UNDEFINED);
            if (curHeader >= 0 && curHeader < mHeaders.size()) {
                setSelectedHeader(mHeaders.get(curHeader));
            }
        }
    } else {
        if (initialFragment != null && mSinglePane) {
            // If we are just showing a fragment, we want to run in
            // new fragment mode, but don't need to compute and show
            // the headers.
            switchToHeader(initialFragment, initialArguments);
            if (initialTitle != 0) {
                CharSequence initialTitleStr = getText(initialTitle);
                CharSequence initialShortTitleStr = initialShortTitle != 0 ? getText(initialShortTitle) : null;
                showBreadCrumbs(initialTitleStr, initialShortTitleStr);
            }
        } else {
            // We need to try to build the headers.
            onBuildHeaders(mHeaders);
            // the currently selected preference fragment.
            if (mHeaders.size() > 0) {
                if (!mSinglePane) {
                    if (initialFragment == null) {
                        Header h = onGetInitialHeader();
                        switchToHeader(h);
                    } else {
                        switchToHeader(initialFragment, initialArguments);
                    }
                }
            }
        }
    }
    // visibility for other configurations.
    if (initialFragment != null && mSinglePane) {
        // Single pane, showing just a prefs fragment.
        findViewById(com.android.internal.R.id.headers).setVisibility(View.GONE);
        mPrefsContainer.setVisibility(View.VISIBLE);
        if (initialTitle != 0) {
            CharSequence initialTitleStr = getText(initialTitle);
            CharSequence initialShortTitleStr = initialShortTitle != 0 ? getText(initialShortTitle) : null;
            showBreadCrumbs(initialTitleStr, initialShortTitleStr);
        }
    } else if (mHeaders.size() > 0) {
        setListAdapter(new HeaderAdapter(this, mHeaders, mPreferenceHeaderItemResId, mPreferenceHeaderRemoveEmptyIcon));
        if (!mSinglePane) {
            // Multi-pane.
            getListView().setChoiceMode(AbsListView.CHOICE_MODE_SINGLE);
            if (mCurHeader != null) {
                setSelectedHeader(mCurHeader);
            }
            mPrefsContainer.setVisibility(View.VISIBLE);
        }
    } else {
        // If there are no headers, we are in the old ""just show a screen
        // of preferences"" mode.
        setContentView(com.android.internal.R.layout.preference_list_content_single);
        mListFooter = (FrameLayout) findViewById(com.android.internal.R.id.list_footer);
        mPrefsContainer = (ViewGroup) findViewById(com.android.internal.R.id.prefs);
        mPreferenceManager = new PreferenceManager(this, FIRST_REQUEST_CODE);
        mPreferenceManager.setOnPreferenceTreeClickListener(this);
    }
    // see if we should show Back/Next buttons
    Intent intent = getIntent();
    if (intent.getBooleanExtra(EXTRA_PREFS_SHOW_BUTTON_BAR, false)) {
        findViewById(com.android.internal.R.id.button_bar).setVisibility(View.VISIBLE);
        Button backButton = (Button) findViewById(com.android.internal.R.id.back_button);
        backButton.setOnClickListener(new OnClickListener() {

            public void onClick(View v) {
                setResult(RESULT_CANCELED);
                finish();
            }
        });
        Button skipButton = (Button) findViewById(com.android.internal.R.id.skip_button);
        skipButton.setOnClickListener(new OnClickListener() {

            public void onClick(View v) {
                setResult(RESULT_OK);
                finish();
            }
        });
        mNextButton = (Button) findViewById(com.android.internal.R.id.next_button);
        mNextButton.setOnClickListener(new OnClickListener() {

            public void onClick(View v) {
                setResult(RESULT_OK);
                finish();
            }
        });
        // set our various button parameters
        if (intent.hasExtra(EXTRA_PREFS_SET_NEXT_TEXT)) {
            String buttonText = intent.getStringExtra(EXTRA_PREFS_SET_NEXT_TEXT);
            if (TextUtils.isEmpty(buttonText)) {
                mNextButton.setVisibility(View.GONE);
            } else {
                mNextButton.setText(buttonText);
            }
        }
        if (intent.hasExtra(EXTRA_PREFS_SET_BACK_TEXT)) {
            String buttonText = intent.getStringExtra(EXTRA_PREFS_SET_BACK_TEXT);
            if (TextUtils.isEmpty(buttonText)) {
                backButton.setVisibility(View.GONE);
            } else {
                backButton.setText(buttonText);
            }
        }
        if (intent.getBooleanExtra(EXTRA_PREFS_SHOW_SKIP, false)) {
            skipButton.setVisibility(View.VISIBLE);
        }
    }
}","{
    super.onCreate(savedInstanceState);
    // Theming for the PreferenceActivity layout and for the Preference Header(s) layout
    TypedArray sa = obtainStyledAttributes(null, com.android.internal.R.styleable.PreferenceActivity, com.android.internal.R.attr.preferenceActivityStyle, 0);
    final int layoutResId = sa.getResourceId(com.android.internal.R.styleable.PreferenceActivity_layout, com.android.internal.R.layout.preference_list_content);
    mPreferenceHeaderItemResId = sa.getResourceId(com.android.internal.R.styleable.PreferenceActivity_headerLayout, com.android.internal.R.layout.preference_header_item);
    mPreferenceHeaderRemoveEmptyIcon = sa.getBoolean(com.android.internal.R.styleable.PreferenceActivity_headerRemoveIconIfEmpty, false);
    sa.recycle();
    setContentView(layoutResId);
    mListFooter = (FrameLayout) findViewById(com.android.internal.R.id.list_footer);
    mPrefsContainer = (ViewGroup) findViewById(com.android.internal.R.id.prefs_frame);
    mHeadersContainer = (ViewGroup) findViewById(com.android.internal.R.id.headers);
    boolean hidingHeaders = onIsHidingHeaders();
    mSinglePane = hidingHeaders || !onIsMultiPane();
    String initialFragment = getIntent().getStringExtra(EXTRA_SHOW_FRAGMENT);
    Bundle initialArguments = getIntent().getBundleExtra(EXTRA_SHOW_FRAGMENT_ARGUMENTS);
    int initialTitle = getIntent().getIntExtra(EXTRA_SHOW_FRAGMENT_TITLE, 0);
    int initialShortTitle = getIntent().getIntExtra(EXTRA_SHOW_FRAGMENT_SHORT_TITLE, 0);
    mActivityTitle = getTitle();
    if (savedInstanceState != null) {
        // We are restarting from a previous saved state; used that to
        // initialize, instead of starting fresh.
        ArrayList<Header> headers = savedInstanceState.getParcelableArrayList(HEADERS_TAG);
        if (headers != null) {
            mHeaders.addAll(headers);
            int curHeader = savedInstanceState.getInt(CUR_HEADER_TAG, (int) HEADER_ID_UNDEFINED);
            if (curHeader >= 0 && curHeader < mHeaders.size()) {
                setSelectedHeader(mHeaders.get(curHeader));
            } else if (!mSinglePane && initialFragment == null) {
                switchToHeader(onGetInitialHeader());
            }
        } else {
            // This will for instance hide breadcrumbs for single pane.
            showBreadCrumbs(getTitle(), null);
        }
    } else {
        if (!onIsHidingHeaders()) {
            onBuildHeaders(mHeaders);
        }
        if (initialFragment != null) {
            switchToHeader(initialFragment, initialArguments);
        } else if (!mSinglePane && mHeaders.size() > 0) {
            switchToHeader(onGetInitialHeader());
        }
    }
    if (mHeaders.size() > 0) {
        setListAdapter(new HeaderAdapter(this, mHeaders, mPreferenceHeaderItemResId, mPreferenceHeaderRemoveEmptyIcon));
        if (!mSinglePane) {
            getListView().setChoiceMode(AbsListView.CHOICE_MODE_SINGLE);
        }
    }
    if (mSinglePane && initialFragment != null && initialTitle != 0) {
        CharSequence initialTitleStr = getText(initialTitle);
        CharSequence initialShortTitleStr = initialShortTitle != 0 ? getText(initialShortTitle) : null;
        showBreadCrumbs(initialTitleStr, initialShortTitleStr);
    }
    if (mHeaders.size() == 0 && initialFragment == null) {
        // If there are no headers, we are in the old ""just show a screen
        // of preferences"" mode.
        setContentView(com.android.internal.R.layout.preference_list_content_single);
        mListFooter = (FrameLayout) findViewById(com.android.internal.R.id.list_footer);
        mPrefsContainer = (ViewGroup) findViewById(com.android.internal.R.id.prefs);
        mPreferenceManager = new PreferenceManager(this, FIRST_REQUEST_CODE);
        mPreferenceManager.setOnPreferenceTreeClickListener(this);
        mHeadersContainer = null;
    } else if (mSinglePane) {
        // Single-pane so one of the header or prefs containers must be hidden.
        if (initialFragment != null || mCurHeader != null) {
            mHeadersContainer.setVisibility(View.GONE);
        } else {
            mPrefsContainer.setVisibility(View.GONE);
        }
        // This animates our manual transitions between headers and prefs panel in single-pane.
        // It also comes last so we don't animate any initial layout changes done above.
        ViewGroup container = (ViewGroup) findViewById(com.android.internal.R.id.prefs_container);
        container.setLayoutTransition(new LayoutTransition());
    } else {
        // Multi-pane
        if (mHeaders.size() > 0 && mCurHeader != null) {
            setSelectedHeader(mCurHeader);
        }
    }
    // see if we should show Back/Next buttons
    Intent intent = getIntent();
    if (intent.getBooleanExtra(EXTRA_PREFS_SHOW_BUTTON_BAR, false)) {
        findViewById(com.android.internal.R.id.button_bar).setVisibility(View.VISIBLE);
        Button backButton = (Button) findViewById(com.android.internal.R.id.back_button);
        backButton.setOnClickListener(new OnClickListener() {

            public void onClick(View v) {
                setResult(RESULT_CANCELED);
                finish();
            }
        });
        Button skipButton = (Button) findViewById(com.android.internal.R.id.skip_button);
        skipButton.setOnClickListener(new OnClickListener() {

            public void onClick(View v) {
                setResult(RESULT_OK);
                finish();
            }
        });
        mNextButton = (Button) findViewById(com.android.internal.R.id.next_button);
        mNextButton.setOnClickListener(new OnClickListener() {

            public void onClick(View v) {
                setResult(RESULT_OK);
                finish();
            }
        });
        // set our various button parameters
        if (intent.hasExtra(EXTRA_PREFS_SET_NEXT_TEXT)) {
            String buttonText = intent.getStringExtra(EXTRA_PREFS_SET_NEXT_TEXT);
            if (TextUtils.isEmpty(buttonText)) {
                mNextButton.setVisibility(View.GONE);
            } else {
                mNextButton.setText(buttonText);
            }
        }
        if (intent.hasExtra(EXTRA_PREFS_SET_BACK_TEXT)) {
            String buttonText = intent.getStringExtra(EXTRA_PREFS_SET_BACK_TEXT);
            if (TextUtils.isEmpty(buttonText)) {
                backButton.setVisibility(View.GONE);
            } else {
                backButton.setText(buttonText);
            }
        }
        if (intent.getBooleanExtra(EXTRA_PREFS_SHOW_SKIP, false)) {
            skipButton.setVisibility(View.VISIBLE);
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
727,"<android.content.ContentResolver: Object addStatusChangeListener(int,SyncStatusObserver)>",25,26,"<android.content.ContentResolver: Object addStatusChangeListener(int,SyncStatusObserver)>","<android.content.ContentResolver: Object addStatusChangeListener(int,SyncStatusObserver)>",0,"{
    if (callback == null) {
        throw new IllegalArgumentException(""you passed in a null callback"");
    }
    try {
        ISyncStatusObserver.Stub observer = new ISyncStatusObserver.Stub() {

            public void onStatusChanged(int which) throws RemoteException {
                callback.onStatusChanged(which);
            }
        };
        getContentService().addStatusChangeListener(mask, observer);
        return observer;
    } catch (RemoteException e) {
        throw new RuntimeException(""the ContentService should always be reachable"", e);
    }
}","{
    if (callback == null) {
        throw new IllegalArgumentException(""you passed in a null callback"");
    }
    try {
        ISyncStatusObserver.Stub observer = new ISyncStatusObserver.Stub() {

            @Override
            public void onStatusChanged(int which) throws RemoteException {
                callback.onStatusChanged(which);
            }
        };
        getContentService().addStatusChangeListener(mask, observer);
        return observer;
    } catch (RemoteException e) {
        throw new RuntimeException(""the ContentService should always be reachable"", e);
    }
}",1,"/**
 * Request notifications when the different aspects of the SyncManager change. The
 * different items that can be requested are:
 * <ul>
 * <li> {@link #SYNC_OBSERVER_TYPE_PENDING}
 * <li> {@link #SYNC_OBSERVER_TYPE_ACTIVE}
 * <li> {@link #SYNC_OBSERVER_TYPE_SETTINGS}
 * </ul>
 * The caller can set one or more of the status types in the mask for any
 * given listener registration.
 * @param mask the status change types that will cause the callback to be invoked
 * @param callback observer to be invoked when the status changes
 * @return a handle that can be used to remove the listener at a later time
 */
","/**
 * Request notifications when the different aspects of the SyncManager change. The
 * different items that can be requested are:
 * <ul>
 * <li> {@link #SYNC_OBSERVER_TYPE_PENDING}
 * <li> {@link #SYNC_OBSERVER_TYPE_ACTIVE}
 * <li> {@link #SYNC_OBSERVER_TYPE_SETTINGS}
 * </ul>
 * The caller can set one or more of the status types in the mask for any
 * given listener registration.
 * @param mask the status change types that will cause the callback to be invoked
 * @param callback observer to be invoked when the status changes
 * @return a handle that can be used to remove the listener at a later time
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"There is no actual code change between the early and late versions; the only difference is the presence of the `@Override` annotation, which does not affect the method's behavior.",No Compatibility Issue arises because there is no change in the behavior of the API between the two versions.
728,<android.app.Notification.Builder: int resolveContrastColor()>,25,26,<android.app.Notification.Builder: int resolveContrastColor()>,<android.app.Notification.Builder: int resolveContrastColor()>,0,"{
    if (mCachedContrastColorIsFor == mN.color && mCachedContrastColor != COLOR_INVALID) {
        return mCachedContrastColor;
    }
    final int contrasted = NotificationColorUtil.resolveContrastColor(mContext, mN.color);
    mCachedContrastColorIsFor = mN.color;
    return mCachedContrastColor = contrasted;
}","{
    if (mCachedContrastColorIsFor == mN.color && mCachedContrastColor != COLOR_INVALID) {
        return mCachedContrastColor;
    }
    int color;
    int background = mBackgroundColorHint;
    if (mBackgroundColorHint == COLOR_INVALID) {
        background = mContext.getColor(com.android.internal.R.color.notification_material_background_color);
    }
    if (mN.color == COLOR_DEFAULT) {
        ensureColors();
        color = mSecondaryTextColor;
    } else {
        color = NotificationColorUtil.resolveContrastColor(mContext, mN.color, background);
    }
    if (Color.alpha(color) < 255) {
        // alpha doesn't go well for color filters, so let's blend it manually
        color = NotificationColorUtil.compositeColors(color, background);
    }
    mCachedContrastColorIsFor = mN.color;
    return mCachedContrastColor = color;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The late version introduces new variables and statements to handle more conditions for contrast color resolution, adding new control dependencies (background checks and branching based on mN.color value), altering the value assignment to color, and the final computation of the mCachedContrastColor. Hence, the code change type includes 1 (return statement changed), 3 (control dependency change), and 4 (other statement changed).","Due to the extra conditions and new computation steps introduced in the late version implementation, the behavior of the API can change, potentially returning different values compared to the early version. This constitutes a Compatibility Issue of type 1 caused by potential different return values."
730,"<android.content.pm.PackageManager: PackageInfo getPackageArchiveInfo(String,int)>",25,26,"<android.content.pm.PackageManager: PackageInfo getPackageArchiveInfo(String,int)>","<android.content.pm.PackageManager: PackageInfo getPackageArchiveInfo(String,int)>",0,"{
    final PackageParser parser = new PackageParser();
    final File apkFile = new File(archiveFilePath);
    try {
        if ((flags & (MATCH_DIRECT_BOOT_UNAWARE | MATCH_DIRECT_BOOT_AWARE)) != 0) {
        // Caller expressed an explicit opinion about what encryption
        // aware/unaware components they want to see, so fall through and
        // give them what they want
        } else {
            // Caller expressed no opinion, so match everything
            flags |= MATCH_DIRECT_BOOT_AWARE | MATCH_DIRECT_BOOT_UNAWARE;
        }
        PackageParser.Package pkg = parser.parseMonolithicPackage(apkFile, 0);
        if ((flags & GET_SIGNATURES) != 0) {
            PackageParser.collectCertificates(pkg, 0);
        }
        PackageUserState state = new PackageUserState();
        return PackageParser.generatePackageInfo(pkg, null, flags, 0, 0, null, state);
    } catch (PackageParserException e) {
        return null;
    }
}","{
    final PackageParser parser = new PackageParser();
    parser.setCallback(new PackageParser.CallbackImpl(this));
    final File apkFile = new File(archiveFilePath);
    try {
        if ((flags & (MATCH_DIRECT_BOOT_UNAWARE | MATCH_DIRECT_BOOT_AWARE)) != 0) {
        // Caller expressed an explicit opinion about what encryption
        // aware/unaware components they want to see, so fall through and
        // give them what they want
        } else {
            // Caller expressed no opinion, so match everything
            flags |= MATCH_DIRECT_BOOT_AWARE | MATCH_DIRECT_BOOT_UNAWARE;
        }
        PackageParser.Package pkg = parser.parseMonolithicPackage(apkFile, 0);
        if ((flags & GET_SIGNATURES) != 0) {
            PackageParser.collectCertificates(pkg, 0);
        }
        PackageUserState state = new PackageUserState();
        return PackageParser.generatePackageInfo(pkg, null, flags, 0, 0, null, state);
    } catch (PackageParserException e) {
        return null;
    }
}",1,"/**
 * Retrieve overall information about an application package defined
 * in a package archive file
 *
 * @param archiveFilePath The path to the archive file
 * @param flags Additional option flags. Use any combination of
 * {@link #GET_ACTIVITIES}, {@link #GET_CONFIGURATIONS},
 * {@link #GET_GIDS}, {@link #GET_INSTRUMENTATION},
 * {@link #GET_INTENT_FILTERS}, {@link #GET_META_DATA},
 * {@link #GET_PERMISSIONS}, {@link #GET_PROVIDERS},
 * {@link #GET_RECEIVERS}, {@link #GET_SERVICES},
 * {@link #GET_SHARED_LIBRARY_FILES}, {@link #GET_SIGNATURES},
 * {@link #GET_URI_PERMISSION_PATTERNS}, {@link #GET_UNINSTALLED_PACKAGES},
 * {@link #MATCH_DISABLED_COMPONENTS}, {@link #MATCH_DISABLED_UNTIL_USED_COMPONENTS},
 * {@link #MATCH_UNINSTALLED_PACKAGES}
 * to modify the data returned.
 *
 * @return A PackageInfo object containing information about the
 * package archive. If the package could not be parsed,
 * returns null.
 *
 * @see #GET_ACTIVITIES
 * @see #GET_CONFIGURATIONS
 * @see #GET_GIDS
 * @see #GET_INSTRUMENTATION
 * @see #GET_INTENT_FILTERS
 * @see #GET_META_DATA
 * @see #GET_PERMISSIONS
 * @see #GET_PROVIDERS
 * @see #GET_RECEIVERS
 * @see #GET_SERVICES
 * @see #GET_SHARED_LIBRARY_FILES
 * @see #GET_SIGNATURES
 * @see #GET_URI_PERMISSION_PATTERNS
 * @see #MATCH_DISABLED_COMPONENTS
 * @see #MATCH_DISABLED_UNTIL_USED_COMPONENTS
 * @see #MATCH_UNINSTALLED_PACKAGES
 */
","/**
 * Retrieve overall information about an application package defined in a
 * package archive file
 *
 * @param archiveFilePath The path to the archive file
 * @param flags Additional option flags to modify the data returned.
 * @return A PackageInfo object containing information about the package
 * archive. If the package could not be parsed, returns null.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The statement ""parser.setCallback(new PackageParser.CallbackImpl(this));"" has been added to the late implementation, and no other changes are observed. Therefore, the code change type is 4.","The added statement sets a callback but doesn't change the control flow or modify the method's return value or the exceptions it may throw. Since these are the circumstances under which a Compatibility Issue would be considered, and none are present, there is no Compatibility Issue. Hence, the CI type is 0."
731,"<android.app.admin.DevicePolicyManager: void setApplicationRestrictions(ComponentName,String,Bundle)>",25,26,"<android.app.admin.DevicePolicyManager: void setApplicationRestrictions(ComponentName,String,Bundle)>","<android.app.admin.DevicePolicyManager: void setApplicationRestrictions(ComponentName,String,Bundle)>",0,"{
    throwIfParentInstance(""setApplicationRestrictions"");
    if (mService != null) {
        try {
            mService.setApplicationRestrictions(admin, packageName, settings);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}","{
    throwIfParentInstance(""setApplicationRestrictions"");
    if (mService != null) {
        try {
            mService.setApplicationRestrictions(admin, mContext.getPackageName(), packageName, settings);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Sets the application restrictions for a given target application running in the calling user.
 * <p>
 * The caller must be a profile or device owner on that user, or the package allowed to manage
 * application restrictions via {@link #setApplicationRestrictionsManagingPackage}; otherwise a
 * security exception will be thrown.
 * <p>
 * The provided {@link Bundle} consists of key-value pairs, where the types of values may be:
 * <ul>
 * <li>{@code boolean}
 * <li>{@code int}
 * <li>{@code String} or {@code String[]}
 * <li>From {@link android.os.Build.VERSION_CODES#M}, {@code Bundle} or {@code Bundle[]}
 * </ul>
 * <p>
 * If the restrictions are not available yet, but may be applied in the near future, the caller
 * can notify the target application of that by adding
 * {@link UserManager#KEY_RESTRICTIONS_PENDING} to the settings parameter.
 * <p>
 * The application restrictions are only made visible to the target application via
 * {@link UserManager#getApplicationRestrictions(String)}, in addition to the profile or device
 * owner, and the application restrictions managing package via
 * {@link #getApplicationRestrictions}.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or
 * {@code null} if called by the application restrictions managing package.
 * @param packageName The name of the package to update restricted settings for.
 * @param settings A {@link Bundle} to be parsed by the receiving application, conveying a new
 * set of active restrictions.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 * @see #setApplicationRestrictionsManagingPackage
 * @see UserManager#KEY_RESTRICTIONS_PENDING
 */
","/**
 * Sets the application restrictions for a given target application running in the calling user.
 * <p>
 * The caller must be a profile or device owner on that user, or the package allowed to manage
 * application restrictions via {@link #setDelegatedScopes} with the
 * {@link #DELEGATION_APP_RESTRICTIONS} scope; otherwise a security exception will be thrown.
 * <p>
 * The provided {@link Bundle} consists of key-value pairs, where the types of values may be:
 * <ul>
 * <li>{@code boolean}
 * <li>{@code int}
 * <li>{@code String} or {@code String[]}
 * <li>From {@link android.os.Build.VERSION_CODES#M}, {@code Bundle} or {@code Bundle[]}
 * </ul>
 * <p>
 * If the restrictions are not available yet, but may be applied in the near future, the caller
 * can notify the target application of that by adding
 * {@link UserManager#KEY_RESTRICTIONS_PENDING} to the settings parameter.
 * <p>
 * The application restrictions are only made visible to the target application via
 * {@link UserManager#getApplicationRestrictions(String)}, in addition to the profile or device
 * owner, and the application restrictions managing package via
 * {@link #getApplicationRestrictions}.
 *
 * <p>NOTE: The method performs disk I/O and shouldn't be called on the main thread
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or
 * {@code null} if called by the application restrictions managing package.
 * @param packageName The name of the package to update restricted settings for.
 * @param settings A {@link Bundle} to be parsed by the receiving application, conveying a new
 * set of active restrictions.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 * @see #setDelegatedScopes
 * @see #DELEGATION_APP_RESTRICTIONS
 * @see UserManager#KEY_RESTRICTIONS_PENDING
 */
",-1,,[@WorkerThread],-1,-1,-1,-1,-1,-1,5,0,"There is a change in a method call within the try block, a modification that includes an additional argument being passed to `mService.setApplicationRestrictions`. The change is in the dependent API with an altered number of parameters, so the change type is 5.","There is no Compatibility Issue introduced by this change since the new argument `mContext.getPackageName()` does not affect the return type or the exceptions thrown by the method, and the API itself does not return any value (void method). Thus, the method's behavior from the caller's perspective remains the same."
732,"<android.app.admin.DevicePolicyManager: boolean installKeyPair(ComponentName,PrivateKey,Certificate[],String,boolean)>",25,26,"<android.app.admin.DevicePolicyManager: boolean installKeyPair(ComponentName,PrivateKey,Certificate[],String,boolean)>","<android.app.admin.DevicePolicyManager: boolean installKeyPair(ComponentName,PrivateKey,Certificate[],String,boolean)>",0,"{
    throwIfParentInstance(""installKeyPair"");
    try {
        final byte[] pemCert = Credentials.convertToPem(certs[0]);
        byte[] pemChain = null;
        if (certs.length > 1) {
            pemChain = Credentials.convertToPem(Arrays.copyOfRange(certs, 1, certs.length));
        }
        final byte[] pkcs8Key = KeyFactory.getInstance(privKey.getAlgorithm()).getKeySpec(privKey, PKCS8EncodedKeySpec.class).getEncoded();
        return mService.installKeyPair(admin, pkcs8Key, pemCert, pemChain, alias, requestAccess);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    } catch (NoSuchAlgorithmException | InvalidKeySpecException e) {
        Log.w(TAG, ""Failed to obtain private key material"", e);
    } catch (CertificateException | IOException e) {
        Log.w(TAG, ""Could not pem-encode certificate"", e);
    }
    return false;
}","{
    throwIfParentInstance(""installKeyPair"");
    try {
        final byte[] pemCert = Credentials.convertToPem(certs[0]);
        byte[] pemChain = null;
        if (certs.length > 1) {
            pemChain = Credentials.convertToPem(Arrays.copyOfRange(certs, 1, certs.length));
        }
        final byte[] pkcs8Key = KeyFactory.getInstance(privKey.getAlgorithm()).getKeySpec(privKey, PKCS8EncodedKeySpec.class).getEncoded();
        return mService.installKeyPair(admin, mContext.getPackageName(), pkcs8Key, pemCert, pemChain, alias, requestAccess);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    } catch (NoSuchAlgorithmException | InvalidKeySpecException e) {
        Log.w(TAG, ""Failed to obtain private key material"", e);
    } catch (CertificateException | IOException e) {
        Log.w(TAG, ""Could not pem-encode certificate"", e);
    }
    return false;
}",1,"/**
 * Called by a device or profile owner, or delegated certificate installer, to install a
 * certificate chain and corresponding private key for the leaf certificate. All apps within the
 * profile will be able to access the certificate chain and use the private key, given direct
 * user approval.
 *
 * <p>The caller of this API may grant itself access to the certificate and private key
 * immediately, without user approval. It is a best practice not to request this unless strictly
 * necessary since it opens up additional security vulnerabilities.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or
 * {@code null} if calling from a delegated certificate installer.
 * @param privKey The private key to install.
 * @param certs The certificate chain to install. The chain should start with the leaf
 * certificate and include the chain of trust in order. This will be returned by
 * {@link android.security.KeyChain#getCertificateChain}.
 * @param alias The private key alias under which to install the certificate. If a certificate
 * with that alias already exists, it will be overwritten.
 * @param requestAccess {@code true} to request that the calling app be granted access to the
 * credentials immediately. Otherwise, access to the credentials will be gated by user
 * approval.
 * @return {@code true} if the keys were installed, {@code false} otherwise.
 * @throws SecurityException if {@code admin} is not {@code null} and not a device or profile
 * owner.
 * @see android.security.KeyChain#getCertificateChain
 */
","/**
 * Called by a device or profile owner, or delegated certificate installer, to install a
 * certificate chain and corresponding private key for the leaf certificate. All apps within the
 * profile will be able to access the certificate chain and use the private key, given direct
 * user approval.
 *
 * <p>The caller of this API may grant itself access to the certificate and private key
 * immediately, without user approval. It is a best practice not to request this unless strictly
 * necessary since it opens up additional security vulnerabilities.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or
 * {@code null} if calling from a delegated certificate installer.
 * @param privKey The private key to install.
 * @param certs The certificate chain to install. The chain should start with the leaf
 * certificate and include the chain of trust in order. This will be returned by
 * {@link android.security.KeyChain#getCertificateChain}.
 * @param alias The private key alias under which to install the certificate. If a certificate
 * with that alias already exists, it will be overwritten.
 * @param requestAccess {@code true} to request that the calling app be granted access to the
 * credentials immediately. Otherwise, access to the credentials will be gated by user
 * approval.
 * @return {@code true} if the keys were installed, {@code false} otherwise.
 * @throws SecurityException if {@code admin} is not {@code null} and not a device or profile
 * owner.
 * @see android.security.KeyChain#getCertificateChain
 * @see #setDelegatedScopes
 * @see #DELEGATION_CERT_INSTALL
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The change here involves the addition of `mContext.getPackageName()` as a parameter to the `mService.installKeyPair` method call. This is an internal change that does not directly affect the control flow or return value of the installKeyPair API method, as long as 'packageName' is a correct and acceptable parameter. As such, it constitutes an ""Other statement changed"" (4) and a change in the ""Dependent API changed"" (5).","Since the addition of `mContext.getPackageName()` as a parameter to the `mService.installKeyPair` method does not alter the return type of the method nor the overall execution flow (assuming the package name is valid and the behavior of `installKeyPair` remains consistent for any package name), it is reasonable to consider that no Compatibility Issue should arise solely due to this parameter change. Hence, CI is 0."
734,"<android.app.Activity: boolean onKeyDown(int,KeyEvent)>",25,26,"<android.app.Activity: boolean onKeyDown(int,KeyEvent)>","<android.app.Activity: boolean onKeyDown(int,KeyEvent)>",0,"{
    if (keyCode == KeyEvent.KEYCODE_BACK) {
        if (getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.ECLAIR) {
            event.startTracking();
        } else {
            onBackPressed();
        }
        return true;
    }
    if (mDefaultKeyMode == DEFAULT_KEYS_DISABLE) {
        return false;
    } else if (mDefaultKeyMode == DEFAULT_KEYS_SHORTCUT) {
        Window w = getWindow();
        if (w.hasFeature(Window.FEATURE_OPTIONS_PANEL) && w.performPanelShortcut(Window.FEATURE_OPTIONS_PANEL, keyCode, event, Menu.FLAG_ALWAYS_PERFORM_CLOSE)) {
            return true;
        }
        return false;
    } else {
        // Common code for DEFAULT_KEYS_DIALER & DEFAULT_KEYS_SEARCH_*
        boolean clearSpannable = false;
        boolean handled;
        if ((event.getRepeatCount() != 0) || event.isSystem()) {
            clearSpannable = true;
            handled = false;
        } else {
            handled = TextKeyListener.getInstance().onKeyDown(null, mDefaultKeySsb, keyCode, event);
            if (handled && mDefaultKeySsb.length() > 0) {
                // something useable has been typed - dispatch it now.
                final String str = mDefaultKeySsb.toString();
                clearSpannable = true;
                switch(mDefaultKeyMode) {
                    case DEFAULT_KEYS_DIALER:
                        Intent intent = new Intent(Intent.ACTION_DIAL, Uri.parse(""tel:"" + str));
                        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                        startActivity(intent);
                        break;
                    case DEFAULT_KEYS_SEARCH_LOCAL:
                        startSearch(str, false, null, false);
                        break;
                    case DEFAULT_KEYS_SEARCH_GLOBAL:
                        startSearch(str, false, null, true);
                        break;
                }
            }
        }
        if (clearSpannable) {
            mDefaultKeySsb.clear();
            mDefaultKeySsb.clearSpans();
            Selection.setSelection(mDefaultKeySsb, 0);
        }
        return handled;
    }
}","{
    if (keyCode == KeyEvent.KEYCODE_BACK) {
        if (getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.ECLAIR) {
            event.startTracking();
        } else {
            onBackPressed();
        }
        return true;
    }
    if (mDefaultKeyMode == DEFAULT_KEYS_DISABLE) {
        return false;
    } else if (mDefaultKeyMode == DEFAULT_KEYS_SHORTCUT) {
        Window w = getWindow();
        if (w.hasFeature(Window.FEATURE_OPTIONS_PANEL) && w.performPanelShortcut(Window.FEATURE_OPTIONS_PANEL, keyCode, event, Menu.FLAG_ALWAYS_PERFORM_CLOSE)) {
            return true;
        }
        return false;
    } else if (keyCode == KeyEvent.KEYCODE_TAB) {
        // aren't considered ""typing keys"" so they already won't get consumed.
        return false;
    } else {
        // Common code for DEFAULT_KEYS_DIALER & DEFAULT_KEYS_SEARCH_*
        boolean clearSpannable = false;
        boolean handled;
        if ((event.getRepeatCount() != 0) || event.isSystem()) {
            clearSpannable = true;
            handled = false;
        } else {
            handled = TextKeyListener.getInstance().onKeyDown(null, mDefaultKeySsb, keyCode, event);
            if (handled && mDefaultKeySsb.length() > 0) {
                // something useable has been typed - dispatch it now.
                final String str = mDefaultKeySsb.toString();
                clearSpannable = true;
                switch(mDefaultKeyMode) {
                    case DEFAULT_KEYS_DIALER:
                        Intent intent = new Intent(Intent.ACTION_DIAL, Uri.parse(""tel:"" + str));
                        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                        startActivity(intent);
                        break;
                    case DEFAULT_KEYS_SEARCH_LOCAL:
                        startSearch(str, false, null, false);
                        break;
                    case DEFAULT_KEYS_SEARCH_GLOBAL:
                        startSearch(str, false, null, true);
                        break;
                }
            }
        }
        if (clearSpannable) {
            mDefaultKeySsb.clear();
            mDefaultKeySsb.clearSpans();
            Selection.setSelection(mDefaultKeySsb, 0);
        }
        return handled;
    }
}",1,"/**
 * Called when a key was pressed down and not handled by any of the views
 * inside of the activity. So, for example, key presses while the cursor
 * is inside a TextView will not trigger the event (unless it is a navigation
 * to another object) because TextView handles its own key presses.
 *
 * <p>If the focused view didn't want this event, this method is called.
 *
 * <p>The default implementation takes care of {@link KeyEvent#KEYCODE_BACK}
 * by calling {@link #onBackPressed()}, though the behavior varies based
 * on the application compatibility mode: for
 * {@link android.os.Build.VERSION_CODES#ECLAIR} or later applications,
 * it will set up the dispatch to call {@link #onKeyUp} where the action
 * will be performed; for earlier applications, it will perform the
 * action immediately in on-down, as those versions of the platform
 * behaved.
 *
 * <p>Other additional default key handling may be performed
 * if configured with {@link #setDefaultKeyMode}.
 *
 * @return Return <code>true</code> to prevent this event from being propagated
 * further, or <code>false</code> to indicate that you have not handled
 * this event and it should continue to be propagated.
 * @see #onKeyUp
 * @see android.view.KeyEvent
 */
","/**
 * Called when a key was pressed down and not handled by any of the views
 * inside of the activity. So, for example, key presses while the cursor
 * is inside a TextView will not trigger the event (unless it is a navigation
 * to another object) because TextView handles its own key presses.
 *
 * <p>If the focused view didn't want this event, this method is called.
 *
 * <p>The default implementation takes care of {@link KeyEvent#KEYCODE_BACK}
 * by calling {@link #onBackPressed()}, though the behavior varies based
 * on the application compatibility mode: for
 * {@link android.os.Build.VERSION_CODES#ECLAIR} or later applications,
 * it will set up the dispatch to call {@link #onKeyUp} where the action
 * will be performed; for earlier applications, it will perform the
 * action immediately in on-down, as those versions of the platform
 * behaved.
 *
 * <p>Other additional default key handling may be performed
 * if configured with {@link #setDefaultKeyMode}.
 *
 * @return Return <code>true</code> to prevent this event from being propagated
 * further, or <code>false</code> to indicate that you have not handled
 * this event and it should continue to be propagated.
 * @see #onKeyUp
 * @see android.view.KeyEvent
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"An additional control dependency and an additional control statement ('else if (keyCode == KeyEvent.KEYCODE_TAB)') have been introduced, along with a 'return false;' statement under this new condition, so the change types are 3 for the control dependency change and 4 for the other statement change (the addition of 'return false;' within the new condition).","The introduction of the new condition check for KeyEvent.KEYCODE_TAB, which returns false could potentially lead to a different return value when the keyCode parameter is KeyEvent.KEYCODE_TAB. Thus, the potential Compatibility Issue type is 1."
735,<android.app.Activity: boolean showAssist(Bundle)>,25,26,<android.app.Activity: boolean showAssist(Bundle)>,<android.app.Activity: boolean showAssist(Bundle)>,0,"{
    try {
        return ActivityManagerNative.getDefault().showAssistFromActivity(mToken, args);
    } catch (RemoteException e) {
    }
    return false;
}","{
    try {
        return ActivityManager.getService().showAssistFromActivity(mToken, args);
    } catch (RemoteException e) {
    }
    return false;
}",1,"/**
 * Ask to have the current assistant shown to the user.  This only works if the calling
 * activity is the current foreground activity.  It is the same as calling
 * {@link android.service.voice.VoiceInteractionService#showSession
 * VoiceInteractionService.showSession} and requesting all of the possible context.
 * The receiver will always see
 * {@link android.service.voice.VoiceInteractionSession#SHOW_SOURCE_APPLICATION} set.
 * @return Returns true if the assistant was successfully invoked, else false.  For example
 * false will be returned if the caller is not the current top activity.
 */
","/**
 * Ask to have the current assistant shown to the user.  This only works if the calling
 * activity is the current foreground activity.  It is the same as calling
 * {@link android.service.voice.VoiceInteractionService#showSession
 * VoiceInteractionService.showSession} and requesting all of the possible context.
 * The receiver will always see
 * {@link android.service.voice.VoiceInteractionSession#SHOW_SOURCE_APPLICATION} set.
 * @return Returns true if the assistant was successfully invoked, else false.  For example
 * false will be returned if the caller is not the current top activity.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation changes from `ActivityManagerNative.getDefault()` to `ActivityManager.getService()`. This is a change in the dependent API the method relies on, so the change type is 5.","The dependent API change does not necessarily lead to a compatibility issue, as the behavior of the method showAssistFromActivity() called on the ActivityManager service object is expected to be consistent with the behavior of the method called on the ActivityManagerNative object. Both calls are handling the RemoteException similarly and return the same type of result. Therefore, there is no CI caused by the change."
736,<android.accessibilityservice.AccessibilityServiceInfo: int hashCode()>,25,26,<android.accessibilityservice.AccessibilityServiceInfo: int hashCode()>,<android.accessibilityservice.AccessibilityServiceInfo: int hashCode()>,0,"{
    return 31 * 1 + ((mId == null) ? 0 : mId.hashCode());
}","{
    return 31 * 1 + ((mComponentName == null) ? 0 : mComponentName.hashCode());
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The hashCode implementation has been updated to use a different member variable (from mId to mComponentName) for computing the hash code, so the change type is 1,5.","Since the method now computes the hash code based on a different member variable, the returned hash code values between the two versions can be different, which constitutes a compatibility issue of type 1 as it affects the return values."
737,<android.content.res.Configuration: int diff(Configuration)>,25,26,<android.content.res.Configuration: int diff(Configuration)>,<android.content.res.Configuration: int diff(Configuration)>,0,"{
    int changed = 0;
    if (delta.fontScale > 0 && fontScale != delta.fontScale) {
        changed |= ActivityInfo.CONFIG_FONT_SCALE;
    }
    if (delta.mcc != 0 && mcc != delta.mcc) {
        changed |= ActivityInfo.CONFIG_MCC;
    }
    if (delta.mnc != 0 && mnc != delta.mnc) {
        changed |= ActivityInfo.CONFIG_MNC;
    }
    fixUpLocaleList();
    delta.fixUpLocaleList();
    if (!delta.mLocaleList.isEmpty() && !mLocaleList.equals(delta.mLocaleList)) {
        changed |= ActivityInfo.CONFIG_LOCALE;
        changed |= ActivityInfo.CONFIG_LAYOUT_DIRECTION;
    }
    final int deltaScreenLayoutDir = delta.screenLayout & SCREENLAYOUT_LAYOUTDIR_MASK;
    if (deltaScreenLayoutDir != SCREENLAYOUT_LAYOUTDIR_UNDEFINED && deltaScreenLayoutDir != (screenLayout & SCREENLAYOUT_LAYOUTDIR_MASK)) {
        changed |= ActivityInfo.CONFIG_LAYOUT_DIRECTION;
    }
    if (delta.touchscreen != TOUCHSCREEN_UNDEFINED && touchscreen != delta.touchscreen) {
        changed |= ActivityInfo.CONFIG_TOUCHSCREEN;
    }
    if (delta.keyboard != KEYBOARD_UNDEFINED && keyboard != delta.keyboard) {
        changed |= ActivityInfo.CONFIG_KEYBOARD;
    }
    if (delta.keyboardHidden != KEYBOARDHIDDEN_UNDEFINED && keyboardHidden != delta.keyboardHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
    }
    if (delta.hardKeyboardHidden != HARDKEYBOARDHIDDEN_UNDEFINED && hardKeyboardHidden != delta.hardKeyboardHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
    }
    if (delta.navigation != NAVIGATION_UNDEFINED && navigation != delta.navigation) {
        changed |= ActivityInfo.CONFIG_NAVIGATION;
    }
    if (delta.navigationHidden != NAVIGATIONHIDDEN_UNDEFINED && navigationHidden != delta.navigationHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
    }
    if (delta.orientation != ORIENTATION_UNDEFINED && orientation != delta.orientation) {
        changed |= ActivityInfo.CONFIG_ORIENTATION;
    }
    if (getScreenLayoutNoDirection(delta.screenLayout) != (SCREENLAYOUT_SIZE_UNDEFINED | SCREENLAYOUT_LONG_UNDEFINED) && getScreenLayoutNoDirection(screenLayout) != getScreenLayoutNoDirection(delta.screenLayout)) {
        changed |= ActivityInfo.CONFIG_SCREEN_LAYOUT;
    }
    if (delta.uiMode != (UI_MODE_TYPE_UNDEFINED | UI_MODE_NIGHT_UNDEFINED) && uiMode != delta.uiMode) {
        changed |= ActivityInfo.CONFIG_UI_MODE;
    }
    if (delta.screenWidthDp != SCREEN_WIDTH_DP_UNDEFINED && screenWidthDp != delta.screenWidthDp) {
        changed |= ActivityInfo.CONFIG_SCREEN_SIZE;
    }
    if (delta.screenHeightDp != SCREEN_HEIGHT_DP_UNDEFINED && screenHeightDp != delta.screenHeightDp) {
        changed |= ActivityInfo.CONFIG_SCREEN_SIZE;
    }
    if (delta.smallestScreenWidthDp != SMALLEST_SCREEN_WIDTH_DP_UNDEFINED && smallestScreenWidthDp != delta.smallestScreenWidthDp) {
        changed |= ActivityInfo.CONFIG_SMALLEST_SCREEN_SIZE;
    }
    if (delta.densityDpi != DENSITY_DPI_UNDEFINED && densityDpi != delta.densityDpi) {
        changed |= ActivityInfo.CONFIG_DENSITY;
    }
    return changed;
}","{
    return diff(delta, false);
}",1,"/**
 * Return a bit mask of the differences between this Configuration
 * object and the given one.  Does not change the values of either.  Any
 * undefined fields in <var>delta</var> are ignored.
 * @return Returns a bit mask indicating which configuration
 * values has changed, containing any combination of
 * {@link android.content.pm.ActivityInfo#CONFIG_FONT_SCALE
 * PackageManager.ActivityInfo.CONFIG_FONT_SCALE},
 * {@link android.content.pm.ActivityInfo#CONFIG_MCC
 * PackageManager.ActivityInfo.CONFIG_MCC},
 * {@link android.content.pm.ActivityInfo#CONFIG_MNC
 * PackageManager.ActivityInfo.CONFIG_MNC},
 * {@link android.content.pm.ActivityInfo#CONFIG_LOCALE
 * PackageManager.ActivityInfo.CONFIG_LOCALE},
 * {@link android.content.pm.ActivityInfo#CONFIG_TOUCHSCREEN
 * PackageManager.ActivityInfo.CONFIG_TOUCHSCREEN},
 * {@link android.content.pm.ActivityInfo#CONFIG_KEYBOARD
 * PackageManager.ActivityInfo.CONFIG_KEYBOARD},
 * {@link android.content.pm.ActivityInfo#CONFIG_NAVIGATION
 * PackageManager.ActivityInfo.CONFIG_NAVIGATION},
 * {@link android.content.pm.ActivityInfo#CONFIG_ORIENTATION
 * PackageManager.ActivityInfo.CONFIG_ORIENTATION},
 * {@link android.content.pm.ActivityInfo#CONFIG_SCREEN_LAYOUT
 * PackageManager.ActivityInfo.CONFIG_SCREEN_LAYOUT}, or
 * {@link android.content.pm.ActivityInfo#CONFIG_SCREEN_SIZE
 * PackageManager.ActivityInfo.CONFIG_SCREEN_SIZE}, or
 * {@link android.content.pm.ActivityInfo#CONFIG_SMALLEST_SCREEN_SIZE
 * PackageManager.ActivityInfo.CONFIG_SMALLEST_SCREEN_SIZE}.
 * {@link android.content.pm.ActivityInfo#CONFIG_LAYOUT_DIRECTION
 * PackageManager.ActivityInfo.CONFIG_LAYOUT_DIRECTION}.
 */
","/**
 * Return a bit mask of the differences between this Configuration
 * object and the given one.  Does not change the values of either.  Any
 * undefined fields in <var>delta</var> are ignored.
 * @return Returns a bit mask indicating which configuration
 * values has changed, containing any combination of
 * {@link android.content.pm.ActivityInfo#CONFIG_FONT_SCALE
 * PackageManager.ActivityInfo.CONFIG_FONT_SCALE},
 * {@link android.content.pm.ActivityInfo#CONFIG_MCC
 * PackageManager.ActivityInfo.CONFIG_MCC},
 * {@link android.content.pm.ActivityInfo#CONFIG_MNC
 * PackageManager.ActivityInfo.CONFIG_MNC},
 * {@link android.content.pm.ActivityInfo#CONFIG_LOCALE
 * PackageManager.ActivityInfo.CONFIG_LOCALE},
 * {@link android.content.pm.ActivityInfo#CONFIG_TOUCHSCREEN
 * PackageManager.ActivityInfo.CONFIG_TOUCHSCREEN},
 * {@link android.content.pm.ActivityInfo#CONFIG_KEYBOARD
 * PackageManager.ActivityInfo.CONFIG_KEYBOARD},
 * {@link android.content.pm.ActivityInfo#CONFIG_NAVIGATION
 * PackageManager.ActivityInfo.CONFIG_NAVIGATION},
 * {@link android.content.pm.ActivityInfo#CONFIG_ORIENTATION
 * PackageManager.ActivityInfo.CONFIG_ORIENTATION},
 * {@link android.content.pm.ActivityInfo#CONFIG_SCREEN_LAYOUT
 * PackageManager.ActivityInfo.CONFIG_SCREEN_LAYOUT}, or
 * {@link android.content.pm.ActivityInfo#CONFIG_SCREEN_SIZE
 * PackageManager.ActivityInfo.CONFIG_SCREEN_SIZE}, or
 * {@link android.content.pm.ActivityInfo#CONFIG_SMALLEST_SCREEN_SIZE
 * PackageManager.ActivityInfo.CONFIG_SMALLEST_SCREEN_SIZE}.
 * {@link android.content.pm.ActivityInfo#CONFIG_LAYOUT_DIRECTION
 * PackageManager.ActivityInfo.CONFIG_LAYOUT_DIRECTION}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method's implementation was completely replaced with a call to a different method `diff(delta, false)`, so there is a change in the dependent API, the type of code change is 5.","Without knowing the implementation of the newly introduced `diff(delta, false)` method in the late version, we cannot determine whether there are compatibility issues solely based on the current information provided in the signature and annotations. However, assuming that the new `diff` method variant is correctly designed to mimic and replace the functionality of the original inline code, there may be no compatibility issues introduced. Thus, the CI is classified as 0."
739,"<android.widget.Editor.UndoInputFilter: CharSequence filter(CharSequence,int,int,Spanned,int,int)>",25,26,"<android.widget.Editor.UndoInputFilter: CharSequence filter(CharSequence,int,int,Spanned,int,int)>","<android.widget.Editor.UndoInputFilter: CharSequence filter(CharSequence,int,int,Spanned,int,int)>",0,"{
    if (DEBUG_UNDO) {
        Log.d(TAG, ""filter: source="" + source + "" ("" + start + ""-"" + end + "") "" + ""dest="" + dest + "" ("" + dstart + ""-"" + dend + "")"");
    }
    // Check to see if this edit should be tracked for undo.
    if (!canUndoEdit(source, start, end, dest, dstart, dend)) {
        return null;
    }
    // Check for and handle IME composition edits.
    if (handleCompositionEdit(source, start, end, dstart)) {
        return null;
    }
    // Handle keyboard edits.
    handleKeyboardEdit(source, start, end, dest, dstart, dend);
    return null;
}","{
    if (DEBUG_UNDO) {
        Log.d(TAG, ""filter: source="" + source + "" ("" + start + ""-"" + end + "") "" + ""dest="" + dest + "" ("" + dstart + ""-"" + dend + "")"");
    }
    // Check to see if this edit should be tracked for undo.
    if (!canUndoEdit(source, start, end, dest, dstart, dend)) {
        return null;
    }
    final boolean hadComposition = mHasComposition;
    mHasComposition = isComposition(source);
    final boolean wasExpanding = mExpanding;
    boolean shouldCreateSeparateState = false;
    if ((end - start) != (dend - dstart)) {
        mExpanding = (end - start) > (dend - dstart);
        if (hadComposition && mExpanding != wasExpanding) {
            shouldCreateSeparateState = true;
        }
    }
    // Handle edit.
    handleEdit(source, start, end, dest, dstart, dend, shouldCreateSeparateState);
    return null;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The late version introduces several new local variables (hadComposition, mHasComposition, wasExpanding, shouldCreateSeparateState) and changes the method being called from handleCompositionEdit and handleKeyboardEdit to handleEdit with additional parameters. This leads to a change in the other statements, so the code change types are 3 and 4.","Although there are changes in local variables and a modified method call, the return value for both versions of the API is always 'null'. Since the return statement and exception handling statements remain the same (always returning null and not introducing any new exceptions), there is no Compatibility Issue; hence, CI type is 0."
740,<android.hardware.camera2.params.OutputConfiguration: Surface getSurface()>,25,26,<android.hardware.camera2.params.OutputConfiguration: Surface getSurface()>,<android.hardware.camera2.params.OutputConfiguration: Surface getSurface()>,0,"{
    return mSurface;
}","{
    if (mSurfaces.size() == 0) {
        return null;
    }
    return mSurfaces.get(0);
}",1,"/**
 * Get the {@link Surface} associated with this {@link OutputConfiguration}.
 *
 * @return the {@link Surface} associated with this {@link OutputConfiguration}.
 */
","/**
 * Get the {@link Surface} associated with this {@link OutputConfiguration}.
 *
 * If more than one surface is associated with this {@link OutputConfiguration}, return the
 * first one as specified in the constructor or {@link OutputConfiguration#addSurface}.
 */
",-1,[@NonNull],[@Nullable],-1,-1,-1,-1,-1,-1,"1,3",1,"The method's implementation has changed to include a control flow (an 'if' statement) that was not present earlier, and the logic for returning a Surface has changed from directly returning a single Surface, mSurface, to checking a collection of Surfaces, mSurfaces, and returning either null or the first entry. This is reflected as changes in return statement and control dependencies, so the change type is 1,3.","The method now potentially returns null if mSurfaces is empty, which is a different behavior compared to always returning a non-null mSurface in the early version. This difference in behavior implies that the updated method may now return a different value, introducing a possible compatibility issue. Therefore, the CI type is 1."
741,<android.app.ContextImpl: Context createCredentialProtectedStorageContext()>,25,26,<android.app.ContextImpl: Context createCredentialProtectedStorageContext()>,<android.app.ContextImpl: Context createCredentialProtectedStorageContext()>,0,"{
    final int flags = (mFlags & ~Context.CONTEXT_DEVICE_PROTECTED_STORAGE) | Context.CONTEXT_CREDENTIAL_PROTECTED_STORAGE;
    return new ContextImpl(this, mMainThread, mPackageInfo, mActivityToken, mUser, flags, mDisplay, null, Display.INVALID_DISPLAY);
}","{
    final int flags = (mFlags & ~Context.CONTEXT_DEVICE_PROTECTED_STORAGE) | Context.CONTEXT_CREDENTIAL_PROTECTED_STORAGE;
    return new ContextImpl(this, mMainThread, mPackageInfo, mSplitName, mActivityToken, mUser, flags, mClassLoader);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed since the constructor for ContextImpl has different arguments in the early and late versions. There is also a change in dependent API since the constructor's signature has been altered, which implies a change in the dependent API. Therefore, the change types are 1 and 5.",The Construction of ContextImpl has changed which will potentially return an object with different state due to the different arguments passed to it. This will result in a Compatibility Issue of type 1 due to potential different return values or types.
743,<android.view.accessibility.AccessibilityManager: boolean addTouchExplorationStateChangeListener(TouchExplorationStateChangeListener)>,25,26,<android.view.accessibility.AccessibilityManager: boolean addTouchExplorationStateChangeListener(TouchExplorationStateChangeListener)>,<android.view.accessibility.AccessibilityManager: boolean addTouchExplorationStateChangeListener(TouchExplorationStateChangeListener)>,0,"{
    // Final CopyOnWriteArrayList - no lock needed.
    return mTouchExplorationStateChangeListeners.add(listener);
}","{
    addTouchExplorationStateChangeListener(listener, null);
    return true;
}",1,"/**
 * Registers a {@link TouchExplorationStateChangeListener} for changes in
 * the global touch exploration state of the system.
 *
 * @param listener The listener.
 * @return True if successfully registered.
 */
","/**
 * Registers a {@link TouchExplorationStateChangeListener} for changes in
 * the global touch exploration state of the system. Equivalent to calling
 * {@link #addTouchExplorationStateChangeListener(TouchExplorationStateChangeListener, Handler)}
 * with a null handler.
 *
 * @param listener The listener.
 * @return Always returns {@code true}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,The code has changed from directly adding a listener to a list and returning the result to calling another method to perform the add operation and then always returning true. This indicates a change type of 4 and 5 because there is a change in the statements besides a control construct and there is a reliance on another API whose behavior is not known from the provided context.,"Although the implementation has changed, there is no Compatibility Issue since the method now always returns true, which is a constant, implying that the behavior of returning a value from this method is consistent regardless of the result of adding the listener. Thus, the CI type is 0."
745,"<android.app.FragmentManagerImpl: Fragment getFragment(Bundle,String)>",25,26,"<android.app.FragmentManagerImpl: Fragment getFragment(Bundle,String)>","<android.app.FragmentManagerImpl: Fragment getFragment(Bundle,String)>",0,"{
    int index = bundle.getInt(key, -1);
    if (index == -1) {
        return null;
    }
    if (index >= mActive.size()) {
        throwException(new IllegalStateException(""Fragment no longer exists for key "" + key + "": index "" + index));
    }
    Fragment f = mActive.get(index);
    if (f == null) {
        throwException(new IllegalStateException(""Fragment no longer exists for key "" + key + "": index "" + index));
    }
    return f;
}","{
    int index = bundle.getInt(key, -1);
    if (index == -1) {
        return null;
    }
    Fragment f = mActive.get(index);
    if (f == null) {
        throwException(new IllegalStateException(""Fragment no longer exists for key "" + key + "": index "" + index));
    }
    return f;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,3",2,"The late version of code has removed the condition that checks if the index is greater than or equal to the size of `mActive`. This removal is a change in the control dependency, specifically the condition now is less restrictive which is marked as type 3. Additionally, it also means an exception handling statement has been removed, which is marked as type 2.","The removal of the exception handling ('if' condition that checks if the index is valid) means that the late version could potentially not throw an IllegalStateException when 'index' is greater than or equal to 'mActive.size()', where the early version would have thrown an exception. This can lead to the function behaving differently in an error case, and thereby it introduces a Compatibility Issue of type 2."
746,<android.app.FragmentManagerImpl: void startPendingDeferredFragments()>,25,26,<android.app.FragmentManagerImpl: void startPendingDeferredFragments()>,<android.app.FragmentManagerImpl: void startPendingDeferredFragments()>,0,"{
    if (mActive == null)
        return;
    for (int i = 0; i < mActive.size(); i++) {
        Fragment f = mActive.get(i);
        if (f != null) {
            performPendingDeferredStart(f);
        }
    }
}","{
    if (mActive == null)
        return;
    for (int i = 0; i < mActive.size(); i++) {
        Fragment f = mActive.valueAt(i);
        if (f != null) {
            performPendingDeferredStart(f);
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The change from mActive.get(i) to mActive.valueAt(i) indicates a change in accessing elements within the mActive collection, which is an other statement change. Additionally, this seems to be a change in the dependent API (the method used to access the elements in the collection), hence the change is also marked as type 5.","This change does not cause a Compatibility Issue because it does not fundamentally alter the control flow of the method or the values being returned. The method still iterates over all elements in `mActive` and performs the same operation on each non-null `Fragment`, assuming that the `mActive` collection semantic behavior remains consistent (i.e., `valueAt(i)` is a valid replacement for `get(i)`). Therefore, no Compatibility Issue is expected to be caused by this change."
749,<android.app.AlarmManager.ListenerWrapper: void run()>,25,26,<android.app.AlarmManager.ListenerWrapper: void run()>,<android.app.AlarmManager.ListenerWrapper: void run()>,0,"{
    // already considers it gone
    synchronized (AlarmManager.class) {
        if (sWrappers != null) {
            sWrappers.remove(mListener);
        }
    }
    // Now deliver it to the app
    try {
        mListener.onAlarm();
    } finally {
        try {
            mCompletion.alarmComplete(this);
        } catch (Exception e) {
            Log.e(TAG, ""Unable to report completion to Alarm Manager!"", e);
        }
    }
}","{
    // Now deliver it to the app
    try {
        mListener.onAlarm();
    } finally {
        try {
            mCompletion.alarmComplete(this);
        } catch (Exception e) {
            Log.e(TAG, ""Unable to report completion to Alarm Manager!"", e);
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"A synchronized block of code, including a condition and removal operation on sWrappers, has been removed. Thus, the changes are a control dependency change (3) and an other statement changed (4).","The removal of the synchronized block alters the behavior of the method since it no longer removes the mListener from sWrappers. Therefore, this can cause a potential Compatibility Issue with different behavior due to the removal of this side effect, classifying it as a type 1 CI."
750,<android.text.method.DateKeyListener: DateKeyListener getInstance()>,25,26,<android.text.method.DateKeyListener: DateKeyListener getInstance()>,<android.text.method.DateKeyListener: DateKeyListener getInstance()>,0,"{
    if (sInstance != null)
        return sInstance;
    sInstance = new DateKeyListener();
    return sInstance;
}","{
    return getInstance(null);
}",1,,"/**
 * @deprecated Use {@link #getInstance(Locale)} instead.
 */
",-1,,"[@Deprecated, @NonNull]",-1,-1,-1,-1,-1,-1,5,0,"The implementation of the method now calls another method getInstance(null), which indicates that the actual implementation might be offloaded to another overloaded method. This is a typical refactoring to simplify code or to provide a more generic implementation to handle different cases uniformly. Therefore, the change type is Dependent API changed (5).","There is no compatibility issue here since the method still seems to serve the same purpose of returning an instance of DateKeyListener. The behavior of getting an instance is now handled by another getInstance method which takes a parameter, but for this method's contract, it still returns a DateKeyListener instance. If the getInstance(null) method maintains the same contract and behavior, it should not introduce a behavior change, so there is no compatibility issue (0)."
752,"<android.app.ApplicationErrorReport.CrashInfo: void writeToParcel(Parcel,int)>",25,26,"<android.app.ApplicationErrorReport.CrashInfo: void writeToParcel(Parcel,int)>","<android.app.ApplicationErrorReport.CrashInfo: void writeToParcel(Parcel,int)>",0,"{
    int start = dest.dataPosition();
    dest.writeString(exceptionClassName);
    dest.writeString(exceptionMessage);
    dest.writeString(throwFileName);
    dest.writeString(throwClassName);
    dest.writeString(throwMethodName);
    dest.writeInt(throwLineNumber);
    dest.writeString(stackTrace);
    int total = dest.dataPosition() - start;
    if (total > 20 * 1024) {
        Slog.d(""Error"", ""ERR: exClass="" + exceptionClassName);
        Slog.d(""Error"", ""ERR: exMsg="" + exceptionMessage);
        Slog.d(""Error"", ""ERR: file="" + throwFileName);
        Slog.d(""Error"", ""ERR: class="" + throwClassName);
        Slog.d(""Error"", ""ERR: method="" + throwMethodName + "" line="" + throwLineNumber);
        Slog.d(""Error"", ""ERR: stack="" + stackTrace);
        Slog.d(""Error"", ""ERR: TOTAL BYTES WRITTEN: "" + (dest.dataPosition() - start));
    }
}","{
    int start = dest.dataPosition();
    dest.writeString(exceptionClassName);
    dest.writeString(exceptionMessage);
    dest.writeString(throwFileName);
    dest.writeString(throwClassName);
    dest.writeString(throwMethodName);
    dest.writeInt(throwLineNumber);
    dest.writeString(stackTrace);
    int total = dest.dataPosition() - start;
    if (Binder.CHECK_PARCEL_SIZE && total > 20 * 1024) {
        Slog.d(""Error"", ""ERR: exClass="" + exceptionClassName);
        Slog.d(""Error"", ""ERR: exMsg="" + exceptionMessage);
        Slog.d(""Error"", ""ERR: file="" + throwFileName);
        Slog.d(""Error"", ""ERR: class="" + throwClassName);
        Slog.d(""Error"", ""ERR: method="" + throwMethodName + "" line="" + throwLineNumber);
        Slog.d(""Error"", ""ERR: stack="" + stackTrace);
        Slog.d(""Error"", ""ERR: TOTAL BYTES WRITTEN: "" + (dest.dataPosition() - start));
    }
}",1,"/**
 * Save a CrashInfo instance to a parcel.
 */
","/**
 * Save a CrashInfo instance to a parcel.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The change in the late implementation is the addition of the condition `Binder.CHECK_PARCEL_SIZE` in the `if` statement. Therefore, the code change type is 3.","Although there's been a change in the control dependency, the behaviour of the method remains the same regardless of whether `Binder.CHECK_PARCEL_SIZE` is true or false. This added condition controls whether or not to log the error, but does not affect the actual data written to the `Parcel` in any case. Thus, there is no Compatibility Issue, and the CI type is 0."
753,"<android.widget.RemoteViews.TextViewSizeAction: void apply(View,ViewGroup,OnClickHandler)>",25,26,"<android.widget.RemoteViews.TextViewSizeAction: void apply(View,ViewGroup,OnClickHandler)>","<android.widget.RemoteViews.TextViewSizeAction: void apply(View,ViewGroup,OnClickHandler)>",0,"{
    final TextView target = (TextView) root.findViewById(viewId);
    if (target == null)
        return;
    target.setTextSize(units, size);
}","{
    final TextView target = root.findViewById(viewId);
    if (target == null)
        return;
    target.setTextSize(units, size);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,The code change is related to the remove of explicit casting to TextView. The casting is unnecessary because findViewById already returns a view of the specified type due to Java's generics. So the change is of type 4 (Other statement changed).,"The removal of the explicit cast does not affect the behavior of the API as the casting is redundant with generics, so there is no compatibility issue; hence the CI type is 0."
754,<android.widget.TabHost.LabelIndicatorStrategy: View createIndicatorView()>,25,26,<android.widget.TabHost.LabelIndicatorStrategy: View createIndicatorView()>,<android.widget.TabHost.LabelIndicatorStrategy: View createIndicatorView()>,0,"{
    final Context context = getContext();
    LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    View tabIndicator = inflater.inflate(mTabLayoutId, // tab widget is the parent
    mTabWidget, // no inflate params
    false);
    final TextView tv = (TextView) tabIndicator.findViewById(R.id.title);
    tv.setText(mLabel);
    if (context.getApplicationInfo().targetSdkVersion <= Build.VERSION_CODES.DONUT) {
        // Donut apps get old color scheme
        tabIndicator.setBackgroundResource(R.drawable.tab_indicator_v4);
        tv.setTextColor(context.getColorStateList(R.color.tab_indicator_text_v4));
    }
    return tabIndicator;
}","{
    final Context context = getContext();
    LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    View tabIndicator = inflater.inflate(mTabLayoutId, // tab widget is the parent
    mTabWidget, // no inflate params
    false);
    final TextView tv = tabIndicator.findViewById(R.id.title);
    tv.setText(mLabel);
    if (context.getApplicationInfo().targetSdkVersion <= Build.VERSION_CODES.DONUT) {
        // Donut apps get old color scheme
        tabIndicator.setBackgroundResource(R.drawable.tab_indicator_v4);
        tv.setTextColor(context.getColorStateList(R.color.tab_indicator_text_v4));
    }
    return tabIndicator;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,0,0,"The implementation between the early version and the late version remains unchanged; only the type casting to TextView has been removed, which does not affect the outcome since `findViewById` already returns a view of the specified type when possible.","Since there are no actual code changes to any statement that would affect the behavior of the method, there would be no compatibility issues between these two versions."
755,<android.accessibilityservice.AccessibilityService.SoftKeyboardController: void dispatchSoftKeyboardShowModeChanged(int)>,25,26,<android.accessibilityservice.AccessibilityService.SoftKeyboardController: void dispatchSoftKeyboardShowModeChanged(int)>,<android.accessibilityservice.AccessibilityService.SoftKeyboardController: void dispatchSoftKeyboardShowModeChanged(int)>,0,"{
    final ArrayMap<OnShowModeChangedListener, Handler> entries;
    synchronized (mLock) {
        if (mListeners == null || mListeners.isEmpty()) {
            Slog.d(LOG_TAG, ""Received soft keyboard show mode changed callback"" + "" with no listeners registered!"");
            setSoftKeyboardCallbackEnabled(false);
            return;
        }
        // Listeners may remove themselves. Perform a shallow copy to avoid concurrent
        // modification.
        entries = new ArrayMap<>(mListeners);
    }
    for (int i = 0, count = entries.size(); i < count; i++) {
        final OnShowModeChangedListener listener = entries.keyAt(i);
        final Handler handler = entries.valueAt(i);
        if (handler != null) {
            handler.post(new Runnable() {

                @Override
                public void run() {
                    listener.onShowModeChanged(SoftKeyboardController.this, showMode);
                }
            });
        } else {
            // We're already on the main thread, just run the listener.
            listener.onShowModeChanged(this, showMode);
        }
    }
}","{
    final ArrayMap<OnShowModeChangedListener, Handler> entries;
    synchronized (mLock) {
        if (mListeners == null || mListeners.isEmpty()) {
            Slog.w(LOG_TAG, ""Received soft keyboard show mode changed callback"" + "" with no listeners registered!"");
            setSoftKeyboardCallbackEnabled(false);
            return;
        }
        // Listeners may remove themselves. Perform a shallow copy to avoid concurrent
        // modification.
        entries = new ArrayMap<>(mListeners);
    }
    for (int i = 0, count = entries.size(); i < count; i++) {
        final OnShowModeChangedListener listener = entries.keyAt(i);
        final Handler handler = entries.valueAt(i);
        if (handler != null) {
            handler.post(new Runnable() {

                @Override
                public void run() {
                    listener.onShowModeChanged(SoftKeyboardController.this, showMode);
                }
            });
        } else {
            // We're already on the main thread, just run the listener.
            listener.onShowModeChanged(this, showMode);
        }
    }
}",1,"/**
 * Dispatches the soft keyboard show mode change to any registered listeners. This should
 * be called on the service's main thread.
 */
","/**
 * Dispatches the soft keyboard show mode change to any registered listeners. This should
 * be called on the service's main thread.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change in the code is the log level in Slog from ""d"" (debug) to ""w"" (warning). This is an example of an ""Other statement changed"", more specifically the argument of a method invocation (Slog method).","The change in the logging level does not affect the API’s behavior in terms of the returned value or thrown exceptions, therefore it does not introduce a Compatibility Issue."
756,<android.util.jar.StrictJarVerifier.VerifierEntry: void verify()>,25,26,<android.util.jar.StrictJarVerifier.VerifierEntry: void verify()>,<android.util.jar.StrictJarVerifier.VerifierEntry: void verify()>,0,"{
    byte[] d = digest.digest();
    if (!MessageDigest.isEqual(d, Base64.decode(hash))) {
        throw invalidDigest(JarFile.MANIFEST_NAME, name, name);
    }
    verifiedEntries.put(name, certChains);
}","{
    byte[] d = digest.digest();
    if (!verifyMessageDigest(d, hash)) {
        throw invalidDigest(JarFile.MANIFEST_NAME, name, name);
    }
    verifiedEntries.put(name, certChains);
}",1,"/**
 * Verifies that the digests stored in the manifest match the decrypted
 * digests from the .SF file. This indicates the validity of the
 * signing, not the integrity of the file, as its digest must be
 * calculated and verified when its contents are read.
 *
 * @throws SecurityException
 * if the digest value stored in the manifest does <i>not</i>
 * agree with the decrypted digest as recovered from the
 * <code>.SF</code> file.
 */
","/**
 * Verifies that the digests stored in the manifest match the decrypted
 * digests from the .SF file. This indicates the validity of the
 * signing, not the integrity of the file, as its digest must be
 * calculated and verified when its contents are read.
 *
 * @throws SecurityException
 * if the digest value stored in the manifest does <i>not</i>
 * agree with the decrypted digest as recovered from the
 * <code>.SF</code> file.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method call within the if condition has been changed from using MessageDigest.isEqual(d, Base64.decode(hash)) to verifyMessageDigest(d, hash), but without a clear indication that the verifyMessageDigest method's behavior is different from the original code. Because the implementation details of verifyMessageDigest are not provided, we assume it behaves the same as the original code, therefore the only change is related to the internal implementation of the condition check, which does not affect the public API's behavior. Additionally, there's a dependency change for the internal call to a different method to verify the message digest which is classified as change type 4,5.","Since there is no change in the behavior of the API that would affect the return type, thrown exceptions, or control flow from the perspective of the API user, there is no compatibility issue (CI type 0). It seems like a refactoring of the internal implementation to perhaps clean up the code or improve readability."
758,<android.os.StrictMode: void readAndHandleBinderCallViolations(Parcel)>,25,26,<android.os.StrictMode: void readAndHandleBinderCallViolations(Parcel)>,<android.os.StrictMode: void readAndHandleBinderCallViolations(Parcel)>,0,"{
    // Our own stack trace to append
    StringWriter sw = new StringWriter();
    PrintWriter pw = new FastPrintWriter(sw, false, 256);
    new LogStackTrace().printStackTrace(pw);
    pw.flush();
    String ourStack = sw.toString();
    int policyMask = getThreadPolicyMask();
    boolean currentlyGathering = (policyMask & PENALTY_GATHER) != 0;
    int numViolations = p.readInt();
    for (int i = 0; i < numViolations; ++i) {
        if (LOG_V)
            Log.d(TAG, ""strict mode violation stacks read from binder call.  i="" + i);
        ViolationInfo info = new ViolationInfo(p, !currentlyGathering);
        if (info.crashInfo.stackTrace != null && info.crashInfo.stackTrace.length() > 30000) {
            String front = info.crashInfo.stackTrace.substring(0, 256);
            // 30000 characters is way too large for this to be any sane kind of
            // strict mode collection of stacks.  We've had a problem where we leave
            // strict mode violations associated with the thread, and it keeps tacking
            // more and more stacks on to the violations.  Looks like we're in this casse,
            // so we'll report it and bail on all of the current strict mode violations
            // we currently are maintaining for this thread.
            // First, drain the remaining violations from the parcel.
            // Skip the current entry.
            i++;
            for (; i < numViolations; i++) {
                info = new ViolationInfo(p, !currentlyGathering);
            }
            // Next clear out all gathered violations.
            clearGatheredViolations();
            // Now report the problem.
            Slog.wtfStack(TAG, ""Stack is too large: numViolations="" + numViolations + "" policy=#"" + Integer.toHexString(policyMask) + "" front="" + front);
            return;
        }
        info.crashInfo.stackTrace += ""# via Binder call with stack:\n"" + ourStack;
        BlockGuard.Policy policy = BlockGuard.getThreadPolicy();
        if (policy instanceof AndroidBlockGuardPolicy) {
            ((AndroidBlockGuardPolicy) policy).handleViolationWithTimingAttempt(info);
        }
    }
}","{
    // Our own stack trace to append
    StringWriter sw = new StringWriter();
    sw.append(""# via Binder call with stack:\n"");
    PrintWriter pw = new FastPrintWriter(sw, false, 256);
    new LogStackTrace().printStackTrace(pw);
    pw.flush();
    String ourStack = sw.toString();
    final int policyMask = getThreadPolicyMask();
    final boolean currentlyGathering = (policyMask & PENALTY_GATHER) != 0;
    final int size = p.readInt();
    for (int i = 0; i < size; i++) {
        final ViolationInfo info = new ViolationInfo(p, !currentlyGathering);
        info.crashInfo.appendStackTrace(ourStack);
        BlockGuard.Policy policy = BlockGuard.getThreadPolicy();
        if (policy instanceof AndroidBlockGuardPolicy) {
            ((AndroidBlockGuardPolicy) policy).handleViolationWithTimingAttempt(info);
        }
    }
}",1,"/* package */
","/* package */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The loop variable is renamed from numViolations to size, and the stack trace string is now appended earlier in the code using sw.append() rather than later by concatenating strings with '+'. Also, the way of adding the stack trace to ViolationInfo changed from string concatenation to using an append method. These are control dependency changes (due to changes in the loop and conditional statement), and other statement changes, so the change codes are 3,4.","Although there's a change in the loop variable and the method of appending the stack trace, these changes don't affect the output of the method readAndHandleBinderCallViolations. It still handles each violation in the same way and does not change any return value or exception thrown; it's just an internal change of how data is processed. Therefore, there should be no Compatibility Issue, and the CI code is 0."
759,<android.view.accessibility.AccessibilityWindowInfo: AccessibilityWindowInfo obtain(AccessibilityWindowInfo)>,25,26,<android.view.accessibility.AccessibilityWindowInfo: AccessibilityWindowInfo obtain(AccessibilityWindowInfo)>,<android.view.accessibility.AccessibilityWindowInfo: AccessibilityWindowInfo obtain(AccessibilityWindowInfo)>,0,"{
    AccessibilityWindowInfo infoClone = obtain();
    infoClone.mType = info.mType;
    infoClone.mLayer = info.mLayer;
    infoClone.mBooleanProperties = info.mBooleanProperties;
    infoClone.mId = info.mId;
    infoClone.mParentId = info.mParentId;
    infoClone.mBoundsInScreen.set(info.mBoundsInScreen);
    infoClone.mTitle = info.mTitle;
    infoClone.mAnchorId = info.mAnchorId;
    if (info.mChildIds != null && info.mChildIds.size() > 0) {
        if (infoClone.mChildIds == null) {
            infoClone.mChildIds = info.mChildIds.clone();
        } else {
            infoClone.mChildIds.addAll(info.mChildIds);
        }
    }
    infoClone.mConnectionId = info.mConnectionId;
    return infoClone;
}","{
    AccessibilityWindowInfo infoClone = obtain();
    infoClone.mType = info.mType;
    infoClone.mLayer = info.mLayer;
    infoClone.mBooleanProperties = info.mBooleanProperties;
    infoClone.mId = info.mId;
    infoClone.mParentId = info.mParentId;
    infoClone.mBoundsInScreen.set(info.mBoundsInScreen);
    infoClone.mTitle = info.mTitle;
    infoClone.mAnchorId = info.mAnchorId;
    infoClone.mInPictureInPicture = info.mInPictureInPicture;
    if (info.mChildIds != null && info.mChildIds.size() > 0) {
        if (infoClone.mChildIds == null) {
            infoClone.mChildIds = info.mChildIds.clone();
        } else {
            infoClone.mChildIds.addAll(info.mChildIds);
        }
    }
    infoClone.mConnectionId = info.mConnectionId;
    return infoClone;
}",1,"/**
 * Returns a cached instance if such is available or a new one is
 * created. The returned instance is initialized from the given
 * <code>info</code>.
 *
 * @param info The other info.
 * @return An instance.
 */
","/**
 * Returns a cached instance if such is available or a new one is
 * created. The returned instance is initialized from the given
 * <code>info</code>.
 *
 * @param info The other info.
 * @return An instance.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"A new line has been added to set `infoClone.mInPictureInPicture` value from the passed `info`, which is an addition of a new field assignment. This is an 'Other statement changed' and is categorized as change type 4.","The additional assignment of the `mInPictureInPicture` field to `infoClone` does not affect the returned object's type, nor does it change the method's control flow or exception behavior. Because this is merely adding a new property to the cloned object without altering the return type or introducing new exceptions, there is no Compatibility Issue according to the definitions provided. Thus, the CI type is 0."
761,<android.app.SharedPreferencesImpl: Editor edit()>,25,26,<android.app.SharedPreferencesImpl: Editor edit()>,<android.app.SharedPreferencesImpl: Editor edit()>,0,"{
    // ... all without blocking.
    synchronized (this) {
        awaitLoadedLocked();
    }
    return new EditorImpl();
}","{
    // ... all without blocking.
    synchronized (mLock) {
        awaitLoadedLocked();
    }
    return new EditorImpl();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only code change is in the object on which the synchronization is performed. It changed from ""synchronized (this)"" to ""synchronized (mLock)"". This is categorized as an 'Other statement changed' type of change since no return, exception handling, or control dependency statements have been modified.","This change does not result in a Compatibility Issue because the behavior of the API does not change as far as the calling code is concerned. The change to the synchronization mechanism does not affect the API's outward behavior (the values returned or exceptions thrown). The change only affects the internal synchronization details, which do not affect the API’s external contract."
762,<android.app.PendingIntent: void cancel()>,25,26,<android.app.PendingIntent: void cancel()>,<android.app.PendingIntent: void cancel()>,0,"{
    try {
        ActivityManagerNative.getDefault().cancelIntentSender(mTarget);
    } catch (RemoteException e) {
    }
}","{
    try {
        ActivityManager.getService().cancelIntentSender(mTarget);
    } catch (RemoteException e) {
    }
}",1,"/**
 * Cancel a currently active PendingIntent.  Only the original application
 * owning a PendingIntent can cancel it.
 */
","/**
 * Cancel a currently active PendingIntent.  Only the original application
 * owning a PendingIntent can cancel it.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method called to cancel the intent sender has changed from ActivityManagerNative.getDefault().cancelIntentSender(mTarget) to ActivityManager.getService().cancelIntentSender(mTarget), which indicates that a dependent API has changed, so the code change type is 4,5.","The internal implementation uses a different method to achieve the same result and the RemoteException is caught and not propagated outside of the method in both versions, so there is no change in exception handling or return values. Therefore, there is no Compatibility Issue, and the CI type is 0."
763,"<android.widget.PopupWindow: void showAsDropDown(View,int,int,int)>",25,26,"<android.widget.PopupWindow: void showAsDropDown(View,int,int,int)>","<android.widget.PopupWindow: void showAsDropDown(View,int,int,int)>",0,"{
    if (isShowing() || mContentView == null) {
        return;
    }
    TransitionManager.endTransitions(mDecorView);
    attachToAnchor(anchor, xoff, yoff, gravity);
    mIsShowing = true;
    mIsDropdown = true;
    final WindowManager.LayoutParams p = createPopupLayoutParams(anchor.getWindowToken());
    preparePopup(p);
    final boolean aboveAnchor = findDropDownPosition(anchor, p, xoff, yoff, p.width, p.height, gravity);
    updateAboveAnchor(aboveAnchor);
    p.accessibilityIdOfAnchor = (anchor != null) ? anchor.getAccessibilityViewId() : -1;
    invokePopup(p);
}","{
    if (isShowing() || !hasContentView()) {
        return;
    }
    TransitionManager.endTransitions(mDecorView);
    attachToAnchor(anchor, xoff, yoff, gravity);
    mIsShowing = true;
    mIsDropdown = true;
    final WindowManager.LayoutParams p = createPopupLayoutParams(anchor.getApplicationWindowToken());
    preparePopup(p);
    final boolean aboveAnchor = findDropDownPosition(anchor, p, xoff, yoff, p.width, p.height, gravity, mAllowScrollingAnchorParent);
    updateAboveAnchor(aboveAnchor);
    p.accessibilityIdOfAnchor = (anchor != null) ? anchor.getAccessibilityViewId() : -1;
    invokePopup(p);
}",1,"/**
 * Displays the content view in a popup window anchored to the corner of
 * another view. The window is positioned according to the specified
 * gravity and offset by the specified x and y coordinates.
 * <p>
 * If there is not enough room on screen to show the popup in its entirety,
 * this method tries to find a parent scroll view to scroll. If no parent
 * view can be scrolled, the specified vertical gravity will be ignored and
 * the popup will anchor itself such that it is visible.
 * <p>
 * If the view later scrolls to move <code>anchor</code> to a different
 * location, the popup will be moved correspondingly.
 *
 * @param anchor the view on which to pin the popup window
 * @param xoff A horizontal offset from the anchor in pixels
 * @param yoff A vertical offset from the anchor in pixels
 * @param gravity Alignment of the popup relative to the anchor
 *
 * @see #dismiss()
 */
","/**
 * Displays the content view in a popup window anchored to the corner of
 * another view. The window is positioned according to the specified
 * gravity and offset by the specified x and y coordinates.
 * <p>
 * If there is not enough room on screen to show the popup in its entirety,
 * this method tries to find a parent scroll view to scroll. If no parent
 * view can be scrolled, the specified vertical gravity will be ignored and
 * the popup will anchor itself such that it is visible.
 * <p>
 * If the view later scrolls to move <code>anchor</code> to a different
 * location, the popup will be moved correspondingly.
 *
 * @param anchor the view on which to pin the popup window
 * @param xoff A horizontal offset from the anchor in pixels
 * @param yoff A vertical offset from the anchor in pixels
 * @param gravity Alignment of the popup relative to the anchor
 *
 * @see #dismiss()
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,5",1,"The change in the conditional check from mContentView == null to !hasContentView() suggests a change in method invocation which could potentially alter the behavior of the return statement, resulting in a CI; the argument of createPopupLayoutParams has changed from anchor.getWindowToken() to anchor.getApplicationWindowToken(), indicating a change in the dependent API; and the parameters list for findDropDownPosition has an additional argument mAllowScrollingAnchorParent, which signifies a change in control dependency as now an extra condition is taken into account for the execution. Therefore, the changes are 1, 3, and 5.","The condition check change at the beginning will potentially affect whether the method returns early or not based on the changed method for checking content view existence, which may introduce a different return behavior. The changes in createPopupLayoutParams and findDropDownPosition parameters imply that this method is now using a different approach to obtain a window token and determine the drop-down position, which could result in a different execution path or result. Thus, the CI is caused by potential different return values or types (1)."
764,<android.bluetooth.BluetoothSocket: void close()>,25,26,<android.bluetooth.BluetoothSocket: void close()>,<android.bluetooth.BluetoothSocket: void close()>,0,"{
    if (DBG)
        Log.d(TAG, ""close() in, this: "" + this + "", channel: "" + mPort + "", state: "" + mSocketState);
    if (mSocketState == SocketState.CLOSED)
        return;
    else {
        synchronized (this) {
            if (mSocketState == SocketState.CLOSED)
                return;
            mSocketState = SocketState.CLOSED;
            if (DBG)
                Log.d(TAG, ""close() this: "" + this + "", channel: "" + mPort + "", mSocketIS: "" + mSocketIS + "", mSocketOS: "" + mSocketOS + ""mSocket: "" + mSocket);
            if (mSocket != null) {
                if (DBG)
                    Log.d(TAG, ""Closing mSocket: "" + mSocket);
                mSocket.shutdownInput();
                mSocket.shutdownOutput();
                mSocket.close();
                mSocket = null;
            }
            if (mPfd != null) {
                mPfd.close();
                mPfd = null;
            }
        }
    }
}","{
    Log.d(TAG, ""close() this: "" + this + "", channel: "" + mPort + "", mSocketIS: "" + mSocketIS + "", mSocketOS: "" + mSocketOS + ""mSocket: "" + mSocket + "", mSocketState: "" + mSocketState);
    if (mSocketState == SocketState.CLOSED)
        return;
    else {
        synchronized (this) {
            if (mSocketState == SocketState.CLOSED)
                return;
            mSocketState = SocketState.CLOSED;
            if (mSocket != null) {
                if (DBG)
                    Log.d(TAG, ""Closing mSocket: "" + mSocket);
                mSocket.shutdownInput();
                mSocket.shutdownOutput();
                mSocket.close();
                mSocket = null;
            }
            if (mPfd != null) {
                mPfd.close();
                mPfd = null;
            }
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The only change is that the conditional 'if (DBG)' debug log print statement has been removed and a non-conditional Log.d() statement has been added. Such logging statements don't affect the method's execution flow or return values, so the code change type is 4.",There is no Compatibility Issue since the operational behavior of the function and the conditions under which it operates remain consistent between versions. The change is purely in logging and does not affect how the method functions or the value it returns.
765,"<android.widget.RemoteViewsAdapter.RemoteViewsFrameLayoutRefSet: void notifyOnRemoteViewsLoaded(int,RemoteViews)>",25,26,"<android.widget.RemoteViewsAdapter.RemoteViewsFrameLayoutRefSet: void notifyOnRemoteViewsLoaded(int,RemoteViews)>","<android.widget.RemoteViewsAdapter.RemoteViewsFrameLayoutRefSet: void notifyOnRemoteViewsLoaded(int,RemoteViews)>",0,"{
    if (view == null)
        return;
    final LinkedList<RemoteViewsFrameLayout> refs = mReferences.get(position);
    if (refs != null) {
        // Notify all the references for that position of the newly loaded RemoteViews
        for (final RemoteViewsFrameLayout ref : refs) {
            ref.onRemoteViewsLoaded(view, mRemoteViewsOnClickHandler);
            if (mViewToLinkedList.containsKey(ref)) {
                mViewToLinkedList.remove(ref);
            }
        }
        refs.clear();
        // Remove this set from the original mapping
        mReferences.remove(position);
    }
}","{
    if (view == null)
        return;
    final LinkedList<RemoteViewsFrameLayout> refs = mReferences.get(position);
    if (refs != null) {
        // Notify all the references for that position of the newly loaded RemoteViews
        for (final RemoteViewsFrameLayout ref : refs) {
            ref.onRemoteViewsLoaded(view, mRemoteViewsOnClickHandler, true);
            if (mViewToLinkedList.containsKey(ref)) {
                mViewToLinkedList.remove(ref);
            }
        }
        refs.clear();
        // Remove this set from the original mapping
        mReferences.remove(position);
    }
}",1,"/**
 * Notifies each of the RemoteViewsFrameLayouts associated with a particular position that
 * the associated RemoteViews has loaded.
 */
","/**
 * Notifies each of the RemoteViewsFrameLayouts associated with a particular position that
 * the associated RemoteViews has loaded.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The only change in the API implementation is in the line of the method call for `ref.onRemoteViewsLoaded(view, mRemoteViewsOnClickHandler)`, which has been changed to include an additional argument `true` in the late version: `ref.onRemoteViewsLoaded(view, mRemoteViewsOnClickHandler, true)`. This indicates a change in the signature of the `onRemoteViewsLoaded(...)` method, so the code change type is 4 for other statement changed and 5 for dependent API changed.","There is no compatibility issue detected as the additional parameter (`true`) added to `onRemoteViewsLoaded()` does not change what `notifyOnRemoteViewsLoaded` itself returns or the exceptions it may throw, and the method `notifyOnRemoteViewsLoaded` does not return a value (return type is `void`). It is a detail of the inner implementation that affects another method call, which would only cause a compatibility issue if the contract for `onRemoteViewsLoaded()` has been altered incompatibly. Since we don't have visibility into that method's contract here, we assume no compatibility issue solely based on this change within the method `notifyOnRemoteViewsLoaded`."
767,<android.preference.Preference: Editor getEditor()>,25,26,<android.preference.Preference: Editor getEditor()>,<android.preference.Preference: Editor getEditor()>,0,"{
    if (mPreferenceManager == null) {
        return null;
    }
    return mPreferenceManager.getEditor();
}","{
    if (mPreferenceManager == null || getPreferenceDataStore() != null) {
        return null;
    }
    return mPreferenceManager.getEditor();
}",1,"/**
 * Returns an {@link SharedPreferences.Editor} where this Preference can
 * save its value(s). Usually it's easier to use one of the helper save
 * methods: {@link #persistBoolean(boolean)}, {@link #persistFloat(float)},
 * {@link #persistInt(int)}, {@link #persistLong(long)},
 * {@link #persistString(String)}. To read values, see
 * {@link #getSharedPreferences()}. If {@link #shouldCommit()} returns
 * true, it is this Preference's responsibility to commit.
 * <p>
 * In some cases, writes to this will not be committed right away and hence
 * not show up in the SharedPreferences, this is intended behavior to
 * improve performance.
 *
 * @return A {@link SharedPreferences.Editor} where this preference saves
 * its value(s), or null if it isn't attached to a Preference
 * hierarchy.
 * @see #shouldCommit()
 * @see #getSharedPreferences()
 */
","/**
 * Returns an {@link SharedPreferences.Editor} where this Preference can
 * save its value(s). Usually it's easier to use one of the helper save
 * methods: {@link #persistBoolean(boolean)}, {@link #persistFloat(float)},
 * {@link #persistInt(int)}, {@link #persistLong(long)},
 * {@link #persistString(String)}. To read values, see
 * {@link #getSharedPreferences()}. If {@link #shouldCommit()} returns
 * true, it is this Preference's responsibility to commit.
 * <p>
 * In some cases, writes to this will not be committed right away and hence
 * not show up in the SharedPreferences, this is intended behavior to
 * improve performance.
 *
 * @return a {@link SharedPreferences.Editor} where this preference saves its value(s). If
 * this preference isn't attached to a Preference hierarchy or if
 * a {@link PreferenceDataStore} has been set, this method returns {@code null}.
 * @see #shouldCommit()
 * @see #getSharedPreferences()
 * @see #setPreferenceDataStore(PreferenceDataStore)
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"An additional condition was added to the if-statement (checking if getPreferenceDataStore() is not null), so the code change type is 3.","The introduction of an additional condition to the if-statement could result in a scenario where the method now returns null in a situation where it previously would have returned an Editor object; thus, the change can potentially lead to different return values, making the CI type 1."
768,<android.accessibilityservice.AccessibilityService: IBinder onBind(Intent)>,25,26,<android.accessibilityservice.AccessibilityService: IBinder onBind(Intent)>,<android.accessibilityservice.AccessibilityService: IBinder onBind(Intent)>,0,"{
    return new IAccessibilityServiceClientWrapper(this, getMainLooper(), new Callbacks() {

        @Override
        public void onServiceConnected() {
            AccessibilityService.this.dispatchServiceConnected();
        }

        @Override
        public void onInterrupt() {
            AccessibilityService.this.onInterrupt();
        }

        @Override
        public void onAccessibilityEvent(AccessibilityEvent event) {
            AccessibilityService.this.onAccessibilityEvent(event);
        }

        @Override
        public void init(int connectionId, IBinder windowToken) {
            mConnectionId = connectionId;
            mWindowToken = windowToken;
            // The client may have already obtained the window manager, so
            // update the default token on whatever manager we gave them.
            final WindowManagerImpl wm = (WindowManagerImpl) getSystemService(WINDOW_SERVICE);
            wm.setDefaultToken(windowToken);
        }

        @Override
        public boolean onGesture(int gestureId) {
            return AccessibilityService.this.onGesture(gestureId);
        }

        @Override
        public boolean onKeyEvent(KeyEvent event) {
            return AccessibilityService.this.onKeyEvent(event);
        }

        @Override
        public void onMagnificationChanged(@NonNull Region region, float scale, float centerX, float centerY) {
            AccessibilityService.this.onMagnificationChanged(region, scale, centerX, centerY);
        }

        @Override
        public void onSoftKeyboardShowModeChanged(int showMode) {
            AccessibilityService.this.onSoftKeyboardShowModeChanged(showMode);
        }

        @Override
        public void onPerformGestureResult(int sequence, boolean completedSuccessfully) {
            AccessibilityService.this.onPerformGestureResult(sequence, completedSuccessfully);
        }
    });
}","{
    return new IAccessibilityServiceClientWrapper(this, getMainLooper(), new Callbacks() {

        @Override
        public void onServiceConnected() {
            AccessibilityService.this.dispatchServiceConnected();
        }

        @Override
        public void onInterrupt() {
            AccessibilityService.this.onInterrupt();
        }

        @Override
        public void onAccessibilityEvent(AccessibilityEvent event) {
            AccessibilityService.this.onAccessibilityEvent(event);
        }

        @Override
        public void init(int connectionId, IBinder windowToken) {
            mConnectionId = connectionId;
            mWindowToken = windowToken;
            // The client may have already obtained the window manager, so
            // update the default token on whatever manager we gave them.
            final WindowManagerImpl wm = (WindowManagerImpl) getSystemService(WINDOW_SERVICE);
            wm.setDefaultToken(windowToken);
        }

        @Override
        public boolean onGesture(int gestureId) {
            return AccessibilityService.this.onGesture(gestureId);
        }

        @Override
        public boolean onKeyEvent(KeyEvent event) {
            return AccessibilityService.this.onKeyEvent(event);
        }

        @Override
        public void onMagnificationChanged(@NonNull Region region, float scale, float centerX, float centerY) {
            AccessibilityService.this.onMagnificationChanged(region, scale, centerX, centerY);
        }

        @Override
        public void onSoftKeyboardShowModeChanged(int showMode) {
            AccessibilityService.this.onSoftKeyboardShowModeChanged(showMode);
        }

        @Override
        public void onPerformGestureResult(int sequence, boolean completedSuccessfully) {
            AccessibilityService.this.onPerformGestureResult(sequence, completedSuccessfully);
        }

        @Override
        public void onFingerprintCapturingGesturesChanged(boolean active) {
            AccessibilityService.this.onFingerprintCapturingGesturesChanged(active);
        }

        @Override
        public void onFingerprintGesture(int gesture) {
            AccessibilityService.this.onFingerprintGesture(gesture);
        }

        @Override
        public void onAccessibilityButtonClicked() {
            AccessibilityService.this.onAccessibilityButtonClicked();
        }

        @Override
        public void onAccessibilityButtonAvailabilityChanged(boolean available) {
            AccessibilityService.this.onAccessibilityButtonAvailabilityChanged(available);
        }
    });
}",1,"/**
 * Implement to return the implementation of the internal accessibility
 * service interface.
 */
","/**
 * Implement to return the implementation of the internal accessibility
 * service interface.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,1,"The implementation of the anonymous Callbacks class within the returned IAccessibilityServiceClientWrapper has new methods added to it. These methods include onFingerprintCapturingGesturesChanged, onFingerprintGesture, onAccessibilityButtonClicked, and onAccessibilityButtonAvailabilityChanged. This is a change in the dependent API, since additional callback methods are now part of the contract between the service and its clients, as the service's capabilities have been expanded by introducing new functionalities. Code change type is 5.","These changes represent a Compatibility Issue because a client compiled against the new version would have these additional methods that would not be invoked if the client runs on the older version of the platform where these callbacks do not exist. Additionally, newer clients might expect these new callback methods to be called and to handle them, leading to potential behavioral differences when running on the older version that lacks these methods. The CI type is 1."
769,"<android.app.UiAutomation: AccessibilityEvent executeAndWaitForEvent(Runnable,AccessibilityEventFilter,long)>",25,26,"<android.app.UiAutomation: AccessibilityEvent executeAndWaitForEvent(Runnable,AccessibilityEventFilter,long)>","<android.app.UiAutomation: AccessibilityEvent executeAndWaitForEvent(Runnable,AccessibilityEventFilter,long)>",0,"{
    // Acquire the lock and prepare for receiving events.
    synchronized (mLock) {
        throwIfNotConnectedLocked();
        mEventQueue.clear();
        // Prepare to wait for an event.
        mWaitingForEventDelivery = true;
    }
    // Note: We have to release the lock since calling out with this lock held
    // can bite. We will correctly filter out events from other interactions,
    // so starting to collect events before running the action is just fine.
    // We will ignore events from previous interactions.
    final long executionStartTimeMillis = SystemClock.uptimeMillis();
    // Execute the command *without* the lock being held.
    command.run();
    // Acquire the lock and wait for the event.
    synchronized (mLock) {
        try {
            // Wait for the event.
            final long startTimeMillis = SystemClock.uptimeMillis();
            while (true) {
                // Drain the event queue
                while (!mEventQueue.isEmpty()) {
                    AccessibilityEvent event = mEventQueue.remove(0);
                    // Ignore events from previous interactions.
                    if (event.getEventTime() < executionStartTimeMillis) {
                        continue;
                    }
                    if (filter.accept(event)) {
                        return event;
                    }
                    event.recycle();
                }
                // Check if timed out and if not wait.
                final long elapsedTimeMillis = SystemClock.uptimeMillis() - startTimeMillis;
                final long remainingTimeMillis = timeoutMillis - elapsedTimeMillis;
                if (remainingTimeMillis <= 0) {
                    throw new TimeoutException(""Expected event not received within: "" + timeoutMillis + "" ms."");
                }
                try {
                    mLock.wait(remainingTimeMillis);
                } catch (InterruptedException ie) {
                /* ignore */
                }
            }
        } finally {
            mWaitingForEventDelivery = false;
            mEventQueue.clear();
            mLock.notifyAll();
        }
    }
}","{
    // Acquire the lock and prepare for receiving events.
    synchronized (mLock) {
        throwIfNotConnectedLocked();
        mEventQueue.clear();
        // Prepare to wait for an event.
        mWaitingForEventDelivery = true;
    }
    // Note: We have to release the lock since calling out with this lock held
    // can bite. We will correctly filter out events from other interactions,
    // so starting to collect events before running the action is just fine.
    // We will ignore events from previous interactions.
    final long executionStartTimeMillis = SystemClock.uptimeMillis();
    // Execute the command *without* the lock being held.
    command.run();
    // Acquire the lock and wait for the event.
    try {
        // Wait for the event.
        final long startTimeMillis = SystemClock.uptimeMillis();
        while (true) {
            List<AccessibilityEvent> localEvents = new ArrayList<>();
            synchronized (mLock) {
                localEvents.addAll(mEventQueue);
                mEventQueue.clear();
            }
            // Drain the event queue
            while (!localEvents.isEmpty()) {
                AccessibilityEvent event = localEvents.remove(0);
                // Ignore events from previous interactions.
                if (event.getEventTime() < executionStartTimeMillis) {
                    continue;
                }
                if (filter.accept(event)) {
                    return event;
                }
                event.recycle();
            }
            // Check if timed out and if not wait.
            final long elapsedTimeMillis = SystemClock.uptimeMillis() - startTimeMillis;
            final long remainingTimeMillis = timeoutMillis - elapsedTimeMillis;
            if (remainingTimeMillis <= 0) {
                throw new TimeoutException(""Expected event not received within: "" + timeoutMillis + "" ms."");
            }
            synchronized (mLock) {
                if (mEventQueue.isEmpty()) {
                    try {
                        mLock.wait(remainingTimeMillis);
                    } catch (InterruptedException ie) {
                    /* ignore */
                    }
                }
            }
        }
    } finally {
        synchronized (mLock) {
            mWaitingForEventDelivery = false;
            mEventQueue.clear();
            mLock.notifyAll();
        }
    }
}",1,"/**
 * Executes a command and waits for a specific accessibility event up to a
 * given wait timeout. To detect a sequence of events one can implement a
 * filter that keeps track of seen events of the expected sequence and
 * returns true after the last event of that sequence is received.
 * <p>
 * <strong>Note:</strong> It is caller's responsibility to recycle the returned event.
 * </p>
 * @param command The command to execute.
 * @param filter Filter that recognizes the expected event.
 * @param timeoutMillis The wait timeout in milliseconds.
 *
 * @throws TimeoutException If the expected event is not received within the timeout.
 */
","/**
 * Executes a command and waits for a specific accessibility event up to a
 * given wait timeout. To detect a sequence of events one can implement a
 * filter that keeps track of seen events of the expected sequence and
 * returns true after the last event of that sequence is received.
 * <p>
 * <strong>Note:</strong> It is caller's responsibility to recycle the returned event.
 * </p>
 * @param command The command to execute.
 * @param filter Filter that recognizes the expected event.
 * @param timeoutMillis The wait timeout in milliseconds.
 *
 * @throws TimeoutException If the expected event is not received within the timeout.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The code has changed in that the event queue is copied to a local list and the synchronization block has been modified, so control dependency has changed which is identified by ""3"". There are new statements added for dealing with the local copy of events and handling synchronization differently without changing the logic of throwing exceptions or returning which falls under ""4"".","While the changes in the synchronization might affect the way events are handled, no new return statements, exception handling, or API changes were introduced. The outcome of the method remains the same – either it returns an event or throws a TimeoutException, depending on whether an acceptable event is received within the given timeframe. Therefore, there's no Compatibility Issue, coded as ""0""."
771,"<android.provider.DocumentsContract: Bitmap getDocumentThumbnail(ContentResolver,Uri,Point,CancellationSignal)>",25,26,"<android.provider.DocumentsContract: Bitmap getDocumentThumbnail(ContentResolver,Uri,Point,CancellationSignal)>","<android.provider.DocumentsContract: Bitmap getDocumentThumbnail(ContentResolver,Uri,Point,CancellationSignal)>",0,"{
    final ContentProviderClient client = resolver.acquireUnstableContentProviderClient(documentUri.getAuthority());
    try {
        return getDocumentThumbnail(client, documentUri, size, signal);
    } catch (Exception e) {
        if (!(e instanceof OperationCanceledException)) {
            Log.w(TAG, ""Failed to load thumbnail for "" + documentUri + "": "" + e);
        }
        return null;
    } finally {
        ContentProviderClient.releaseQuietly(client);
    }
}","{
    final ContentProviderClient client = resolver.acquireUnstableContentProviderClient(documentUri.getAuthority());
    try {
        return getDocumentThumbnail(client, documentUri, size, signal);
    } catch (Exception e) {
        if (!(e instanceof OperationCanceledException)) {
            Log.w(TAG, ""Failed to load thumbnail for "" + documentUri + "": "" + e);
        }
        rethrowIfNecessary(resolver, e);
        return null;
    } finally {
        ContentProviderClient.releaseQuietly(client);
    }
}",1,"/**
 * Return thumbnail representing the document at the given URI. Callers are
 * responsible for their own in-memory caching.
 *
 * @param documentUri document to return thumbnail for, which must have
 * {@link Document#FLAG_SUPPORTS_THUMBNAIL} set.
 * @param size optimal thumbnail size desired. A provider may return a
 * thumbnail of a different size, but never more than double the
 * requested size.
 * @param signal signal used to indicate if caller is no longer interested
 * in the thumbnail.
 * @return decoded thumbnail, or {@code null} if problem was encountered.
 * @see DocumentsProvider#openDocumentThumbnail(String, Point,
 * android.os.CancellationSignal)
 */
","/**
 * Return thumbnail representing the document at the given URI. Callers are
 * responsible for their own in-memory caching.
 *
 * @param documentUri document to return thumbnail for, which must have
 * {@link Document#FLAG_SUPPORTS_THUMBNAIL} set.
 * @param size optimal thumbnail size desired. A provider may return a
 * thumbnail of a different size, but never more than double the
 * requested size.
 * @param signal signal used to indicate if caller is no longer interested
 * in the thumbnail.
 * @return decoded thumbnail, or {@code null} if problem was encountered.
 * @see DocumentsProvider#openDocumentThumbnail(String, Point,
 * android.os.CancellationSignal)
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"An additional method call has been added: rethrowIfNecessary(resolver, e). However, this method call is conditional and only occurs if the caught Exception is not an instance of OperationCanceledException. No return or exception handling statement was changed outside of this conditional block. Therefore, the change type is 4.","This code change does not create any compatibility issues in terms of the API behavior because the 'rethrowIfNecessary' method is only called if the exception is not an 'OperationCanceledException', which means it does not affect the flow that leads to the 'return null' statement which was present in the earlier version. The handling for 'OperationCanceledException' remains the same, and other exceptions don't lead to any change in behavior that would cause a compatibility issue, as the code will still return null after processing the exception. Therefore, the CI type is 0."
772,<android.os.StatFs: long getTotalBytes()>,25,26,<android.os.StatFs: long getTotalBytes()>,<android.os.StatFs: long getTotalBytes()>,0,"{
    return mStat.f_blocks * mStat.f_bsize;
}","{
    return mStat.f_blocks * mStat.f_frsize;
}",1,"/**
 * The total number of bytes supported by the file system.
 */
","/**
 * The total number of bytes supported by the file system.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The multiplication factor in the return statement has changed from `mStat.f_bsize` to `mStat.f_frsize`, indicating a field used inside the method has changed. This is classified as a dependent API change (since `mStat` is an external structure and its field being accessed has changed) and also a return statement change.","Since the result of the method is dependent on the value of `mStat.f_frsize` rather than `mStat.f_bsize`, the method will potentially return a different value. This constitutes a compatibility issue due to different return values or types."
774,<android.content.IntentSender: String getTargetPackage()>,25,26,<android.content.IntentSender: String getTargetPackage()>,<android.content.IntentSender: String getTargetPackage()>,0,"{
    try {
        return ActivityManagerNative.getDefault().getPackageForIntentSender(mTarget);
    } catch (RemoteException e) {
        // Should never happen.
        return null;
    }
}","{
    try {
        return ActivityManager.getService().getPackageForIntentSender(mTarget);
    } catch (RemoteException e) {
        // Should never happen.
        return null;
    }
}",1,"/**
 * @deprecated Renamed to {@link #getCreatorPackage()}.
 */
","/**
 * @deprecated Renamed to {@link #getCreatorPackage()}.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,5,0,"The method called within the return statement has changed from ActivityManagerNative.getDefault().getPackageForIntentSender(mTarget) to ActivityManager.getService().getPackageForIntentSender(mTarget), which indicates a dependent API has changed; hence, the code change type is 5.","Although there is a change in the dependent API, both methods seem to serve the same purpose, and the rest of the code, including exception handling, remains identical. Therefore, from the given information, it does not seem like this change would lead to a compatibility issue; hence, the CI type is 0."
775,<android.view.accessibility.AccessibilityManager: void sendAccessibilityEvent(AccessibilityEvent)>,25,26,<android.view.accessibility.AccessibilityManager: void sendAccessibilityEvent(AccessibilityEvent)>,<android.view.accessibility.AccessibilityManager: void sendAccessibilityEvent(AccessibilityEvent)>,0,"{
    final IAccessibilityManager service;
    final int userId;
    synchronized (mLock) {
        service = getServiceLocked();
        if (service == null) {
            return;
        }
        if (!mIsEnabled) {
            Looper myLooper = Looper.myLooper();
            if (myLooper == Looper.getMainLooper()) {
                throw new IllegalStateException(""Accessibility off. Did you forget to check that?"");
            } else {
                // If we're not running on the thread with the main looper, it's possible for
                // the state of accessibility to change between checking isEnabled and
                // calling this method. So just log the error rather than throwing the
                // exception.
                Log.e(LOG_TAG, ""AccessibilityEvent sent with accessibility disabled"");
                return;
            }
        }
        userId = mUserId;
    }
    boolean doRecycle = false;
    try {
        event.setEventTime(SystemClock.uptimeMillis());
        // it is possible that this manager is in the same process as the service but
        // client using it is called through Binder from another process. Example: MMS
        // app adds a SMS notification and the NotificationManagerService calls this method
        long identityToken = Binder.clearCallingIdentity();
        doRecycle = service.sendAccessibilityEvent(event, userId);
        Binder.restoreCallingIdentity(identityToken);
        if (DEBUG) {
            Log.i(LOG_TAG, event + "" sent"");
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error during sending "" + event + "" "", re);
    } finally {
        if (doRecycle) {
            event.recycle();
        }
    }
}","{
    final IAccessibilityManager service;
    final int userId;
    synchronized (mLock) {
        service = getServiceLocked();
        if (service == null) {
            return;
        }
        if (!mIsEnabled) {
            Looper myLooper = Looper.myLooper();
            if (myLooper == Looper.getMainLooper()) {
                throw new IllegalStateException(""Accessibility off. Did you forget to check that?"");
            } else {
                // If we're not running on the thread with the main looper, it's possible for
                // the state of accessibility to change between checking isEnabled and
                // calling this method. So just log the error rather than throwing the
                // exception.
                Log.e(LOG_TAG, ""AccessibilityEvent sent with accessibility disabled"");
                return;
            }
        }
        if ((event.getEventType() & mRelevantEventTypes) == 0) {
            if (DEBUG) {
                Log.i(LOG_TAG, ""Not dispatching irrelevant event: "" + event + "" that is not among "" + AccessibilityEvent.eventTypeToString(mRelevantEventTypes));
            }
            return;
        }
        userId = mUserId;
    }
    try {
        event.setEventTime(SystemClock.uptimeMillis());
        // it is possible that this manager is in the same process as the service but
        // client using it is called through Binder from another process. Example: MMS
        // app adds a SMS notification and the NotificationManagerService calls this method
        long identityToken = Binder.clearCallingIdentity();
        service.sendAccessibilityEvent(event, userId);
        Binder.restoreCallingIdentity(identityToken);
        if (DEBUG) {
            Log.i(LOG_TAG, event + "" sent"");
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error during sending "" + event + "" "", re);
    } finally {
        event.recycle();
    }
}",1,"/**
 * Sends an {@link AccessibilityEvent}.
 *
 * @param event The event to send.
 *
 * @throws IllegalStateException if accessibility is not enabled.
 *
 * <strong>Note:</strong> The preferred mechanism for sending custom accessibility
 * events is through calling
 * {@link android.view.ViewParent#requestSendAccessibilityEvent(View, AccessibilityEvent)}
 * instead of this method to allow predecessors to augment/filter events sent by
 * their descendants.
 */
","/**
 * Sends an {@link AccessibilityEvent}.
 *
 * @param event The event to send.
 *
 * @throws IllegalStateException if accessibility is not enabled.
 *
 * <strong>Note:</strong> The preferred mechanism for sending custom accessibility
 * events is through calling
 * {@link android.view.ViewParent#requestSendAccessibilityEvent(View, AccessibilityEvent)}
 * instead of this method to allow predecessors to augment/filter events sent by
 * their descendants.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The implementation has added a control dependency that checks if the event type is relevant (`if ((event.getEventType() & mRelevantEventTypes) == 0)`) and returns if it is not. This introduces a new return statement before the previously present logic, which could prevent the event from being sent and modifies the flow within the method by introducing an early return. Additionally, the variable `doRecycle` and its related condition for recycling the event are not present in the late implementation.",
777,<android.service.notification.ConditionProviderService.H: void handleMessage(Message)>,25,26,<android.service.notification.ConditionProviderService.H: void handleMessage(Message)>,<android.service.notification.ConditionProviderService.H: void handleMessage(Message)>,0,"{
    String name = null;
    try {
        switch(msg.what) {
            case ON_CONNECTED:
                name = ""onConnected"";
                onConnected();
                break;
            case ON_SUBSCRIBE:
                name = ""onSubscribe"";
                onSubscribe((Uri) msg.obj);
                break;
            case ON_UNSUBSCRIBE:
                name = ""onUnsubscribe"";
                onUnsubscribe((Uri) msg.obj);
                break;
        }
    } catch (Throwable t) {
        Log.w(TAG, ""Error running "" + name, t);
    }
}","{
    String name = null;
    if (!isBound()) {
        return;
    }
    try {
        switch(msg.what) {
            case ON_CONNECTED:
                name = ""onConnected"";
                onConnected();
                break;
            case ON_SUBSCRIBE:
                name = ""onSubscribe"";
                onSubscribe((Uri) msg.obj);
                break;
            case ON_UNSUBSCRIBE:
                name = ""onUnsubscribe"";
                onUnsubscribe((Uri) msg.obj);
                break;
        }
    } catch (Throwable t) {
        Log.w(TAG, ""Error running "" + name, t);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,"A new control dependency, an if-statement `if (!isBound())`, has been introduced before the switch statement, so the code change type is 3.","The early version of the method unconditionally enters the switch statement to handle messages, while the late version first checks if the service is bound with `isBound()`. If `isBound()` returns `false`, the method will return early without handling the message, which alters the behavior of the method. However, this change does not cause the method to return a different value or throw a different exception as the method return type is void and no new exception handling has been introduced. Thus, there is no Compatibility Issue (CI)."
778,<android.app.ActivityTransitionCoordinator: void moveSharedElementsFromOverlay()>,25,26,<android.app.ActivityTransitionCoordinator: void moveSharedElementsFromOverlay()>,<android.app.ActivityTransitionCoordinator: void moveSharedElementsFromOverlay()>,0,"{
    int numListeners = mGhostViewListeners.size();
    for (int i = 0; i < numListeners; i++) {
        GhostViewListeners listener = mGhostViewListeners.get(i);
        ViewGroup parent = (ViewGroup) listener.getView().getParent();
        parent.getViewTreeObserver().removeOnPreDrawListener(listener);
    }
    mGhostViewListeners.clear();
    if (mWindow == null || !mWindow.getSharedElementsUseOverlay()) {
        return;
    }
    ViewGroup decor = getDecor();
    if (decor != null) {
        ViewGroupOverlay overlay = decor.getOverlay();
        int count = mSharedElements.size();
        for (int i = 0; i < count; i++) {
            View sharedElement = mSharedElements.get(i);
            GhostView.removeGhost(sharedElement);
        }
    }
}","{
    int numListeners = mGhostViewListeners.size();
    for (int i = 0; i < numListeners; i++) {
        GhostViewListeners listener = mGhostViewListeners.get(i);
        listener.removeListener();
    }
    mGhostViewListeners.clear();
    if (mWindow == null || !mWindow.getSharedElementsUseOverlay()) {
        return;
    }
    ViewGroup decor = getDecor();
    if (decor != null) {
        ViewGroupOverlay overlay = decor.getOverlay();
        int count = mSharedElements.size();
        for (int i = 0; i < count; i++) {
            View sharedElement = mSharedElements.get(i);
            GhostView.removeGhost(sharedElement);
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"There is a change in how the listener is removed, replacing the manual removal of the listener from the view's parent with a call to the method `listener.removeListener()`. This indicates a change in other statements (code change type 4) and a change in control dependency within the loop (code change type 3). ","The end result of listener removal should theoretically remain the same, assuming the `removeListener()` method internally performs the same actions as the replaced code. As such, there is no direct change in the behavior that would cause the return values to change or the exceptions thrown to be different. Therefore, there is no compatibility issue detected."
779,<android.widget.Toast: void setText(CharSequence)>,25,26,<android.widget.Toast: void setText(CharSequence)>,<android.widget.Toast: void setText(CharSequence)>,0,"{
    if (mNextView == null) {
        throw new RuntimeException(""This Toast was not created with Toast.makeText()"");
    }
    TextView tv = (TextView) mNextView.findViewById(com.android.internal.R.id.message);
    if (tv == null) {
        throw new RuntimeException(""This Toast was not created with Toast.makeText()"");
    }
    tv.setText(s);
}","{
    if (mNextView == null) {
        throw new RuntimeException(""This Toast was not created with Toast.makeText()"");
    }
    TextView tv = mNextView.findViewById(com.android.internal.R.id.message);
    if (tv == null) {
        throw new RuntimeException(""This Toast was not created with Toast.makeText()"");
    }
    tv.setText(s);
}",1,"/**
 * Update the text in a Toast that was previously created using one of the makeText() methods.
 * @param s The new text for the Toast.
 */
","/**
 * Update the text in a Toast that was previously created using one of the makeText() methods.
 * @param s The new text for the Toast.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,The cast to `(TextView)` before the `findViewById` call has been removed. This is a minor change that doesn't affect the execution since `findViewById` is expected to return a `TextView` object anyway.,"There is no Compatibility Issue since removing the cast does not change the behavior of the API. The `setText` method will still be called on the same `TextView` object, therefore, no CI caused by potential different return values or exception handlings."
780,"<android.view.View: void invalidateInternal(int,int,int,int,boolean,boolean)>",25,26,"<android.view.View: void invalidateInternal(int,int,int,int,boolean,boolean)>","<android.view.View: void invalidateInternal(int,int,int,int,boolean,boolean)>",0,"{
    if (mGhostView != null) {
        mGhostView.invalidate(true);
        return;
    }
    if (skipInvalidate()) {
        return;
    }
    if ((mPrivateFlags & (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)) == (PFLAG_DRAWN | PFLAG_HAS_BOUNDS) || (invalidateCache && (mPrivateFlags & PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID) || (mPrivateFlags & PFLAG_INVALIDATED) != PFLAG_INVALIDATED || (fullInvalidate && isOpaque() != mLastIsOpaque)) {
        if (fullInvalidate) {
            mLastIsOpaque = isOpaque();
            mPrivateFlags &= ~PFLAG_DRAWN;
        }
        mPrivateFlags |= PFLAG_DIRTY;
        if (invalidateCache) {
            mPrivateFlags |= PFLAG_INVALIDATED;
            mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
        }
        // Propagate the damage rectangle to the parent view.
        final AttachInfo ai = mAttachInfo;
        final ViewParent p = mParent;
        if (p != null && ai != null && l < r && t < b) {
            final Rect damage = ai.mTmpInvalRect;
            damage.set(l, t, r, b);
            p.invalidateChild(this, damage);
        }
        // Damage the entire projection receiver, if necessary.
        if (mBackground != null && mBackground.isProjected()) {
            final View receiver = getProjectionReceiver();
            if (receiver != null) {
                receiver.damageInParent();
            }
        }
        // Damage the entire IsolatedZVolume receiving this view's shadow.
        if (isHardwareAccelerated() && getZ() != 0) {
            damageShadowReceiver();
        }
    }
}","{
    if (mGhostView != null) {
        mGhostView.invalidate(true);
        return;
    }
    if (skipInvalidate()) {
        return;
    }
    if ((mPrivateFlags & (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)) == (PFLAG_DRAWN | PFLAG_HAS_BOUNDS) || (invalidateCache && (mPrivateFlags & PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID) || (mPrivateFlags & PFLAG_INVALIDATED) != PFLAG_INVALIDATED || (fullInvalidate && isOpaque() != mLastIsOpaque)) {
        if (fullInvalidate) {
            mLastIsOpaque = isOpaque();
            mPrivateFlags &= ~PFLAG_DRAWN;
        }
        mPrivateFlags |= PFLAG_DIRTY;
        if (invalidateCache) {
            mPrivateFlags |= PFLAG_INVALIDATED;
            mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
        }
        // Propagate the damage rectangle to the parent view.
        final AttachInfo ai = mAttachInfo;
        final ViewParent p = mParent;
        if (p != null && ai != null && l < r && t < b) {
            final Rect damage = ai.mTmpInvalRect;
            damage.set(l, t, r, b);
            p.invalidateChild(this, damage);
        }
        // Damage the entire projection receiver, if necessary.
        if (mBackground != null && mBackground.isProjected()) {
            final View receiver = getProjectionReceiver();
            if (receiver != null) {
                receiver.damageInParent();
            }
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,0,0,There is no change between the early and late implementation of the method; both the source code and the annotations remain the same.,"Since there is no change in the implementation or annotations of the method between the two versions, there is no compatibility issue."
783,<android.app.Activity: String getCallingPackage()>,25,26,<android.app.Activity: String getCallingPackage()>,<android.app.Activity: String getCallingPackage()>,0,"{
    try {
        return ActivityManagerNative.getDefault().getCallingPackage(mToken);
    } catch (RemoteException e) {
        return null;
    }
}","{
    try {
        return ActivityManager.getService().getCallingPackage(mToken);
    } catch (RemoteException e) {
        return null;
    }
}",1,"/**
 * Return the name of the package that invoked this activity.  This is who
 * the data in {@link #setResult setResult()} will be sent to.  You can
 * use this information to validate that the recipient is allowed to
 * receive the data.
 *
 * <p class=""note"">Note: if the calling activity is not expecting a result (that is it
 * did not use the {@link #startActivityForResult}
 * form that includes a request code), then the calling package will be
 * null.</p>
 *
 * <p class=""note"">Note: prior to {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2},
 * the result from this method was unstable.  If the process hosting the calling
 * package was no longer running, it would return null instead of the proper package
 * name.  You can use {@link #getCallingActivity()} and retrieve the package name
 * from that instead.</p>
 *
 * @return The package of the activity that will receive your
 * reply, or null if none.
 */
","/**
 * Return the name of the package that invoked this activity.  This is who
 * the data in {@link #setResult setResult()} will be sent to.  You can
 * use this information to validate that the recipient is allowed to
 * receive the data.
 *
 * <p class=""note"">Note: if the calling activity is not expecting a result (that is it
 * did not use the {@link #startActivityForResult}
 * form that includes a request code), then the calling package will be
 * null.</p>
 *
 * <p class=""note"">Note: prior to {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2},
 * the result from this method was unstable.  If the process hosting the calling
 * package was no longer running, it would return null instead of the proper package
 * name.  You can use {@link #getCallingActivity()} and retrieve the package name
 * from that instead.</p>
 *
 * @return The package of the activity that will receive your
 * reply, or null if none.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,5,0,"The dependent API being used has changed from ActivityManagerNative.getDefault().getCallingPackage(mToken) to ActivityManager.getService().getCallingPackage(mToken), so the code change type is 5.","There's no compatibility issue introduced by this change because the external behavior of the method should remain the same - it returns the package name of the calling activity or null if there's a RemoteException. Therefore, the CI type is 0."
784,<android.util.ArrayMap: void ensureCapacity(int)>,25,26,<android.util.ArrayMap: void ensureCapacity(int)>,<android.util.ArrayMap: void ensureCapacity(int)>,0,"{
    if (mHashes.length < minimumCapacity) {
        final int[] ohashes = mHashes;
        final Object[] oarray = mArray;
        allocArrays(minimumCapacity);
        if (mSize > 0) {
            System.arraycopy(ohashes, 0, mHashes, 0, mSize);
            System.arraycopy(oarray, 0, mArray, 0, mSize << 1);
        }
        freeArrays(ohashes, oarray, mSize);
    }
}","{
    final int osize = mSize;
    if (mHashes.length < minimumCapacity) {
        final int[] ohashes = mHashes;
        final Object[] oarray = mArray;
        allocArrays(minimumCapacity);
        if (mSize > 0) {
            System.arraycopy(ohashes, 0, mHashes, 0, osize);
            System.arraycopy(oarray, 0, mArray, 0, osize << 1);
        }
        freeArrays(ohashes, oarray, osize);
    }
    if (CONCURRENT_MODIFICATION_EXCEPTIONS && mSize != osize) {
        throw new ConcurrentModificationException();
    }
}",1,"/**
 * Ensure the array map can hold at least <var>minimumCapacity</var>
 * items.
 */
","/**
 * Ensure the array map can hold at least <var>minimumCapacity</var>
 * items.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",2,"In the late version implementation, a local variable 'osize' is introduced to hold the value of 'mSize' before the array allocation. Additionally, a new if-statement that throws a ConcurrentModificationException has been added, which implies a change in the exception handling logic. Thus, the code change types are 3 and 4.","The added if-condition that throws a new ConcurrentModificationException represents a change in the exception handling behavior of the method. Since this new exception was not present in the earlier version, it constitutes a Compatibility Issue of type 2 caused by potential different exception handlings."
785,<android.app.FragmentManagerImpl: Bundle saveFragmentBasicState(Fragment)>,25,26,<android.app.FragmentManagerImpl: Bundle saveFragmentBasicState(Fragment)>,<android.app.FragmentManagerImpl: Bundle saveFragmentBasicState(Fragment)>,0,"{
    Bundle result = null;
    if (mStateBundle == null) {
        mStateBundle = new Bundle();
    }
    f.performSaveInstanceState(mStateBundle);
    if (!mStateBundle.isEmpty()) {
        result = mStateBundle;
        mStateBundle = null;
    }
    if (f.mView != null) {
        saveFragmentViewState(f);
    }
    if (f.mSavedViewState != null) {
        if (result == null) {
            result = new Bundle();
        }
        result.putSparseParcelableArray(FragmentManagerImpl.VIEW_STATE_TAG, f.mSavedViewState);
    }
    if (!f.mUserVisibleHint) {
        if (result == null) {
            result = new Bundle();
        }
        // Only add this if it's not the default value
        result.putBoolean(FragmentManagerImpl.USER_VISIBLE_HINT_TAG, f.mUserVisibleHint);
    }
    return result;
}","{
    Bundle result = null;
    if (mStateBundle == null) {
        mStateBundle = new Bundle();
    }
    f.performSaveInstanceState(mStateBundle);
    dispatchOnFragmentSaveInstanceState(f, mStateBundle, false);
    if (!mStateBundle.isEmpty()) {
        result = mStateBundle;
        mStateBundle = null;
    }
    if (f.mView != null) {
        saveFragmentViewState(f);
    }
    if (f.mSavedViewState != null) {
        if (result == null) {
            result = new Bundle();
        }
        result.putSparseParcelableArray(FragmentManagerImpl.VIEW_STATE_TAG, f.mSavedViewState);
    }
    if (!f.mUserVisibleHint) {
        if (result == null) {
            result = new Bundle();
        }
        // Only add this if it's not the default value
        result.putBoolean(FragmentManagerImpl.USER_VISIBLE_HINT_TAG, f.mUserVisibleHint);
    }
    return result;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method dispatchOnFragmentSaveInstanceState(f, mStateBundle, false) is added in the late implementation, which does not affect any return statement or exception handling statement directly. This change is an additional method call, so the code change type is 4.","There's no indication that the newly introduced call to dispatchOnFragmentSaveInstanceState(f, mStateBundle, false) would result in a changed return value or a new exception being thrown. Since additional method calls don't inherently cause a CI unless they modify the control flow in a way that affects the return statements or exception handling, we cannot infer a CI based solely on this change. Therefore, the CI type is 0."
786,<android.content.SyncAdapterType: String toString()>,25,26,<android.content.SyncAdapterType: String toString()>,<android.content.SyncAdapterType: String toString()>,0,"{
    if (isKey) {
        return ""SyncAdapterType Key {name="" + authority + "", type="" + accountType + ""}"";
    } else {
        return ""SyncAdapterType {name="" + authority + "", type="" + accountType + "", userVisible="" + userVisible + "", supportsUploading="" + supportsUploading + "", isAlwaysSyncable="" + isAlwaysSyncable + "", allowParallelSyncs="" + allowParallelSyncs + "", settingsActivity="" + settingsActivity + ""}"";
    }
}","{
    if (isKey) {
        return ""SyncAdapterType Key {name="" + authority + "", type="" + accountType + ""}"";
    } else {
        return ""SyncAdapterType {name="" + authority + "", type="" + accountType + "", userVisible="" + userVisible + "", supportsUploading="" + supportsUploading + "", isAlwaysSyncable="" + isAlwaysSyncable + "", allowParallelSyncs="" + allowParallelSyncs + "", settingsActivity="" + settingsActivity + "", packageName="" + packageName + ""}"";
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The if-else structure and control flow remain unchanged. A new string concatenation including "", packageName="" + packageName"" has been added to the else block, which classes as 'Other statement changed'.","Although there is an additional string concatenation for the 'packageName', it does not affect the return type (still a String) or change the possibility to throw an exception. There is no Compatibility Issue due to this change."
788,"<android.app.ActivityTransitionState: void setEnterActivityOptions(Activity,ActivityOptions)>",25,26,"<android.app.ActivityTransitionState: void setEnterActivityOptions(Activity,ActivityOptions)>","<android.app.ActivityTransitionState: void setEnterActivityOptions(Activity,ActivityOptions)>",0,"{
    final Window window = activity.getWindow();
    if (window == null) {
        return;
    }
    // ensure Decor View has been created so that the window features are activated
    window.getDecorView();
    if (window.hasFeature(Window.FEATURE_ACTIVITY_TRANSITIONS) && options != null && mEnterActivityOptions == null && mEnterTransitionCoordinator == null && options.getAnimationType() == ActivityOptions.ANIM_SCENE_TRANSITION) {
        mEnterActivityOptions = options;
        mIsEnterTriggered = false;
        if (mEnterActivityOptions.isReturning()) {
            restoreExitedViews();
            int result = mEnterActivityOptions.getResultCode();
            if (result != 0) {
                activity.onActivityReenter(result, mEnterActivityOptions.getResultData());
            }
        }
    }
}","{
    final Window window = activity.getWindow();
    if (window == null) {
        return;
    }
    // ensure Decor View has been created so that the window features are activated
    window.getDecorView();
    if (window.hasFeature(Window.FEATURE_ACTIVITY_TRANSITIONS) && options != null && mEnterActivityOptions == null && mEnterTransitionCoordinator == null && options.getAnimationType() == ActivityOptions.ANIM_SCENE_TRANSITION) {
        mEnterActivityOptions = options;
        mIsEnterTriggered = false;
        if (mEnterActivityOptions.isReturning()) {
            restoreExitedViews();
            int result = mEnterActivityOptions.getResultCode();
            if (result != 0) {
                Intent intent = mEnterActivityOptions.getResultData();
                if (intent != null) {
                    intent.setExtrasClassLoader(activity.getClassLoader());
                }
                activity.onActivityReenter(result, intent);
            }
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The late version includes additional steps to set a class loader for the intent (intent.setExtrasClassLoader(activity.getClassLoader());), which is not present in the early version. This change falls under the category ""Other statement changed"" because the setExtrasClassLoader() does not affect the API's control flow, return statement, or exception handling.","There is no Compatibility Issue since the additional code does not affect the return value of the method, as the method returns void, nor does it introduce changes to the exceptions that the method might throw. The method's behavior remains the same in terms of the interaction protocol with the method's inputs and outputs."
789,"<android.content.pm.PackageInstaller: void uninstall(String,IntentSender)>",25,26,"<android.content.pm.PackageInstaller: void uninstall(String,IntentSender)>","<android.content.pm.PackageInstaller: void uninstall(String,IntentSender)>",0,"{
    try {
        mInstaller.uninstall(packageName, mInstallerPackageName, 0, statusReceiver, mUserId);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    uninstall(new VersionedPackage(packageName, PackageManager.VERSION_CODE_HIGHEST), statusReceiver);
}",1,"/**
 * Uninstall the given package, removing it completely from the device. This
 * method is only available to the current ""installer of record"" for the
 * package.
 */
","/**
 * Uninstall the given package, removing it completely from the device. This
 * method is only available to the current ""installer of record"" for the
 * package.
 *
 * @param packageName The package to uninstall.
 * @param statusReceiver Where to deliver the result.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation of the API calls a different method with a different signature ('uninstall(new VersionedPackage(packageName, PackageManager.VERSION_CODE_HIGHEST), statusReceiver)' instead of 'mInstaller.uninstall(packageName, mInstallerPackageName, 0, statusReceiver, mUserId)'), so the change type is 4,5.","Even though they call different methods, the API's purpose remains the same — to initiate an uninstall of a package. Both methods are internal calls, which should handle the uninstallation process correctly. Since the abstract behavior of uninstalling a package by its name does not change and there is no indication that the exception handling has changed, we do not classify this as a Compatibility Issue. Therefore, the CI type is 0."
790,<android.widget.VideoView: boolean onTouchEvent(MotionEvent)>,25,26,<android.widget.VideoView: boolean onTouchEvent(MotionEvent)>,<android.widget.VideoView: boolean onTouchEvent(MotionEvent)>,0,"{
    if (isInPlaybackState() && mMediaController != null) {
        toggleMediaControlsVisiblity();
    }
    return false;
}","{
    if (ev.getAction() == MotionEvent.ACTION_DOWN && isInPlaybackState() && mMediaController != null) {
        toggleMediaControlsVisiblity();
    }
    return super.onTouchEvent(ev);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"The addition of ""ev.getAction() == MotionEvent.ACTION_DOWN"" in the if condition and the replacement of ""return false;"" with ""return super.onTouchEvent(ev);"" makes two types of changes: control dependency change (3) and return statement changed (1).","The API now requires an additional condition for the if statement to execute, which could affect whether toggleMediaControlsVisiblity() is called or not. Additionally, returning the result of super.onTouchEvent(ev) rather than a hard-coded false could result in different return values. These changes can lead to a CI, categorizing it as type 1."
791,<android.preference.PreferenceManager: Editor getEditor()>,25,26,<android.preference.PreferenceManager: Editor getEditor()>,<android.preference.PreferenceManager: Editor getEditor()>,0,"{
    if (mNoCommit) {
        if (mEditor == null) {
            mEditor = getSharedPreferences().edit();
        }
        return mEditor;
    } else {
        return getSharedPreferences().edit();
    }
}","{
    if (mPreferenceDataStore != null) {
        return null;
    }
    if (mNoCommit) {
        if (mEditor == null) {
            mEditor = getSharedPreferences().edit();
        }
        return mEditor;
    } else {
        return getSharedPreferences().edit();
    }
}",1,"/**
 * Returns an editor to use when modifying the shared preferences.
 * <p>
 * Do NOT commit unless {@link #shouldCommit()} returns true.
 *
 * @return An editor to use to write to shared preferences.
 * @see #shouldCommit()
 */
","/**
 * Returns an editor to use when modifying the shared preferences.
 *
 * <p>Do NOT commit unless {@link #shouldCommit()} returns true.
 *
 * @return an editor to use to write to shared preferences. If a {@link PreferenceDataStore}
 * has been set, this method returns {@code null}.
 * @see #shouldCommit()
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The control dependency has changed with the addition of a new condition `if (mPreferenceDataStore != null)`. This introduces a new branch which returns null, which is a new return statement. So, the code change types are 1 and 3.","Due to the new conditional statement and corresponding return of null, there's a potential for the API to return a different value than it did before. If `mPreferenceDataStore` is not null, the method previously would have returned a SharedPreferences.Editor, but now it returns null. This is a CI type 1, where the returned value can be different due to the new check."
792,"<android.widget.RemoteViews.ViewGroupAction: Action initActionAsync(ViewTree,ViewGroup,OnClickHandler)>",25,26,"<android.widget.RemoteViews.ViewGroupAction: Action initActionAsync(ViewTree,ViewGroup,OnClickHandler)>","<android.widget.RemoteViews.ViewGroupAction: Action initActionAsync(ViewTree,ViewGroup,OnClickHandler)>",0,"{
    // In the async implementation, update the view tree so that subsequent calls to
    // findViewById return the currect view.
    root.createTree();
    ViewTree target = root.findViewTreeById(viewId);
    if ((target == null) || !(target.mRoot instanceof ViewGroup)) {
        return ACTION_NOOP;
    }
    if (nestedViews == null) {
        // Clear all children when nested views omitted
        target.mChildren = null;
        return this;
    } else {
        // Inflate nested views and perform all the async tasks for the child remoteView.
        final Context context = root.mRoot.getContext();
        final AsyncApplyTask task = nestedViews.getAsyncApplyTask(context, (ViewGroup) target.mRoot, null, handler);
        final ViewTree tree = task.doInBackground();
        // Update the global view tree, so that next call to findViewTreeById
        // goes through the subtree as well.
        target.addChild(tree);
        return new RuntimeAction() {

            @Override
            public void apply(View root, ViewGroup rootParent, OnClickHandler handler) throws ActionException {
                // This view will exist as we have already made sure
                final ViewGroup target = (ViewGroup) root.findViewById(viewId);
                task.onPostExecute(tree);
                target.addView(task.mResult);
            }
        };
    }
}","{
    // In the async implementation, update the view tree so that subsequent calls to
    // findViewById return the currect view.
    root.createTree();
    ViewTree target = root.findViewTreeById(viewId);
    if ((target == null) || !(target.mRoot instanceof ViewGroup)) {
        return ACTION_NOOP;
    }
    final ViewGroup targetVg = (ViewGroup) target.mRoot;
    if (nestedViews == null) {
        // Clear all children when nested views omitted
        target.mChildren = null;
        return new RuntimeAction() {

            @Override
            public void apply(View root, ViewGroup rootParent, OnClickHandler handler) throws ActionException {
                targetVg.removeAllViews();
            }
        };
    } else {
        // Inflate nested views and perform all the async tasks for the child remoteView.
        final Context context = root.mRoot.getContext();
        final AsyncApplyTask task = nestedViews.getAsyncApplyTask(context, targetVg, null, handler);
        final ViewTree tree = task.doInBackground();
        if (tree == null) {
            throw new ActionException(task.mError);
        }
        // Update the global view tree, so that next call to findViewTreeById
        // goes through the subtree as well.
        target.addChild(tree);
        return new RuntimeAction() {

            @Override
            public void apply(View root, ViewGroup rootParent, OnClickHandler handler) throws ActionException {
                task.onPostExecute(tree);
                targetVg.addView(task.mResult);
            }
        };
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,2,3,4","1,2",There are multiple code changes:,3. The `RuntimeAction` inside the `else` block was also modified with changes in the `apply` method implementation.
793,"<android.app.PendingIntent: void send(Context,int,Intent,OnFinished,Handler,String,Bundle)>",25,26,"<android.app.PendingIntent: void send(Context,int,Intent,OnFinished,Handler,String,Bundle)>","<android.app.PendingIntent: void send(Context,int,Intent,OnFinished,Handler,String,Bundle)>",0,"{
    try {
        String resolvedType = intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
        int res = ActivityManagerNative.getDefault().sendIntentSender(mTarget, code, intent, resolvedType, onFinished != null ? new FinishedDispatcher(this, onFinished, handler) : null, requiredPermission, options);
        if (res < 0) {
            throw new CanceledException();
        }
    } catch (RemoteException e) {
        throw new CanceledException(e);
    }
}","{
    try {
        String resolvedType = intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
        int res = ActivityManager.getService().sendIntentSender(mTarget, mWhitelistToken, code, intent, resolvedType, onFinished != null ? new FinishedDispatcher(this, onFinished, handler) : null, requiredPermission, options);
        if (res < 0) {
            throw new CanceledException();
        }
    } catch (RemoteException e) {
        throw new CanceledException(e);
    }
}",1,"/**
 * Perform the operation associated with this PendingIntent, allowing the
 * caller to specify information about the Intent to use and be notified
 * when the send has completed.
 *
 * <p>For the intent parameter, a PendingIntent
 * often has restrictions on which fields can be supplied here, based on
 * how the PendingIntent was retrieved in {@link #getActivity},
 * {@link #getBroadcast}, or {@link #getService}.
 *
 * @param context The Context of the caller.  This may be null if
 * <var>intent</var> is also null.
 * @param code Result code to supply back to the PendingIntent's target.
 * @param intent Additional Intent data.  See {@link Intent#fillIn
 * Intent.fillIn()} for information on how this is applied to the
 * original Intent.  Use null to not modify the original Intent.
 * If flag {@link #FLAG_IMMUTABLE} was set when this pending intent was
 * created, this argument will be ignored.
 * @param onFinished The object to call back on when the send has
 * completed, or null for no callback.
 * @param handler Handler identifying the thread on which the callback
 * should happen.  If null, the callback will happen from the thread
 * pool of the process.
 * @param requiredPermission Name of permission that a recipient of the PendingIntent
 * is required to hold.  This is only valid for broadcast intents, and
 * corresponds to the permission argument in
 * {@link Context#sendBroadcast(Intent, String) Context.sendOrderedBroadcast(Intent, String)}.
 * If null, no permission is required.
 * @param options Additional options the caller would like to provide to modify the sending
 * behavior.  May be built from an {@link ActivityOptions} to apply to an activity start.
 *
 * @see #send()
 * @see #send(int)
 * @see #send(Context, int, Intent)
 * @see #send(int, android.app.PendingIntent.OnFinished, Handler)
 * @see #send(Context, int, Intent, OnFinished, Handler)
 *
 * @throws CanceledException Throws CanceledException if the PendingIntent
 * is no longer allowing more intents to be sent through it.
 */
","/**
 * Perform the operation associated with this PendingIntent, allowing the
 * caller to specify information about the Intent to use and be notified
 * when the send has completed.
 *
 * <p>For the intent parameter, a PendingIntent
 * often has restrictions on which fields can be supplied here, based on
 * how the PendingIntent was retrieved in {@link #getActivity},
 * {@link #getBroadcast}, or {@link #getService}.
 *
 * @param context The Context of the caller.  This may be null if
 * <var>intent</var> is also null.
 * @param code Result code to supply back to the PendingIntent's target.
 * @param intent Additional Intent data.  See {@link Intent#fillIn
 * Intent.fillIn()} for information on how this is applied to the
 * original Intent.  Use null to not modify the original Intent.
 * If flag {@link #FLAG_IMMUTABLE} was set when this pending intent was
 * created, this argument will be ignored.
 * @param onFinished The object to call back on when the send has
 * completed, or null for no callback.
 * @param handler Handler identifying the thread on which the callback
 * should happen.  If null, the callback will happen from the thread
 * pool of the process.
 * @param requiredPermission Name of permission that a recipient of the PendingIntent
 * is required to hold.  This is only valid for broadcast intents, and
 * corresponds to the permission argument in
 * {@link Context#sendBroadcast(Intent, String) Context.sendOrderedBroadcast(Intent, String)}.
 * If null, no permission is required.
 * @param options Additional options the caller would like to provide to modify the sending
 * behavior.  May be built from an {@link ActivityOptions} to apply to an activity start.
 *
 * @see #send()
 * @see #send(int)
 * @see #send(Context, int, Intent)
 * @see #send(int, android.app.PendingIntent.OnFinished, Handler)
 * @see #send(Context, int, Intent, OnFinished, Handler)
 *
 * @throws CanceledException Throws CanceledException if the PendingIntent
 * is no longer allowing more intents to be sent through it.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The call to the activity manager service has been changed from ActivityManagerNative.getDefault().sendIntentSender to ActivityManager.getService().sendIntentSender and the addition of mWhitelistToken in the parameter. This is an internal implementation detail relating to how the PendingIntent sends its intent, and represents a change in the dependent API invoked by the method, so the code change type is 5.","Although there's a change in how the ActivityManager service is accessed and an additional parameter is used, from the perspective of the API caller, there's no direct change in behavior. The method's signature is unchanged, the exceptions thrown are the same, and the same conditions lead to these exceptions. As such, there's no CI."
794,<android.animation.AnimatorSet: void cancel()>,25,26,<android.animation.AnimatorSet: void cancel()>,<android.animation.AnimatorSet: void cancel()>,0,"{
    mTerminated = true;
    if (isStarted()) {
        ArrayList<AnimatorListener> tmpListeners = null;
        if (mListeners != null) {
            tmpListeners = (ArrayList<AnimatorListener>) mListeners.clone();
            int size = tmpListeners.size();
            for (int i = 0; i < size; i++) {
                tmpListeners.get(i).onAnimationCancel(this);
            }
        }
        ArrayList<Animator> playingSet = new ArrayList<>(mPlayingSet);
        int setSize = playingSet.size();
        for (int i = 0; i < setSize; i++) {
            playingSet.get(i).cancel();
        }
        if (tmpListeners != null) {
            int size = tmpListeners.size();
            for (int i = 0; i < size; i++) {
                tmpListeners.get(i).onAnimationEnd(this);
            }
        }
        mStarted = false;
    }
}","{
    if (Looper.myLooper() == null) {
        throw new AndroidRuntimeException(""Animators may only be run on Looper threads"");
    }
    if (isStarted()) {
        ArrayList<AnimatorListener> tmpListeners = null;
        if (mListeners != null) {
            tmpListeners = (ArrayList<AnimatorListener>) mListeners.clone();
            int size = tmpListeners.size();
            for (int i = 0; i < size; i++) {
                tmpListeners.get(i).onAnimationCancel(this);
            }
        }
        ArrayList<Node> playingSet = new ArrayList<>(mPlayingSet);
        int setSize = playingSet.size();
        for (int i = 0; i < setSize; i++) {
            playingSet.get(i).mAnimation.cancel();
        }
        mPlayingSet.clear();
        endAnimation();
    }
}",1,"/**
 * {@inheritDoc}
 *
 * <p>Note that canceling a <code>AnimatorSet</code> also cancels all of the animations that it
 * is responsible for.</p>
 */
","/**
 * {@inheritDoc}
 *
 * <p>Note that canceling a <code>AnimatorSet</code> also cancels all of the animations that it
 * is responsible for.</p>
 */
",-1,"[@SuppressWarnings(""unchecked""), @Override]","[@SuppressWarnings(""unchecked""), @Override]",-1,-1,-1,-1,-1,-1,"2,3,4","1,2",Code changes include:,- There are other changes in statements such as replacing `ArrayList<Animator>` with `ArrayList<Node>` and calling `mAnimation.cancel()` on the Node objects instead of directly canceling Animator objects.
795,<android.app.ActivityThread.Profiler: void startProfiling()>,25,26,<android.app.ActivityThread.Profiler: void startProfiling()>,<android.app.ActivityThread.Profiler: void startProfiling()>,0,"{
    if (profileFd == null || profiling) {
        return;
    }
    try {
        int bufferSize = SystemProperties.getInt(""debug.traceview-buffer-size-mb"", 8);
        VMDebug.startMethodTracing(profileFile, profileFd.getFileDescriptor(), bufferSize * 1024 * 1024, 0, samplingInterval != 0, samplingInterval);
        profiling = true;
    } catch (RuntimeException e) {
        Slog.w(TAG, ""Profiling failed on path "" + profileFile);
        try {
            profileFd.close();
            profileFd = null;
        } catch (IOException e2) {
            Slog.w(TAG, ""Failure closing profile fd"", e2);
        }
    }
}","{
    if (profileFd == null || profiling) {
        return;
    }
    try {
        int bufferSize = SystemProperties.getInt(""debug.traceview-buffer-size-mb"", 8);
        VMDebug.startMethodTracing(profileFile, profileFd.getFileDescriptor(), bufferSize * 1024 * 1024, 0, samplingInterval != 0, samplingInterval, streamingOutput);
        profiling = true;
    } catch (RuntimeException e) {
        Slog.w(TAG, ""Profiling failed on path "" + profileFile);
        try {
            profileFd.close();
            profileFd = null;
        } catch (IOException e2) {
            Slog.w(TAG, ""Failure closing profile fd"", e2);
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The only change is the addition of `streamingOutput` as a parameter to the method `VMDebug.startMethodTracing()` which makes it a dependent API change, type 5. There is also a related change in the method call, which is not a control-flow or exception handling change, but an ""Other statement change,"" type 4.","There are no changes to the return statements or exception handling that would cause different behavior, so there are no compatibility issues related to return values/types or exception handling. However, there could be behavior differences not captured by those CI categories due to the change in method behavior with the added `streamingOutput` parameter. But since there isn't any specific criteria given for that scenario, the CI type is 0 based on the definitions provided."
796,<android.bluetooth.BluetoothSocket: int bindListen()>,25,26,<android.bluetooth.BluetoothSocket: int bindListen()>,<android.bluetooth.BluetoothSocket: int bindListen()>,0,"{
    int ret;
    if (mSocketState == SocketState.CLOSED)
        return EBADFD;
    IBluetooth bluetoothProxy = BluetoothAdapter.getDefaultAdapter().getBluetoothService(null);
    if (bluetoothProxy == null) {
        Log.e(TAG, ""bindListen fail, reason: bluetooth is off"");
        return -1;
    }
    try {
        mPfd = bluetoothProxy.createSocketChannel(mType, mServiceName, mUuid, mPort, getSecurityFlags());
    } catch (RemoteException e) {
        Log.e(TAG, Log.getStackTraceString(new Throwable()));
        return -1;
    }
    // read out port number
    try {
        synchronized (this) {
            if (DBG)
                Log.d(TAG, ""bindListen(), SocketState: "" + mSocketState + "", mPfd: "" + mPfd);
            if (mSocketState != SocketState.INIT)
                return EBADFD;
            if (mPfd == null)
                return -1;
            FileDescriptor fd = mPfd.getFileDescriptor();
            if (DBG)
                Log.d(TAG, ""bindListen(), new LocalSocket "");
            mSocket = new LocalSocket(fd);
            if (DBG)
                Log.d(TAG, ""bindListen(), new LocalSocket.getInputStream() "");
            mSocketIS = mSocket.getInputStream();
            mSocketOS = mSocket.getOutputStream();
        }
        if (DBG)
            Log.d(TAG, ""bindListen(), readInt mSocketIS: "" + mSocketIS);
        int channel = readInt(mSocketIS);
        synchronized (this) {
            if (mSocketState == SocketState.INIT)
                mSocketState = SocketState.LISTENING;
        }
        if (DBG)
            Log.d(TAG, ""channel: "" + channel);
        if (mPort <= -1) {
            mPort = channel;
        }
        // else ASSERT(mPort == channel)
        ret = 0;
    } catch (IOException e) {
        if (mPfd != null) {
            try {
                mPfd.close();
            } catch (IOException e1) {
                Log.e(TAG, ""bindListen, close mPfd: "" + e1);
            }
            mPfd = null;
        }
        Log.e(TAG, ""bindListen, fail to get port number, exception: "" + e);
        return -1;
    }
    return ret;
}","{
    int ret;
    if (mSocketState == SocketState.CLOSED)
        return EBADFD;
    IBluetooth bluetoothProxy = BluetoothAdapter.getDefaultAdapter().getBluetoothService(null);
    if (bluetoothProxy == null) {
        Log.e(TAG, ""bindListen fail, reason: bluetooth is off"");
        return -1;
    }
    try {
        mPfd = bluetoothProxy.createSocketChannel(mType, mServiceName, mUuid, mPort, getSecurityFlags());
    } catch (RemoteException e) {
        Log.e(TAG, Log.getStackTraceString(new Throwable()));
        return -1;
    }
    // read out port number
    try {
        synchronized (this) {
            if (DBG)
                Log.d(TAG, ""bindListen(), SocketState: "" + mSocketState + "", mPfd: "" + mPfd);
            if (mSocketState != SocketState.INIT)
                return EBADFD;
            if (mPfd == null)
                return -1;
            FileDescriptor fd = mPfd.getFileDescriptor();
            if (fd == null) {
                Log.e(TAG, ""bindListen(), null file descriptor"");
                return -1;
            }
            if (DBG)
                Log.d(TAG, ""bindListen(), Create LocalSocket"");
            mSocket = LocalSocket.createConnectedLocalSocket(fd);
            if (DBG)
                Log.d(TAG, ""bindListen(), new LocalSocket.getInputStream()"");
            mSocketIS = mSocket.getInputStream();
            mSocketOS = mSocket.getOutputStream();
        }
        if (DBG)
            Log.d(TAG, ""bindListen(), readInt mSocketIS: "" + mSocketIS);
        int channel = readInt(mSocketIS);
        synchronized (this) {
            if (mSocketState == SocketState.INIT)
                mSocketState = SocketState.LISTENING;
        }
        if (DBG)
            Log.d(TAG, ""channel: "" + channel);
        if (mPort <= -1) {
            mPort = channel;
        }
        // else ASSERT(mPort == channel)
        ret = 0;
    } catch (IOException e) {
        if (mPfd != null) {
            try {
                mPfd.close();
            } catch (IOException e1) {
                Log.e(TAG, ""bindListen, close mPfd: "" + e1);
            }
            mPfd = null;
        }
        Log.e(TAG, ""bindListen, fail to get port number, exception: "" + e);
        return -1;
    }
    return ret;
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,,,,
797,<android.content.IntentSender: UserHandle getCreatorUserHandle()>,25,26,<android.content.IntentSender: UserHandle getCreatorUserHandle()>,<android.content.IntentSender: UserHandle getCreatorUserHandle()>,0,"{
    try {
        int uid = ActivityManagerNative.getDefault().getUidForIntentSender(mTarget);
        return uid > 0 ? new UserHandle(UserHandle.getUserId(uid)) : null;
    } catch (RemoteException e) {
        // Should never happen.
        return null;
    }
}","{
    try {
        int uid = ActivityManager.getService().getUidForIntentSender(mTarget);
        return uid > 0 ? new UserHandle(UserHandle.getUserId(uid)) : null;
    } catch (RemoteException e) {
        // Should never happen.
        return null;
    }
}",1,"/**
 * Return the user handle of the application that created this
 * PendingIntent, that is the user under which you will actually be
 * sending the Intent.  The returned UserHandle is supplied by the system, so
 * that an application can not spoof its user.  See
 * {@link android.os.Process#myUserHandle() Process.myUserHandle()} for
 * more explanation of user handles.
 *
 * @return The user handle of the PendingIntent, or null if there is
 * none associated with it.
 */
","/**
 * Return the user handle of the application that created this
 * PendingIntent, that is the user under which you will actually be
 * sending the Intent.  The returned UserHandle is supplied by the system, so
 * that an application can not spoof its user.  See
 * {@link android.os.Process#myUserHandle() Process.myUserHandle()} for
 * more explanation of user handles.
 *
 * @return The user handle of the PendingIntent, or null if there is
 * none associated with it.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The code has changed from ActivityManagerNative.getDefault().getUidForIntentSender(mTarget) to ActivityManager.getService().getUidForIntentSender(mTarget). Therefore, the dependent API has changed and the code change type is 5.","Although there is a change in the method used to retrieve the UID, the behavior and the contract of the method getUidForIntentSender appear to remain the same. Both versions catch RemoteException and return null if this exception occurs. Since there is no indication that the new method changes the way UIDs are returned or the circumstances under which exceptions are thrown or catch blocks are entered, there should be no compatibility issue. The return values should be consistent between versions when the same input is provided, and exception handling has not changed. Hence, the CI type is 0."
798,<android.bluetooth.BluetoothAdapter: boolean enable()>,25,26,<android.bluetooth.BluetoothAdapter: boolean enable()>,<android.bluetooth.BluetoothAdapter: boolean enable()>,0,"{
    if (isEnabled() == true) {
        if (DBG)
            Log.d(TAG, ""enable(): BT is already enabled..!"");
        return true;
    }
    try {
        return mManagerService.enable();
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}","{
    if (isEnabled()) {
        if (DBG)
            Log.d(TAG, ""enable(): BT already enabled!"");
        return true;
    }
    try {
        return mManagerService.enable(ActivityThread.currentPackageName());
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}",1,"/**
 * Turn on the local Bluetooth adapter&mdash;do not use without explicit
 * user action to turn on Bluetooth.
 * <p>This powers on the underlying Bluetooth hardware, and starts all
 * Bluetooth system services.
 * <p class=""caution""><strong>Bluetooth should never be enabled without
 * direct user consent</strong>. If you want to turn on Bluetooth in order
 * to create a wireless connection, you should use the {@link
 * #ACTION_REQUEST_ENABLE} Intent, which will raise a dialog that requests
 * user permission to turn on Bluetooth. The {@link #enable()} method is
 * provided only for applications that include a user interface for changing
 * system settings, such as a ""power manager"" app.</p>
 * <p>This is an asynchronous call: it will return immediately, and
 * clients should listen for {@link #ACTION_STATE_CHANGED}
 * to be notified of subsequent adapter state changes. If this call returns
 * true, then the adapter state will immediately transition from {@link
 * #STATE_OFF} to {@link #STATE_TURNING_ON}, and some time
 * later transition to either {@link #STATE_OFF} or {@link
 * #STATE_ON}. If this call returns false then there was an
 * immediate problem that will prevent the adapter from being turned on -
 * such as Airplane mode, or the adapter is already turned on.
 * <p>Requires the {@link android.Manifest.permission#BLUETOOTH_ADMIN}
 * permission
 *
 * @return true to indicate adapter startup has begun, or false on
 * immediate error
 */
","/**
 * Turn on the local Bluetooth adapter&mdash;do not use without explicit
 * user action to turn on Bluetooth.
 * <p>This powers on the underlying Bluetooth hardware, and starts all
 * Bluetooth system services.
 * <p class=""caution""><strong>Bluetooth should never be enabled without
 * direct user consent</strong>. If you want to turn on Bluetooth in order
 * to create a wireless connection, you should use the {@link
 * #ACTION_REQUEST_ENABLE} Intent, which will raise a dialog that requests
 * user permission to turn on Bluetooth. The {@link #enable()} method is
 * provided only for applications that include a user interface for changing
 * system settings, such as a ""power manager"" app.</p>
 * <p>This is an asynchronous call: it will return immediately, and
 * clients should listen for {@link #ACTION_STATE_CHANGED}
 * to be notified of subsequent adapter state changes. If this call returns
 * true, then the adapter state will immediately transition from {@link
 * #STATE_OFF} to {@link #STATE_TURNING_ON}, and some time
 * later transition to either {@link #STATE_OFF} or {@link
 * #STATE_ON}. If this call returns false then there was an
 * immediate problem that will prevent the adapter from being turned on -
 * such as Airplane mode, or the adapter is already turned on.
 *
 * @return true to indicate adapter startup has begun, or false on
 * immediate error
 */
",-1,[@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)],[@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)],-1,-1,-1,-1,-1,-1,"1,5",1,"The change involves passing a new parameter to the method 'mManagerService.enable()' which now includes 'ActivityThread.currentPackageName()' in the late version. This represents a change in a dependent API, so the code change type is 5. Also, the return statement has potentially changed because the enable() function is now invoked with a parameter which may affect its behavior, making the change type 1 as well.","Since the method 'mManagerService.enable()' is now called with an additional argument, the method's behavior could potentially be different, leading to different return values. Therefore, the CI type is 1."
799,"<android.content.pm.LauncherApps: boolean isActivityEnabled(ComponentName,UserHandle)>",25,26,"<android.content.pm.LauncherApps: boolean isActivityEnabled(ComponentName,UserHandle)>","<android.content.pm.LauncherApps: boolean isActivityEnabled(ComponentName,UserHandle)>",0,"{
    try {
        return mService.isActivityEnabled(component, user);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}","{
    logErrorForInvalidProfileAccess(user);
    try {
        return mService.isActivityEnabled(mContext.getPackageName(), component, user);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}",1,"/**
 * Checks if the activity exists and it enabled for a profile.
 *
 * @param component The activity to check.
 * @param user The UserHandle of the profile.
 *
 * @return true if the activity exists and is enabled.
 */
","/**
 * Checks if the activity exists and it enabled for a profile.
 *
 * @param component The activity to check.
 * @param user The UserHandle of the profile.
 *
 * @return true if the activity exists and is enabled.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The method implementation added a non-exception throwing statement (logErrorForInvalidProfileAccess(user);) and altered the dependent API call from mService.isActivityEnabled(component, user) to mService.isActivityEnabled(mContext.getPackageName(), component, user) by including an additional parameter mContext.getPackageName(), which alters the behavior of the dependent API. The change is thus classified under Other statement changed (4) and Dependent API changed (5).","Because the dependent API's behavior has changed due to the inclusion of an additional argument, which potentially affects the condition to be checked for the activity's enablement, it might result in a different return value, marking this as a Compatibility Issue of type 1."
800,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo obtain()>,25,26,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo obtain()>,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo obtain()>,0,"{
    AccessibilityNodeInfo info = sPool.acquire();
    return (info != null) ? info : new AccessibilityNodeInfo();
}","{
    AccessibilityNodeInfo info = sPool.acquire();
    if (sNumInstancesInUse != null) {
        sNumInstancesInUse.incrementAndGet();
    }
    return (info != null) ? info : new AccessibilityNodeInfo();
}",1,"/**
 * Returns a cached instance if such is available otherwise a new one.
 *
 * @return An instance.
 */
","/**
 * Returns a cached instance if such is available otherwise a new one.
 *
 * @return An instance.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"An if-statement that increments `sNumInstancesInUse` has been added, but this does not affect the return statement's result; therefore, the code change type is 4.","Though an additional action is performed regarding the `sNumInstancesInUse`, the returned value from the method, `AccessibilityNodeInfo`, is not affected by this change. Hence, there is no Compatibility Issue, so the CI type is 0."
801,<android.app.ContextImpl: Context createDisplayContext(Display)>,25,26,<android.app.ContextImpl: Context createDisplayContext(Display)>,<android.app.ContextImpl: Context createDisplayContext(Display)>,0,"{
    if (display == null) {
        throw new IllegalArgumentException(""display must not be null"");
    }
    return new ContextImpl(this, mMainThread, mPackageInfo, mActivityToken, mUser, mFlags, display, null, Display.INVALID_DISPLAY);
}","{
    if (display == null) {
        throw new IllegalArgumentException(""display must not be null"");
    }
    ContextImpl context = new ContextImpl(this, mMainThread, mPackageInfo, mSplitName, mActivityToken, mUser, mFlags, mClassLoader);
    final int displayId = display.getDisplayId();
    context.setResources(createResources(mActivityToken, mPackageInfo, mSplitName, displayId, null, getDisplayAdjustments(displayId).getCompatibilityInfo()));
    context.mDisplay = display;
    return context;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4,5",1,"The method's return statement has been modified to incorporate additional steps, including setting the resources and display for the newly created ContextImpl object. Additionally, the constructor of ContextImpl has been changed to include different parameters, indicating a change in the dependent API, as well as other changes that are not related to control flow or exception handling. So the code change type is 1,4,5.","The late implementation of the method could lead to a different ContextImpl object being returned because the method now sets resources and display for the context and uses a different constructor for ContextImpl. Therefore, there is a compatibility issue due to potentially returning a different instance with different state, making the CI type 1."
802,<android.content.res.Configuration: int compareTo(Configuration)>,25,26,<android.content.res.Configuration: int compareTo(Configuration)>,<android.content.res.Configuration: int compareTo(Configuration)>,0,"{
    int n;
    float a = this.fontScale;
    float b = that.fontScale;
    if (a < b)
        return -1;
    if (a > b)
        return 1;
    n = this.mcc - that.mcc;
    if (n != 0)
        return n;
    n = this.mnc - that.mnc;
    if (n != 0)
        return n;
    fixUpLocaleList();
    that.fixUpLocaleList();
    // than any non-empty locale list.
    if (this.mLocaleList.isEmpty()) {
        if (!that.mLocaleList.isEmpty())
            return 1;
    } else if (that.mLocaleList.isEmpty()) {
        return -1;
    } else {
        final int minSize = Math.min(this.mLocaleList.size(), that.mLocaleList.size());
        for (int i = 0; i < minSize; ++i) {
            final Locale thisLocale = this.mLocaleList.get(i);
            final Locale thatLocale = that.mLocaleList.get(i);
            n = thisLocale.getLanguage().compareTo(thatLocale.getLanguage());
            if (n != 0)
                return n;
            n = thisLocale.getCountry().compareTo(thatLocale.getCountry());
            if (n != 0)
                return n;
            n = thisLocale.getVariant().compareTo(thatLocale.getVariant());
            if (n != 0)
                return n;
            n = thisLocale.toLanguageTag().compareTo(thatLocale.toLanguageTag());
            if (n != 0)
                return n;
        }
        n = this.mLocaleList.size() - that.mLocaleList.size();
        if (n != 0)
            return n;
    }
    n = this.touchscreen - that.touchscreen;
    if (n != 0)
        return n;
    n = this.keyboard - that.keyboard;
    if (n != 0)
        return n;
    n = this.keyboardHidden - that.keyboardHidden;
    if (n != 0)
        return n;
    n = this.hardKeyboardHidden - that.hardKeyboardHidden;
    if (n != 0)
        return n;
    n = this.navigation - that.navigation;
    if (n != 0)
        return n;
    n = this.navigationHidden - that.navigationHidden;
    if (n != 0)
        return n;
    n = this.orientation - that.orientation;
    if (n != 0)
        return n;
    n = this.screenLayout - that.screenLayout;
    if (n != 0)
        return n;
    n = this.uiMode - that.uiMode;
    if (n != 0)
        return n;
    n = this.screenWidthDp - that.screenWidthDp;
    if (n != 0)
        return n;
    n = this.screenHeightDp - that.screenHeightDp;
    if (n != 0)
        return n;
    n = this.smallestScreenWidthDp - that.smallestScreenWidthDp;
    if (n != 0)
        return n;
    n = this.densityDpi - that.densityDpi;
    // if (n != 0) return n;
    return n;
}","{
    int n;
    float a = this.fontScale;
    float b = that.fontScale;
    if (a < b)
        return -1;
    if (a > b)
        return 1;
    n = this.mcc - that.mcc;
    if (n != 0)
        return n;
    n = this.mnc - that.mnc;
    if (n != 0)
        return n;
    fixUpLocaleList();
    that.fixUpLocaleList();
    // than any non-empty locale list.
    if (this.mLocaleList.isEmpty()) {
        if (!that.mLocaleList.isEmpty())
            return 1;
    } else if (that.mLocaleList.isEmpty()) {
        return -1;
    } else {
        final int minSize = Math.min(this.mLocaleList.size(), that.mLocaleList.size());
        for (int i = 0; i < minSize; ++i) {
            final Locale thisLocale = this.mLocaleList.get(i);
            final Locale thatLocale = that.mLocaleList.get(i);
            n = thisLocale.getLanguage().compareTo(thatLocale.getLanguage());
            if (n != 0)
                return n;
            n = thisLocale.getCountry().compareTo(thatLocale.getCountry());
            if (n != 0)
                return n;
            n = thisLocale.getVariant().compareTo(thatLocale.getVariant());
            if (n != 0)
                return n;
            n = thisLocale.toLanguageTag().compareTo(thatLocale.toLanguageTag());
            if (n != 0)
                return n;
        }
        n = this.mLocaleList.size() - that.mLocaleList.size();
        if (n != 0)
            return n;
    }
    n = this.touchscreen - that.touchscreen;
    if (n != 0)
        return n;
    n = this.keyboard - that.keyboard;
    if (n != 0)
        return n;
    n = this.keyboardHidden - that.keyboardHidden;
    if (n != 0)
        return n;
    n = this.hardKeyboardHidden - that.hardKeyboardHidden;
    if (n != 0)
        return n;
    n = this.navigation - that.navigation;
    if (n != 0)
        return n;
    n = this.navigationHidden - that.navigationHidden;
    if (n != 0)
        return n;
    n = this.orientation - that.orientation;
    if (n != 0)
        return n;
    n = this.colorMode - that.colorMode;
    if (n != 0)
        return n;
    n = this.screenLayout - that.screenLayout;
    if (n != 0)
        return n;
    n = this.uiMode - that.uiMode;
    if (n != 0)
        return n;
    n = this.screenWidthDp - that.screenWidthDp;
    if (n != 0)
        return n;
    n = this.screenHeightDp - that.screenHeightDp;
    if (n != 0)
        return n;
    n = this.smallestScreenWidthDp - that.smallestScreenWidthDp;
    if (n != 0)
        return n;
    n = this.densityDpi - that.densityDpi;
    if (n != 0)
        return n;
    n = this.assetsSeq - that.assetsSeq;
    // if (n != 0) return n;
    return n;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
803,<android.view.accessibility.AccessibilityWindowInfo: AccessibilityWindowInfo obtain()>,25,26,<android.view.accessibility.AccessibilityWindowInfo: AccessibilityWindowInfo obtain()>,<android.view.accessibility.AccessibilityWindowInfo: AccessibilityWindowInfo obtain()>,0,"{
    AccessibilityWindowInfo info = sPool.acquire();
    if (info == null) {
        info = new AccessibilityWindowInfo();
    }
    return info;
}","{
    AccessibilityWindowInfo info = sPool.acquire();
    if (info == null) {
        info = new AccessibilityWindowInfo();
    }
    if (sNumInstancesInUse != null) {
        sNumInstancesInUse.incrementAndGet();
    }
    return info;
}",1,"/**
 * Returns a cached instance if such is available or a new one is
 * created.
 *
 * @return An instance.
 */
","/**
 * Returns a cached instance if such is available or a new one is
 * created.
 *
 * @return An instance.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,A new control statement (if check) and an increment operation on sNumInstancesInUse are added. These changes are of types 3 (Control dependency change) and 4 (Other statement change).,"The added condition and increment statement do not affect the return value of the method since they occur after the value of 'info' is set and do not change the assignment process. They only manage an external variable sNumInstancesInUse, and this does not change the return value of the function 'obtain()', so there is no Compatibility Issue here."
804,"<android.app.ContextImpl: void removeStickyBroadcastAsUser(Intent,UserHandle)>",25,26,"<android.app.ContextImpl: void removeStickyBroadcastAsUser(Intent,UserHandle)>","<android.app.ContextImpl: void removeStickyBroadcastAsUser(Intent,UserHandle)>",0,"{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    if (resolvedType != null) {
        intent = new Intent(intent);
        intent.setDataAndType(intent.getData(), resolvedType);
    }
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManagerNative.getDefault().unbroadcastIntent(mMainThread.getApplicationThread(), intent, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    if (resolvedType != null) {
        intent = new Intent(intent);
        intent.setDataAndType(intent.getData(), resolvedType);
    }
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().unbroadcastIntent(mMainThread.getApplicationThread(), intent, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,"[@Override, @Deprecated]","[@Override, @Deprecated]",-1,-1,-1,-1,-1,-1,5,0,"The method used to un-broadcast the intent has changed from ActivityManagerNative.getDefault().unbroadcastIntent(...) to ActivityManager.getService().unbroadcastIntent(...), which indicates that the dependent API has changed. Therefore, the code change type is 5.","Since there is no change in the signature, return type, or exception handling, and assuming that the new `ActivityManager.getService()` maintains the same behavior as `ActivityManagerNative.getDefault()`, no Compatibility Issue is introduced. The CI type is 0."
805,<android.bluetooth.le.BluetoothLeScanner.BleScanCallbackWrapper: void onScanManagerErrorCallback(int)>,25,26,<android.bluetooth.le.BluetoothLeScanner.BleScanCallbackWrapper: void onScanManagerErrorCallback(int)>,<android.bluetooth.le.BluetoothLeScanner.BleScanCallbackWrapper: void onScanManagerErrorCallback(int)>,0,"{
    if (VDBG) {
        Log.d(TAG, ""onScanManagerErrorCallback() - errorCode = "" + errorCode);
    }
    synchronized (this) {
        if (mClientIf <= 0)
            return;
    }
    postCallbackError(mScanCallback, errorCode);
}","{
    if (VDBG) {
        Log.d(TAG, ""onScanManagerErrorCallback() - errorCode = "" + errorCode);
    }
    synchronized (this) {
        if (mScannerId <= 0)
            return;
    }
    postCallbackError(mScanCallback, errorCode);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The only change is the variable checked in the if statement after synchronized block, which was changed from `mClientIf` to `mScannerId`. This is classified as ""Other statement changed,"" so the type is 4.","The change from `mClientIf` to `mScannerId` is an internal change and does not affect the API's external behavior. The method signature and its logic to return or post an error callback based on a condition remain the same, and it is an internal check with no impact on what the API ultimately does from an external point of view. Therefore, there is no Compatibility Issue, so the CI type is 0."
806,"<android.content.res.AssetManager: boolean getResourceValue(int,int,TypedValue,boolean)>",25,26,"<android.content.res.AssetManager: boolean getResourceValue(int,int,TypedValue,boolean)>","<android.content.res.AssetManager: boolean getResourceValue(int,int,TypedValue,boolean)>",0,"{
    final int block = loadResourceValue(resId, (short) densityDpi, outValue, resolveRefs);
    if (block < 0) {
        return false;
    }
    if (outValue.type == TypedValue.TYPE_STRING) {
        outValue.string = mStringBlocks[block].get(outValue.data);
    }
    return true;
}","{
    synchronized (this) {
        final int block = loadResourceValue(resId, (short) densityDpi, outValue, resolveRefs);
        if (block < 0) {
            return false;
        }
        // Convert the changing configurations flags populated by native code.
        outValue.changingConfigurations = ActivityInfo.activityInfoConfigNativeToJava(outValue.changingConfigurations);
        if (outValue.type == TypedValue.TYPE_STRING) {
            outValue.string = mStringBlocks[block].get(outValue.data);
        }
        return true;
    }
}",1,"/**
 * Populates {@code outValue} with the data associated a particular
 * resource identifier for the current configuration.
 *
 * @param resId the resource identifier to load
 * @param densityDpi the density bucket for which to load the resource
 * @param outValue the typed value in which to put the data
 * @param resolveRefs {@code true} to resolve references, {@code false}
 * to leave them unresolved
 * @return {@code true} if the data was loaded into {@code outValue},
 * {@code false} otherwise
 */
","/**
 * Populates {@code outValue} with the data associated a particular
 * resource identifier for the current configuration.
 *
 * @param resId the resource identifier to load
 * @param densityDpi the density bucket for which to load the resource
 * @param outValue the typed value in which to put the data
 * @param resolveRefs {@code true} to resolve references, {@code false}
 * to leave them unresolved
 * @return {@code true} if the data was loaded into {@code outValue},
 * {@code false} otherwise
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"There is an addition of a synchronized block and a new operation on outValue.changingConfigurations, which are classified under types 3 (control dependency change) and 4 (other statement changed).","There is no compatibility issue here because the added synchronized block doesn't change the method's behavior regarding its input-output contract. It simply adds thread safety. Similarly, the changingConfigurations being modified doesn't alter the API's contract; it likely just updates additional information in 'outValue', which is already expected to be modified by the method. Therefore, the public behavior of the API remains consistent, and there is no CI."
807,<android.app.ContextImpl: File getCacheDir()>,25,26,<android.app.ContextImpl: File getCacheDir()>,<android.app.ContextImpl: File getCacheDir()>,0,"{
    synchronized (mSync) {
        if (mCacheDir == null) {
            mCacheDir = new File(getDataDir(), ""cache"");
        }
        return ensurePrivateDirExists(mCacheDir);
    }
}","{
    synchronized (mSync) {
        if (mCacheDir == null) {
            mCacheDir = new File(getDataDir(), ""cache"");
        }
        return ensurePrivateCacheDirExists(mCacheDir, XATTR_INODE_CACHE);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The method called in the return statement changed from ensurePrivateDirExists(mCacheDir) to ensurePrivateCacheDirExists(mCacheDir, XATTR_INODE_CACHE) which means the method signature has changed since it includes an additional parameter, so the code change includes 1 (Return statement changed) and 5 (Dependent API changed).","Since the method ensurePrivateCacheDirExists appears to be a different method due to the additional parameter (XATTR_INODE_CACHE), which could potentially change the behavior of ensurePrivateCacheDirExists compared to ensurePrivateDirExists, this could lead to a different return value (file reference). Thus, the CI is of type 1."
808,<android.app.Activity: boolean shouldUpRecreateTask(Intent)>,25,26,<android.app.Activity: boolean shouldUpRecreateTask(Intent)>,<android.app.Activity: boolean shouldUpRecreateTask(Intent)>,0,"{
    try {
        PackageManager pm = getPackageManager();
        ComponentName cn = targetIntent.getComponent();
        if (cn == null) {
            cn = targetIntent.resolveActivity(pm);
        }
        ActivityInfo info = pm.getActivityInfo(cn, 0);
        if (info.taskAffinity == null) {
            return false;
        }
        return ActivityManagerNative.getDefault().shouldUpRecreateTask(mToken, info.taskAffinity);
    } catch (RemoteException e) {
        return false;
    } catch (NameNotFoundException e) {
        return false;
    }
}","{
    try {
        PackageManager pm = getPackageManager();
        ComponentName cn = targetIntent.getComponent();
        if (cn == null) {
            cn = targetIntent.resolveActivity(pm);
        }
        ActivityInfo info = pm.getActivityInfo(cn, 0);
        if (info.taskAffinity == null) {
            return false;
        }
        return ActivityManager.getService().shouldUpRecreateTask(mToken, info.taskAffinity);
    } catch (RemoteException e) {
        return false;
    } catch (NameNotFoundException e) {
        return false;
    }
}",1,"/**
 * Returns true if the app should recreate the task when navigating 'up' from this activity
 * by using targetIntent.
 *
 * <p>If this method returns false the app can trivially call
 * {@link #navigateUpTo(Intent)} using the same parameters to correctly perform
 * up navigation. If this method returns false, the app should synthesize a new task stack
 * by using {@link TaskStackBuilder} or another similar mechanism to perform up navigation.</p>
 *
 * @param targetIntent An intent representing the target destination for up navigation
 * @return true if navigating up should recreate a new task stack, false if the same task
 * should be used for the destination
 */
","/**
 * Returns true if the app should recreate the task when navigating 'up' from this activity
 * by using targetIntent.
 *
 * <p>If this method returns false the app can trivially call
 * {@link #navigateUpTo(Intent)} using the same parameters to correctly perform
 * up navigation. If this method returns false, the app should synthesize a new task stack
 * by using {@link TaskStackBuilder} or another similar mechanism to perform up navigation.</p>
 *
 * @param targetIntent An intent representing the target destination for up navigation
 * @return true if navigating up should recreate a new task stack, false if the same task
 * should be used for the destination
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent API call within the try block changed from ActivityManagerNative.getDefault().shouldUpRecreateTask(...) to ActivityManager.getService().shouldUpRecreateTask(...). There are no other code changes, so the change type is 5.","Although the internal API invoked has changed, the behaviour of the method shouldUpRecreateTask is not inherently changed because it is reasonably expected that the new API provides the same functionality; there's also no change in exception handling or return values. Therefore, this change should not cause the method to behave differently from an external point of view, and thus there is no Compatibility Issue, which corresponds to 0."
810,<android.view.View: void setForeground(Drawable)>,25,26,<android.view.View: void setForeground(Drawable)>,<android.view.View: void setForeground(Drawable)>,0,"{
    if (mForegroundInfo == null) {
        if (foreground == null) {
            // Nothing to do.
            return;
        }
        mForegroundInfo = new ForegroundInfo();
    }
    if (foreground == mForegroundInfo.mDrawable) {
        // Nothing to do
        return;
    }
    if (mForegroundInfo.mDrawable != null) {
        if (isAttachedToWindow()) {
            mForegroundInfo.mDrawable.setVisible(false, false);
        }
        mForegroundInfo.mDrawable.setCallback(null);
        unscheduleDrawable(mForegroundInfo.mDrawable);
    }
    mForegroundInfo.mDrawable = foreground;
    mForegroundInfo.mBoundsChanged = true;
    if (foreground != null) {
        if ((mPrivateFlags & PFLAG_SKIP_DRAW) != 0) {
            mPrivateFlags &= ~PFLAG_SKIP_DRAW;
        }
        foreground.setLayoutDirection(getLayoutDirection());
        if (foreground.isStateful()) {
            foreground.setState(getDrawableState());
        }
        applyForegroundTint();
        if (isAttachedToWindow()) {
            foreground.setVisible(getWindowVisibility() == VISIBLE && isShown(), false);
        }
        // Set callback last, since the view may still be initializing.
        foreground.setCallback(this);
    } else if ((mViewFlags & WILL_NOT_DRAW) != 0 && mBackground == null) {
        mPrivateFlags |= PFLAG_SKIP_DRAW;
    }
    requestLayout();
    invalidate();
}","{
    if (mForegroundInfo == null) {
        if (foreground == null) {
            // Nothing to do.
            return;
        }
        mForegroundInfo = new ForegroundInfo();
    }
    if (foreground == mForegroundInfo.mDrawable) {
        // Nothing to do
        return;
    }
    if (mForegroundInfo.mDrawable != null) {
        if (isAttachedToWindow()) {
            mForegroundInfo.mDrawable.setVisible(false, false);
        }
        mForegroundInfo.mDrawable.setCallback(null);
        unscheduleDrawable(mForegroundInfo.mDrawable);
    }
    mForegroundInfo.mDrawable = foreground;
    mForegroundInfo.mBoundsChanged = true;
    if (foreground != null) {
        if ((mPrivateFlags & PFLAG_SKIP_DRAW) != 0) {
            mPrivateFlags &= ~PFLAG_SKIP_DRAW;
        }
        foreground.setLayoutDirection(getLayoutDirection());
        if (foreground.isStateful()) {
            foreground.setState(getDrawableState());
        }
        applyForegroundTint();
        if (isAttachedToWindow()) {
            foreground.setVisible(getWindowVisibility() == VISIBLE && isShown(), false);
        }
        // Set callback last, since the view may still be initializing.
        foreground.setCallback(this);
    } else if ((mViewFlags & WILL_NOT_DRAW) != 0 && mBackground == null && (mDefaultFocusHighlight == null)) {
        mPrivateFlags |= PFLAG_SKIP_DRAW;
    }
    requestLayout();
    invalidate();
}",1,"/**
 * Supply a Drawable that is to be rendered on top of all of the content in the view.
 *
 * @param foreground the Drawable to be drawn on top of the children
 *
 * @attr ref android.R.styleable#View_foreground
 */
","/**
 * Supply a Drawable that is to be rendered on top of all of the content in the view.
 *
 * @param foreground the Drawable to be drawn on top of the children
 *
 * @attr ref android.R.styleable#View_foreground
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The code introduces an additional condition in an 'if' statement that checks if ""mDefaultFocusHighlight"" is null. As a result, the change types are 3 (Control dependency changed) and 4 (Other statement changed).","The new condition can potentially alter the flow of the method, particularly whether the ""mPrivateFlags |= PFLAG_SKIP_DRAW"" statement is executed or not. Therefore, the API could return a different state of the ""mPrivateFlags"" variable, leading to a CI type of 1 (Compatibility Issue caused by potential different return values or types)."
812,<android.app.PendingIntent: IntentSender getIntentSender()>,25,26,<android.app.PendingIntent: IntentSender getIntentSender()>,<android.app.PendingIntent: IntentSender getIntentSender()>,0,"{
    return new IntentSender(mTarget);
}","{
    return new IntentSender(mTarget, mWhitelistToken);
}",1,"/**
 * Retrieve a IntentSender object that wraps the existing sender of the PendingIntent
 *
 * @return Returns a IntentSender object that wraps the sender of PendingIntent
 */
","/**
 * Retrieve a IntentSender object that wraps the existing sender of the PendingIntent
 *
 * @return Returns a IntentSender object that wraps the sender of PendingIntent
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The constructor for IntentSender has changed from new IntentSender(mTarget) to new IntentSender(mTarget, mWhitelistToken), which indicates that a new parameter is introduced, so the code change type is 1,5.","Since the constructor call for IntentSender has introduced an additional parameter, the behavior of the method has changed as it might now be returning a differently constructed IntentSender object. Therefore, the potential CI is due to a different return value, and the CI type is 1."
813,<android.util.MapCollections.ArrayIterator: T next()>,25,26,<android.util.MapCollections.ArrayIterator: T next()>,<android.util.MapCollections.ArrayIterator: T next()>,0,"{
    Object res = colGetEntry(mIndex, mOffset);
    mIndex++;
    mCanRemove = true;
    return (T) res;
}","{
    if (!hasNext())
        throw new NoSuchElementException();
    Object res = colGetEntry(mIndex, mOffset);
    mIndex++;
    mCanRemove = true;
    return (T) res;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,3",2,"An exception handling statement `if (!hasNext()) throw new NoSuchElementException();` has been added in the late version, this is a change of type 2. Additionally, the change affects the control flow of the method, which makes it also a change of type 3.","The addition of a new conditional check that throws an exception if `hasNext()` returns false introduces a new code path that can result in a `NoSuchElementException` being thrown where it wasn't thrown before. Therefore, this is a compatibility issue of type 2."
814,"<android.text.StaticLayout.Builder: Builder obtain(CharSequence,int,int,TextPaint,int)>",25,26,"<android.text.StaticLayout.Builder: Builder obtain(CharSequence,int,int,TextPaint,int)>","<android.text.StaticLayout.Builder: Builder obtain(CharSequence,int,int,TextPaint,int)>",0,"{
    Builder b = sPool.acquire();
    if (b == null) {
        b = new Builder();
    }
    // set default initial values
    b.mText = source;
    b.mStart = start;
    b.mEnd = end;
    b.mPaint = paint;
    b.mWidth = width;
    b.mAlignment = Alignment.ALIGN_NORMAL;
    b.mTextDir = TextDirectionHeuristics.FIRSTSTRONG_LTR;
    b.mSpacingMult = 1.0f;
    b.mSpacingAdd = 0.0f;
    b.mIncludePad = true;
    b.mEllipsizedWidth = width;
    b.mEllipsize = null;
    b.mMaxLines = Integer.MAX_VALUE;
    b.mBreakStrategy = Layout.BREAK_STRATEGY_SIMPLE;
    b.mHyphenationFrequency = Layout.HYPHENATION_FREQUENCY_NONE;
    b.mMeasuredText = MeasuredText.obtain();
    return b;
}","{
    Builder b = sPool.acquire();
    if (b == null) {
        b = new Builder();
    }
    // set default initial values
    b.mText = source;
    b.mStart = start;
    b.mEnd = end;
    b.mPaint = paint;
    b.mWidth = width;
    b.mAlignment = Alignment.ALIGN_NORMAL;
    b.mTextDir = TextDirectionHeuristics.FIRSTSTRONG_LTR;
    b.mSpacingMult = 1.0f;
    b.mSpacingAdd = 0.0f;
    b.mIncludePad = true;
    b.mEllipsizedWidth = width;
    b.mEllipsize = null;
    b.mMaxLines = Integer.MAX_VALUE;
    b.mBreakStrategy = Layout.BREAK_STRATEGY_SIMPLE;
    b.mHyphenationFrequency = Layout.HYPHENATION_FREQUENCY_NONE;
    b.mJustificationMode = Layout.JUSTIFICATION_MODE_NONE;
    b.mMeasuredText = MeasuredText.obtain();
    return b;
}",1,"/**
 * Obtain a builder for constructing StaticLayout objects
 *
 * @param source The text to be laid out, optionally with spans
 * @param start The index of the start of the text
 * @param end The index + 1 of the end of the text
 * @param paint The base paint used for layout
 * @param width The width in pixels
 * @return a builder object used for constructing the StaticLayout
 */
","/**
 * Obtain a builder for constructing StaticLayout objects
 *
 * @param source The text to be laid out, optionally with spans
 * @param start The index of the start of the text
 * @param end The index + 1 of the end of the text
 * @param paint The base paint used for layout
 * @param width The width in pixels
 * @return a builder object used for constructing the StaticLayout
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"An additional assignment statement (`b.mJustificationMode = Layout.JUSTIFICATION_MODE_NONE;`) has been added to the late version implementation. This is an 'Other statement changed' as it does not affect control flow or dependency on other APIs, nor it is an exception handling or return statement change.","The assignment of a default value to `b.mJustificationMode` does not constitute a compatibility issue on its own since it's not causing a difference in return types or values under the conditions in which the method is invoked, nor does it introduce a difference in exception handling. Thus, there is no compatibility issue according to the provided context and rules."
815,<android.app.Notification.Builder: RemoteViews createContentView()>,25,26,<android.app.Notification.Builder: RemoteViews createContentView()>,<android.app.Notification.Builder: RemoteViews createContentView()>,0,"{
    if (mN.contentView != null && (mStyle == null || !mStyle.displayCustomViewInline())) {
        return mN.contentView;
    } else if (mStyle != null) {
        final RemoteViews styleView = mStyle.makeContentView();
        if (styleView != null) {
            return styleView;
        }
    }
    return applyStandardTemplate(getBaseLayoutResource());
}","{
    return createContentView(false);
}",1,"/**
 * Construct a RemoteViews for the final 1U notification layout. In order:
 * 1. Custom contentView from the caller
 * 2. Style's proposed content view
 * 3. Standard template view
 */
","/**
 * Construct a RemoteViews for the final 1U notification layout. In order:
 * 1. Custom contentView from the caller
 * 2. Style's proposed content view
 * 3. Standard template view
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The early version has a condition-based implementation with multiple return points based on the conditions. The late version delegates the entire operation to a separate method call `createContentView(false)`. The dependent API (`createContentView(boolean)`) being called is different and since the internal logic is not available for inspection, this is presumed to be an altered dependent API constituting the change type 5. Additionally, the early code's return paths are consolidated into a singular return statement in the late code, making change type 1 applicable here.","The change in the return paths and delegation to another method could potentially lead to different return values, assuming that `createContentView(false)` has a different behavior compared to the inlined logic of the early version. Therefore, a Compatibility Issue of type 1 could arise due to the potential difference in the returned `RemoteViews`."
817,"<android.widget.TextView: boolean onKeyUp(int,KeyEvent)>",25,26,"<android.widget.TextView: boolean onKeyUp(int,KeyEvent)>","<android.widget.TextView: boolean onKeyUp(int,KeyEvent)>",0,"{
    if (!isEnabled()) {
        return super.onKeyUp(keyCode, event);
    }
    if (!KeyEvent.isModifierKey(keyCode)) {
        mPreventDefaultMovement = false;
    }
    switch(keyCode) {
        case KeyEvent.KEYCODE_DPAD_CENTER:
            if (event.hasNoModifiers()) {
                /*
                     * If there is a click listener, just call through to
                     * super, which will invoke it.
                     *
                     * If there isn't a click listener, try to show the soft
                     * input method.  (It will also
                     * call performClick(), but that won't do anything in
                     * this case.)
                     */
                if (!hasOnClickListeners()) {
                    if (mMovement != null && mText instanceof Editable && mLayout != null && onCheckIsTextEditor()) {
                        InputMethodManager imm = InputMethodManager.peekInstance();
                        viewClicked(imm);
                        if (imm != null && getShowSoftInputOnFocus()) {
                            imm.showSoftInput(this, 0);
                        }
                    }
                }
            }
            return super.onKeyUp(keyCode, event);
        case KeyEvent.KEYCODE_ENTER:
            if (event.hasNoModifiers()) {
                if (mEditor != null && mEditor.mInputContentType != null && mEditor.mInputContentType.onEditorActionListener != null && mEditor.mInputContentType.enterDown) {
                    mEditor.mInputContentType.enterDown = false;
                    if (mEditor.mInputContentType.onEditorActionListener.onEditorAction(this, EditorInfo.IME_NULL, event)) {
                        return true;
                    }
                }
                if ((event.getFlags() & KeyEvent.FLAG_EDITOR_ACTION) != 0 || shouldAdvanceFocusOnEnter()) {
                    /*
                         * If there is a click listener, just call through to
                         * super, which will invoke it.
                         *
                         * If there isn't a click listener, try to advance focus,
                         * but still call through to super, which will reset the
                         * pressed state and longpress state.  (It will also
                         * call performClick(), but that won't do anything in
                         * this case.)
                         */
                    if (!hasOnClickListeners()) {
                        View v = focusSearch(FOCUS_DOWN);
                        if (v != null) {
                            if (!v.requestFocus(FOCUS_DOWN)) {
                                throw new IllegalStateException(""focus search returned a view "" + ""that wasn't able to take focus!"");
                            }
                            /*
                                 * Return true because we handled the key; super
                                 * will return false because there was no click
                                 * listener.
                                 */
                            super.onKeyUp(keyCode, event);
                            return true;
                        } else if ((event.getFlags() & KeyEvent.FLAG_EDITOR_ACTION) != 0) {
                            // No target for next focus, but make sure the IME
                            // if this came from it.
                            InputMethodManager imm = InputMethodManager.peekInstance();
                            if (imm != null && imm.isActive(this)) {
                                imm.hideSoftInputFromWindow(getWindowToken(), 0);
                            }
                        }
                    }
                }
                return super.onKeyUp(keyCode, event);
            }
            break;
    }
    if (mEditor != null && mEditor.mKeyListener != null)
        if (mEditor.mKeyListener.onKeyUp(this, (Editable) mText, keyCode, event))
            return true;
    if (mMovement != null && mLayout != null)
        if (mMovement.onKeyUp(this, (Spannable) mText, keyCode, event))
            return true;
    return super.onKeyUp(keyCode, event);
}","{
    if (!isEnabled()) {
        return super.onKeyUp(keyCode, event);
    }
    if (!KeyEvent.isModifierKey(keyCode)) {
        mPreventDefaultMovement = false;
    }
    switch(keyCode) {
        case KeyEvent.KEYCODE_DPAD_CENTER:
            if (event.hasNoModifiers()) {
                /*
                     * If there is a click listener, just call through to
                     * super, which will invoke it.
                     *
                     * If there isn't a click listener, try to show the soft
                     * input method.  (It will also
                     * call performClick(), but that won't do anything in
                     * this case.)
                     */
                if (!hasOnClickListeners()) {
                    if (mMovement != null && mText instanceof Editable && mLayout != null && onCheckIsTextEditor()) {
                        InputMethodManager imm = InputMethodManager.peekInstance();
                        viewClicked(imm);
                        if (imm != null && getShowSoftInputOnFocus()) {
                            imm.showSoftInput(this, 0);
                        }
                    }
                }
            }
            return super.onKeyUp(keyCode, event);
        case KeyEvent.KEYCODE_ENTER:
            if (event.hasNoModifiers()) {
                if (mEditor != null && mEditor.mInputContentType != null && mEditor.mInputContentType.onEditorActionListener != null && mEditor.mInputContentType.enterDown) {
                    mEditor.mInputContentType.enterDown = false;
                    if (mEditor.mInputContentType.onEditorActionListener.onEditorAction(this, EditorInfo.IME_NULL, event)) {
                        return true;
                    }
                }
                if ((event.getFlags() & KeyEvent.FLAG_EDITOR_ACTION) != 0 || shouldAdvanceFocusOnEnter()) {
                    /*
                         * If there is a click listener, just call through to
                         * super, which will invoke it.
                         *
                         * If there isn't a click listener, try to advance focus,
                         * but still call through to super, which will reset the
                         * pressed state and longpress state.  (It will also
                         * call performClick(), but that won't do anything in
                         * this case.)
                         */
                    if (!hasOnClickListeners()) {
                        View v = focusSearch(FOCUS_DOWN);
                        if (v != null) {
                            if (!v.requestFocus(FOCUS_DOWN)) {
                                throw new IllegalStateException(""focus search returned a view "" + ""that wasn't able to take focus!"");
                            }
                            /*
                                 * Return true because we handled the key; super
                                 * will return false because there was no click
                                 * listener.
                                 */
                            super.onKeyUp(keyCode, event);
                            return true;
                        } else if ((event.getFlags() & KeyEvent.FLAG_EDITOR_ACTION) != 0) {
                            // No target for next focus, but make sure the IME
                            // if this came from it.
                            InputMethodManager imm = InputMethodManager.peekInstance();
                            if (imm != null && imm.isActive(this)) {
                                imm.hideSoftInputFromWindow(getWindowToken(), 0);
                            }
                        }
                    }
                }
                return super.onKeyUp(keyCode, event);
            }
            break;
    }
    if (mEditor != null && mEditor.mKeyListener != null) {
        if (mEditor.mKeyListener.onKeyUp(this, (Editable) mText, keyCode, event)) {
            return true;
        }
    }
    if (mMovement != null && mLayout != null) {
        if (mMovement.onKeyUp(this, (Spannable) mText, keyCode, event)) {
            return true;
        }
    }
    return super.onKeyUp(keyCode, event);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
820,"<android.nfc.NdefRecord: NdefRecord[] parse(ByteBuffer,boolean)>",25,26,"<android.nfc.NdefRecord: NdefRecord[] parse(ByteBuffer,boolean)>","<android.nfc.NdefRecord: NdefRecord[] parse(ByteBuffer,boolean)>",0,"{
    List<NdefRecord> records = new ArrayList<NdefRecord>();
    try {
        byte[] type = null;
        byte[] id = null;
        byte[] payload = null;
        ArrayList<byte[]> chunks = new ArrayList<byte[]>();
        boolean inChunk = false;
        short chunkTnf = -1;
        boolean me = false;
        while (!me) {
            byte flag = buffer.get();
            boolean mb = (flag & NdefRecord.FLAG_MB) != 0;
            me = (flag & NdefRecord.FLAG_ME) != 0;
            boolean cf = (flag & NdefRecord.FLAG_CF) != 0;
            boolean sr = (flag & NdefRecord.FLAG_SR) != 0;
            boolean il = (flag & NdefRecord.FLAG_IL) != 0;
            short tnf = (short) (flag & 0x07);
            if (!mb && records.size() == 0 && !inChunk && !ignoreMbMe) {
                throw new FormatException(""expected MB flag"");
            } else if (mb && records.size() != 0 && !ignoreMbMe) {
                throw new FormatException(""unexpected MB flag"");
            } else if (inChunk && il) {
                throw new FormatException(""unexpected IL flag in non-leading chunk"");
            } else if (cf && me) {
                throw new FormatException(""unexpected ME flag in non-trailing chunk"");
            } else if (inChunk && tnf != NdefRecord.TNF_UNCHANGED) {
                throw new FormatException(""expected TNF_UNCHANGED in non-leading chunk"");
            } else if (!inChunk && tnf == NdefRecord.TNF_UNCHANGED) {
                throw new FormatException("""" + ""unexpected TNF_UNCHANGED in first chunk or unchunked record"");
            }
            int typeLength = buffer.get() & 0xFF;
            long payloadLength = sr ? (buffer.get() & 0xFF) : (buffer.getInt() & 0xFFFFFFFFL);
            int idLength = il ? (buffer.get() & 0xFF) : 0;
            if (inChunk && typeLength != 0) {
                throw new FormatException(""expected zero-length type in non-leading chunk"");
            }
            if (!inChunk) {
                type = (typeLength > 0 ? new byte[typeLength] : EMPTY_BYTE_ARRAY);
                id = (idLength > 0 ? new byte[idLength] : EMPTY_BYTE_ARRAY);
                buffer.get(type);
                buffer.get(id);
            }
            ensureSanePayloadSize(payloadLength);
            payload = (payloadLength > 0 ? new byte[(int) payloadLength] : EMPTY_BYTE_ARRAY);
            buffer.get(payload);
            if (cf && !inChunk) {
                // first chunk
                chunks.clear();
                chunkTnf = tnf;
            }
            if (cf || inChunk) {
                // any chunk
                chunks.add(payload);
            }
            if (!cf && inChunk) {
                // last chunk, flatten the payload
                payloadLength = 0;
                for (byte[] p : chunks) {
                    payloadLength += p.length;
                }
                ensureSanePayloadSize(payloadLength);
                payload = new byte[(int) payloadLength];
                int i = 0;
                for (byte[] p : chunks) {
                    System.arraycopy(p, 0, payload, i, p.length);
                    i += p.length;
                }
                tnf = chunkTnf;
            }
            if (cf) {
                // more chunks to come
                inChunk = true;
                continue;
            } else {
                inChunk = false;
            }
            String error = validateTnf(tnf, type, id, payload);
            if (error != null) {
                throw new FormatException(error);
            }
            records.add(new NdefRecord(tnf, type, id, payload));
            if (ignoreMbMe) {
                // for parsing a single NdefRecord
                break;
            }
        }
    } catch (BufferUnderflowException e) {
        throw new FormatException(""expected more data"", e);
    }
    return records.toArray(new NdefRecord[records.size()]);
}","{
    List<NdefRecord> records = new ArrayList<NdefRecord>();
    try {
        byte[] type = null;
        byte[] id = null;
        byte[] payload = null;
        ArrayList<byte[]> chunks = new ArrayList<byte[]>();
        boolean inChunk = false;
        short chunkTnf = -1;
        boolean me = false;
        while (!me) {
            byte flag = buffer.get();
            boolean mb = (flag & NdefRecord.FLAG_MB) != 0;
            me = (flag & NdefRecord.FLAG_ME) != 0;
            boolean cf = (flag & NdefRecord.FLAG_CF) != 0;
            boolean sr = (flag & NdefRecord.FLAG_SR) != 0;
            boolean il = (flag & NdefRecord.FLAG_IL) != 0;
            short tnf = (short) (flag & 0x07);
            if (!mb && records.size() == 0 && !inChunk && !ignoreMbMe) {
                throw new FormatException(""expected MB flag"");
            } else if (mb && (records.size() != 0 || inChunk) && !ignoreMbMe) {
                throw new FormatException(""unexpected MB flag"");
            } else if (inChunk && il) {
                throw new FormatException(""unexpected IL flag in non-leading chunk"");
            } else if (cf && me) {
                throw new FormatException(""unexpected ME flag in non-trailing chunk"");
            } else if (inChunk && tnf != NdefRecord.TNF_UNCHANGED) {
                throw new FormatException(""expected TNF_UNCHANGED in non-leading chunk"");
            } else if (!inChunk && tnf == NdefRecord.TNF_UNCHANGED) {
                throw new FormatException("""" + ""unexpected TNF_UNCHANGED in first chunk or unchunked record"");
            }
            int typeLength = buffer.get() & 0xFF;
            long payloadLength = sr ? (buffer.get() & 0xFF) : (buffer.getInt() & 0xFFFFFFFFL);
            int idLength = il ? (buffer.get() & 0xFF) : 0;
            if (inChunk && typeLength != 0) {
                throw new FormatException(""expected zero-length type in non-leading chunk"");
            }
            if (!inChunk) {
                type = (typeLength > 0 ? new byte[typeLength] : EMPTY_BYTE_ARRAY);
                id = (idLength > 0 ? new byte[idLength] : EMPTY_BYTE_ARRAY);
                buffer.get(type);
                buffer.get(id);
            }
            ensureSanePayloadSize(payloadLength);
            payload = (payloadLength > 0 ? new byte[(int) payloadLength] : EMPTY_BYTE_ARRAY);
            buffer.get(payload);
            if (cf && !inChunk) {
                // first chunk
                if (typeLength == 0 && tnf != NdefRecord.TNF_UNKNOWN) {
                    throw new FormatException(""expected non-zero type length in first chunk"");
                }
                chunks.clear();
                chunkTnf = tnf;
            }
            if (cf || inChunk) {
                // any chunk
                chunks.add(payload);
            }
            if (!cf && inChunk) {
                // last chunk, flatten the payload
                payloadLength = 0;
                for (byte[] p : chunks) {
                    payloadLength += p.length;
                }
                ensureSanePayloadSize(payloadLength);
                payload = new byte[(int) payloadLength];
                int i = 0;
                for (byte[] p : chunks) {
                    System.arraycopy(p, 0, payload, i, p.length);
                    i += p.length;
                }
                tnf = chunkTnf;
            }
            if (cf) {
                // more chunks to come
                inChunk = true;
                continue;
            } else {
                inChunk = false;
            }
            String error = validateTnf(tnf, type, id, payload);
            if (error != null) {
                throw new FormatException(error);
            }
            records.add(new NdefRecord(tnf, type, id, payload));
            if (ignoreMbMe) {
                // for parsing a single NdefRecord
                break;
            }
        }
    } catch (BufferUnderflowException e) {
        throw new FormatException(""expected more data"", e);
    }
    return records.toArray(new NdefRecord[records.size()]);
}",1,"/**
 * Main record parsing method.<p>
 * Expects NdefMessage to begin immediately, allows trailing data.<p>
 * Currently has strict validation of all fields as per NDEF 1.0
 * specification section 2.5. We will attempt to keep this as strict as
 * possible to encourage well-formatted NDEF.<p>
 * Always returns 1 or more NdefRecord's, or throws FormatException.
 *
 * @param buffer ByteBuffer to read from
 * @param ignoreMbMe ignore MB and ME flags, and read only 1 complete record
 * @return one or more records
 * @throws FormatException on any parsing error
 */
","/**
 * Main record parsing method.<p>
 * Expects NdefMessage to begin immediately, allows trailing data.<p>
 * Currently has strict validation of all fields as per NDEF 1.0
 * specification section 2.5. We will attempt to keep this as strict as
 * possible to encourage well-formatted NDEF.<p>
 * Always returns 1 or more NdefRecord's, or throws FormatException.
 *
 * @param buffer ByteBuffer to read from
 * @param ignoreMbMe ignore MB and ME flags, and read only 1 complete record
 * @return one or more records
 * @throws FormatException on any parsing error
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
821,<android.preference.PreferenceActivity: boolean hasHeaders()>,25,26,<android.preference.PreferenceActivity: boolean hasHeaders()>,<android.preference.PreferenceActivity: boolean hasHeaders()>,0,"{
    return getListView().getVisibility() == View.VISIBLE && mPreferenceManager == null;
}","{
    return mHeadersContainer != null && mHeadersContainer.getVisibility() == View.VISIBLE;
}",1,"/**
 * Returns true if this activity is currently showing the header list.
 */
","/**
 * Returns true if this activity is currently showing the header list.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement logic has changed from checking the visibility of the list view and nullity of mPreferenceManager to checking the nullity of mHeadersContainer and its visibility. This constitutes a changed return statement, so the code change type is 1.","Since the logic to determine the return value has been modified, this might lead to different return values depending on the presence and visibility of mHeadersContainer instead of the visibility of the list view and state of mPreferenceManager. Therefore, the change could potentially result in a different behavior, indicating a CI type 1."
822,"<android.widget.ListView: View findViewWithTagInHeadersOrFooters(ArrayList<FixedViewInfo>,Object)>",25,26,"<android.widget.ListView: View findViewWithTagInHeadersOrFooters(ArrayList<FixedViewInfo>,Object)>","<android.widget.ListView: View findViewWithTagInHeadersOrFooters(ArrayList<FixedViewInfo>,Object)>",0,"{
    if (where != null) {
        int len = where.size();
        View v;
        for (int i = 0; i < len; i++) {
            v = where.get(i).view;
            if (!v.isRootNamespace()) {
                v = v.findViewWithTag(tag);
                if (v != null) {
                    return v;
                }
            }
        }
    }
    return null;
}","{
    // the tag.
    if (where != null) {
        int len = where.size();
        View v;
        for (int i = 0; i < len; i++) {
            v = where.get(i).view;
            if (!v.isRootNamespace()) {
                v = v.findViewWithTag(tag);
                if (v != null) {
                    return v;
                }
            }
        }
    }
    return null;
}",1,"/* (non-Javadoc)
     *
     * Look in the passed in list of headers or footers for the view with the tag.
     */
",,-1,,,-1,-1,-1,-1,-1,-1,0,0,"There is no code change, only comments have been added in the late version.",There is no compatibility issue since the executable code remains unchanged.
823,<android.view.View: boolean performClick()>,25,26,<android.view.View: boolean performClick()>,<android.view.View: boolean performClick()>,0,"{
    final boolean result;
    final ListenerInfo li = mListenerInfo;
    if (li != null && li.mOnClickListener != null) {
        playSoundEffect(SoundEffectConstants.CLICK);
        li.mOnClickListener.onClick(this);
        result = true;
    } else {
        result = false;
    }
    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);
    return result;
}","{
    final boolean result;
    final ListenerInfo li = mListenerInfo;
    if (li != null && li.mOnClickListener != null) {
        playSoundEffect(SoundEffectConstants.CLICK);
        li.mOnClickListener.onClick(this);
        result = true;
    } else {
        result = false;
    }
    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);
    notifyEnterOrExitForAutoFillIfNeeded(true);
    return result;
}",1,"/**
 * Call this view's OnClickListener, if it is defined.  Performs all normal
 * actions associated with clicking: reporting accessibility event, playing
 * a sound, etc.
 *
 * @return True there was an assigned OnClickListener that was called, false
 * otherwise is returned.
 */
","/**
 * Call this view's OnClickListener, if it is defined.  Performs all normal
 * actions associated with clicking: reporting accessibility event, playing
 * a sound, etc.
 *
 * @return True there was an assigned OnClickListener that was called, false
 * otherwise is returned.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"A new method call (notifyEnterOrExitForAutoFillIfNeeded(true)) has been added before the last return statement, so the code change type is 4.","The change does not affect the return value or the exceptions thrown by the method performClick(). The result variable's value is set before the new method call and is unrelated to it. Thus, there is no CI, so the CI type is 0."
824,"<android.database.sqlite.SQLiteDatabase: long insertWithOnConflict(String,String,ContentValues,int)>",25,26,"<android.database.sqlite.SQLiteDatabase: long insertWithOnConflict(String,String,ContentValues,int)>","<android.database.sqlite.SQLiteDatabase: long insertWithOnConflict(String,String,ContentValues,int)>",0,"{
    acquireReference();
    try {
        StringBuilder sql = new StringBuilder();
        sql.append(""INSERT"");
        sql.append(CONFLICT_VALUES[conflictAlgorithm]);
        sql.append("" INTO "");
        sql.append(table);
        sql.append('(');
        Object[] bindArgs = null;
        int size = (initialValues != null && initialValues.size() > 0) ? initialValues.size() : 0;
        if (size > 0) {
            bindArgs = new Object[size];
            int i = 0;
            for (String colName : initialValues.keySet()) {
                sql.append((i > 0) ? "","" : """");
                sql.append(colName);
                bindArgs[i++] = initialValues.get(colName);
            }
            sql.append(')');
            sql.append("" VALUES ("");
            for (i = 0; i < size; i++) {
                sql.append((i > 0) ? "",?"" : ""?"");
            }
        } else {
            sql.append(nullColumnHack + "") VALUES (NULL"");
        }
        sql.append(')');
        SQLiteStatement statement = new SQLiteStatement(this, sql.toString(), bindArgs);
        try {
            return statement.executeInsert();
        } finally {
            statement.close();
        }
    } finally {
        releaseReference();
    }
}","{
    acquireReference();
    try {
        StringBuilder sql = new StringBuilder();
        sql.append(""INSERT"");
        sql.append(CONFLICT_VALUES[conflictAlgorithm]);
        sql.append("" INTO "");
        sql.append(table);
        sql.append('(');
        Object[] bindArgs = null;
        int size = (initialValues != null && !initialValues.isEmpty()) ? initialValues.size() : 0;
        if (size > 0) {
            bindArgs = new Object[size];
            int i = 0;
            for (String colName : initialValues.keySet()) {
                sql.append((i > 0) ? "","" : """");
                sql.append(colName);
                bindArgs[i++] = initialValues.get(colName);
            }
            sql.append(')');
            sql.append("" VALUES ("");
            for (i = 0; i < size; i++) {
                sql.append((i > 0) ? "",?"" : ""?"");
            }
        } else {
            sql.append(nullColumnHack + "") VALUES (NULL"");
        }
        sql.append(')');
        SQLiteStatement statement = new SQLiteStatement(this, sql.toString(), bindArgs);
        try {
            return statement.executeInsert();
        } finally {
            statement.close();
        }
    } finally {
        releaseReference();
    }
}",1,"/**
 * General method for inserting a row into the database.
 *
 * @param table the table to insert the row into
 * @param nullColumnHack optional; may be <code>null</code>.
 * SQL doesn't allow inserting a completely empty row without
 * naming at least one column name.  If your provided <code>initialValues</code> is
 * empty, no column names are known and an empty row can't be inserted.
 * If not set to null, the <code>nullColumnHack</code> parameter
 * provides the name of nullable column name to explicitly insert a NULL into
 * in the case where your <code>initialValues</code> is empty.
 * @param initialValues this map contains the initial column values for the
 * row. The keys should be the column names and the values the
 * column values
 * @param conflictAlgorithm for insert conflict resolver
 * @return the row ID of the newly inserted row OR <code>-1</code> if either the
 * input parameter <code>conflictAlgorithm</code> = {@link #CONFLICT_IGNORE}
 * or an error occurred.
 */
","/**
 * General method for inserting a row into the database.
 *
 * @param table the table to insert the row into
 * @param nullColumnHack optional; may be <code>null</code>.
 * SQL doesn't allow inserting a completely empty row without
 * naming at least one column name.  If your provided <code>initialValues</code> is
 * empty, no column names are known and an empty row can't be inserted.
 * If not set to null, the <code>nullColumnHack</code> parameter
 * provides the name of nullable column name to explicitly insert a NULL into
 * in the case where your <code>initialValues</code> is empty.
 * @param initialValues this map contains the initial column values for the
 * row. The keys should be the column names and the values the
 * column values
 * @param conflictAlgorithm for insert conflict resolver
 * @return the row ID of the newly inserted row OR <code>-1</code> if either the
 * input parameter <code>conflictAlgorithm</code> = {@link #CONFLICT_IGNORE}
 * or an error occurred.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The condition `(initialValues != null && initialValues.size() > 0)` has been changed to `(initialValues != null && !initialValues.isEmpty())`. This change affects a control statement's condition, so the code change type is 3.","The change doesn't lead to a Compatibility Issue; the updated condition is logically equivalent to the original. Using `!isEmpty()` instead of `size() > 0` does not change the behavior of the API because both are checking whether the collection is not empty. Consequently, there are no potential different return values, types, or exceptions that the API would produce, hence no CI."
825,<android.app.Fragment: void setEnterSharedElementCallback(SharedElementCallback)>,25,26,<android.app.Fragment: void setEnterSharedElementCallback(SharedElementCallback)>,<android.app.Fragment: void setEnterSharedElementCallback(SharedElementCallback)>,0,"{
    if (callback == null) {
        callback = SharedElementCallback.NULL_CALLBACK;
    }
    mEnterTransitionCallback = callback;
}","{
    if (callback == null) {
        if (mAnimationInfo == null) {
            // already a null callback
            return;
        }
        callback = SharedElementCallback.NULL_CALLBACK;
    }
    ensureAnimationInfo().mEnterTransitionCallback = callback;
}",1,"/**
 * When custom transitions are used with Fragments, the enter transition callback
 * is called when this Fragment is attached or detached when not popping the back stack.
 *
 * @param callback Used to manipulate the shared element transitions on this Fragment
 * when added not as a pop from the back stack.
 */
","/**
 * When custom transitions are used with Fragments, the enter transition callback
 * is called when this Fragment is attached or detached when not popping the back stack.
 *
 * @param callback Used to manipulate the shared element transitions on this Fragment
 * when added not as a pop from the back stack.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",0,The late implementation added a new conditional block for setting the callback to NULL_CALLBACK only if `mAnimationInfo` is non-null and added a call to `ensureAnimationInfo()` before assigning the callback. This indicates a control dependency change (3) and other statement changes (4). We also observe an addition of dependent API call `ensureAnimationInfo()` which is 5.,"There seems to be no compatibility issue here as the behavior change is only in the internal state management and how the callback is set. It ensures that a `SharedElementCallback.NULL_CALLBACK` is set if callback is null, similar to the early version. The changes do not appear to alter the externally observable behavior of the API. Thus, the result is 0."
827,<android.animation.ValueAnimator: void end()>,25,26,<android.animation.ValueAnimator: void end()>,<android.animation.ValueAnimator: void end()>,0,"{
    if (Looper.myLooper() == null) {
        throw new AndroidRuntimeException(""Animators may only be run on Looper threads"");
    }
    if (!mRunning) {
        // Special case if the animation has not yet started; get it ready for ending
        startAnimation();
        mStarted = true;
    } else if (!mInitialized) {
        initAnimation();
    }
    animateValue(shouldPlayBackward(mRepeatCount) ? 0f : 1f);
    endAnimation();
}","{
    if (Looper.myLooper() == null) {
        throw new AndroidRuntimeException(""Animators may only be run on Looper threads"");
    }
    if (!mRunning) {
        // Special case if the animation has not yet started; get it ready for ending
        startAnimation();
        mStarted = true;
    } else if (!mInitialized) {
        initAnimation();
    }
    animateValue(shouldPlayBackward(mRepeatCount, mReversing) ? 0f : 1f);
    endAnimation();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The parameter checklist of method shouldPlayBackward() has changed, a new parameter mReversing has been added, which classifies as a change type 4. Since it's a change within the statement and no conditional or control flow has been altered, we consider it as an 'Other statement changed.' Moreover, since the shouldPlayBackward() method is a dependent API and its parameter list has been modified, this is also classified as 'Dependent API changed' change type 5.","There's no Compatibility Issue because the change to the method shouldPlayBackward() does not affect the control flow or lead to a new or different exception being thrown, nor does it lead to a potential different return value or type from the end() method. The behavior of end() simply reflects the result of the shouldPlayBackward(), and there is no indication that changes to shouldPlayBackward() would yield a different result in regards to the execution of end(). This is why the Compatibility Issue type is 0."
829,"<android.app.Fragment: View performCreateView(LayoutInflater,ViewGroup,Bundle)>",25,26,"<android.app.Fragment: View performCreateView(LayoutInflater,ViewGroup,Bundle)>","<android.app.Fragment: View performCreateView(LayoutInflater,ViewGroup,Bundle)>",0,"{
    if (mChildFragmentManager != null) {
        mChildFragmentManager.noteStateNotSaved();
    }
    return onCreateView(inflater, container, savedInstanceState);
}","{
    if (mChildFragmentManager != null) {
        mChildFragmentManager.noteStateNotSaved();
    }
    mPerformedCreateView = true;
    return onCreateView(inflater, container, savedInstanceState);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"An assignment to the field 'mPerformedCreateView' has been added before the return statement, so the code change type is 4.","The newly added assignment doesn't change the behaviour of the 'return' statement nor does it add any new exception handling. Thus, there's no Compatibility Issue, and the CI type is 0."
830,"<android.provider.DocumentsProvider: void attachInfo(Context,ProviderInfo)>",25,26,"<android.provider.DocumentsProvider: void attachInfo(Context,ProviderInfo)>","<android.provider.DocumentsProvider: void attachInfo(Context,ProviderInfo)>",0,"{
    mAuthority = info.authority;
    mMatcher = new UriMatcher(UriMatcher.NO_MATCH);
    mMatcher.addURI(mAuthority, ""root"", MATCH_ROOTS);
    mMatcher.addURI(mAuthority, ""root/*"", MATCH_ROOT);
    mMatcher.addURI(mAuthority, ""root/*/recent"", MATCH_RECENT);
    mMatcher.addURI(mAuthority, ""root/*/search"", MATCH_SEARCH);
    mMatcher.addURI(mAuthority, ""document/*"", MATCH_DOCUMENT);
    mMatcher.addURI(mAuthority, ""document/*/children"", MATCH_CHILDREN);
    mMatcher.addURI(mAuthority, ""tree/*/document/*"", MATCH_DOCUMENT_TREE);
    mMatcher.addURI(mAuthority, ""tree/*/document/*/children"", MATCH_CHILDREN_TREE);
    // Sanity check our setup
    if (!info.exported) {
        throw new SecurityException(""Provider must be exported"");
    }
    if (!info.grantUriPermissions) {
        throw new SecurityException(""Provider must grantUriPermissions"");
    }
    if (!android.Manifest.permission.MANAGE_DOCUMENTS.equals(info.readPermission) || !android.Manifest.permission.MANAGE_DOCUMENTS.equals(info.writePermission)) {
        throw new SecurityException(""Provider must be protected by MANAGE_DOCUMENTS"");
    }
    super.attachInfo(context, info);
}","{
    registerAuthority(info.authority);
    // Sanity check our setup
    if (!info.exported) {
        throw new SecurityException(""Provider must be exported"");
    }
    if (!info.grantUriPermissions) {
        throw new SecurityException(""Provider must grantUriPermissions"");
    }
    if (!android.Manifest.permission.MANAGE_DOCUMENTS.equals(info.readPermission) || !android.Manifest.permission.MANAGE_DOCUMENTS.equals(info.writePermission)) {
        throw new SecurityException(""Provider must be protected by MANAGE_DOCUMENTS"");
    }
    super.attachInfo(context, info);
}",1,"/**
 * Implementation is provided by the parent class.
 */
","/**
 * Implementation is provided by the parent class.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The early implementation of the method directly assigns values to mAuthority and mMatcher and adds various URI patterns to the matcher. The late implementation replaces these operations with a single call to registerAuthority(info.authority). Thus, there is no change to return statements, exception handling, or control flow; the implementation changes how the authority is registered (which seems to be a refactoring into a method), so it's a change in ""Other statement changed"" and ""Dependent API changed"".",There is no compatibility issue since there is no change in the behavior of exceptions or the return value of the method. The changes seem to be internal refactoring that should not affect the method's external behavior.
831,<android.text.method.DateTimeKeyListener: DateTimeKeyListener getInstance()>,25,26,<android.text.method.DateTimeKeyListener: DateTimeKeyListener getInstance()>,<android.text.method.DateTimeKeyListener: DateTimeKeyListener getInstance()>,0,"{
    if (sInstance != null)
        return sInstance;
    sInstance = new DateTimeKeyListener();
    return sInstance;
}","{
    return getInstance(null);
}",1,,"/**
 * @deprecated Use {@link #getInstance(Locale)} instead.
 */
",-1,,"[@Deprecated, @NonNull]",-1,-1,-1,-1,-1,-1,5,0,"The late version of the method calls a different method (getInstance(null)) as opposed to creating a new instance or returning the static instance directly which means a dependent API has changed, so the change type is 5.","There is no compatibility issue detected because the intended behavior of getting an instance of DateTimeKeyListener is preserved. The late implementation delegates the instance creation or retrieval to another method, which doesn't inherently cause a different return value or exception handling by this API, as long as the new getInstance method maintains the same contract. Therefore, there is no compatibility issue."
832,"<android.text.SpannableStringInternal: void setSpan(Object,int,int,int)>",25,26,"<android.text.SpannableStringInternal: void setSpan(Object,int,int,int)>","<android.text.SpannableStringInternal: void setSpan(Object,int,int,int)>",0,"{
    int nstart = start;
    int nend = end;
    checkRange(""setSpan"", start, end);
    if ((flags & Spannable.SPAN_PARAGRAPH) == Spannable.SPAN_PARAGRAPH) {
        if (start != 0 && start != length()) {
            char c = charAt(start - 1);
            if (c != '\n')
                throw new RuntimeException(""PARAGRAPH span must start at paragraph boundary"" + "" ("" + start + "" follows "" + c + "")"");
        }
        if (end != 0 && end != length()) {
            char c = charAt(end - 1);
            if (c != '\n')
                throw new RuntimeException(""PARAGRAPH span must end at paragraph boundary"" + "" ("" + end + "" follows "" + c + "")"");
        }
    }
    int count = mSpanCount;
    Object[] spans = mSpans;
    int[] data = mSpanData;
    for (int i = 0; i < count; i++) {
        if (spans[i] == what) {
            int ostart = data[i * COLUMNS + START];
            int oend = data[i * COLUMNS + END];
            data[i * COLUMNS + START] = start;
            data[i * COLUMNS + END] = end;
            data[i * COLUMNS + FLAGS] = flags;
            sendSpanChanged(what, ostart, oend, nstart, nend);
            return;
        }
    }
    if (mSpanCount + 1 >= mSpans.length) {
        Object[] newtags = ArrayUtils.newUnpaddedObjectArray(GrowingArrayUtils.growSize(mSpanCount));
        int[] newdata = new int[newtags.length * 3];
        System.arraycopy(mSpans, 0, newtags, 0, mSpanCount);
        System.arraycopy(mSpanData, 0, newdata, 0, mSpanCount * 3);
        mSpans = newtags;
        mSpanData = newdata;
    }
    mSpans[mSpanCount] = what;
    mSpanData[mSpanCount * COLUMNS + START] = start;
    mSpanData[mSpanCount * COLUMNS + END] = end;
    mSpanData[mSpanCount * COLUMNS + FLAGS] = flags;
    mSpanCount++;
    if (this instanceof Spannable)
        sendSpanAdded(what, nstart, nend);
}","{
    setSpan(what, start, end, flags, true);
}",1,"/* package */
","/* package */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method implementation has changed to call another overloaded method setSpan with the signature setSpan(Object,int,int,int,boolean). This indicates the internal workings of setSpan have been refactored or moved to a different method. Since it's a call to an overloaded method, the classification is 5 for Dependent API changed.","Due to lack of details about the implementation of the new overloaded method setSpan(Object,int,int,int,boolean), it is impossible to definitively state whether the change will lead to different behavior. In such cases, where the exact consequence of the change is unknown, it is standard to give the system the benefit of the doubt and assume that the API behavior remains consistent. Therefore, no Compatibility Issue is detected, pending information on the new method's behavior."
833,"<android.content.ClipData: ClipData newUri(ContentResolver,CharSequence,Uri)>",25,26,"<android.content.ClipData: ClipData newUri(ContentResolver,CharSequence,Uri)>","<android.content.ClipData: ClipData newUri(ContentResolver,CharSequence,Uri)>",0,"{
    Item item = new Item(uri);
    String[] mimeTypes = null;
    if (""content"".equals(uri.getScheme())) {
        String realType = resolver.getType(uri);
        mimeTypes = resolver.getStreamTypes(uri, ""*/*"");
        if (realType != null) {
            if (mimeTypes == null) {
                mimeTypes = new String[] { realType };
            } else {
                String[] tmp = new String[mimeTypes.length + 1];
                tmp[0] = realType;
                System.arraycopy(mimeTypes, 0, tmp, 1, mimeTypes.length);
                mimeTypes = tmp;
            }
        }
    }
    if (mimeTypes == null) {
        mimeTypes = MIMETYPES_TEXT_URILIST;
    }
    return new ClipData(label, mimeTypes, item);
}","{
    Item item = new Item(uri);
    String[] mimeTypes = getMimeTypes(resolver, uri);
    return new ClipData(label, mimeTypes, item);
}",1,"/**
 * Create a new ClipData holding a URI.  If the URI is a content: URI,
 * this will query the content provider for the MIME type of its data and
 * use that as the MIME type.  Otherwise, it will use the MIME type
 * {@link ClipDescription#MIMETYPE_TEXT_URILIST}.
 *
 * @param resolver ContentResolver used to get information about the URI.
 * @param label User-visible label for the clip data.
 * @param uri The URI in the clip.
 * @return Returns a new ClipData containing the specified data.
 */
","/**
 * Create a new ClipData holding a URI.  If the URI is a content: URI,
 * this will query the content provider for the MIME type of its data and
 * use that as the MIME type.  Otherwise, it will use the MIME type
 * {@link ClipDescription#MIMETYPE_TEXT_URILIST}.
 *
 * @param resolver ContentResolver used to get information about the URI.
 * @param label User-visible label for the clip data.
 * @param uri The URI in the clip.
 * @return Returns a new ClipData containing the specified data.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",0,"The implementation has been refactored. There is a change in the return statement as it now uses a new helper method getMimeTypes(resolver, uri), which replaces the previous inline code for mime type detection. This suggests changes in the return statement, although the overall logic appears to be intended to remain the same, and also because a helper method has been introduced, which is a dependent API change. So, the code change types are 1,4,5.","There's no Compatibility Issue in terms of different return values or exceptions because the same values (label, mimeTypes from the method getMimeTypes(), and item) are being returned, and the extracted method getMimeTypes() is intended to perform the same mimeType resolution logic just in a cleaner, refactored way. Assuming getMimeTypes() behaves identically to the inlined logic it replaced, the behavior and public contract of the API remains the same. Therefore, the CI type is 0."
834,"<android.app.LoadedApk.ReceiverDispatcher.InnerReceiver: void performReceive(Intent,int,String,Bundle,boolean,boolean,int)>",25,26,"<android.app.LoadedApk.ReceiverDispatcher.InnerReceiver: void performReceive(Intent,int,String,Bundle,boolean,boolean,int)>","<android.app.LoadedApk.ReceiverDispatcher.InnerReceiver: void performReceive(Intent,int,String,Bundle,boolean,boolean,int)>",0,"{
    final LoadedApk.ReceiverDispatcher rd;
    if (intent == null) {
        Log.wtf(TAG, ""Null intent received"");
        rd = null;
    } else {
        rd = mDispatcher.get();
    }
    if (ActivityThread.DEBUG_BROADCAST) {
        int seq = intent.getIntExtra(""seq"", -1);
        Slog.i(ActivityThread.TAG, ""Receiving broadcast "" + intent.getAction() + "" seq="" + seq + "" to "" + (rd != null ? rd.mReceiver : null));
    }
    if (rd != null) {
        rd.performReceive(intent, resultCode, data, extras, ordered, sticky, sendingUser);
    } else {
        // behalf so that the system's broadcast sequence can continue.
        if (ActivityThread.DEBUG_BROADCAST)
            Slog.i(ActivityThread.TAG, ""Finishing broadcast to unregistered receiver"");
        IActivityManager mgr = ActivityManagerNative.getDefault();
        try {
            if (extras != null) {
                extras.setAllowFds(false);
            }
            mgr.finishReceiver(this, resultCode, data, extras, false, intent.getFlags());
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}","{
    final LoadedApk.ReceiverDispatcher rd;
    if (intent == null) {
        Log.wtf(TAG, ""Null intent received"");
        rd = null;
    } else {
        rd = mDispatcher.get();
    }
    if (ActivityThread.DEBUG_BROADCAST) {
        int seq = intent.getIntExtra(""seq"", -1);
        Slog.i(ActivityThread.TAG, ""Receiving broadcast "" + intent.getAction() + "" seq="" + seq + "" to "" + (rd != null ? rd.mReceiver : null));
    }
    if (rd != null) {
        rd.performReceive(intent, resultCode, data, extras, ordered, sticky, sendingUser);
    } else {
        // behalf so that the system's broadcast sequence can continue.
        if (ActivityThread.DEBUG_BROADCAST)
            Slog.i(ActivityThread.TAG, ""Finishing broadcast to unregistered receiver"");
        IActivityManager mgr = ActivityManager.getService();
        try {
            if (extras != null) {
                extras.setAllowFds(false);
            }
            mgr.finishReceiver(this, resultCode, data, extras, false, intent.getFlags());
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The change is in the line calling the `ActivityManager`, where `ActivityManagerNative.getDefault()` has been replaced by `ActivityManager.getService()`. This change represents a change to a dependent API (the method used to get the `IActivityManager` service instance), hence the code change type is 5.","Since the change does not affect the behavior of the `performReceive` method from the caller's perspective—the method still performs its actions without altering its contract, the types of exceptions thrown, or the values returned—the change should not lead to any compatibility issues. Therefore, the CI type is 0."
835,<android.widget.AbsListView: boolean onGenericMotionEvent(MotionEvent)>,25,26,<android.widget.AbsListView: boolean onGenericMotionEvent(MotionEvent)>,<android.widget.AbsListView: boolean onGenericMotionEvent(MotionEvent)>,0,"{
    if ((event.getSource() & InputDevice.SOURCE_CLASS_POINTER) != 0) {
        switch(event.getAction()) {
            case MotionEvent.ACTION_SCROLL:
                if (mTouchMode == TOUCH_MODE_REST) {
                    final float vscroll = event.getAxisValue(MotionEvent.AXIS_VSCROLL);
                    if (vscroll != 0) {
                        final int delta = (int) (vscroll * getVerticalScrollFactor());
                        if (!trackMotionScroll(delta, delta)) {
                            return true;
                        }
                    }
                }
                break;
            case MotionEvent.ACTION_BUTTON_PRESS:
                int actionButton = event.getActionButton();
                if ((actionButton == MotionEvent.BUTTON_STYLUS_PRIMARY || actionButton == MotionEvent.BUTTON_SECONDARY) && (mTouchMode == TOUCH_MODE_DOWN || mTouchMode == TOUCH_MODE_TAP)) {
                    if (performStylusButtonPressAction(event)) {
                        removeCallbacks(mPendingCheckForLongPress);
                        removeCallbacks(mPendingCheckForTap);
                    }
                }
                break;
        }
    }
    return super.onGenericMotionEvent(event);
}","{
    switch(event.getAction()) {
        case MotionEvent.ACTION_SCROLL:
            final float axisValue;
            if (event.isFromSource(InputDevice.SOURCE_CLASS_POINTER)) {
                axisValue = event.getAxisValue(MotionEvent.AXIS_VSCROLL);
            } else if (event.isFromSource(InputDevice.SOURCE_ROTARY_ENCODER)) {
                axisValue = event.getAxisValue(MotionEvent.AXIS_SCROLL);
            } else {
                axisValue = 0;
            }
            final int delta = Math.round(axisValue * mVerticalScrollFactor);
            if (delta != 0) {
                if (!trackMotionScroll(delta, delta)) {
                    return true;
                }
            }
            break;
        case MotionEvent.ACTION_BUTTON_PRESS:
            if (event.isFromSource(InputDevice.SOURCE_CLASS_POINTER)) {
                int actionButton = event.getActionButton();
                if ((actionButton == MotionEvent.BUTTON_STYLUS_PRIMARY || actionButton == MotionEvent.BUTTON_SECONDARY) && (mTouchMode == TOUCH_MODE_DOWN || mTouchMode == TOUCH_MODE_TAP)) {
                    if (performStylusButtonPressAction(event)) {
                        removeCallbacks(mPendingCheckForLongPress);
                        removeCallbacks(mPendingCheckForTap);
                    }
                }
            }
            break;
    }
    return super.onGenericMotionEvent(event);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"The control flow has changed due to the modification of the input source checks for `MotionEvent.ACTION_SCROLL` and `MotionEvent.ACTION_BUTTON_PRESS`, moving them into the switch statement, along with the introduction of handling for `InputDevice.SOURCE_ROTARY_ENCODER`, so the type of change is 1,3.","These alterations in the control flow could potentially lead to different return values based on the new source checks, especially with the addition of the `InputDevice.SOURCE_ROTARY_ENCODER` source check. The late version may return `true` for sources it previously did not handle, which constitutes a change in return values between versions, and therefore a CI type of 1 is detected."
836,<android.widget.RemoteViewsAdapter.RemoteViewsFrameLayout: View getDefaultView()>,25,26,<android.widget.RemoteViewsAdapter.RemoteViewsFrameLayout: View getDefaultView()>,<android.widget.RemoteViewsAdapter.RemoteViewsFrameLayout: View getDefaultView()>,0,"{
    return mCache.getMetaData().createDefaultLoadingView(this);
}","{
    int viewHeight = mCache.getMetaData().getLoadingTemplate(getContext()).defaultHeight;
    // Compose the loading view text
    TextView loadingTextView = (TextView) LayoutInflater.from(getContext()).inflate(com.android.internal.R.layout.remote_views_adapter_default_loading_view, this, false);
    loadingTextView.setHeight(viewHeight);
    return loadingTextView;
}",1,,"/**
 * Creates a default loading view. Uses the size of the first row as a guide for the
 * size of the loading view.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The late version of the implementation constructs and sets up a TextView manually instead of calling createDefaultLoadingView on the mCache's metadata, so both the statements are different and the return type is now TextView instead of View. This is a return statement change (1) and involves other statement changes (4), such as instantiation and method calls on other objects.","The late version of the code is constructing a default loading view with explicit height and text, which involves a different execution path and consequently will potentially return a different view from the early version, and because of this, the CI type is 1 (CI caused by potential different return values)."
840,<android.preference.Preference: boolean persistLong(long)>,25,26,<android.preference.Preference: boolean persistLong(long)>,<android.preference.Preference: boolean persistLong(long)>,0,"{
    if (shouldPersist()) {
        if (value == getPersistedLong(~value)) {
            // It's already there, so the same as persisting
            return true;
        }
        SharedPreferences.Editor editor = mPreferenceManager.getEditor();
        editor.putLong(mKey, value);
        tryCommit(editor);
        return true;
    }
    return false;
}","{
    if (!shouldPersist()) {
        return false;
    }
    if (value == getPersistedLong(~value)) {
        // It's already there, so the same as persisting
        return true;
    }
    PreferenceDataStore dataStore = getPreferenceDataStore();
    if (dataStore != null) {
        dataStore.putLong(mKey, value);
    } else {
        SharedPreferences.Editor editor = mPreferenceManager.getEditor();
        editor.putLong(mKey, value);
        tryCommit(editor);
    }
    return true;
}",1,"/**
 * Attempts to persist a long to the {@link android.content.SharedPreferences}.
 *
 * @param value The value to persist.
 * @return True if this Preference is persistent. (This is not whether the
 * value was persisted, since we may not necessarily commit if there
 * will be a batch commit later.)
 * @see #persistString(String)
 * @see #getPersistedLong(long)
 */
","/**
 * Attempts to persist a long if this Preference is persistent.
 *
 * @param value The value to persist.
 * @return True if this Preference is persistent. (This is not whether the
 * value was persisted, since we may not necessarily commit if there
 * will be a batch commit later.)
 * @see #persistString(String)
 * @see #getPersistedLong(long)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The control flow has been changed by inverting the condition check within the 'if' statement and by adding the handling of `PreferenceDataStore`. An additional check for `getPreferenceDataStore()` and subsequent logic has been added, which constitute an ""Other statement changed"". The code change types are 3 and 4 due to the control dependency change and the introduction of new logic to handle `PreferenceDataStore`.","There is no Compatibility Issue as the outcome of the API remains the same. The method will return 'false' if it should not persist, 'true' if the value either already exists or has been successfully committed, regardless of whether it is saved to `SharedPreferences` or `PreferenceDataStore`. The different internal mechanisms for persisting the value (via `SharedPreferences` or `PreferenceDataStore`) do not alter the behavior from the caller's perspective, as both mechanisms will successfully persist the value if conditions are met, and the expected return type is consistent in the early and late versions."
843,<android.app.ContextImpl: void sendBroadcast(Intent)>,25,26,<android.app.ContextImpl: void sendBroadcast(Intent)>,<android.app.ContextImpl: void sendBroadcast(Intent)>,0,"{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, false, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, false, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The code change between the two versions is a change in the method used to retrieve the ActivityManager service, from `ActivityManagerNative.getDefault()` to `ActivityManager.getService()`. This is a dependent API changed (code change type 5).","The modification to the dependent API does not manifest a change in behavior of the `sendBroadcast(Intent)` method itself. It is an internal detail within the method that should not affect the functionality perceived by the method's clients, provided that the new implementation of this dependent API (`ActivityManager.getService()`) continues to provide the same service. Hence, there is no Compatibility Issue (CI type 0)."
844,<android.os.StatFs: int getBlockSize()>,25,26,<android.os.StatFs: int getBlockSize()>,<android.os.StatFs: int getBlockSize()>,0,"{
    return (int) mStat.f_bsize;
}","{
    return (int) mStat.f_frsize;
}",1,"/**
 * @deprecated Use {@link #getBlockSizeLong()} instead.
 */
","/**
 * @deprecated Use {@link #getBlockSizeLong()} instead.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,1,1,"The return statement has changed from returning mStat.f_bsize to mStat.f_frsize, so the code change type is 1.","Since the API now returns a value from a different field of the mStat object, it will potentially return a different value, which constitutes a Compatibility Issue of type 1."
847,<android.widget.ListPopupWindow: void setHeight(int)>,25,26,<android.widget.ListPopupWindow: void setHeight(int)>,<android.widget.ListPopupWindow: void setHeight(int)>,0,"{
    mDropDownHeight = height;
}","{
    if (height < 0 && ViewGroup.LayoutParams.WRAP_CONTENT != height && ViewGroup.LayoutParams.MATCH_PARENT != height) {
        if (mContext.getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.O) {
            Log.e(TAG, ""Negative value "" + height + "" passed to ListPopupWindow#setHeight"" + "" produces undefined results"");
        } else {
            throw new IllegalArgumentException(""Invalid height. Must be a positive value, MATCH_PARENT, or WRAP_CONTENT."");
        }
    }
    mDropDownHeight = height;
}",1,"/**
 * Sets the height of the popup window in pixels. Can also be {@link #MATCH_PARENT}.
 *
 * @param height Height of the popup window.
 */
","/**
 * Sets the height of the popup window in pixels. Can also be {@link #MATCH_PARENT}.
 *
 * @param height Height of the popup window must be a positive value,
 * {@link #MATCH_PARENT}, or {@link #WRAP_CONTENT}.
 *
 * @throws IllegalArgumentException if height is set to negative value
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",2,"The late version of the method added a conditional check for the height parameter and depending on the SDK version it either logs an error or throws an `IllegalArgumentException`. This involves both control dependency changes and other statement changes, hence the code change type is 3,4.","The added control dependency can lead to an exception being thrown under certain conditions where the early version would not throw any exception. Therefore, a Compatibility Issue arises due to potential different exception handlings (type 2)."
849,<android.widget.TimePicker: Integer getCurrentHour()>,25,26,<android.widget.TimePicker: Integer getCurrentHour()>,<android.widget.TimePicker: Integer getCurrentHour()>,0,"{
    return mDelegate.getHour();
}","{
    return getHour();
}",1,"/**
 * @return the current hour in the range (0-23)
 * @deprecated Use {@link #getHour()}
 */
","/**
 * @return the currently selected hour, in the range (0-23)
 * @deprecated Use {@link #getHour()}
 */
",-1,"[@NonNull, @Deprecated]","[@NonNull, @Deprecated]",-1,-1,-1,-1,-1,-1,5,0,"The method called within the return statement has changed from mDelegate.getHour() to getHour(), indicating that the method being used to get the current hour has potentially changed. This can be classified as a change in the dependent API, hence the code change type is 5.","Although there is a change in the dependent API, since there's no description of the implementation of getHour() or any change in its signature, we cannot determine whether there is a difference in return values or types based on the available information alone. The annotations are consistent between versions and do not indicate a change in the return type. Thus, there is no demonstrable compatibility issue, so the CI type is 0."
850,<android.app.ContextImpl: ComponentName startService(Intent)>,25,26,<android.app.ContextImpl: ComponentName startService(Intent)>,<android.app.ContextImpl: ComponentName startService(Intent)>,0,"{
    warnIfCallingFromSystemProcess();
    return startServiceCommon(service, mUser);
}","{
    warnIfCallingFromSystemProcess();
    return startServiceCommon(service, false, mUser);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"There is an additional parameter 'false' in the call to startServiceCommon method, so the code change type is 5 (Dependent API changed).",There is no Compatibility Issue as the change reflects an additional argument being passed which is hardcoded and does not affect external behavior.
851,<android.content.ClipboardManager: void addPrimaryClipChangedListener(OnPrimaryClipChangedListener)>,25,26,<android.content.ClipboardManager: void addPrimaryClipChangedListener(OnPrimaryClipChangedListener)>,<android.content.ClipboardManager: void addPrimaryClipChangedListener(OnPrimaryClipChangedListener)>,0,"{
    synchronized (mPrimaryClipChangedListeners) {
        if (mPrimaryClipChangedListeners.size() == 0) {
            try {
                getService().addPrimaryClipChangedListener(mPrimaryClipChangedServiceListener, mContext.getOpPackageName());
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
        }
        mPrimaryClipChangedListeners.add(what);
    }
}","{
    synchronized (mPrimaryClipChangedListeners) {
        if (mPrimaryClipChangedListeners.isEmpty()) {
            try {
                mService.addPrimaryClipChangedListener(mPrimaryClipChangedServiceListener, mContext.getOpPackageName());
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
        }
        mPrimaryClipChangedListeners.add(what);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"There is a modification in the condition checking if the listeners list is empty. The implementation changed from using `mPrimaryClipChangedListeners.size() == 0` to `mPrimaryClipChangedListeners.isEmpty()`. That's a refactoring to make the code cleaner and doesn't affect the semantics, so the code change type is 4.","Since the change is purely syntactical and doesn't affect the logic of the method (both `size() == 0` and `isEmpty()` are functionally equivalent in checking whether a collection is empty), no compatibility issue arises from this change."
852,<android.service.voice.VoiceInteractionSession: LayoutInflater getLayoutInflater()>,25,26,<android.service.voice.VoiceInteractionSession: LayoutInflater getLayoutInflater()>,<android.service.voice.VoiceInteractionSession: LayoutInflater getLayoutInflater()>,0,"{
    return mInflater;
}","{
    ensureWindowCreated();
    return mInflater;
}",1,"/**
 * Convenience for inflating views.
 */
","/**
 * Convenience for inflating views.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"An additional method call ""ensureWindowCreated()"" is introduced before returning ""mInflater"", so the change type is 4.","There is no indication that the new method call ""ensureWindowCreated()"" will alter the return type or value of the method; it seems like a setup method to ensure some state before getting the LayoutInflater. Unless ""ensureWindowCreated()"" changes the state of ""mInflater"", this would not introduce a compatibility issue by itself. Therefore, the CI type is 0."
853,<android.view.ViewGroup: boolean dispatchDragEvent(DragEvent)>,25,26,<android.view.ViewGroup: boolean dispatchDragEvent(DragEvent)>,<android.view.ViewGroup: boolean dispatchDragEvent(DragEvent)>,0,"{
    boolean retval = false;
    final float tx = event.mX;
    final float ty = event.mY;
    ViewRootImpl root = getViewRootImpl();
    // Dispatch down the view hierarchy
    final PointF localPoint = getLocalPoint();
    switch(event.mAction) {
        case DragEvent.ACTION_DRAG_STARTED:
            {
                // clear state to recalculate which views we drag over
                mCurrentDragView = null;
                // Set up our tracking of drag-started notifications
                mCurrentDragStartEvent = DragEvent.obtain(event);
                if (mChildrenInterestedInDrag == null) {
                    mChildrenInterestedInDrag = new HashSet<View>();
                } else {
                    mChildrenInterestedInDrag.clear();
                }
                // Now dispatch down to our children, caching the responses
                final int count = mChildrenCount;
                final View[] children = mChildren;
                for (int i = 0; i < count; i++) {
                    final View child = children[i];
                    child.mPrivateFlags2 &= ~View.DRAG_MASK;
                    if (child.getVisibility() == VISIBLE) {
                        if (notifyChildOfDragStart(children[i])) {
                            retval = true;
                        }
                    }
                }
                // Notify itself of the drag start.
                mIsInterestedInDrag = super.dispatchDragEvent(event);
                if (mIsInterestedInDrag) {
                    retval = true;
                }
                if (!retval) {
                    // Neither us nor any of our children are interested in this drag, so stop tracking
                    // the current drag event.
                    mCurrentDragStartEvent.recycle();
                    mCurrentDragStartEvent = null;
                }
            }
            break;
        case DragEvent.ACTION_DRAG_ENDED:
            {
                // Release the bookkeeping now that the drag lifecycle has ended
                final HashSet<View> childrenInterestedInDrag = mChildrenInterestedInDrag;
                if (childrenInterestedInDrag != null) {
                    for (View child : childrenInterestedInDrag) {
                        // If a child was interested in the ongoing drag, it's told that it's over
                        if (child.dispatchDragEvent(event)) {
                            retval = true;
                        }
                        child.mPrivateFlags2 &= ~View.DRAG_MASK;
                        child.refreshDrawableState();
                    }
                    childrenInterestedInDrag.clear();
                }
                if (mCurrentDragStartEvent != null) {
                    mCurrentDragStartEvent.recycle();
                    mCurrentDragStartEvent = null;
                }
                if (mIsInterestedInDrag) {
                    if (super.dispatchDragEvent(event)) {
                        retval = true;
                    }
                    mIsInterestedInDrag = false;
                }
            }
            break;
        case DragEvent.ACTION_DRAG_LOCATION:
            {
                // Find the [possibly new] drag target
                View target = findFrontmostDroppableChildAt(event.mX, event.mY, localPoint);
                if (target == null && mIsInterestedInDrag) {
                    target = this;
                }
                // before reporting the new potential recipient to the framework.
                if (mCurrentDragView != target) {
                    root.setDragFocus(target);
                    final int action = event.mAction;
                    // Position should not be available for ACTION_DRAG_ENTERED and ACTION_DRAG_EXITED.
                    event.mX = 0;
                    event.mY = 0;
                    // If we've dragged off of a child view or this window, send it the EXITED message
                    if (mCurrentDragView != null) {
                        final View view = mCurrentDragView;
                        event.mAction = DragEvent.ACTION_DRAG_EXITED;
                        if (view != this) {
                            view.dispatchDragEvent(event);
                            view.mPrivateFlags2 &= ~View.PFLAG2_DRAG_HOVERED;
                            view.refreshDrawableState();
                        } else {
                            super.dispatchDragEvent(event);
                        }
                    }
                    mCurrentDragView = target;
                    // send it to this window.
                    if (target != null) {
                        event.mAction = DragEvent.ACTION_DRAG_ENTERED;
                        if (target != this) {
                            target.dispatchDragEvent(event);
                            target.mPrivateFlags2 |= View.PFLAG2_DRAG_HOVERED;
                            target.refreshDrawableState();
                        } else {
                            super.dispatchDragEvent(event);
                        }
                    }
                    // restore the event's original state
                    event.mAction = action;
                    event.mX = tx;
                    event.mY = ty;
                }
                // Dispatch the actual drag location notice, localized into its coordinates
                if (target != null) {
                    if (target != this) {
                        event.mX = localPoint.x;
                        event.mY = localPoint.y;
                        retval = target.dispatchDragEvent(event);
                        event.mX = tx;
                        event.mY = ty;
                    } else {
                        retval = super.dispatchDragEvent(event);
                    }
                }
            }
            break;
        case DragEvent.ACTION_DRAG_EXITED:
            {
                if (mCurrentDragView != null) {
                    final View view = mCurrentDragView;
                    if (view != this) {
                        view.dispatchDragEvent(event);
                        view.mPrivateFlags2 &= ~View.PFLAG2_DRAG_HOVERED;
                        view.refreshDrawableState();
                    } else {
                        super.dispatchDragEvent(event);
                    }
                    mCurrentDragView = null;
                }
            }
            break;
        case DragEvent.ACTION_DROP:
            {
                if (ViewDebug.DEBUG_DRAG)
                    Log.d(View.VIEW_LOG_TAG, ""Drop event: "" + event);
                View target = findFrontmostDroppableChildAt(event.mX, event.mY, localPoint);
                if (target != null) {
                    if (ViewDebug.DEBUG_DRAG)
                        Log.d(View.VIEW_LOG_TAG, ""   dispatch drop to "" + target);
                    event.mX = localPoint.x;
                    event.mY = localPoint.y;
                    retval = target.dispatchDragEvent(event);
                    event.mX = tx;
                    event.mY = ty;
                } else if (mIsInterestedInDrag) {
                    retval = super.dispatchDragEvent(event);
                } else {
                    if (ViewDebug.DEBUG_DRAG) {
                        Log.d(View.VIEW_LOG_TAG, ""   not dropped on an accepting view"");
                    }
                }
            }
            break;
    }
    return retval;
}","{
    boolean retval = false;
    final float tx = event.mX;
    final float ty = event.mY;
    final ClipData td = event.mClipData;
    // Dispatch down the view hierarchy
    final PointF localPoint = getLocalPoint();
    switch(event.mAction) {
        case DragEvent.ACTION_DRAG_STARTED:
            {
                // Clear the state to recalculate which views we drag over.
                mCurrentDragChild = null;
                // Set up our tracking of drag-started notifications
                mCurrentDragStartEvent = DragEvent.obtain(event);
                if (mChildrenInterestedInDrag == null) {
                    mChildrenInterestedInDrag = new HashSet<View>();
                } else {
                    mChildrenInterestedInDrag.clear();
                }
                // Now dispatch down to our children, caching the responses
                final int count = mChildrenCount;
                final View[] children = mChildren;
                for (int i = 0; i < count; i++) {
                    final View child = children[i];
                    child.mPrivateFlags2 &= ~View.DRAG_MASK;
                    if (child.getVisibility() == VISIBLE) {
                        if (notifyChildOfDragStart(children[i])) {
                            retval = true;
                        }
                    }
                }
                // Notify itself of the drag start.
                mIsInterestedInDrag = super.dispatchDragEvent(event);
                if (mIsInterestedInDrag) {
                    retval = true;
                }
                if (!retval) {
                    // Neither us nor any of our children are interested in this drag, so stop tracking
                    // the current drag event.
                    mCurrentDragStartEvent.recycle();
                    mCurrentDragStartEvent = null;
                }
            }
            break;
        case DragEvent.ACTION_DRAG_ENDED:
            {
                // Release the bookkeeping now that the drag lifecycle has ended
                final HashSet<View> childrenInterestedInDrag = mChildrenInterestedInDrag;
                if (childrenInterestedInDrag != null) {
                    for (View child : childrenInterestedInDrag) {
                        // If a child was interested in the ongoing drag, it's told that it's over
                        if (child.dispatchDragEvent(event)) {
                            retval = true;
                        }
                    }
                    childrenInterestedInDrag.clear();
                }
                if (mCurrentDragStartEvent != null) {
                    mCurrentDragStartEvent.recycle();
                    mCurrentDragStartEvent = null;
                }
                if (mIsInterestedInDrag) {
                    if (super.dispatchDragEvent(event)) {
                        retval = true;
                    }
                    mIsInterestedInDrag = false;
                }
            }
            break;
        case DragEvent.ACTION_DRAG_LOCATION:
        case DragEvent.ACTION_DROP:
            {
                // Find the [possibly new] drag target
                View target = findFrontmostDroppableChildAt(event.mX, event.mY, localPoint);
                if (target != mCurrentDragChild) {
                    if (sCascadedDragDrop) {
                        // For pre-Nougat apps, make sure that the whole hierarchy of views that contain
                        // the drag location is kept in the state between ENTERED and EXITED events.
                        // (Starting with N, only the innermost view will be in that state).
                        final int action = event.mAction;
                        // Position should not be available for ACTION_DRAG_ENTERED and
                        // ACTION_DRAG_EXITED.
                        event.mX = 0;
                        event.mY = 0;
                        event.mClipData = null;
                        if (mCurrentDragChild != null) {
                            event.mAction = DragEvent.ACTION_DRAG_EXITED;
                            mCurrentDragChild.dispatchDragEnterExitInPreN(event);
                        }
                        if (target != null) {
                            event.mAction = DragEvent.ACTION_DRAG_ENTERED;
                            target.dispatchDragEnterExitInPreN(event);
                        }
                        event.mAction = action;
                        event.mX = tx;
                        event.mY = ty;
                        event.mClipData = td;
                    }
                    mCurrentDragChild = target;
                }
                if (target == null && mIsInterestedInDrag) {
                    target = this;
                }
                // Dispatch the actual drag notice, localized into the target coordinates.
                if (target != null) {
                    if (target != this) {
                        event.mX = localPoint.x;
                        event.mY = localPoint.y;
                        retval = target.dispatchDragEvent(event);
                        event.mX = tx;
                        event.mY = ty;
                        if (mIsInterestedInDrag) {
                            final boolean eventWasConsumed;
                            if (sCascadedDragDrop) {
                                eventWasConsumed = retval;
                            } else {
                                eventWasConsumed = event.mEventHandlerWasCalled;
                            }
                            if (!eventWasConsumed) {
                                retval = super.dispatchDragEvent(event);
                            }
                        }
                    } else {
                        retval = super.dispatchDragEvent(event);
                    }
                }
            }
            break;
    }
    return retval;
}",1,"// TODO: Write real docs
","// TODO: Write real docs
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
854,"<android.app.Activity: void requestPermissions(String[],int)>",25,26,"<android.app.Activity: void requestPermissions(String[],int)>","<android.app.Activity: void requestPermissions(String[],int)>",0,"{
    if (mHasCurrentPermissionsRequest) {
        Log.w(TAG, ""Can reqeust only one set of permissions at a time"");
        // Dispatch the callback with empty arrays which means a cancellation.
        onRequestPermissionsResult(requestCode, new String[0], new int[0]);
        return;
    }
    Intent intent = getPackageManager().buildRequestPermissionsIntent(permissions);
    startActivityForResult(REQUEST_PERMISSIONS_WHO_PREFIX, intent, requestCode, null);
    mHasCurrentPermissionsRequest = true;
}","{
    if (requestCode < 0) {
        throw new IllegalArgumentException(""requestCode should be >= 0"");
    }
    if (mHasCurrentPermissionsRequest) {
        Log.w(TAG, ""Can reqeust only one set of permissions at a time"");
        // Dispatch the callback with empty arrays which means a cancellation.
        onRequestPermissionsResult(requestCode, new String[0], new int[0]);
        return;
    }
    Intent intent = getPackageManager().buildRequestPermissionsIntent(permissions);
    startActivityForResult(REQUEST_PERMISSIONS_WHO_PREFIX, intent, requestCode, null);
    mHasCurrentPermissionsRequest = true;
}",1,"/**
 * Requests permissions to be granted to this application. These permissions
 * must be requested in your manifest, they should not be granted to your app,
 * and they should have protection level {@link android.content.pm.PermissionInfo
 * #PROTECTION_DANGEROUS dangerous}, regardless whether they are declared by
 * the platform or a third-party app.
 * <p>
 * Normal permissions {@link android.content.pm.PermissionInfo#PROTECTION_NORMAL}
 * are granted at install time if requested in the manifest. Signature permissions
 * {@link android.content.pm.PermissionInfo#PROTECTION_SIGNATURE} are granted at
 * install time if requested in the manifest and the signature of your app matches
 * the signature of the app declaring the permissions.
 * </p>
 * <p>
 * If your app does not have the requested permissions the user will be presented
 * with UI for accepting them. After the user has accepted or rejected the
 * requested permissions you will receive a callback on {@link
 * #onRequestPermissionsResult(int, String[], int[])} reporting whether the
 * permissions were granted or not.
 * </p>
 * <p>
 * Note that requesting a permission does not guarantee it will be granted and
 * your app should be able to run without having this permission.
 * </p>
 * <p>
 * This method may start an activity allowing the user to choose which permissions
 * to grant and which to reject. Hence, you should be prepared that your activity
 * may be paused and resumed. Further, granting some permissions may require
 * a restart of you application. In such a case, the system will recreate the
 * activity stack before delivering the result to {@link
 * #onRequestPermissionsResult(int, String[], int[])}.
 * </p>
 * <p>
 * When checking whether you have a permission you should use {@link
 * #checkSelfPermission(String)}.
 * </p>
 * <p>
 * Calling this API for permissions already granted to your app would show UI
 * to the user to decide whether the app can still hold these permissions. This
 * can be useful if the way your app uses data guarded by the permissions
 * changes significantly.
 * </p>
 * <p>
 * You cannot request a permission if your activity sets {@link
 * android.R.styleable#AndroidManifestActivity_noHistory noHistory} to
 * <code>true</code> because in this case the activity would not receive
 * result callbacks including {@link #onRequestPermissionsResult(int, String[], int[])}.
 * </p>
 * <p>
 * The <a href=""http://developer.android.com/samples/RuntimePermissions/index.html"">
 * RuntimePermissions</a> sample app demonstrates how to use this method to
 * request permissions at run time.
 * </p>
 *
 * @param permissions The requested permissions. Must me non-null and not empty.
 * @param requestCode Application specific request code to match with a result
 * reported to {@link #onRequestPermissionsResult(int, String[], int[])}.
 * Should be >= 0.
 *
 * @see #onRequestPermissionsResult(int, String[], int[])
 * @see #checkSelfPermission(String)
 * @see #shouldShowRequestPermissionRationale(String)
 */
","/**
 * Requests permissions to be granted to this application. These permissions
 * must be requested in your manifest, they should not be granted to your app,
 * and they should have protection level {@link android.content.pm.PermissionInfo
 * #PROTECTION_DANGEROUS dangerous}, regardless whether they are declared by
 * the platform or a third-party app.
 * <p>
 * Normal permissions {@link android.content.pm.PermissionInfo#PROTECTION_NORMAL}
 * are granted at install time if requested in the manifest. Signature permissions
 * {@link android.content.pm.PermissionInfo#PROTECTION_SIGNATURE} are granted at
 * install time if requested in the manifest and the signature of your app matches
 * the signature of the app declaring the permissions.
 * </p>
 * <p>
 * If your app does not have the requested permissions the user will be presented
 * with UI for accepting them. After the user has accepted or rejected the
 * requested permissions you will receive a callback on {@link
 * #onRequestPermissionsResult(int, String[], int[])} reporting whether the
 * permissions were granted or not.
 * </p>
 * <p>
 * Note that requesting a permission does not guarantee it will be granted and
 * your app should be able to run without having this permission.
 * </p>
 * <p>
 * This method may start an activity allowing the user to choose which permissions
 * to grant and which to reject. Hence, you should be prepared that your activity
 * may be paused and resumed. Further, granting some permissions may require
 * a restart of you application. In such a case, the system will recreate the
 * activity stack before delivering the result to {@link
 * #onRequestPermissionsResult(int, String[], int[])}.
 * </p>
 * <p>
 * When checking whether you have a permission you should use {@link
 * #checkSelfPermission(String)}.
 * </p>
 * <p>
 * Calling this API for permissions already granted to your app would show UI
 * to the user to decide whether the app can still hold these permissions. This
 * can be useful if the way your app uses data guarded by the permissions
 * changes significantly.
 * </p>
 * <p>
 * You cannot request a permission if your activity sets {@link
 * android.R.styleable#AndroidManifestActivity_noHistory noHistory} to
 * <code>true</code> because in this case the activity would not receive
 * result callbacks including {@link #onRequestPermissionsResult(int, String[], int[])}.
 * </p>
 * <p>
 * The <a href=""http://developer.android.com/samples/RuntimePermissions/index.html"">
 * RuntimePermissions</a> sample app demonstrates how to use this method to
 * request permissions at run time.
 * </p>
 *
 * @param permissions The requested permissions. Must me non-null and not empty.
 * @param requestCode Application specific request code to match with a result
 * reported to {@link #onRequestPermissionsResult(int, String[], int[])}.
 * Should be >= 0.
 *
 * @throws IllegalArgumentException if requestCode is negative.
 *
 * @see #onRequestPermissionsResult(int, String[], int[])
 * @see #checkSelfPermission(String)
 * @see #shouldShowRequestPermissionRationale(String)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"An exception check (if (requestCode < 0)) is added at the very beginning of the method, which results in a new potential exception being thrown, so the code change type is 2. Since an 'if' statement is added, it also includes a control dependency change with type 3.","The newly introduced exception check can lead to a new IllegalArgumentException being thrown if the condition is met, which was not possible in the early version. Therefore, a Compatibility Issue of type 2 is present."
855,<android.app.Activity: void onBackPressed()>,25,26,<android.app.Activity: void onBackPressed()>,<android.app.Activity: void onBackPressed()>,0,"{
    if (mActionBar != null && mActionBar.collapseActionView()) {
        return;
    }
    if (!mFragments.getFragmentManager().popBackStackImmediate()) {
        finishAfterTransition();
    }
}","{
    if (mActionBar != null && mActionBar.collapseActionView()) {
        return;
    }
    FragmentManager fragmentManager = mFragments.getFragmentManager();
    if (fragmentManager.isStateSaved() || !fragmentManager.popBackStackImmediate()) {
        finishAfterTransition();
    }
}",1,"/**
 * Called when the activity has detected the user's press of the back
 * key.  The default implementation simply finishes the current activity,
 * but you can override this to do whatever you want.
 */
","/**
 * Called when the activity has detected the user's press of the back
 * key.  The default implementation simply finishes the current activity,
 * but you can override this to do whatever you want.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The late version introduces a temporary variable FragmentManager and a new condition check with fragmentManager.isStateSaved(). This is a combination of control dependency change (3) because there's a new condition in the if statement, and other statement change (4) because of the introduction of a new local variable within the method.","Despite the new condition check and local variable, there is no CI here because the overall behavior of onBackPressed() remains consistent between versions. The additional isStateSaved() check is to determine if fragment transactions can be altered, and if not, the method proceeds to finishAfterTransition(), which aligns with the overall purpose of the method in both versions. The change is aimed at proper state management without altering the external behavior."
856,"<android.widget.PopupWindow: int getMaxAvailableHeight(View,int,boolean)>",25,26,"<android.widget.PopupWindow: int getMaxAvailableHeight(View,int,boolean)>","<android.widget.PopupWindow: int getMaxAvailableHeight(View,int,boolean)>",0,"{
    final Rect displayFrame = new Rect();
    if (ignoreBottomDecorations) {
        anchor.getWindowDisplayFrame(displayFrame);
    } else {
        anchor.getWindowVisibleDisplayFrame(displayFrame);
    }
    final int[] anchorPos = mTmpDrawingLocation;
    anchor.getLocationOnScreen(anchorPos);
    final int bottomEdge = displayFrame.bottom;
    final int distanceToBottom;
    if (mOverlapAnchor) {
        distanceToBottom = bottomEdge - anchorPos[1] - yOffset;
    } else {
        distanceToBottom = bottomEdge - (anchorPos[1] + anchor.getHeight()) - yOffset;
    }
    final int distanceToTop = anchorPos[1] - displayFrame.top + yOffset;
    // anchorPos[1] is distance from anchor to top of screen
    int returnedHeight = Math.max(distanceToBottom, distanceToTop);
    if (mBackground != null) {
        mBackground.getPadding(mTempRect);
        returnedHeight -= mTempRect.top + mTempRect.bottom;
    }
    return returnedHeight;
}","{
    Rect displayFrame = null;
    final Rect visibleDisplayFrame = new Rect();
    final View appView = getAppRootView(anchor);
    appView.getWindowVisibleDisplayFrame(visibleDisplayFrame);
    if (ignoreBottomDecorations) {
        // In the ignore bottom decorations case we want to
        // still respect all other decorations so we use the inset visible
        // frame on the top right and left and take the bottom
        // value from the full frame.
        displayFrame = new Rect();
        anchor.getWindowDisplayFrame(displayFrame);
        displayFrame.top = visibleDisplayFrame.top;
        displayFrame.right = visibleDisplayFrame.right;
        displayFrame.left = visibleDisplayFrame.left;
    } else {
        displayFrame = visibleDisplayFrame;
    }
    final int[] anchorPos = mTmpDrawingLocation;
    anchor.getLocationOnScreen(anchorPos);
    final int bottomEdge = displayFrame.bottom;
    final int distanceToBottom;
    if (mOverlapAnchor) {
        distanceToBottom = bottomEdge - anchorPos[1] - yOffset;
    } else {
        distanceToBottom = bottomEdge - (anchorPos[1] + anchor.getHeight()) - yOffset;
    }
    final int distanceToTop = anchorPos[1] - displayFrame.top + yOffset;
    // anchorPos[1] is distance from anchor to top of screen
    int returnedHeight = Math.max(distanceToBottom, distanceToTop);
    if (mBackground != null) {
        mBackground.getPadding(mTempRect);
        returnedHeight -= mTempRect.top + mTempRect.bottom;
    }
    return returnedHeight;
}",1,"/**
 * Returns the maximum height that is available for the popup to be
 * completely shown, optionally ignoring any bottom decorations such as
 * the input method. It is recommended that this height be the maximum for
 * the popup's height, otherwise it is possible that the popup will be
 * clipped.
 *
 * @param anchor The view on which the popup window must be anchored.
 * @param yOffset y offset from the view's bottom edge
 * @param ignoreBottomDecorations if true, the height returned will be
 * all the way to the bottom of the display, ignoring any
 * bottom decorations
 * @return The maximum available height for the popup to be completely
 * shown.
 */
","/**
 * Returns the maximum height that is available for the popup to be
 * completely shown, optionally ignoring any bottom decorations such as
 * the input method. It is recommended that this height be the maximum for
 * the popup's height, otherwise it is possible that the popup will be
 * clipped.
 *
 * @param anchor The view on which the popup window must be anchored.
 * @param yOffset y offset from the view's bottom edge
 * @param ignoreBottomDecorations if true, the height returned will be
 * all the way to the bottom of the display, ignoring any
 * bottom decorations
 * @return The maximum available height for the popup to be completely
 * shown.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,The code change includes:,"- Changes to logic that calculates 'returnedHeight', involving new conditionals and calculations. This is a return statement change (1)."
858,<android.app.ContextImpl: void removeStickyBroadcast(Intent)>,25,26,<android.app.ContextImpl: void removeStickyBroadcast(Intent)>,<android.app.ContextImpl: void removeStickyBroadcast(Intent)>,0,"{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    if (resolvedType != null) {
        intent = new Intent(intent);
        intent.setDataAndType(intent.getData(), resolvedType);
    }
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManagerNative.getDefault().unbroadcastIntent(mMainThread.getApplicationThread(), intent, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    if (resolvedType != null) {
        intent = new Intent(intent);
        intent.setDataAndType(intent.getData(), resolvedType);
    }
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().unbroadcastIntent(mMainThread.getApplicationThread(), intent, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,"[@Override, @Deprecated]","[@Override, @Deprecated]",-1,-1,-1,-1,-1,-1,5,0,The API method ActivityManagerNative.getDefault() has been changed to ActivityManager.getService() but there is no change in the method parameters or its usage. So the code change type is 5.,"Since the method signature for the method of the dependent API used within this method is unchanged (same method name, parameters, and expected behaviour), it does not cause a difference in the API's output or in the type of exceptions thrown. Therefore, there is no Compatibility Issue."
861,<android.widget.VideoView: boolean onTrackballEvent(MotionEvent)>,25,26,<android.widget.VideoView: boolean onTrackballEvent(MotionEvent)>,<android.widget.VideoView: boolean onTrackballEvent(MotionEvent)>,0,"{
    if (isInPlaybackState() && mMediaController != null) {
        toggleMediaControlsVisiblity();
    }
    return false;
}","{
    if (ev.getAction() == MotionEvent.ACTION_DOWN && isInPlaybackState() && mMediaController != null) {
        toggleMediaControlsVisiblity();
    }
    return super.onTrackballEvent(ev);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",0,"The control expression of the 'if' condition has been changed to include checking the action of the MotionEvent. Additionally, the return statement has been altered to `return super.onTrackballEvent(ev)` instead of `return false`. There's also the implicit change of using the event `ev` in the late implementation, which is also classified as 4, an 'Other statement changed'. Therefore, the change type is 1,3,4.","Although there is a change in the implementation, it does not necessarily introduce a CI because the return statement now depends on the parent class's implementation of `onTrackballEvent`. If the superclass's method returns false, then there will be no behavior change. The modification in the control statement additionally does not introduce a change in the API’s behavior that would cause a different return value unless the parent class’s implementation behaves differently on the ACTION_DOWN event. Therefore, based on the information given and assuming that the superclass behavior is consistent with returning false, we have no CI as per your definition."
862,"<android.app.admin.DevicePolicyManager: boolean setApplicationHidden(ComponentName,String,boolean)>",25,26,"<android.app.admin.DevicePolicyManager: boolean setApplicationHidden(ComponentName,String,boolean)>","<android.app.admin.DevicePolicyManager: boolean setApplicationHidden(ComponentName,String,boolean)>",0,"{
    throwIfParentInstance(""setApplicationHidden"");
    if (mService != null) {
        try {
            return mService.setApplicationHidden(admin, packageName, hidden);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return false;
}","{
    throwIfParentInstance(""setApplicationHidden"");
    if (mService != null) {
        try {
            return mService.setApplicationHidden(admin, mContext.getPackageName(), packageName, hidden);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return false;
}",1,"/**
 * Called by profile or device owners to hide or unhide packages. When a package is hidden it is
 * unavailable for use, but the data and actual package file remain.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param packageName The name of the package to hide or unhide.
 * @param hidden {@code true} if the package should be hidden, {@code false} if it should be
 * unhidden.
 * @return boolean Whether the hidden setting of the package was successfully updated.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 */
","/**
 * Hide or unhide packages. When a package is hidden it is unavailable for use, but the data and
 * actual package file remain. This function can be called by a device owner, profile owner, or
 * by a delegate given the {@link #DELEGATION_PACKAGE_ACCESS} scope via
 * {@link #setDelegatedScopes}.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or
 * {@code null} if the caller is a package access delegate.
 * @param packageName The name of the package to hide or unhide.
 * @param hidden {@code true} if the package should be hidden, {@code false} if it should be
 * unhidden.
 * @return boolean Whether the hidden setting of the package was successfully updated.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 * @see #setDelegatedScopes
 * @see #DELEGATION_PACKAGE_ACCESS
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,"The method setApplicationHidden being called on mService has a new parameter added: mContext.getPackageName(). Thus, the method signature that is being called has changed, indicating a code change type of 5.","Since the dependent API mService.setApplicationHidden now includes an additional parameter, the behavior of the method could be different if mContext.getPackageName() changes the logic within the setApplicationHidden method. This constitutes a potential Compatibility Issue due to a change in dependent API behavior which can lead to different return values, so the CI type is 1."
863,"<android.app.ContextImpl: ComponentName startServiceAsUser(Intent,UserHandle)>",25,26,"<android.app.ContextImpl: ComponentName startServiceAsUser(Intent,UserHandle)>","<android.app.ContextImpl: ComponentName startServiceAsUser(Intent,UserHandle)>",0,"{
    return startServiceCommon(service, user);
}","{
    return startServiceCommon(service, false, user);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The method signature for 'startServiceCommon' has changed by adding a boolean parameter in the late version, which indicates a dependent API has changed, so the code change type is 5.","Even though the dependent API 'startServiceCommon' has added an extra parameter, there's no indication that the return type of the method has changed or that a different exception will be thrown. The actual handling of potential compatibility issues would depend on the implementation of 'startServiceCommon'. With the information given, we cannot conclude there is a compatibility issue thus the CI type is 0."
865,<android.view.accessibility.AccessibilityWindowInfo: String toString()>,25,26,<android.view.accessibility.AccessibilityWindowInfo: String toString()>,<android.view.accessibility.AccessibilityWindowInfo: String toString()>,0,"{
    StringBuilder builder = new StringBuilder();
    builder.append(""AccessibilityWindowInfo["");
    builder.append(""title="").append(mTitle);
    builder.append(""id="").append(mId);
    builder.append("", type="").append(typeToString(mType));
    builder.append("", layer="").append(mLayer);
    builder.append("", bounds="").append(mBoundsInScreen);
    builder.append("", focused="").append(isFocused());
    builder.append("", active="").append(isActive());
    if (DEBUG) {
        builder.append("", parent="").append(mParentId);
        builder.append("", children=["");
        if (mChildIds != null) {
            final int childCount = mChildIds.size();
            for (int i = 0; i < childCount; i++) {
                builder.append(mChildIds.get(i));
                if (i < childCount - 1) {
                    builder.append(',');
                }
            }
        } else {
            builder.append(""null"");
        }
        builder.append(']');
    } else {
        builder.append("", hasParent="").append(mParentId != UNDEFINED);
        builder.append("", isAnchored="").append(mAnchorId != UNDEFINED);
        builder.append("", hasChildren="").append(mChildIds != null && mChildIds.size() > 0);
    }
    builder.append(']');
    return builder.toString();
}","{
    StringBuilder builder = new StringBuilder();
    builder.append(""AccessibilityWindowInfo["");
    builder.append(""title="").append(mTitle);
    builder.append(""id="").append(mId);
    builder.append("", type="").append(typeToString(mType));
    builder.append("", layer="").append(mLayer);
    builder.append("", bounds="").append(mBoundsInScreen);
    builder.append("", focused="").append(isFocused());
    builder.append("", active="").append(isActive());
    builder.append("", pictureInPicture="").append(inPictureInPicture());
    if (DEBUG) {
        builder.append("", parent="").append(mParentId);
        builder.append("", children=["");
        if (mChildIds != null) {
            final int childCount = mChildIds.size();
            for (int i = 0; i < childCount; i++) {
                builder.append(mChildIds.get(i));
                if (i < childCount - 1) {
                    builder.append(',');
                }
            }
        } else {
            builder.append(""null"");
        }
        builder.append(']');
    } else {
        builder.append("", hasParent="").append(mParentId != UNDEFINED_WINDOW_ID);
        builder.append("", isAnchored="").append(mAnchorId != UNDEFINED_WINDOW_ID);
        builder.append("", hasChildren="").append(mChildIds != null && mChildIds.size() > 0);
    }
    builder.append(']');
    return builder.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"A new string representation, ""pictureInPicture="", and its boolean return from inPictureInPicture() have been introduced to the StringBuilder. Additionally, UNDEFINED has been changed to UNDEFINED_WINDOW_ID, which is just a change in the constant reference. The overall structure of the control flow remains the same, so it is classified under 'Other statement changed'.","No Compatibility Issue is introduced because the toString() method's contract is generally meant to provide a convenient string representation of the object for debugging or logging. This change does not affect the object's state or behavior as exposed via its API, and clients should not be programmatically relying on the format of the string representation. Therefore, this alteration does not constitute a compatibility issue."
866,<android.app.Fragment: void setArguments(Bundle)>,25,26,<android.app.Fragment: void setArguments(Bundle)>,<android.app.Fragment: void setArguments(Bundle)>,0,"{
    if (mIndex >= 0) {
        throw new IllegalStateException(""Fragment already active"");
    }
    mArguments = args;
}","{
    // See method javadoc.
    if (mIndex >= 0 && isStateSaved()) {
        throw new IllegalStateException(""Fragment already active"");
    }
    mArguments = args;
}",1,"/**
 * Supply the construction arguments for this fragment.  This can only
 * be called before the fragment has been attached to its activity; that
 * is, you should call it immediately after constructing the fragment.  The
 * arguments supplied here will be retained across fragment destroy and
 * creation.
 */
","/**
 * Supply the construction arguments for this fragment.
 * The arguments supplied here will be retained across fragment destroy and
 * creation.
 *
 * <p>This method cannot be called if the fragment is added to a FragmentManager and
 * if {@link #isStateSaved()} would return true. Prior to {@link Build.VERSION_CODES#O},
 * this method may only be called if the fragment has not yet been added to a FragmentManager.
 * </p>
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The condition for throwing `IllegalStateException` has been enhanced with an additional check `isStateSaved()`, which alters the control dependency, thus the code change type is 3.","The added condition `isStateSaved()` makes the exception throw more restrictive. However, it does not lead to a compatibility issue because it does not change the behavior in any way that would affect existing clients negatively; rather, it prevents the exception from being thrown in a new state that wasn't checked before. Therefore, the CI type is 0."
867,<android.app.KeyguardManager: boolean isDeviceLocked()>,25,26,<android.app.KeyguardManager: boolean isDeviceLocked()>,<android.app.KeyguardManager: boolean isDeviceLocked()>,0,"{
    return isDeviceLocked(UserHandle.getCallingUserId());
}","{
    return isDeviceLocked(UserHandle.myUserId());
}",1,"/**
 * Returns whether the device is currently locked and requires a PIN, pattern or
 * password to unlock.
 *
 * @return true if unlocking the device currently requires a PIN, pattern or
 * password.
 */
","/**
 * Returns whether the device is currently locked and requires a PIN, pattern or
 * password to unlock.
 *
 * @return true if unlocking the device currently requires a PIN, pattern or
 * password.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The method call within the return statement changed from `isDeviceLocked(UserHandle.getCallingUserId())` to `isDeviceLocked(UserHandle.myUserId())`, indicating a change in which user identifier is used to determine if the device is locked. This change is classified under 'Other statement changed' and 'Dependent API changed', so the code change type is 4,5.","The change in user identifier from 'getCallingUserId' to 'myUserId' could cause the API to return different values under some circumstances (e.g., when a different user is considered the current user), hence there is a potential Compatibility Issue caused by potentially different return values, which is type 1."
868,<android.bluetooth.le.BluetoothLeScanner.BleScanCallbackWrapper: void stopLeScan()>,25,26,<android.bluetooth.le.BluetoothLeScanner.BleScanCallbackWrapper: void stopLeScan()>,<android.bluetooth.le.BluetoothLeScanner.BleScanCallbackWrapper: void stopLeScan()>,0,"{
    synchronized (this) {
        if (mClientIf <= 0) {
            Log.e(TAG, ""Error state, mLeHandle: "" + mClientIf);
            return;
        }
        try {
            mBluetoothGatt.stopScan(mClientIf, false);
            mBluetoothGatt.unregisterClient(mClientIf);
        } catch (RemoteException e) {
            Log.e(TAG, ""Failed to stop scan and unregister"", e);
        }
        mClientIf = -1;
    }
}","{
    synchronized (this) {
        if (mScannerId <= 0) {
            Log.e(TAG, ""Error state, mLeHandle: "" + mScannerId);
            return;
        }
        try {
            mBluetoothGatt.stopScan(mScannerId);
            mBluetoothGatt.unregisterScanner(mScannerId);
        } catch (RemoteException e) {
            Log.e(TAG, ""Failed to stop scan and unregister"", e);
        }
        mScannerId = -1;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",0,"The control statement in if(mClientIf <= 0) changed to if(mScannerId <= 0), and the log message also changed accordingly, which denotes a change in control dependency (3). The method calls within the try block have changed from mBluetoothGatt.stopScan(mClientIf, false) to mBluetoothGatt.stopScan(mScannerId) and mBluetoothGatt.unregisterClient(mClientIf) to mBluetoothGatt.unregisterScanner(mScannerId), and these changes are changes to other statements (4), as well as changes to dependent APIs because of the signature change from stopScan with two parameters to one with a single parameter, and from unregisterClient to unregisterScanner (5).","There's no Compatibility Issue because the API maintains the same behavior. The change in variable name from mClientIf to mScannerId and corresponding method calls does not affect the contract of the method. The changed methods (stopScan and unregisterScanner) are used internally and do not alter the public behavior of the stopLeScan() method. The removal of the 'false' parameter in stopScan(mScannerId) may be due to a change in the underlying implementation, which the clients are abstracted from in the method. There is no change in the control flow that would affect the external behavior or the exceptions that this method would send to its caller. Hence, no CI is detected (0)."
869,"<android.app.ContextImpl: boolean startInstrumentation(ComponentName,String,Bundle)>",25,26,"<android.app.ContextImpl: boolean startInstrumentation(ComponentName,String,Bundle)>","<android.app.ContextImpl: boolean startInstrumentation(ComponentName,String,Bundle)>",0,"{
    try {
        if (arguments != null) {
            arguments.setAllowFds(false);
        }
        return ActivityManagerNative.getDefault().startInstrumentation(className, profileFile, 0, arguments, null, null, getUserId(), null);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        if (arguments != null) {
            arguments.setAllowFds(false);
        }
        return ActivityManager.getService().startInstrumentation(className, profileFile, 0, arguments, null, null, getUserId(), null);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The method call within the return statement has changed from ActivityManagerNative.getDefault().startInstrumentation to ActivityManager.getService().startInstrumentation. This indicates a change of the dependent API that this method uses, making it a type 5 change.","Since only the internal API call changed but not the parameters or the behavior of how exceptions are handled, nor did the modification affect control flows in the method itself, there is no indication that these changes would result in a different value being returned or a different exception being thrown under identical circumstances. Hence, there is no Compatibility Issue, so the CI type is 0."
871,"<android.app.Instrumentation: Activity newActivity(Class<?>,Context,IBinder,Application,Intent,ActivityInfo,CharSequence,Activity,String,Object)>",25,26,"<android.app.Instrumentation: Activity newActivity(Class<?>,Context,IBinder,Application,Intent,ActivityInfo,CharSequence,Activity,String,Object)>","<android.app.Instrumentation: Activity newActivity(Class<?>,Context,IBinder,Application,Intent,ActivityInfo,CharSequence,Activity,String,Object)>",0,"{
    Activity activity = (Activity) clazz.newInstance();
    ActivityThread aThread = null;
    activity.attach(context, aThread, this, token, 0, application, intent, info, title, parent, id, (Activity.NonConfigurationInstances) lastNonConfigurationInstance, new Configuration(), null, null, null);
    return activity;
}","{
    Activity activity = (Activity) clazz.newInstance();
    ActivityThread aThread = null;
    activity.attach(context, aThread, this, token, 0, /* ident */
    application, intent, info, title, parent, id, (Activity.NonConfigurationInstances) lastNonConfigurationInstance, new Configuration(), null, /* referrer */
    null, /* voiceInteractor */
    null, /* window */
    null);
    return activity;
}",1,"/**
 * Perform instantiation of an {@link Activity} object.  This method is intended for use with
 * unit tests, such as android.test.ActivityUnitTestCase.  The activity will be useable
 * locally but will be missing some of the linkages necessary for use within the sytem.
 *
 * @param clazz The Class of the desired Activity
 * @param context The base context for the activity to use
 * @param token The token for this activity to communicate with
 * @param application The application object (if any)
 * @param intent The intent that started this Activity
 * @param info ActivityInfo from the manifest
 * @param title The title, typically retrieved from the ActivityInfo record
 * @param parent The parent Activity (if any)
 * @param id The embedded Id (if any)
 * @param lastNonConfigurationInstance Arbitrary object that will be
 * available via {@link Activity#getLastNonConfigurationInstance()
 * Activity.getLastNonConfigurationInstance()}.
 * @return Returns the instantiated activity
 * @throws InstantiationException
 * @throws IllegalAccessException
 */
","/**
 * Perform instantiation of an {@link Activity} object.  This method is intended for use with
 * unit tests, such as android.test.ActivityUnitTestCase.  The activity will be useable
 * locally but will be missing some of the linkages necessary for use within the system.
 *
 * @param clazz The Class of the desired Activity
 * @param context The base context for the activity to use
 * @param token The token for this activity to communicate with
 * @param application The application object (if any)
 * @param intent The intent that started this Activity
 * @param info ActivityInfo from the manifest
 * @param title The title, typically retrieved from the ActivityInfo record
 * @param parent The parent Activity (if any)
 * @param id The embedded Id (if any)
 * @param lastNonConfigurationInstance Arbitrary object that will be
 * available via {@link Activity#getLastNonConfigurationInstance()
 * Activity.getLastNonConfigurationInstance()}.
 * @return Returns the instantiated activity
 * @throws InstantiationException
 * @throws IllegalAccessException
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The actual code within the method implementation did not change; only comments were added for clarity. Therefore, the change type is 4.","Comments do not affect the functionality or behavior of the code, so they will not cause compatibility issues. The CI type is 0."
872,<android.content.IntentSender: int getCreatorUid()>,25,26,<android.content.IntentSender: int getCreatorUid()>,<android.content.IntentSender: int getCreatorUid()>,0,"{
    try {
        return ActivityManagerNative.getDefault().getUidForIntentSender(mTarget);
    } catch (RemoteException e) {
        // Should never happen.
        return -1;
    }
}","{
    try {
        return ActivityManager.getService().getUidForIntentSender(mTarget);
    } catch (RemoteException e) {
        // Should never happen.
        return -1;
    }
}",1,"/**
 * Return the uid of the application that created this
 * PendingIntent, that is the identity under which you will actually be
 * sending the Intent.  The returned integer is supplied by the system, so
 * that an application can not spoof its uid.
 *
 * @return The uid of the PendingIntent, or -1 if there is
 * none associated with it.
 */
","/**
 * Return the uid of the application that created this
 * PendingIntent, that is the identity under which you will actually be
 * sending the Intent.  The returned integer is supplied by the system, so
 * that an application can not spoof its uid.
 *
 * @return The uid of the PendingIntent, or -1 if there is
 * none associated with it.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method call ActivityManagerNative.getDefault().getUidForIntentSender(mTarget) has been replaced with ActivityManager.getService().getUidForIntentSender(mTarget), which indicates a change in the dependent API. Therefore, the code change type is 5.","There is no Compatibility Issue detected because while the method to get the service has changed, the functionality and return type of getUidForIntentSender(mTarget) remain the same, and the overall logic and exception handling have not been altered. Hence, any previous code invoking getCreatorUid() would continue to behave the same way, assuming the new getService() method provides a valid instance of ActivityManager as getDefault() did."
873,<android.os.StrictMode.AndroidBlockGuardPolicy: void handleViolation(ViolationInfo)>,25,26,<android.os.StrictMode.AndroidBlockGuardPolicy: void handleViolation(ViolationInfo)>,<android.os.StrictMode.AndroidBlockGuardPolicy: void handleViolation(ViolationInfo)>,0,"{
    if (info == null || info.crashInfo == null || info.crashInfo.stackTrace == null) {
        Log.wtf(TAG, ""unexpected null stacktrace"");
        return;
    }
    if (LOG_V)
        Log.d(TAG, ""handleViolation; policy="" + info.policy);
    if ((info.policy & PENALTY_GATHER) != 0) {
        ArrayList<ViolationInfo> violations = gatheredViolations.get();
        if (violations == null) {
            violations = new ArrayList<ViolationInfo>(1);
            gatheredViolations.set(violations);
        } else if (violations.size() >= 5) {
            // Too many.  In a loop or something?  Don't gather them all.
            return;
        }
        for (ViolationInfo previous : violations) {
            if (info.crashInfo.stackTrace.equals(previous.crashInfo.stackTrace)) {
                // Duplicate. Don't log.
                return;
            }
        }
        violations.add(info);
        return;
    }
    // Not perfect, but fast and good enough for dup suppression.
    Integer crashFingerprint = info.hashCode();
    long lastViolationTime = 0;
    if (mLastViolationTime != null) {
        Long vtime = mLastViolationTime.get(crashFingerprint);
        if (vtime != null) {
            lastViolationTime = vtime;
        }
    } else {
        mLastViolationTime = new ArrayMap<Integer, Long>(1);
    }
    long now = SystemClock.uptimeMillis();
    mLastViolationTime.put(crashFingerprint, now);
    long timeSinceLastViolationMillis = lastViolationTime == 0 ? Long.MAX_VALUE : (now - lastViolationTime);
    if ((info.policy & PENALTY_LOG) != 0 && timeSinceLastViolationMillis > MIN_LOG_INTERVAL_MS) {
        if (info.durationMillis != -1) {
            Log.d(TAG, ""StrictMode policy violation; ~duration="" + info.durationMillis + "" ms: "" + info.crashInfo.stackTrace);
        } else {
            Log.d(TAG, ""StrictMode policy violation: "" + info.crashInfo.stackTrace);
        }
    }
    // The violationMaskSubset, passed to ActivityManager, is a
    // subset of the original StrictMode policy bitmask, with
    // only the bit violated and penalty bits to be executed
    // by the ActivityManagerService remaining set.
    int violationMaskSubset = 0;
    if ((info.policy & PENALTY_DIALOG) != 0 && timeSinceLastViolationMillis > MIN_DIALOG_INTERVAL_MS) {
        violationMaskSubset |= PENALTY_DIALOG;
    }
    if ((info.policy & PENALTY_DROPBOX) != 0 && lastViolationTime == 0) {
        violationMaskSubset |= PENALTY_DROPBOX;
    }
    if (violationMaskSubset != 0) {
        int violationBit = parseViolationFromMessage(info.crashInfo.exceptionMessage);
        violationMaskSubset |= violationBit;
        final int savedPolicyMask = getThreadPolicyMask();
        final boolean justDropBox = (info.policy & THREAD_PENALTY_MASK) == PENALTY_DROPBOX;
        if (justDropBox) {
            // If all we're going to ask the activity manager
            // to do is dropbox it (the common case during
            // platform development), we can avoid doing this
            // call synchronously which Binder data suggests
            // isn't always super fast, despite the implementation
            // in the ActivityManager trying to be mostly async.
            dropboxViolationAsync(violationMaskSubset, info);
            return;
        }
        // Normal synchronous call to the ActivityManager.
        try {
            // First, remove any policy before we call into the Activity Manager,
            // otherwise we'll infinite recurse as we try to log policy violations
            // to disk, thus violating policy, thus requiring logging, etc...
            // We restore the current policy below, in the finally block.
            setThreadPolicyMask(0);
            ActivityManagerNative.getDefault().handleApplicationStrictModeViolation(RuntimeInit.getApplicationObject(), violationMaskSubset, info);
        } catch (RemoteException e) {
            if (e instanceof DeadObjectException) {
            // System process is dead; ignore
            } else {
                Log.e(TAG, ""RemoteException trying to handle StrictMode violation"", e);
            }
        } finally {
            // Restore the policy.
            setThreadPolicyMask(savedPolicyMask);
        }
    }
    if ((info.policy & PENALTY_DEATH) != 0) {
        executeDeathPenalty(info);
    }
}","{
    if (info == null || info.crashInfo == null || info.crashInfo.stackTrace == null) {
        Log.wtf(TAG, ""unexpected null stacktrace"");
        return;
    }
    if (LOG_V)
        Log.d(TAG, ""handleViolation; policy="" + info.policy);
    if ((info.policy & PENALTY_GATHER) != 0) {
        ArrayList<ViolationInfo> violations = gatheredViolations.get();
        if (violations == null) {
            violations = new ArrayList<ViolationInfo>(1);
            gatheredViolations.set(violations);
        }
        for (ViolationInfo previous : violations) {
            if (info.crashInfo.stackTrace.equals(previous.crashInfo.stackTrace)) {
                // Duplicate. Don't log.
                return;
            }
        }
        violations.add(info);
        return;
    }
    // Not perfect, but fast and good enough for dup suppression.
    Integer crashFingerprint = info.hashCode();
    long lastViolationTime = 0;
    if (mLastViolationTime != null) {
        Long vtime = mLastViolationTime.get(crashFingerprint);
        if (vtime != null) {
            lastViolationTime = vtime;
        }
    } else {
        mLastViolationTime = new ArrayMap<Integer, Long>(1);
    }
    long now = SystemClock.uptimeMillis();
    mLastViolationTime.put(crashFingerprint, now);
    long timeSinceLastViolationMillis = lastViolationTime == 0 ? Long.MAX_VALUE : (now - lastViolationTime);
    if ((info.policy & PENALTY_LOG) != 0 && sListener != null) {
        sListener.onViolation(info.crashInfo.stackTrace);
    }
    if ((info.policy & PENALTY_LOG) != 0 && timeSinceLastViolationMillis > MIN_LOG_INTERVAL_MS) {
        if (info.durationMillis != -1) {
            Log.d(TAG, ""StrictMode policy violation; ~duration="" + info.durationMillis + "" ms: "" + info.crashInfo.stackTrace);
        } else {
            Log.d(TAG, ""StrictMode policy violation: "" + info.crashInfo.stackTrace);
        }
    }
    // The violationMaskSubset, passed to ActivityManager, is a
    // subset of the original StrictMode policy bitmask, with
    // only the bit violated and penalty bits to be executed
    // by the ActivityManagerService remaining set.
    int violationMaskSubset = 0;
    if ((info.policy & PENALTY_DIALOG) != 0 && timeSinceLastViolationMillis > MIN_DIALOG_INTERVAL_MS) {
        violationMaskSubset |= PENALTY_DIALOG;
    }
    if ((info.policy & PENALTY_DROPBOX) != 0 && lastViolationTime == 0) {
        violationMaskSubset |= PENALTY_DROPBOX;
    }
    if (violationMaskSubset != 0) {
        int violationBit = parseViolationFromMessage(info.crashInfo.exceptionMessage);
        violationMaskSubset |= violationBit;
        final int savedPolicyMask = getThreadPolicyMask();
        final boolean justDropBox = (info.policy & THREAD_PENALTY_MASK) == PENALTY_DROPBOX;
        if (justDropBox) {
            // If all we're going to ask the activity manager
            // to do is dropbox it (the common case during
            // platform development), we can avoid doing this
            // call synchronously which Binder data suggests
            // isn't always super fast, despite the implementation
            // in the ActivityManager trying to be mostly async.
            dropboxViolationAsync(violationMaskSubset, info);
            return;
        }
        // Normal synchronous call to the ActivityManager.
        try {
            // First, remove any policy before we call into the Activity Manager,
            // otherwise we'll infinite recurse as we try to log policy violations
            // to disk, thus violating policy, thus requiring logging, etc...
            // We restore the current policy below, in the finally block.
            setThreadPolicyMask(0);
            ActivityManager.getService().handleApplicationStrictModeViolation(RuntimeInit.getApplicationObject(), violationMaskSubset, info);
        } catch (RemoteException e) {
            if (e instanceof DeadObjectException) {
            // System process is dead; ignore
            } else {
                Log.e(TAG, ""RemoteException trying to handle StrictMode violation"", e);
            }
        } finally {
            // Restore the policy.
            setThreadPolicyMask(savedPolicyMask);
        }
    }
    if ((info.policy & PENALTY_DEATH) != 0) {
        executeDeathPenalty(info);
    }
}",1,"// hence the policy being passed around.
","// hence the policy being passed around.
",-1,,,-1,-1,-1,-1,-1,-1,,,,
875,<android.bluetooth.le.ScanSettings.Builder: ScanSettings build()>,25,26,<android.bluetooth.le.ScanSettings.Builder: ScanSettings build()>,<android.bluetooth.le.ScanSettings.Builder: ScanSettings build()>,0,"{
    return new ScanSettings(mScanMode, mCallbackType, mScanResultType, mReportDelayMillis, mMatchMode, mNumOfMatchesPerFilter);
}","{
    return new ScanSettings(mScanMode, mCallbackType, mScanResultType, mReportDelayMillis, mMatchMode, mNumOfMatchesPerFilter, mLegacy, mPhy);
}",1,"/**
 * Build {@link ScanSettings}.
 */
","/**
 * Build {@link ScanSettings}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method signature for constructor ScanSettings(...) has changed, as it takes two additional parameters 'mLegacy' and 'mPhy' in the late version. Therefore, the changes are classified under code change type 1 (Return statement changed) due to the different constructor call, and code change type 5 (Dependent API changed) because the constructor itself is a dependent API that has changed.","The change in the constructor signature suggests that different values could be set in the ScanSettings object returned by the build() method. Hence, the CI type is 1, indicating that this change could potentially lead to a different return value or type."
876,<android.content.ClipboardManager: void removePrimaryClipChangedListener(OnPrimaryClipChangedListener)>,25,26,<android.content.ClipboardManager: void removePrimaryClipChangedListener(OnPrimaryClipChangedListener)>,<android.content.ClipboardManager: void removePrimaryClipChangedListener(OnPrimaryClipChangedListener)>,0,"{
    synchronized (mPrimaryClipChangedListeners) {
        mPrimaryClipChangedListeners.remove(what);
        if (mPrimaryClipChangedListeners.size() == 0) {
            try {
                getService().removePrimaryClipChangedListener(mPrimaryClipChangedServiceListener);
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
        }
    }
}","{
    synchronized (mPrimaryClipChangedListeners) {
        mPrimaryClipChangedListeners.remove(what);
        if (mPrimaryClipChangedListeners.isEmpty()) {
            try {
                mService.removePrimaryClipChangedListener(mPrimaryClipChangedServiceListener);
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code inside the synchronized block has a minor change in the condition checking if the listeners list is empty, from ""mPrimaryClipChangedListeners.size() == 0"" to ""mPrimaryClipChangedListeners.isEmpty()"". There is also a change from ""getService()"" to ""mService"" when calling ""removePrimaryClipChangedListener"". The change from size check to isEmpty check is functionally equivalent and does not change the behavior of the method. The change from using ""getService()"" to ""mService"" does not necessarily indicate a behavior change; it could be an internal implementation detail (like caching the service reference in a field).","No compatibility issue is expected because the change from size() check to isEmpty() check will yield the same result, and replacing ""getService()"" with ""mService"" seems to be a refactor and should not affect the method's behavior as long as ""mService"" is correctly initialized with ""getService()"". Assuming ""mService"" is correctly initialized, the behavior remains the same when removing the clip changed listener."
877,<android.text.method.DigitsKeyListener: DigitsKeyListener getInstance(String)>,25,26,<android.text.method.DigitsKeyListener: DigitsKeyListener getInstance(String)>,<android.text.method.DigitsKeyListener: DigitsKeyListener getInstance(String)>,0,"{
    // TODO: do we need a cache of these to avoid allocating?
    DigitsKeyListener dim = new DigitsKeyListener();
    dim.mAccepted = new char[accepted.length()];
    accepted.getChars(0, accepted.length(), dim.mAccepted, 0);
    return dim;
}","{
    DigitsKeyListener result;
    synchronized (sStringCacheLock) {
        result = sStringInstanceCache.get(accepted);
        if (result == null) {
            result = new DigitsKeyListener(accepted);
            sStringInstanceCache.put(accepted, result);
        }
    }
    return result;
}",1,"/**
 * Returns a DigitsKeyListener that accepts only the characters
 * that appear in the specified String.  Note that not all characters
 * may be available on every keyboard.
 */
","/**
 * Returns a DigitsKeyListener that accepts only the characters
 * that appear in the specified String.  Note that not all characters
 * may be available on every keyboard.
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,"1,4",0,"The late version of the API now includes synchronization and caching logic based on the parameter `accepted`, with a new constructor `DigitsKeyListener(accepted)` being used. Additionally, the earlier manual creation and setting of fields of `DigitsKeyListener` is no longer evident in the late version. These changes classify as Other statement changed (4). The late version also includes the '@NonNull' annotation, which could potentially change the type of variable returned (since now it guarantees a non-null value being returned), considered as Return statement changed (1).","There's no Compatibility Issue detected since the returned `DigitsKeyListener` instance is still fulfilling the same contract, now it's just cached and created in a thread-safe manner. Moreover, the introduction of '@NonNull' reinforces the contract by ensuring a non-null value is returned, but does not change the returned type."
879,<android.app.Fragment: Transition getReenterTransition()>,25,26,<android.app.Fragment: Transition getReenterTransition()>,<android.app.Fragment: Transition getReenterTransition()>,0,"{
    return mReenterTransition == USE_DEFAULT_TRANSITION ? getExitTransition() : mReenterTransition;
}","{
    if (mAnimationInfo == null) {
        return null;
    }
    return mAnimationInfo.mReenterTransition == USE_DEFAULT_TRANSITION ? getExitTransition() : mAnimationInfo.mReenterTransition;
}",1,"/**
 * Returns the Transition that will be used to move Views in to the scene when returning due
 * to popping a back stack. The entering Views will be those that are regular Views
 * or ViewGroups that have {@link ViewGroup#isTransitionGroup} return true. Typical Transitions
 * will extend {@link android.transition.Visibility} as exiting is governed by changing
 * visibility from {@link View#VISIBLE} to {@link View#INVISIBLE}. If transition is null,
 * the views will remain unaffected. If nothing is set, the default will be to use the same
 * transition as {@link #setExitTransition(android.transition.Transition)}.
 *
 * @return the Transition to use to move Views into the scene when reentering from a
 * previously-started Activity.
 * @attr ref android.R.styleable#Fragment_fragmentReenterTransition
 */
","/**
 * Returns the Transition that will be used to move Views in to the scene when returning due
 * to popping a back stack. The entering Views will be those that are regular Views
 * or ViewGroups that have {@link ViewGroup#isTransitionGroup} return true. Typical Transitions
 * will extend {@link android.transition.Visibility} as exiting is governed by changing
 * visibility from {@link View#VISIBLE} to {@link View#INVISIBLE}. If transition is null,
 * the views will remain unaffected. If nothing is set, the default will be to use the same
 * transition as {@link #setExitTransition(android.transition.Transition)}.
 *
 * @return the Transition to use to move Views into the scene when reentering from a
 * previously-started Activity.
 * @attr ref android.R.styleable#Fragment_fragmentReenterTransition
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The control dependency has changed with the addition of an 'if' statement checking for 'mAnimationInfo == null', and the return statement is now conditional based on this null check. It previously returned 'mReenterTransition' or a result from 'getExitTransition()', but now, depending on 'mAnimationInfo', it may return 'null'. Consequently, there are changes in both control dependency and return statement, which correspond to the change types 1 and 3.","With the change to the implementation, the API could now potentially return 'null', which it wouldn't have prior to this change, should 'mAnimationInfo' be 'null'. Similarly, the potential value to be returned could differ if 'mAnimationInfo.mReenterTransition' holds a different value than 'mReenterTransition'. Therefore, this leads to the CI type 1."
880,<android.animation.AnimatorSet: boolean isRunning()>,25,26,<android.animation.AnimatorSet: boolean isRunning()>,<android.animation.AnimatorSet: boolean isRunning()>,0,"{
    int size = mNodes.size();
    for (int i = 0; i < size; i++) {
        Node node = mNodes.get(i);
        if (node != mRootNode && node.mAnimation.isStarted()) {
            return true;
        }
    }
    return false;
}","{
    if (mStartDelay == 0) {
        return mStarted;
    }
    return mLastFrameTime > 0;
}",1,"/**
 * Returns true if any of the child animations of this AnimatorSet have been started and have
 * not yet ended. Child animations will not be started until the AnimatorSet has gone past
 * its initial delay set through {@link #setStartDelay(long)}.
 *
 * @return Whether this AnimatorSet has gone past the initial delay, and at least one child
 * animation has been started and not yet ended.
 */
","/**
 * Returns true if any of the child animations of this AnimatorSet have been started and have
 * not yet ended. Child animations will not be started until the AnimatorSet has gone past
 * its initial delay set through {@link #setStartDelay(long)}.
 *
 * @return Whether this AnimatorSet has gone past the initial delay, and at least one child
 * animation has been started and not yet ended.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"The control flow and return statements were both completely replcae in the late version with different logic; the check in the early version iterates over nodes to see if any animation is started, while the late version returns mStarted if mStartDelay is zero or checks mLastFrameTime otherwise. This constitutes a change in the control dependency as well as the return statement, so the code change type is 1,3.","Given that the implementation of isRunning() method has changed significantly with different conditions and return values, the late version could potentially return a different result from the early version for the same state of the AnimatorSet. Therefore, this is a CI caused by potential different return values or types, making the CI type 1."
881,<android.bluetooth.BluetoothAdapter: BluetoothLeAdvertiser getBluetoothLeAdvertiser()>,25,26,<android.bluetooth.BluetoothAdapter: BluetoothLeAdvertiser getBluetoothLeAdvertiser()>,<android.bluetooth.BluetoothAdapter: BluetoothLeAdvertiser getBluetoothLeAdvertiser()>,0,"{
    if (!getLeAccess())
        return null;
    if (!isMultipleAdvertisementSupported() && !isPeripheralModeSupported()) {
        Log.e(TAG, ""Bluetooth LE advertising not supported"");
        return null;
    }
    synchronized (mLock) {
        if (sBluetoothLeAdvertiser == null) {
            sBluetoothLeAdvertiser = new BluetoothLeAdvertiser(mManagerService);
        }
    }
    return sBluetoothLeAdvertiser;
}","{
    if (!getLeAccess())
        return null;
    synchronized (mLock) {
        if (sBluetoothLeAdvertiser == null) {
            sBluetoothLeAdvertiser = new BluetoothLeAdvertiser(mManagerService);
        }
    }
    return sBluetoothLeAdvertiser;
}",1,"/**
 * Returns a {@link BluetoothLeAdvertiser} object for Bluetooth LE Advertising operations.
 * Will return null if Bluetooth is turned off or if Bluetooth LE Advertising is not
 * supported on this device.
 * <p>
 * Use {@link #isMultipleAdvertisementSupported()} to check whether LE Advertising is supported
 * on this device before calling this method.
 */
","/**
 * Returns a {@link BluetoothLeAdvertiser} object for Bluetooth LE Advertising operations.
 * Will return null if Bluetooth is turned off or if Bluetooth LE Advertising is not
 * supported on this device.
 * <p>
 * Use {@link #isMultipleAdvertisementSupported()} to check whether LE Advertising is supported
 * on this device before calling this method.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"The condition that checks for `isMultipleAdvertisementSupported()` and `isPeripheralModeSupported()` before initializing the `sBluetoothLeAdvertiser` is removed, which alters the control flow. Hence, the code change type is 3.","By removing the condition that checks the support for multiple advertisement and peripheral mode, the API now potentially can return a non-null `BluetoothLeAdvertiser` when it previously would have returned null. As there is a change in the cases when a null or non-null value is returned, the CI type is 1."
883,"<android.app.PendingIntent: PendingIntent getActivities(Context,int,Intent[],int,Bundle)>",25,26,"<android.app.PendingIntent: PendingIntent getActivities(Context,int,Intent[],int,Bundle)>","<android.app.PendingIntent: PendingIntent getActivities(Context,int,Intent[],int,Bundle)>",0,"{
    String packageName = context.getPackageName();
    String[] resolvedTypes = new String[intents.length];
    for (int i = 0; i < intents.length; i++) {
        intents[i].migrateExtraStreamToClipData();
        intents[i].prepareToLeaveProcess(context);
        resolvedTypes[i] = intents[i].resolveTypeIfNeeded(context.getContentResolver());
    }
    try {
        IIntentSender target = ActivityManagerNative.getDefault().getIntentSender(ActivityManager.INTENT_SENDER_ACTIVITY, packageName, null, null, requestCode, intents, resolvedTypes, flags, options, UserHandle.myUserId());
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
    }
    return null;
}","{
    String packageName = context.getPackageName();
    String[] resolvedTypes = new String[intents.length];
    for (int i = 0; i < intents.length; i++) {
        intents[i].migrateExtraStreamToClipData();
        intents[i].prepareToLeaveProcess(context);
        resolvedTypes[i] = intents[i].resolveTypeIfNeeded(context.getContentResolver());
    }
    try {
        IIntentSender target = ActivityManager.getService().getIntentSender(ActivityManager.INTENT_SENDER_ACTIVITY, packageName, null, null, requestCode, intents, resolvedTypes, flags, options, UserHandle.myUserId());
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Like {@link #getActivity(Context, int, Intent, int)}, but allows an
 * array of Intents to be supplied.  The last Intent in the array is
 * taken as the primary key for the PendingIntent, like the single Intent
 * given to {@link #getActivity(Context, int, Intent, int)}.  Upon sending
 * the resulting PendingIntent, all of the Intents are started in the same
 * way as they would be by passing them to {@link Context#startActivities(Intent[])}.
 *
 * <p class=""note"">
 * The <em>first</em> intent in the array will be started outside of the context of an
 * existing activity, so you must use the {@link Intent#FLAG_ACTIVITY_NEW_TASK
 * Intent.FLAG_ACTIVITY_NEW_TASK} launch flag in the Intent.  (Activities after
 * the first in the array are started in the context of the previous activity
 * in the array, so FLAG_ACTIVITY_NEW_TASK is not needed nor desired for them.)
 * </p>
 *
 * <p class=""note"">
 * The <em>last</em> intent in the array represents the key for the
 * PendingIntent.  In other words, it is the significant element for matching
 * (as done with the single intent given to {@link #getActivity(Context, int, Intent, int)},
 * its content will be the subject of replacement by
 * {@link #send(Context, int, Intent)} and {@link #FLAG_UPDATE_CURRENT}, etc.
 * This is because it is the most specific of the supplied intents, and the
 * UI the user actually sees when the intents are started.
 * </p>
 *
 * <p class=""note"">For security reasons, the {@link android.content.Intent} objects
 * you supply here should almost always be <em>explicit intents</em>,
 * that is specify an explicit component to be delivered to through
 * {@link Intent#setClass(android.content.Context, Class) Intent.setClass}</p>
 *
 * @param context The Context in which this PendingIntent should start
 * the activity.
 * @param requestCode Private request code for the sender
 * @param intents Array of Intents of the activities to be launched.
 * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},
 * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},
 * {@link #FLAG_IMMUTABLE} or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been
 * supplied.
 */
","/**
 * Like {@link #getActivity(Context, int, Intent, int)}, but allows an
 * array of Intents to be supplied.  The last Intent in the array is
 * taken as the primary key for the PendingIntent, like the single Intent
 * given to {@link #getActivity(Context, int, Intent, int)}.  Upon sending
 * the resulting PendingIntent, all of the Intents are started in the same
 * way as they would be by passing them to {@link Context#startActivities(Intent[])}.
 *
 * <p class=""note"">
 * The <em>first</em> intent in the array will be started outside of the context of an
 * existing activity, so you must use the {@link Intent#FLAG_ACTIVITY_NEW_TASK
 * Intent.FLAG_ACTIVITY_NEW_TASK} launch flag in the Intent.  (Activities after
 * the first in the array are started in the context of the previous activity
 * in the array, so FLAG_ACTIVITY_NEW_TASK is not needed nor desired for them.)
 * </p>
 *
 * <p class=""note"">
 * The <em>last</em> intent in the array represents the key for the
 * PendingIntent.  In other words, it is the significant element for matching
 * (as done with the single intent given to {@link #getActivity(Context, int, Intent, int)},
 * its content will be the subject of replacement by
 * {@link #send(Context, int, Intent)} and {@link #FLAG_UPDATE_CURRENT}, etc.
 * This is because it is the most specific of the supplied intents, and the
 * UI the user actually sees when the intents are started.
 * </p>
 *
 * <p class=""note"">For security reasons, the {@link android.content.Intent} objects
 * you supply here should almost always be <em>explicit intents</em>,
 * that is specify an explicit component to be delivered to through
 * {@link Intent#setClass(android.content.Context, Class) Intent.setClass}</p>
 *
 * @param context The Context in which this PendingIntent should start
 * the activity.
 * @param requestCode Private request code for the sender
 * @param intents Array of Intents of the activities to be launched.
 * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},
 * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},
 * {@link #FLAG_IMMUTABLE} or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been
 * supplied.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,5",2,"There's a change in exception handling where a new throw statement is introduced in the late version (throw e.rethrowFromSystemServer()), and there's a change in the dependent API used where `ActivityManagerNative.getDefault()` has been replaced with `ActivityManager.getService()`, therefore the change types are 2,5.","Since the late version introduces a new throw within the catch block, this could lead to a different exception being thrown than in the early version. Therefore, it could potentially lead to a Compatibility Issue of type 2."
885,"<android.widget.PopupWindow: void update(int,int,int,int,boolean)>",25,26,"<android.widget.PopupWindow: void update(int,int,int,int,boolean)>","<android.widget.PopupWindow: void update(int,int,int,int,boolean)>",0,"{
    if (width >= 0) {
        mLastWidth = width;
        setWidth(width);
    }
    if (height >= 0) {
        mLastHeight = height;
        setHeight(height);
    }
    if (!isShowing() || mContentView == null) {
        return;
    }
    final WindowManager.LayoutParams p = (WindowManager.LayoutParams) mDecorView.getLayoutParams();
    boolean update = force;
    final int finalWidth = mWidthMode < 0 ? mWidthMode : mLastWidth;
    if (width != -1 && p.width != finalWidth) {
        p.width = mLastWidth = finalWidth;
        update = true;
    }
    final int finalHeight = mHeightMode < 0 ? mHeightMode : mLastHeight;
    if (height != -1 && p.height != finalHeight) {
        p.height = mLastHeight = finalHeight;
        update = true;
    }
    if (p.x != x) {
        p.x = x;
        update = true;
    }
    if (p.y != y) {
        p.y = y;
        update = true;
    }
    final int newAnim = computeAnimationResource();
    if (newAnim != p.windowAnimations) {
        p.windowAnimations = newAnim;
        update = true;
    }
    final int newFlags = computeFlags(p.flags);
    if (newFlags != p.flags) {
        p.flags = newFlags;
        update = true;
    }
    final int newGravity = computeGravity();
    if (newGravity != p.gravity) {
        p.gravity = newGravity;
        update = true;
    }
    int newAccessibilityIdOfAnchor = (mAnchor != null) ? mAnchor.get().getAccessibilityViewId() : -1;
    if (newAccessibilityIdOfAnchor != p.accessibilityIdOfAnchor) {
        p.accessibilityIdOfAnchor = newAccessibilityIdOfAnchor;
        update = true;
    }
    if (update) {
        setLayoutDirectionFromAnchor();
        mWindowManager.updateViewLayout(mDecorView, p);
    }
}","{
    if (width >= 0) {
        mLastWidth = width;
        setWidth(width);
    }
    if (height >= 0) {
        mLastHeight = height;
        setHeight(height);
    }
    if (!isShowing() || !hasContentView()) {
        return;
    }
    final WindowManager.LayoutParams p = getDecorViewLayoutParams();
    boolean update = force;
    final int finalWidth = mWidthMode < 0 ? mWidthMode : mLastWidth;
    if (width != -1 && p.width != finalWidth) {
        p.width = mLastWidth = finalWidth;
        update = true;
    }
    final int finalHeight = mHeightMode < 0 ? mHeightMode : mLastHeight;
    if (height != -1 && p.height != finalHeight) {
        p.height = mLastHeight = finalHeight;
        update = true;
    }
    if (p.x != x) {
        p.x = x;
        update = true;
    }
    if (p.y != y) {
        p.y = y;
        update = true;
    }
    final int newAnim = computeAnimationResource();
    if (newAnim != p.windowAnimations) {
        p.windowAnimations = newAnim;
        update = true;
    }
    final int newFlags = computeFlags(p.flags);
    if (newFlags != p.flags) {
        p.flags = newFlags;
        update = true;
    }
    final int newGravity = computeGravity();
    if (newGravity != p.gravity) {
        p.gravity = newGravity;
        update = true;
    }
    View anchor = null;
    int newAccessibilityIdOfAnchor = -1;
    if (mAnchor != null && mAnchor.get() != null) {
        anchor = mAnchor.get();
        newAccessibilityIdOfAnchor = anchor.getAccessibilityViewId();
    }
    if (newAccessibilityIdOfAnchor != p.accessibilityIdOfAnchor) {
        p.accessibilityIdOfAnchor = newAccessibilityIdOfAnchor;
        update = true;
    }
    if (update) {
        update(anchor, p);
    }
}",1,"/**
 * Updates the position and the dimension of the popup window.
 * <p>
 * Width and height can be set to -1 to update location only. Calling this
 * function also updates the window with the current popup state as
 * described for {@link #update()}.
 *
 * @param x the new x location
 * @param y the new y location
 * @param width the new width in pixels, must be >= 0 or -1 to ignore
 * @param height the new height in pixels, must be >= 0 or -1 to ignore
 * @param force {@code true} to reposition the window even if the specified
 * position already seems to correspond to the LayoutParams,
 * {@code false} to only reposition if needed
 */
","/**
 * Updates the position and the dimension of the popup window.
 * <p>
 * Width and height can be set to -1 to update location only. Calling this
 * function also updates the window with the current popup state as
 * described for {@link #update()}.
 *
 * @param x the new x location
 * @param y the new y location
 * @param width the new width in pixels, must be >= 0 or -1 to ignore
 * @param height the new height in pixels, must be >= 0 or -1 to ignore
 * @param force {@code true} to reposition the window even if the specified
 * position already seems to correspond to the LayoutParams,
 * {@code false} to only reposition if needed
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",1,"The control dependency (if condition) for checking the view content is showing has been changed from 'mContentView == null' to '!hasContentView()'. There is a refactoring of temporary variables into a single if condition for the anchor check, and two method names `getDecorViewLayoutParams()` and `update(Anchor, Params)` are changed, which results in the change types 3, 4, 5.","Because the control dependency has changed and the dependent API `getDecorViewLayoutParams()` and `update(Anchor, Params)` are changed, these could lead to different behavior, potentially returning different results. Therefore, the CI type is classified as 1."
886,<android.widget.LinearLayout: void setShowDividers(int)>,25,26,<android.widget.LinearLayout: void setShowDividers(int)>,<android.widget.LinearLayout: void setShowDividers(int)>,0,"{
    if (showDividers != mShowDividers) {
        requestLayout();
    }
    mShowDividers = showDividers;
}","{
    if (showDividers == mShowDividers) {
        return;
    }
    mShowDividers = showDividers;
    setWillNotDraw(!isShowingDividers());
    requestLayout();
}",1,"/**
 * Set how dividers should be shown between items in this layout
 *
 * @param showDividers One or more of {@link #SHOW_DIVIDER_BEGINNING},
 * {@link #SHOW_DIVIDER_MIDDLE}, or {@link #SHOW_DIVIDER_END},
 * or {@link #SHOW_DIVIDER_NONE} to show no dividers.
 */
","/**
 * Set how dividers should be shown between items in this layout
 *
 * @param showDividers One or more of {@link #SHOW_DIVIDER_BEGINNING},
 * {@link #SHOW_DIVIDER_MIDDLE}, or {@link #SHOW_DIVIDER_END}
 * to show dividers, or {@link #SHOW_DIVIDER_NONE} to show no dividers.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The change consists of an added return statement when showDividers is equal to mShowDividers, a call to setWillNotDraw() method with an inverted evaluation of isShowingDividers(), and an unconditional call to requestLayout(). There are control structure changes and other statement changes, hence the classification 3,4.","There is no CI because the behaviour of the method has been preserved in terms of functionality. The early version requests layout if showDividers and mShowDividers are different, which is also the case in the late version; additional steps are all related to graphical updates that do not affect the API's logic from the user's perspective."
887,"<android.content.pm.LauncherApps: Drawable getShortcutIconDrawable(ShortcutInfo,int)>",25,26,"<android.content.pm.LauncherApps: Drawable getShortcutIconDrawable(ShortcutInfo,int)>","<android.content.pm.LauncherApps: Drawable getShortcutIconDrawable(ShortcutInfo,int)>",0,"{
    if (shortcut.hasIconFile()) {
        final ParcelFileDescriptor pfd = getShortcutIconFd(shortcut);
        if (pfd == null) {
            return null;
        }
        try {
            final Bitmap bmp = BitmapFactory.decodeFileDescriptor(pfd.getFileDescriptor());
            return (bmp == null) ? null : new BitmapDrawable(mContext.getResources(), bmp);
        } finally {
            try {
                pfd.close();
            } catch (IOException ignore) {
            }
        }
    } else if (shortcut.hasIconResource()) {
        try {
            final int resId = shortcut.getIconResourceId();
            if (resId == 0) {
                // Shouldn't happen but just in case.
                return null;
            }
            final ApplicationInfo ai = getApplicationInfo(shortcut.getPackage(), /* flags =*/
            0, shortcut.getUserHandle());
            final Resources res = mContext.getPackageManager().getResourcesForApplication(ai);
            return res.getDrawableForDensity(resId, density);
        } catch (NameNotFoundException | Resources.NotFoundException e) {
            return null;
        }
    } else {
        // Has no icon.
        return null;
    }
}","{
    if (shortcut.hasIconFile()) {
        final ParcelFileDescriptor pfd = getShortcutIconFd(shortcut);
        if (pfd == null) {
            return null;
        }
        try {
            final Bitmap bmp = BitmapFactory.decodeFileDescriptor(pfd.getFileDescriptor());
            if (bmp != null) {
                BitmapDrawable dr = new BitmapDrawable(mContext.getResources(), bmp);
                if (shortcut.hasAdaptiveBitmap()) {
                    return new AdaptiveIconDrawable(null, dr);
                } else {
                    return dr;
                }
            }
            return null;
        } finally {
            try {
                pfd.close();
            } catch (IOException ignore) {
            }
        }
    } else if (shortcut.hasIconResource()) {
        return loadDrawableResourceFromPackage(shortcut.getPackage(), shortcut.getIconResourceId(), shortcut.getUserHandle(), density);
    } else if (shortcut.getIcon() != null) {
        // This happens if a shortcut is pending-approval.
        final Icon icon = shortcut.getIcon();
        switch(icon.getType()) {
            case Icon.TYPE_RESOURCE:
                {
                    return loadDrawableResourceFromPackage(shortcut.getPackage(), icon.getResId(), shortcut.getUserHandle(), density);
                }
            case Icon.TYPE_BITMAP:
            case Icon.TYPE_ADAPTIVE_BITMAP:
                {
                    return icon.loadDrawable(mContext);
                }
            default:
                // Shouldn't happen though.
                return null;
        }
    } else {
        // Has no icon.
        return null;
    }
}",1,"/**
 * Returns the icon for this shortcut, without any badging for the profile.
 *
 * <p>The calling launcher application must be allowed to access the shortcut information,
 * as defined in {@link #hasShortcutHostPermission()}.
 *
 * @param density The preferred density of the icon, zero for default density. Use
 * density DPI values from {@link DisplayMetrics}.
 *
 * @return The drawable associated with the shortcut.
 * @throws IllegalStateException when the user is locked, or when the {@code user} user
 * is locked or not running.
 *
 * @see ShortcutManager
 * @see #getShortcutBadgedIconDrawable(ShortcutInfo, int)
 * @see DisplayMetrics
 */
","/**
 * Returns the icon for this shortcut, without any badging for the profile.
 *
 * <p>The calling launcher application must be allowed to access the shortcut information,
 * as defined in {@link #hasShortcutHostPermission()}.
 *
 * @param density The preferred density of the icon, zero for default density. Use
 * density DPI values from {@link DisplayMetrics}.
 *
 * @return The drawable associated with the shortcut.
 * @throws IllegalStateException when the user is locked, or when the {@code user} user
 * is locked or not running.
 *
 * @see ShortcutManager
 * @see #getShortcutBadgedIconDrawable(ShortcutInfo, int)
 * @see DisplayMetrics
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The return statement has changed with the introduction of the 'AdaptiveIconDrawable' logic within the 'bitmap != null' condition. Furthermore, there are also changes in the control dependency as a new 'else if' clause has been added, and to the dependent APIs as the late version includes new calls to 'shortcut.hasAdaptiveBitmap()', 'shortcut.getIcon()', 'icon.getType()', 'icon.getResId()', and 'icon.loadDrawable(mContext)' which are all affecting the overall behavior of this API. Additionally, there's the extraction of loading drawable resources logic into a separate method 'loadDrawableResourceFromPackage' instead of inline code logic as in the early version. Therefore, there's also an 'other statement change' due to these newly added codes and method invocations.","The compatibility issue arises due to changes in the types of drawables that may now be returned. The Drawable returned may now be an instance of 'AdaptiveIconDrawable', which was not possible in the early version. Additionally, the introduction of a new block to handle 'shortcut.getIcon()' can cause the return of different types of Drawable or different resource identifiers, posing a compatibility issue of type 1."
888,<android.accounts.AccountManager: void removeOnAccountsUpdatedListener(OnAccountsUpdateListener)>,25,26,<android.accounts.AccountManager: void removeOnAccountsUpdatedListener(OnAccountsUpdateListener)>,<android.accounts.AccountManager: void removeOnAccountsUpdatedListener(OnAccountsUpdateListener)>,0,"{
    if (listener == null)
        throw new IllegalArgumentException(""listener is null"");
    synchronized (mAccountsUpdatedListeners) {
        if (!mAccountsUpdatedListeners.containsKey(listener)) {
            Log.e(TAG, ""Listener was not previously added"");
            return;
        }
        mAccountsUpdatedListeners.remove(listener);
        if (mAccountsUpdatedListeners.isEmpty()) {
            mContext.unregisterReceiver(mAccountsChangedBroadcastReceiver);
        }
    }
}","{
    if (listener == null)
        throw new IllegalArgumentException(""listener is null"");
    synchronized (mAccountsUpdatedListeners) {
        if (!mAccountsUpdatedListeners.containsKey(listener)) {
            Log.e(TAG, ""Listener was not previously added"");
            return;
        }
        Set<String> accountTypes = mAccountsUpdatedListenersTypes.get(listener);
        String[] accountsArray;
        if (accountTypes != null) {
            accountsArray = accountTypes.toArray(new String[accountTypes.size()]);
        } else {
            accountsArray = null;
        }
        mAccountsUpdatedListeners.remove(listener);
        mAccountsUpdatedListenersTypes.remove(listener);
        if (mAccountsUpdatedListeners.isEmpty()) {
            mContext.unregisterReceiver(mAccountsChangedBroadcastReceiver);
        }
        try {
            mService.unregisterAccountListener(accountsArray, mContext.getOpPackageName());
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Removes an {@link OnAccountsUpdateListener} previously registered with
 * {@link #addOnAccountsUpdatedListener}.  The listener will no longer
 * receive notifications of account changes.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>No permission is required to call this method.
 *
 * @param listener The previously added listener to remove
 * @throws IllegalArgumentException if listener is null
 * @throws IllegalStateException if listener was not already added
 */
","/**
 * Removes an {@link OnAccountsUpdateListener} previously registered with
 * {@link #addOnAccountsUpdatedListener}.  The listener will no longer
 * receive notifications of account changes.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>No permission is required to call this method.
 *
 * @param listener The previously added listener to remove
 * @throws IllegalArgumentException if listener is null
 * @throws IllegalStateException if listener was not already added
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,4,5","1,2",There are several changes in the late implementation:,"- Some different actions are taken depending on the state of `accountTypes`, where an accounts array is created and used."
890,"<android.os.storage.StorageManager: boolean unmountObb(String,boolean,OnObbStateChangeListener)>",25,26,"<android.os.storage.StorageManager: boolean unmountObb(String,boolean,OnObbStateChangeListener)>","<android.os.storage.StorageManager: boolean unmountObb(String,boolean,OnObbStateChangeListener)>",0,"{
    Preconditions.checkNotNull(rawPath, ""rawPath cannot be null"");
    Preconditions.checkNotNull(listener, ""listener cannot be null"");
    try {
        final int nonce = mObbActionListener.addListener(listener);
        mMountService.unmountObb(rawPath, force, mObbActionListener, nonce);
        return true;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    Preconditions.checkNotNull(rawPath, ""rawPath cannot be null"");
    Preconditions.checkNotNull(listener, ""listener cannot be null"");
    try {
        final int nonce = mObbActionListener.addListener(listener);
        mStorageManager.unmountObb(rawPath, force, mObbActionListener, nonce);
        return true;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Unmount an Opaque Binary Blob (OBB) file asynchronously. If the
 * <code>force</code> flag is true, it will kill any application needed to
 * unmount the given OBB (even the calling application).
 * <p>
 * The {@link OnObbStateChangeListener} registered with this call will
 * receive the success or failure of this operation.
 * <p>
 * <em>Note:</em> you can only mount OBB files for which the OBB tag on the
 * file matches a package ID that is owned by the calling program's UID.
 * That is, shared UID applications can obtain access to any other
 * application's OBB that shares its UID.
 * <p>
 *
 * @param rawPath path to the OBB file
 * @param force whether to kill any programs using this in order to unmount
 * it
 * @param listener will receive the success or failure of the operation
 * @return whether the unmount call was successfully queued or not
 */
","/**
 * Unmount an Opaque Binary Blob (OBB) file asynchronously. If the
 * <code>force</code> flag is true, it will kill any application needed to
 * unmount the given OBB (even the calling application).
 * <p>
 * The {@link OnObbStateChangeListener} registered with this call will
 * receive the success or failure of this operation.
 * <p>
 * <em>Note:</em> you can only mount OBB files for which the OBB tag on the
 * file matches a package ID that is owned by the calling program's UID.
 * That is, shared UID applications can obtain access to any other
 * application's OBB that shares its UID.
 * <p>
 *
 * @param rawPath path to the OBB file
 * @param force whether to kill any programs using this in order to unmount
 * it
 * @param listener will receive the success or failure of the operation
 * @return whether the unmount call was successfully queued or not
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method call within the try block changed from mMountService.unmountObb() to mStorageManager.unmountObb(), indicating a dependent API change, so the code change type is 5.","There's no compatibility issue arising from the change in the dependent API call as long as the mStorageManager.unmountObb() method has the same behavior as mMountService.unmountObb(). There's no indication that the functionality has changed, only the object through which the method is called. Thus, the CI type is 0."
891,<android.animation.ObjectAnimator: void animateValue(float)>,25,26,<android.animation.ObjectAnimator: void animateValue(float)>,<android.animation.ObjectAnimator: void animateValue(float)>,0,"{
    final Object target = getTarget();
    if (target == null) {
        // We lost the target reference, cancel and clean up.
        cancel();
        return;
    }
    super.animateValue(fraction);
    int numValues = mValues.length;
    for (int i = 0; i < numValues; ++i) {
        mValues[i].setAnimatedValue(target);
    }
}","{
    final Object target = getTarget();
    if (mTarget != null && target == null) {
        // We lost the target reference, cancel and clean up. Note: we allow null target if the
        // / target has never been set.
        cancel();
        return;
    }
    super.animateValue(fraction);
    int numValues = mValues.length;
    for (int i = 0; i < numValues; ++i) {
        mValues[i].setAnimatedValue(target);
    }
}",1,"/**
 * This method is called with the elapsed fraction of the animation during every
 * animation frame. This function turns the elapsed fraction into an interpolated fraction
 * and then into an animated value (from the evaluator. The function is called mostly during
 * animation updates, but it is also called when the <code>end()</code>
 * function is called, to set the final value on the property.
 *
 * <p>Overrides of this method must call the superclass to perform the calculation
 * of the animated value.</p>
 *
 * @param fraction The elapsed fraction of the animation.
 */
","/**
 * This method is called with the elapsed fraction of the animation during every
 * animation frame. This function turns the elapsed fraction into an interpolated fraction
 * and then into an animated value (from the evaluator. The function is called mostly during
 * animation updates, but it is also called when the <code>end()</code>
 * function is called, to set the final value on the property.
 *
 * <p>Overrides of this method must call the superclass to perform the calculation
 * of the animated value.</p>
 *
 * @param fraction The elapsed fraction of the animation.
 */
",-1,"[@CallSuper, @Override]","[@CallSuper, @Override]",-1,-1,-1,-1,-1,-1,3,0,"The 'if' condition has changed from checking if target is null to checking if mTarget is not null and target is null, so the code change type is 3.","There is no Compatibility Issue because the change in the if condition is actually relaxing the constraint for canceling the animation. In the early version, if target is null, the animation is canceled. In the late version, cancellation only happens if mTarget has been set at least once and then target becomes null. If mTarget has never been set, then target being null won't trigger cancellation. This change should not cause any different exceptions or return values under the same conditions when used as intended, hence, there is no CI, which is 0."
893,"<android.app.ActivityManager: List<RecentTaskInfo> getRecentTasks(int,int)>",25,26,"<android.app.ActivityManager: List<RecentTaskInfo> getRecentTasks(int,int)>","<android.app.ActivityManager: List<RecentTaskInfo> getRecentTasks(int,int)>",0,"{
    try {
        return ActivityManagerNative.getDefault().getRecentTasks(maxNum, flags, UserHandle.myUserId()).getList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        return getService().getRecentTasks(maxNum, flags, UserHandle.myUserId()).getList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * <p></p>Return a list of the tasks that the user has recently launched, with
 * the most recent being first and older ones after in order.
 *
 * <p><b>Note: this method is only intended for debugging and presenting
 * task management user interfaces</b>.  This should never be used for
 * core logic in an application, such as deciding between different
 * behaviors based on the information found here.  Such uses are
 * <em>not</em> supported, and will likely break in the future.  For
 * example, if multiple applications can be actively running at the
 * same time, assumptions made about the meaning of the data here for
 * purposes of control flow will be incorrect.</p>
 *
 * @deprecated As of {@link android.os.Build.VERSION_CODES#LOLLIPOP}, this method is
 * no longer available to third party applications: the introduction of
 * document-centric recents means
 * it can leak personal information to the caller.  For backwards compatibility,
 * it will still return a small subset of its data: at least the caller's
 * own tasks (though see {@link #getAppTasks()} for the correct supported
 * way to retrieve that information), and possibly some other tasks
 * such as home that are known to not be sensitive.
 *
 * @param maxNum The maximum number of entries to return in the list.  The
 * actual number returned may be smaller, depending on how many tasks the
 * user has started and the maximum number the system can remember.
 * @param flags Information about what to return.  May be any combination
 * of {@link #RECENT_WITH_EXCLUDED} and {@link #RECENT_IGNORE_UNAVAILABLE}.
 *
 * @return Returns a list of RecentTaskInfo records describing each of
 * the recent tasks.
 */
","/**
 * <p></p>Return a list of the tasks that the user has recently launched, with
 * the most recent being first and older ones after in order.
 *
 * <p><b>Note: this method is only intended for debugging and presenting
 * task management user interfaces</b>.  This should never be used for
 * core logic in an application, such as deciding between different
 * behaviors based on the information found here.  Such uses are
 * <em>not</em> supported, and will likely break in the future.  For
 * example, if multiple applications can be actively running at the
 * same time, assumptions made about the meaning of the data here for
 * purposes of control flow will be incorrect.</p>
 *
 * @deprecated As of {@link android.os.Build.VERSION_CODES#LOLLIPOP}, this method is
 * no longer available to third party applications: the introduction of
 * document-centric recents means
 * it can leak personal information to the caller.  For backwards compatibility,
 * it will still return a small subset of its data: at least the caller's
 * own tasks (though see {@link #getAppTasks()} for the correct supported
 * way to retrieve that information), and possibly some other tasks
 * such as home that are known to not be sensitive.
 *
 * @param maxNum The maximum number of entries to return in the list.  The
 * actual number returned may be smaller, depending on how many tasks the
 * user has started and the maximum number the system can remember.
 * @param flags Information about what to return.  May be any combination
 * of {@link #RECENT_WITH_EXCLUDED} and {@link #RECENT_IGNORE_UNAVAILABLE}.
 *
 * @return Returns a list of RecentTaskInfo records describing each of
 * the recent tasks.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,4,0,"The code change is that ActivityManagerNative.getDefault() has been replaced with getService(). However, the functionality is presumed to remain the same, hence the change type is 4 (Other statement changed).","Since the change was simply replacing one method call with another which is likely to serve the same purpose and there is no indication of a change in behaviour, there is no Compatibility Issue. The return values and exception handling remain unchanged."
895,"<android.widget.Toolbar: void onLayout(boolean,int,int,int,int)>",25,26,"<android.widget.Toolbar: void onLayout(boolean,int,int,int,int)>","<android.widget.Toolbar: void onLayout(boolean,int,int,int,int)>",0,"{
    final boolean isRtl = getLayoutDirection() == LAYOUT_DIRECTION_RTL;
    final int width = getWidth();
    final int height = getHeight();
    final int paddingLeft = getPaddingLeft();
    final int paddingRight = getPaddingRight();
    final int paddingTop = getPaddingTop();
    final int paddingBottom = getPaddingBottom();
    int left = paddingLeft;
    int right = width - paddingRight;
    final int[] collapsingMargins = mTempMargins;
    collapsingMargins[0] = collapsingMargins[1] = 0;
    // Align views within the minimum toolbar height, if set.
    final int alignmentHeight = getMinimumHeight();
    if (shouldLayout(mNavButtonView)) {
        if (isRtl) {
            right = layoutChildRight(mNavButtonView, right, collapsingMargins, alignmentHeight);
        } else {
            left = layoutChildLeft(mNavButtonView, left, collapsingMargins, alignmentHeight);
        }
    }
    if (shouldLayout(mCollapseButtonView)) {
        if (isRtl) {
            right = layoutChildRight(mCollapseButtonView, right, collapsingMargins, alignmentHeight);
        } else {
            left = layoutChildLeft(mCollapseButtonView, left, collapsingMargins, alignmentHeight);
        }
    }
    if (shouldLayout(mMenuView)) {
        if (isRtl) {
            left = layoutChildLeft(mMenuView, left, collapsingMargins, alignmentHeight);
        } else {
            right = layoutChildRight(mMenuView, right, collapsingMargins, alignmentHeight);
        }
    }
    final int contentInsetLeft = getCurrentContentInsetLeft();
    final int contentInsetRight = getCurrentContentInsetRight();
    collapsingMargins[0] = Math.max(0, contentInsetLeft - left);
    collapsingMargins[1] = Math.max(0, contentInsetRight - (width - paddingRight - right));
    left = Math.max(left, contentInsetLeft);
    right = Math.min(right, width - paddingRight - contentInsetRight);
    if (shouldLayout(mExpandedActionView)) {
        if (isRtl) {
            right = layoutChildRight(mExpandedActionView, right, collapsingMargins, alignmentHeight);
        } else {
            left = layoutChildLeft(mExpandedActionView, left, collapsingMargins, alignmentHeight);
        }
    }
    if (shouldLayout(mLogoView)) {
        if (isRtl) {
            right = layoutChildRight(mLogoView, right, collapsingMargins, alignmentHeight);
        } else {
            left = layoutChildLeft(mLogoView, left, collapsingMargins, alignmentHeight);
        }
    }
    final boolean layoutTitle = shouldLayout(mTitleTextView);
    final boolean layoutSubtitle = shouldLayout(mSubtitleTextView);
    int titleHeight = 0;
    if (layoutTitle) {
        final LayoutParams lp = (LayoutParams) mTitleTextView.getLayoutParams();
        titleHeight += lp.topMargin + mTitleTextView.getMeasuredHeight() + lp.bottomMargin;
    }
    if (layoutSubtitle) {
        final LayoutParams lp = (LayoutParams) mSubtitleTextView.getLayoutParams();
        titleHeight += lp.topMargin + mSubtitleTextView.getMeasuredHeight() + lp.bottomMargin;
    }
    if (layoutTitle || layoutSubtitle) {
        int titleTop;
        final View topChild = layoutTitle ? mTitleTextView : mSubtitleTextView;
        final View bottomChild = layoutSubtitle ? mSubtitleTextView : mTitleTextView;
        final LayoutParams toplp = (LayoutParams) topChild.getLayoutParams();
        final LayoutParams bottomlp = (LayoutParams) bottomChild.getLayoutParams();
        final boolean titleHasWidth = layoutTitle && mTitleTextView.getMeasuredWidth() > 0 || layoutSubtitle && mSubtitleTextView.getMeasuredWidth() > 0;
        switch(mGravity & Gravity.VERTICAL_GRAVITY_MASK) {
            case Gravity.TOP:
                titleTop = getPaddingTop() + toplp.topMargin + mTitleMarginTop;
                break;
            default:
            case Gravity.CENTER_VERTICAL:
                final int space = height - paddingTop - paddingBottom;
                int spaceAbove = (space - titleHeight) / 2;
                if (spaceAbove < toplp.topMargin + mTitleMarginTop) {
                    spaceAbove = toplp.topMargin + mTitleMarginTop;
                } else {
                    final int spaceBelow = height - paddingBottom - titleHeight - spaceAbove - paddingTop;
                    if (spaceBelow < toplp.bottomMargin + mTitleMarginBottom) {
                        spaceAbove = Math.max(0, spaceAbove - (bottomlp.bottomMargin + mTitleMarginBottom - spaceBelow));
                    }
                }
                titleTop = paddingTop + spaceAbove;
                break;
            case Gravity.BOTTOM:
                titleTop = height - paddingBottom - bottomlp.bottomMargin - mTitleMarginBottom - titleHeight;
                break;
        }
        if (isRtl) {
            final int rd = (titleHasWidth ? mTitleMarginStart : 0) - collapsingMargins[1];
            right -= Math.max(0, rd);
            collapsingMargins[1] = Math.max(0, -rd);
            int titleRight = right;
            int subtitleRight = right;
            if (layoutTitle) {
                final LayoutParams lp = (LayoutParams) mTitleTextView.getLayoutParams();
                final int titleLeft = titleRight - mTitleTextView.getMeasuredWidth();
                final int titleBottom = titleTop + mTitleTextView.getMeasuredHeight();
                mTitleTextView.layout(titleLeft, titleTop, titleRight, titleBottom);
                titleRight = titleLeft - mTitleMarginEnd;
                titleTop = titleBottom + lp.bottomMargin;
            }
            if (layoutSubtitle) {
                final LayoutParams lp = (LayoutParams) mSubtitleTextView.getLayoutParams();
                titleTop += lp.topMargin;
                final int subtitleLeft = subtitleRight - mSubtitleTextView.getMeasuredWidth();
                final int subtitleBottom = titleTop + mSubtitleTextView.getMeasuredHeight();
                mSubtitleTextView.layout(subtitleLeft, titleTop, subtitleRight, subtitleBottom);
                subtitleRight = subtitleRight - mTitleMarginEnd;
                titleTop = subtitleBottom + lp.bottomMargin;
            }
            if (titleHasWidth) {
                right = Math.min(titleRight, subtitleRight);
            }
        } else {
            final int ld = (titleHasWidth ? mTitleMarginStart : 0) - collapsingMargins[0];
            left += Math.max(0, ld);
            collapsingMargins[0] = Math.max(0, -ld);
            int titleLeft = left;
            int subtitleLeft = left;
            if (layoutTitle) {
                final LayoutParams lp = (LayoutParams) mTitleTextView.getLayoutParams();
                final int titleRight = titleLeft + mTitleTextView.getMeasuredWidth();
                final int titleBottom = titleTop + mTitleTextView.getMeasuredHeight();
                mTitleTextView.layout(titleLeft, titleTop, titleRight, titleBottom);
                titleLeft = titleRight + mTitleMarginEnd;
                titleTop = titleBottom + lp.bottomMargin;
            }
            if (layoutSubtitle) {
                final LayoutParams lp = (LayoutParams) mSubtitleTextView.getLayoutParams();
                titleTop += lp.topMargin;
                final int subtitleRight = subtitleLeft + mSubtitleTextView.getMeasuredWidth();
                final int subtitleBottom = titleTop + mSubtitleTextView.getMeasuredHeight();
                mSubtitleTextView.layout(subtitleLeft, titleTop, subtitleRight, subtitleBottom);
                subtitleLeft = subtitleRight + mTitleMarginEnd;
                titleTop = subtitleBottom + lp.bottomMargin;
            }
            if (titleHasWidth) {
                left = Math.max(titleLeft, subtitleLeft);
            }
        }
    }
    // Get all remaining children sorted for layout. This is all prepared
    // such that absolute layout direction can be used below.
    addCustomViewsWithGravity(mTempViews, Gravity.LEFT);
    final int leftViewsCount = mTempViews.size();
    for (int i = 0; i < leftViewsCount; i++) {
        left = layoutChildLeft(mTempViews.get(i), left, collapsingMargins, alignmentHeight);
    }
    addCustomViewsWithGravity(mTempViews, Gravity.RIGHT);
    final int rightViewsCount = mTempViews.size();
    for (int i = 0; i < rightViewsCount; i++) {
        right = layoutChildRight(mTempViews.get(i), right, collapsingMargins, alignmentHeight);
    }
    // Centered views try to center with respect to the whole bar, but views pinned
    // to the left or right can push the mass of centered views to one side or the other.
    addCustomViewsWithGravity(mTempViews, Gravity.CENTER_HORIZONTAL);
    final int centerViewsWidth = getViewListMeasuredWidth(mTempViews, collapsingMargins);
    final int parentCenter = paddingLeft + (width - paddingLeft - paddingRight) / 2;
    final int halfCenterViewsWidth = centerViewsWidth / 2;
    int centerLeft = parentCenter - halfCenterViewsWidth;
    final int centerRight = centerLeft + centerViewsWidth;
    if (centerLeft < left) {
        centerLeft = left;
    } else if (centerRight > right) {
        centerLeft -= centerRight - right;
    }
    final int centerViewsCount = mTempViews.size();
    for (int i = 0; i < centerViewsCount; i++) {
        centerLeft = layoutChildLeft(mTempViews.get(i), centerLeft, collapsingMargins, alignmentHeight);
    }
    mTempViews.clear();
}","{
    final boolean isRtl = getLayoutDirection() == LAYOUT_DIRECTION_RTL;
    final int width = getWidth();
    final int height = getHeight();
    final int paddingLeft = getPaddingLeft();
    final int paddingRight = getPaddingRight();
    final int paddingTop = getPaddingTop();
    final int paddingBottom = getPaddingBottom();
    int left = paddingLeft;
    int right = width - paddingRight;
    final int[] collapsingMargins = mTempMargins;
    collapsingMargins[0] = collapsingMargins[1] = 0;
    // Align views within the minimum toolbar height, if set.
    final int minHeight = getMinimumHeight();
    final int alignmentHeight = minHeight >= 0 ? Math.min(minHeight, b - t) : 0;
    if (shouldLayout(mNavButtonView)) {
        if (isRtl) {
            right = layoutChildRight(mNavButtonView, right, collapsingMargins, alignmentHeight);
        } else {
            left = layoutChildLeft(mNavButtonView, left, collapsingMargins, alignmentHeight);
        }
    }
    if (shouldLayout(mCollapseButtonView)) {
        if (isRtl) {
            right = layoutChildRight(mCollapseButtonView, right, collapsingMargins, alignmentHeight);
        } else {
            left = layoutChildLeft(mCollapseButtonView, left, collapsingMargins, alignmentHeight);
        }
    }
    if (shouldLayout(mMenuView)) {
        if (isRtl) {
            left = layoutChildLeft(mMenuView, left, collapsingMargins, alignmentHeight);
        } else {
            right = layoutChildRight(mMenuView, right, collapsingMargins, alignmentHeight);
        }
    }
    final int contentInsetLeft = getCurrentContentInsetLeft();
    final int contentInsetRight = getCurrentContentInsetRight();
    collapsingMargins[0] = Math.max(0, contentInsetLeft - left);
    collapsingMargins[1] = Math.max(0, contentInsetRight - (width - paddingRight - right));
    left = Math.max(left, contentInsetLeft);
    right = Math.min(right, width - paddingRight - contentInsetRight);
    if (shouldLayout(mExpandedActionView)) {
        if (isRtl) {
            right = layoutChildRight(mExpandedActionView, right, collapsingMargins, alignmentHeight);
        } else {
            left = layoutChildLeft(mExpandedActionView, left, collapsingMargins, alignmentHeight);
        }
    }
    if (shouldLayout(mLogoView)) {
        if (isRtl) {
            right = layoutChildRight(mLogoView, right, collapsingMargins, alignmentHeight);
        } else {
            left = layoutChildLeft(mLogoView, left, collapsingMargins, alignmentHeight);
        }
    }
    final boolean layoutTitle = shouldLayout(mTitleTextView);
    final boolean layoutSubtitle = shouldLayout(mSubtitleTextView);
    int titleHeight = 0;
    if (layoutTitle) {
        final LayoutParams lp = (LayoutParams) mTitleTextView.getLayoutParams();
        titleHeight += lp.topMargin + mTitleTextView.getMeasuredHeight() + lp.bottomMargin;
    }
    if (layoutSubtitle) {
        final LayoutParams lp = (LayoutParams) mSubtitleTextView.getLayoutParams();
        titleHeight += lp.topMargin + mSubtitleTextView.getMeasuredHeight() + lp.bottomMargin;
    }
    if (layoutTitle || layoutSubtitle) {
        int titleTop;
        final View topChild = layoutTitle ? mTitleTextView : mSubtitleTextView;
        final View bottomChild = layoutSubtitle ? mSubtitleTextView : mTitleTextView;
        final LayoutParams toplp = (LayoutParams) topChild.getLayoutParams();
        final LayoutParams bottomlp = (LayoutParams) bottomChild.getLayoutParams();
        final boolean titleHasWidth = layoutTitle && mTitleTextView.getMeasuredWidth() > 0 || layoutSubtitle && mSubtitleTextView.getMeasuredWidth() > 0;
        switch(mGravity & Gravity.VERTICAL_GRAVITY_MASK) {
            case Gravity.TOP:
                titleTop = getPaddingTop() + toplp.topMargin + mTitleMarginTop;
                break;
            default:
            case Gravity.CENTER_VERTICAL:
                final int space = height - paddingTop - paddingBottom;
                int spaceAbove = (space - titleHeight) / 2;
                if (spaceAbove < toplp.topMargin + mTitleMarginTop) {
                    spaceAbove = toplp.topMargin + mTitleMarginTop;
                } else {
                    final int spaceBelow = height - paddingBottom - titleHeight - spaceAbove - paddingTop;
                    if (spaceBelow < toplp.bottomMargin + mTitleMarginBottom) {
                        spaceAbove = Math.max(0, spaceAbove - (bottomlp.bottomMargin + mTitleMarginBottom - spaceBelow));
                    }
                }
                titleTop = paddingTop + spaceAbove;
                break;
            case Gravity.BOTTOM:
                titleTop = height - paddingBottom - bottomlp.bottomMargin - mTitleMarginBottom - titleHeight;
                break;
        }
        if (isRtl) {
            final int rd = (titleHasWidth ? mTitleMarginStart : 0) - collapsingMargins[1];
            right -= Math.max(0, rd);
            collapsingMargins[1] = Math.max(0, -rd);
            int titleRight = right;
            int subtitleRight = right;
            if (layoutTitle) {
                final LayoutParams lp = (LayoutParams) mTitleTextView.getLayoutParams();
                final int titleLeft = titleRight - mTitleTextView.getMeasuredWidth();
                final int titleBottom = titleTop + mTitleTextView.getMeasuredHeight();
                mTitleTextView.layout(titleLeft, titleTop, titleRight, titleBottom);
                titleRight = titleLeft - mTitleMarginEnd;
                titleTop = titleBottom + lp.bottomMargin;
            }
            if (layoutSubtitle) {
                final LayoutParams lp = (LayoutParams) mSubtitleTextView.getLayoutParams();
                titleTop += lp.topMargin;
                final int subtitleLeft = subtitleRight - mSubtitleTextView.getMeasuredWidth();
                final int subtitleBottom = titleTop + mSubtitleTextView.getMeasuredHeight();
                mSubtitleTextView.layout(subtitleLeft, titleTop, subtitleRight, subtitleBottom);
                subtitleRight = subtitleRight - mTitleMarginEnd;
                titleTop = subtitleBottom + lp.bottomMargin;
            }
            if (titleHasWidth) {
                right = Math.min(titleRight, subtitleRight);
            }
        } else {
            final int ld = (titleHasWidth ? mTitleMarginStart : 0) - collapsingMargins[0];
            left += Math.max(0, ld);
            collapsingMargins[0] = Math.max(0, -ld);
            int titleLeft = left;
            int subtitleLeft = left;
            if (layoutTitle) {
                final LayoutParams lp = (LayoutParams) mTitleTextView.getLayoutParams();
                final int titleRight = titleLeft + mTitleTextView.getMeasuredWidth();
                final int titleBottom = titleTop + mTitleTextView.getMeasuredHeight();
                mTitleTextView.layout(titleLeft, titleTop, titleRight, titleBottom);
                titleLeft = titleRight + mTitleMarginEnd;
                titleTop = titleBottom + lp.bottomMargin;
            }
            if (layoutSubtitle) {
                final LayoutParams lp = (LayoutParams) mSubtitleTextView.getLayoutParams();
                titleTop += lp.topMargin;
                final int subtitleRight = subtitleLeft + mSubtitleTextView.getMeasuredWidth();
                final int subtitleBottom = titleTop + mSubtitleTextView.getMeasuredHeight();
                mSubtitleTextView.layout(subtitleLeft, titleTop, subtitleRight, subtitleBottom);
                subtitleLeft = subtitleRight + mTitleMarginEnd;
                titleTop = subtitleBottom + lp.bottomMargin;
            }
            if (titleHasWidth) {
                left = Math.max(titleLeft, subtitleLeft);
            }
        }
    }
    // Get all remaining children sorted for layout. This is all prepared
    // such that absolute layout direction can be used below.
    addCustomViewsWithGravity(mTempViews, Gravity.LEFT);
    final int leftViewsCount = mTempViews.size();
    for (int i = 0; i < leftViewsCount; i++) {
        left = layoutChildLeft(mTempViews.get(i), left, collapsingMargins, alignmentHeight);
    }
    addCustomViewsWithGravity(mTempViews, Gravity.RIGHT);
    final int rightViewsCount = mTempViews.size();
    for (int i = 0; i < rightViewsCount; i++) {
        right = layoutChildRight(mTempViews.get(i), right, collapsingMargins, alignmentHeight);
    }
    // Centered views try to center with respect to the whole bar, but views pinned
    // to the left or right can push the mass of centered views to one side or the other.
    addCustomViewsWithGravity(mTempViews, Gravity.CENTER_HORIZONTAL);
    final int centerViewsWidth = getViewListMeasuredWidth(mTempViews, collapsingMargins);
    final int parentCenter = paddingLeft + (width - paddingLeft - paddingRight) / 2;
    final int halfCenterViewsWidth = centerViewsWidth / 2;
    int centerLeft = parentCenter - halfCenterViewsWidth;
    final int centerRight = centerLeft + centerViewsWidth;
    if (centerLeft < left) {
        centerLeft = left;
    } else if (centerRight > right) {
        centerLeft -= centerRight - right;
    }
    final int centerViewsCount = mTempViews.size();
    for (int i = 0; i < centerViewsCount; i++) {
        centerLeft = layoutChildLeft(mTempViews.get(i), centerLeft, collapsingMargins, alignmentHeight);
    }
    mTempViews.clear();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
896,"<android.widget.ArrayAdapter: ArrayAdapter<CharSequence> createFromResource(Context,int,int)>",25,26,"<android.widget.ArrayAdapter: ArrayAdapter<CharSequence> createFromResource(Context,int,int)>","<android.widget.ArrayAdapter: ArrayAdapter<CharSequence> createFromResource(Context,int,int)>",0,"{
    final CharSequence[] strings = context.getResources().getTextArray(textArrayResId);
    return new ArrayAdapter<>(context, textViewResId, strings);
}","{
    final CharSequence[] strings = context.getResources().getTextArray(textArrayResId);
    return new ArrayAdapter<>(context, textViewResId, 0, Arrays.asList(strings), true);
}",1,"/**
 * Creates a new ArrayAdapter from external resources. The content of the array is
 * obtained through {@link android.content.res.Resources#getTextArray(int)}.
 *
 * @param context The application's environment.
 * @param textArrayResId The identifier of the array to use as the data source.
 * @param textViewResId The identifier of the layout used to create views.
 *
 * @return An ArrayAdapter<CharSequence>.
 */
","/**
 * Creates a new ArrayAdapter from external resources. The content of the array is
 * obtained through {@link android.content.res.Resources#getTextArray(int)}.
 *
 * @param context The application's environment.
 * @param textArrayResId The identifier of the array to use as the data source.
 * @param textViewResId The identifier of the layout used to create views.
 *
 * @return An ArrayAdapter<CharSequence>.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"1,5",1,"The constructor call for ArrayAdapter<> has changed, with new parameters added (a list created from the array, and 'true'). This indicates that the dependent API ArrayAdapter<>(Context, int, int, List<CharSequence>, boolean) has been used instead of ArrayAdapter<>(Context, int, CharSequence[]). Thus, the code change classification includes 1 (Return statement changed) due to the new constructor behavior and also 5 (Dependent API changed) because the constructor itself is a different API.","Because the constructor of ArrayAdapter is changed and extra arguments are passed to it, the behavior of the resulting ArrayAdapter instance can be different, potentially affecting how the adapter handles the list and the default behavior indicated by the 'true' argument. Thus, there's a CI caused by potential different return values or types, type 1."
897,<android.app.DownloadManager: String[] getWhereArgsForIds(long[])>,25,26,<android.app.DownloadManager: String[] getWhereArgsForIds(long[])>,<android.app.DownloadManager: String[] getWhereArgsForIds(long[])>,0,"{
    String[] whereArgs = new String[ids.length];
    for (int i = 0; i < ids.length; i++) {
        whereArgs[i] = Long.toString(ids[i]);
    }
    return whereArgs;
}","{
    String[] whereArgs = new String[ids.length];
    return getWhereArgsForIds(ids, whereArgs);
}",1,"/**
 * Get the selection args for a clause returned by {@link #getWhereClauseForIds(long[])}.
 */
","/**
 * Get the selection args for a clause returned by {@link #getWhereClauseForIds(long[])}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The late version replaced the loop with a function call getWhereArgsForIds(ids, whereArgs). This indicates a change in the dependent API as the implementation relies on an external method now.","There is no compatibility issue because the behavior of the method is expected to remain the same. The function getWhereArgsForIds is likely a refactoring to improve code reuse, but it's designed to achieve the same result as the inlined loop in the early version."
898,<android.hardware.camera2.impl.CameraMetadataNative.Key: int getTag()>,25,26,<android.hardware.camera2.impl.CameraMetadataNative.Key: int getTag()>,<android.hardware.camera2.impl.CameraMetadataNative.Key: int getTag()>,0,"{
    if (!mHasTag) {
        mTag = CameraMetadataNative.getTag(mName);
        mHasTag = true;
    }
    return mTag;
}","{
    if (!mHasTag) {
        mTag = CameraMetadataNative.getTag(mName, mVendorId);
        mHasTag = true;
    }
    return mTag;
}",1,"/**
 * <p>
 * Get the tag corresponding to this key. This enables insertion into the
 * native metadata.
 * </p>
 *
 * <p>This value is looked up the first time, and cached subsequently.</p>
 *
 * @return The tag numeric value corresponding to the string
 */
","/**
 * <p>
 * Get the tag corresponding to this key. This enables insertion into the
 * native metadata.
 * </p>
 *
 * <p>This value is looked up the first time, and cached subsequently.</p>
 *
 * @return The tag numeric value corresponding to the string
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,5",0,"The CameraMetadataNative.getTag() method has changed, it now includes an additional parameter 'mVendorId', and the control dependency remains unchanged. Therefore, the code change type is 3 for the control dependency change and 5 for the dependent API changed.","There is no Compatibility Issue since the method's return type and control flow have not changed, the added parameter 'mVendorId' must have been accounted for in the updated CameraMetadataNative.getTag(). The internal implementation detail is abstracted from the API user, and the return type of getTag() remains an int, which should not affect existing implementations assuming 'mVendorId' is properly handled within getTag(). Hence, the CI type is 0."
899,<android.app.ContextImpl: Context createConfigurationContext(Configuration)>,25,26,<android.app.ContextImpl: Context createConfigurationContext(Configuration)>,<android.app.ContextImpl: Context createConfigurationContext(Configuration)>,0,"{
    if (overrideConfiguration == null) {
        throw new IllegalArgumentException(""overrideConfiguration must not be null"");
    }
    return new ContextImpl(this, mMainThread, mPackageInfo, mActivityToken, mUser, mFlags, mDisplay, overrideConfiguration, Display.INVALID_DISPLAY);
}","{
    if (overrideConfiguration == null) {
        throw new IllegalArgumentException(""overrideConfiguration must not be null"");
    }
    ContextImpl context = new ContextImpl(this, mMainThread, mPackageInfo, mSplitName, mActivityToken, mUser, mFlags, mClassLoader);
    final int displayId = mDisplay != null ? mDisplay.getDisplayId() : Display.DEFAULT_DISPLAY;
    context.setResources(createResources(mActivityToken, mPackageInfo, mSplitName, displayId, overrideConfiguration, getDisplayAdjustments(displayId).getCompatibilityInfo()));
    return context;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4,5",1,"The implementation of the method has changed significantly, which includes the construction of a new `ContextImpl` object with a different set of parameters and setting its resources separately using `setResources()`. In the early version, the `ContextImpl` is being constructed with parameters such as `mDisplay` and `overrideConfiguration`, while in the late version, a new variable `context` is created with a different set of parameters and the display ID is calculated separately using `mDisplay.getDisplayId()`. Additionally, the resources for `context` are set using a separate method `createResources()`, which includes additional parameters `mSplitName`, `displayId`, `overrideConfiguration`, and `getDisplayAdjustments(displayId).getCompatibilityInfo()`. These changes included reorganizing the control flow and introduction of new local variables and method calls. This indicates that control dependencies have changed, other statements have changed, and dependent APIs have changed, so the code change types are 3, 4, and 5.","Due to the changes in how the `ContextImpl` is created and how its resources are initialized, there is a potential for the late version of the method to return a `Context` object that behaves differently than what the early version would return. This constitutes a change in the potential return value which leads to CI type 1."
900,<android.app.Activity: boolean releaseInstance()>,25,26,<android.app.Activity: boolean releaseInstance()>,<android.app.Activity: boolean releaseInstance()>,0,"{
    try {
        return ActivityManagerNative.getDefault().releaseActivityInstance(mToken);
    } catch (RemoteException e) {
    // Empty
    }
    return false;
}","{
    try {
        return ActivityManager.getService().releaseActivityInstance(mToken);
    } catch (RemoteException e) {
    // Empty
    }
    return false;
}",1,"/**
 * Ask that the local app instance of this activity be released to free up its memory.
 * This is asking for the activity to be destroyed, but does <b>not</b> finish the activity --
 * a new instance of the activity will later be re-created if needed due to the user
 * navigating back to it.
 *
 * @return Returns true if the activity was in a state that it has started the process
 * of destroying its current instance; returns false if for any reason this could not
 * be done: it is currently visible to the user, it is already being destroyed, it is
 * being finished, it hasn't yet saved its state, etc.
 */
","/**
 * Ask that the local app instance of this activity be released to free up its memory.
 * This is asking for the activity to be destroyed, but does <b>not</b> finish the activity --
 * a new instance of the activity will later be re-created if needed due to the user
 * navigating back to it.
 *
 * @return Returns true if the activity was in a state that it has started the process
 * of destroying its current instance; returns false if for any reason this could not
 * be done: it is currently visible to the user, it is already being destroyed, it is
 * being finished, it hasn't yet saved its state, etc.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent API changed from `ActivityManagerNative.getDefault()` to `ActivityManager.getService()`, thus the code change type is 5.","No Compatibility Issue arises from this change since the same return value and exception handling are present, and the change is an internal one which does not affect the API's external behavior. The surrounding try-catch block and return value remain unchanged, so there is no potential difference in return values or exception handlings introduced by this update."
902,<android.app.FragmentManagerImpl: void makeInactive(Fragment)>,25,26,<android.app.FragmentManagerImpl: void makeInactive(Fragment)>,<android.app.FragmentManagerImpl: void makeInactive(Fragment)>,0,"{
    if (f.mIndex < 0) {
        return;
    }
    if (DEBUG)
        Log.v(TAG, ""Freeing fragment index "" + f);
    mActive.set(f.mIndex, null);
    if (mAvailIndices == null) {
        mAvailIndices = new ArrayList<Integer>();
    }
    mAvailIndices.add(f.mIndex);
    mHost.inactivateFragment(f.mWho);
    f.initState();
}","{
    if (f.mIndex < 0) {
        return;
    }
    if (DEBUG)
        Log.v(TAG, ""Freeing fragment index "" + f);
    // Don't remove yet. That happens in burpActive(). This prevents
    // concurrent modification while iterating over mActive
    mActive.put(f.mIndex, null);
    mHost.inactivateFragment(f.mWho);
    f.initState();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method to make an entry null has changed from 'mActive.set(f.mIndex, null)' to 'mActive.put(f.mIndex, null)', and a comment is added to explain the behavior. So the change type is 4.","This change should not cause a compatibility issue since the outcome of both operations is the same: the entry at index 'f.mIndex' is set to null. It is an internal implementation detail rather than a change in API behavior. Therefore, the CI type is 0."
903,<android.app.TabActivity: void onContentChanged()>,25,26,<android.app.TabActivity: void onContentChanged()>,<android.app.TabActivity: void onContentChanged()>,0,"{
    super.onContentChanged();
    mTabHost = (TabHost) findViewById(com.android.internal.R.id.tabhost);
    if (mTabHost == null) {
        throw new RuntimeException(""Your content must have a TabHost whose id attribute is "" + ""'android.R.id.tabhost'"");
    }
    mTabHost.setup(getLocalActivityManager());
}","{
    super.onContentChanged();
    mTabHost = findViewById(com.android.internal.R.id.tabhost);
    if (mTabHost == null) {
        throw new RuntimeException(""Your content must have a TabHost whose id attribute is "" + ""'android.R.id.tabhost'"");
    }
    mTabHost.setup(getLocalActivityManager());
}",1,"/**
 * Updates the screen state (current list and other views) when the
 * content changes.
 *
 * @see Activity#onContentChanged()
 */
","/**
 * Updates the screen state (current list and other views) when the
 * content changes.
 *
 * @see Activity#onContentChanged()
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"There's a change in how mTabHost is cast. The explicit cast to (TabHost) has been removed. Because findViewById() method is designed to return a View, and mTabHost is being assigned to this method's return value, there's no observable behavior change from the point of view of an API consumer. The mTabHost still expects a View of type TabHost to be returned from findViewById(), and code inside onContentChanged() method remains functionally identical assuming findViewById() returns the correct type. Therefore, the code change type is 4.","There is no compatibility issue because the change doesn't affect how the method operates from an external point of view. The method's contract is still the same - it either successfully finds the TabHost and sets it up or throws a RuntimeException if it fails to find it. The removal of the explicit cast does not change any behavior as long as the id 'tabhost' refers to a TabHost; otherwise, it would have resulted in a ClassCastException at runtime in the previous version as well, signaling incorrect usage of the API. Hence, no compatibility issue is introduced by this change."
904,<android.app.ActivityManager: void getMyMemoryState(RunningAppProcessInfo)>,25,26,<android.app.ActivityManager: void getMyMemoryState(RunningAppProcessInfo)>,<android.app.ActivityManager: void getMyMemoryState(RunningAppProcessInfo)>,0,"{
    try {
        ActivityManagerNative.getDefault().getMyMemoryState(outState);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        getService().getMyMemoryState(outState);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Return global memory state information for the calling process.  This
 * does not fill in all fields of the {@link RunningAppProcessInfo}.  The
 * only fields that will be filled in are
 * {@link RunningAppProcessInfo#pid},
 * {@link RunningAppProcessInfo#uid},
 * {@link RunningAppProcessInfo#lastTrimLevel},
 * {@link RunningAppProcessInfo#importance},
 * {@link RunningAppProcessInfo#lru}, and
 * {@link RunningAppProcessInfo#importanceReasonCode}.
 */
","/**
 * Return global memory state information for the calling process.  This
 * does not fill in all fields of the {@link RunningAppProcessInfo}.  The
 * only fields that will be filled in are
 * {@link RunningAppProcessInfo#pid},
 * {@link RunningAppProcessInfo#uid},
 * {@link RunningAppProcessInfo#lastTrimLevel},
 * {@link RunningAppProcessInfo#importance},
 * {@link RunningAppProcessInfo#lru}, and
 * {@link RunningAppProcessInfo#importanceReasonCode}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method called within try block is changed from `ActivityManagerNative.getDefault().getMyMemoryState(outState)` to `getService().getMyMemoryState(outState)`, which indicates that the dependent API has changed, hence the code change type is 5.","There is no indication that the change to the dependent API would lead to different behavior in terms of exceptions thrown or return values, since the exception handling remains unchanged and there is no return value involved in this API (it's a `void` method). Therefore, there is no Compatibility Issue and the CI type is 0."
907,<android.app.Activity: int getTaskId()>,25,26,<android.app.Activity: int getTaskId()>,<android.app.Activity: int getTaskId()>,0,"{
    try {
        return ActivityManagerNative.getDefault().getTaskForActivity(mToken, false);
    } catch (RemoteException e) {
        return -1;
    }
}","{
    try {
        return ActivityManager.getService().getTaskForActivity(mToken, false);
    } catch (RemoteException e) {
        return -1;
    }
}",1,"/**
 * Return the identifier of the task this activity is in.  This identifier
 * will remain the same for the lifetime of the activity.
 *
 * @return Task identifier, an opaque integer.
 */
","/**
 * Return the identifier of the task this activity is in.  This identifier
 * will remain the same for the lifetime of the activity.
 *
 * @return Task identifier, an opaque integer.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method used to obtain the service has changed from ActivityManagerNative.getDefault() to ActivityManager.getService(), although the method called on the service (getTaskForActivity) is the same. Therefore, this change does not affect the return statement or exception handling but involves a dependent API, leading to code change type 5.","The change to how the service is obtained should not directly lead to a different behavior of the method itself, provided that the method getTaskForActivity(mToken, false) behaves the same way in both versions of the service. No new return statements or error handling logic are introduced, and the change doesn't modify the return value or the exceptions thrown by the API method. Hence, no compatibility issue is expected, which is 0."
911,<android.app.ActivityThread.StopInfo: void run()>,25,26,<android.app.ActivityThread.StopInfo: void run()>,<android.app.ActivityThread.StopInfo: void run()>,0,"{
    // Tell activity manager we have been stopped.
    try {
        if (DEBUG_MEMORY_TRIM)
            Slog.v(TAG, ""Reporting activity stopped: "" + activity);
        ActivityManagerNative.getDefault().activityStopped(activity.token, state, persistentState, description);
    } catch (RemoteException ex) {
        if (ex instanceof TransactionTooLargeException && activity.packageInfo.getTargetSdkVersion() < Build.VERSION_CODES.N) {
            Log.e(TAG, ""App sent too much data in instance state, so it was ignored"", ex);
            return;
        }
        throw ex.rethrowFromSystemServer();
    }
}","{
    // Tell activity manager we have been stopped.
    try {
        if (DEBUG_MEMORY_TRIM)
            Slog.v(TAG, ""Reporting activity stopped: "" + activity);
        ActivityManager.getService().activityStopped(activity.token, state, persistentState, description);
    } catch (RemoteException ex) {
        if (ex instanceof TransactionTooLargeException && activity.packageInfo.getTargetSdkVersion() < Build.VERSION_CODES.N) {
            Log.e(TAG, ""App sent too much data in instance state, so it was ignored"", ex);
            return;
        }
        throw ex.rethrowFromSystemServer();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The change is in the method call within the try block: 'ActivityManagerNative.getDefault().activityStopped' has been changed to 'ActivityManager.getService().activityStopped'. This is an indication that the dependent API has changed, hence the code change type is 5.","There is no Compatibility Issue because the modification is an internal call to a different method that achieves the same end, and the exception handling and return logic have not changed. There is no change in the method signature, return type, or thrown exceptions that would affect callers of this method, so the CI type is 0."
912,<android.hardware.camera2.impl.CameraDeviceImpl: void prepare(Surface)>,25,26,<android.hardware.camera2.impl.CameraDeviceImpl: void prepare(Surface)>,<android.hardware.camera2.impl.CameraDeviceImpl: void prepare(Surface)>,0,"{
    if (surface == null)
        throw new IllegalArgumentException(""Surface is null"");
    synchronized (mInterfaceLock) {
        int streamId = -1;
        for (int i = 0; i < mConfiguredOutputs.size(); i++) {
            if (surface == mConfiguredOutputs.valueAt(i).getSurface()) {
                streamId = mConfiguredOutputs.keyAt(i);
                break;
            }
        }
        if (streamId == -1) {
            throw new IllegalArgumentException(""Surface is not part of this session"");
        }
        mRemoteDevice.prepare(streamId);
    }
}","{
    if (surface == null)
        throw new IllegalArgumentException(""Surface is null"");
    synchronized (mInterfaceLock) {
        int streamId = -1;
        for (int i = 0; i < mConfiguredOutputs.size(); i++) {
            final List<Surface> surfaces = mConfiguredOutputs.valueAt(i).getSurfaces();
            if (surfaces.contains(surface)) {
                streamId = mConfiguredOutputs.keyAt(i);
                break;
            }
        }
        if (streamId == -1) {
            throw new IllegalArgumentException(""Surface is not part of this session"");
        }
        mRemoteDevice.prepare(streamId);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The method implementation has changed to check against a list of surfaces using `surfaces.contains(surface)` instead of directly comparing the Surface object with `getSurface()`. This is a control dependency change (type 3) because the logic inside the loop has been modified. Moreover, since the type of operation on the Surface object within the loop iteration has shifted from a direct getter method to a list containment check, it is also an 'other statement changed' (type 4).","Despite this modification, the change in iteration logic does not affect the invariant conditions that will cause the exceptions, nor does it alter the final return value (since there's no return here). The conditions for throwing IllegalArgumentException remain consistent with the previous implementation. Therefore, no Compatibility Issue exists as the final outcome of the method does not differ."
915,"<android.app.ContextImpl: Context createPackageContextAsUser(String,int,UserHandle)>",25,26,"<android.app.ContextImpl: Context createPackageContextAsUser(String,int,UserHandle)>","<android.app.ContextImpl: Context createPackageContextAsUser(String,int,UserHandle)>",0,"{
    if (packageName.equals(""system"") || packageName.equals(""android"")) {
        return new ContextImpl(this, mMainThread, mPackageInfo, mActivityToken, user, flags, mDisplay, null, Display.INVALID_DISPLAY);
    }
    LoadedApk pi = mMainThread.getPackageInfo(packageName, mResources.getCompatibilityInfo(), flags | CONTEXT_REGISTER_PACKAGE, user.getIdentifier());
    if (pi != null) {
        ContextImpl c = new ContextImpl(this, mMainThread, pi, mActivityToken, user, flags, mDisplay, null, Display.INVALID_DISPLAY);
        if (c.mResources != null) {
            return c;
        }
    }
    // Should be a better exception.
    throw new PackageManager.NameNotFoundException(""Application package "" + packageName + "" not found"");
}","{
    if (packageName.equals(""system"") || packageName.equals(""android"")) {
        // the context without reloading Resources.
        return new ContextImpl(this, mMainThread, mPackageInfo, null, mActivityToken, user, flags, null);
    }
    LoadedApk pi = mMainThread.getPackageInfo(packageName, mResources.getCompatibilityInfo(), flags | CONTEXT_REGISTER_PACKAGE, user.getIdentifier());
    if (pi != null) {
        ContextImpl c = new ContextImpl(this, mMainThread, pi, null, mActivityToken, user, flags, null);
        final int displayId = mDisplay != null ? mDisplay.getDisplayId() : Display.DEFAULT_DISPLAY;
        c.setResources(createResources(mActivityToken, pi, null, displayId, null, getDisplayAdjustments(displayId).getCompatibilityInfo()));
        if (c.mResources != null) {
            return c;
        }
    }
    // Should be a better exception.
    throw new PackageManager.NameNotFoundException(""Application package "" + packageName + "" not found"");
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,"The constructor calls for ContextImpl and how the Resources are handled have changed between the two versions. Specifically, different sets of parameters are used in the constructor calls, and there is an additional method call to setResources in the late version. Additionally, a control dependency on mDisplay is introduced for obtaining the displayId which alters how the Resources are created. These changes fall under types 1 (Return statement changed), 3 (Control dependency changed), and 4 (Other statement changed).","The changes in how the ContextImpl instances are created, including the changes in the parameters provided to the constructors and the additional method call to setResources, can affect the state and functionality of the returned Context object. Additionally, the creation of Resources based on displayId introduces a new behavior that is dependent on the mDisplay variable, which was not present before. Thus, there is a potential Compatibility Issue due to different return values or types (type 1)."
916,<android.app.Fragment: void setExitSharedElementCallback(SharedElementCallback)>,25,26,<android.app.Fragment: void setExitSharedElementCallback(SharedElementCallback)>,<android.app.Fragment: void setExitSharedElementCallback(SharedElementCallback)>,0,"{
    if (callback == null) {
        callback = SharedElementCallback.NULL_CALLBACK;
    }
    mExitTransitionCallback = callback;
}","{
    if (callback == null) {
        if (mAnimationInfo == null) {
            // already a null callback
            return;
        }
        callback = SharedElementCallback.NULL_CALLBACK;
    }
    ensureAnimationInfo().mExitTransitionCallback = callback;
}",1,"/**
 * When custom transitions are used with Fragments, the exit transition callback
 * is called when this Fragment is attached or detached when popping the back stack.
 *
 * @param callback Used to manipulate the shared element transitions on this Fragment
 * when added as a pop from the back stack.
 */
","/**
 * When custom transitions are used with Fragments, the exit transition callback
 * is called when this Fragment is attached or detached when popping the back stack.
 *
 * @param callback Used to manipulate the shared element transitions on this Fragment
 * when added as a pop from the back stack.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",0,"The control has changed with an introduction of a new if statement to check for mAnimationInfo’s nullity before assigning NULL_CALLBACK to the callback. A new method call `ensureAnimationInfo()` is introduced before assigning value to `mExitTransitionCallback`, so the code change types involved are 3 (Control dependency change), 4 (Other statement changed), and 5 (Dependent API changed).","There is no Compatibility Issue here because the behavior of setting the exit shared element callback doesn't fundamentally change. The changes made are set to ensure that the callback is not null or if it's supposed to be null, the system handles it internally. If the callback is null, it is assigned the NULL_CALLBACK just like in the previous version if `mAnimationInfo` is not null. In all other cases, it proceeds as usual. The update with `ensureAnimationInfo()` does not change the behavior from an external standpoint but rather ensures internal states are correctly managed. Hence, there is no change in the return type or the way exceptions are thrown that would affect the compatibility."
917,"<android.os.Vibrator: void vibrate(long,AudioAttributes)>",25,26,"<android.os.Vibrator: void vibrate(long,AudioAttributes)>","<android.os.Vibrator: void vibrate(long,AudioAttributes)>",0,"{
    vibrate(Process.myUid(), mPackageName, milliseconds, attributes);
}","{
    try {
        // This ignores all exceptions to stay compatible with pre-O implementations.
        VibrationEffect effect = VibrationEffect.createOneShot(milliseconds, VibrationEffect.DEFAULT_AMPLITUDE);
        vibrate(effect, attributes);
    } catch (IllegalArgumentException iae) {
        Log.e(TAG, ""Failed to create VibrationEffect"", iae);
    }
}",1,"/**
 * Vibrate constantly for the specified period of time.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#VIBRATE}.
 *
 * @param milliseconds The number of milliseconds to vibrate.
 * @param attributes {@link AudioAttributes} corresponding to the vibration. For example,
 * specify {@link AudioAttributes#USAGE_ALARM} for alarm vibrations or
 * {@link AudioAttributes#USAGE_NOTIFICATION_RINGTONE} for
 * vibrations associated with incoming calls.
 */
","/**
 * Vibrate constantly for the specified period of time.
 *
 * @param milliseconds The number of milliseconds to vibrate.
 * @param attributes {@link AudioAttributes} corresponding to the vibration. For example,
 * specify {@link AudioAttributes#USAGE_ALARM} for alarm vibrations or
 * {@link AudioAttributes#USAGE_NOTIFICATION_RINGTONE} for
 * vibrations associated with incoming calls.
 *
 * @deprecated Use {@link #vibrate(VibrationEffect, AudioAttributes)} instead.
 */
",-1,,"[@Deprecated, @RequiresPermission(android.Manifest.permission.VIBRATE)]",-1,-1,-1,-1,-1,-1,"1,2,4,5","1,2","The method now wraps the vibration call around a try-catch block, creates a VibrationEffect using the given milliseconds value, and passes this to an overloaded vibrate method. The exception handling for IllegalArgumentException has changed, and so has the implementation of the method by invoking an overloaded vibrate method along with the created VibrationEffect. This determines the code change types as 1 for a new return statement, 2 for the new exception handling, 4 for other statement changes, and 5 for calling a different vibrate method which is a dependent API change.","The changes lead to potential compatibility issues. Specifically, the method could previously throw exceptions (implicitly), as the local vibrate method might have thrown unchecked exceptions. Now any IllegalArgumentException will be caught and logged, altering the method's behavior and exception handling, signifying a CI type 2. Also, because the method no longer calls the original vibrate method directly and now depends on creating a VibrationEffect and using a different overload of vibrate, the return behavior might also be different if the new overloaded vibrate method behaves differently (e.g., it could have a different implementation or additional conditions), which signifies a CI type 1."
918,"<android.accounts.AccountManager: void addOnAccountsUpdatedListener(OnAccountsUpdateListener,Handler,boolean)>",25,26,"<android.accounts.AccountManager: void addOnAccountsUpdatedListener(OnAccountsUpdateListener,Handler,boolean)>","<android.accounts.AccountManager: void addOnAccountsUpdatedListener(OnAccountsUpdateListener,Handler,boolean)>",0,"{
    if (listener == null) {
        throw new IllegalArgumentException(""the listener is null"");
    }
    synchronized (mAccountsUpdatedListeners) {
        if (mAccountsUpdatedListeners.containsKey(listener)) {
            throw new IllegalStateException(""this listener is already added"");
        }
        final boolean wasEmpty = mAccountsUpdatedListeners.isEmpty();
        mAccountsUpdatedListeners.put(listener, handler);
        if (wasEmpty) {
            // Register a broadcast receiver to monitor account changes
            IntentFilter intentFilter = new IntentFilter();
            intentFilter.addAction(LOGIN_ACCOUNTS_CHANGED_ACTION);
            // To recover from disk-full.
            intentFilter.addAction(Intent.ACTION_DEVICE_STORAGE_OK);
            mContext.registerReceiver(mAccountsChangedBroadcastReceiver, intentFilter);
        }
    }
    if (updateImmediately) {
        postToHandler(handler, listener, getAccounts());
    }
}","{
    addOnAccountsUpdatedListener(listener, handler, updateImmediately, null);
}",1,"/**
 * Adds an {@link OnAccountsUpdateListener} to this instance of the
 * {@link AccountManager}.  This listener will be notified whenever the
 * list of accounts on the device changes.
 *
 * <p>As long as this listener is present, the AccountManager instance
 * will not be garbage-collected, and neither will the {@link Context}
 * used to retrieve it, which may be a large Activity instance.  To avoid
 * memory leaks, you must remove this listener before then.  Normally
 * listeners are added in an Activity or Service's {@link Activity#onCreate}
 * and removed in {@link Activity#onDestroy}.
 *
 * <p>The listener will only be informed of accounts that would be returned
 * to the caller via {@link #getAccounts()}. Typically this means that to
 * get any accounts, the caller will need to be grated the GET_ACCOUNTS
 * permission.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * @param listener The listener to send notifications to
 * @param handler {@link Handler} identifying the thread to use
 * for notifications, null for the main thread
 * @param updateImmediately If true, the listener will be invoked
 * (on the handler thread) right away with the current account list
 * @throws IllegalArgumentException if listener is null
 * @throws IllegalStateException if listener was already added
 */
","/**
 * Adds an {@link OnAccountsUpdateListener} to this instance of the {@link AccountManager}. This
 * listener will be notified whenever user or AbstractAcccountAuthenticator made changes to
 * accounts of any type related to the caller. This method is equivalent to
 * addOnAccountsUpdatedListener(listener, handler, updateImmediately, null)
 *
 * @see #addOnAccountsUpdatedListener(OnAccountsUpdateListener, Handler, boolean,
 * String[])
 */
",-1,[@RequiresPermission(GET_ACCOUNTS)],,-1,-1,-1,-1,-1,-1,"4,5",0,"The early version of the implementation provided the complete method body, while in the late version, the implementation has been modified to call another method instead. Therefore, we have a dependent API change because the functionality is now relying on another API (addOnAccountsUpdatedListener with different parameters), and there are other statements changed as the body of the method has been replaced with a method call, so the code change type is 4,5.","Since the early method implementation has been replaced by a call to another method with the same name (but different arguments) in the late version, and there is no direct indication that the replacement will alter the functionality or behavior, it's reasonable to assume that the new method performs the same logic with similar side effects. This change suggests that the specific implementation details have been abstracted away rather than altered in a way that would lead to a compatibility issue based on the provided early and late implementation. Therefore, the Compatibility Issue type is 0."
919,<android.view.ViewRootImpl.ViewRootHandler: void handleMessage(Message)>,25,26,<android.view.ViewRootImpl.ViewRootHandler: void handleMessage(Message)>,<android.view.ViewRootImpl.ViewRootHandler: void handleMessage(Message)>,0,"{
    switch(msg.what) {
        case MSG_INVALIDATE:
            ((View) msg.obj).invalidate();
            break;
        case MSG_INVALIDATE_RECT:
            final View.AttachInfo.InvalidateInfo info = (View.AttachInfo.InvalidateInfo) msg.obj;
            info.target.invalidate(info.left, info.top, info.right, info.bottom);
            info.recycle();
            break;
        case MSG_PROCESS_INPUT_EVENTS:
            mProcessInputEventsScheduled = false;
            doProcessInputEvents();
            break;
        case MSG_DISPATCH_APP_VISIBILITY:
            handleAppVisibility(msg.arg1 != 0);
            break;
        case MSG_DISPATCH_GET_NEW_SURFACE:
            handleGetNewSurface();
            break;
        case MSG_RESIZED:
            {
                // Recycled in the fall through...
                SomeArgs args = (SomeArgs) msg.obj;
                if (mWinFrame.equals(args.arg1) && mPendingOverscanInsets.equals(args.arg5) && mPendingContentInsets.equals(args.arg2) && mPendingStableInsets.equals(args.arg6) && mPendingVisibleInsets.equals(args.arg3) && mPendingOutsets.equals(args.arg7) && mPendingBackDropFrame.equals(args.arg8) && args.arg4 == null && args.argi1 == 0) {
                    break;
                }
            }
        // fall through...
        case MSG_RESIZED_REPORT:
            if (mAdded) {
                SomeArgs args = (SomeArgs) msg.obj;
                Configuration config = (Configuration) args.arg4;
                if (config != null) {
                    updateConfiguration(config, false);
                }
                final boolean framesChanged = !mWinFrame.equals(args.arg1) || !mPendingOverscanInsets.equals(args.arg5) || !mPendingContentInsets.equals(args.arg2) || !mPendingStableInsets.equals(args.arg6) || !mPendingVisibleInsets.equals(args.arg3) || !mPendingOutsets.equals(args.arg7);
                mWinFrame.set((Rect) args.arg1);
                mPendingOverscanInsets.set((Rect) args.arg5);
                mPendingContentInsets.set((Rect) args.arg2);
                mPendingStableInsets.set((Rect) args.arg6);
                mPendingVisibleInsets.set((Rect) args.arg3);
                mPendingOutsets.set((Rect) args.arg7);
                mPendingBackDropFrame.set((Rect) args.arg8);
                mForceNextWindowRelayout = args.argi1 != 0;
                mPendingAlwaysConsumeNavBar = args.argi2 != 0;
                args.recycle();
                if (msg.what == MSG_RESIZED_REPORT) {
                    mReportNextDraw = true;
                }
                if (mView != null && framesChanged) {
                    forceLayout(mView);
                }
                requestLayout();
            }
            break;
        case MSG_WINDOW_MOVED:
            if (mAdded) {
                final int w = mWinFrame.width();
                final int h = mWinFrame.height();
                final int l = msg.arg1;
                final int t = msg.arg2;
                mWinFrame.left = l;
                mWinFrame.right = l + w;
                mWinFrame.top = t;
                mWinFrame.bottom = t + h;
                mPendingBackDropFrame.set(mWinFrame);
                // Suppress layouts during resizing - a correct layout will happen when resizing
                // is done, and this just increases system load.
                boolean isDockedDivider = mWindowAttributes.type == TYPE_DOCK_DIVIDER;
                boolean suppress = (mDragResizing && mResizeMode == RESIZE_MODE_DOCKED_DIVIDER) || isDockedDivider;
                if (!suppress) {
                    if (mView != null) {
                        forceLayout(mView);
                    }
                    requestLayout();
                } else {
                    maybeHandleWindowMove(mWinFrame);
                }
            }
            break;
        case MSG_WINDOW_FOCUS_CHANGED:
            {
                if (mAdded) {
                    boolean hasWindowFocus = msg.arg1 != 0;
                    mAttachInfo.mHasWindowFocus = hasWindowFocus;
                    profileRendering(hasWindowFocus);
                    if (hasWindowFocus) {
                        boolean inTouchMode = msg.arg2 != 0;
                        ensureTouchModeLocally(inTouchMode);
                        if (mAttachInfo.mHardwareRenderer != null && mSurface.isValid()) {
                            mFullRedrawNeeded = true;
                            try {
                                final WindowManager.LayoutParams lp = mWindowAttributes;
                                final Rect surfaceInsets = lp != null ? lp.surfaceInsets : null;
                                mAttachInfo.mHardwareRenderer.initializeIfNeeded(mWidth, mHeight, mAttachInfo, mSurface, surfaceInsets);
                            } catch (OutOfResourcesException e) {
                                Log.e(mTag, ""OutOfResourcesException locking surface"", e);
                                try {
                                    if (!mWindowSession.outOfMemory(mWindow)) {
                                        Slog.w(mTag, ""No processes killed for memory; killing self"");
                                        Process.killProcess(Process.myPid());
                                    }
                                } catch (RemoteException ex) {
                                }
                                // Retry in a bit.
                                sendMessageDelayed(obtainMessage(msg.what, msg.arg1, msg.arg2), 500);
                                return;
                            }
                        }
                    }
                    mLastWasImTarget = WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
                    InputMethodManager imm = InputMethodManager.peekInstance();
                    if (imm != null && mLastWasImTarget && !isInLocalFocusMode()) {
                        imm.onPreWindowFocus(mView, hasWindowFocus);
                    }
                    if (mView != null) {
                        mAttachInfo.mKeyDispatchState.reset();
                        mView.dispatchWindowFocusChanged(hasWindowFocus);
                        mAttachInfo.mTreeObserver.dispatchOnWindowFocusChange(hasWindowFocus);
                    }
                    // so all of the view state is set up correctly.
                    if (hasWindowFocus) {
                        if (imm != null && mLastWasImTarget && !isInLocalFocusMode()) {
                            imm.onPostWindowFocus(mView, mView.findFocus(), mWindowAttributes.softInputMode, !mHasHadWindowFocus, mWindowAttributes.flags);
                        }
                        // Clear the forward bit.  We can just do this directly, since
                        // the window manager doesn't care about it.
                        mWindowAttributes.softInputMode &= ~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
                        ((WindowManager.LayoutParams) mView.getLayoutParams()).softInputMode &= ~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
                        mHasHadWindowFocus = true;
                    }
                }
            }
            break;
        case MSG_DIE:
            doDie();
            break;
        case MSG_DISPATCH_INPUT_EVENT:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                InputEvent event = (InputEvent) args.arg1;
                InputEventReceiver receiver = (InputEventReceiver) args.arg2;
                enqueueInputEvent(event, receiver, 0, true);
                args.recycle();
            }
            break;
        case MSG_SYNTHESIZE_INPUT_EVENT:
            {
                InputEvent event = (InputEvent) msg.obj;
                enqueueInputEvent(event, null, QueuedInputEvent.FLAG_UNHANDLED, true);
            }
            break;
        case MSG_DISPATCH_KEY_FROM_IME:
            {
                if (LOCAL_LOGV)
                    Log.v(TAG, ""Dispatching key "" + msg.obj + "" from IME to "" + mView);
                KeyEvent event = (KeyEvent) msg.obj;
                if ((event.getFlags() & KeyEvent.FLAG_FROM_SYSTEM) != 0) {
                    // The IME is trying to say this event is from the
                    // system!  Bad bad bad!
                    // noinspection UnusedAssignment
                    event = KeyEvent.changeFlags(event, event.getFlags() & ~KeyEvent.FLAG_FROM_SYSTEM);
                }
                enqueueInputEvent(event, null, QueuedInputEvent.FLAG_DELIVER_POST_IME, true);
            }
            break;
        case MSG_CHECK_FOCUS:
            {
                InputMethodManager imm = InputMethodManager.peekInstance();
                if (imm != null) {
                    imm.checkFocus();
                }
            }
            break;
        case MSG_CLOSE_SYSTEM_DIALOGS:
            {
                if (mView != null) {
                    mView.onCloseSystemDialogs((String) msg.obj);
                }
            }
            break;
        case MSG_DISPATCH_DRAG_EVENT:
        case MSG_DISPATCH_DRAG_LOCATION_EVENT:
            {
                DragEvent event = (DragEvent) msg.obj;
                // only present when this app called startDrag()
                event.mLocalState = mLocalDragState;
                handleDragEvent(event);
            }
            break;
        case MSG_DISPATCH_SYSTEM_UI_VISIBILITY:
            {
                handleDispatchSystemUiVisibilityChanged((SystemUiVisibilityInfo) msg.obj);
            }
            break;
        case MSG_UPDATE_CONFIGURATION:
            {
                Configuration config = (Configuration) msg.obj;
                if (config.isOtherSeqNewer(mLastConfiguration)) {
                    config = mLastConfiguration;
                }
                updateConfiguration(config, false);
            }
            break;
        case MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST:
            {
                setAccessibilityFocus(null, null);
            }
            break;
        case MSG_INVALIDATE_WORLD:
            {
                if (mView != null) {
                    invalidateWorld(mView);
                }
            }
            break;
        case MSG_DISPATCH_WINDOW_SHOWN:
            {
                handleDispatchWindowShown();
            }
            break;
        case MSG_REQUEST_KEYBOARD_SHORTCUTS:
            {
                final IResultReceiver receiver = (IResultReceiver) msg.obj;
                final int deviceId = msg.arg1;
                handleRequestKeyboardShortcuts(receiver, deviceId);
            }
            break;
        case MSG_UPDATE_POINTER_ICON:
            {
                MotionEvent event = (MotionEvent) msg.obj;
                resetPointerIcon(event);
            }
            break;
    }
}","{
    switch(msg.what) {
        case MSG_INVALIDATE:
            ((View) msg.obj).invalidate();
            break;
        case MSG_INVALIDATE_RECT:
            final View.AttachInfo.InvalidateInfo info = (View.AttachInfo.InvalidateInfo) msg.obj;
            info.target.invalidate(info.left, info.top, info.right, info.bottom);
            info.recycle();
            break;
        case MSG_PROCESS_INPUT_EVENTS:
            mProcessInputEventsScheduled = false;
            doProcessInputEvents();
            break;
        case MSG_DISPATCH_APP_VISIBILITY:
            handleAppVisibility(msg.arg1 != 0);
            break;
        case MSG_DISPATCH_GET_NEW_SURFACE:
            handleGetNewSurface();
            break;
        case MSG_RESIZED:
            {
                // Recycled in the fall through...
                SomeArgs args = (SomeArgs) msg.obj;
                if (mWinFrame.equals(args.arg1) && mPendingOverscanInsets.equals(args.arg5) && mPendingContentInsets.equals(args.arg2) && mPendingStableInsets.equals(args.arg6) && mPendingVisibleInsets.equals(args.arg3) && mPendingOutsets.equals(args.arg7) && mPendingBackDropFrame.equals(args.arg8) && args.arg4 == null && args.argi1 == 0 && mDisplay.getDisplayId() == args.argi3) {
                    break;
                }
            }
        // fall through...
        case MSG_RESIZED_REPORT:
            if (mAdded) {
                SomeArgs args = (SomeArgs) msg.obj;
                final int displayId = args.argi3;
                final MergedConfiguration mergedConfiguration = (MergedConfiguration) args.arg4;
                final boolean displayChanged = mDisplay.getDisplayId() != displayId;
                if (mergedConfiguration != null) {
                    // If configuration changed - notify about that and, maybe, about move to
                    // display.
                    performConfigurationChange(mergedConfiguration, false, /* force */
                    displayChanged ? displayId : INVALID_DISPLAY);
                } else if (displayChanged) {
                    // Moved to display without config change - report last applied one.
                    onMovedToDisplay(displayId, mLastConfigurationFromResources);
                }
                final boolean framesChanged = !mWinFrame.equals(args.arg1) || !mPendingOverscanInsets.equals(args.arg5) || !mPendingContentInsets.equals(args.arg2) || !mPendingStableInsets.equals(args.arg6) || !mPendingVisibleInsets.equals(args.arg3) || !mPendingOutsets.equals(args.arg7);
                mWinFrame.set((Rect) args.arg1);
                mPendingOverscanInsets.set((Rect) args.arg5);
                mPendingContentInsets.set((Rect) args.arg2);
                mPendingStableInsets.set((Rect) args.arg6);
                mPendingVisibleInsets.set((Rect) args.arg3);
                mPendingOutsets.set((Rect) args.arg7);
                mPendingBackDropFrame.set((Rect) args.arg8);
                mForceNextWindowRelayout = args.argi1 != 0;
                mPendingAlwaysConsumeNavBar = args.argi2 != 0;
                args.recycle();
                if (msg.what == MSG_RESIZED_REPORT) {
                    reportNextDraw();
                }
                if (mView != null && framesChanged) {
                    forceLayout(mView);
                }
                requestLayout();
            }
            break;
        case MSG_WINDOW_MOVED:
            if (mAdded) {
                final int w = mWinFrame.width();
                final int h = mWinFrame.height();
                final int l = msg.arg1;
                final int t = msg.arg2;
                mWinFrame.left = l;
                mWinFrame.right = l + w;
                mWinFrame.top = t;
                mWinFrame.bottom = t + h;
                mPendingBackDropFrame.set(mWinFrame);
                maybeHandleWindowMove(mWinFrame);
            }
            break;
        case MSG_WINDOW_FOCUS_CHANGED:
            {
                if (mAdded) {
                    boolean hasWindowFocus = msg.arg1 != 0;
                    mAttachInfo.mHasWindowFocus = hasWindowFocus;
                    profileRendering(hasWindowFocus);
                    if (hasWindowFocus) {
                        boolean inTouchMode = msg.arg2 != 0;
                        ensureTouchModeLocally(inTouchMode);
                        if (mAttachInfo.mThreadedRenderer != null && mSurface.isValid()) {
                            mFullRedrawNeeded = true;
                            try {
                                final WindowManager.LayoutParams lp = mWindowAttributes;
                                final Rect surfaceInsets = lp != null ? lp.surfaceInsets : null;
                                mAttachInfo.mThreadedRenderer.initializeIfNeeded(mWidth, mHeight, mAttachInfo, mSurface, surfaceInsets);
                            } catch (OutOfResourcesException e) {
                                Log.e(mTag, ""OutOfResourcesException locking surface"", e);
                                try {
                                    if (!mWindowSession.outOfMemory(mWindow)) {
                                        Slog.w(mTag, ""No processes killed for memory; killing self"");
                                        Process.killProcess(Process.myPid());
                                    }
                                } catch (RemoteException ex) {
                                }
                                // Retry in a bit.
                                sendMessageDelayed(obtainMessage(msg.what, msg.arg1, msg.arg2), 500);
                                return;
                            }
                        }
                    }
                    mLastWasImTarget = WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
                    InputMethodManager imm = InputMethodManager.peekInstance();
                    if (imm != null && mLastWasImTarget && !isInLocalFocusMode()) {
                        imm.onPreWindowFocus(mView, hasWindowFocus);
                    }
                    if (mView != null) {
                        mAttachInfo.mKeyDispatchState.reset();
                        mView.dispatchWindowFocusChanged(hasWindowFocus);
                        mAttachInfo.mTreeObserver.dispatchOnWindowFocusChange(hasWindowFocus);
                        if (mAttachInfo.mTooltipHost != null) {
                            mAttachInfo.mTooltipHost.hideTooltip();
                        }
                    }
                    // so all of the view state is set up correctly.
                    if (hasWindowFocus) {
                        if (imm != null && mLastWasImTarget && !isInLocalFocusMode()) {
                            imm.onPostWindowFocus(mView, mView.findFocus(), mWindowAttributes.softInputMode, !mHasHadWindowFocus, mWindowAttributes.flags);
                        }
                        // Clear the forward bit.  We can just do this directly, since
                        // the window manager doesn't care about it.
                        mWindowAttributes.softInputMode &= ~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
                        ((WindowManager.LayoutParams) mView.getLayoutParams()).softInputMode &= ~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
                        mHasHadWindowFocus = true;
                    } else {
                        if (mPointerCapture) {
                            handlePointerCaptureChanged(false);
                        }
                    }
                }
            }
            break;
        case MSG_DIE:
            doDie();
            break;
        case MSG_DISPATCH_INPUT_EVENT:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                InputEvent event = (InputEvent) args.arg1;
                InputEventReceiver receiver = (InputEventReceiver) args.arg2;
                enqueueInputEvent(event, receiver, 0, true);
                args.recycle();
            }
            break;
        case MSG_SYNTHESIZE_INPUT_EVENT:
            {
                InputEvent event = (InputEvent) msg.obj;
                enqueueInputEvent(event, null, QueuedInputEvent.FLAG_UNHANDLED, true);
            }
            break;
        case MSG_DISPATCH_KEY_FROM_IME:
            {
                if (LOCAL_LOGV)
                    Log.v(TAG, ""Dispatching key "" + msg.obj + "" from IME to "" + mView);
                KeyEvent event = (KeyEvent) msg.obj;
                if ((event.getFlags() & KeyEvent.FLAG_FROM_SYSTEM) != 0) {
                    // The IME is trying to say this event is from the
                    // system!  Bad bad bad!
                    // noinspection UnusedAssignment
                    event = KeyEvent.changeFlags(event, event.getFlags() & ~KeyEvent.FLAG_FROM_SYSTEM);
                }
                enqueueInputEvent(event, null, QueuedInputEvent.FLAG_DELIVER_POST_IME, true);
            }
            break;
        case MSG_CHECK_FOCUS:
            {
                InputMethodManager imm = InputMethodManager.peekInstance();
                if (imm != null) {
                    imm.checkFocus();
                }
            }
            break;
        case MSG_CLOSE_SYSTEM_DIALOGS:
            {
                if (mView != null) {
                    mView.onCloseSystemDialogs((String) msg.obj);
                }
            }
            break;
        case MSG_DISPATCH_DRAG_EVENT:
        case MSG_DISPATCH_DRAG_LOCATION_EVENT:
            {
                DragEvent event = (DragEvent) msg.obj;
                // only present when this app called startDrag()
                event.mLocalState = mLocalDragState;
                handleDragEvent(event);
            }
            break;
        case MSG_DISPATCH_SYSTEM_UI_VISIBILITY:
            {
                handleDispatchSystemUiVisibilityChanged((SystemUiVisibilityInfo) msg.obj);
            }
            break;
        case MSG_UPDATE_CONFIGURATION:
            {
                Configuration config = (Configuration) msg.obj;
                if (config.isOtherSeqNewer(mLastReportedMergedConfiguration.getMergedConfiguration())) {
                    // If we already have a newer merged config applied - use its global part.
                    config = mLastReportedMergedConfiguration.getGlobalConfiguration();
                }
                // Use the newer global config and last reported override config.
                mPendingMergedConfiguration.setConfiguration(config, mLastReportedMergedConfiguration.getOverrideConfiguration());
                performConfigurationChange(mPendingMergedConfiguration, false, /* force */
                INVALID_DISPLAY);
            }
            break;
        case MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST:
            {
                setAccessibilityFocus(null, null);
            }
            break;
        case MSG_INVALIDATE_WORLD:
            {
                if (mView != null) {
                    invalidateWorld(mView);
                }
            }
            break;
        case MSG_DISPATCH_WINDOW_SHOWN:
            {
                handleDispatchWindowShown();
            }
            break;
        case MSG_REQUEST_KEYBOARD_SHORTCUTS:
            {
                final IResultReceiver receiver = (IResultReceiver) msg.obj;
                final int deviceId = msg.arg1;
                handleRequestKeyboardShortcuts(receiver, deviceId);
            }
            break;
        case MSG_UPDATE_POINTER_ICON:
            {
                MotionEvent event = (MotionEvent) msg.obj;
                resetPointerIcon(event);
            }
            break;
        case MSG_POINTER_CAPTURE_CHANGED:
            {
                final boolean hasCapture = msg.arg1 != 0;
                handlePointerCaptureChanged(hasCapture);
            }
            break;
        case MSG_DRAW_FINISHED:
            {
                pendingDrawFinished();
            }
            break;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
920,<android.app.ActivityTransitionCoordinator: void moveSharedElementsToOverlay()>,25,26,<android.app.ActivityTransitionCoordinator: void moveSharedElementsToOverlay()>,<android.app.ActivityTransitionCoordinator: void moveSharedElementsToOverlay()>,0,"{
    if (mWindow == null || !mWindow.getSharedElementsUseOverlay()) {
        return;
    }
    setSharedElementMatrices();
    int numSharedElements = mSharedElements.size();
    ViewGroup decor = getDecor();
    if (decor != null) {
        boolean moveWithParent = moveSharedElementWithParent();
        Matrix tempMatrix = new Matrix();
        for (int i = 0; i < numSharedElements; i++) {
            View view = mSharedElements.get(i);
            tempMatrix.reset();
            mSharedElementParentMatrices.get(i).invert(tempMatrix);
            GhostView.addGhost(view, decor, tempMatrix);
            ViewGroup parent = (ViewGroup) view.getParent();
            if (moveWithParent && !isInTransitionGroup(parent, decor)) {
                GhostViewListeners listener = new GhostViewListeners(view, parent, decor);
                parent.getViewTreeObserver().addOnPreDrawListener(listener);
                mGhostViewListeners.add(listener);
            }
        }
    }
}","{
    if (mWindow == null || !mWindow.getSharedElementsUseOverlay()) {
        return;
    }
    setSharedElementMatrices();
    int numSharedElements = mSharedElements.size();
    ViewGroup decor = getDecor();
    if (decor != null) {
        boolean moveWithParent = moveSharedElementWithParent();
        Matrix tempMatrix = new Matrix();
        for (int i = 0; i < numSharedElements; i++) {
            View view = mSharedElements.get(i);
            if (view.isAttachedToWindow()) {
                tempMatrix.reset();
                mSharedElementParentMatrices.get(i).invert(tempMatrix);
                GhostView.addGhost(view, decor, tempMatrix);
                ViewGroup parent = (ViewGroup) view.getParent();
                if (moveWithParent && !isInTransitionGroup(parent, decor)) {
                    GhostViewListeners listener = new GhostViewListeners(view, parent, decor);
                    parent.getViewTreeObserver().addOnPreDrawListener(listener);
                    parent.addOnAttachStateChangeListener(listener);
                    mGhostViewListeners.add(listener);
                }
            }
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The late version of the implementation includes a new if condition `if (view.isAttachedToWindow())` which is a control dependency change (code change type 3). There's also the addition of `parent.addOnAttachStateChangeListener(listener);` which doesn't fall under return statement change, exception handling change, control dependency change, or dependent API change, hence qualifies as other statement change (code change type 4).","There are no changes to return statements, exception handling, or dependent APIs that would cause a different return value or different exception to be thrown, therefore no compatibility issue arises from these changes. The if condition `if (view.isAttachedToWindow())` is a guard to prevent operations on views that are not attached to a window; however, it further restricts the operations to a subset of `mSharedElements`, which would not cause a different behavior but ensure existing behavior is safe against a specific case (views not attached to window). Hence, it's not a compatibility issue (CI type 0)."
921,<android.content.res.Configuration: int updateFrom(Configuration)>,25,26,<android.content.res.Configuration: int updateFrom(Configuration)>,<android.content.res.Configuration: int updateFrom(Configuration)>,0,"{
    int changed = 0;
    if (delta.fontScale > 0 && fontScale != delta.fontScale) {
        changed |= ActivityInfo.CONFIG_FONT_SCALE;
        fontScale = delta.fontScale;
    }
    if (delta.mcc != 0 && mcc != delta.mcc) {
        changed |= ActivityInfo.CONFIG_MCC;
        mcc = delta.mcc;
    }
    if (delta.mnc != 0 && mnc != delta.mnc) {
        changed |= ActivityInfo.CONFIG_MNC;
        mnc = delta.mnc;
    }
    fixUpLocaleList();
    delta.fixUpLocaleList();
    if (!delta.mLocaleList.isEmpty() && !mLocaleList.equals(delta.mLocaleList)) {
        changed |= ActivityInfo.CONFIG_LOCALE;
        mLocaleList = delta.mLocaleList;
        // delta.locale can't be null, since delta.mLocaleList is not empty.
        if (!delta.locale.equals(locale)) {
            locale = (Locale) delta.locale.clone();
            // If locale has changed, then layout direction is also changed ...
            changed |= ActivityInfo.CONFIG_LAYOUT_DIRECTION;
            // ... and we need to update the layout direction (represented by the first
            // 2 most significant bits in screenLayout).
            setLayoutDirection(locale);
        }
    }
    final int deltaScreenLayoutDir = delta.screenLayout & SCREENLAYOUT_LAYOUTDIR_MASK;
    if (deltaScreenLayoutDir != SCREENLAYOUT_LAYOUTDIR_UNDEFINED && deltaScreenLayoutDir != (screenLayout & SCREENLAYOUT_LAYOUTDIR_MASK)) {
        screenLayout = (screenLayout & ~SCREENLAYOUT_LAYOUTDIR_MASK) | deltaScreenLayoutDir;
        changed |= ActivityInfo.CONFIG_LAYOUT_DIRECTION;
    }
    if (delta.userSetLocale && (!userSetLocale || ((changed & ActivityInfo.CONFIG_LOCALE) != 0))) {
        changed |= ActivityInfo.CONFIG_LOCALE;
        userSetLocale = true;
    }
    if (delta.touchscreen != TOUCHSCREEN_UNDEFINED && touchscreen != delta.touchscreen) {
        changed |= ActivityInfo.CONFIG_TOUCHSCREEN;
        touchscreen = delta.touchscreen;
    }
    if (delta.keyboard != KEYBOARD_UNDEFINED && keyboard != delta.keyboard) {
        changed |= ActivityInfo.CONFIG_KEYBOARD;
        keyboard = delta.keyboard;
    }
    if (delta.keyboardHidden != KEYBOARDHIDDEN_UNDEFINED && keyboardHidden != delta.keyboardHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
        keyboardHidden = delta.keyboardHidden;
    }
    if (delta.hardKeyboardHidden != HARDKEYBOARDHIDDEN_UNDEFINED && hardKeyboardHidden != delta.hardKeyboardHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
        hardKeyboardHidden = delta.hardKeyboardHidden;
    }
    if (delta.navigation != NAVIGATION_UNDEFINED && navigation != delta.navigation) {
        changed |= ActivityInfo.CONFIG_NAVIGATION;
        navigation = delta.navigation;
    }
    if (delta.navigationHidden != NAVIGATIONHIDDEN_UNDEFINED && navigationHidden != delta.navigationHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
        navigationHidden = delta.navigationHidden;
    }
    if (delta.orientation != ORIENTATION_UNDEFINED && orientation != delta.orientation) {
        changed |= ActivityInfo.CONFIG_ORIENTATION;
        orientation = delta.orientation;
    }
    if (getScreenLayoutNoDirection(delta.screenLayout) != (SCREENLAYOUT_SIZE_UNDEFINED | SCREENLAYOUT_LONG_UNDEFINED) && (getScreenLayoutNoDirection(screenLayout) != getScreenLayoutNoDirection(delta.screenLayout))) {
        changed |= ActivityInfo.CONFIG_SCREEN_LAYOUT;
        // We need to preserve the previous layout dir bits if they were defined
        if ((delta.screenLayout & SCREENLAYOUT_LAYOUTDIR_MASK) == 0) {
            screenLayout = (screenLayout & SCREENLAYOUT_LAYOUTDIR_MASK) | delta.screenLayout;
        } else {
            screenLayout = delta.screenLayout;
        }
    }
    if (delta.uiMode != (UI_MODE_TYPE_UNDEFINED | UI_MODE_NIGHT_UNDEFINED) && uiMode != delta.uiMode) {
        changed |= ActivityInfo.CONFIG_UI_MODE;
        if ((delta.uiMode & UI_MODE_TYPE_MASK) != UI_MODE_TYPE_UNDEFINED) {
            uiMode = (uiMode & ~UI_MODE_TYPE_MASK) | (delta.uiMode & UI_MODE_TYPE_MASK);
        }
        if ((delta.uiMode & UI_MODE_NIGHT_MASK) != UI_MODE_NIGHT_UNDEFINED) {
            uiMode = (uiMode & ~UI_MODE_NIGHT_MASK) | (delta.uiMode & UI_MODE_NIGHT_MASK);
        }
    }
    if (delta.screenWidthDp != SCREEN_WIDTH_DP_UNDEFINED && screenWidthDp != delta.screenWidthDp) {
        changed |= ActivityInfo.CONFIG_SCREEN_SIZE;
        screenWidthDp = delta.screenWidthDp;
    }
    if (delta.screenHeightDp != SCREEN_HEIGHT_DP_UNDEFINED && screenHeightDp != delta.screenHeightDp) {
        changed |= ActivityInfo.CONFIG_SCREEN_SIZE;
        screenHeightDp = delta.screenHeightDp;
    }
    if (delta.smallestScreenWidthDp != SMALLEST_SCREEN_WIDTH_DP_UNDEFINED && smallestScreenWidthDp != delta.smallestScreenWidthDp) {
        changed |= ActivityInfo.CONFIG_SMALLEST_SCREEN_SIZE;
        smallestScreenWidthDp = delta.smallestScreenWidthDp;
    }
    if (delta.densityDpi != DENSITY_DPI_UNDEFINED && densityDpi != delta.densityDpi) {
        changed |= ActivityInfo.CONFIG_DENSITY;
        densityDpi = delta.densityDpi;
    }
    if (delta.compatScreenWidthDp != SCREEN_WIDTH_DP_UNDEFINED) {
        compatScreenWidthDp = delta.compatScreenWidthDp;
    }
    if (delta.compatScreenHeightDp != SCREEN_HEIGHT_DP_UNDEFINED) {
        compatScreenHeightDp = delta.compatScreenHeightDp;
    }
    if (delta.compatSmallestScreenWidthDp != SMALLEST_SCREEN_WIDTH_DP_UNDEFINED) {
        compatSmallestScreenWidthDp = delta.compatSmallestScreenWidthDp;
    }
    if (delta.seq != 0) {
        seq = delta.seq;
    }
    return changed;
}","{
    int changed = 0;
    if (delta.fontScale > 0 && fontScale != delta.fontScale) {
        changed |= ActivityInfo.CONFIG_FONT_SCALE;
        fontScale = delta.fontScale;
    }
    if (delta.mcc != 0 && mcc != delta.mcc) {
        changed |= ActivityInfo.CONFIG_MCC;
        mcc = delta.mcc;
    }
    if (delta.mnc != 0 && mnc != delta.mnc) {
        changed |= ActivityInfo.CONFIG_MNC;
        mnc = delta.mnc;
    }
    fixUpLocaleList();
    delta.fixUpLocaleList();
    if (!delta.mLocaleList.isEmpty() && !mLocaleList.equals(delta.mLocaleList)) {
        changed |= ActivityInfo.CONFIG_LOCALE;
        mLocaleList = delta.mLocaleList;
        // delta.locale can't be null, since delta.mLocaleList is not empty.
        if (!delta.locale.equals(locale)) {
            locale = (Locale) delta.locale.clone();
            // If locale has changed, then layout direction is also changed ...
            changed |= ActivityInfo.CONFIG_LAYOUT_DIRECTION;
            // ... and we need to update the layout direction (represented by the first
            // 2 most significant bits in screenLayout).
            setLayoutDirection(locale);
        }
    }
    final int deltaScreenLayoutDir = delta.screenLayout & SCREENLAYOUT_LAYOUTDIR_MASK;
    if (deltaScreenLayoutDir != SCREENLAYOUT_LAYOUTDIR_UNDEFINED && deltaScreenLayoutDir != (screenLayout & SCREENLAYOUT_LAYOUTDIR_MASK)) {
        screenLayout = (screenLayout & ~SCREENLAYOUT_LAYOUTDIR_MASK) | deltaScreenLayoutDir;
        changed |= ActivityInfo.CONFIG_LAYOUT_DIRECTION;
    }
    if (delta.userSetLocale && (!userSetLocale || ((changed & ActivityInfo.CONFIG_LOCALE) != 0))) {
        changed |= ActivityInfo.CONFIG_LOCALE;
        userSetLocale = true;
    }
    if (delta.touchscreen != TOUCHSCREEN_UNDEFINED && touchscreen != delta.touchscreen) {
        changed |= ActivityInfo.CONFIG_TOUCHSCREEN;
        touchscreen = delta.touchscreen;
    }
    if (delta.keyboard != KEYBOARD_UNDEFINED && keyboard != delta.keyboard) {
        changed |= ActivityInfo.CONFIG_KEYBOARD;
        keyboard = delta.keyboard;
    }
    if (delta.keyboardHidden != KEYBOARDHIDDEN_UNDEFINED && keyboardHidden != delta.keyboardHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
        keyboardHidden = delta.keyboardHidden;
    }
    if (delta.hardKeyboardHidden != HARDKEYBOARDHIDDEN_UNDEFINED && hardKeyboardHidden != delta.hardKeyboardHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
        hardKeyboardHidden = delta.hardKeyboardHidden;
    }
    if (delta.navigation != NAVIGATION_UNDEFINED && navigation != delta.navigation) {
        changed |= ActivityInfo.CONFIG_NAVIGATION;
        navigation = delta.navigation;
    }
    if (delta.navigationHidden != NAVIGATIONHIDDEN_UNDEFINED && navigationHidden != delta.navigationHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
        navigationHidden = delta.navigationHidden;
    }
    if (delta.orientation != ORIENTATION_UNDEFINED && orientation != delta.orientation) {
        changed |= ActivityInfo.CONFIG_ORIENTATION;
        orientation = delta.orientation;
    }
    if (((delta.screenLayout & SCREENLAYOUT_SIZE_MASK) != SCREENLAYOUT_SIZE_UNDEFINED) && (delta.screenLayout & SCREENLAYOUT_SIZE_MASK) != (screenLayout & SCREENLAYOUT_SIZE_MASK)) {
        changed |= ActivityInfo.CONFIG_SCREEN_LAYOUT;
        screenLayout = (screenLayout & ~SCREENLAYOUT_SIZE_MASK) | (delta.screenLayout & SCREENLAYOUT_SIZE_MASK);
    }
    if (((delta.screenLayout & SCREENLAYOUT_LONG_MASK) != SCREENLAYOUT_LONG_UNDEFINED) && (delta.screenLayout & SCREENLAYOUT_LONG_MASK) != (screenLayout & SCREENLAYOUT_LONG_MASK)) {
        changed |= ActivityInfo.CONFIG_SCREEN_LAYOUT;
        screenLayout = (screenLayout & ~SCREENLAYOUT_LONG_MASK) | (delta.screenLayout & SCREENLAYOUT_LONG_MASK);
    }
    if (((delta.screenLayout & SCREENLAYOUT_ROUND_MASK) != SCREENLAYOUT_ROUND_UNDEFINED) && (delta.screenLayout & SCREENLAYOUT_ROUND_MASK) != (screenLayout & SCREENLAYOUT_ROUND_MASK)) {
        changed |= ActivityInfo.CONFIG_SCREEN_LAYOUT;
        screenLayout = (screenLayout & ~SCREENLAYOUT_ROUND_MASK) | (delta.screenLayout & SCREENLAYOUT_ROUND_MASK);
    }
    if ((delta.screenLayout & SCREENLAYOUT_COMPAT_NEEDED) != (screenLayout & SCREENLAYOUT_COMPAT_NEEDED) && delta.screenLayout != 0) {
        changed |= ActivityInfo.CONFIG_SCREEN_LAYOUT;
        screenLayout = (screenLayout & ~SCREENLAYOUT_COMPAT_NEEDED) | (delta.screenLayout & SCREENLAYOUT_COMPAT_NEEDED);
    }
    if (((delta.colorMode & COLOR_MODE_WIDE_COLOR_GAMUT_MASK) != COLOR_MODE_WIDE_COLOR_GAMUT_UNDEFINED) && (delta.colorMode & COLOR_MODE_WIDE_COLOR_GAMUT_MASK) != (colorMode & COLOR_MODE_WIDE_COLOR_GAMUT_MASK)) {
        changed |= ActivityInfo.CONFIG_COLOR_MODE;
        colorMode = (colorMode & ~COLOR_MODE_WIDE_COLOR_GAMUT_MASK) | (delta.colorMode & COLOR_MODE_WIDE_COLOR_GAMUT_MASK);
    }
    if (((delta.colorMode & COLOR_MODE_HDR_MASK) != COLOR_MODE_HDR_UNDEFINED) && (delta.colorMode & COLOR_MODE_HDR_MASK) != (colorMode & COLOR_MODE_HDR_MASK)) {
        changed |= ActivityInfo.CONFIG_COLOR_MODE;
        colorMode = (colorMode & ~COLOR_MODE_HDR_MASK) | (delta.colorMode & COLOR_MODE_HDR_MASK);
    }
    if (delta.uiMode != (UI_MODE_TYPE_UNDEFINED | UI_MODE_NIGHT_UNDEFINED) && uiMode != delta.uiMode) {
        changed |= ActivityInfo.CONFIG_UI_MODE;
        if ((delta.uiMode & UI_MODE_TYPE_MASK) != UI_MODE_TYPE_UNDEFINED) {
            uiMode = (uiMode & ~UI_MODE_TYPE_MASK) | (delta.uiMode & UI_MODE_TYPE_MASK);
        }
        if ((delta.uiMode & UI_MODE_NIGHT_MASK) != UI_MODE_NIGHT_UNDEFINED) {
            uiMode = (uiMode & ~UI_MODE_NIGHT_MASK) | (delta.uiMode & UI_MODE_NIGHT_MASK);
        }
    }
    if (delta.screenWidthDp != SCREEN_WIDTH_DP_UNDEFINED && screenWidthDp != delta.screenWidthDp) {
        changed |= ActivityInfo.CONFIG_SCREEN_SIZE;
        screenWidthDp = delta.screenWidthDp;
    }
    if (delta.screenHeightDp != SCREEN_HEIGHT_DP_UNDEFINED && screenHeightDp != delta.screenHeightDp) {
        changed |= ActivityInfo.CONFIG_SCREEN_SIZE;
        screenHeightDp = delta.screenHeightDp;
    }
    if (delta.smallestScreenWidthDp != SMALLEST_SCREEN_WIDTH_DP_UNDEFINED && smallestScreenWidthDp != delta.smallestScreenWidthDp) {
        changed |= ActivityInfo.CONFIG_SMALLEST_SCREEN_SIZE;
        smallestScreenWidthDp = delta.smallestScreenWidthDp;
    }
    if (delta.densityDpi != DENSITY_DPI_UNDEFINED && densityDpi != delta.densityDpi) {
        changed |= ActivityInfo.CONFIG_DENSITY;
        densityDpi = delta.densityDpi;
    }
    if (delta.compatScreenWidthDp != SCREEN_WIDTH_DP_UNDEFINED) {
        compatScreenWidthDp = delta.compatScreenWidthDp;
    }
    if (delta.compatScreenHeightDp != SCREEN_HEIGHT_DP_UNDEFINED) {
        compatScreenHeightDp = delta.compatScreenHeightDp;
    }
    if (delta.compatSmallestScreenWidthDp != SMALLEST_SCREEN_WIDTH_DP_UNDEFINED) {
        compatSmallestScreenWidthDp = delta.compatSmallestScreenWidthDp;
    }
    if (delta.appBounds != null && !delta.appBounds.equals(appBounds)) {
        changed |= ActivityInfo.CONFIG_SCREEN_SIZE;
        setAppBounds(delta.appBounds);
    }
    if (delta.assetsSeq != ASSETS_SEQ_UNDEFINED) {
        changed |= ActivityInfo.CONFIG_ASSETS_PATHS;
        assetsSeq = delta.assetsSeq;
    }
    if (delta.seq != 0) {
        seq = delta.seq;
    }
    return changed;
}",1,"/**
 * Copies the fields from delta into this Configuration object, keeping
 * track of which ones have changed. Any undefined fields in {@code delta}
 * are ignored and not copied in to the current Configuration.
 *
 * @return a bit mask of the changed fields, as per {@link #diff}
 */
","/**
 * Copies the fields from delta into this Configuration object, keeping
 * track of which ones have changed. Any undefined fields in {@code delta}
 * are ignored and not copied in to the current Configuration.
 *
 * @return a bit mask of the changed fields, as per {@link #diff}
 */
",-1,[@Config],[@Config],-1,-1,-1,-1,-1,-1,,,,
922,<android.app.Notification.Builder: RemoteViews createHeadsUpContentView()>,25,26,<android.app.Notification.Builder: RemoteViews createHeadsUpContentView()>,<android.app.Notification.Builder: RemoteViews createHeadsUpContentView()>,0,"{
    if (mN.headsUpContentView != null && (mStyle == null || !mStyle.displayCustomViewInline())) {
        return mN.headsUpContentView;
    } else if (mStyle != null) {
        final RemoteViews styleView = mStyle.makeHeadsUpContentView();
        if (styleView != null) {
            return styleView;
        }
    } else if (mActions.size() == 0) {
        return null;
    }
    return applyStandardTemplateWithActions(getBigBaseLayoutResource());
}","{
    return createHeadsUpContentView(false);
}",1,"/**
 * Construct a RemoteViews for the final heads-up notification layout.
 */
","/**
 * Construct a RemoteViews for the final heads-up notification layout.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The early implementation of the method contains a complex block of code with multiple return statements, but in the late version, this is replaced with a single call to createHeadsUpContentView(false), which is a different method. Thus the changed code types are 1 (return statement changed) and 5 (dependent API changed).","Since there is a significant change in the implementation of the method, where previously multiple conditions could lead to different paths and return values, the new version boils down the complexity to a single method call. This suggests that the return value of the method could be different depending on those conditions that are now missing. Hence, a Compatibility Issue due to different return values could arise, classified as type 1."
924,<android.app.RemoteInput: Bundle getResultsFromIntent(Intent)>,25,26,<android.app.RemoteInput: Bundle getResultsFromIntent(Intent)>,<android.app.RemoteInput: Bundle getResultsFromIntent(Intent)>,0,"{
    ClipData clipData = intent.getClipData();
    if (clipData == null) {
        return null;
    }
    ClipDescription clipDescription = clipData.getDescription();
    if (!clipDescription.hasMimeType(ClipDescription.MIMETYPE_TEXT_INTENT)) {
        return null;
    }
    if (clipDescription.getLabel().equals(RESULTS_CLIP_LABEL)) {
        return clipData.getItemAt(0).getIntent().getExtras().getParcelable(EXTRA_RESULTS_DATA);
    }
    return null;
}","{
    Intent clipDataIntent = getClipDataIntentFromIntent(intent);
    if (clipDataIntent == null) {
        return null;
    }
    return clipDataIntent.getExtras().getParcelable(EXTRA_RESULTS_DATA);
}",1,"/**
 * Get the remote input results bundle from an intent. The returned Bundle will
 * contain a key/value for every result key populated by remote input collector.
 * Use the {@link Bundle#getCharSequence(String)} method to retrieve a value.
 * @param intent The intent object that fired in response to an action or content intent
 * which also had one or more remote input requested.
 */
","/**
 * Get the remote input text results bundle from an intent. The returned Bundle will
 * contain a key/value for every result key populated with text by remote input collector.
 * Use the {@link Bundle#getCharSequence(String)} method to retrieve a value. For non-text
 * results use {@link #getDataResultsFromIntent}.
 * @param intent The intent object that fired in response to an action or content intent
 * which also had one or more remote input requested.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,5",1,"The return statement has been changed to use `getClipDataIntentFromIntent(intent)` instead of manually checking the `ClipData` and its description. There is also removal of control dependency checks for mime type and clip label. Additionally, this late version is utilizing a new or modified method `getClipDataIntentFromIntent` to retrieve the `Bundle`, indicating a change in a dependent API, hence the change type is 1,3,5.","The late version method no longer includes checks for mime type and clip label and therefore behavior of the API could be different, depending on the ""Intent"" object. Furthermore, the change introduces a new method `getClipDataIntentFromIntent`, which could potentially return a different `Bundle` object than the manually extracted `Parcelable` from the early version. Hence, there is a potential Compatibility Issue with different return values, being classified as type 1."
928,"<android.app.ContextImpl: void sendBroadcast(Intent,String)>",25,26,"<android.app.ContextImpl: void sendBroadcast(Intent,String)>","<android.app.ContextImpl: void sendBroadcast(Intent,String)>",0,"{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, AppOpsManager.OP_NONE, null, false, false, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, AppOpsManager.OP_NONE, null, false, false, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The method call within the try block has changed from ActivityManagerNative.getDefault().broadcastIntent(...) to ActivityManager.getService().broadcastIntent(...). This reflects the internal changes of the dependent API calls, so the change type is 5.","The change is to a dependent API call that is most likely intended to maintain the same functionality but using a different method to achieve it. Since there is no change to the method signature, return type, exception handling, or control flow that would affect the API's external behavior, there is no expected Compatibility Issue, hence the CI type is 0."
929,<android.view.Display: String toString()>,25,26,<android.view.Display: String toString()>,<android.view.Display: String toString()>,0,"{
    synchronized (this) {
        updateDisplayInfoLocked();
        mDisplayInfo.getAppMetrics(mTempMetrics, mDisplayAdjustments);
        return ""Display id "" + mDisplayId + "": "" + mDisplayInfo + "", "" + mTempMetrics + "", isValid="" + mIsValid;
    }
}","{
    synchronized (this) {
        updateDisplayInfoLocked();
        mDisplayInfo.getAppMetrics(mTempMetrics, getDisplayAdjustments());
        return ""Display id "" + mDisplayId + "": "" + mDisplayInfo + "", "" + mTempMetrics + "", isValid="" + mIsValid;
    }
}",1,"// For debugging purposes
","// For debugging purposes
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"An internal method call within the `toString()` method has been updated from `mDisplayInfo.getAppMetrics(mTempMetrics, mDisplayAdjustments)` to `mDisplayInfo.getAppMetrics(mTempMetrics, getDisplayAdjustments())`. There are no changes in return or exception handling statements, but there is a change in an internal method call, implying a different method of retrieving display adjustments is being used. This suggests that the dependent API `getDisplayAdjustments()` has been introduced or modified. Thus, the code change types include 4 (Other statement changed) for the method call change and 5 (Dependent API changed) due to the change in the method used to fetch the display adjustments.","As the change only affects how display adjustments are retrieved internally and the format of the return string has not changed, there should be no compatibility issue from this change provided `getDisplayAdjustments()` returns the same result as accessing `mDisplayAdjustments` directly. There is no impact on the value or type that is returned and no new exception paths. So, the Compatibility Issue is 0 (No Compatibility Issue)."
931,"<android.app.ContextImpl: Intent registerReceiver(BroadcastReceiver,IntentFilter,String,Handler)>",25,26,"<android.app.ContextImpl: Intent registerReceiver(BroadcastReceiver,IntentFilter,String,Handler)>","<android.app.ContextImpl: Intent registerReceiver(BroadcastReceiver,IntentFilter,String,Handler)>",0,"{
    return registerReceiverInternal(receiver, getUserId(), filter, broadcastPermission, scheduler, getOuterContext());
}","{
    return registerReceiverInternal(receiver, getUserId(), filter, broadcastPermission, scheduler, getOuterContext(), 0);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The change consists of adding a new parameter to the method registerReceiverInternal(), resulting in a different method signature being called, so the code change types are 4 (Other statement changed) and 5 (Dependent API changed).","There is no Compatibility Issue as the additional argument does not alter the return type nor behavior of the method from an external point of view. The added parameter is handled internally, and the method's contract remains the same with respect to its inputs and outputs, assuming the dependent method registerReceiverInternal is capable of handling the additional parameter without changing its behavior as observable by the caller. Therefore, the predicted CI is 0 (No Compatibility Issue)."
932,<android.app.PendingIntent: PendingIntent readPendingIntentOrNullFromParcel(Parcel)>,25,26,<android.app.PendingIntent: PendingIntent readPendingIntentOrNullFromParcel(Parcel)>,<android.app.PendingIntent: PendingIntent readPendingIntentOrNullFromParcel(Parcel)>,0,"{
    IBinder b = in.readStrongBinder();
    return b != null ? new PendingIntent(b) : null;
}","{
    IBinder b = in.readStrongBinder();
    return b != null ? new PendingIntent(b, in.getClassCookie(PendingIntent.class)) : null;
}",1,"/**
 * Convenience function for reading either a Messenger or null pointer from
 * a Parcel.  You must have previously written the Messenger with
 * {@link #writePendingIntentOrNullToParcel}.
 *
 * @param in The Parcel containing the written Messenger.
 *
 * @return Returns the Messenger read from the Parcel, or null if null had
 * been written.
 */
","/**
 * Convenience function for reading either a PendingIntent or null pointer from
 * a Parcel.  You must have previously written the PendingIntent with
 * {@link #writePendingIntentOrNullToParcel}.
 *
 * @param in The Parcel containing the written PendingIntent.
 *
 * @return Returns the PendingIntent read from the Parcel, or null if null had
 * been written.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,"1,5",1,"The constructor for `PendingIntent` objects has been changed to include a new parameter (`in.getClassCookie(PendingIntent.class)`), which indicates a dependent API has changed. Therefore, the code change type is 1,5.","The change of the constructor could potentially lead to a new instance of `PendingIntent` with different internal state, hence the API can return a different value. Therefore, the CI type is 1."
933,<android.widget.TextView: boolean onDragEvent(DragEvent)>,25,26,<android.widget.TextView: boolean onDragEvent(DragEvent)>,<android.widget.TextView: boolean onDragEvent(DragEvent)>,0,"{
    switch(event.getAction()) {
        case DragEvent.ACTION_DRAG_STARTED:
            return mEditor != null && mEditor.hasInsertionController();
        case DragEvent.ACTION_DRAG_ENTERED:
            TextView.this.requestFocus();
            return true;
        case DragEvent.ACTION_DRAG_LOCATION:
            final int offset = getOffsetForPosition(event.getX(), event.getY());
            Selection.setSelection((Spannable) mText, offset);
            return true;
        case DragEvent.ACTION_DROP:
            if (mEditor != null)
                mEditor.onDrop(event);
            return true;
        case DragEvent.ACTION_DRAG_ENDED:
        case DragEvent.ACTION_DRAG_EXITED:
        default:
            return true;
    }
}","{
    switch(event.getAction()) {
        case DragEvent.ACTION_DRAG_STARTED:
            return mEditor != null && mEditor.hasInsertionController();
        case DragEvent.ACTION_DRAG_ENTERED:
            TextView.this.requestFocus();
            return true;
        case DragEvent.ACTION_DRAG_LOCATION:
            if (mText instanceof Spannable) {
                final int offset = getOffsetForPosition(event.getX(), event.getY());
                Selection.setSelection((Spannable) mText, offset);
            }
            return true;
        case DragEvent.ACTION_DROP:
            if (mEditor != null)
                mEditor.onDrop(event);
            return true;
        case DragEvent.ACTION_DRAG_ENDED:
        case DragEvent.ACTION_DRAG_EXITED:
        default:
            return true;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,"The change exists within the DragEvent.ACTION_DRAG_LOCATION case where an additional condition has been added to check if `mText` is an instance of `Spannable`. This is a control dependency change, so the code change type is 3.","This change does not lead to a CI because the method still returns `true` in all cases. The additional condition simply determines whether or not to call `Selection.setSelection`, which does not affect the return value or exception handling of the method. Thus, there is no Compatibility Issue."
935,<android.app.Dialog: void show()>,25,26,<android.app.Dialog: void show()>,<android.app.Dialog: void show()>,0,"{
    if (mShowing) {
        if (mDecor != null) {
            if (mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) {
                mWindow.invalidatePanelMenu(Window.FEATURE_ACTION_BAR);
            }
            mDecor.setVisibility(View.VISIBLE);
        }
        return;
    }
    mCanceled = false;
    if (!mCreated) {
        dispatchOnCreate(null);
    }
    onStart();
    mDecor = mWindow.getDecorView();
    if (mActionBar == null && mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) {
        final ApplicationInfo info = mContext.getApplicationInfo();
        mWindow.setDefaultIcon(info.icon);
        mWindow.setDefaultLogo(info.logo);
        mActionBar = new WindowDecorActionBar(this);
    }
    WindowManager.LayoutParams l = mWindow.getAttributes();
    if ((l.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) == 0) {
        WindowManager.LayoutParams nl = new WindowManager.LayoutParams();
        nl.copyFrom(l);
        nl.softInputMode |= WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
        l = nl;
    }
    mWindowManager.addView(mDecor, l);
    mShowing = true;
    sendShowMessage();
}","{
    if (mShowing) {
        if (mDecor != null) {
            if (mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) {
                mWindow.invalidatePanelMenu(Window.FEATURE_ACTION_BAR);
            }
            mDecor.setVisibility(View.VISIBLE);
        }
        return;
    }
    mCanceled = false;
    if (!mCreated) {
        dispatchOnCreate(null);
    } else {
        // Fill the DecorView in on any configuration changes that
        // may have occured while it was removed from the WindowManager.
        final Configuration config = mContext.getResources().getConfiguration();
        mWindow.getDecorView().dispatchConfigurationChanged(config);
    }
    onStart();
    mDecor = mWindow.getDecorView();
    if (mActionBar == null && mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) {
        final ApplicationInfo info = mContext.getApplicationInfo();
        mWindow.setDefaultIcon(info.icon);
        mWindow.setDefaultLogo(info.logo);
        mActionBar = new WindowDecorActionBar(this);
    }
    WindowManager.LayoutParams l = mWindow.getAttributes();
    if ((l.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) == 0) {
        WindowManager.LayoutParams nl = new WindowManager.LayoutParams();
        nl.copyFrom(l);
        nl.softInputMode |= WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
        l = nl;
    }
    mWindowManager.addView(mDecor, l);
    mShowing = true;
    sendShowMessage();
}",1,"/**
 * Start the dialog and display it on screen.  The window is placed in the
 * application layer and opaque.  Note that you should not override this
 * method to do initialization when the dialog is shown, instead implement
 * that in {@link #onStart}.
 */
","/**
 * Start the dialog and display it on screen.  The window is placed in the
 * application layer and opaque.  Note that you should not override this
 * method to do initialization when the dialog is shown, instead implement
 * that in {@link #onStart}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"There is a new 'else' block added that executes when 'mCreated' is true. This inserts a new control flow path involving a call to dispatchConfigurationChanged(config), so the code change type includes 3 for control dependency change and 4 for other statement change.","The new 'else' block executes only when 'mCreated' is true and updates the DecorView with the latest configuration changes. It does not affect the return value or exception handling of the `show()` method itself, as this method still doesn't return any value nor does it have any exception handling that would change the expected behavior. So in terms of the API contract, there's no compatibility issue, hence pred_CI is 0."
937,<android.text.TextUtils: boolean isEmpty(CharSequence)>,25,26,<android.text.TextUtils: boolean isEmpty(CharSequence)>,<android.text.TextUtils: boolean isEmpty(CharSequence)>,0,"{
    if (str == null || str.length() == 0)
        return true;
    else
        return false;
}","{
    return str == null || str.length() == 0;
}",1,"/**
 * Returns true if the string is null or 0-length.
 * @param str the string to be examined
 * @return true if str is null or zero length
 */
","/**
 * Returns true if the string is null or 0-length.
 * @param str the string to be examined
 * @return true if str is null or zero length
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change is only in the refactoring of the same condition to a single return statement without affecting the logic of the method, so the code change type is 4.","Since the change is strictly refactoring without modifying the behavior or outcomes of the original implementation, there is no Compatibility Issue, thus CI type is 0."
938,"<android.os.Binder: boolean onTransact(int,Parcel,Parcel,int)>",25,26,"<android.os.Binder: boolean onTransact(int,Parcel,Parcel,int)>","<android.os.Binder: boolean onTransact(int,Parcel,Parcel,int)>",0,"{
    if (code == INTERFACE_TRANSACTION) {
        reply.writeString(getInterfaceDescriptor());
        return true;
    } else if (code == DUMP_TRANSACTION) {
        ParcelFileDescriptor fd = data.readFileDescriptor();
        String[] args = data.readStringArray();
        if (fd != null) {
            try {
                dump(fd.getFileDescriptor(), args);
            } finally {
                IoUtils.closeQuietly(fd);
            }
        }
        // Write the StrictMode header.
        if (reply != null) {
            reply.writeNoException();
        } else {
            StrictMode.clearGatheredViolations();
        }
        return true;
    } else if (code == SHELL_COMMAND_TRANSACTION) {
        ParcelFileDescriptor in = data.readFileDescriptor();
        ParcelFileDescriptor out = data.readFileDescriptor();
        ParcelFileDescriptor err = data.readFileDescriptor();
        String[] args = data.readStringArray();
        ResultReceiver resultReceiver = ResultReceiver.CREATOR.createFromParcel(data);
        try {
            if (out != null) {
                shellCommand(in != null ? in.getFileDescriptor() : null, out.getFileDescriptor(), err != null ? err.getFileDescriptor() : out.getFileDescriptor(), args, resultReceiver);
            }
        } finally {
            IoUtils.closeQuietly(in);
            IoUtils.closeQuietly(out);
            IoUtils.closeQuietly(err);
            // Write the StrictMode header.
            if (reply != null) {
                reply.writeNoException();
            } else {
                StrictMode.clearGatheredViolations();
            }
        }
        return true;
    }
    return false;
}","{
    if (code == INTERFACE_TRANSACTION) {
        reply.writeString(getInterfaceDescriptor());
        return true;
    } else if (code == DUMP_TRANSACTION) {
        ParcelFileDescriptor fd = data.readFileDescriptor();
        String[] args = data.readStringArray();
        if (fd != null) {
            try {
                dump(fd.getFileDescriptor(), args);
            } finally {
                IoUtils.closeQuietly(fd);
            }
        }
        // Write the StrictMode header.
        if (reply != null) {
            reply.writeNoException();
        } else {
            StrictMode.clearGatheredViolations();
        }
        return true;
    } else if (code == SHELL_COMMAND_TRANSACTION) {
        ParcelFileDescriptor in = data.readFileDescriptor();
        ParcelFileDescriptor out = data.readFileDescriptor();
        ParcelFileDescriptor err = data.readFileDescriptor();
        String[] args = data.readStringArray();
        ShellCallback shellCallback = ShellCallback.CREATOR.createFromParcel(data);
        ResultReceiver resultReceiver = ResultReceiver.CREATOR.createFromParcel(data);
        try {
            if (out != null) {
                shellCommand(in != null ? in.getFileDescriptor() : null, out.getFileDescriptor(), err != null ? err.getFileDescriptor() : out.getFileDescriptor(), args, shellCallback, resultReceiver);
            }
        } finally {
            IoUtils.closeQuietly(in);
            IoUtils.closeQuietly(out);
            IoUtils.closeQuietly(err);
            // Write the StrictMode header.
            if (reply != null) {
                reply.writeNoException();
            } else {
                StrictMode.clearGatheredViolations();
            }
        }
        return true;
    }
    return false;
}",1,"/**
 * Default implementation is a stub that returns false.  You will want
 * to override this to do the appropriate unmarshalling of transactions.
 *
 * <p>If you want to call this, call transact().
 */
","/**
 * Default implementation is a stub that returns false.  You will want
 * to override this to do the appropriate unmarshalling of transactions.
 *
 * <p>If you want to call this, call transact().
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The code has changed in the SHELL_COMMAND_TRANSACTION block, specifically in the call to shellCommand, where a new parameter 'shellCallback' is passed in. This parameter is acquired via ShellCallback.CREATOR.createFromParcel(data), which implies a change in the dependent method's signature (adding the ShellCallback parameter), so the change types are 4 and 5.","The method 'shellCommand' is now receiving an additional parameter 'shellCallback' which could potentially alter the behavior of the API, leading to a different return value. Thus, the CI type is 1."
939,<android.app.FragmentManagerImpl: Fragment findFragmentByWho(String)>,25,26,<android.app.FragmentManagerImpl: Fragment findFragmentByWho(String)>,<android.app.FragmentManagerImpl: Fragment findFragmentByWho(String)>,0,"{
    if (mActive != null && who != null) {
        for (int i = mActive.size() - 1; i >= 0; i--) {
            Fragment f = mActive.get(i);
            if (f != null && (f = f.findFragmentByWho(who)) != null) {
                return f;
            }
        }
    }
    return null;
}","{
    if (mActive != null && who != null) {
        for (int i = mActive.size() - 1; i >= 0; i--) {
            Fragment f = mActive.valueAt(i);
            if (f != null && (f = f.findFragmentByWho(who)) != null) {
                return f;
            }
        }
    }
    return null;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method called on `mActive` to retrieve the Fragment has changed from `get(i)` to `valueAt(i)`, which indicates a change in how the fragment is accessed from `mActive`. The code change is a method call within a dependent API and does not fall under return statement, exception handling statement, or control dependency changes – therefore, the code change type is 4,5.","Despite the change in method call from `get(i)` to `valueAt(i)`, there is no indication that this would result in a different returned value from the `findFragmentByWho` API, assuming the underlying data structure of `mActive` still supports index-based access to fragments in the same order. The same conditional checks remain in place and the logic for finding and returning a fragment is identical between versions. Thus, there is no CI, hence the CI type is 0."
940,"<android.content.res.AssetManager: CharSequence getResourceBagText(int,int)>",25,26,"<android.content.res.AssetManager: CharSequence getResourceBagText(int,int)>","<android.content.res.AssetManager: CharSequence getResourceBagText(int,int)>",0,"{
    synchronized (this) {
        final TypedValue outValue = mValue;
        final int block = loadResourceBagValue(resId, bagEntryId, outValue, true);
        if (block < 0) {
            return null;
        }
        if (outValue.type == TypedValue.TYPE_STRING) {
            return mStringBlocks[block].get(outValue.data);
        }
        return outValue.coerceToString();
    }
}","{
    synchronized (this) {
        final TypedValue outValue = mValue;
        final int block = loadResourceBagValue(resId, bagEntryId, outValue, true);
        if (block < 0) {
            return null;
        }
        // Convert the changing configurations flags populated by native code.
        outValue.changingConfigurations = ActivityInfo.activityInfoConfigNativeToJava(outValue.changingConfigurations);
        if (outValue.type == TypedValue.TYPE_STRING) {
            return mStringBlocks[block].get(outValue.data);
        }
        return outValue.coerceToString();
    }
}",1,"/**
 * Retrieves the string value associated with a particular resource
 * identifier for the current configuration.
 *
 * @param resId the resource identifier to load
 * @param bagEntryId
 * @return the string value, or {@code null}
 */
","/**
 * Retrieves the string value associated with a particular resource
 * identifier for the current configuration.
 *
 * @param resId the resource identifier to load
 * @param bagEntryId
 * @return the string value, or {@code null}
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,4,0,"The change in the late version is that an additional line of code has been inserted to convert the 'changingConfigurations' value from native to Java. There is no change to the control flow, return statements, or exception handling statements based on the given implementations, so the code change type is 4.","The new line of code added does not affect the behavior of the API in terms of the returned value or the type of exceptions that could be thrown. The API's contract seems intact, and it will still return the same values under the same conditions; hence, there is no compatibility issue, and the CI type is 0."
941,<android.bluetooth.le.BluetoothLeScanner.BleScanCallbackWrapper: void flushPendingBatchResults()>,25,26,<android.bluetooth.le.BluetoothLeScanner.BleScanCallbackWrapper: void flushPendingBatchResults()>,<android.bluetooth.le.BluetoothLeScanner.BleScanCallbackWrapper: void flushPendingBatchResults()>,0,"{
    synchronized (this) {
        if (mClientIf <= 0) {
            Log.e(TAG, ""Error state, mLeHandle: "" + mClientIf);
            return;
        }
        try {
            mBluetoothGatt.flushPendingBatchResults(mClientIf, false);
        } catch (RemoteException e) {
            Log.e(TAG, ""Failed to get pending scan results"", e);
        }
    }
}","{
    synchronized (this) {
        if (mScannerId <= 0) {
            Log.e(TAG, ""Error state, mLeHandle: "" + mScannerId);
            return;
        }
        try {
            mBluetoothGatt.flushPendingBatchResults(mScannerId);
        } catch (RemoteException e) {
            Log.e(TAG, ""Failed to get pending scan results"", e);
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",1,"The reference name in the conditional check has been changed from `mClientIf` to `mScannerId`, the log message has been updated accordingly, and the method call within the try block has been updated from `mBluetoothGatt.flushPendingBatchResults(mClientIf, false)` to `mBluetoothGatt.flushPendingBatchResults(mScannerId)`, indicating a change in the method signature as it no longer accepts the second parameter `false`. The changes made are types 3, 4, and 5.","The change in the method call `mBluetoothGatt.flushPendingBatchResults` may cause the API to behave differently due to the absence of the boolean parameter, which alters the way the method operates. This can affect the results returned by `flushPendingBatchResults()`, resulting in a CI type 1."
942,"<android.app.ContextImpl: void revokeUriPermission(Uri,int)>",25,26,"<android.app.ContextImpl: void revokeUriPermission(Uri,int)>","<android.app.ContextImpl: void revokeUriPermission(Uri,int)>",0,"{
    try {
        ActivityManagerNative.getDefault().revokeUriPermission(mMainThread.getApplicationThread(), ContentProvider.getUriWithoutUserId(uri), modeFlags, resolveUserId(uri));
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        ActivityManager.getService().revokeUriPermission(mMainThread.getApplicationThread(), null, ContentProvider.getUriWithoutUserId(uri), modeFlags, resolveUserId(uri));
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The dependent API call within the try block has changed from ActivityManagerNative.getDefault().revokeUriPermission(...) to ActivityManager.getService().revokeUriPermission(...), and there is an additional null parameter added to the method call, so the code change type is 4,5.","Although the dependent API call has changed, the outer method's signature remains unaffected, the behavior of exception handling is consistent, and there is no change in return value (since this method is void, it can't return a value). Therefore, despite the code change, it does not lead to any compatibility issues, and the CI type is 0."
943,<android.view.View: void buildLayer()>,25,26,<android.view.View: void buildLayer()>,<android.view.View: void buildLayer()>,0,"{
    if (mLayerType == LAYER_TYPE_NONE)
        return;
    final AttachInfo attachInfo = mAttachInfo;
    if (attachInfo == null) {
        throw new IllegalStateException(""This view must be attached to a window first"");
    }
    if (getWidth() == 0 || getHeight() == 0) {
        return;
    }
    switch(mLayerType) {
        case LAYER_TYPE_HARDWARE:
            updateDisplayListIfDirty();
            if (attachInfo.mHardwareRenderer != null && mRenderNode.isValid()) {
                attachInfo.mHardwareRenderer.buildLayer(mRenderNode);
            }
            break;
        case LAYER_TYPE_SOFTWARE:
            buildDrawingCache(true);
            break;
    }
}","{
    if (mLayerType == LAYER_TYPE_NONE)
        return;
    final AttachInfo attachInfo = mAttachInfo;
    if (attachInfo == null) {
        throw new IllegalStateException(""This view must be attached to a window first"");
    }
    if (getWidth() == 0 || getHeight() == 0) {
        return;
    }
    switch(mLayerType) {
        case LAYER_TYPE_HARDWARE:
            updateDisplayListIfDirty();
            if (attachInfo.mThreadedRenderer != null && mRenderNode.isValid()) {
                attachInfo.mThreadedRenderer.buildLayer(mRenderNode);
            }
            break;
        case LAYER_TYPE_SOFTWARE:
            buildDrawingCache(true);
            break;
    }
}",1,"/**
 * Forces this view's layer to be created and this view to be rendered
 * into its layer. If this view's layer type is set to {@link #LAYER_TYPE_NONE},
 * invoking this method will have no effect.
 *
 * This method can for instance be used to render a view into its layer before
 * starting an animation. If this view is complex, rendering into the layer
 * before starting the animation will avoid skipping frames.
 *
 * @throws IllegalStateException If this view is not attached to a window
 *
 * @see #setLayerType(int, android.graphics.Paint)
 */
","/**
 * Forces this view's layer to be created and this view to be rendered
 * into its layer. If this view's layer type is set to {@link #LAYER_TYPE_NONE},
 * invoking this method will have no effect.
 *
 * This method can for instance be used to render a view into its layer before
 * starting an animation. If this view is complex, rendering into the layer
 * before starting the animation will avoid skipping frames.
 *
 * @throws IllegalStateException If this view is not attached to a window
 *
 * @see #setLayerType(int, android.graphics.Paint)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The only change between the two versions is within a control dependency statement, where `attachInfo.mHardwareRenderer.buildLayer(mRenderNode);` has been changed to `attachInfo.mThreadedRenderer.buildLayer(mRenderNode);`. It indicates that the name of a member variable in the dependent API `AttachInfo` has changed from `mHardwareRenderer` to `mThreadedRenderer`. This is an other statement changed as well as a dependent API changed, so the code change types are 4,5.","Despite the renaming of the variable from `mHardwareRenderer` to `mThreadedRenderer`, there is no indication that the behavior of the method `buildLayer()` has changed. If we assume that `mThreadedRenderer.buildLayer(mRenderNode)` behaves the same as `mHardwareRenderer.buildLayer(mRenderNode)`, this is not a compatibility issue because the change does not alter the values returned or exceptions thrown by the method. Thus, the CI type is 0. However, without exact knowledge about the implementation of both `mHardwareRenderer` and `mThreadedRenderer`, it can't be guaranteed with certainty. Given the context that this is an early and late version change analysis, the assumption is that the underlying functionality did not change."
944,"<android.app.ActivityManager: int addAppTask(Activity,Intent,TaskDescription,Bitmap)>",25,26,"<android.app.ActivityManager: int addAppTask(Activity,Intent,TaskDescription,Bitmap)>","<android.app.ActivityManager: int addAppTask(Activity,Intent,TaskDescription,Bitmap)>",0,"{
    Point size;
    synchronized (this) {
        ensureAppTaskThumbnailSizeLocked();
        size = mAppTaskThumbnailSize;
    }
    final int tw = thumbnail.getWidth();
    final int th = thumbnail.getHeight();
    if (tw != size.x || th != size.y) {
        Bitmap bm = Bitmap.createBitmap(size.x, size.y, thumbnail.getConfig());
        // Use ScaleType.CENTER_CROP, except we leave the top edge at the top.
        float scale;
        float dx = 0, dy = 0;
        if (tw * size.x > size.y * th) {
            scale = (float) size.x / (float) th;
            dx = (size.y - tw * scale) * 0.5f;
        } else {
            scale = (float) size.y / (float) tw;
            dy = (size.x - th * scale) * 0.5f;
        }
        Matrix matrix = new Matrix();
        matrix.setScale(scale, scale);
        matrix.postTranslate((int) (dx + 0.5f), 0);
        Canvas canvas = new Canvas(bm);
        canvas.drawBitmap(thumbnail, matrix, null);
        canvas.setBitmap(null);
        thumbnail = bm;
    }
    if (description == null) {
        description = new TaskDescription();
    }
    try {
        return ActivityManagerNative.getDefault().addAppTask(activity.getActivityToken(), intent, description, thumbnail);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    Point size;
    synchronized (this) {
        ensureAppTaskThumbnailSizeLocked();
        size = mAppTaskThumbnailSize;
    }
    final int tw = thumbnail.getWidth();
    final int th = thumbnail.getHeight();
    if (tw != size.x || th != size.y) {
        Bitmap bm = Bitmap.createBitmap(size.x, size.y, thumbnail.getConfig());
        // Use ScaleType.CENTER_CROP, except we leave the top edge at the top.
        float scale;
        float dx = 0, dy = 0;
        if (tw * size.x > size.y * th) {
            scale = (float) size.x / (float) th;
            dx = (size.y - tw * scale) * 0.5f;
        } else {
            scale = (float) size.y / (float) tw;
            dy = (size.x - th * scale) * 0.5f;
        }
        Matrix matrix = new Matrix();
        matrix.setScale(scale, scale);
        matrix.postTranslate((int) (dx + 0.5f), 0);
        Canvas canvas = new Canvas(bm);
        canvas.drawBitmap(thumbnail, matrix, null);
        canvas.setBitmap(null);
        thumbnail = bm;
    }
    if (description == null) {
        description = new TaskDescription();
    }
    try {
        return getService().addAppTask(activity.getActivityToken(), intent, description, thumbnail);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Add a new {@link AppTask} for the calling application.  This will create a new
 * recents entry that is added to the <b>end</b> of all existing recents.
 *
 * @param activity The activity that is adding the entry.   This is used to help determine
 * the context that the new recents entry will be in.
 * @param intent The Intent that describes the recents entry.  This is the same Intent that
 * you would have used to launch the activity for it.  In generally you will want to set
 * both {@link Intent#FLAG_ACTIVITY_NEW_DOCUMENT} and
 * {@link Intent#FLAG_ACTIVITY_RETAIN_IN_RECENTS}; the latter is required since this recents
 * entry will exist without an activity, so it doesn't make sense to not retain it when
 * its activity disappears.  The given Intent here also must have an explicit ComponentName
 * set on it.
 * @param description Optional additional description information.
 * @param thumbnail Thumbnail to use for the recents entry.  Should be the size given by
 * {@link #getAppTaskThumbnailSize()}.  If the bitmap is not that exact size, it will be
 * recreated in your process, probably in a way you don't like, before the recents entry
 * is added.
 *
 * @return Returns the task id of the newly added app task, or -1 if the add failed.  The
 * most likely cause of failure is that there is no more room for more tasks for your app.
 */
","/**
 * Add a new {@link AppTask} for the calling application.  This will create a new
 * recents entry that is added to the <b>end</b> of all existing recents.
 *
 * @param activity The activity that is adding the entry.   This is used to help determine
 * the context that the new recents entry will be in.
 * @param intent The Intent that describes the recents entry.  This is the same Intent that
 * you would have used to launch the activity for it.  In generally you will want to set
 * both {@link Intent#FLAG_ACTIVITY_NEW_DOCUMENT} and
 * {@link Intent#FLAG_ACTIVITY_RETAIN_IN_RECENTS}; the latter is required since this recents
 * entry will exist without an activity, so it doesn't make sense to not retain it when
 * its activity disappears.  The given Intent here also must have an explicit ComponentName
 * set on it.
 * @param description Optional additional description information.
 * @param thumbnail Thumbnail to use for the recents entry.  Should be the size given by
 * {@link #getAppTaskThumbnailSize()}.  If the bitmap is not that exact size, it will be
 * recreated in your process, probably in a way you don't like, before the recents entry
 * is added.
 *
 * @return Returns the task id of the newly added app task, or -1 if the add failed.  The
 * most likely cause of failure is that there is no more room for more tasks for your app.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent API call has changed from ActivityManagerNative.getDefault().addAppTask(..) to getService().addAppTask(..), so the change type is 5.","Despite the change in the method used to add the app task, it is not clear whether the behavior of the new method is different from that of the old one. Without additional information indicating a change in behavior, we can't assume there's a compatibility issue based solely on the change of a method call, thus, there's no Compatibility Issue."
945,<android.text.method.TimeKeyListener: int getInputType()>,25,26,<android.text.method.TimeKeyListener: int getInputType()>,<android.text.method.TimeKeyListener: int getInputType()>,0,"{
    return InputType.TYPE_CLASS_DATETIME | InputType.TYPE_DATETIME_VARIATION_TIME;
}","{
    if (mNeedsAdvancedInput) {
        return InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_NORMAL;
    } else {
        return InputType.TYPE_CLASS_DATETIME | InputType.TYPE_DATETIME_VARIATION_TIME;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"An 'if' condition has been introduced in the late version that affects what input type is returned. Furthermore, the return statement can now potentially return different input types based on the value of the newly introduced variable `mNeedsAdvancedInput`. This modifies the control flow (type 3) and the returned value (type 1).","The conditional statement introduces a new code path that could result in a different returned type if `mNeedsAdvancedInput` is `true`, which is a change that could cause Compatibility Issues of type 1 due to potentially different return types."
946,<android.bluetooth.le.BluetoothLeAdvertiser: void stopAdvertising(AdvertiseCallback)>,25,26,<android.bluetooth.le.BluetoothLeAdvertiser: void stopAdvertising(AdvertiseCallback)>,<android.bluetooth.le.BluetoothLeAdvertiser: void stopAdvertising(AdvertiseCallback)>,0,"{
    synchronized (mLeAdvertisers) {
        if (callback == null) {
            throw new IllegalArgumentException(""callback cannot be null"");
        }
        AdvertiseCallbackWrapper wrapper = mLeAdvertisers.get(callback);
        if (wrapper == null)
            return;
        wrapper.stopAdvertising();
    }
}","{
    synchronized (mLegacyAdvertisers) {
        if (callback == null) {
            throw new IllegalArgumentException(""callback cannot be null"");
        }
        AdvertisingSetCallback wrapper = mLegacyAdvertisers.get(callback);
        if (wrapper == null)
            return;
        stopAdvertisingSet(wrapper);
        mLegacyAdvertisers.remove(callback);
    }
}",1,"/**
 * Stop Bluetooth LE advertising. The {@code callback} must be the same one use in
 * {@link BluetoothLeAdvertiser#startAdvertising}.
 * <p>
 * Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN} permission.
 *
 * @param callback {@link AdvertiseCallback} identifies the advertising instance to stop.
 */
","/**
 * Stop Bluetooth LE advertising. The {@code callback} must be the same one use in
 * {@link BluetoothLeAdvertiser#startAdvertising}.
 * <p>
 * Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN} permission.
 *
 * @param callback {@link AdvertiseCallback} identifies the advertising instance to stop.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,5","1,2","The code change includes modifying a synchronized block variable from mLeAdvertisers to mLegacyAdvertisers, changing the type of wrapper to AdvertisingSetCallback, introducing a new method stopAdvertisingSet() with the wrapper as a parameter, and adding a map removal operation mLegacyAdvertisers.remove(callback). These changes are categorized under exception handling statement changed, control dependency changed, and dependent API changed (3,5). The synchronized block's object change is categorized under other statements changed (4).","Introducing a new method call `stopAdvertisingSet(wrapper)` that was not present in the early version could change the execution flow leading to a different behavior. This can potentially introduce a different exception handling scenario because if this new method throws any unchecked exceptions, they were not present in the early version. Furthermore, the late version removes an entry from the mLegacyAdvertisers Map which is a change in behavior from the early version where this operation was not performed. This change can potentially lead to the method throwing exceptions related to object state (such as NullPointerException) and also returning different results due to the state mutation (removing a callback that no longer will be returned in potential subsequent calls to other methods expecting to find this callback). Therefore, the CI type is 1 for a potentially different return value or type due to the map removal and 2 for potential different exception throw due to the new stopAdvertisingSet method call."
947,<android.util.ArraySet: E removeAt(int)>,25,26,<android.util.ArraySet: E removeAt(int)>,<android.util.ArraySet: E removeAt(int)>,0,"{
    final Object old = mArray[index];
    if (mSize <= 1) {
        // Now empty.
        if (DEBUG)
            Log.d(TAG, ""remove: shrink from "" + mHashes.length + "" to 0"");
        freeArrays(mHashes, mArray, mSize);
        mHashes = EmptyArray.INT;
        mArray = EmptyArray.OBJECT;
        mSize = 0;
    } else {
        if (mHashes.length > (BASE_SIZE * 2) && mSize < mHashes.length / 3) {
            // Shrunk enough to reduce size of arrays.  We don't allow it to
            // shrink smaller than (BASE_SIZE*2) to avoid flapping between
            // that and BASE_SIZE.
            final int n = mSize > (BASE_SIZE * 2) ? (mSize + (mSize >> 1)) : (BASE_SIZE * 2);
            if (DEBUG)
                Log.d(TAG, ""remove: shrink from "" + mHashes.length + "" to "" + n);
            final int[] ohashes = mHashes;
            final Object[] oarray = mArray;
            allocArrays(n);
            mSize--;
            if (index > 0) {
                if (DEBUG)
                    Log.d(TAG, ""remove: copy from 0-"" + index + "" to 0"");
                System.arraycopy(ohashes, 0, mHashes, 0, index);
                System.arraycopy(oarray, 0, mArray, 0, index);
            }
            if (index < mSize) {
                if (DEBUG)
                    Log.d(TAG, ""remove: copy from "" + (index + 1) + ""-"" + mSize + "" to "" + index);
                System.arraycopy(ohashes, index + 1, mHashes, index, mSize - index);
                System.arraycopy(oarray, index + 1, mArray, index, mSize - index);
            }
        } else {
            mSize--;
            if (index < mSize) {
                if (DEBUG)
                    Log.d(TAG, ""remove: move "" + (index + 1) + ""-"" + mSize + "" to "" + index);
                System.arraycopy(mHashes, index + 1, mHashes, index, mSize - index);
                System.arraycopy(mArray, index + 1, mArray, index, mSize - index);
            }
            mArray[mSize] = null;
        }
    }
    return (E) old;
}","{
    final Object old = mArray[index];
    if (mSize <= 1) {
        // Now empty.
        if (DEBUG)
            Log.d(TAG, ""remove: shrink from "" + mHashes.length + "" to 0"");
        freeArrays(mHashes, mArray, mSize);
        mHashes = EmptyArray.INT;
        mArray = EmptyArray.OBJECT;
        mSize = 0;
    } else {
        if (mHashes.length > (BASE_SIZE * 2) && mSize < mHashes.length / 3) {
            // Shrunk enough to reduce size of arrays.  We don't allow it to
            // shrink smaller than (BASE_SIZE*2) to avoid flapping between
            // that and BASE_SIZE.
            final int n = mSize > (BASE_SIZE * 2) ? (mSize + (mSize >> 1)) : (BASE_SIZE * 2);
            if (DEBUG)
                Log.d(TAG, ""remove: shrink from "" + mHashes.length + "" to "" + n);
            final int[] ohashes = mHashes;
            final Object[] oarray = mArray;
            allocArrays(n);
            mSize--;
            if (index > 0) {
                if (DEBUG)
                    Log.d(TAG, ""remove: copy from 0-"" + index + "" to 0"");
                System.arraycopy(ohashes, 0, mHashes, 0, index);
                System.arraycopy(oarray, 0, mArray, 0, index);
            }
            if (index < mSize) {
                if (DEBUG) {
                    Log.d(TAG, ""remove: copy from "" + (index + 1) + ""-"" + mSize + "" to "" + index);
                }
                System.arraycopy(ohashes, index + 1, mHashes, index, mSize - index);
                System.arraycopy(oarray, index + 1, mArray, index, mSize - index);
            }
        } else {
            mSize--;
            if (index < mSize) {
                if (DEBUG) {
                    Log.d(TAG, ""remove: move "" + (index + 1) + ""-"" + mSize + "" to "" + index);
                }
                System.arraycopy(mHashes, index + 1, mHashes, index, mSize - index);
                System.arraycopy(mArray, index + 1, mArray, index, mSize - index);
            }
            mArray[mSize] = null;
        }
    }
    return (E) old;
}",1,"/**
 * Remove the key/value mapping at the given index.
 * @param index The desired index, must be between 0 and {@link #size()}-1.
 * @return Returns the value that was stored at this index.
 */
","/**
 * Remove the key/value mapping at the given index.
 * @param index The desired index, must be between 0 and {@link #size()}-1.
 * @return Returns the value that was stored at this index.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
948,<android.content.ClipboardManager: ClipData getPrimaryClip()>,25,26,<android.content.ClipboardManager: ClipData getPrimaryClip()>,<android.content.ClipboardManager: ClipData getPrimaryClip()>,0,"{
    try {
        return getService().getPrimaryClip(mContext.getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        return mService.getPrimaryClip(mContext.getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns the current primary clip on the clipboard.
 */
","/**
 * Returns the current primary clip on the clipboard.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method getService() invocation has been replaced with the direct use of mService, which indicates a change in how the service object is obtained. Thus, the code change type is 4,5.","Despite this change, it doesn't affect the return value or exception handling of the API because 'getService()' and 'mService' are expected to return the reference to the same service object. Thus, there is no Compatibility Issue, so the CI type is 0."
949,"<android.widget.RemoteViews.TextViewDrawableAction: void apply(View,ViewGroup,OnClickHandler)>",25,26,"<android.widget.RemoteViews.TextViewDrawableAction: void apply(View,ViewGroup,OnClickHandler)>","<android.widget.RemoteViews.TextViewDrawableAction: void apply(View,ViewGroup,OnClickHandler)>",0,"{
    final TextView target = (TextView) root.findViewById(viewId);
    if (target == null)
        return;
    if (drawablesLoaded) {
        if (isRelative) {
            target.setCompoundDrawablesRelativeWithIntrinsicBounds(id1, id2, id3, id4);
        } else {
            target.setCompoundDrawablesWithIntrinsicBounds(id1, id2, id3, id4);
        }
    } else if (useIcons) {
        final Context ctx = target.getContext();
        final Drawable id1 = i1 == null ? null : i1.loadDrawable(ctx);
        final Drawable id2 = i2 == null ? null : i2.loadDrawable(ctx);
        final Drawable id3 = i3 == null ? null : i3.loadDrawable(ctx);
        final Drawable id4 = i4 == null ? null : i4.loadDrawable(ctx);
        if (isRelative) {
            target.setCompoundDrawablesRelativeWithIntrinsicBounds(id1, id2, id3, id4);
        } else {
            target.setCompoundDrawablesWithIntrinsicBounds(id1, id2, id3, id4);
        }
    } else {
        if (isRelative) {
            target.setCompoundDrawablesRelativeWithIntrinsicBounds(d1, d2, d3, d4);
        } else {
            target.setCompoundDrawablesWithIntrinsicBounds(d1, d2, d3, d4);
        }
    }
}","{
    final TextView target = root.findViewById(viewId);
    if (target == null)
        return;
    if (drawablesLoaded) {
        if (isRelative) {
            target.setCompoundDrawablesRelativeWithIntrinsicBounds(id1, id2, id3, id4);
        } else {
            target.setCompoundDrawablesWithIntrinsicBounds(id1, id2, id3, id4);
        }
    } else if (useIcons) {
        final Context ctx = target.getContext();
        final Drawable id1 = i1 == null ? null : i1.loadDrawable(ctx);
        final Drawable id2 = i2 == null ? null : i2.loadDrawable(ctx);
        final Drawable id3 = i3 == null ? null : i3.loadDrawable(ctx);
        final Drawable id4 = i4 == null ? null : i4.loadDrawable(ctx);
        if (isRelative) {
            target.setCompoundDrawablesRelativeWithIntrinsicBounds(id1, id2, id3, id4);
        } else {
            target.setCompoundDrawablesWithIntrinsicBounds(id1, id2, id3, id4);
        }
    } else {
        if (isRelative) {
            target.setCompoundDrawablesRelativeWithIntrinsicBounds(d1, d2, d3, d4);
        } else {
            target.setCompoundDrawablesWithIntrinsicBounds(d1, d2, d3, d4);
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,0,0,"The code between the early version and late version of the implementation did not change, therefore, there's no change in terms of functionality.","Since there's no change in the implementation, there is no potential Compatibility Issue between the versions."
950,"<android.view.LayoutInflater: void rInflate(XmlPullParser,View,Context,AttributeSet,boolean)>",25,26,"<android.view.LayoutInflater: void rInflate(XmlPullParser,View,Context,AttributeSet,boolean)>","<android.view.LayoutInflater: void rInflate(XmlPullParser,View,Context,AttributeSet,boolean)>",0,"{
    final int depth = parser.getDepth();
    int type;
    while (((type = parser.next()) != XmlPullParser.END_TAG || parser.getDepth() > depth) && type != XmlPullParser.END_DOCUMENT) {
        if (type != XmlPullParser.START_TAG) {
            continue;
        }
        final String name = parser.getName();
        if (TAG_REQUEST_FOCUS.equals(name)) {
            parseRequestFocus(parser, parent);
        } else if (TAG_TAG.equals(name)) {
            parseViewTag(parser, parent, attrs);
        } else if (TAG_INCLUDE.equals(name)) {
            if (parser.getDepth() == 0) {
                throw new InflateException(""<include /> cannot be the root element"");
            }
            parseInclude(parser, context, parent, attrs);
        } else if (TAG_MERGE.equals(name)) {
            throw new InflateException(""<merge /> must be the root element"");
        } else {
            final View view = createViewFromTag(parent, name, context, attrs);
            final ViewGroup viewGroup = (ViewGroup) parent;
            final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs);
            rInflateChildren(parser, view, attrs, true);
            viewGroup.addView(view, params);
        }
    }
    if (finishInflate) {
        parent.onFinishInflate();
    }
}","{
    final int depth = parser.getDepth();
    int type;
    boolean pendingRequestFocus = false;
    while (((type = parser.next()) != XmlPullParser.END_TAG || parser.getDepth() > depth) && type != XmlPullParser.END_DOCUMENT) {
        if (type != XmlPullParser.START_TAG) {
            continue;
        }
        final String name = parser.getName();
        if (TAG_REQUEST_FOCUS.equals(name)) {
            pendingRequestFocus = true;
            consumeChildElements(parser);
        } else if (TAG_TAG.equals(name)) {
            parseViewTag(parser, parent, attrs);
        } else if (TAG_INCLUDE.equals(name)) {
            if (parser.getDepth() == 0) {
                throw new InflateException(""<include /> cannot be the root element"");
            }
            parseInclude(parser, context, parent, attrs);
        } else if (TAG_MERGE.equals(name)) {
            throw new InflateException(""<merge /> must be the root element"");
        } else {
            final View view = createViewFromTag(parent, name, context, attrs);
            final ViewGroup viewGroup = (ViewGroup) parent;
            final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs);
            rInflateChildren(parser, view, attrs, true);
            viewGroup.addView(view, params);
        }
    }
    if (pendingRequestFocus) {
        parent.restoreDefaultFocus();
    }
    if (finishInflate) {
        parent.onFinishInflate();
    }
}",1,"/**
 * Recursive method used to descend down the xml hierarchy and instantiate
 * views, instantiate their children, and then call onFinishInflate().
 * <p>
 * <strong>Note:</strong> Default visibility so the BridgeInflater can
 * override it.
 */
","/**
 * Recursive method used to descend down the xml hierarchy and instantiate
 * views, instantiate their children, and then call onFinishInflate().
 * <p>
 * <strong>Note:</strong> Default visibility so the BridgeInflater can
 * override it.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",0,"The late implementation introduces a new boolean variable `pendingRequestFocus` and changes the behavior associated with `TAG_REQUEST_FOCUS`. Instead of calling `parseRequestFocus(parser, parent)`, it now sets `pendingRequestFocus` to true and calls `consumeChildElements(parser)`. Additionally, at the end of the rInflate process, the condition if `(pendingRequestFocus)` now calls `parent.restoreDefaultFocus()` instead of `parent.onFinishInflate()`. These changes correspond to a return statement changed (since the variable that could potentially be part of a return state has been modified), a control dependency change, and an addition of a new variable and related condition, which are classified as other statement change.","There is no Compatibility Issue since the method return type is void and these changes will not lead to the API returning a different type or value, nor do they change the exceptions thrown by the method; they just alter the internal state or process by which the view is inflated."
951,"<android.app.KeyguardManager: Intent createConfirmDeviceCredentialIntent(CharSequence,CharSequence)>",25,26,"<android.app.KeyguardManager: Intent createConfirmDeviceCredentialIntent(CharSequence,CharSequence)>","<android.app.KeyguardManager: Intent createConfirmDeviceCredentialIntent(CharSequence,CharSequence)>",0,"{
    if (!isDeviceSecure())
        return null;
    Intent intent = new Intent(ACTION_CONFIRM_DEVICE_CREDENTIAL);
    intent.putExtra(EXTRA_TITLE, title);
    intent.putExtra(EXTRA_DESCRIPTION, description);
    // For security reasons, only allow this to come from system settings.
    intent.setPackage(""com.android.settings"");
    return intent;
}","{
    if (!isDeviceSecure())
        return null;
    Intent intent = new Intent(ACTION_CONFIRM_DEVICE_CREDENTIAL);
    intent.putExtra(EXTRA_TITLE, title);
    intent.putExtra(EXTRA_DESCRIPTION, description);
    // explicitly set the package for security
    intent.setPackage(getSettingsPackageForIntent(intent));
    return intent;
}",1,"/**
 * Get an intent to prompt the user to confirm credentials (pin, pattern or password)
 * for the current user of the device. The caller is expected to launch this activity using
 * {@link android.app.Activity#startActivityForResult(Intent, int)} and check for
 * {@link android.app.Activity#RESULT_OK} if the user successfully completes the challenge.
 *
 * @return the intent for launching the activity or null if no password is required.
 */
","/**
 * Get an intent to prompt the user to confirm credentials (pin, pattern or password)
 * for the current user of the device. The caller is expected to launch this activity using
 * {@link android.app.Activity#startActivityForResult(Intent, int)} and check for
 * {@link android.app.Activity#RESULT_OK} if the user successfully completes the challenge.
 *
 * @return the intent for launching the activity or null if no password is required.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method within the Intent instance to set the package has changed to use a method getSettingsPackageForIntent(intent) instead of a hardcoded string ""com.android.settings"", so the code change type is 4,5 as this involves changing a method call to another method which calculates or retrieves the intent's package.","There is no Compatibility Issue caused by this change because it does not alter the behavior of the API in terms of what it logically performs; it still sets the package for the Intent but in a potentially more dynamic way without affecting the external usage of the API. Thus, the CI type is 0."
952,"<android.app.FragmentManagerImpl: void addFragment(Fragment,boolean)>",25,26,"<android.app.FragmentManagerImpl: void addFragment(Fragment,boolean)>","<android.app.FragmentManagerImpl: void addFragment(Fragment,boolean)>",0,"{
    if (mAdded == null) {
        mAdded = new ArrayList<Fragment>();
    }
    if (DEBUG)
        Log.v(TAG, ""add: "" + fragment);
    makeActive(fragment);
    if (!fragment.mDetached) {
        if (mAdded.contains(fragment)) {
            throw new IllegalStateException(""Fragment already added: "" + fragment);
        }
        mAdded.add(fragment);
        fragment.mAdded = true;
        fragment.mRemoving = false;
        if (fragment.mHasMenu && fragment.mMenuVisible) {
            mNeedMenuInvalidate = true;
        }
        if (moveToStateNow) {
            moveToState(fragment);
        }
    }
}","{
    if (mAdded == null) {
        mAdded = new ArrayList<Fragment>();
    }
    if (DEBUG)
        Log.v(TAG, ""add: "" + fragment);
    makeActive(fragment);
    if (!fragment.mDetached) {
        if (mAdded.contains(fragment)) {
            throw new IllegalStateException(""Fragment already added: "" + fragment);
        }
        synchronized (mAdded) {
            mAdded.add(fragment);
        }
        fragment.mAdded = true;
        fragment.mRemoving = false;
        if (fragment.mView == null) {
            fragment.mHiddenChanged = false;
        }
        if (fragment.mHasMenu && fragment.mMenuVisible) {
            mNeedMenuInvalidate = true;
        }
        if (moveToStateNow) {
            moveToState(fragment);
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The condition in the control statement remains the same; however, the synchronized block has been introduced when adding the fragment to the `mAdded` list, which is a control dependency change. Additionally, these changes were within an existing control structure and did not introduce or remove any control structures, which constitutes an ""Other statement changed."" These are classified as 3,4 changes.","Despite the introduction of the synchronized block and checking for the `fragment.mView == null` condition, the behavior modifications do not result in a different variable being returned or an exception being thrown under normal API usage. It enhances thread safety and changes internal state management, but these alterations do not affect the behavior as perceived by the API's consumers in a way that would cause a compatibility issue. Therefore, it is classified as no compatibility issue, 0."
954,<android.app.admin.DevicePolicyManager: DevicePolicyManager getParentProfileInstance(ComponentName)>,25,26,<android.app.admin.DevicePolicyManager: DevicePolicyManager getParentProfileInstance(ComponentName)>,<android.app.admin.DevicePolicyManager: DevicePolicyManager getParentProfileInstance(ComponentName)>,0,"{
    throwIfParentInstance(""getParentProfileInstance"");
    try {
        if (!mService.isManagedProfile(admin)) {
            throw new SecurityException(""The current user does not have a parent profile."");
        }
        return new DevicePolicyManager(mContext, true);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    throwIfParentInstance(""getParentProfileInstance"");
    try {
        if (!mService.isManagedProfile(admin)) {
            throw new SecurityException(""The current user does not have a parent profile."");
        }
        return new DevicePolicyManager(mContext, mService, true);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Called by the profile owner of a managed profile to obtain a {@link DevicePolicyManager}
 * whose calls act on the parent profile.
 *
 * <p>The following methods are supported for the parent instance, all other methods will
 * throw a SecurityException when called on the parent instance:
 * <ul>
 * <li>{@link #getPasswordQuality}</li>
 * <li>{@link #setPasswordQuality}</li>
 * <li>{@link #getPasswordMinimumLength}</li>
 * <li>{@link #setPasswordMinimumLength}</li>
 * <li>{@link #getPasswordMinimumUpperCase}</li>
 * <li>{@link #setPasswordMinimumUpperCase}</li>
 * <li>{@link #getPasswordMinimumLowerCase}</li>
 * <li>{@link #setPasswordMinimumLowerCase}</li>
 * <li>{@link #getPasswordMinimumLetters}</li>
 * <li>{@link #setPasswordMinimumLetters}</li>
 * <li>{@link #getPasswordMinimumNumeric}</li>
 * <li>{@link #setPasswordMinimumNumeric}</li>
 * <li>{@link #getPasswordMinimumSymbols}</li>
 * <li>{@link #setPasswordMinimumSymbols}</li>
 * <li>{@link #getPasswordMinimumNonLetter}</li>
 * <li>{@link #setPasswordMinimumNonLetter}</li>
 * <li>{@link #getPasswordHistoryLength}</li>
 * <li>{@link #setPasswordHistoryLength}</li>
 * <li>{@link #getPasswordExpirationTimeout}</li>
 * <li>{@link #setPasswordExpirationTimeout}</li>
 * <li>{@link #getPasswordExpiration}</li>
 * <li>{@link #isActivePasswordSufficient}</li>
 * <li>{@link #getCurrentFailedPasswordAttempts}</li>
 * <li>{@link #getMaximumFailedPasswordsForWipe}</li>
 * <li>{@link #setMaximumFailedPasswordsForWipe}</li>
 * <li>{@link #getMaximumTimeToLock}</li>
 * <li>{@link #setMaximumTimeToLock}</li>
 * <li>{@link #lockNow}</li>
 * <li>{@link #getKeyguardDisabledFeatures}</li>
 * <li>{@link #setKeyguardDisabledFeatures}</li>
 * <li>{@link #getTrustAgentConfiguration}</li>
 * <li>{@link #setTrustAgentConfiguration}</li>
 * </ul>
 *
 * @return a new instance of {@link DevicePolicyManager} that acts on the parent profile.
 * @throws SecurityException if {@code admin} is not a profile owner.
 */
","/**
 * Called by the profile owner of a managed profile to obtain a {@link DevicePolicyManager}
 * whose calls act on the parent profile.
 *
 * <p>The following methods are supported for the parent instance, all other methods will
 * throw a SecurityException when called on the parent instance:
 * <ul>
 * <li>{@link #getPasswordQuality}</li>
 * <li>{@link #setPasswordQuality}</li>
 * <li>{@link #getPasswordMinimumLength}</li>
 * <li>{@link #setPasswordMinimumLength}</li>
 * <li>{@link #getPasswordMinimumUpperCase}</li>
 * <li>{@link #setPasswordMinimumUpperCase}</li>
 * <li>{@link #getPasswordMinimumLowerCase}</li>
 * <li>{@link #setPasswordMinimumLowerCase}</li>
 * <li>{@link #getPasswordMinimumLetters}</li>
 * <li>{@link #setPasswordMinimumLetters}</li>
 * <li>{@link #getPasswordMinimumNumeric}</li>
 * <li>{@link #setPasswordMinimumNumeric}</li>
 * <li>{@link #getPasswordMinimumSymbols}</li>
 * <li>{@link #setPasswordMinimumSymbols}</li>
 * <li>{@link #getPasswordMinimumNonLetter}</li>
 * <li>{@link #setPasswordMinimumNonLetter}</li>
 * <li>{@link #getPasswordHistoryLength}</li>
 * <li>{@link #setPasswordHistoryLength}</li>
 * <li>{@link #getPasswordExpirationTimeout}</li>
 * <li>{@link #setPasswordExpirationTimeout}</li>
 * <li>{@link #getPasswordExpiration}</li>
 * <li>{@link #getPasswordMaximumLength}</li>
 * <li>{@link #isActivePasswordSufficient}</li>
 * <li>{@link #getCurrentFailedPasswordAttempts}</li>
 * <li>{@link #getMaximumFailedPasswordsForWipe}</li>
 * <li>{@link #setMaximumFailedPasswordsForWipe}</li>
 * <li>{@link #getMaximumTimeToLock}</li>
 * <li>{@link #setMaximumTimeToLock}</li>
 * <li>{@link #lockNow}</li>
 * <li>{@link #getKeyguardDisabledFeatures}</li>
 * <li>{@link #setKeyguardDisabledFeatures}</li>
 * <li>{@link #getTrustAgentConfiguration}</li>
 * <li>{@link #setTrustAgentConfiguration}</li>
 * <li>{@link #getRequiredStrongAuthTimeout}</li>
 * <li>{@link #setRequiredStrongAuthTimeout}</li>
 * </ul>
 *
 * @return a new instance of {@link DevicePolicyManager} that acts on the parent profile.
 * @throws SecurityException if {@code admin} is not a profile owner.
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,5,0,"The constructor call for DevicePolicyManager has been changed from new DevicePolicyManager(mContext, true) to new DevicePolicyManager(mContext, mService, true), which means that there is a change in the dependent API (by adding an additional argument to the constructor), so the code change type is 5.","Despite the dependent API constructor changing (different parameters), as long as the constructor's handling of the parameters does not affect the returned object's behavior, there should be no compatibility issue. The constructor is called with an additional parameter, but this does not signify a change in the value or the type of the returned object. Since we cannot infer the internal implementation impact of adding 'mService' to the constructor based on the provided information alone, it should not be assumed as a CI unless we know it alters the returned 'DevicePolicyManager' instance behavior. Thus, I classified this as no compatibility issue (0)."
955,"<android.app.ContextImpl: void sendBroadcastMultiplePermissions(Intent,String[])>",25,26,"<android.app.ContextImpl: void sendBroadcastMultiplePermissions(Intent,String[])>","<android.app.ContextImpl: void sendBroadcastMultiplePermissions(Intent,String[])>",0,"{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, AppOpsManager.OP_NONE, null, false, false, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, AppOpsManager.OP_NONE, null, false, false, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,1,"The method `ActivityManagerNative.getDefault().broadcastIntent` in the early version has been changed to `ActivityManager.getService().broadcastIntent` in the late version, which means that a dependent API has been changed. Thus, the code change type is 5.","As there is a change in the dependent API that this method calls, there is a potential for the method to behave differently or return a different value due to changes in the dependent service. Therefore, the CI type is 1."
956,<android.util.EventLog.Event: Object getData()>,25,26,<android.util.EventLog.Event: Object getData()>,<android.util.EventLog.Event: Object getData()>,0,"{
    try {
        int offset = mBuffer.getShort(HEADER_SIZE_OFFSET);
        if (offset == 0) {
            offset = V1_PAYLOAD_START;
        }
        mBuffer.limit(offset + mBuffer.getShort(LENGTH_OFFSET));
        // Just after the tag.
        mBuffer.position(offset + DATA_OFFSET);
        return decodeObject();
    } catch (IllegalArgumentException e) {
        Log.wtf(TAG, ""Illegal entry payload: tag="" + getTag(), e);
        return null;
    } catch (BufferUnderflowException e) {
        Log.wtf(TAG, ""Truncated entry payload: tag="" + getTag(), e);
        return null;
    }
}","{
    try {
        int offset = mBuffer.getShort(HEADER_SIZE_OFFSET);
        if (offset == 0) {
            offset = V1_PAYLOAD_START;
        }
        mBuffer.limit(offset + mBuffer.getShort(LENGTH_OFFSET));
        if ((offset + DATA_OFFSET) >= mBuffer.limit()) {
            // no payload
            return null;
        }
        // Just after the tag.
        mBuffer.position(offset + DATA_OFFSET);
        return decodeObject();
    } catch (IllegalArgumentException e) {
        Log.wtf(TAG, ""Illegal entry payload: tag="" + getTag(), e);
        mLastWtf = e;
        return null;
    } catch (BufferUnderflowException e) {
        Log.wtf(TAG, ""Truncated entry payload: tag="" + getTag(), e);
        mLastWtf = e;
        return null;
    }
}",1,"/**
 * @return one of Integer, Long, Float, String, null, or Object[] of same.
 */
","/**
 * @return one of Integer, Long, Float, String, null, or Object[] of same.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The control dependency has changed with the addition of a new if statement to check if the buffer limit has exceeded before position setting, and a new assignment to the 'mLastWtf' variable introduces an 'Other statement changed'. Hence, the code change types are 3,4.","There are additional checks and an assignment to a variable, but these changes don't alter what is returned by the method or the exceptions that it might throw. The new check prevents a potential buffer over-read, which would have resulted in a runtime exception, so it could actually reduce the possibility of an exception being thrown. Therefore, there are no compatibility issues introduced by this change."
957,"<android.app.ContextImpl: void sendStickyBroadcastAsUser(Intent,UserHandle,Bundle)>",25,26,"<android.app.ContextImpl: void sendStickyBroadcastAsUser(Intent,UserHandle,Bundle)>","<android.app.ContextImpl: void sendStickyBroadcastAsUser(Intent,UserHandle,Bundle)>",0,"{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, options, false, true, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, options, false, true, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,"[@Override, @Deprecated]","[@Override, @Deprecated]",-1,-1,-1,-1,-1,-1,5,0,"The method `ActivityManagerNative.getDefault()` in the early version has been changed to `ActivityManager.getService()` in the late version. This indicates that the dependent API being invoked has changed, thus the code change type is 5.","Since the change is internal to the method and does not alter the method signature, thrown exceptions, or return types, it does not lead to a Compatibility Issue in the context of how the method is invoked or its expected results from an API consumer perspective. Therefore, there is no Compatibility Issue, and the CI type is 0."
960,<android.content.AsyncTaskLoader: boolean onCancelLoad()>,25,26,<android.content.AsyncTaskLoader: boolean onCancelLoad()>,<android.content.AsyncTaskLoader: boolean onCancelLoad()>,0,"{
    if (DEBUG)
        Log.v(TAG, ""onCancelLoad: mTask="" + mTask);
    if (mTask != null) {
        if (mCancellingTask != null) {
            // one being canceled; just drop it.
            if (DEBUG)
                Log.v(TAG, ""cancelLoad: still waiting for cancelled task; dropping next"");
            if (mTask.waiting) {
                mTask.waiting = false;
                mHandler.removeCallbacks(mTask);
            }
            mTask = null;
            return false;
        } else if (mTask.waiting) {
            // execute.  We can just toss it.
            if (DEBUG)
                Log.v(TAG, ""cancelLoad: task is waiting, dropping it"");
            mTask.waiting = false;
            mHandler.removeCallbacks(mTask);
            mTask = null;
            return false;
        } else {
            boolean cancelled = mTask.cancel(false);
            if (DEBUG)
                Log.v(TAG, ""cancelLoad: cancelled="" + cancelled);
            if (cancelled) {
                mCancellingTask = mTask;
                cancelLoadInBackground();
            }
            mTask = null;
            return cancelled;
        }
    }
    return false;
}","{
    if (DEBUG)
        Log.v(TAG, ""onCancelLoad: mTask="" + mTask);
    if (mTask != null) {
        if (!mStarted) {
            mContentChanged = true;
        }
        if (mCancellingTask != null) {
            // one being canceled; just drop it.
            if (DEBUG)
                Log.v(TAG, ""cancelLoad: still waiting for cancelled task; dropping next"");
            if (mTask.waiting) {
                mTask.waiting = false;
                mHandler.removeCallbacks(mTask);
            }
            mTask = null;
            return false;
        } else if (mTask.waiting) {
            // execute.  We can just toss it.
            if (DEBUG)
                Log.v(TAG, ""cancelLoad: task is waiting, dropping it"");
            mTask.waiting = false;
            mHandler.removeCallbacks(mTask);
            mTask = null;
            return false;
        } else {
            boolean cancelled = mTask.cancel(false);
            if (DEBUG)
                Log.v(TAG, ""cancelLoad: cancelled="" + cancelled);
            if (cancelled) {
                mCancellingTask = mTask;
                cancelLoadInBackground();
            }
            mTask = null;
            return cancelled;
        }
    }
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"There is an addition of a new if statement (`if (!mStarted) { mContentChanged = true; }`) that modifies a variable without affecting the return value or exception handling, so the code change type is 4.","The observed change does not introduce a new return statement, modify an existing one, or alter any exception handling behavior. The modification affects an internal state, which does not directly translate to a compatibility issue according to the definitions provided. Therefore, there is no compatibility issue (CI type 0)."
961,<android.view.InputDevice: String toString()>,25,26,<android.view.InputDevice: String toString()>,<android.view.InputDevice: String toString()>,0,"{
    StringBuilder description = new StringBuilder();
    description.append(""Input Device "").append(mId).append("": "").append(mName).append(""\n"");
    description.append(""  Descriptor: "").append(mDescriptor).append(""\n"");
    description.append(""  Generation: "").append(mGeneration).append(""\n"");
    description.append(""  Location: "").append(mIsExternal ? ""external"" : ""built-in"").append(""\n"");
    description.append(""  Keyboard Type: "");
    switch(mKeyboardType) {
        case KEYBOARD_TYPE_NONE:
            description.append(""none"");
            break;
        case KEYBOARD_TYPE_NON_ALPHABETIC:
            description.append(""non-alphabetic"");
            break;
        case KEYBOARD_TYPE_ALPHABETIC:
            description.append(""alphabetic"");
            break;
    }
    description.append(""\n"");
    description.append(""  Has Vibrator: "").append(mHasVibrator).append(""\n"");
    description.append(""  Has mic: "").append(mHasMicrophone).append(""\n"");
    description.append(""  Sources: 0x"").append(Integer.toHexString(mSources)).append("" ("");
    appendSourceDescriptionIfApplicable(description, SOURCE_KEYBOARD, ""keyboard"");
    appendSourceDescriptionIfApplicable(description, SOURCE_DPAD, ""dpad"");
    appendSourceDescriptionIfApplicable(description, SOURCE_TOUCHSCREEN, ""touchscreen"");
    appendSourceDescriptionIfApplicable(description, SOURCE_MOUSE, ""mouse"");
    appendSourceDescriptionIfApplicable(description, SOURCE_STYLUS, ""stylus"");
    appendSourceDescriptionIfApplicable(description, SOURCE_TRACKBALL, ""trackball"");
    appendSourceDescriptionIfApplicable(description, SOURCE_TOUCHPAD, ""touchpad"");
    appendSourceDescriptionIfApplicable(description, SOURCE_JOYSTICK, ""joystick"");
    appendSourceDescriptionIfApplicable(description, SOURCE_GAMEPAD, ""gamepad"");
    description.append("" )\n"");
    final int numAxes = mMotionRanges.size();
    for (int i = 0; i < numAxes; i++) {
        MotionRange range = mMotionRanges.get(i);
        description.append(""    "").append(MotionEvent.axisToString(range.mAxis));
        description.append("": source=0x"").append(Integer.toHexString(range.mSource));
        description.append("" min="").append(range.mMin);
        description.append("" max="").append(range.mMax);
        description.append("" flat="").append(range.mFlat);
        description.append("" fuzz="").append(range.mFuzz);
        description.append("" resolution="").append(range.mResolution);
        description.append(""\n"");
    }
    return description.toString();
}","{
    StringBuilder description = new StringBuilder();
    description.append(""Input Device "").append(mId).append("": "").append(mName).append(""\n"");
    description.append(""  Descriptor: "").append(mDescriptor).append(""\n"");
    description.append(""  Generation: "").append(mGeneration).append(""\n"");
    description.append(""  Location: "").append(mIsExternal ? ""external"" : ""built-in"").append(""\n"");
    description.append(""  Keyboard Type: "");
    switch(mKeyboardType) {
        case KEYBOARD_TYPE_NONE:
            description.append(""none"");
            break;
        case KEYBOARD_TYPE_NON_ALPHABETIC:
            description.append(""non-alphabetic"");
            break;
        case KEYBOARD_TYPE_ALPHABETIC:
            description.append(""alphabetic"");
            break;
    }
    description.append(""\n"");
    description.append(""  Has Vibrator: "").append(mHasVibrator).append(""\n"");
    description.append(""  Has mic: "").append(mHasMicrophone).append(""\n"");
    description.append(""  Sources: 0x"").append(Integer.toHexString(mSources)).append("" ("");
    appendSourceDescriptionIfApplicable(description, SOURCE_KEYBOARD, ""keyboard"");
    appendSourceDescriptionIfApplicable(description, SOURCE_DPAD, ""dpad"");
    appendSourceDescriptionIfApplicable(description, SOURCE_TOUCHSCREEN, ""touchscreen"");
    appendSourceDescriptionIfApplicable(description, SOURCE_MOUSE, ""mouse"");
    appendSourceDescriptionIfApplicable(description, SOURCE_STYLUS, ""stylus"");
    appendSourceDescriptionIfApplicable(description, SOURCE_TRACKBALL, ""trackball"");
    appendSourceDescriptionIfApplicable(description, SOURCE_MOUSE_RELATIVE, ""mouse_relative"");
    appendSourceDescriptionIfApplicable(description, SOURCE_TOUCHPAD, ""touchpad"");
    appendSourceDescriptionIfApplicable(description, SOURCE_JOYSTICK, ""joystick"");
    appendSourceDescriptionIfApplicable(description, SOURCE_GAMEPAD, ""gamepad"");
    description.append("" )\n"");
    final int numAxes = mMotionRanges.size();
    for (int i = 0; i < numAxes; i++) {
        MotionRange range = mMotionRanges.get(i);
        description.append(""    "").append(MotionEvent.axisToString(range.mAxis));
        description.append("": source=0x"").append(Integer.toHexString(range.mSource));
        description.append("" min="").append(range.mMin);
        description.append("" max="").append(range.mMax);
        description.append("" flat="").append(range.mFlat);
        description.append("" fuzz="").append(range.mFuzz);
        description.append("" resolution="").append(range.mResolution);
        description.append(""\n"");
    }
    return description.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
962,<android.content.res.ResourcesImpl.ThemeImpl: int getChangingConfigurations()>,25,26,<android.content.res.ResourcesImpl.ThemeImpl: int getChangingConfigurations()>,<android.content.res.ResourcesImpl.ThemeImpl: int getChangingConfigurations()>,0,"{
    synchronized (mKey) {
        final int nativeChangingConfig = AssetManager.getThemeChangingConfigurations(mTheme);
        return ActivityInfo.activityInfoConfigNativeToJava(nativeChangingConfig);
    }
}","{
    synchronized (mKey) {
        @NativeConfig final int nativeChangingConfig = AssetManager.getThemeChangingConfigurations(mTheme);
        return ActivityInfo.activityInfoConfigNativeToJava(nativeChangingConfig);
    }
}",1,,,-1,[@Config],[@Config],-1,-1,-1,-1,-1,-1,4,0,"The only change in the code is the addition of the @NativeConfig annotation to the local variable nativeChangingConfig. This is a change in the annotation of a local variable and not a structural change to the method's code. Given that annotations on local variables do not affect the method's runtime behavior, the code change type is 4.","The change does not impact the method's functionality, as it's only an annotation change on a local variable. Thus, there are no Compatibility Issues, and the CI type is 0."
964,<android.bluetooth.BluetoothGatt: boolean writeDescriptor(BluetoothGattDescriptor)>,25,26,<android.bluetooth.BluetoothGatt: boolean writeDescriptor(BluetoothGattDescriptor)>,<android.bluetooth.BluetoothGatt: boolean writeDescriptor(BluetoothGattDescriptor)>,0,"{
    if (VDBG)
        Log.d(TAG, ""writeDescriptor() - uuid: "" + descriptor.getUuid());
    if (mService == null || mClientIf == 0 || descriptor.getValue() == null)
        return false;
    BluetoothGattCharacteristic characteristic = descriptor.getCharacteristic();
    if (characteristic == null)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusy) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.writeDescriptor(mClientIf, device.getAddress(), descriptor.getInstanceId(), BluetoothGattCharacteristic.WRITE_TYPE_DEFAULT, AUTHENTICATION_NONE, descriptor.getValue());
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}","{
    if (VDBG)
        Log.d(TAG, ""writeDescriptor() - uuid: "" + descriptor.getUuid());
    if (mService == null || mClientIf == 0 || descriptor.getValue() == null)
        return false;
    BluetoothGattCharacteristic characteristic = descriptor.getCharacteristic();
    if (characteristic == null)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusy) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.writeDescriptor(mClientIf, device.getAddress(), descriptor.getInstanceId(), AUTHENTICATION_NONE, descriptor.getValue());
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}",1,"/**
 * Write the value of a given descriptor to the associated remote device.
 *
 * <p>A {@link BluetoothGattCallback#onDescriptorWrite} callback is
 * triggered to report the result of the write operation.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param descriptor Descriptor to write to the associated remote device
 * @return true, if the write operation was initiated successfully
 */
","/**
 * Write the value of a given descriptor to the associated remote device.
 *
 * <p>A {@link BluetoothGattCallback#onDescriptorWrite} callback is
 * triggered to report the result of the write operation.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param descriptor Descriptor to write to the associated remote device
 * @return true, if the write operation was initiated successfully
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,"A parameter is removed from the method call `mService.writeDescriptor()`. This is a Dependent API change, so the code change type is 5.","The removed parameter from the `mService.writeDescriptor()` method call will cause the API to potentially behave differently because the dependent API has changed. Therefore, the CI type is 1."
965,"<android.text.SpannableStringBuilder: SpannableStringBuilder replace(int,int,CharSequence,int,int)>",25,26,"<android.text.SpannableStringBuilder: SpannableStringBuilder replace(int,int,CharSequence,int,int)>","<android.text.SpannableStringBuilder: SpannableStringBuilder replace(int,int,CharSequence,int,int)>",0,"{
    checkRange(""replace"", start, end);
    int filtercount = mFilters.length;
    for (int i = 0; i < filtercount; i++) {
        CharSequence repl = mFilters[i].filter(tb, tbstart, tbend, this, start, end);
        if (repl != null) {
            tb = repl;
            tbstart = 0;
            tbend = repl.length();
        }
    }
    final int origLen = end - start;
    final int newLen = tbend - tbstart;
    if (origLen == 0 && newLen == 0 && !hasNonExclusiveExclusiveSpanAt(tb, tbstart)) {
        // Early exit so that the text watchers do not get notified
        return this;
    }
    TextWatcher[] textWatchers = getSpans(start, start + origLen, TextWatcher.class);
    sendBeforeTextChanged(textWatchers, start, origLen, newLen);
    // Try to keep the cursor / selection at the same relative position during
    // a text replacement. If replaced or replacement text length is zero, this
    // is already taken care of.
    boolean adjustSelection = origLen != 0 && newLen != 0;
    int selectionStart = 0;
    int selectionEnd = 0;
    if (adjustSelection) {
        selectionStart = Selection.getSelectionStart(this);
        selectionEnd = Selection.getSelectionEnd(this);
    }
    change(start, end, tb, tbstart, tbend);
    if (adjustSelection) {
        boolean changed = false;
        if (selectionStart > start && selectionStart < end) {
            final long diff = selectionStart - start;
            final int offset = Math.toIntExact(diff * newLen / origLen);
            selectionStart = start + offset;
            changed = true;
            setSpan(false, Selection.SELECTION_START, selectionStart, selectionStart, Spanned.SPAN_POINT_POINT);
        }
        if (selectionEnd > start && selectionEnd < end) {
            final long diff = selectionEnd - start;
            final int offset = Math.toIntExact(diff * newLen / origLen);
            selectionEnd = start + offset;
            changed = true;
            setSpan(false, Selection.SELECTION_END, selectionEnd, selectionEnd, Spanned.SPAN_POINT_POINT);
        }
        if (changed) {
            restoreInvariants();
        }
    }
    sendTextChanged(textWatchers, start, origLen, newLen);
    sendAfterTextChanged(textWatchers);
    // Span watchers need to be called after text watchers, which may update the layout
    sendToSpanWatchers(start, end, newLen - origLen);
    return this;
}","{
    checkRange(""replace"", start, end);
    int filtercount = mFilters.length;
    for (int i = 0; i < filtercount; i++) {
        CharSequence repl = mFilters[i].filter(tb, tbstart, tbend, this, start, end);
        if (repl != null) {
            tb = repl;
            tbstart = 0;
            tbend = repl.length();
        }
    }
    final int origLen = end - start;
    final int newLen = tbend - tbstart;
    if (origLen == 0 && newLen == 0 && !hasNonExclusiveExclusiveSpanAt(tb, tbstart)) {
        // Early exit so that the text watchers do not get notified
        return this;
    }
    TextWatcher[] textWatchers = getSpans(start, start + origLen, TextWatcher.class);
    sendBeforeTextChanged(textWatchers, start, origLen, newLen);
    // Try to keep the cursor / selection at the same relative position during
    // a text replacement. If replaced or replacement text length is zero, this
    // is already taken care of.
    boolean adjustSelection = origLen != 0 && newLen != 0;
    int selectionStart = 0;
    int selectionEnd = 0;
    if (adjustSelection) {
        selectionStart = Selection.getSelectionStart(this);
        selectionEnd = Selection.getSelectionEnd(this);
    }
    change(start, end, tb, tbstart, tbend);
    if (adjustSelection) {
        boolean changed = false;
        if (selectionStart > start && selectionStart < end) {
            final long diff = selectionStart - start;
            final int offset = Math.toIntExact(diff * newLen / origLen);
            selectionStart = start + offset;
            changed = true;
            setSpan(false, Selection.SELECTION_START, selectionStart, selectionStart, Spanned.SPAN_POINT_POINT, true);
        }
        if (selectionEnd > start && selectionEnd < end) {
            final long diff = selectionEnd - start;
            final int offset = Math.toIntExact(diff * newLen / origLen);
            selectionEnd = start + offset;
            changed = true;
            setSpan(false, Selection.SELECTION_END, selectionEnd, selectionEnd, Spanned.SPAN_POINT_POINT, true);
        }
        if (changed) {
            restoreInvariants();
        }
    }
    sendTextChanged(textWatchers, start, origLen, newLen);
    sendAfterTextChanged(textWatchers);
    // Span watchers need to be called after text watchers, which may update the layout
    sendToSpanWatchers(start, end, newLen - origLen);
    return this;
}",1,"// Documentation from interface
","// Documentation from interface
",-1,,,-1,-1,-1,-1,-1,-1,,,,
968,"<android.app.FragmentManagerImpl: void restoreAllState(Parcelable,FragmentManagerNonConfig)>",25,26,"<android.app.FragmentManagerImpl: void restoreAllState(Parcelable,FragmentManagerNonConfig)>","<android.app.FragmentManagerImpl: void restoreAllState(Parcelable,FragmentManagerNonConfig)>",0,"{
    // any nonConfig fragments either, so that is that.
    if (state == null)
        return;
    FragmentManagerState fms = (FragmentManagerState) state;
    if (fms.mActive == null)
        return;
    List<FragmentManagerNonConfig> childNonConfigs = null;
    // to their saved state, so we don't try to instantiate them again.
    if (nonConfig != null) {
        List<Fragment> nonConfigFragments = nonConfig.getFragments();
        childNonConfigs = nonConfig.getChildNonConfigs();
        final int count = nonConfigFragments != null ? nonConfigFragments.size() : 0;
        for (int i = 0; i < count; i++) {
            Fragment f = nonConfigFragments.get(i);
            if (DEBUG)
                Log.v(TAG, ""restoreAllState: re-attaching retained "" + f);
            FragmentState fs = fms.mActive[f.mIndex];
            fs.mInstance = f;
            f.mSavedViewState = null;
            f.mBackStackNesting = 0;
            f.mInLayout = false;
            f.mAdded = false;
            f.mTarget = null;
            if (fs.mSavedFragmentState != null) {
                fs.mSavedFragmentState.setClassLoader(mHost.getContext().getClassLoader());
                f.mSavedViewState = fs.mSavedFragmentState.getSparseParcelableArray(FragmentManagerImpl.VIEW_STATE_TAG);
                f.mSavedFragmentState = fs.mSavedFragmentState;
            }
        }
    }
    // Build the full list of active fragments, instantiating them from
    // their saved state.
    mActive = new ArrayList<>(fms.mActive.length);
    if (mAvailIndices != null) {
        mAvailIndices.clear();
    }
    for (int i = 0; i < fms.mActive.length; i++) {
        FragmentState fs = fms.mActive[i];
        if (fs != null) {
            FragmentManagerNonConfig childNonConfig = null;
            if (childNonConfigs != null && i < childNonConfigs.size()) {
                childNonConfig = childNonConfigs.get(i);
            }
            Fragment f = fs.instantiate(mHost, mParent, childNonConfig);
            if (DEBUG)
                Log.v(TAG, ""restoreAllState: active #"" + i + "": "" + f);
            mActive.add(f);
            // Now that the fragment is instantiated (or came from being
            // retained above), clear mInstance in case we end up re-restoring
            // from this FragmentState again.
            fs.mInstance = null;
        } else {
            mActive.add(null);
            if (mAvailIndices == null) {
                mAvailIndices = new ArrayList<>();
            }
            if (DEBUG)
                Log.v(TAG, ""restoreAllState: avail #"" + i);
            mAvailIndices.add(i);
        }
    }
    // Update the target of all retained fragments.
    if (nonConfig != null) {
        List<Fragment> nonConfigFragments = nonConfig.getFragments();
        final int count = nonConfigFragments != null ? nonConfigFragments.size() : 0;
        for (int i = 0; i < count; i++) {
            Fragment f = nonConfigFragments.get(i);
            if (f.mTargetIndex >= 0) {
                if (f.mTargetIndex < mActive.size()) {
                    f.mTarget = mActive.get(f.mTargetIndex);
                } else {
                    Log.w(TAG, ""Re-attaching retained fragment "" + f + "" target no longer exists: "" + f.mTargetIndex);
                    f.mTarget = null;
                }
            }
        }
    }
    // Build the list of currently added fragments.
    if (fms.mAdded != null) {
        mAdded = new ArrayList<Fragment>(fms.mAdded.length);
        for (int i = 0; i < fms.mAdded.length; i++) {
            Fragment f = mActive.get(fms.mAdded[i]);
            if (f == null) {
                throwException(new IllegalStateException(""No instantiated fragment for index #"" + fms.mAdded[i]));
            }
            f.mAdded = true;
            if (DEBUG)
                Log.v(TAG, ""restoreAllState: added #"" + i + "": "" + f);
            if (mAdded.contains(f)) {
                throw new IllegalStateException(""Already added!"");
            }
            mAdded.add(f);
        }
    } else {
        mAdded = null;
    }
    // Build the back stack.
    if (fms.mBackStack != null) {
        mBackStack = new ArrayList<BackStackRecord>(fms.mBackStack.length);
        for (int i = 0; i < fms.mBackStack.length; i++) {
            BackStackRecord bse = fms.mBackStack[i].instantiate(this);
            if (DEBUG) {
                Log.v(TAG, ""restoreAllState: back stack #"" + i + "" (index "" + bse.mIndex + ""): "" + bse);
                LogWriter logw = new LogWriter(Log.VERBOSE, TAG);
                PrintWriter pw = new FastPrintWriter(logw, false, 1024);
                bse.dump(""  "", pw, false);
                pw.flush();
            }
            mBackStack.add(bse);
            if (bse.mIndex >= 0) {
                setBackStackIndex(bse.mIndex, bse);
            }
        }
    } else {
        mBackStack = null;
    }
}","{
    // any nonConfig fragments either, so that is that.
    if (state == null)
        return;
    FragmentManagerState fms = (FragmentManagerState) state;
    if (fms.mActive == null)
        return;
    List<FragmentManagerNonConfig> childNonConfigs = null;
    // to their saved state, so we don't try to instantiate them again.
    if (nonConfig != null) {
        List<Fragment> nonConfigFragments = nonConfig.getFragments();
        childNonConfigs = nonConfig.getChildNonConfigs();
        final int count = nonConfigFragments != null ? nonConfigFragments.size() : 0;
        for (int i = 0; i < count; i++) {
            Fragment f = nonConfigFragments.get(i);
            if (DEBUG)
                Log.v(TAG, ""restoreAllState: re-attaching retained "" + f);
            // index of f in fms.mActive
            int index = 0;
            while (index < fms.mActive.length && fms.mActive[index].mIndex != f.mIndex) {
                index++;
            }
            if (index == fms.mActive.length) {
                throwException(new IllegalStateException(""Could not find active fragment "" + ""with index "" + f.mIndex));
            }
            FragmentState fs = fms.mActive[index];
            fs.mInstance = f;
            f.mSavedViewState = null;
            f.mBackStackNesting = 0;
            f.mInLayout = false;
            f.mAdded = false;
            f.mTarget = null;
            if (fs.mSavedFragmentState != null) {
                fs.mSavedFragmentState.setClassLoader(mHost.getContext().getClassLoader());
                f.mSavedViewState = fs.mSavedFragmentState.getSparseParcelableArray(FragmentManagerImpl.VIEW_STATE_TAG);
                f.mSavedFragmentState = fs.mSavedFragmentState;
            }
        }
    }
    // Build the full list of active fragments, instantiating them from
    // their saved state.
    mActive = new SparseArray<>(fms.mActive.length);
    for (int i = 0; i < fms.mActive.length; i++) {
        FragmentState fs = fms.mActive[i];
        if (fs != null) {
            FragmentManagerNonConfig childNonConfig = null;
            if (childNonConfigs != null && i < childNonConfigs.size()) {
                childNonConfig = childNonConfigs.get(i);
            }
            Fragment f = fs.instantiate(mHost, mContainer, mParent, childNonConfig);
            if (DEBUG)
                Log.v(TAG, ""restoreAllState: active #"" + i + "": "" + f);
            mActive.put(f.mIndex, f);
            // Now that the fragment is instantiated (or came from being
            // retained above), clear mInstance in case we end up re-restoring
            // from this FragmentState again.
            fs.mInstance = null;
        }
    }
    // Update the target of all retained fragments.
    if (nonConfig != null) {
        List<Fragment> nonConfigFragments = nonConfig.getFragments();
        final int count = nonConfigFragments != null ? nonConfigFragments.size() : 0;
        for (int i = 0; i < count; i++) {
            Fragment f = nonConfigFragments.get(i);
            if (f.mTargetIndex >= 0) {
                f.mTarget = mActive.get(f.mTargetIndex);
                if (f.mTarget == null) {
                    Log.w(TAG, ""Re-attaching retained fragment "" + f + "" target no longer exists: "" + f.mTargetIndex);
                    f.mTarget = null;
                }
            }
        }
    }
    // Build the list of currently added fragments.
    if (fms.mAdded != null) {
        mAdded = new ArrayList<Fragment>(fms.mAdded.length);
        for (int i = 0; i < fms.mAdded.length; i++) {
            Fragment f = mActive.get(fms.mAdded[i]);
            if (f == null) {
                throwException(new IllegalStateException(""No instantiated fragment for index #"" + fms.mAdded[i]));
            }
            f.mAdded = true;
            if (DEBUG)
                Log.v(TAG, ""restoreAllState: added #"" + i + "": "" + f);
            if (mAdded.contains(f)) {
                throw new IllegalStateException(""Already added!"");
            }
            synchronized (mAdded) {
                mAdded.add(f);
            }
        }
    } else {
        mAdded = null;
    }
    // Build the back stack.
    if (fms.mBackStack != null) {
        mBackStack = new ArrayList<BackStackRecord>(fms.mBackStack.length);
        for (int i = 0; i < fms.mBackStack.length; i++) {
            BackStackRecord bse = fms.mBackStack[i].instantiate(this);
            if (DEBUG) {
                Log.v(TAG, ""restoreAllState: back stack #"" + i + "" (index "" + bse.mIndex + ""): "" + bse);
                LogWriter logw = new LogWriter(Log.VERBOSE, TAG);
                PrintWriter pw = new FastPrintWriter(logw, false, 1024);
                bse.dump(""  "", pw, false);
                pw.flush();
            }
            mBackStack.add(bse);
            if (bse.mIndex >= 0) {
                setBackStackIndex(bse.mIndex, bse);
            }
        }
    } else {
        mBackStack = null;
    }
    if (fms.mPrimaryNavActiveIndex >= 0) {
        mPrimaryNav = mActive.get(fms.mPrimaryNavActiveIndex);
    }
    mNextFragmentIndex = fms.mNextFragmentIndex;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
969,<android.app.ActivityThread.NewIntentData: String toString()>,25,26,<android.app.ActivityThread.NewIntentData: String toString()>,<android.app.ActivityThread.NewIntentData: String toString()>,0,"{
    return ""NewIntentData{intents="" + intents + "" token="" + token + ""}"";
}","{
    return ""NewIntentData{intents="" + intents + "" token="" + token + "" andPause="" + andPause + ""}"";
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change consists of appending "" andPause="" + andPause to the existing return string, which qualifies as an 'Other statement changed' scenario, so the change type is 4.","The modification made to the toString() method will not result in a compatibility issue since the method's purpose is to represent the NewIntentData object as a string, typically used for debugging or logging. Adding additional data to this representation does not affect the API's logical function or control flow, and therefore no CI (Compatibility Issue) arises from this change."
970,<android.view.accessibility.AccessibilityWindowInfo: AccessibilityNodeInfo getAnchor()>,25,26,<android.view.accessibility.AccessibilityWindowInfo: AccessibilityNodeInfo getAnchor()>,<android.view.accessibility.AccessibilityWindowInfo: AccessibilityNodeInfo getAnchor()>,0,"{
    if ((mConnectionId == UNDEFINED) || (mAnchorId == UNDEFINED) || (mParentId == UNDEFINED)) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mParentId, mAnchorId, true, 0);
}","{
    if ((mConnectionId == UNDEFINED_WINDOW_ID) || (mAnchorId == UNDEFINED_WINDOW_ID) || (mParentId == UNDEFINED_WINDOW_ID)) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mParentId, mAnchorId, true, 0, null);
}",1,"/**
 * Gets the node that anchors this window to another.
 *
 * @return The anchor node, or {@code null} if none exists.
 */
","/**
 * Gets the node that anchors this window to another.
 *
 * @return The anchor node, or {@code null} if none exists.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",1,"There are changes in the condition of the 'if' statement, where the constants used for comparison have been renamed, which is a control dependency change (type 3). Additionally, the method findAccessibilityNodeInfoByAccessibilityId has an extra parameter in the late version, which is a dependent API change (type 5). Arguments in the method call have been changed, which is classified as other statement change (type 4).","The change in conditions may potentially alter the flow of execution such that the return value could be affected (CI type 1), since the criteria for returning 'null' have been modified. Moreover, the addition of a new parameter to the method call of findAccessibilityNodeInfoByAccessibilityId() indicates the behavior of this method could have changed, also leading to a potential CI by returning a different value (CI type 1)."
971,"<android.hardware.display.DisplayManager: VirtualDisplay createVirtualDisplay(String,int,int,int,Surface,int,Callback,Handler)>",25,26,"<android.hardware.display.DisplayManager: VirtualDisplay createVirtualDisplay(String,int,int,int,Surface,int,Callback,Handler)>","<android.hardware.display.DisplayManager: VirtualDisplay createVirtualDisplay(String,int,int,int,Surface,int,Callback,Handler)>",0,"{
    return createVirtualDisplay(null, name, width, height, densityDpi, surface, flags, callback, handler);
}","{
    return createVirtualDisplay(null, /* projection */
    name, width, height, densityDpi, surface, flags, callback, handler, null);
}",1,"/**
 * Creates a virtual display.
 * <p>
 * The content of a virtual display is rendered to a {@link Surface} provided
 * by the application.
 * </p><p>
 * The virtual display should be {@link VirtualDisplay#release released}
 * when no longer needed.  Because a virtual display renders to a surface
 * provided by the application, it will be released automatically when the
 * process terminates and all remaining windows on it will be forcibly removed.
 * </p><p>
 * The behavior of the virtual display depends on the flags that are provided
 * to this method.  By default, virtual displays are created to be private,
 * non-presentation and unsecure.  Permissions may be required to use certain flags.
 * </p><p>
 * As of {@link android.os.Build.VERSION_CODES#KITKAT_WATCH}, the surface may
 * be attached or detached dynamically using {@link VirtualDisplay#setSurface}.
 * Previously, the surface had to be non-null when {@link #createVirtualDisplay}
 * was called and could not be changed for the lifetime of the display.
 * </p><p>
 * Detaching the surface that backs a virtual display has a similar effect to
 * turning off the screen.
 * </p>
 *
 * @param name The name of the virtual display, must be non-empty.
 * @param width The width of the virtual display in pixels, must be greater than 0.
 * @param height The height of the virtual display in pixels, must be greater than 0.
 * @param densityDpi The density of the virtual display in dpi, must be greater than 0.
 * @param surface The surface to which the content of the virtual display should
 * be rendered, or null if there is none initially.
 * @param flags A combination of virtual display flags:
 * {@link #VIRTUAL_DISPLAY_FLAG_PUBLIC}, {@link #VIRTUAL_DISPLAY_FLAG_PRESENTATION},
 * {@link #VIRTUAL_DISPLAY_FLAG_SECURE}, {@link #VIRTUAL_DISPLAY_FLAG_OWN_CONTENT_ONLY},
 * or {@link #VIRTUAL_DISPLAY_FLAG_AUTO_MIRROR}.
 * @param callback Callback to call when the state of the {@link VirtualDisplay} changes
 * @param handler The handler on which the listener should be invoked, or null
 * if the listener should be invoked on the calling thread's looper.
 * @return The newly created virtual display, or null if the application could
 * not create the virtual display.
 *
 * @throws SecurityException if the caller does not have permission to create
 * a virtual display with the specified flags.
 */
","/**
 * Creates a virtual display.
 * <p>
 * The content of a virtual display is rendered to a {@link Surface} provided
 * by the application.
 * </p><p>
 * The virtual display should be {@link VirtualDisplay#release released}
 * when no longer needed.  Because a virtual display renders to a surface
 * provided by the application, it will be released automatically when the
 * process terminates and all remaining windows on it will be forcibly removed.
 * </p><p>
 * The behavior of the virtual display depends on the flags that are provided
 * to this method.  By default, virtual displays are created to be private,
 * non-presentation and unsecure.  Permissions may be required to use certain flags.
 * </p><p>
 * As of {@link android.os.Build.VERSION_CODES#KITKAT_WATCH}, the surface may
 * be attached or detached dynamically using {@link VirtualDisplay#setSurface}.
 * Previously, the surface had to be non-null when {@link #createVirtualDisplay}
 * was called and could not be changed for the lifetime of the display.
 * </p><p>
 * Detaching the surface that backs a virtual display has a similar effect to
 * turning off the screen.
 * </p>
 *
 * @param name The name of the virtual display, must be non-empty.
 * @param width The width of the virtual display in pixels, must be greater than 0.
 * @param height The height of the virtual display in pixels, must be greater than 0.
 * @param densityDpi The density of the virtual display in dpi, must be greater than 0.
 * @param surface The surface to which the content of the virtual display should
 * be rendered, or null if there is none initially.
 * @param flags A combination of virtual display flags:
 * {@link #VIRTUAL_DISPLAY_FLAG_PUBLIC}, {@link #VIRTUAL_DISPLAY_FLAG_PRESENTATION},
 * {@link #VIRTUAL_DISPLAY_FLAG_SECURE}, {@link #VIRTUAL_DISPLAY_FLAG_OWN_CONTENT_ONLY},
 * or {@link #VIRTUAL_DISPLAY_FLAG_AUTO_MIRROR}.
 * @param callback Callback to call when the state of the {@link VirtualDisplay} changes
 * @param handler The handler on which the listener should be invoked, or null
 * if the listener should be invoked on the calling thread's looper.
 * @return The newly created virtual display, or null if the application could
 * not create the virtual display.
 *
 * @throws SecurityException if the caller does not have permission to create
 * a virtual display with the specified flags.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The only change is an addition of a null parameter in the call to createVirtualDisplay() within the method, which reflects a change in the dependent API that this method is calling. This is a signature change in the dependent API without modifying any control flow or exception handling, so the code change type is 5.","Since the addition of the null parameter doesn't affect the control flow or the types and values returned by the method, nor the exception handling, there should be no Compatibility Issue. The null is just another value passed to an overloaded method and would not cause the API to behave differently on its own."
972,<android.net.nsd.NsdManager.ServiceHandler: void handleMessage(Message)>,25,26,<android.net.nsd.NsdManager.ServiceHandler: void handleMessage(Message)>,<android.net.nsd.NsdManager.ServiceHandler: void handleMessage(Message)>,0,"{
    switch(message.what) {
        case AsyncChannel.CMD_CHANNEL_HALF_CONNECTED:
            mAsyncChannel.sendMessage(AsyncChannel.CMD_CHANNEL_FULL_CONNECTION);
            return;
        case AsyncChannel.CMD_CHANNEL_FULLY_CONNECTED:
            mConnected.countDown();
            return;
        case AsyncChannel.CMD_CHANNEL_DISCONNECTED:
            Log.e(TAG, ""Channel lost"");
            return;
        default:
            break;
    }
    Object listener = getListener(message.arg2);
    if (listener == null) {
        Log.d(TAG, ""Stale key "" + message.arg2);
        return;
    }
    NsdServiceInfo ns = getNsdService(message.arg2);
    switch(message.what) {
        case DISCOVER_SERVICES_STARTED:
            String s = getNsdServiceInfoType((NsdServiceInfo) message.obj);
            ((DiscoveryListener) listener).onDiscoveryStarted(s);
            break;
        case DISCOVER_SERVICES_FAILED:
            removeListener(message.arg2);
            ((DiscoveryListener) listener).onStartDiscoveryFailed(getNsdServiceInfoType(ns), message.arg1);
            break;
        case SERVICE_FOUND:
            ((DiscoveryListener) listener).onServiceFound((NsdServiceInfo) message.obj);
            break;
        case SERVICE_LOST:
            ((DiscoveryListener) listener).onServiceLost((NsdServiceInfo) message.obj);
            break;
        case STOP_DISCOVERY_FAILED:
            removeListener(message.arg2);
            ((DiscoveryListener) listener).onStopDiscoveryFailed(getNsdServiceInfoType(ns), message.arg1);
            break;
        case STOP_DISCOVERY_SUCCEEDED:
            removeListener(message.arg2);
            ((DiscoveryListener) listener).onDiscoveryStopped(getNsdServiceInfoType(ns));
            break;
        case REGISTER_SERVICE_FAILED:
            removeListener(message.arg2);
            ((RegistrationListener) listener).onRegistrationFailed(ns, message.arg1);
            break;
        case REGISTER_SERVICE_SUCCEEDED:
            ((RegistrationListener) listener).onServiceRegistered((NsdServiceInfo) message.obj);
            break;
        case UNREGISTER_SERVICE_FAILED:
            removeListener(message.arg2);
            ((RegistrationListener) listener).onUnregistrationFailed(ns, message.arg1);
            break;
        case UNREGISTER_SERVICE_SUCCEEDED:
            removeListener(message.arg2);
            ((RegistrationListener) listener).onServiceUnregistered(ns);
            break;
        case RESOLVE_SERVICE_FAILED:
            removeListener(message.arg2);
            ((ResolveListener) listener).onResolveFailed(ns, message.arg1);
            break;
        case RESOLVE_SERVICE_SUCCEEDED:
            removeListener(message.arg2);
            ((ResolveListener) listener).onServiceResolved((NsdServiceInfo) message.obj);
            break;
        default:
            Log.d(TAG, ""Ignored "" + message);
            break;
    }
}","{
    if (DBG)
        Log.d(TAG, ""received "" + nameOf(message.what));
    switch(message.what) {
        case AsyncChannel.CMD_CHANNEL_HALF_CONNECTED:
            mAsyncChannel.sendMessage(AsyncChannel.CMD_CHANNEL_FULL_CONNECTION);
            return;
        case AsyncChannel.CMD_CHANNEL_FULLY_CONNECTED:
            mConnected.countDown();
            return;
        case AsyncChannel.CMD_CHANNEL_DISCONNECTED:
            Log.e(TAG, ""Channel lost"");
            return;
        default:
            break;
    }
    Object listener = getListener(message.arg2);
    if (listener == null) {
        Log.d(TAG, ""Stale key "" + message.arg2);
        return;
    }
    NsdServiceInfo ns = getNsdService(message.arg2);
    switch(message.what) {
        case DISCOVER_SERVICES_STARTED:
            String s = getNsdServiceInfoType((NsdServiceInfo) message.obj);
            ((DiscoveryListener) listener).onDiscoveryStarted(s);
            break;
        case DISCOVER_SERVICES_FAILED:
            removeListener(message.arg2);
            ((DiscoveryListener) listener).onStartDiscoveryFailed(getNsdServiceInfoType(ns), message.arg1);
            break;
        case SERVICE_FOUND:
            ((DiscoveryListener) listener).onServiceFound((NsdServiceInfo) message.obj);
            break;
        case SERVICE_LOST:
            ((DiscoveryListener) listener).onServiceLost((NsdServiceInfo) message.obj);
            break;
        case STOP_DISCOVERY_FAILED:
            removeListener(message.arg2);
            ((DiscoveryListener) listener).onStopDiscoveryFailed(getNsdServiceInfoType(ns), message.arg1);
            break;
        case STOP_DISCOVERY_SUCCEEDED:
            removeListener(message.arg2);
            ((DiscoveryListener) listener).onDiscoveryStopped(getNsdServiceInfoType(ns));
            break;
        case REGISTER_SERVICE_FAILED:
            removeListener(message.arg2);
            ((RegistrationListener) listener).onRegistrationFailed(ns, message.arg1);
            break;
        case REGISTER_SERVICE_SUCCEEDED:
            ((RegistrationListener) listener).onServiceRegistered((NsdServiceInfo) message.obj);
            break;
        case UNREGISTER_SERVICE_FAILED:
            removeListener(message.arg2);
            ((RegistrationListener) listener).onUnregistrationFailed(ns, message.arg1);
            break;
        case UNREGISTER_SERVICE_SUCCEEDED:
            removeListener(message.arg2);
            ((RegistrationListener) listener).onServiceUnregistered(ns);
            break;
        case RESOLVE_SERVICE_FAILED:
            removeListener(message.arg2);
            ((ResolveListener) listener).onResolveFailed(ns, message.arg1);
            break;
        case RESOLVE_SERVICE_SUCCEEDED:
            removeListener(message.arg2);
            ((ResolveListener) listener).onServiceResolved((NsdServiceInfo) message.obj);
            break;
        default:
            Log.d(TAG, ""Ignored "" + message);
            break;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
973,<android.app.RemoteInput.Builder: RemoteInput build()>,25,26,<android.app.RemoteInput.Builder: RemoteInput build()>,<android.app.RemoteInput.Builder: RemoteInput build()>,0,"{
    return new RemoteInput(mResultKey, mLabel, mChoices, mFlags, mExtras);
}","{
    return new RemoteInput(mResultKey, mLabel, mChoices, mFlags, mExtras, mAllowedDataTypes);
}",1,"/**
 * Combine all of the options that have been set and return a new {@link RemoteInput}
 * object.
 */
","/**
 * Combine all of the options that have been set and return a new {@link RemoteInput}
 * object.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"An additional parameter, mAllowedDataTypes, has been added to the constructor call of RemoteInput in the return statement. Since the constructor signature has changed to include an extra parameter, this is categorized as a change in a dependent API and a return statement change, therefore the code change type is 1,5.","The added parameter to the constructor call of RemoteInput indicates that the returned object's state may be altered, which potentially leads to a different return value. Hence, the CI type is 1."
975,<android.widget.CompoundButton: void setChecked(boolean)>,25,26,<android.widget.CompoundButton: void setChecked(boolean)>,<android.widget.CompoundButton: void setChecked(boolean)>,0,"{
    if (mChecked != checked) {
        mChecked = checked;
        refreshDrawableState();
        notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_UNDEFINED);
        // Avoid infinite recursions if setChecked() is called from a listener
        if (mBroadcasting) {
            return;
        }
        mBroadcasting = true;
        if (mOnCheckedChangeListener != null) {
            mOnCheckedChangeListener.onCheckedChanged(this, mChecked);
        }
        if (mOnCheckedChangeWidgetListener != null) {
            mOnCheckedChangeWidgetListener.onCheckedChanged(this, mChecked);
        }
        mBroadcasting = false;
    }
}","{
    if (mChecked != checked) {
        mCheckedFromResource = false;
        mChecked = checked;
        refreshDrawableState();
        notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_UNDEFINED);
        // Avoid infinite recursions if setChecked() is called from a listener
        if (mBroadcasting) {
            return;
        }
        mBroadcasting = true;
        if (mOnCheckedChangeListener != null) {
            mOnCheckedChangeListener.onCheckedChanged(this, mChecked);
        }
        if (mOnCheckedChangeWidgetListener != null) {
            mOnCheckedChangeWidgetListener.onCheckedChanged(this, mChecked);
        }
        final AutofillManager afm = mContext.getSystemService(AutofillManager.class);
        if (afm != null) {
            afm.notifyValueChanged(this);
        }
        mBroadcasting = false;
    }
}",1,"/**
 * <p>Changes the checked state of this button.</p>
 *
 * @param checked true to check the button, false to uncheck it
 */
","/**
 * <p>Changes the checked state of this button.</p>
 *
 * @param checked true to check the button, false to uncheck it
 */
",-1,,[@Override],-1,-1,-1,-1,-1,-1,4,0,"There is the addition of a new variable assignment (`mCheckedFromResource = false;`) and a new interaction with `AutofillManager` (`afm.notifyValueChanged(this);`) in the late version. Thus, the change type is 4.","The added variable assignment and the call to `AutofillManager` do not affect the method's return type or value (since the method is void), nor do they affect exception handling. Therefore, there is no Compatibility Issue, and CI type is 0."
976,<android.hardware.usb.UsbManager: UsbDeviceConnection openDevice(UsbDevice)>,25,26,<android.hardware.usb.UsbManager: UsbDeviceConnection openDevice(UsbDevice)>,<android.hardware.usb.UsbManager: UsbDeviceConnection openDevice(UsbDevice)>,0,"{
    try {
        String deviceName = device.getDeviceName();
        ParcelFileDescriptor pfd = mService.openDevice(deviceName);
        if (pfd != null) {
            UsbDeviceConnection connection = new UsbDeviceConnection(device);
            boolean result = connection.open(deviceName, pfd);
            pfd.close();
            if (result) {
                return connection;
            }
        }
    } catch (Exception e) {
        Log.e(TAG, ""exception in UsbManager.openDevice"", e);
    }
    return null;
}","{
    try {
        String deviceName = device.getDeviceName();
        ParcelFileDescriptor pfd = mService.openDevice(deviceName);
        if (pfd != null) {
            UsbDeviceConnection connection = new UsbDeviceConnection(device);
            boolean result = connection.open(deviceName, pfd, mContext);
            pfd.close();
            if (result) {
                return connection;
            }
        }
    } catch (Exception e) {
        Log.e(TAG, ""exception in UsbManager.openDevice"", e);
    }
    return null;
}",1,"/**
 * Opens the device so it can be used to send and receive
 * data using {@link android.hardware.usb.UsbRequest}.
 *
 * @param device the device to open
 * @return a {@link UsbDeviceConnection}, or {@code null} if open failed
 */
","/**
 * Opens the device so it can be used to send and receive
 * data using {@link android.hardware.usb.UsbRequest}.
 *
 * @param device the device to open
 * @return a {@link UsbDeviceConnection}, or {@code null} if open failed
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The method connection.open in the implementation has changed to include an additional parameter, mContext, thus the method call has changed, which means the type of change is 4,5 (Other statement changed and Dependent API changed).","The dependent API connection.open has been changed to accept an additional argument. This could potentially change the behavior of how the UsbDeviceConnection instance is opened because the context in which it is being opened is now being taken into account. Therefore, this could lead to Compatibility Issue of type 1, potentially returning different values due to the change in how the UsbDeviceConnection is opened."
978,<android.hardware.camera2.marshal.impl.MarshalQueryableString.MarshalerString: int calculateMarshalSize(String)>,25,26,<android.hardware.camera2.marshal.impl.MarshalQueryableString.MarshalerString: int calculateMarshalSize(String)>,<android.hardware.camera2.marshal.impl.MarshalQueryableString.MarshalerString: int calculateMarshalSize(String)>,0,"{
    byte[] arr = value.getBytes(UTF8_CHARSET);
    // metadata strings are NUL-terminated
    return arr.length + 1;
}","{
    byte[] arr = value.getBytes(PreloadHolder.UTF8_CHARSET);
    // metadata strings are NUL-terminated
    return arr.length + 1;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The only change is in the way UTF8_CHARSET constant is accessed; it has been changed from directly accessing UTF8_CHARSET to accessing through PreloadHolder.UTF8_CHARSET. This change type is 5, as it involves access to a constant value that might be defined in a different way.","Despite the modification in the way UTF8_CHARSET is accessed, it should not affect the behavior of the API, provided that the UTF8_CHARSET constant remains the same. The API's method contract and the return value have not been altered; therefore, there's no Compatibility Issue caused by different return values or exceptions."
980,"<android.content.res.Resources: Drawable getDrawable(int,Theme)>",25,26,"<android.content.res.Resources: Drawable getDrawable(int,Theme)>","<android.content.res.Resources: Drawable getDrawable(int,Theme)>",0,"{
    final TypedValue value = obtainTempTypedValue();
    try {
        final ResourcesImpl impl = mResourcesImpl;
        impl.getValue(id, value, true);
        return impl.loadDrawable(this, value, id, theme, true);
    } finally {
        releaseTempTypedValue(value);
    }
}","{
    return getDrawableForDensity(id, 0, theme);
}",1,"/**
 * Return a drawable object associated with a particular resource ID and
 * styled for the specified theme. Various types of objects will be
 * returned depending on the underlying resource -- for example, a solid
 * color, PNG image, scalable image, etc.
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 * @param theme The theme used to style the drawable attributes, may be {@code null}.
 * @return Drawable An object that can be used to draw this resource.
 * @throws NotFoundException Throws NotFoundException if the given ID does
 * not exist.
 */
","/**
 * Return a drawable object associated with a particular resource ID and
 * styled for the specified theme. Various types of objects will be
 * returned depending on the underlying resource -- for example, a solid
 * color, PNG image, scalable image, etc.
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 * @param theme The theme used to style the drawable attributes, may be {@code null}.
 * @return Drawable An object that can be used to draw this resource.
 * @throws NotFoundException Throws NotFoundException if the given ID does
 * not exist.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation of the method has completely changed from using multiple statements to directly returning a value from getDrawableForDensity(id, 0, theme). Also, the dependent API getDrawableForDensity() is now being used instead of the previous internal code, so the change type is 1,5.","Since the late version of the method delegates the work to another method, the behavior may change due to different processing within getDrawableForDensity() as compared to the original code block, thus potentially causing different return values. Therefore, the CI type is 1."
985,"<android.widget.LinearLayout: void measureVertical(int,int)>",25,26,"<android.widget.LinearLayout: void measureVertical(int,int)>","<android.widget.LinearLayout: void measureVertical(int,int)>",0,"{
    mTotalLength = 0;
    int maxWidth = 0;
    int childState = 0;
    int alternativeMaxWidth = 0;
    int weightedMaxWidth = 0;
    boolean allFillParent = true;
    float totalWeight = 0;
    final int count = getVirtualChildCount();
    final int widthMode = MeasureSpec.getMode(widthMeasureSpec);
    final int heightMode = MeasureSpec.getMode(heightMeasureSpec);
    boolean matchWidth = false;
    boolean skippedMeasure = false;
    final int baselineChildIndex = mBaselineAlignedChildIndex;
    final boolean useLargestChild = mUseLargestChild;
    int largestChildHeight = Integer.MIN_VALUE;
    int consumedExcessSpace = 0;
    // See how tall everyone is. Also remember max width.
    for (int i = 0; i < count; ++i) {
        final View child = getVirtualChildAt(i);
        if (child == null) {
            mTotalLength += measureNullChild(i);
            continue;
        }
        if (child.getVisibility() == View.GONE) {
            i += getChildrenSkipCount(child, i);
            continue;
        }
        if (hasDividerBeforeChildAt(i)) {
            mTotalLength += mDividerHeight;
        }
        final LayoutParams lp = (LayoutParams) child.getLayoutParams();
        totalWeight += lp.weight;
        final boolean useExcessSpace = lp.height == 0 && lp.weight > 0;
        if (heightMode == MeasureSpec.EXACTLY && useExcessSpace) {
            // Optimization: don't bother measuring children who are only
            // laid out using excess space. These views will get measured
            // later if we have space to distribute.
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);
            skippedMeasure = true;
        } else {
            if (useExcessSpace) {
                // The heightMode is either UNSPECIFIED or AT_MOST, and
                // this child is only laid out using excess space. Measure
                // using WRAP_CONTENT so that we can find out the view's
                // optimal height. We'll restore the original height of 0
                // after measurement.
                lp.height = LayoutParams.WRAP_CONTENT;
            }
            // Determine how big this child would like to be. If this or
            // previous children have given a weight, then we allow it to
            // use all available space (and we will shrink things later
            // if needed).
            final int usedHeight = totalWeight == 0 ? mTotalLength : 0;
            measureChildBeforeLayout(child, i, widthMeasureSpec, 0, heightMeasureSpec, usedHeight);
            final int childHeight = child.getMeasuredHeight();
            if (useExcessSpace) {
                // Restore the original height and record how much space
                // we've allocated to excess-only children so that we can
                // match the behavior of EXACTLY measurement.
                lp.height = 0;
                consumedExcessSpace += childHeight;
            }
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
            if (useLargestChild) {
                largestChildHeight = Math.max(childHeight, largestChildHeight);
            }
        }
        /**
         * If applicable, compute the additional offset to the child's baseline
         * we'll need later when asked {@link #getBaseline}.
         */
        if ((baselineChildIndex >= 0) && (baselineChildIndex == i + 1)) {
            mBaselineChildTop = mTotalLength;
        }
        // weight.  fail fast to aid the developer.
        if (i < baselineChildIndex && lp.weight > 0) {
            throw new RuntimeException(""A child of LinearLayout with index "" + ""less than mBaselineAlignedChildIndex has weight > 0, which "" + ""won't work.  Either remove the weight, or don't set "" + ""mBaselineAlignedChildIndex."");
        }
        boolean matchWidthLocally = false;
        if (widthMode != MeasureSpec.EXACTLY && lp.width == LayoutParams.MATCH_PARENT) {
            // The width of the linear layout will scale, and at least one
            // child said it wanted to match our width. Set a flag
            // indicating that we need to remeasure at least that view when
            // we know our width.
            matchWidth = true;
            matchWidthLocally = true;
        }
        final int margin = lp.leftMargin + lp.rightMargin;
        final int measuredWidth = child.getMeasuredWidth() + margin;
        maxWidth = Math.max(maxWidth, measuredWidth);
        childState = combineMeasuredStates(childState, child.getMeasuredState());
        allFillParent = allFillParent && lp.width == LayoutParams.MATCH_PARENT;
        if (lp.weight > 0) {
            /*
                 * Widths of weighted Views are bogus if we end up
                 * remeasuring, so keep them separate.
                 */
            weightedMaxWidth = Math.max(weightedMaxWidth, matchWidthLocally ? margin : measuredWidth);
        } else {
            alternativeMaxWidth = Math.max(alternativeMaxWidth, matchWidthLocally ? margin : measuredWidth);
        }
        i += getChildrenSkipCount(child, i);
    }
    if (mTotalLength > 0 && hasDividerBeforeChildAt(count)) {
        mTotalLength += mDividerHeight;
    }
    if (useLargestChild && (heightMode == MeasureSpec.AT_MOST || heightMode == MeasureSpec.UNSPECIFIED)) {
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child == null) {
                mTotalLength += measureNullChild(i);
                continue;
            }
            if (child.getVisibility() == GONE) {
                i += getChildrenSkipCount(child, i);
                continue;
            }
            final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
            // Account for negative margins
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + largestChildHeight + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
        }
    }
    // Add in our padding
    mTotalLength += mPaddingTop + mPaddingBottom;
    int heightSize = mTotalLength;
    // Check against our minimum height
    heightSize = Math.max(heightSize, getSuggestedMinimumHeight());
    // Reconcile our calculated size with the heightMeasureSpec
    int heightSizeAndState = resolveSizeAndState(heightSize, heightMeasureSpec, 0);
    heightSize = heightSizeAndState & MEASURED_SIZE_MASK;
    // Either expand children with weight to take up available space or
    // shrink them if they extend beyond our current bounds. If we skipped
    // measurement on any children, we need to measure them now.
    int remainingExcess = heightSize - mTotalLength + (mAllowInconsistentMeasurement ? 0 : consumedExcessSpace);
    if (skippedMeasure || remainingExcess != 0 && totalWeight > 0.0f) {
        float remainingWeightSum = mWeightSum > 0.0f ? mWeightSum : totalWeight;
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child == null || child.getVisibility() == View.GONE) {
                continue;
            }
            final LayoutParams lp = (LayoutParams) child.getLayoutParams();
            final float childWeight = lp.weight;
            if (childWeight > 0) {
                final int share = (int) (childWeight * remainingExcess / remainingWeightSum);
                remainingExcess -= share;
                remainingWeightSum -= childWeight;
                final int childHeight;
                if (mUseLargestChild && heightMode != MeasureSpec.EXACTLY) {
                    childHeight = largestChildHeight;
                } else if (lp.height == 0 && (!mAllowInconsistentMeasurement || heightMode == MeasureSpec.EXACTLY)) {
                    // This child needs to be laid out from scratch using
                    // only its share of excess space.
                    childHeight = share;
                } else {
                    // This child had some intrinsic height to which we
                    // need to add its share of excess space.
                    childHeight = child.getMeasuredHeight() + share;
                }
                final int childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(Math.max(0, childHeight), MeasureSpec.EXACTLY);
                final int childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin, lp.width);
                child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
                // Child may now not fit in vertical dimension.
                childState = combineMeasuredStates(childState, child.getMeasuredState() & (MEASURED_STATE_MASK >> MEASURED_HEIGHT_STATE_SHIFT));
            }
            final int margin = lp.leftMargin + lp.rightMargin;
            final int measuredWidth = child.getMeasuredWidth() + margin;
            maxWidth = Math.max(maxWidth, measuredWidth);
            boolean matchWidthLocally = widthMode != MeasureSpec.EXACTLY && lp.width == LayoutParams.MATCH_PARENT;
            alternativeMaxWidth = Math.max(alternativeMaxWidth, matchWidthLocally ? margin : measuredWidth);
            allFillParent = allFillParent && lp.width == LayoutParams.MATCH_PARENT;
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
        }
        // Add in our padding
        mTotalLength += mPaddingTop + mPaddingBottom;
    // TODO: Should we recompute the heightSpec based on the new total length?
    } else {
        alternativeMaxWidth = Math.max(alternativeMaxWidth, weightedMaxWidth);
        // Children will have already been measured once.
        if (useLargestChild && heightMode != MeasureSpec.EXACTLY) {
            for (int i = 0; i < count; i++) {
                final View child = getVirtualChildAt(i);
                if (child == null || child.getVisibility() == View.GONE) {
                    continue;
                }
                final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
                float childExtra = lp.weight;
                if (childExtra > 0) {
                    child.measure(MeasureSpec.makeMeasureSpec(child.getMeasuredWidth(), MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(largestChildHeight, MeasureSpec.EXACTLY));
                }
            }
        }
    }
    if (!allFillParent && widthMode != MeasureSpec.EXACTLY) {
        maxWidth = alternativeMaxWidth;
    }
    maxWidth += mPaddingLeft + mPaddingRight;
    // Check against our minimum width
    maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());
    setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState), heightSizeAndState);
    if (matchWidth) {
        forceUniformWidth(count, heightMeasureSpec);
    }
}","{
    mTotalLength = 0;
    int maxWidth = 0;
    int childState = 0;
    int alternativeMaxWidth = 0;
    int weightedMaxWidth = 0;
    boolean allFillParent = true;
    float totalWeight = 0;
    final int count = getVirtualChildCount();
    final int widthMode = MeasureSpec.getMode(widthMeasureSpec);
    final int heightMode = MeasureSpec.getMode(heightMeasureSpec);
    boolean matchWidth = false;
    boolean skippedMeasure = false;
    final int baselineChildIndex = mBaselineAlignedChildIndex;
    final boolean useLargestChild = mUseLargestChild;
    int largestChildHeight = Integer.MIN_VALUE;
    int consumedExcessSpace = 0;
    int nonSkippedChildCount = 0;
    // See how tall everyone is. Also remember max width.
    for (int i = 0; i < count; ++i) {
        final View child = getVirtualChildAt(i);
        if (child == null) {
            mTotalLength += measureNullChild(i);
            continue;
        }
        if (child.getVisibility() == View.GONE) {
            i += getChildrenSkipCount(child, i);
            continue;
        }
        nonSkippedChildCount++;
        if (hasDividerBeforeChildAt(i)) {
            mTotalLength += mDividerHeight;
        }
        final LayoutParams lp = (LayoutParams) child.getLayoutParams();
        totalWeight += lp.weight;
        final boolean useExcessSpace = lp.height == 0 && lp.weight > 0;
        if (heightMode == MeasureSpec.EXACTLY && useExcessSpace) {
            // Optimization: don't bother measuring children who are only
            // laid out using excess space. These views will get measured
            // later if we have space to distribute.
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);
            skippedMeasure = true;
        } else {
            if (useExcessSpace) {
                // The heightMode is either UNSPECIFIED or AT_MOST, and
                // this child is only laid out using excess space. Measure
                // using WRAP_CONTENT so that we can find out the view's
                // optimal height. We'll restore the original height of 0
                // after measurement.
                lp.height = LayoutParams.WRAP_CONTENT;
            }
            // Determine how big this child would like to be. If this or
            // previous children have given a weight, then we allow it to
            // use all available space (and we will shrink things later
            // if needed).
            final int usedHeight = totalWeight == 0 ? mTotalLength : 0;
            measureChildBeforeLayout(child, i, widthMeasureSpec, 0, heightMeasureSpec, usedHeight);
            final int childHeight = child.getMeasuredHeight();
            if (useExcessSpace) {
                // Restore the original height and record how much space
                // we've allocated to excess-only children so that we can
                // match the behavior of EXACTLY measurement.
                lp.height = 0;
                consumedExcessSpace += childHeight;
            }
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
            if (useLargestChild) {
                largestChildHeight = Math.max(childHeight, largestChildHeight);
            }
        }
        /**
         * If applicable, compute the additional offset to the child's baseline
         * we'll need later when asked {@link #getBaseline}.
         */
        if ((baselineChildIndex >= 0) && (baselineChildIndex == i + 1)) {
            mBaselineChildTop = mTotalLength;
        }
        // weight.  fail fast to aid the developer.
        if (i < baselineChildIndex && lp.weight > 0) {
            throw new RuntimeException(""A child of LinearLayout with index "" + ""less than mBaselineAlignedChildIndex has weight > 0, which "" + ""won't work.  Either remove the weight, or don't set "" + ""mBaselineAlignedChildIndex."");
        }
        boolean matchWidthLocally = false;
        if (widthMode != MeasureSpec.EXACTLY && lp.width == LayoutParams.MATCH_PARENT) {
            // The width of the linear layout will scale, and at least one
            // child said it wanted to match our width. Set a flag
            // indicating that we need to remeasure at least that view when
            // we know our width.
            matchWidth = true;
            matchWidthLocally = true;
        }
        final int margin = lp.leftMargin + lp.rightMargin;
        final int measuredWidth = child.getMeasuredWidth() + margin;
        maxWidth = Math.max(maxWidth, measuredWidth);
        childState = combineMeasuredStates(childState, child.getMeasuredState());
        allFillParent = allFillParent && lp.width == LayoutParams.MATCH_PARENT;
        if (lp.weight > 0) {
            /*
                 * Widths of weighted Views are bogus if we end up
                 * remeasuring, so keep them separate.
                 */
            weightedMaxWidth = Math.max(weightedMaxWidth, matchWidthLocally ? margin : measuredWidth);
        } else {
            alternativeMaxWidth = Math.max(alternativeMaxWidth, matchWidthLocally ? margin : measuredWidth);
        }
        i += getChildrenSkipCount(child, i);
    }
    if (nonSkippedChildCount > 0 && hasDividerBeforeChildAt(count)) {
        mTotalLength += mDividerHeight;
    }
    if (useLargestChild && (heightMode == MeasureSpec.AT_MOST || heightMode == MeasureSpec.UNSPECIFIED)) {
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child == null) {
                mTotalLength += measureNullChild(i);
                continue;
            }
            if (child.getVisibility() == GONE) {
                i += getChildrenSkipCount(child, i);
                continue;
            }
            final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
            // Account for negative margins
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + largestChildHeight + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
        }
    }
    // Add in our padding
    mTotalLength += mPaddingTop + mPaddingBottom;
    int heightSize = mTotalLength;
    // Check against our minimum height
    heightSize = Math.max(heightSize, getSuggestedMinimumHeight());
    // Reconcile our calculated size with the heightMeasureSpec
    int heightSizeAndState = resolveSizeAndState(heightSize, heightMeasureSpec, 0);
    heightSize = heightSizeAndState & MEASURED_SIZE_MASK;
    // Either expand children with weight to take up available space or
    // shrink them if they extend beyond our current bounds. If we skipped
    // measurement on any children, we need to measure them now.
    int remainingExcess = heightSize - mTotalLength + (mAllowInconsistentMeasurement ? 0 : consumedExcessSpace);
    if (skippedMeasure || remainingExcess != 0 && totalWeight > 0.0f) {
        float remainingWeightSum = mWeightSum > 0.0f ? mWeightSum : totalWeight;
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child == null || child.getVisibility() == View.GONE) {
                continue;
            }
            final LayoutParams lp = (LayoutParams) child.getLayoutParams();
            final float childWeight = lp.weight;
            if (childWeight > 0) {
                final int share = (int) (childWeight * remainingExcess / remainingWeightSum);
                remainingExcess -= share;
                remainingWeightSum -= childWeight;
                final int childHeight;
                if (mUseLargestChild && heightMode != MeasureSpec.EXACTLY) {
                    childHeight = largestChildHeight;
                } else if (lp.height == 0 && (!mAllowInconsistentMeasurement || heightMode == MeasureSpec.EXACTLY)) {
                    // This child needs to be laid out from scratch using
                    // only its share of excess space.
                    childHeight = share;
                } else {
                    // This child had some intrinsic height to which we
                    // need to add its share of excess space.
                    childHeight = child.getMeasuredHeight() + share;
                }
                final int childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(Math.max(0, childHeight), MeasureSpec.EXACTLY);
                final int childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin, lp.width);
                child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
                // Child may now not fit in vertical dimension.
                childState = combineMeasuredStates(childState, child.getMeasuredState() & (MEASURED_STATE_MASK >> MEASURED_HEIGHT_STATE_SHIFT));
            }
            final int margin = lp.leftMargin + lp.rightMargin;
            final int measuredWidth = child.getMeasuredWidth() + margin;
            maxWidth = Math.max(maxWidth, measuredWidth);
            boolean matchWidthLocally = widthMode != MeasureSpec.EXACTLY && lp.width == LayoutParams.MATCH_PARENT;
            alternativeMaxWidth = Math.max(alternativeMaxWidth, matchWidthLocally ? margin : measuredWidth);
            allFillParent = allFillParent && lp.width == LayoutParams.MATCH_PARENT;
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
        }
        // Add in our padding
        mTotalLength += mPaddingTop + mPaddingBottom;
    // TODO: Should we recompute the heightSpec based on the new total length?
    } else {
        alternativeMaxWidth = Math.max(alternativeMaxWidth, weightedMaxWidth);
        // Children will have already been measured once.
        if (useLargestChild && heightMode != MeasureSpec.EXACTLY) {
            for (int i = 0; i < count; i++) {
                final View child = getVirtualChildAt(i);
                if (child == null || child.getVisibility() == View.GONE) {
                    continue;
                }
                final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
                float childExtra = lp.weight;
                if (childExtra > 0) {
                    child.measure(MeasureSpec.makeMeasureSpec(child.getMeasuredWidth(), MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(largestChildHeight, MeasureSpec.EXACTLY));
                }
            }
        }
    }
    if (!allFillParent && widthMode != MeasureSpec.EXACTLY) {
        maxWidth = alternativeMaxWidth;
    }
    maxWidth += mPaddingLeft + mPaddingRight;
    // Check against our minimum width
    maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());
    setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState), heightSizeAndState);
    if (matchWidth) {
        forceUniformWidth(count, heightMeasureSpec);
    }
}",1,"/**
 * Measures the children when the orientation of this LinearLayout is set
 * to {@link #VERTICAL}.
 *
 * @param widthMeasureSpec Horizontal space requirements as imposed by the parent.
 * @param heightMeasureSpec Vertical space requirements as imposed by the parent.
 *
 * @see #getOrientation()
 * @see #setOrientation(int)
 * @see #onMeasure(int, int)
 */
","/**
 * Measures the children when the orientation of this LinearLayout is set
 * to {@link #VERTICAL}.
 *
 * @param widthMeasureSpec Horizontal space requirements as imposed by the parent.
 * @param heightMeasureSpec Vertical space requirements as imposed by the parent.
 *
 * @see #getOrientation()
 * @see #setOrientation(int)
 * @see #onMeasure(int, int)
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
986,"<android.app.SharedPreferencesImpl: int getInt(String,int)>",25,26,"<android.app.SharedPreferencesImpl: int getInt(String,int)>","<android.app.SharedPreferencesImpl: int getInt(String,int)>",0,"{
    synchronized (this) {
        awaitLoadedLocked();
        Integer v = (Integer) mMap.get(key);
        return v != null ? v : defValue;
    }
}","{
    synchronized (mLock) {
        awaitLoadedLocked();
        Integer v = (Integer) mMap.get(key);
        return v != null ? v : defValue;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The object on which the synchronized block is locking changed from `this` to `mLock`, which constitutes an ""Other statement changed"" situation, so the code change type is 4.","Although the lock object has changed from `this` to `mLock`, this would not affect the application code invoking `getInt` API because it does not alter the functionality or the return value of the method. The compatibility is strictly preserved in terms of API behavior; therefore, no Compatibility Issue is detected, and the CI type is 0."
987,"<android.app.ContextImpl: SharedPreferences getSharedPreferences(File,int)>",25,26,"<android.app.ContextImpl: SharedPreferences getSharedPreferences(File,int)>","<android.app.ContextImpl: SharedPreferences getSharedPreferences(File,int)>",0,"{
    checkMode(mode);
    SharedPreferencesImpl sp;
    synchronized (ContextImpl.class) {
        final ArrayMap<File, SharedPreferencesImpl> cache = getSharedPreferencesCacheLocked();
        sp = cache.get(file);
        if (sp == null) {
            sp = new SharedPreferencesImpl(file, mode);
            cache.put(file, sp);
            return sp;
        }
    }
    if ((mode & Context.MODE_MULTI_PROCESS) != 0 || getApplicationInfo().targetSdkVersion < android.os.Build.VERSION_CODES.HONEYCOMB) {
        // If somebody else (some other process) changed the prefs
        // file behind our back, we reload it.  This has been the
        // historical (if undocumented) behavior.
        sp.startReloadIfChangedUnexpectedly();
    }
    return sp;
}","{
    checkMode(mode);
    if (getApplicationInfo().targetSdkVersion >= android.os.Build.VERSION_CODES.O) {
        if (isCredentialProtectedStorage() && !getSystemService(StorageManager.class).isUserKeyUnlocked(UserHandle.myUserId()) && !isBuggy()) {
            throw new IllegalStateException(""SharedPreferences in credential encrypted "" + ""storage are not available until after user is unlocked"");
        }
    }
    SharedPreferencesImpl sp;
    synchronized (ContextImpl.class) {
        final ArrayMap<File, SharedPreferencesImpl> cache = getSharedPreferencesCacheLocked();
        sp = cache.get(file);
        if (sp == null) {
            sp = new SharedPreferencesImpl(file, mode);
            cache.put(file, sp);
            return sp;
        }
    }
    if ((mode & Context.MODE_MULTI_PROCESS) != 0 || getApplicationInfo().targetSdkVersion < android.os.Build.VERSION_CODES.HONEYCOMB) {
        // If somebody else (some other process) changed the prefs
        // file behind our back, we reload it.  This has been the
        // historical (if undocumented) behavior.
        sp.startReloadIfChangedUnexpectedly();
    }
    return sp;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,3",2,"The late implementation introduces a new exception handling block that throws a IllegalStateException when certain conditions are met. The control flow has also changed due to the introduction of a new 'if' condition, thus the code change type is 2,3.","An IllegalStateException can now be thrown in a scenario where it would not have been thrown in the early version, and this modification can lead to different exception behavior. Therefore, the CI type is 2."
989,<android.content.res.Configuration: String toString()>,25,26,<android.content.res.Configuration: String toString()>,<android.content.res.Configuration: String toString()>,0,"{
    StringBuilder sb = new StringBuilder(128);
    sb.append(""{"");
    sb.append(fontScale);
    sb.append("" "");
    if (mcc != 0) {
        sb.append(mcc);
        sb.append(""mcc"");
    } else {
        sb.append(""?mcc"");
    }
    if (mnc != 0) {
        sb.append(mnc);
        sb.append(""mnc"");
    } else {
        sb.append(""?mnc"");
    }
    fixUpLocaleList();
    if (!mLocaleList.isEmpty()) {
        sb.append("" "");
        sb.append(mLocaleList);
    } else {
        sb.append("" ?localeList"");
    }
    int layoutDir = (screenLayout & SCREENLAYOUT_LAYOUTDIR_MASK);
    switch(layoutDir) {
        case SCREENLAYOUT_LAYOUTDIR_UNDEFINED:
            sb.append("" ?layoutDir"");
            break;
        case SCREENLAYOUT_LAYOUTDIR_LTR:
            sb.append("" ldltr"");
            break;
        case SCREENLAYOUT_LAYOUTDIR_RTL:
            sb.append("" ldrtl"");
            break;
        default:
            sb.append("" layoutDir="");
            sb.append(layoutDir >> SCREENLAYOUT_LAYOUTDIR_SHIFT);
            break;
    }
    if (smallestScreenWidthDp != SMALLEST_SCREEN_WIDTH_DP_UNDEFINED) {
        sb.append("" sw"");
        sb.append(smallestScreenWidthDp);
        sb.append(""dp"");
    } else {
        sb.append("" ?swdp"");
    }
    if (screenWidthDp != SCREEN_WIDTH_DP_UNDEFINED) {
        sb.append("" w"");
        sb.append(screenWidthDp);
        sb.append(""dp"");
    } else {
        sb.append("" ?wdp"");
    }
    if (screenHeightDp != SCREEN_HEIGHT_DP_UNDEFINED) {
        sb.append("" h"");
        sb.append(screenHeightDp);
        sb.append(""dp"");
    } else {
        sb.append("" ?hdp"");
    }
    if (densityDpi != DENSITY_DPI_UNDEFINED) {
        sb.append("" "");
        sb.append(densityDpi);
        sb.append(""dpi"");
    } else {
        sb.append("" ?density"");
    }
    switch((screenLayout & SCREENLAYOUT_SIZE_MASK)) {
        case SCREENLAYOUT_SIZE_UNDEFINED:
            sb.append("" ?lsize"");
            break;
        case SCREENLAYOUT_SIZE_SMALL:
            sb.append("" smll"");
            break;
        case SCREENLAYOUT_SIZE_NORMAL:
            sb.append("" nrml"");
            break;
        case SCREENLAYOUT_SIZE_LARGE:
            sb.append("" lrg"");
            break;
        case SCREENLAYOUT_SIZE_XLARGE:
            sb.append("" xlrg"");
            break;
        default:
            sb.append("" layoutSize="");
            sb.append(screenLayout & SCREENLAYOUT_SIZE_MASK);
            break;
    }
    switch((screenLayout & SCREENLAYOUT_LONG_MASK)) {
        case SCREENLAYOUT_LONG_UNDEFINED:
            sb.append("" ?long"");
            break;
        case SCREENLAYOUT_LONG_NO:
            /* not-long is not interesting to print */
            break;
        case SCREENLAYOUT_LONG_YES:
            sb.append("" long"");
            break;
        default:
            sb.append("" layoutLong="");
            sb.append(screenLayout & SCREENLAYOUT_LONG_MASK);
            break;
    }
    switch(orientation) {
        case ORIENTATION_UNDEFINED:
            sb.append("" ?orien"");
            break;
        case ORIENTATION_LANDSCAPE:
            sb.append("" land"");
            break;
        case ORIENTATION_PORTRAIT:
            sb.append("" port"");
            break;
        default:
            sb.append("" orien="");
            sb.append(orientation);
            break;
    }
    switch((uiMode & UI_MODE_TYPE_MASK)) {
        case UI_MODE_TYPE_UNDEFINED:
            sb.append("" ?uimode"");
            break;
        case UI_MODE_TYPE_NORMAL:
            /* normal is not interesting to print */
            break;
        case UI_MODE_TYPE_DESK:
            sb.append("" desk"");
            break;
        case UI_MODE_TYPE_CAR:
            sb.append("" car"");
            break;
        case UI_MODE_TYPE_TELEVISION:
            sb.append("" television"");
            break;
        case UI_MODE_TYPE_APPLIANCE:
            sb.append("" appliance"");
            break;
        case UI_MODE_TYPE_WATCH:
            sb.append("" watch"");
            break;
        default:
            sb.append("" uimode="");
            sb.append(uiMode & UI_MODE_TYPE_MASK);
            break;
    }
    switch((uiMode & UI_MODE_NIGHT_MASK)) {
        case UI_MODE_NIGHT_UNDEFINED:
            sb.append("" ?night"");
            break;
        case UI_MODE_NIGHT_NO:
            /* not-night is not interesting to print */
            break;
        case UI_MODE_NIGHT_YES:
            sb.append("" night"");
            break;
        default:
            sb.append("" night="");
            sb.append(uiMode & UI_MODE_NIGHT_MASK);
            break;
    }
    switch(touchscreen) {
        case TOUCHSCREEN_UNDEFINED:
            sb.append("" ?touch"");
            break;
        case TOUCHSCREEN_NOTOUCH:
            sb.append("" -touch"");
            break;
        case TOUCHSCREEN_STYLUS:
            sb.append("" stylus"");
            break;
        case TOUCHSCREEN_FINGER:
            sb.append("" finger"");
            break;
        default:
            sb.append("" touch="");
            sb.append(touchscreen);
            break;
    }
    switch(keyboard) {
        case KEYBOARD_UNDEFINED:
            sb.append("" ?keyb"");
            break;
        case KEYBOARD_NOKEYS:
            sb.append("" -keyb"");
            break;
        case KEYBOARD_QWERTY:
            sb.append("" qwerty"");
            break;
        case KEYBOARD_12KEY:
            sb.append("" 12key"");
            break;
        default:
            sb.append("" keys="");
            sb.append(keyboard);
            break;
    }
    switch(keyboardHidden) {
        case KEYBOARDHIDDEN_UNDEFINED:
            sb.append(""/?"");
            break;
        case KEYBOARDHIDDEN_NO:
            sb.append(""/v"");
            break;
        case KEYBOARDHIDDEN_YES:
            sb.append(""/h"");
            break;
        case KEYBOARDHIDDEN_SOFT:
            sb.append(""/s"");
            break;
        default:
            sb.append(""/"");
            sb.append(keyboardHidden);
            break;
    }
    switch(hardKeyboardHidden) {
        case HARDKEYBOARDHIDDEN_UNDEFINED:
            sb.append(""/?"");
            break;
        case HARDKEYBOARDHIDDEN_NO:
            sb.append(""/v"");
            break;
        case HARDKEYBOARDHIDDEN_YES:
            sb.append(""/h"");
            break;
        default:
            sb.append(""/"");
            sb.append(hardKeyboardHidden);
            break;
    }
    switch(navigation) {
        case NAVIGATION_UNDEFINED:
            sb.append("" ?nav"");
            break;
        case NAVIGATION_NONAV:
            sb.append("" -nav"");
            break;
        case NAVIGATION_DPAD:
            sb.append("" dpad"");
            break;
        case NAVIGATION_TRACKBALL:
            sb.append("" tball"");
            break;
        case NAVIGATION_WHEEL:
            sb.append("" wheel"");
            break;
        default:
            sb.append("" nav="");
            sb.append(navigation);
            break;
    }
    switch(navigationHidden) {
        case NAVIGATIONHIDDEN_UNDEFINED:
            sb.append(""/?"");
            break;
        case NAVIGATIONHIDDEN_NO:
            sb.append(""/v"");
            break;
        case NAVIGATIONHIDDEN_YES:
            sb.append(""/h"");
            break;
        default:
            sb.append(""/"");
            sb.append(navigationHidden);
            break;
    }
    if (seq != 0) {
        sb.append("" s."");
        sb.append(seq);
    }
    sb.append('}');
    return sb.toString();
}","{
    StringBuilder sb = new StringBuilder(128);
    sb.append(""{"");
    sb.append(fontScale);
    sb.append("" "");
    if (mcc != 0) {
        sb.append(mcc);
        sb.append(""mcc"");
    } else {
        sb.append(""?mcc"");
    }
    if (mnc != 0) {
        sb.append(mnc);
        sb.append(""mnc"");
    } else {
        sb.append(""?mnc"");
    }
    fixUpLocaleList();
    if (!mLocaleList.isEmpty()) {
        sb.append("" "");
        sb.append(mLocaleList);
    } else {
        sb.append("" ?localeList"");
    }
    int layoutDir = (screenLayout & SCREENLAYOUT_LAYOUTDIR_MASK);
    switch(layoutDir) {
        case SCREENLAYOUT_LAYOUTDIR_UNDEFINED:
            sb.append("" ?layoutDir"");
            break;
        case SCREENLAYOUT_LAYOUTDIR_LTR:
            sb.append("" ldltr"");
            break;
        case SCREENLAYOUT_LAYOUTDIR_RTL:
            sb.append("" ldrtl"");
            break;
        default:
            sb.append("" layoutDir="");
            sb.append(layoutDir >> SCREENLAYOUT_LAYOUTDIR_SHIFT);
            break;
    }
    if (smallestScreenWidthDp != SMALLEST_SCREEN_WIDTH_DP_UNDEFINED) {
        sb.append("" sw"");
        sb.append(smallestScreenWidthDp);
        sb.append(""dp"");
    } else {
        sb.append("" ?swdp"");
    }
    if (screenWidthDp != SCREEN_WIDTH_DP_UNDEFINED) {
        sb.append("" w"");
        sb.append(screenWidthDp);
        sb.append(""dp"");
    } else {
        sb.append("" ?wdp"");
    }
    if (screenHeightDp != SCREEN_HEIGHT_DP_UNDEFINED) {
        sb.append("" h"");
        sb.append(screenHeightDp);
        sb.append(""dp"");
    } else {
        sb.append("" ?hdp"");
    }
    if (densityDpi != DENSITY_DPI_UNDEFINED) {
        sb.append("" "");
        sb.append(densityDpi);
        sb.append(""dpi"");
    } else {
        sb.append("" ?density"");
    }
    switch((screenLayout & SCREENLAYOUT_SIZE_MASK)) {
        case SCREENLAYOUT_SIZE_UNDEFINED:
            sb.append("" ?lsize"");
            break;
        case SCREENLAYOUT_SIZE_SMALL:
            sb.append("" smll"");
            break;
        case SCREENLAYOUT_SIZE_NORMAL:
            sb.append("" nrml"");
            break;
        case SCREENLAYOUT_SIZE_LARGE:
            sb.append("" lrg"");
            break;
        case SCREENLAYOUT_SIZE_XLARGE:
            sb.append("" xlrg"");
            break;
        default:
            sb.append("" layoutSize="");
            sb.append(screenLayout & SCREENLAYOUT_SIZE_MASK);
            break;
    }
    switch((screenLayout & SCREENLAYOUT_LONG_MASK)) {
        case SCREENLAYOUT_LONG_UNDEFINED:
            sb.append("" ?long"");
            break;
        case SCREENLAYOUT_LONG_NO:
            /* not-long is not interesting to print */
            break;
        case SCREENLAYOUT_LONG_YES:
            sb.append("" long"");
            break;
        default:
            sb.append("" layoutLong="");
            sb.append(screenLayout & SCREENLAYOUT_LONG_MASK);
            break;
    }
    switch((colorMode & COLOR_MODE_HDR_MASK)) {
        // most likely not HDR
        case COLOR_MODE_HDR_UNDEFINED:
            sb.append("" ?ldr"");
            break;
        case COLOR_MODE_HDR_NO:
            /* ldr is not interesting to print */
            break;
        case COLOR_MODE_HDR_YES:
            sb.append("" hdr"");
            break;
        default:
            sb.append("" dynamicRange="");
            sb.append(colorMode & COLOR_MODE_HDR_MASK);
            break;
    }
    switch((colorMode & COLOR_MODE_WIDE_COLOR_GAMUT_MASK)) {
        case COLOR_MODE_WIDE_COLOR_GAMUT_UNDEFINED:
            sb.append("" ?wideColorGamut"");
            break;
        case COLOR_MODE_WIDE_COLOR_GAMUT_NO:
            /* not wide is not interesting to print */
            break;
        case COLOR_MODE_WIDE_COLOR_GAMUT_YES:
            sb.append("" widecg"");
            break;
        default:
            sb.append("" wideColorGamut="");
            sb.append(colorMode & COLOR_MODE_WIDE_COLOR_GAMUT_MASK);
            break;
    }
    switch(orientation) {
        case ORIENTATION_UNDEFINED:
            sb.append("" ?orien"");
            break;
        case ORIENTATION_LANDSCAPE:
            sb.append("" land"");
            break;
        case ORIENTATION_PORTRAIT:
            sb.append("" port"");
            break;
        default:
            sb.append("" orien="");
            sb.append(orientation);
            break;
    }
    switch((uiMode & UI_MODE_TYPE_MASK)) {
        case UI_MODE_TYPE_UNDEFINED:
            sb.append("" ?uimode"");
            break;
        case UI_MODE_TYPE_NORMAL:
            /* normal is not interesting to print */
            break;
        case UI_MODE_TYPE_DESK:
            sb.append("" desk"");
            break;
        case UI_MODE_TYPE_CAR:
            sb.append("" car"");
            break;
        case UI_MODE_TYPE_TELEVISION:
            sb.append("" television"");
            break;
        case UI_MODE_TYPE_APPLIANCE:
            sb.append("" appliance"");
            break;
        case UI_MODE_TYPE_WATCH:
            sb.append("" watch"");
            break;
        case UI_MODE_TYPE_VR_HEADSET:
            sb.append("" vrheadset"");
            break;
        default:
            sb.append("" uimode="");
            sb.append(uiMode & UI_MODE_TYPE_MASK);
            break;
    }
    switch((uiMode & UI_MODE_NIGHT_MASK)) {
        case UI_MODE_NIGHT_UNDEFINED:
            sb.append("" ?night"");
            break;
        case UI_MODE_NIGHT_NO:
            /* not-night is not interesting to print */
            break;
        case UI_MODE_NIGHT_YES:
            sb.append("" night"");
            break;
        default:
            sb.append("" night="");
            sb.append(uiMode & UI_MODE_NIGHT_MASK);
            break;
    }
    switch(touchscreen) {
        case TOUCHSCREEN_UNDEFINED:
            sb.append("" ?touch"");
            break;
        case TOUCHSCREEN_NOTOUCH:
            sb.append("" -touch"");
            break;
        case TOUCHSCREEN_STYLUS:
            sb.append("" stylus"");
            break;
        case TOUCHSCREEN_FINGER:
            sb.append("" finger"");
            break;
        default:
            sb.append("" touch="");
            sb.append(touchscreen);
            break;
    }
    switch(keyboard) {
        case KEYBOARD_UNDEFINED:
            sb.append("" ?keyb"");
            break;
        case KEYBOARD_NOKEYS:
            sb.append("" -keyb"");
            break;
        case KEYBOARD_QWERTY:
            sb.append("" qwerty"");
            break;
        case KEYBOARD_12KEY:
            sb.append("" 12key"");
            break;
        default:
            sb.append("" keys="");
            sb.append(keyboard);
            break;
    }
    switch(keyboardHidden) {
        case KEYBOARDHIDDEN_UNDEFINED:
            sb.append(""/?"");
            break;
        case KEYBOARDHIDDEN_NO:
            sb.append(""/v"");
            break;
        case KEYBOARDHIDDEN_YES:
            sb.append(""/h"");
            break;
        case KEYBOARDHIDDEN_SOFT:
            sb.append(""/s"");
            break;
        default:
            sb.append(""/"");
            sb.append(keyboardHidden);
            break;
    }
    switch(hardKeyboardHidden) {
        case HARDKEYBOARDHIDDEN_UNDEFINED:
            sb.append(""/?"");
            break;
        case HARDKEYBOARDHIDDEN_NO:
            sb.append(""/v"");
            break;
        case HARDKEYBOARDHIDDEN_YES:
            sb.append(""/h"");
            break;
        default:
            sb.append(""/"");
            sb.append(hardKeyboardHidden);
            break;
    }
    switch(navigation) {
        case NAVIGATION_UNDEFINED:
            sb.append("" ?nav"");
            break;
        case NAVIGATION_NONAV:
            sb.append("" -nav"");
            break;
        case NAVIGATION_DPAD:
            sb.append("" dpad"");
            break;
        case NAVIGATION_TRACKBALL:
            sb.append("" tball"");
            break;
        case NAVIGATION_WHEEL:
            sb.append("" wheel"");
            break;
        default:
            sb.append("" nav="");
            sb.append(navigation);
            break;
    }
    switch(navigationHidden) {
        case NAVIGATIONHIDDEN_UNDEFINED:
            sb.append(""/?"");
            break;
        case NAVIGATIONHIDDEN_NO:
            sb.append(""/v"");
            break;
        case NAVIGATIONHIDDEN_YES:
            sb.append(""/h"");
            break;
        default:
            sb.append(""/"");
            sb.append(navigationHidden);
            break;
    }
    if (appBounds != null) {
        sb.append("" appBounds="");
        sb.append(appBounds);
    }
    if (assetsSeq != 0) {
        sb.append("" as."").append(assetsSeq);
    }
    if (seq != 0) {
        sb.append("" s."").append(seq);
    }
    sb.append('}');
    return sb.toString();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
990,"<android.os.BinderProxy: boolean transact(int,Parcel,Parcel,int)>",25,26,"<android.os.BinderProxy: boolean transact(int,Parcel,Parcel,int)>","<android.os.BinderProxy: boolean transact(int,Parcel,Parcel,int)>",0,"{
    Binder.checkParcel(this, code, data, ""Unreasonably large binder buffer"");
    if (Binder.isTracingEnabled()) {
        Binder.getTransactionTracker().addTrace();
    }
    return transactNative(code, data, reply, flags);
}","{
    Binder.checkParcel(this, code, data, ""Unreasonably large binder buffer"");
    if (mWarnOnBlocking && ((flags & FLAG_ONEWAY) == 0)) {
        // For now, avoid spamming the log by disabling after we've logged
        // about this interface at least once
        mWarnOnBlocking = false;
        Log.w(Binder.TAG, ""Outgoing transactions from this process must be FLAG_ONEWAY"", new Throwable());
    }
    final boolean tracingEnabled = Binder.isTracingEnabled();
    if (tracingEnabled) {
        final Throwable tr = new Throwable();
        Binder.getTransactionTracker().addTrace(tr);
        StackTraceElement stackTraceElement = tr.getStackTrace()[1];
        Trace.traceBegin(Trace.TRACE_TAG_ALWAYS, stackTraceElement.getClassName() + ""."" + stackTraceElement.getMethodName());
    }
    try {
        return transactNative(code, data, reply, flags);
    } finally {
        if (tracingEnabled) {
            Trace.traceEnd(Trace.TRACE_TAG_ALWAYS);
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The conditional block for Binder.isTracingEnabled() has been extended with additional logic for tracing and includes a try-finally statement block, and there is a new conditional logging statement based on mWarnOnBlocking. These are control dependency and other type statement changes, so the code change type is 3,4.","The changes do not affect the API’s behavior related to return values or exception throwing, as the method still ultimately returns the result of transactNative with the same arguments. The additional logging and tracing do not change the outcome of the method execution, thus there is no CI, so the CI type is 0."
991,<android.widget.TimePicker: Integer getCurrentMinute()>,25,26,<android.widget.TimePicker: Integer getCurrentMinute()>,<android.widget.TimePicker: Integer getCurrentMinute()>,0,"{
    return mDelegate.getMinute();
}","{
    return getMinute();
}",1,"/**
 * @return the current minute
 * @deprecated Use {@link #getMinute()}
 */
","/**
 * @return the currently selected minute, in the range (0-59)
 * @deprecated Use {@link #getMinute()}
 */
",-1,"[@NonNull, @Deprecated]","[@NonNull, @Deprecated]",-1,-1,-1,-1,-1,-1,5,0,"The implementation changed from calling `mDelegate.getMinute()` to directly calling `getMinute()`. This is a change in the API being called, indicating a dependent API change, so the change type is 5.","There is no visible change that would affect the behavior of the API in the way it handles exceptions or returns a value based on the information provided. Assuming `getMinute()` is correctly implemented to provide the same functionality as `mDelegate.getMinute()`, there should be no compatibility issue, so the CI type is 0."
993,<android.preference.Preference: Set<String> getPersistedStringSet(Set<String>)>,25,26,<android.preference.Preference: Set<String> getPersistedStringSet(Set<String>)>,<android.preference.Preference: Set<String> getPersistedStringSet(Set<String>)>,0,"{
    if (!shouldPersist()) {
        return defaultReturnValue;
    }
    return mPreferenceManager.getSharedPreferences().getStringSet(mKey, defaultReturnValue);
}","{
    if (!shouldPersist()) {
        return defaultReturnValue;
    }
    PreferenceDataStore dataStore = getPreferenceDataStore();
    if (dataStore != null) {
        return dataStore.getStringSet(mKey, defaultReturnValue);
    }
    return mPreferenceManager.getSharedPreferences().getStringSet(mKey, defaultReturnValue);
}",1,"/**
 * Attempts to get a persisted set of Strings from the
 * {@link android.content.SharedPreferences}.
 * <p>
 * This will check if this Preference is persistent, get the SharedPreferences
 * from the {@link PreferenceManager}, and get the value.
 *
 * @param defaultReturnValue The default value to return if either the
 * Preference is not persistent or the Preference is not in the
 * shared preferences.
 * @return The value from the SharedPreferences or the default return
 * value.
 * @see #persistStringSet(Set)
 */
","/**
 * Attempts to get a persisted set of Strings if this Preference is persistent.
 *
 * @param defaultReturnValue The default value to return if either this
 * Preference is not persistent or this Preference is not present.
 * @return The value from the data store or the default return
 * value.
 * @see #persistStringSet(Set)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,5",1,"The late version has added a conditional block to check if a `PreferenceDataStore` is not null, and if that's true, it retrieves the string set from there instead of from `SharedPreferences`. Therefore, control dependency has changed and a new dependent API `PreferenceDataStore.getStringSet` method has been introduced, hence the code change types are 3 and 5.","Considering that a new data store can be involved in the late version (`PreferenceDataStore dataStore = getPreferenceDataStore(); if (dataStore != null) ...`), it may return a different set of strings than the `SharedPreferences` would, thus potentially leading to a different behavior of the API. Therefore, a CI caused by potentially different return values is identified, corresponding to CI type 1."
994,<android.app.Notification.Action.Builder: Action build()>,25,26,<android.app.Notification.Action.Builder: Action build()>,<android.app.Notification.Action.Builder: Action build()>,0,"{
    RemoteInput[] remoteInputs = mRemoteInputs != null ? mRemoteInputs.toArray(new RemoteInput[mRemoteInputs.size()]) : null;
    return new Action(mIcon, mTitle, mIntent, mExtras, remoteInputs, mAllowGeneratedReplies);
}","{
    ArrayList<RemoteInput> dataOnlyInputs = new ArrayList<>();
    RemoteInput[] previousDataInputs = (RemoteInput[]) mExtras.getParcelableArray(EXTRA_DATA_ONLY_INPUTS);
    if (previousDataInputs != null) {
        for (RemoteInput input : previousDataInputs) {
            dataOnlyInputs.add(input);
        }
    }
    List<RemoteInput> textInputs = new ArrayList<>();
    if (mRemoteInputs != null) {
        for (RemoteInput input : mRemoteInputs) {
            if (input.isDataOnly()) {
                dataOnlyInputs.add(input);
            } else {
                textInputs.add(input);
            }
        }
    }
    if (!dataOnlyInputs.isEmpty()) {
        RemoteInput[] dataInputsArr = dataOnlyInputs.toArray(new RemoteInput[dataOnlyInputs.size()]);
        mExtras.putParcelableArray(EXTRA_DATA_ONLY_INPUTS, dataInputsArr);
    }
    RemoteInput[] textInputsArr = textInputs.isEmpty() ? null : textInputs.toArray(new RemoteInput[textInputs.size()]);
    return new Action(mIcon, mTitle, mIntent, mExtras, textInputsArr, mAllowGeneratedReplies);
}",1,"/**
 * Combine all of the options that have been set and return a new {@link Action}
 * object.
 * @return the built action
 */
","/**
 * Combine all of the options that have been set and return a new {@link Action}
 * object.
 * @return the built action
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The method's implementation has added data processing logic which includes filtering inputs into dataOnlyInputs and textInputs, and modifications on mExtras bundle to include EXTRA_DATA_ONLY_INPUTS. These changes reflect in the control statements added, new variables defined, and other statements for processing the remote inputs which are different from the early version. The code change types are 1,3,4.","Since the return statement now passes a potentially different array of RemoteInput objects namely textInputsArr, based on new processing logic, where previously it passed remoteInputs without such filtering and alteration of mExtras, the action built from this method could be different in terms of the inputs and extras associated with it. Thus, the CI type is 1."
995,<android.accessibilityservice.AccessibilityServiceInfo: String capabilityToString(int)>,25,26,<android.accessibilityservice.AccessibilityServiceInfo: String capabilityToString(int)>,<android.accessibilityservice.AccessibilityServiceInfo: String capabilityToString(int)>,0,"{
    switch(capability) {
        case CAPABILITY_CAN_RETRIEVE_WINDOW_CONTENT:
            return ""CAPABILITY_CAN_RETRIEVE_WINDOW_CONTENT"";
        case CAPABILITY_CAN_REQUEST_TOUCH_EXPLORATION:
            return ""CAPABILITY_CAN_REQUEST_TOUCH_EXPLORATION"";
        case CAPABILITY_CAN_REQUEST_ENHANCED_WEB_ACCESSIBILITY:
            return ""CAPABILITY_CAN_REQUEST_ENHANCED_WEB_ACCESSIBILITY"";
        case CAPABILITY_CAN_REQUEST_FILTER_KEY_EVENTS:
            return ""CAPABILITY_CAN_FILTER_KEY_EVENTS"";
        case CAPABILITY_CAN_CONTROL_MAGNIFICATION:
            return ""CAPABILITY_CAN_CONTROL_MAGNIFICATION"";
        case CAPABILITY_CAN_PERFORM_GESTURES:
            return ""CAPABILITY_CAN_PERFORM_GESTURES"";
        default:
            return ""UNKNOWN"";
    }
}","{
    switch(capability) {
        case CAPABILITY_CAN_RETRIEVE_WINDOW_CONTENT:
            return ""CAPABILITY_CAN_RETRIEVE_WINDOW_CONTENT"";
        case CAPABILITY_CAN_REQUEST_TOUCH_EXPLORATION:
            return ""CAPABILITY_CAN_REQUEST_TOUCH_EXPLORATION"";
        case CAPABILITY_CAN_REQUEST_ENHANCED_WEB_ACCESSIBILITY:
            return ""CAPABILITY_CAN_REQUEST_ENHANCED_WEB_ACCESSIBILITY"";
        case CAPABILITY_CAN_REQUEST_FILTER_KEY_EVENTS:
            return ""CAPABILITY_CAN_REQUEST_FILTER_KEY_EVENTS"";
        case CAPABILITY_CAN_CONTROL_MAGNIFICATION:
            return ""CAPABILITY_CAN_CONTROL_MAGNIFICATION"";
        case CAPABILITY_CAN_PERFORM_GESTURES:
            return ""CAPABILITY_CAN_PERFORM_GESTURES"";
        case CAPABILITY_CAN_REQUEST_FINGERPRINT_GESTURES:
            return ""CAPABILITY_CAN_REQUEST_FINGERPRINT_GESTURES"";
        default:
            return ""UNKNOWN"";
    }
}",1,"/**
 * Returns the string representation of a capability. For example,
 * {@link #CAPABILITY_CAN_RETRIEVE_WINDOW_CONTENT} is represented
 * by the string CAPABILITY_CAN_RETRIEVE_WINDOW_CONTENT.
 *
 * @param capability The capability.
 * @return The string representation.
 */
","/**
 * Returns the string representation of a capability. For example,
 * {@link #CAPABILITY_CAN_RETRIEVE_WINDOW_CONTENT} is represented
 * by the string CAPABILITY_CAN_RETRIEVE_WINDOW_CONTENT.
 *
 * @param capability The capability.
 * @return The string representation.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"There is an additional 'case' statement added to the 'switch' block - case CAPABILITY_CAN_REQUEST_FINGERPRINT_GESTURES, and the return statement for CAPABILITY_CAN_REQUEST_FILTER_KEY_EVENTS now correctly returns ""CAPABILITY_CAN_REQUEST_FILTER_KEY_EVENTS"" instead of the incorrect ""CAPABILITY_CAN_FILTER_KEY_EVENTS"" from the earlier version. These changes imply both a control dependency change and a changed return statement.","As there's an additional case added to the switch, the late implementation can potentially return a different string (""CAPABILITY_CAN_REQUEST_FINGERPRINT_GESTURES"") if the 'capability' parameter matches CAPABILITY_CAN_REQUEST_FINGERPRINT_GESTURES. Additionally, since the return string for the CASE_CAPABILITY_CAN_REQUEST_FILTER_KEY_EVENTS has been corrected, the function now can return a different string for this value as well. Therefore, a Compatibility Issue related to returning a different value arises, hence the CI type is 1."
996,"<android.text.method.DigitsKeyListener: DigitsKeyListener getInstance(boolean,boolean)>",25,26,"<android.text.method.DigitsKeyListener: DigitsKeyListener getInstance(boolean,boolean)>","<android.text.method.DigitsKeyListener: DigitsKeyListener getInstance(boolean,boolean)>",0,"{
    int kind = (sign ? SIGN : 0) | (decimal ? DECIMAL : 0);
    if (sInstance[kind] != null)
        return sInstance[kind];
    sInstance[kind] = new DigitsKeyListener(sign, decimal);
    return sInstance[kind];
}","{
    return getInstance(null, sign, decimal);
}",1,"/**
 * Returns a DigitsKeyListener that accepts the digits 0 through 9,
 * plus the minus sign (only at the beginning) and/or decimal point
 * (only one per field) if specified.
 */
","/**
 * Returns a DigitsKeyListener that accepts the ASCII digits 0 through 9, plus the ASCII plus
 * or minus sign (only at the beginning) and/or the ASCII period ('.') as the decimal point
 * (only one per field) if specified.
 *
 * @deprecated Use {@link #getInstance(Locale, boolean, boolean)} instead.
 */
",-1,,"[@Deprecated, @NonNull]",-1,-1,-1,-1,-1,-1,"1,4,5",1,"The method in the late version is now calling another method with the signature 'getInstance(null, sign, decimal)', which represents both a change in the method body (an indirect call to another method instead of direct logic) and a dependent API change. Therefore, the code change types are 1,4,5.","As the implementation delegates the call to another method and does not execute the same code as it used to, it could potentially lead to a different return value, which classifies it as a Compatibility Issue of type 1."
997,<android.hardware.camera2.impl.CameraCaptureSessionImpl.IdleDrainListener: void onDrained()>,25,26,<android.hardware.camera2.impl.CameraCaptureSessionImpl.IdleDrainListener: void onDrained()>,<android.hardware.camera2.impl.CameraCaptureSessionImpl.IdleDrainListener: void onDrained()>,0,"{
    if (DEBUG)
        Log.v(TAG, mIdString + ""onIdleDrained"");
    // without causing a deadlock
    synchronized (mDeviceImpl.mInterfaceLock) {
        synchronized (CameraCaptureSessionImpl.this) {
            /*
                 * The device is now IDLE, and has settled. It will not transition to
                 * ACTIVE or BUSY again by itself.
                 *
                 * It's now safe to unconfigure the outputs.
                 *
                 * This operation is idempotent; a session will not be closed twice.
                 */
            if (DEBUG)
                Log.v(TAG, mIdString + ""Session drain complete, skip unconfigure: "" + mSkipUnconfigure);
            // as we won't get state updates any more anyway.
            if (mSkipUnconfigure) {
                return;
            }
            // everything is idle.
            try {
                // begin transition to unconfigured
                mDeviceImpl.configureStreamsChecked(/*inputConfig*/
                null, /*outputs*/
                null, /*isConstrainedHighSpeed*/
                false);
            } catch (CameraAccessException e) {
                // OK: do not throw checked exceptions.
                Log.e(TAG, mIdString + ""Exception while unconfiguring outputs: "", e);
            // TODO: call onError instead of onClosed if this happens
            } catch (IllegalStateException e) {
                // Camera is already closed, so nothing left to do
                if (DEBUG)
                    Log.v(TAG, mIdString + ""Camera was already closed or busy, skipping unconfigure"");
            }
        }
    }
}","{
    if (DEBUG)
        Log.v(TAG, mIdString + ""onIdleDrained"");
    // without causing a deadlock
    synchronized (mDeviceImpl.mInterfaceLock) {
        synchronized (CameraCaptureSessionImpl.this) {
            /*
                 * The device is now IDLE, and has settled. It will not transition to
                 * ACTIVE or BUSY again by itself.
                 *
                 * It's now safe to unconfigure the outputs.
                 *
                 * This operation is idempotent; a session will not be closed twice.
                 */
            if (DEBUG)
                Log.v(TAG, mIdString + ""Session drain complete, skip unconfigure: "" + mSkipUnconfigure);
            // as we won't get state updates any more anyway.
            if (mSkipUnconfigure) {
                return;
            }
            // everything is idle.
            try {
                // begin transition to unconfigured
                mDeviceImpl.configureStreamsChecked(/*inputConfig*/
                null, /*outputs*/
                null, /*operatingMode*/
                ICameraDeviceUser.NORMAL_MODE);
            } catch (CameraAccessException e) {
                // OK: do not throw checked exceptions.
                Log.e(TAG, mIdString + ""Exception while unconfiguring outputs: "", e);
            // TODO: call onError instead of onClosed if this happens
            } catch (IllegalStateException e) {
                // Camera is already closed, so nothing left to do
                if (DEBUG)
                    Log.v(TAG, mIdString + ""Camera was already closed or busy, skipping unconfigure"");
            }
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The code inside the try block changed from `mDeviceImpl.configureStreamsChecked(null, null, false);` to `mDeviceImpl.configureStreamsChecked(null, null, ICameraDeviceUser.NORMAL_MODE);`. There's a change in the third parameter from a boolean to an integer constant. Hence, the code change type is 4,5 because there's a change in the parameters of a method call within the implementation (Other statement changed) and the dependent API `configureStreamsChecked` signature has changed to use an integer constant instead of a boolean (Dependent API changed).","However, there's no compatibility issue because the behavior of the method `onDrained` itself, from the perspective of an API client, has not changed. The method doesn't return any value and doesn't throw a new exception; it merely calls another method with modified arguments internally. The change in `configureStreamsChecked` is isolated within the `onDrained` method and doesn't affect its contract since there is no change in the return value or exception handling exposed to the caller. Therefore, no CI is detected, and the CI type is 0."
998,<android.content.res.Resources: Theme newTheme()>,25,26,<android.content.res.Resources: Theme newTheme()>,<android.content.res.Resources: Theme newTheme()>,0,"{
    Theme theme = new Theme();
    theme.setImpl(mResourcesImpl.newThemeImpl());
    mThemeRefs.add(new WeakReference<>(theme));
    return theme;
}","{
    Theme theme = new Theme();
    theme.setImpl(mResourcesImpl.newThemeImpl());
    synchronized (mThemeRefs) {
        mThemeRefs.add(new WeakReference<>(theme));
    }
    return theme;
}",1,"/**
 * Generate a new Theme object for this set of Resources.  It initially
 * starts out empty.
 *
 * @return Theme The newly created Theme container.
 */
","/**
 * Generate a new Theme object for this set of Resources.  It initially
 * starts out empty.
 *
 * @return Theme The newly created Theme container.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The change is about how the method adds the `theme` WeakReference to `mThemeRefs`. It now uses synchronized block to control the access to `mThemeRefs` which is a change in the control dependency and Other statement changed, so the code change type is 3,4.","This change only affects thread-safety and does not affect the returned value of `newTheme()` method or exception handling, hence there's no potential Compatibility Issue. The CI type is 0."
1000,<android.hardware.camera2.params.OutputConfiguration: boolean equals(Object)>,25,26,<android.hardware.camera2.params.OutputConfiguration: boolean equals(Object)>,<android.hardware.camera2.params.OutputConfiguration: boolean equals(Object)>,0,"{
    if (obj == null) {
        return false;
    } else if (this == obj) {
        return true;
    } else if (obj instanceof OutputConfiguration) {
        final OutputConfiguration other = (OutputConfiguration) obj;
        boolean iSSurfaceEqual = mSurface == other.mSurface && mConfiguredGenerationId == other.mConfiguredGenerationId;
        if (mIsDeferredConfig) {
            Log.i(TAG, ""deferred config has the same surface"");
            iSSurfaceEqual = true;
        }
        return mRotation == other.mRotation && iSSurfaceEqual && mConfiguredSize.equals(other.mConfiguredSize) && mConfiguredFormat == other.mConfiguredFormat && mConfiguredDataspace == other.mConfiguredDataspace && mSurfaceGroupId == other.mSurfaceGroupId && mSurfaceType == other.mSurfaceType && mIsDeferredConfig == other.mIsDeferredConfig;
    }
    return false;
}","{
    if (obj == null) {
        return false;
    } else if (this == obj) {
        return true;
    } else if (obj instanceof OutputConfiguration) {
        final OutputConfiguration other = (OutputConfiguration) obj;
        if (mRotation != other.mRotation || !mConfiguredSize.equals(other.mConfiguredSize) || mConfiguredFormat != other.mConfiguredFormat || mSurfaceGroupId != other.mSurfaceGroupId || mSurfaceType != other.mSurfaceType || mIsDeferredConfig != other.mIsDeferredConfig || mIsShared != other.mIsShared || mConfiguredFormat != other.mConfiguredFormat || mConfiguredDataspace != other.mConfiguredDataspace || mConfiguredGenerationId != other.mConfiguredGenerationId)
            return false;
        int minLen = Math.min(mSurfaces.size(), other.mSurfaces.size());
        for (int i = 0; i < minLen; i++) {
            if (mSurfaces.get(i) != other.mSurfaces.get(i))
                return false;
        }
        return true;
    }
    return false;
}",1,"/**
 * Check if this {@link OutputConfiguration} is equal to another {@link OutputConfiguration}.
 *
 * <p>Two output configurations are only equal if and only if the underlying surfaces, surface
 * properties (width, height, format, dataspace) when the output configurations are created,
 * and all other configuration parameters are equal. </p>
 *
 * @return {@code true} if the objects were equal, {@code false} otherwise
 */
","/**
 * Check if this {@link OutputConfiguration} is equal to another {@link OutputConfiguration}.
 *
 * <p>Two output configurations are only equal if and only if the underlying surfaces, surface
 * properties (width, height, format, dataspace) when the output configurations are created,
 * and all other configuration parameters are equal. </p>
 *
 * @return {@code true} if the objects were equal, {@code false} otherwise
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"The implementation of the 'equals' method has changed significantly. The check for surface equality has been replaced with a more complex condition that includes checks for additional fields like mIsShared, and a new loop to compare the elements of mSurfaces lists. The condition for 'iSSurfaceEqual' has been removed and the condition inside the if (mIsDeferredConfig) block has been removed as well. Moreover, the way of how the equality is checked has changed from a single return statement to multiple return points based on different conditions. This is a structural change in the control dependency of the code, hence the change types are 1,3.","With the added conditions and the loop to compare the mSurfaces, the behavior of the method has changed in such a way that the 'equals' method could potentially return different results for the same inputs as compared to the previous version. This constitutes a compatibility issue as it will return a different boolean result under certain circumstances, reflecting a change in behavior, making the CI type 1."
1001,"<android.app.SharedPreferencesImpl: float getFloat(String,float)>",25,26,"<android.app.SharedPreferencesImpl: float getFloat(String,float)>","<android.app.SharedPreferencesImpl: float getFloat(String,float)>",0,"{
    synchronized (this) {
        awaitLoadedLocked();
        Float v = (Float) mMap.get(key);
        return v != null ? v : defValue;
    }
}","{
    synchronized (mLock) {
        awaitLoadedLocked();
        Float v = (Float) mMap.get(key);
        return v != null ? v : defValue;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change in the implementation is the object on which the method is synchronized: from `this` to `mLock`, so the code change type is 4.","The modification of the synchronization lock object does not affect the method's behavior regarding the return value or the exceptions it may throw. Thus, there is no Compatibility Issue, and the CI type is 0."
1002,<android.text.BidiFormatter.DirectionalityEstimator: byte dirTypeBackward()>,25,26,<android.text.BidiFormatter.DirectionalityEstimator: byte dirTypeBackward()>,<android.text.BidiFormatter.DirectionalityEstimator: byte dirTypeBackward()>,0,"{
    lastChar = text.charAt(charIndex - 1);
    if (Character.isLowSurrogate(lastChar)) {
        int codePoint = Character.codePointBefore(text, charIndex);
        charIndex -= Character.charCount(codePoint);
        return Character.getDirectionality(codePoint);
    }
    charIndex--;
    byte dirType = getCachedDirectionality(lastChar);
    if (isHtml) {
        // Process tags and entities.
        if (lastChar == '>') {
            dirType = skipTagBackward();
        } else if (lastChar == ';') {
            dirType = skipEntityBackward();
        }
    }
    return dirType;
}","{
    lastChar = text.charAt(charIndex - 1);
    if (Character.isLowSurrogate(lastChar)) {
        int codePoint = Character.codePointBefore(text, charIndex);
        charIndex -= Character.charCount(codePoint);
        return getDirectionality(codePoint);
    }
    charIndex--;
    byte dirType = getCachedDirectionality(lastChar);
    if (isHtml) {
        // Process tags and entities.
        if (lastChar == '>') {
            dirType = skipTagBackward();
        } else if (lastChar == ';') {
            dirType = skipEntityBackward();
        }
    }
    return dirType;
}",1,"/**
 * Returns the Character.DIRECTIONALITY_... value of the preceding codepoint and advances
 * charIndex backwards. If isHtml, and the codepoint is the end of a complete HTML tag or
 * entity, advances over the whole tag/entity and returns
 * Character.DIRECTIONALITY_WHITESPACE. For an entity, it would be best to figure out the
 * actual character, and return its dirtype, but treating it as whitespace is good enough
 * for our purposes.
 *
 * @throws java.lang.IndexOutOfBoundsException if called when charIndex > length or <= 0.
 */
","/**
 * Returns the Character.DIRECTIONALITY_... value of the preceding codepoint and advances
 * charIndex backwards. If isHtml, and the codepoint is the end of a complete HTML tag or
 * entity, advances over the whole tag/entity and returns
 * Character.DIRECTIONALITY_WHITESPACE. For an entity, it would be best to figure out the
 * actual character, and return its dirtype, but treating it as whitespace is good enough
 * for our purposes.
 *
 * @throws java.lang.IndexOutOfBoundsException if called when charIndex > length or <= 0.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,There is no difference between the two implementations.,There is no compatibility issue because there is no change between the two versions.
1004,<android.view.View: void setBackgroundDrawable(Drawable)>,25,26,<android.view.View: void setBackgroundDrawable(Drawable)>,<android.view.View: void setBackgroundDrawable(Drawable)>,0,"{
    computeOpaqueFlags();
    if (background == mBackground) {
        return;
    }
    boolean requestLayout = false;
    mBackgroundResource = 0;
    /*
         * Regardless of whether we're setting a new background or not, we want
         * to clear the previous drawable. setVisible first while we still have the callback set.
         */
    if (mBackground != null) {
        if (isAttachedToWindow()) {
            mBackground.setVisible(false, false);
        }
        mBackground.setCallback(null);
        unscheduleDrawable(mBackground);
    }
    if (background != null) {
        Rect padding = sThreadLocal.get();
        if (padding == null) {
            padding = new Rect();
            sThreadLocal.set(padding);
        }
        resetResolvedDrawablesInternal();
        background.setLayoutDirection(getLayoutDirection());
        if (background.getPadding(padding)) {
            resetResolvedPaddingInternal();
            switch(background.getLayoutDirection()) {
                case LAYOUT_DIRECTION_RTL:
                    mUserPaddingLeftInitial = padding.right;
                    mUserPaddingRightInitial = padding.left;
                    internalSetPadding(padding.right, padding.top, padding.left, padding.bottom);
                    break;
                case LAYOUT_DIRECTION_LTR:
                default:
                    mUserPaddingLeftInitial = padding.left;
                    mUserPaddingRightInitial = padding.right;
                    internalSetPadding(padding.left, padding.top, padding.right, padding.bottom);
            }
            mLeftPaddingDefined = false;
            mRightPaddingDefined = false;
        }
        // if it has a different minimum size, we should layout again
        if (mBackground == null || mBackground.getMinimumHeight() != background.getMinimumHeight() || mBackground.getMinimumWidth() != background.getMinimumWidth()) {
            requestLayout = true;
        }
        // Set mBackground before we set this as the callback and start making other
        // background drawable state change calls. In particular, the setVisible call below
        // can result in drawables attempting to start animations or otherwise invalidate,
        // which requires the view set as the callback (us) to recognize the drawable as
        // belonging to it as per verifyDrawable.
        mBackground = background;
        if (background.isStateful()) {
            background.setState(getDrawableState());
        }
        if (isAttachedToWindow()) {
            background.setVisible(getWindowVisibility() == VISIBLE && isShown(), false);
        }
        applyBackgroundTint();
        // Set callback last, since the view may still be initializing.
        background.setCallback(this);
        if ((mPrivateFlags & PFLAG_SKIP_DRAW) != 0) {
            mPrivateFlags &= ~PFLAG_SKIP_DRAW;
            requestLayout = true;
        }
    } else {
        /* Remove the background */
        mBackground = null;
        if ((mViewFlags & WILL_NOT_DRAW) != 0 && (mForegroundInfo == null || mForegroundInfo.mDrawable == null)) {
            mPrivateFlags |= PFLAG_SKIP_DRAW;
        }
        /*
             * When the background is set, we try to apply its padding to this
             * View. When the background is removed, we don't touch this View's
             * padding. This is noted in the Javadocs. Hence, we don't need to
             * requestLayout(), the invalidate() below is sufficient.
             */
        // The old background's minimum size could have affected this
        // View's layout, so let's requestLayout
        requestLayout = true;
    }
    computeOpaqueFlags();
    if (requestLayout) {
        requestLayout();
    }
    mBackgroundSizeChanged = true;
    invalidate(true);
    invalidateOutline();
}","{
    computeOpaqueFlags();
    if (background == mBackground) {
        return;
    }
    boolean requestLayout = false;
    mBackgroundResource = 0;
    /*
         * Regardless of whether we're setting a new background or not, we want
         * to clear the previous drawable. setVisible first while we still have the callback set.
         */
    if (mBackground != null) {
        if (isAttachedToWindow()) {
            mBackground.setVisible(false, false);
        }
        mBackground.setCallback(null);
        unscheduleDrawable(mBackground);
    }
    if (background != null) {
        Rect padding = sThreadLocal.get();
        if (padding == null) {
            padding = new Rect();
            sThreadLocal.set(padding);
        }
        resetResolvedDrawablesInternal();
        background.setLayoutDirection(getLayoutDirection());
        if (background.getPadding(padding)) {
            resetResolvedPaddingInternal();
            switch(background.getLayoutDirection()) {
                case LAYOUT_DIRECTION_RTL:
                    mUserPaddingLeftInitial = padding.right;
                    mUserPaddingRightInitial = padding.left;
                    internalSetPadding(padding.right, padding.top, padding.left, padding.bottom);
                    break;
                case LAYOUT_DIRECTION_LTR:
                default:
                    mUserPaddingLeftInitial = padding.left;
                    mUserPaddingRightInitial = padding.right;
                    internalSetPadding(padding.left, padding.top, padding.right, padding.bottom);
            }
            mLeftPaddingDefined = false;
            mRightPaddingDefined = false;
        }
        // if it has a different minimum size, we should layout again
        if (mBackground == null || mBackground.getMinimumHeight() != background.getMinimumHeight() || mBackground.getMinimumWidth() != background.getMinimumWidth()) {
            requestLayout = true;
        }
        // Set mBackground before we set this as the callback and start making other
        // background drawable state change calls. In particular, the setVisible call below
        // can result in drawables attempting to start animations or otherwise invalidate,
        // which requires the view set as the callback (us) to recognize the drawable as
        // belonging to it as per verifyDrawable.
        mBackground = background;
        if (background.isStateful()) {
            background.setState(getDrawableState());
        }
        if (isAttachedToWindow()) {
            background.setVisible(getWindowVisibility() == VISIBLE && isShown(), false);
        }
        applyBackgroundTint();
        // Set callback last, since the view may still be initializing.
        background.setCallback(this);
        if ((mPrivateFlags & PFLAG_SKIP_DRAW) != 0) {
            mPrivateFlags &= ~PFLAG_SKIP_DRAW;
            requestLayout = true;
        }
    } else {
        /* Remove the background */
        mBackground = null;
        if ((mViewFlags & WILL_NOT_DRAW) != 0 && (mDefaultFocusHighlight == null) && (mForegroundInfo == null || mForegroundInfo.mDrawable == null)) {
            mPrivateFlags |= PFLAG_SKIP_DRAW;
        }
        /*
             * When the background is set, we try to apply its padding to this
             * View. When the background is removed, we don't touch this View's
             * padding. This is noted in the Javadocs. Hence, we don't need to
             * requestLayout(), the invalidate() below is sufficient.
             */
        // The old background's minimum size could have affected this
        // View's layout, so let's requestLayout
        requestLayout = true;
    }
    computeOpaqueFlags();
    if (requestLayout) {
        requestLayout();
    }
    mBackgroundSizeChanged = true;
    invalidate(true);
    invalidateOutline();
}",1,"/**
 * @deprecated use {@link #setBackground(Drawable)} instead
 */
","/**
 * @deprecated use {@link #setBackground(Drawable)} instead
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,,,,
1005,"<android.view.LayoutInflater: View createView(String,String,AttributeSet)>",25,26,"<android.view.LayoutInflater: View createView(String,String,AttributeSet)>","<android.view.LayoutInflater: View createView(String,String,AttributeSet)>",0,"{
    Constructor<? extends View> constructor = sConstructorMap.get(name);
    if (constructor != null && !verifyClassLoader(constructor)) {
        constructor = null;
        sConstructorMap.remove(name);
    }
    Class<? extends View> clazz = null;
    try {
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, name);
        if (constructor == null) {
            // Class not found in the cache, see if it's real, and try to add it
            clazz = mContext.getClassLoader().loadClass(prefix != null ? (prefix + name) : name).asSubclass(View.class);
            if (mFilter != null && clazz != null) {
                boolean allowed = mFilter.onLoadClass(clazz);
                if (!allowed) {
                    failNotAllowed(name, prefix, attrs);
                }
            }
            constructor = clazz.getConstructor(mConstructorSignature);
            constructor.setAccessible(true);
            sConstructorMap.put(name, constructor);
        } else {
            // If we have a filter, apply it to cached constructor
            if (mFilter != null) {
                // Have we seen this name before?
                Boolean allowedState = mFilterMap.get(name);
                if (allowedState == null) {
                    // New class -- remember whether it is allowed
                    clazz = mContext.getClassLoader().loadClass(prefix != null ? (prefix + name) : name).asSubclass(View.class);
                    boolean allowed = clazz != null && mFilter.onLoadClass(clazz);
                    mFilterMap.put(name, allowed);
                    if (!allowed) {
                        failNotAllowed(name, prefix, attrs);
                    }
                } else if (allowedState.equals(Boolean.FALSE)) {
                    failNotAllowed(name, prefix, attrs);
                }
            }
        }
        Object[] args = mConstructorArgs;
        args[1] = attrs;
        final View view = constructor.newInstance(args);
        if (view instanceof ViewStub) {
            // Use the same context when inflating ViewStub later.
            final ViewStub viewStub = (ViewStub) view;
            viewStub.setLayoutInflater(cloneInContext((Context) args[0]));
        }
        return view;
    } catch (NoSuchMethodException e) {
        final InflateException ie = new InflateException(attrs.getPositionDescription() + "": Error inflating class "" + (prefix != null ? (prefix + name) : name), e);
        ie.setStackTrace(EMPTY_STACK_TRACE);
        throw ie;
    } catch (ClassCastException e) {
        // If loaded class is not a View subclass
        final InflateException ie = new InflateException(attrs.getPositionDescription() + "": Class is not a View "" + (prefix != null ? (prefix + name) : name), e);
        ie.setStackTrace(EMPTY_STACK_TRACE);
        throw ie;
    } catch (ClassNotFoundException e) {
        // If loadClass fails, we should propagate the exception.
        throw e;
    } catch (Exception e) {
        final InflateException ie = new InflateException(attrs.getPositionDescription() + "": Error inflating class "" + (clazz == null ? ""<unknown>"" : clazz.getName()), e);
        ie.setStackTrace(EMPTY_STACK_TRACE);
        throw ie;
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_VIEW);
    }
}","{
    Constructor<? extends View> constructor = sConstructorMap.get(name);
    if (constructor != null && !verifyClassLoader(constructor)) {
        constructor = null;
        sConstructorMap.remove(name);
    }
    Class<? extends View> clazz = null;
    try {
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, name);
        if (constructor == null) {
            // Class not found in the cache, see if it's real, and try to add it
            clazz = mContext.getClassLoader().loadClass(prefix != null ? (prefix + name) : name).asSubclass(View.class);
            if (mFilter != null && clazz != null) {
                boolean allowed = mFilter.onLoadClass(clazz);
                if (!allowed) {
                    failNotAllowed(name, prefix, attrs);
                }
            }
            constructor = clazz.getConstructor(mConstructorSignature);
            constructor.setAccessible(true);
            sConstructorMap.put(name, constructor);
        } else {
            // If we have a filter, apply it to cached constructor
            if (mFilter != null) {
                // Have we seen this name before?
                Boolean allowedState = mFilterMap.get(name);
                if (allowedState == null) {
                    // New class -- remember whether it is allowed
                    clazz = mContext.getClassLoader().loadClass(prefix != null ? (prefix + name) : name).asSubclass(View.class);
                    boolean allowed = clazz != null && mFilter.onLoadClass(clazz);
                    mFilterMap.put(name, allowed);
                    if (!allowed) {
                        failNotAllowed(name, prefix, attrs);
                    }
                } else if (allowedState.equals(Boolean.FALSE)) {
                    failNotAllowed(name, prefix, attrs);
                }
            }
        }
        Object lastContext = mConstructorArgs[0];
        if (mConstructorArgs[0] == null) {
            // Fill in the context if not already within inflation.
            mConstructorArgs[0] = mContext;
        }
        Object[] args = mConstructorArgs;
        args[1] = attrs;
        final View view = constructor.newInstance(args);
        if (view instanceof ViewStub) {
            // Use the same context when inflating ViewStub later.
            final ViewStub viewStub = (ViewStub) view;
            viewStub.setLayoutInflater(cloneInContext((Context) args[0]));
        }
        mConstructorArgs[0] = lastContext;
        return view;
    } catch (NoSuchMethodException e) {
        final InflateException ie = new InflateException(attrs.getPositionDescription() + "": Error inflating class "" + (prefix != null ? (prefix + name) : name), e);
        ie.setStackTrace(EMPTY_STACK_TRACE);
        throw ie;
    } catch (ClassCastException e) {
        // If loaded class is not a View subclass
        final InflateException ie = new InflateException(attrs.getPositionDescription() + "": Class is not a View "" + (prefix != null ? (prefix + name) : name), e);
        ie.setStackTrace(EMPTY_STACK_TRACE);
        throw ie;
    } catch (ClassNotFoundException e) {
        // If loadClass fails, we should propagate the exception.
        throw e;
    } catch (Exception e) {
        final InflateException ie = new InflateException(attrs.getPositionDescription() + "": Error inflating class "" + (clazz == null ? ""<unknown>"" : clazz.getName()), e);
        ie.setStackTrace(EMPTY_STACK_TRACE);
        throw ie;
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_VIEW);
    }
}",1,"/**
 * Low-level function for instantiating a view by name. This attempts to
 * instantiate a view class of the given <var>name</var> found in this
 * LayoutInflater's ClassLoader.
 *
 * <p>
 * There are two things that can happen in an error case: either the
 * exception describing the error will be thrown, or a null will be
 * returned. You must deal with both possibilities -- the former will happen
 * the first time createView() is called for a class of a particular name,
 * the latter every time there-after for that class name.
 *
 * @param name The full name of the class to be instantiated.
 * @param attrs The XML attributes supplied for this instance.
 *
 * @return View The newly instantiated view, or null.
 */
","/**
 * Low-level function for instantiating a view by name. This attempts to
 * instantiate a view class of the given <var>name</var> found in this
 * LayoutInflater's ClassLoader.
 *
 * <p>
 * There are two things that can happen in an error case: either the
 * exception describing the error will be thrown, or a null will be
 * returned. You must deal with both possibilities -- the former will happen
 * the first time createView() is called for a class of a particular name,
 * the latter every time there-after for that class name.
 *
 * @param name The full name of the class to be instantiated.
 * @param attrs The XML attributes supplied for this instance.
 *
 * @return View The newly instantiated view, or null.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
1006,"<android.app.ContextImpl: void sendBroadcast(Intent,String,int)>",25,26,"<android.app.ContextImpl: void sendBroadcast(Intent,String,int)>","<android.app.ContextImpl: void sendBroadcast(Intent,String,int)>",0,"{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, appOp, null, false, false, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, appOp, null, false, false, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The dependent API call has been altered from ActivityManagerNative.getDefault().broadcastIntent to ActivityManager.getService().broadcastIntent, which means the change type is 5.","There's no Compatibility Issue in terms of return value or exception handling since none of the existing control flow, return statements, or exception handling statements have been modified; only the method used to get the service instance responsible for broadcasting the intent has changed. As long as the semantics of broadcastIntent remain the same, this change will not cause a CI for clients using the sendBroadcast method."
1007,"<android.content.pm.LauncherApps: boolean isPackageEnabled(String,UserHandle)>",25,26,"<android.content.pm.LauncherApps: boolean isPackageEnabled(String,UserHandle)>","<android.content.pm.LauncherApps: boolean isPackageEnabled(String,UserHandle)>",0,"{
    try {
        return mService.isPackageEnabled(packageName, user);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}","{
    logErrorForInvalidProfileAccess(user);
    try {
        return mService.isPackageEnabled(mContext.getPackageName(), packageName, user);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}",1,"/**
 * Checks if the package is installed and enabled for a profile.
 *
 * @param packageName The package to check.
 * @param user The UserHandle of the profile.
 *
 * @return true if the package exists and is enabled.
 */
","/**
 * Checks if the package is installed and enabled for a profile.
 *
 * @param packageName The package to check.
 * @param user The UserHandle of the profile.
 *
 * @return true if the package exists and is enabled.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The code change includes the addition of the statement `logErrorForInvalidProfileAccess(user)` before the try block and the change in the 'isPackageEnabled' dependent API by inserting `mContext.getPackageName()`. Therefore, we have an Other statement changed (4) and a Dependent API changed (5).","With the change in the late version where an additional argument `mContext.getPackageName()` is passed to the `isPackageEnabled` method, the behavior of the API might differ as the method signature has changed. It could potentially result in a different return value from the service. Therefore, there is a Compatibility Issue caused by potential different return values or types (1)."
1008,<android.speech.tts.SynthesisPlaybackQueueItem: void run()>,25,26,<android.speech.tts.SynthesisPlaybackQueueItem: void run()>,<android.speech.tts.SynthesisPlaybackQueueItem: void run()>,0,"{
    final UtteranceProgressDispatcher dispatcher = getDispatcher();
    dispatcher.dispatchOnStart();
    if (!mAudioTrack.init()) {
        dispatcher.dispatchOnError(TextToSpeech.ERROR_OUTPUT);
        return;
    }
    try {
        byte[] buffer = null;
        // OR (c) done() is called in which case it will return null.
        while ((buffer = take()) != null) {
            mAudioTrack.write(buffer);
            mLogger.onAudioDataWritten();
        }
    } catch (InterruptedException ie) {
        if (DBG)
            Log.d(TAG, ""Interrupted waiting for buffers, cleaning up."");
    }
    mAudioTrack.waitAndRelease();
    if (mStatusCode == TextToSpeech.SUCCESS) {
        dispatcher.dispatchOnSuccess();
    } else if (mStatusCode == TextToSpeech.STOPPED) {
        dispatcher.dispatchOnStop();
    } else {
        dispatcher.dispatchOnError(mStatusCode);
    }
    mLogger.onCompleted(mStatusCode);
}","{
    final UtteranceProgressDispatcher dispatcher = getDispatcher();
    dispatcher.dispatchOnStart();
    if (!mAudioTrack.init()) {
        dispatcher.dispatchOnError(TextToSpeech.ERROR_OUTPUT);
        return;
    }
    mAudioTrack.setPlaybackPositionUpdateListener(this);
    // Ensure we set the first marker if there is one.
    updateMarker();
    try {
        byte[] buffer = null;
        // OR (c) done() is called in which case it will return null.
        while ((buffer = take()) != null) {
            mAudioTrack.write(buffer);
            mLogger.onAudioDataWritten();
        }
    } catch (InterruptedException ie) {
        if (DBG)
            Log.d(TAG, ""Interrupted waiting for buffers, cleaning up."");
    }
    mAudioTrack.waitAndRelease();
    if (mStatusCode == TextToSpeech.SUCCESS) {
        dispatcher.dispatchOnSuccess();
    } else if (mStatusCode == TextToSpeech.STOPPED) {
        dispatcher.dispatchOnStop();
    } else {
        dispatcher.dispatchOnError(mStatusCode);
    }
    mLogger.onCompleted(mStatusCode);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"Two method calls to `mAudioTrack.setPlaybackPositionUpdateListener(this)` and `updateMarker()` have been added in the late version, resulting in an 'Other statement changed', classified as 4.","Since the added method calls do not affect the control flow or the returned values and do not introduce any new exceptions, they represent an internal behavior change without causing a Compatibility Issue. Thus, there is no CI, so the CI type is 0."
1009,"<android.content.res.ResourcesImpl.ThemeImpl: TypedArray obtainStyledAttributes(Theme,AttributeSet,int[],int,int)>",25,26,"<android.content.res.ResourcesImpl.ThemeImpl: TypedArray obtainStyledAttributes(Theme,AttributeSet,int[],int,int)>","<android.content.res.ResourcesImpl.ThemeImpl: TypedArray obtainStyledAttributes(Theme,AttributeSet,int[],int,int)>",0,"{
    synchronized (mKey) {
        final int len = attrs.length;
        final TypedArray array = TypedArray.obtain(wrapper.getResources(), len);
        // XXX note that for now we only work with compiled XML files.
        // To support generic XML files we will need to manually parse
        // out the attributes from the XML file (applying type information
        // contained in the resources and such).
        final XmlBlock.Parser parser = (XmlBlock.Parser) set;
        AssetManager.applyStyle(mTheme, defStyleAttr, defStyleRes, parser != null ? parser.mParseState : 0, attrs, array.mData, array.mIndices);
        array.mTheme = wrapper;
        array.mXml = parser;
        return array;
    }
}","{
    synchronized (mKey) {
        final int len = attrs.length;
        final TypedArray array = TypedArray.obtain(wrapper.getResources(), len);
        // XXX note that for now we only work with compiled XML files.
        // To support generic XML files we will need to manually parse
        // out the attributes from the XML file (applying type information
        // contained in the resources and such).
        final XmlBlock.Parser parser = (XmlBlock.Parser) set;
        AssetManager.applyStyle(mTheme, defStyleAttr, defStyleRes, parser != null ? parser.mParseState : 0, attrs, attrs.length, array.mDataAddress, array.mIndicesAddress);
        array.mTheme = wrapper;
        array.mXml = parser;
        return array;
    }
}",1,,,-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,4,0,"The change is that `AssetManager.applyStyle(...)` method parameters changed from using `array.mData, array.mIndices` to using `array.mDataAddress, array.mIndicesAddress`. These are internal changes to how the data is passed to the `applyStyle` method but we don't see a change in behavior as it's the handling of pointers behind the scenes and neither the return type nor the exception handling are affected, therefore the change type is 4.","No Compatibility Issue should arise due to these internal changes, as they aren't altering the API's behavior, return values, or exception throwing; thus, the CI type is 0."
1010,<android.text.TextUtils.Reverser: char charAt(int)>,25,26,<android.text.TextUtils.Reverser: char charAt(int)>,<android.text.TextUtils.Reverser: char charAt(int)>,0,"{
    return AndroidCharacter.getMirror(mSource.charAt(mEnd - 1 - off));
}","{
    return (char) UCharacter.getMirror(mSource.charAt(mEnd - 1 - off));
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The return statement changed from using AndroidCharacter.getMirror to UCharacter.getMirror and also the cast to `char` type is introduced, which are type 1 and 4 changes. Additionally, since there is a change in the dependent API from `AndroidCharacter.getMirror` to `UCharacter.getMirror`, this is also a type 5 change because it relies on another API that has undergone a change.","Because the dependent API that is used to calculate the returned character has been replaced with a different implementation, this could lead to a different return value if the behavior of `UCharacter.getMirror` is different from `AndroidCharacter.getMirror`, making it a type 1 CI. The added `(char)` cast could also potentially lead to a different value being returned if there is a data loss due to the cast, hence a CI type 1 issue is present."
1011,"<android.app.PendingIntent: PendingIntent getService(Context,int,Intent,int)>",25,26,"<android.app.PendingIntent: PendingIntent getService(Context,int,Intent,int)>","<android.app.PendingIntent: PendingIntent getService(Context,int,Intent,int)>",0,"{
    String packageName = context.getPackageName();
    String resolvedType = intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
    try {
        intent.prepareToLeaveProcess(context);
        IIntentSender target = ActivityManagerNative.getDefault().getIntentSender(ActivityManager.INTENT_SENDER_SERVICE, packageName, null, null, requestCode, new Intent[] { intent }, resolvedType != null ? new String[] { resolvedType } : null, flags, null, UserHandle.myUserId());
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
    }
    return null;
}","{
    return buildServicePendingIntent(context, requestCode, intent, flags, ActivityManager.INTENT_SENDER_SERVICE);
}",1,"/**
 * Retrieve a PendingIntent that will start a service, like calling
 * {@link Context#startService Context.startService()}.  The start
 * arguments given to the service will come from the extras of the Intent.
 *
 * <p class=""note"">For security reasons, the {@link android.content.Intent}
 * you supply here should almost always be an <em>explicit intent</em>,
 * that is specify an explicit component to be delivered to through
 * {@link Intent#setClass(android.content.Context, Class) Intent.setClass}</p>
 *
 * @param context The Context in which this PendingIntent should start
 * the service.
 * @param requestCode Private request code for the sender
 * @param intent An Intent describing the service to be started.
 * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},
 * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},
 * {@link #FLAG_IMMUTABLE} or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been
 * supplied.
 */
","/**
 * Retrieve a PendingIntent that will start a service, like calling
 * {@link Context#startService Context.startService()}.  The start
 * arguments given to the service will come from the extras of the Intent.
 *
 * <p class=""note"">For security reasons, the {@link android.content.Intent}
 * you supply here should almost always be an <em>explicit intent</em>,
 * that is specify an explicit component to be delivered to through
 * {@link Intent#setClass(android.content.Context, Class) Intent.setClass}</p>
 *
 * @param context The Context in which this PendingIntent should start
 * the service.
 * @param requestCode Private request code for the sender
 * @param intent An Intent describing the service to be started.
 * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},
 * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},
 * {@link #FLAG_IMMUTABLE} or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been
 * supplied.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation of the method has been refactored to use a new method `buildServicePendingIntent`, which consolidates steps in the early implementation into one. This includes changes in how the `Intent` is prepared to leave the process and how the `PendingIntent` is obtained. By depending on a new method, the code change type is 1 (because of the change in the return statement) and 5 (because it depends on a new method).","Since the late version is using a new internally called method to create the PendingIntent, the execution path has changed. If the behavior of `buildServicePendingIntent` differs from the inline code in the early version, it could affect what object is returned, or possibly introduce new exceptions. This could lead to a Compatibility Issue of type 1, indicating the potential for different return values."
1013,"<android.widget.SearchView: void onMeasure(int,int)>",25,26,"<android.widget.SearchView: void onMeasure(int,int)>","<android.widget.SearchView: void onMeasure(int,int)>",0,"{
    // Let the standard measurements take effect in iconified state.
    if (isIconified()) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
        return;
    }
    int widthMode = MeasureSpec.getMode(widthMeasureSpec);
    int width = MeasureSpec.getSize(widthMeasureSpec);
    switch(widthMode) {
        case MeasureSpec.AT_MOST:
            // If there is an upper limit, don't exceed maximum width (explicit or implicit)
            if (mMaxWidth > 0) {
                width = Math.min(mMaxWidth, width);
            } else {
                width = Math.min(getPreferredWidth(), width);
            }
            break;
        case MeasureSpec.EXACTLY:
            // If an exact width is specified, still don't exceed any specified maximum width
            if (mMaxWidth > 0) {
                width = Math.min(mMaxWidth, width);
            }
            break;
        case MeasureSpec.UNSPECIFIED:
            // Use maximum width, if specified, else preferred width
            width = mMaxWidth > 0 ? mMaxWidth : getPreferredWidth();
            break;
    }
    widthMode = MeasureSpec.EXACTLY;
    int heightMode = MeasureSpec.getMode(heightMeasureSpec);
    int height = MeasureSpec.getSize(heightMeasureSpec);
    switch(heightMode) {
        case MeasureSpec.AT_MOST:
        case MeasureSpec.UNSPECIFIED:
            height = Math.min(getPreferredHeight(), height);
            break;
    }
    heightMode = MeasureSpec.EXACTLY;
    super.onMeasure(MeasureSpec.makeMeasureSpec(width, widthMode), MeasureSpec.makeMeasureSpec(height, heightMode));
}","{
    // Let the standard measurements take effect in iconified state.
    if (isIconified()) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
        return;
    }
    int widthMode = MeasureSpec.getMode(widthMeasureSpec);
    int width = MeasureSpec.getSize(widthMeasureSpec);
    switch(widthMode) {
        case MeasureSpec.AT_MOST:
            // If there is an upper limit, don't exceed maximum width (explicit or implicit)
            if (mMaxWidth > 0) {
                width = Math.min(mMaxWidth, width);
            } else {
                width = Math.min(getPreferredWidth(), width);
            }
            break;
        case MeasureSpec.EXACTLY:
            // If an exact width is specified, still don't exceed any specified maximum width
            if (mMaxWidth > 0) {
                width = Math.min(mMaxWidth, width);
            }
            break;
        case MeasureSpec.UNSPECIFIED:
            // Use maximum width, if specified, else preferred width
            width = mMaxWidth > 0 ? mMaxWidth : getPreferredWidth();
            break;
    }
    widthMode = MeasureSpec.EXACTLY;
    int heightMode = MeasureSpec.getMode(heightMeasureSpec);
    int height = MeasureSpec.getSize(heightMeasureSpec);
    switch(heightMode) {
        case MeasureSpec.AT_MOST:
            height = Math.min(getPreferredHeight(), height);
            break;
        case MeasureSpec.UNSPECIFIED:
            height = getPreferredHeight();
            break;
    }
    heightMode = MeasureSpec.EXACTLY;
    super.onMeasure(MeasureSpec.makeMeasureSpec(width, widthMode), MeasureSpec.makeMeasureSpec(height, heightMode));
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,1,"The change occurred within a switch-case statement under the MeasureSpec.UNSPECIFIED case in the heightMode switch block. In the late version, the call to Math.min has been removed, and getPreferredHeight() is directly used as the height. This is a control dependency change because the path of execution has changed within the control flow statement (switch-case).","Due to the change, in case of MeasureSpec.UNSPECIFIED, the method will now always use getPreferredHeight() as the height, whereas in the early version, the height could have been smaller than getPreferredHeight() but not larger than it. This change could lead to different behavior, especially if the original MeasureSpec.getSize for height was less than getPreferredHeight(), resulting in potentially larger height values in the late version. Therefore, a Compatibility Issue is detected due to a potential difference in return values, classified as type 1."
1014,<android.view.inputmethod.InputMethodManager.H: void handleMessage(Message)>,25,26,<android.view.inputmethod.InputMethodManager.H: void handleMessage(Message)>,<android.view.inputmethod.InputMethodManager.H: void handleMessage(Message)>,0,"{
    switch(msg.what) {
        case MSG_DUMP:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                try {
                    doDump((FileDescriptor) args.arg1, (PrintWriter) args.arg2, (String[]) args.arg3);
                } catch (RuntimeException e) {
                    ((PrintWriter) args.arg2).println(""Exception: "" + e);
                }
                synchronized (args.arg4) {
                    ((CountDownLatch) args.arg4).countDown();
                }
                args.recycle();
                return;
            }
        case MSG_BIND:
            {
                final InputBindResult res = (InputBindResult) msg.obj;
                if (DEBUG) {
                    Log.i(TAG, ""handleMessage: MSG_BIND "" + res.sequence + "","" + res.id);
                }
                synchronized (mH) {
                    if (mBindSequence < 0 || mBindSequence != res.sequence) {
                        Log.w(TAG, ""Ignoring onBind: cur seq="" + mBindSequence + "", given seq="" + res.sequence);
                        if (res.channel != null && res.channel != mCurChannel) {
                            res.channel.dispose();
                        }
                        return;
                    }
                    mRequestUpdateCursorAnchorInfoMonitorMode = REQUEST_UPDATE_CURSOR_ANCHOR_INFO_NONE;
                    setInputChannelLocked(res.channel);
                    mCurMethod = res.method;
                    mCurId = res.id;
                    mBindSequence = res.sequence;
                }
                startInputInner(InputMethodClient.START_INPUT_REASON_BOUND_TO_IMMS, null, 0, 0, 0);
                return;
            }
        case MSG_UNBIND:
            {
                final int sequence = msg.arg1;
                @InputMethodClient.UnbindReason final int reason = msg.arg2;
                if (DEBUG) {
                    Log.i(TAG, ""handleMessage: MSG_UNBIND "" + sequence + "" reason="" + InputMethodClient.getUnbindReason(reason));
                }
                final boolean startInput;
                synchronized (mH) {
                    if (mBindSequence != sequence) {
                        return;
                    }
                    clearBindingLocked();
                    // we would like to re-connect to the next input method.
                    if (mServedView != null && mServedView.isFocused()) {
                        mServedConnecting = true;
                    }
                    startInput = mActive;
                }
                if (startInput) {
                    startInputInner(InputMethodClient.START_INPUT_REASON_UNBOUND_FROM_IMMS, null, 0, 0, 0);
                }
                return;
            }
        case MSG_SET_ACTIVE:
            {
                final boolean active = msg.arg1 != 0;
                if (DEBUG) {
                    Log.i(TAG, ""handleMessage: MSG_SET_ACTIVE "" + active + "", was "" + mActive);
                }
                synchronized (mH) {
                    mActive = active;
                    mFullscreenMode = false;
                    if (!active) {
                        // Some other client has starting using the IME, so note
                        // that this happened and make sure our own editor's
                        // state is reset.
                        mHasBeenInactive = true;
                        try {
                            // Note that finishComposingText() is allowed to run
                            // even when we are not active.
                            mIInputContext.finishComposingText();
                        } catch (RemoteException e) {
                        }
                    }
                    // handling this message.
                    if (mServedView != null && mServedView.hasWindowFocus()) {
                        if (checkFocusNoStartInput(mHasBeenInactive)) {
                            final int reason = active ? InputMethodClient.START_INPUT_REASON_ACTIVATED_BY_IMMS : InputMethodClient.START_INPUT_REASON_DEACTIVATED_BY_IMMS;
                            startInputInner(reason, null, 0, 0, 0);
                        }
                    }
                }
                return;
            }
        case MSG_SEND_INPUT_EVENT:
            {
                sendInputEventAndReportResultOnMainLooper((PendingEvent) msg.obj);
                return;
            }
        case MSG_TIMEOUT_INPUT_EVENT:
            {
                finishedInputEvent(msg.arg1, false, true);
                return;
            }
        case MSG_FLUSH_INPUT_EVENT:
            {
                finishedInputEvent(msg.arg1, false, false);
                return;
            }
        case MSG_SET_USER_ACTION_NOTIFICATION_SEQUENCE_NUMBER:
            {
                synchronized (mH) {
                    mNextUserActionNotificationSequenceNumber = msg.arg1;
                }
            }
    }
}","{
    switch(msg.what) {
        case MSG_DUMP:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                try {
                    doDump((FileDescriptor) args.arg1, (PrintWriter) args.arg2, (String[]) args.arg3);
                } catch (RuntimeException e) {
                    ((PrintWriter) args.arg2).println(""Exception: "" + e);
                }
                synchronized (args.arg4) {
                    ((CountDownLatch) args.arg4).countDown();
                }
                args.recycle();
                return;
            }
        case MSG_BIND:
            {
                final InputBindResult res = (InputBindResult) msg.obj;
                if (DEBUG) {
                    Log.i(TAG, ""handleMessage: MSG_BIND "" + res.sequence + "","" + res.id);
                }
                synchronized (mH) {
                    if (mBindSequence < 0 || mBindSequence != res.sequence) {
                        Log.w(TAG, ""Ignoring onBind: cur seq="" + mBindSequence + "", given seq="" + res.sequence);
                        if (res.channel != null && res.channel != mCurChannel) {
                            res.channel.dispose();
                        }
                        return;
                    }
                    mRequestUpdateCursorAnchorInfoMonitorMode = REQUEST_UPDATE_CURSOR_ANCHOR_INFO_NONE;
                    setInputChannelLocked(res.channel);
                    mCurMethod = res.method;
                    mCurId = res.id;
                    mBindSequence = res.sequence;
                }
                startInputInner(InputMethodClient.START_INPUT_REASON_BOUND_TO_IMMS, null, 0, 0, 0);
                return;
            }
        case MSG_UNBIND:
            {
                final int sequence = msg.arg1;
                @InputMethodClient.UnbindReason final int reason = msg.arg2;
                if (DEBUG) {
                    Log.i(TAG, ""handleMessage: MSG_UNBIND "" + sequence + "" reason="" + InputMethodClient.getUnbindReason(reason));
                }
                final boolean startInput;
                synchronized (mH) {
                    if (mBindSequence != sequence) {
                        return;
                    }
                    clearBindingLocked();
                    // we would like to re-connect to the next input method.
                    if (mServedView != null && mServedView.isFocused()) {
                        mServedConnecting = true;
                    }
                    startInput = mActive;
                }
                if (startInput) {
                    startInputInner(InputMethodClient.START_INPUT_REASON_UNBOUND_FROM_IMMS, null, 0, 0, 0);
                }
                return;
            }
        case MSG_SET_ACTIVE:
            {
                final boolean active = msg.arg1 != 0;
                final boolean fullscreen = msg.arg2 != 0;
                if (DEBUG) {
                    Log.i(TAG, ""handleMessage: MSG_SET_ACTIVE "" + active + "", was "" + mActive);
                }
                synchronized (mH) {
                    mActive = active;
                    mFullscreenMode = fullscreen;
                    if (!active) {
                        // Some other client has starting using the IME, so note
                        // that this happened and make sure our own editor's
                        // state is reset.
                        mHasBeenInactive = true;
                        try {
                            // Note that finishComposingText() is allowed to run
                            // even when we are not active.
                            mIInputContext.finishComposingText();
                        } catch (RemoteException e) {
                        }
                    }
                    // handling this message.
                    if (mServedView != null && mServedView.hasWindowFocus()) {
                        if (checkFocusNoStartInput(mHasBeenInactive)) {
                            final int reason = active ? InputMethodClient.START_INPUT_REASON_ACTIVATED_BY_IMMS : InputMethodClient.START_INPUT_REASON_DEACTIVATED_BY_IMMS;
                            startInputInner(reason, null, 0, 0, 0);
                        }
                    }
                }
                return;
            }
        case MSG_SEND_INPUT_EVENT:
            {
                sendInputEventAndReportResultOnMainLooper((PendingEvent) msg.obj);
                return;
            }
        case MSG_TIMEOUT_INPUT_EVENT:
            {
                finishedInputEvent(msg.arg1, false, true);
                return;
            }
        case MSG_FLUSH_INPUT_EVENT:
            {
                finishedInputEvent(msg.arg1, false, false);
                return;
            }
        case MSG_SET_USER_ACTION_NOTIFICATION_SEQUENCE_NUMBER:
            {
                synchronized (mH) {
                    mNextUserActionNotificationSequenceNumber = msg.arg1;
                }
                return;
            }
        case MSG_REPORT_FULLSCREEN_MODE:
            {
                final boolean fullscreen = msg.arg1 != 0;
                InputConnection ic = null;
                synchronized (mH) {
                    mFullscreenMode = fullscreen;
                    if (mServedInputConnectionWrapper != null) {
                        ic = mServedInputConnectionWrapper.getInputConnection();
                    }
                }
                if (ic != null) {
                    ic.reportFullscreenMode(fullscreen);
                }
                return;
            }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
1015,"<android.app.Activity: PendingIntent createPendingResult(int,Intent,int)>",25,26,"<android.app.Activity: PendingIntent createPendingResult(int,Intent,int)>","<android.app.Activity: PendingIntent createPendingResult(int,Intent,int)>",0,"{
    String packageName = getPackageName();
    try {
        data.prepareToLeaveProcess(this);
        IIntentSender target = ActivityManagerNative.getDefault().getIntentSender(ActivityManager.INTENT_SENDER_ACTIVITY_RESULT, packageName, mParent == null ? mToken : mParent.mToken, mEmbeddedID, requestCode, new Intent[] { data }, null, flags, null, UserHandle.myUserId());
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
    // Empty
    }
    return null;
}","{
    String packageName = getPackageName();
    try {
        data.prepareToLeaveProcess(this);
        IIntentSender target = ActivityManager.getService().getIntentSender(ActivityManager.INTENT_SENDER_ACTIVITY_RESULT, packageName, mParent == null ? mToken : mParent.mToken, mEmbeddedID, requestCode, new Intent[] { data }, null, flags, null, UserHandle.myUserId());
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
    // Empty
    }
    return null;
}",1,"/**
 * Create a new PendingIntent object which you can hand to others
 * for them to use to send result data back to your
 * {@link #onActivityResult} callback.  The created object will be either
 * one-shot (becoming invalid after a result is sent back) or multiple
 * (allowing any number of results to be sent through it).
 *
 * @param requestCode Private request code for the sender that will be
 * associated with the result data when it is returned.  The sender can not
 * modify this value, allowing you to identify incoming results.
 * @param data Default data to supply in the result, which may be modified
 * by the sender.
 * @param flags May be {@link PendingIntent#FLAG_ONE_SHOT PendingIntent.FLAG_ONE_SHOT},
 * {@link PendingIntent#FLAG_NO_CREATE PendingIntent.FLAG_NO_CREATE},
 * {@link PendingIntent#FLAG_CANCEL_CURRENT PendingIntent.FLAG_CANCEL_CURRENT},
 * {@link PendingIntent#FLAG_UPDATE_CURRENT PendingIntent.FLAG_UPDATE_CURRENT},
 * or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if
 * {@link PendingIntent#FLAG_NO_CREATE PendingIntent.FLAG_NO_CREATE} has been
 * supplied.
 *
 * @see PendingIntent
 */
","/**
 * Create a new PendingIntent object which you can hand to others
 * for them to use to send result data back to your
 * {@link #onActivityResult} callback.  The created object will be either
 * one-shot (becoming invalid after a result is sent back) or multiple
 * (allowing any number of results to be sent through it).
 *
 * @param requestCode Private request code for the sender that will be
 * associated with the result data when it is returned.  The sender can not
 * modify this value, allowing you to identify incoming results.
 * @param data Default data to supply in the result, which may be modified
 * by the sender.
 * @param flags May be {@link PendingIntent#FLAG_ONE_SHOT PendingIntent.FLAG_ONE_SHOT},
 * {@link PendingIntent#FLAG_NO_CREATE PendingIntent.FLAG_NO_CREATE},
 * {@link PendingIntent#FLAG_CANCEL_CURRENT PendingIntent.FLAG_CANCEL_CURRENT},
 * {@link PendingIntent#FLAG_UPDATE_CURRENT PendingIntent.FLAG_UPDATE_CURRENT},
 * or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if
 * {@link PendingIntent#FLAG_NO_CREATE PendingIntent.FLAG_NO_CREATE} has been
 * supplied.
 *
 * @see PendingIntent
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method to retrieve the activity manager service has changed from `ActivityManagerNative.getDefault()` to `ActivityManager.getService()`. This is a change in a dependent API, which falls under code change type 5.","There is no indication that the signature or semantics of the `getIntentSender()` method have changed, and the handling of the RemoteException has not been altered between these two versions. That means the changes should not lead to a Compatibility Issue as they likely would not change the behavior seen by code using `createPendingResult(int,Intent,int)`. Thus, the CI type is 0."
1016,"<android.widget.ProgressBar: boolean setProgressInternal(int,boolean,boolean)>",25,26,"<android.widget.ProgressBar: boolean setProgressInternal(int,boolean,boolean)>","<android.widget.ProgressBar: boolean setProgressInternal(int,boolean,boolean)>",0,"{
    if (mIndeterminate) {
        // Not applicable.
        return false;
    }
    progress = MathUtils.constrain(progress, 0, mMax);
    if (progress == mProgress) {
        // No change from current.
        return false;
    }
    mProgress = progress;
    refreshProgress(R.id.progress, mProgress, fromUser, animate);
    return true;
}","{
    if (mIndeterminate) {
        // Not applicable.
        return false;
    }
    progress = MathUtils.constrain(progress, mMin, mMax);
    if (progress == mProgress) {
        // No change from current.
        return false;
    }
    mProgress = progress;
    refreshProgress(R.id.progress, mProgress, fromUser, animate);
    return true;
}",1,,,-1,[@android.view.RemotableViewMethod],[@android.view.RemotableViewMethod],-1,-1,-1,-1,-1,-1,"4,5",0,"The code change occurs in the statement used to constrain the `progress` value, updating the minimum bound from a hardcoded `0` to `mMin`. Since this is a change in a method call parameter, the change type is 4. Additionally, this is a change to a dependent API (`MathUtils.constrain`), making the change type also a 5.","Although the way the `progress` value is constrained has changed, this change will not introduce a compatibility issue assuming that the valid range of `progress` now correctly accounts for `mMin`. If `mMin` is equivalent to 0, the new version of the code acts the same as the old version. The change is internal to the method's logic and does not change how exceptions are handled or how the method returns, thus there is no compatibility issue here, so the CI type is 0."
1017,<android.widget.ProgressBar: void setSecondaryProgress(int)>,25,26,<android.widget.ProgressBar: void setSecondaryProgress(int)>,<android.widget.ProgressBar: void setSecondaryProgress(int)>,0,"{
    if (mIndeterminate) {
        return;
    }
    if (secondaryProgress < 0) {
        secondaryProgress = 0;
    }
    if (secondaryProgress > mMax) {
        secondaryProgress = mMax;
    }
    if (secondaryProgress != mSecondaryProgress) {
        mSecondaryProgress = secondaryProgress;
        refreshProgress(R.id.secondaryProgress, mSecondaryProgress, false, false);
    }
}","{
    if (mIndeterminate) {
        return;
    }
    if (secondaryProgress < mMin) {
        secondaryProgress = mMin;
    }
    if (secondaryProgress > mMax) {
        secondaryProgress = mMax;
    }
    if (secondaryProgress != mSecondaryProgress) {
        mSecondaryProgress = secondaryProgress;
        refreshProgress(R.id.secondaryProgress, mSecondaryProgress, false, false);
    }
}",1,"/**
 * <p>
 * Set the current secondary progress to the specified value. Does not do
 * anything if the progress bar is in indeterminate mode.
 * </p>
 *
 * @param secondaryProgress the new secondary progress, between 0 and {@link #getMax()}
 * @see #setIndeterminate(boolean)
 * @see #isIndeterminate()
 * @see #getSecondaryProgress()
 * @see #incrementSecondaryProgressBy(int)
 */
","/**
 * <p>
 * Set the current secondary progress to the specified value. Does not do
 * anything if the progress bar is in indeterminate mode.
 * </p>
 *
 * @param secondaryProgress the new secondary progress, between 0 and {@link #getMax()}
 * @see #setIndeterminate(boolean)
 * @see #isIndeterminate()
 * @see #getSecondaryProgress()
 * @see #incrementSecondaryProgressBy(int)
 */
",-1,[@android.view.RemotableViewMethod],[@android.view.RemotableViewMethod],-1,-1,-1,-1,-1,-1,"3,4",0,"The control dependency change is the alteration from if (secondaryProgress < 0) to if (secondaryProgress < mMin), and an other statement changed by altering the conditions checked for setting the secondaryProgress. No return statement or exception handling statement has been changed.","There is no Compatibility Issue as the method's signature remains the same, the method still does not return a value, and the method does not throw an exception. The change from '0' to 'mMin' is an internal condition that does not affect the API contract."
1018,<android.bluetooth.BluetoothHealthAppConfiguration: boolean equals(Object)>,25,26,<android.bluetooth.BluetoothHealthAppConfiguration: boolean equals(Object)>,<android.bluetooth.BluetoothHealthAppConfiguration: boolean equals(Object)>,0,"{
    if (o instanceof BluetoothHealthAppConfiguration) {
        BluetoothHealthAppConfiguration config = (BluetoothHealthAppConfiguration) o;
        // config.getName() can never be NULL
        return mName.equals(config.getName()) && mDataType == config.getDataType() && mRole == config.getRole() && mChannelType == config.getChannelType();
    }
    return false;
}","{
    if (o instanceof BluetoothHealthAppConfiguration) {
        BluetoothHealthAppConfiguration config = (BluetoothHealthAppConfiguration) o;
        if (mName == null)
            return false;
        return mName.equals(config.getName()) && mDataType == config.getDataType() && mRole == config.getRole() && mChannelType == config.getChannelType();
    }
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,"An if condition checking if mName is null has been introduced before the return statement, so the code change type is 3.","The additional null check for mName will not lead to a compatibility issue because the early implementation comment states ""config.getName() can never be NULL"" implying mName is expected to be non-null. The late version is merely adding a defensive programming check which would only affect objects erroneously constructed with a null name. Given that it would be an API misuse to create a BluetoothHealthAppConfiguration instance with a null name, there should be no compatibility issue. Thus, the CI type is 0."
1019,<android.view.accessibility.AccessibilityManager: boolean removeTouchExplorationStateChangeListener(TouchExplorationStateChangeListener)>,25,26,<android.view.accessibility.AccessibilityManager: boolean removeTouchExplorationStateChangeListener(TouchExplorationStateChangeListener)>,<android.view.accessibility.AccessibilityManager: boolean removeTouchExplorationStateChangeListener(TouchExplorationStateChangeListener)>,0,"{
    // Final CopyOnWriteArrayList - no lock needed.
    return mTouchExplorationStateChangeListeners.remove(listener);
}","{
    synchronized (mLock) {
        int index = mTouchExplorationStateChangeListeners.indexOfKey(listener);
        mTouchExplorationStateChangeListeners.remove(listener);
        return (index >= 0);
    }
}",1,"/**
 * Unregisters a {@link TouchExplorationStateChangeListener}.
 *
 * @param listener The listener.
 * @return True if successfully unregistered.
 */
","/**
 * Unregisters a {@link TouchExplorationStateChangeListener}.
 *
 * @param listener The listener.
 * @return True if listener was previously registered.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The late version introduces a new control statement (synchronized) and changes how the result is computed by checking the index before removing the listener. So, the code change types are 3 (Control dependency changed) and 4 (Other statement changed).","There's no compatibility issue predicted because the behavior of the method remains consistent. Both versions are meant to remove a listener and return a boolean indicating success. The introduction of synchronization and index checking doesn't affect the successful removal of the listener or the return value in a way that would cause a compatibility issue for existing code. Thus, the CI type is 0 (No Compatibility Issue)."
1021,<android.app.DownloadManager: Uri getUriForDownloadedFile(long)>,25,26,<android.app.DownloadManager: Uri getUriForDownloadedFile(long)>,<android.app.DownloadManager: Uri getUriForDownloadedFile(long)>,0,"{
    // to check if the file is in cache, get its destination from the database
    Query query = new Query().setFilterById(id);
    Cursor cursor = null;
    try {
        cursor = query(query);
        if (cursor == null) {
            return null;
        }
        if (cursor.moveToFirst()) {
            int status = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_STATUS));
            if (DownloadManager.STATUS_SUCCESSFUL == status) {
                return ContentUris.withAppendedId(Downloads.Impl.CONTENT_URI, id);
            }
        }
    } finally {
        if (cursor != null) {
            cursor.close();
        }
    }
    // downloaded file not found or its status is not 'successfully completed'
    return null;
}","{
    // to check if the file is in cache, get its destination from the database
    Query query = new Query().setFilterById(id);
    Cursor cursor = null;
    try {
        cursor = query(query);
        if (cursor == null) {
            return null;
        }
        if (cursor.moveToFirst()) {
            int status = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_STATUS));
            if (DownloadManager.STATUS_SUCCESSFUL == status) {
                return ContentUris.withAppendedId(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, id);
            }
        }
    } finally {
        if (cursor != null) {
            cursor.close();
        }
    }
    // downloaded file not found or its status is not 'successfully completed'
    return null;
}",1,"/**
 * Returns the {@link Uri} of the given downloaded file id, if the file is
 * downloaded successfully. Otherwise, null is returned.
 *
 * @param id the id of the downloaded file.
 * @return the {@link Uri} of the given downloaded file id, if download was
 * successful. null otherwise.
 */
","/**
 * Returns the {@link Uri} of the given downloaded file id, if the file is
 * downloaded successfully. Otherwise, null is returned.
 *
 * @param id the id of the downloaded file.
 * @return the {@link Uri} of the given downloaded file id, if download was
 * successful. null otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The return statement has changed from ContentUris.withAppendedId(Downloads.Impl.CONTENT_URI, id); to ContentUris.withAppendedId(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, id);. This is an identifier change, so the code change type is 1 for the return statement change and 4 for changing a part of the expression which is not a control structure.","Since the URI returned by the method has changed (from CONTENT_URI to ALL_DOWNLOADS_CONTENT_URI), clients using this method will receive a different URI for the downloaded files. Thus the API potentially returns different values and hence the CI type is 1."
1022,<android.animation.AnimatorSet.Builder: Builder after(Animator)>,25,26,<android.animation.AnimatorSet.Builder: Builder after(Animator)>,<android.animation.AnimatorSet.Builder: Builder after(Animator)>,0,"{
    mReversible = false;
    Node node = getNodeForAnimation(anim);
    mCurrentNode.addParent(node);
    return this;
}","{
    Node node = getNodeForAnimation(anim);
    mCurrentNode.addParent(node);
    return this;
}",1,"/**
 * Sets up the given animation to play when the animation supplied in the
 * {@link AnimatorSet#play(Animator)} call that created this <code>Builder</code> object
 * to start when the animation supplied in this method call ends.
 *
 * @param anim The animation whose end will cause the animation supplied to the
 * {@link AnimatorSet#play(Animator)} method to play.
 */
","/**
 * Sets up the given animation to play when the animation supplied in the
 * {@link AnimatorSet#play(Animator)} call that created this <code>Builder</code> object
 * to start when the animation supplied in this method call ends.
 *
 * @param anim The animation whose end will cause the animation supplied to the
 * {@link AnimatorSet#play(Animator)} method to play.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code change involves the deletion of the statement ""mReversible = false;"" which does not affect the returned value nor the exception handling, so the code change type is 4.","Since the removed statement does not alter what is returned by the method, nor does it introduce a new exception handling, there is no Compatibility Issue. Thus, the CI type is 0."
1024,<android.view.inputmethod.InputContentInfo: Uri getContentUri()>,25,26,<android.view.inputmethod.InputContentInfo: Uri getContentUri()>,<android.view.inputmethod.InputContentInfo: Uri getContentUri()>,0,"{
    return mContentUri;
}","{
    // user ID.
    if (mContentUriOwnerUserId != UserHandle.myUserId()) {
        return ContentProvider.maybeAddUserId(mContentUri, mContentUriOwnerUserId);
    }
    return mContentUri;
}",1,"/**
 * @return Content URI with which the content can be obtained.
 */
","/**
 * @return Content URI with which the content can be obtained.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"1,3,5",1,"The late version implementation adds a condition to check the user ID and may modify the 'mContentUri' using 'ContentProvider.maybeAddUserId()' method before returning the URI which is a dependent API. This introduces both control dependency change and a change in the dependent API besides the change in the return statement, so the change type is 1,3,5.","Since the return value potentially differs depending on the user ID check and the modification by 'ContentProvider.maybeAddUserId()', the late API version could return a different 'Uri' compared to the early version. Thus, the CI type is 1."
1025,<android.util.ArrayMap: void clear()>,25,26,<android.util.ArrayMap: void clear()>,<android.util.ArrayMap: void clear()>,0,"{
    if (mSize > 0) {
        freeArrays(mHashes, mArray, mSize);
        mHashes = EmptyArray.INT;
        mArray = EmptyArray.OBJECT;
        mSize = 0;
    }
}","{
    if (mSize > 0) {
        final int[] ohashes = mHashes;
        final Object[] oarray = mArray;
        final int osize = mSize;
        mHashes = EmptyArray.INT;
        mArray = EmptyArray.OBJECT;
        mSize = 0;
        freeArrays(ohashes, oarray, osize);
    }
    if (CONCURRENT_MODIFICATION_EXCEPTIONS && mSize > 0) {
        throw new ConcurrentModificationException();
    }
}",1,"/**
 * Make the array map empty.  All storage is released.
 */
","/**
 * Make the array map empty.  All storage is released.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"There has been a relocation of the freeArrays call and new variables have been introduced to pass to the freeArrays method. Additionally, a new if condition checking for concurrent modification exceptions has been added, so the code change types are 3 (control dependency change due to the new if condition) and 4 (other statement changed due to the relocation and introduction of new variables).","There is no Compatibility Issue since the changes don't affect the external behavior of the method. The contract of the `clear()` method still ensures that the map is cleared, even though the time at which the internal arrays are freed has changed and the potential for throwing a `ConcurrentModificationException` is introduced but guarded by a flag that needs to be enabled. The API's output remains unchanged in typical usage scenarios."
1026,"<android.view.View: void setFlags(int,int)>",25,26,"<android.view.View: void setFlags(int,int)>","<android.view.View: void setFlags(int,int)>",0,"{
    final boolean accessibilityEnabled = AccessibilityManager.getInstance(mContext).isEnabled();
    final boolean oldIncludeForAccessibility = accessibilityEnabled && includeForAccessibility();
    int old = mViewFlags;
    mViewFlags = (mViewFlags & ~mask) | (flags & mask);
    int changed = mViewFlags ^ old;
    if (changed == 0) {
        return;
    }
    int privateFlags = mPrivateFlags;
    /* Check if the FOCUSABLE bit has changed */
    if (((changed & FOCUSABLE_MASK) != 0) && ((privateFlags & PFLAG_HAS_BOUNDS) != 0)) {
        if (((old & FOCUSABLE_MASK) == FOCUSABLE) && ((privateFlags & PFLAG_FOCUSED) != 0)) {
            /* Give up focus if we are no longer focusable */
            clearFocus();
        } else if (((old & FOCUSABLE_MASK) == NOT_FOCUSABLE) && ((privateFlags & PFLAG_FOCUSED) == 0)) {
            /*
                 * Tell the view system that we are now available to take focus
                 * if no one else already has it.
                 */
            if (mParent != null)
                mParent.focusableViewAvailable(this);
        }
    }
    final int newVisibility = flags & VISIBILITY_MASK;
    if (newVisibility == VISIBLE) {
        if ((changed & VISIBILITY_MASK) != 0) {
            /*
                 * If this view is becoming visible, invalidate it in case it changed while
                 * it was not visible. Marking it drawn ensures that the invalidation will
                 * go through.
                 */
            mPrivateFlags |= PFLAG_DRAWN;
            invalidate(true);
            needGlobalAttributesUpdate(true);
            // the root view try to give this focus if nothing else does.
            if ((mParent != null) && (mBottom > mTop) && (mRight > mLeft)) {
                mParent.focusableViewAvailable(this);
            }
        }
    }
    /* Check if the GONE bit has changed */
    if ((changed & GONE) != 0) {
        needGlobalAttributesUpdate(false);
        requestLayout();
        if (((mViewFlags & VISIBILITY_MASK) == GONE)) {
            if (hasFocus())
                clearFocus();
            clearAccessibilityFocus();
            destroyDrawingCache();
            if (mParent instanceof View) {
                // GONE views noop invalidation, so invalidate the parent
                ((View) mParent).invalidate(true);
            }
            // Mark the view drawn to ensure that it gets invalidated properly the next
            // time it is visible and gets invalidated
            mPrivateFlags |= PFLAG_DRAWN;
        }
        if (mAttachInfo != null) {
            mAttachInfo.mViewVisibilityChanged = true;
        }
    }
    /* Check if the VISIBLE bit has changed */
    if ((changed & INVISIBLE) != 0) {
        needGlobalAttributesUpdate(false);
        /*
             * If this view is becoming invisible, set the DRAWN flag so that
             * the next invalidate() will not be skipped.
             */
        mPrivateFlags |= PFLAG_DRAWN;
        if (((mViewFlags & VISIBILITY_MASK) == INVISIBLE)) {
            // root view becoming invisible shouldn't clear focus and accessibility focus
            if (getRootView() != this) {
                if (hasFocus())
                    clearFocus();
                clearAccessibilityFocus();
            }
        }
        if (mAttachInfo != null) {
            mAttachInfo.mViewVisibilityChanged = true;
        }
    }
    if ((changed & VISIBILITY_MASK) != 0) {
        // If the view is invisible, cleanup its display list to free up resources
        if (newVisibility != VISIBLE && mAttachInfo != null) {
            cleanupDraw();
        }
        if (mParent instanceof ViewGroup) {
            ((ViewGroup) mParent).onChildVisibilityChanged(this, (changed & VISIBILITY_MASK), newVisibility);
            ((View) mParent).invalidate(true);
        } else if (mParent != null) {
            mParent.invalidateChild(this, null);
        }
        if (mAttachInfo != null) {
            dispatchVisibilityChanged(this, newVisibility);
            // to change animation states.
            if (mParent != null && getWindowVisibility() == VISIBLE && ((!(mParent instanceof ViewGroup)) || ((ViewGroup) mParent).isShown())) {
                dispatchVisibilityAggregated(newVisibility == VISIBLE);
            }
            notifySubtreeAccessibilityStateChangedIfNeeded();
        }
    }
    if ((changed & WILL_NOT_CACHE_DRAWING) != 0) {
        destroyDrawingCache();
    }
    if ((changed & DRAWING_CACHE_ENABLED) != 0) {
        destroyDrawingCache();
        mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
        invalidateParentCaches();
    }
    if ((changed & DRAWING_CACHE_QUALITY_MASK) != 0) {
        destroyDrawingCache();
        mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
    }
    if ((changed & DRAW_MASK) != 0) {
        if ((mViewFlags & WILL_NOT_DRAW) != 0) {
            if (mBackground != null || (mForegroundInfo != null && mForegroundInfo.mDrawable != null)) {
                mPrivateFlags &= ~PFLAG_SKIP_DRAW;
            } else {
                mPrivateFlags |= PFLAG_SKIP_DRAW;
            }
        } else {
            mPrivateFlags &= ~PFLAG_SKIP_DRAW;
        }
        requestLayout();
        invalidate(true);
    }
    if ((changed & KEEP_SCREEN_ON) != 0) {
        if (mParent != null && mAttachInfo != null && !mAttachInfo.mRecomputeGlobalAttributes) {
            mParent.recomputeViewAttributes(this);
        }
    }
    if (accessibilityEnabled) {
        if ((changed & FOCUSABLE_MASK) != 0 || (changed & VISIBILITY_MASK) != 0 || (changed & CLICKABLE) != 0 || (changed & LONG_CLICKABLE) != 0 || (changed & CONTEXT_CLICKABLE) != 0) {
            if (oldIncludeForAccessibility != includeForAccessibility()) {
                notifySubtreeAccessibilityStateChangedIfNeeded();
            } else {
                notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_UNDEFINED);
            }
        } else if ((changed & ENABLED_MASK) != 0) {
            notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_UNDEFINED);
        }
    }
}","{
    final boolean accessibilityEnabled = AccessibilityManager.getInstance(mContext).isEnabled();
    final boolean oldIncludeForAccessibility = accessibilityEnabled && includeForAccessibility();
    int old = mViewFlags;
    mViewFlags = (mViewFlags & ~mask) | (flags & mask);
    int changed = mViewFlags ^ old;
    if (changed == 0) {
        return;
    }
    int privateFlags = mPrivateFlags;
    // If focusable is auto, update the FOCUSABLE bit.
    int focusableChangedByAuto = 0;
    if (((mViewFlags & FOCUSABLE_AUTO) != 0) && (changed & (FOCUSABLE_MASK | CLICKABLE)) != 0) {
        // Heuristic only takes into account whether view is clickable.
        final int newFocus;
        if ((mViewFlags & CLICKABLE) != 0) {
            newFocus = FOCUSABLE;
        } else {
            newFocus = NOT_FOCUSABLE;
        }
        mViewFlags = (mViewFlags & ~FOCUSABLE) | newFocus;
        focusableChangedByAuto = (old & FOCUSABLE) ^ (newFocus & FOCUSABLE);
        changed = (changed & ~FOCUSABLE) | focusableChangedByAuto;
    }
    /* Check if the FOCUSABLE bit has changed */
    if (((changed & FOCUSABLE) != 0) && ((privateFlags & PFLAG_HAS_BOUNDS) != 0)) {
        if (((old & FOCUSABLE) == FOCUSABLE) && ((privateFlags & PFLAG_FOCUSED) != 0)) {
            /* Give up focus if we are no longer focusable */
            clearFocus();
        } else if (((old & FOCUSABLE) == NOT_FOCUSABLE) && ((privateFlags & PFLAG_FOCUSED) == 0)) {
            /*
                 * Tell the view system that we are now available to take focus
                 * if no one else already has it.
                 */
            if (mParent != null) {
                ViewRootImpl viewRootImpl = getViewRootImpl();
                if (!sAutoFocusableOffUIThreadWontNotifyParents || focusableChangedByAuto == 0 || viewRootImpl == null || viewRootImpl.mThread == Thread.currentThread()) {
                    mParent.focusableViewAvailable(this);
                }
            }
        }
    }
    final int newVisibility = flags & VISIBILITY_MASK;
    if (newVisibility == VISIBLE) {
        if ((changed & VISIBILITY_MASK) != 0) {
            /*
                 * If this view is becoming visible, invalidate it in case it changed while
                 * it was not visible. Marking it drawn ensures that the invalidation will
                 * go through.
                 */
            mPrivateFlags |= PFLAG_DRAWN;
            invalidate(true);
            needGlobalAttributesUpdate(true);
            // the root view try to give this focus if nothing else does.
            if ((mParent != null)) {
                mParent.focusableViewAvailable(this);
            }
        }
    }
    /* Check if the GONE bit has changed */
    if ((changed & GONE) != 0) {
        needGlobalAttributesUpdate(false);
        requestLayout();
        if (((mViewFlags & VISIBILITY_MASK) == GONE)) {
            if (hasFocus())
                clearFocus();
            clearAccessibilityFocus();
            destroyDrawingCache();
            if (mParent instanceof View) {
                // GONE views noop invalidation, so invalidate the parent
                ((View) mParent).invalidate(true);
            }
            // Mark the view drawn to ensure that it gets invalidated properly the next
            // time it is visible and gets invalidated
            mPrivateFlags |= PFLAG_DRAWN;
        }
        if (mAttachInfo != null) {
            mAttachInfo.mViewVisibilityChanged = true;
        }
    }
    /* Check if the VISIBLE bit has changed */
    if ((changed & INVISIBLE) != 0) {
        needGlobalAttributesUpdate(false);
        /*
             * If this view is becoming invisible, set the DRAWN flag so that
             * the next invalidate() will not be skipped.
             */
        mPrivateFlags |= PFLAG_DRAWN;
        if (((mViewFlags & VISIBILITY_MASK) == INVISIBLE)) {
            // root view becoming invisible shouldn't clear focus and accessibility focus
            if (getRootView() != this) {
                if (hasFocus())
                    clearFocus();
                clearAccessibilityFocus();
            }
        }
        if (mAttachInfo != null) {
            mAttachInfo.mViewVisibilityChanged = true;
        }
    }
    if ((changed & VISIBILITY_MASK) != 0) {
        // If the view is invisible, cleanup its display list to free up resources
        if (newVisibility != VISIBLE && mAttachInfo != null) {
            cleanupDraw();
        }
        if (mParent instanceof ViewGroup) {
            ((ViewGroup) mParent).onChildVisibilityChanged(this, (changed & VISIBILITY_MASK), newVisibility);
            ((View) mParent).invalidate(true);
        } else if (mParent != null) {
            mParent.invalidateChild(this, null);
        }
        if (mAttachInfo != null) {
            dispatchVisibilityChanged(this, newVisibility);
            // to change animation states.
            if (mParent != null && getWindowVisibility() == VISIBLE && ((!(mParent instanceof ViewGroup)) || ((ViewGroup) mParent).isShown())) {
                dispatchVisibilityAggregated(newVisibility == VISIBLE);
            }
            notifySubtreeAccessibilityStateChangedIfNeeded();
        }
    }
    if ((changed & WILL_NOT_CACHE_DRAWING) != 0) {
        destroyDrawingCache();
    }
    if ((changed & DRAWING_CACHE_ENABLED) != 0) {
        destroyDrawingCache();
        mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
        invalidateParentCaches();
    }
    if ((changed & DRAWING_CACHE_QUALITY_MASK) != 0) {
        destroyDrawingCache();
        mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
    }
    if ((changed & DRAW_MASK) != 0) {
        if ((mViewFlags & WILL_NOT_DRAW) != 0) {
            if (mBackground != null || mDefaultFocusHighlight != null || (mForegroundInfo != null && mForegroundInfo.mDrawable != null)) {
                mPrivateFlags &= ~PFLAG_SKIP_DRAW;
            } else {
                mPrivateFlags |= PFLAG_SKIP_DRAW;
            }
        } else {
            mPrivateFlags &= ~PFLAG_SKIP_DRAW;
        }
        requestLayout();
        invalidate(true);
    }
    if ((changed & KEEP_SCREEN_ON) != 0) {
        if (mParent != null && mAttachInfo != null && !mAttachInfo.mRecomputeGlobalAttributes) {
            mParent.recomputeViewAttributes(this);
        }
    }
    if (accessibilityEnabled) {
        if ((changed & FOCUSABLE) != 0 || (changed & VISIBILITY_MASK) != 0 || (changed & CLICKABLE) != 0 || (changed & LONG_CLICKABLE) != 0 || (changed & CONTEXT_CLICKABLE) != 0) {
            if (oldIncludeForAccessibility != includeForAccessibility()) {
                notifySubtreeAccessibilityStateChangedIfNeeded();
            } else {
                notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_UNDEFINED);
            }
        } else if ((changed & ENABLED_MASK) != 0) {
            notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_UNDEFINED);
        }
    }
}",1,"/**
 * Set flags controlling behavior of this view.
 *
 * @param flags Constant indicating the value which should be set
 * @param mask Constant indicating the bit range that should be changed
 */
","/**
 * Set flags controlling behavior of this view.
 *
 * @param flags Constant indicating the value which should be set
 * @param mask Constant indicating the bit range that should be changed
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
1027,"<android.provider.DocumentsContract: Uri renameDocument(ContentResolver,Uri,String)>",25,26,"<android.provider.DocumentsContract: Uri renameDocument(ContentResolver,Uri,String)>","<android.provider.DocumentsContract: Uri renameDocument(ContentResolver,Uri,String)>",0,"{
    final ContentProviderClient client = resolver.acquireUnstableContentProviderClient(documentUri.getAuthority());
    try {
        return renameDocument(client, documentUri, displayName);
    } catch (Exception e) {
        Log.w(TAG, ""Failed to rename document"", e);
        return null;
    } finally {
        ContentProviderClient.releaseQuietly(client);
    }
}","{
    final ContentProviderClient client = resolver.acquireUnstableContentProviderClient(documentUri.getAuthority());
    try {
        return renameDocument(client, documentUri, displayName);
    } catch (Exception e) {
        Log.w(TAG, ""Failed to rename document"", e);
        rethrowIfNecessary(resolver, e);
        return null;
    } finally {
        ContentProviderClient.releaseQuietly(client);
    }
}",1,"/**
 * Change the display name of an existing document.
 * <p>
 * If the underlying provider needs to create a new
 * {@link Document#COLUMN_DOCUMENT_ID} to represent the updated display
 * name, that new document is returned and the original document is no
 * longer valid. Otherwise, the original document is returned.
 *
 * @param documentUri document with {@link Document#FLAG_SUPPORTS_RENAME}
 * @param displayName updated name for document
 * @return the existing or new document after the rename, or {@code null} if
 * failed.
 */
","/**
 * Change the display name of an existing document.
 * <p>
 * If the underlying provider needs to create a new
 * {@link Document#COLUMN_DOCUMENT_ID} to represent the updated display
 * name, that new document is returned and the original document is no
 * longer valid. Otherwise, the original document is returned.
 *
 * @param documentUri document with {@link Document#FLAG_SUPPORTS_RENAME}
 * @param displayName updated name for document
 * @return the existing or new document after the rename, or {@code null} if
 * failed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"The code change includes the addition of a new method call ""rethrowIfNecessary(resolver, e)"" within the catch block, which is considered a change in exception handling statement (2), and since it's a new method call, it also falls under other statement changed (4).","The addition of the ""rethrowIfNecessary"" method call within the exception handling block could potentially alter the exceptions that are being thrown, leading to a change in the behavior of method related to how exceptions are handled. Specifically, if ""rethrowIfNecessary"" throws a new type of exception or modifies the thrown exception, it could result in different exception handling by clients of the API. Therefore, the CI type is 2 due to the potential different exception handling."
1028,<android.animation.ValueAnimator: ValueAnimator clone()>,25,26,<android.animation.ValueAnimator: ValueAnimator clone()>,<android.animation.ValueAnimator: ValueAnimator clone()>,0,"{
    final ValueAnimator anim = (ValueAnimator) super.clone();
    if (mUpdateListeners != null) {
        anim.mUpdateListeners = new ArrayList<AnimatorUpdateListener>(mUpdateListeners);
    }
    anim.mSeekFraction = -1;
    anim.mReversing = false;
    anim.mInitialized = false;
    anim.mStarted = false;
    anim.mRunning = false;
    anim.mPaused = false;
    anim.mResumed = false;
    anim.mStartListenersCalled = false;
    anim.mStartTime = 0;
    anim.mStartTimeCommitted = false;
    anim.mAnimationEndRequested = false;
    anim.mPauseTime = 0;
    anim.mLastFrameTime = 0;
    anim.mOverallFraction = 0;
    anim.mCurrentFraction = 0;
    PropertyValuesHolder[] oldValues = mValues;
    if (oldValues != null) {
        int numValues = oldValues.length;
        anim.mValues = new PropertyValuesHolder[numValues];
        anim.mValuesMap = new HashMap<String, PropertyValuesHolder>(numValues);
        for (int i = 0; i < numValues; ++i) {
            PropertyValuesHolder newValuesHolder = oldValues[i].clone();
            anim.mValues[i] = newValuesHolder;
            anim.mValuesMap.put(newValuesHolder.getPropertyName(), newValuesHolder);
        }
    }
    return anim;
}","{
    final ValueAnimator anim = (ValueAnimator) super.clone();
    if (mUpdateListeners != null) {
        anim.mUpdateListeners = new ArrayList<AnimatorUpdateListener>(mUpdateListeners);
    }
    anim.mSeekFraction = -1;
    anim.mReversing = false;
    anim.mInitialized = false;
    anim.mStarted = false;
    anim.mRunning = false;
    anim.mPaused = false;
    anim.mResumed = false;
    anim.mStartListenersCalled = false;
    anim.mStartTime = -1;
    anim.mStartTimeCommitted = false;
    anim.mAnimationEndRequested = false;
    anim.mPauseTime = -1;
    anim.mLastFrameTime = -1;
    anim.mFirstFrameTime = -1;
    anim.mOverallFraction = 0;
    anim.mCurrentFraction = 0;
    anim.mSelfPulse = true;
    anim.mSuppressSelfPulseRequested = false;
    PropertyValuesHolder[] oldValues = mValues;
    if (oldValues != null) {
        int numValues = oldValues.length;
        anim.mValues = new PropertyValuesHolder[numValues];
        anim.mValuesMap = new HashMap<String, PropertyValuesHolder>(numValues);
        for (int i = 0; i < numValues; ++i) {
            PropertyValuesHolder newValuesHolder = oldValues[i].clone();
            anim.mValues[i] = newValuesHolder;
            anim.mValuesMap.put(newValuesHolder.getPropertyName(), newValuesHolder);
        }
    }
    return anim;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"There are changes to variable assignments (`startTime`, `pauseTime`, `lastFrameTime`, `firstFrameTime`, `selfPulse`, `suppressSelfPulseRequested`), but all these assignments are to default or reset values and do not affect the return type or introduce new exception handling, so the code change type is 4.","The changes in the variable assignments don't lead to different returned values or change exception handling, the return statement still returns a cloned instance with updated but consistent fields. Therefore, there is no Compatibility Issue, hence the CI type is 0."
1030,"<android.provider.Settings.Global: boolean putString(ContentResolver,String,String)>",25,26,"<android.provider.Settings.Global: boolean putString(ContentResolver,String,String)>","<android.provider.Settings.Global: boolean putString(ContentResolver,String,String)>",0,"{
    return putStringForUser(resolver, name, value, UserHandle.myUserId());
}","{
    return putStringForUser(resolver, name, value, null, false, UserHandle.myUserId());
}",1,"/**
 * Store a name/value pair into the database.
 * @param resolver to access the database with
 * @param name to store
 * @param value to associate with the name
 * @return true if the value was set, false on database errors
 */
","/**
 * Store a name/value pair into the database.
 * @param resolver to access the database with
 * @param name to store
 * @param value to associate with the name
 * @return true if the value was set, false on database errors
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The change is in the call to the dependent API `putStringForUser` method which now includes additional parameters, so the code change type is 5.","There's no compatibility issue from the perspective of the current API's signature and behavior, as the additional parameters do not alter the return type or the exceptions that are thrown from the perspective of the `putString` method user. The underlying change is an internal detail assuming the implementation of `putStringForUser` correctly handles the new parameters and maintains backward compatibility. Thus, the CI type is 0."
1031,<android.app.Notification.Action: Action clone()>,25,26,<android.app.Notification.Action: Action clone()>,<android.app.Notification.Action: Action clone()>,0,"{
    return new Action(getIcon(), title, // safe to alias
    actionIntent, new Bundle(mExtras), getRemoteInputs(), getAllowGeneratedReplies());
}","{
    return new Action(getIcon(), title, // safe to alias
    actionIntent, mExtras == null ? new Bundle() : new Bundle(mExtras), getRemoteInputs(), getAllowGeneratedReplies());
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The way the 'Bundle' instance is created has changed; in the early implementation, the constructor is always called with 'mExtras' whereas in the late implementation, it checks for 'mExtras == null' before deciding how to construct the 'Bundle', and a new 'Bundle' is created if 'mExtras' is null. So this is a change in how a dependent object is instantiated (type 4), and since it's part of the return statement it's also a type 1 change.","A Compatibility Issue could arise because depending on whether 'mExtras' is null or not, a different 'Bundle' instance will be passed to the new 'Action' instance in the late version. Therefore, there is a potential for a different outcome (a newly created empty Bundle instead of possibly reusing 'mExtras'), so the CI type is 1."
1032,<android.animation.AnimatorSet: void setStartDelay(long)>,25,26,<android.animation.AnimatorSet: void setStartDelay(long)>,<android.animation.AnimatorSet: void setStartDelay(long)>,0,"{
    // Clamp start delay to non-negative range.
    if (startDelay < 0) {
        Log.w(TAG, ""Start delay should always be non-negative"");
        startDelay = 0;
    }
    long delta = startDelay - mStartDelay;
    if (delta == 0) {
        return;
    }
    mStartDelay = startDelay;
    if (mStartDelay > 0) {
        mReversible = false;
    }
    if (!mDependencyDirty) {
        // Dependency graph already constructed, update all the nodes' start/end time
        int size = mNodes.size();
        for (int i = 0; i < size; i++) {
            Node node = mNodes.get(i);
            if (node == mRootNode) {
                node.mEndTime = mStartDelay;
            } else {
                node.mStartTime = node.mStartTime == DURATION_INFINITE ? DURATION_INFINITE : node.mStartTime + delta;
                node.mEndTime = node.mEndTime == DURATION_INFINITE ? DURATION_INFINITE : node.mEndTime + delta;
            }
        }
        // Update total duration, if necessary.
        if (mTotalDuration != DURATION_INFINITE) {
            mTotalDuration += delta;
        }
    }
}","{
    // Clamp start delay to non-negative range.
    if (startDelay < 0) {
        Log.w(TAG, ""Start delay should always be non-negative"");
        startDelay = 0;
    }
    long delta = startDelay - mStartDelay;
    if (delta == 0) {
        return;
    }
    mStartDelay = startDelay;
    if (!mDependencyDirty) {
        // Dependency graph already constructed, update all the nodes' start/end time
        int size = mNodes.size();
        for (int i = 0; i < size; i++) {
            Node node = mNodes.get(i);
            if (node == mRootNode) {
                node.mEndTime = mStartDelay;
            } else {
                node.mStartTime = node.mStartTime == DURATION_INFINITE ? DURATION_INFINITE : node.mStartTime + delta;
                node.mEndTime = node.mEndTime == DURATION_INFINITE ? DURATION_INFINITE : node.mEndTime + delta;
            }
        }
        // Update total duration, if necessary.
        if (mTotalDuration != DURATION_INFINITE) {
            mTotalDuration += delta;
        }
    }
}",1,"/**
 * The amount of time, in milliseconds, to delay starting the animation after
 * {@link #start()} is called. Note that the start delay should always be non-negative. Any
 * negative start delay will be clamped to 0 on N and above.
 *
 * @param startDelay The amount of the delay, in milliseconds
 */
","/**
 * The amount of time, in milliseconds, to delay starting the animation after
 * {@link #start()} is called. Note that the start delay should always be non-negative. Any
 * negative start delay will be clamped to 0 on N and above.
 *
 * @param startDelay The amount of the delay, in milliseconds
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The change between the two versions is the removal of `if (mStartDelay > 0) { mReversible = false; }`. This is an 'Other statement change', so the code change type is 4.","The removed line does not affect the return value or the exception handling of the method; only the internal state of the object is affected. Therefore, there is no change in the behavior of the method as perceived from outside, so there is no Compatibility Issue, making the CI type 0."
1034,"<android.transition.ChangeClipBounds: Animator createAnimator(ViewGroup,TransitionValues,TransitionValues)>",25,26,"<android.transition.ChangeClipBounds: Animator createAnimator(ViewGroup,TransitionValues,TransitionValues)>","<android.transition.ChangeClipBounds: Animator createAnimator(ViewGroup,TransitionValues,TransitionValues)>",0,"{
    if (startValues == null || endValues == null || !startValues.values.containsKey(PROPNAME_CLIP) || !endValues.values.containsKey(PROPNAME_CLIP)) {
        return null;
    }
    Rect start = (Rect) startValues.values.get(PROPNAME_CLIP);
    Rect end = (Rect) endValues.values.get(PROPNAME_CLIP);
    if (start == null && end == null) {
        // No animation required since there is no clip.
        return null;
    }
    if (start == null) {
        start = (Rect) startValues.values.get(PROPNAME_BOUNDS);
    } else if (end == null) {
        end = (Rect) endValues.values.get(PROPNAME_BOUNDS);
    }
    if (start.equals(end)) {
        return null;
    }
    endValues.view.setClipBounds(start);
    RectEvaluator evaluator = new RectEvaluator(new Rect());
    return ObjectAnimator.ofObject(endValues.view, ""clipBounds"", evaluator, start, end);
}","{
    if (startValues == null || endValues == null || !startValues.values.containsKey(PROPNAME_CLIP) || !endValues.values.containsKey(PROPNAME_CLIP)) {
        return null;
    }
    Rect start = (Rect) startValues.values.get(PROPNAME_CLIP);
    Rect end = (Rect) endValues.values.get(PROPNAME_CLIP);
    boolean endIsNull = end == null;
    if (start == null && end == null) {
        // No animation required since there is no clip.
        return null;
    }
    if (start == null) {
        start = (Rect) startValues.values.get(PROPNAME_BOUNDS);
    } else if (end == null) {
        end = (Rect) endValues.values.get(PROPNAME_BOUNDS);
    }
    if (start.equals(end)) {
        return null;
    }
    endValues.view.setClipBounds(start);
    RectEvaluator evaluator = new RectEvaluator(new Rect());
    ObjectAnimator animator = ObjectAnimator.ofObject(endValues.view, ""clipBounds"", evaluator, start, end);
    if (endIsNull) {
        final View endView = endValues.view;
        animator.addListener(new AnimatorListenerAdapter() {

            @Override
            public void onAnimationEnd(Animator animation) {
                endView.setClipBounds(null);
            }
        });
    }
    return animator;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The control dependency has changed by adding an `if` block that checks the `endIsNull` condition, and other statements have been added inside this `if` block. Additionally, the return statement has been modified to return an `ObjectAnimator` with an added listener if `endIsNull` is true. The change does not affect other parts of code directly involved in the return statement outside the newly added `if` block, which corresponds to code change type 3,4.","The newly introduced logic does not result in a compatibility issue. The additional `AnimatorListenerAdapter` only affects the state of the `endView` once the animation ends, setting its clip bounds to null which would have occurred regardless as the `end` was initially null. The conditions that would return null are unchanged, and the objects ultimately returned, `ObjectAnimator`, would behave the same way without the listener for the cases where `end != null`. Thus, we can say that there is no compatibility issue (0)."
1035,<android.net.NetworkStats.Entry: String toString()>,25,26,<android.net.NetworkStats.Entry: String toString()>,<android.net.NetworkStats.Entry: String toString()>,0,"{
    final StringBuilder builder = new StringBuilder();
    builder.append(""iface="").append(iface);
    builder.append("" uid="").append(uid);
    builder.append("" set="").append(setToString(set));
    builder.append("" tag="").append(tagToString(tag));
    builder.append("" roaming="").append(roamingToString(roaming));
    builder.append("" rxBytes="").append(rxBytes);
    builder.append("" rxPackets="").append(rxPackets);
    builder.append("" txBytes="").append(txBytes);
    builder.append("" txPackets="").append(txPackets);
    builder.append("" operations="").append(operations);
    return builder.toString();
}","{
    final StringBuilder builder = new StringBuilder();
    builder.append(""iface="").append(iface);
    builder.append("" uid="").append(uid);
    builder.append("" set="").append(setToString(set));
    builder.append("" tag="").append(tagToString(tag));
    builder.append("" metered="").append(meteredToString(metered));
    builder.append("" roaming="").append(roamingToString(roaming));
    builder.append("" rxBytes="").append(rxBytes);
    builder.append("" rxPackets="").append(rxPackets);
    builder.append("" txBytes="").append(txBytes);
    builder.append("" txPackets="").append(txPackets);
    builder.append("" operations="").append(operations);
    return builder.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"In the late version, a new StringBuilder append sequence has been added: builder.append("" metered="").append(meteredToString(metered));, which does not affect any control or return statements, and it does not change the method signature or introduce potential changes in exceptions thrown. So, the code change type is 4.","Although the method's body has changed, adding supplementary information to the string representation does not affect the behavior of the method in a way that would cause issues with backward compatibility. It does not change the method signature, alter the control flow, or introduce new exceptions. Thus, there is no Compatibility Issue."
1036,"<android.app.Activity: boolean startNextMatchingActivity(Intent,Bundle)>",25,26,"<android.app.Activity: boolean startNextMatchingActivity(Intent,Bundle)>","<android.app.Activity: boolean startNextMatchingActivity(Intent,Bundle)>",0,"{
    if (mParent == null) {
        try {
            intent.migrateExtraStreamToClipData();
            intent.prepareToLeaveProcess(this);
            return ActivityManagerNative.getDefault().startNextMatchingActivity(mToken, intent, options);
        } catch (RemoteException e) {
        // Empty
        }
        return false;
    }
    throw new UnsupportedOperationException(""startNextMatchingActivity can only be called from a top-level activity"");
}","{
    if (mParent == null) {
        try {
            intent.migrateExtraStreamToClipData();
            intent.prepareToLeaveProcess(this);
            return ActivityManager.getService().startNextMatchingActivity(mToken, intent, options);
        } catch (RemoteException e) {
        // Empty
        }
        return false;
    }
    throw new UnsupportedOperationException(""startNextMatchingActivity can only be called from a top-level activity"");
}",1,"/**
 * Special version of starting an activity, for use when you are replacing
 * other activity components.  You can use this to hand the Intent off
 * to the next Activity that can handle it.  You typically call this in
 * {@link #onCreate} with the Intent returned by {@link #getIntent}.
 *
 * @param intent The intent to dispatch to the next activity.  For
 * correct behavior, this must be the same as the Intent that started
 * your own activity; the only changes you can make are to the extras
 * inside of it.
 * @param options Additional options for how the Activity should be started.
 * See {@link android.content.Context#startActivity(Intent, Bundle)
 * Context.startActivity(Intent, Bundle)} for more details.
 *
 * @return Returns a boolean indicating whether there was another Activity
 * to start: true if there was a next activity to start, false if there
 * wasn't.  In general, if true is returned you will then want to call
 * finish() on yourself.
 */
","/**
 * Special version of starting an activity, for use when you are replacing
 * other activity components.  You can use this to hand the Intent off
 * to the next Activity that can handle it.  You typically call this in
 * {@link #onCreate} with the Intent returned by {@link #getIntent}.
 *
 * @param intent The intent to dispatch to the next activity.  For
 * correct behavior, this must be the same as the Intent that started
 * your own activity; the only changes you can make are to the extras
 * inside of it.
 * @param options Additional options for how the Activity should be started.
 * See {@link android.content.Context#startActivity(Intent, Bundle)}
 * Context.startActivity(Intent, Bundle)} for more details.
 *
 * @return Returns a boolean indicating whether there was another Activity
 * to start: true if there was a next activity to start, false if there
 * wasn't.  In general, if true is returned you will then want to call
 * finish() on yourself.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method called on ActivityManager has changed from ActivityManagerNative.getDefault().startNextMatchingActivity(...) to ActivityManager.getService().startNextMatchingActivity(...). The change indicates a potential dependent API change, which corresponds to code change type 5.","The replacement of ActivityManagerNative.getDefault() with ActivityManager.getService() does not indicate a change in the behavior of the method, as these are typically just different ways to obtain a reference to the ActivityManager service instance. As there is no change in the control flow, return value, or exception handling, there is no compatibility issue due to this change. Thus, the CI type is 0."
1037,<android.accessibilityservice.AccessibilityService: AccessibilityNodeInfo findFocus(int)>,25,26,<android.accessibilityservice.AccessibilityService: AccessibilityNodeInfo findFocus(int)>,<android.accessibilityservice.AccessibilityService: AccessibilityNodeInfo findFocus(int)>,0,"{
    return AccessibilityInteractionClient.getInstance().findFocus(mConnectionId, AccessibilityNodeInfo.ANY_WINDOW_ID, AccessibilityNodeInfo.ROOT_NODE_ID, focus);
}","{
    return AccessibilityInteractionClient.getInstance().findFocus(mConnectionId, AccessibilityWindowInfo.ANY_WINDOW_ID, AccessibilityNodeInfo.ROOT_NODE_ID, focus);
}",1,"/**
 * Find the view that has the specified focus type. The search is performed
 * across all windows.
 * <p>
 * <strong>Note:</strong> In order to access the windows your service has
 * to declare the capability to retrieve window content by setting the
 * {@link android.R.styleable#AccessibilityService_canRetrieveWindowContent}
 * property in its meta-data. For details refer to {@link #SERVICE_META_DATA}.
 * Also the service has to opt-in to retrieve the interactive windows by
 * setting the {@link AccessibilityServiceInfo#FLAG_RETRIEVE_INTERACTIVE_WINDOWS}
 * flag. Otherwise, the search will be performed only in the active window.
 * </p>
 *
 * @param focus The focus to find. One of {@link AccessibilityNodeInfo#FOCUS_INPUT} or
 * {@link AccessibilityNodeInfo#FOCUS_ACCESSIBILITY}.
 * @return The node info of the focused view or null.
 *
 * @see AccessibilityNodeInfo#FOCUS_INPUT
 * @see AccessibilityNodeInfo#FOCUS_ACCESSIBILITY
 */
","/**
 * Find the view that has the specified focus type. The search is performed
 * across all windows.
 * <p>
 * <strong>Note:</strong> In order to access the windows your service has
 * to declare the capability to retrieve window content by setting the
 * {@link android.R.styleable#AccessibilityService_canRetrieveWindowContent}
 * property in its meta-data. For details refer to {@link #SERVICE_META_DATA}.
 * Also the service has to opt-in to retrieve the interactive windows by
 * setting the {@link AccessibilityServiceInfo#FLAG_RETRIEVE_INTERACTIVE_WINDOWS}
 * flag. Otherwise, the search will be performed only in the active window.
 * </p>
 *
 * @param focus The focus to find. One of {@link AccessibilityNodeInfo#FOCUS_INPUT} or
 * {@link AccessibilityNodeInfo#FOCUS_ACCESSIBILITY}.
 * @return The node info of the focused view or null.
 *
 * @see AccessibilityNodeInfo#FOCUS_INPUT
 * @see AccessibilityNodeInfo#FOCUS_ACCESSIBILITY
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method parameter has been changed from AccessibilityNodeInfo.ANY_WINDOW_ID to AccessibilityWindowInfo.ANY_WINDOW_ID in the call to findFocus(), so the code change type is 5 since it's a change in the dependent API.","There is no direct Compatibility Issue because the change is within the dependent API, not the API itself, as long as AccessibilityWindowInfo.ANY_WINDOW_ID provides the same guarantee as AccessibilityNodeInfo.ANY_WINDOW_ID used to. If these constants' values are the same and the behavior of the findFocus() method in AccessibilityInteractionClient remains consistent with this change in constant value, there would be no change in the behavior of the findFocus() method in the AccessibilityService. Assuming that AccessibilityWindowInfo.ANY_WINDOW_ID is meant to replace AccessibilityNodeInfo.ANY_WINDOW_ID without altering functionality, the CI type is 0."
1040,"<android.app.SharedPreferencesImpl: long getLong(String,long)>",25,26,"<android.app.SharedPreferencesImpl: long getLong(String,long)>","<android.app.SharedPreferencesImpl: long getLong(String,long)>",0,"{
    synchronized (this) {
        awaitLoadedLocked();
        Long v = (Long) mMap.get(key);
        return v != null ? v : defValue;
    }
}","{
    synchronized (mLock) {
        awaitLoadedLocked();
        Long v = (Long) mMap.get(key);
        return v != null ? v : defValue;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change in the code is the object on which the 'synchronized' block is locking - it changed from 'this' to 'mLock'. This is an internal change to the synchronizing object and does not affect the return value or exception handling of the method, so the code change type is 4.","Since the modification does not affect the behavior of the API in terms of returning different values or throwing different exceptions, there is no Compatibility Issue, thus the CI type is 0."
1042,<android.animation.IntKeyframeSet: int getIntValue(float)>,25,26,<android.animation.IntKeyframeSet: int getIntValue(float)>,<android.animation.IntKeyframeSet: int getIntValue(float)>,0,"{
    if (mNumKeyframes == 2) {
        if (firstTime) {
            firstTime = false;
            firstValue = ((IntKeyframe) mKeyframes.get(0)).getIntValue();
            lastValue = ((IntKeyframe) mKeyframes.get(1)).getIntValue();
            deltaValue = lastValue - firstValue;
        }
        if (mInterpolator != null) {
            fraction = mInterpolator.getInterpolation(fraction);
        }
        if (mEvaluator == null) {
            return firstValue + (int) (fraction * deltaValue);
        } else {
            return ((Number) mEvaluator.evaluate(fraction, firstValue, lastValue)).intValue();
        }
    }
    if (fraction <= 0f) {
        final IntKeyframe prevKeyframe = (IntKeyframe) mKeyframes.get(0);
        final IntKeyframe nextKeyframe = (IntKeyframe) mKeyframes.get(1);
        int prevValue = prevKeyframe.getIntValue();
        int nextValue = nextKeyframe.getIntValue();
        float prevFraction = prevKeyframe.getFraction();
        float nextFraction = nextKeyframe.getFraction();
        final TimeInterpolator interpolator = nextKeyframe.getInterpolator();
        if (interpolator != null) {
            fraction = interpolator.getInterpolation(fraction);
        }
        float intervalFraction = (fraction - prevFraction) / (nextFraction - prevFraction);
        return mEvaluator == null ? prevValue + (int) (intervalFraction * (nextValue - prevValue)) : ((Number) mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).intValue();
    } else if (fraction >= 1f) {
        final IntKeyframe prevKeyframe = (IntKeyframe) mKeyframes.get(mNumKeyframes - 2);
        final IntKeyframe nextKeyframe = (IntKeyframe) mKeyframes.get(mNumKeyframes - 1);
        int prevValue = prevKeyframe.getIntValue();
        int nextValue = nextKeyframe.getIntValue();
        float prevFraction = prevKeyframe.getFraction();
        float nextFraction = nextKeyframe.getFraction();
        final TimeInterpolator interpolator = nextKeyframe.getInterpolator();
        if (interpolator != null) {
            fraction = interpolator.getInterpolation(fraction);
        }
        float intervalFraction = (fraction - prevFraction) / (nextFraction - prevFraction);
        return mEvaluator == null ? prevValue + (int) (intervalFraction * (nextValue - prevValue)) : ((Number) mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).intValue();
    }
    IntKeyframe prevKeyframe = (IntKeyframe) mKeyframes.get(0);
    for (int i = 1; i < mNumKeyframes; ++i) {
        IntKeyframe nextKeyframe = (IntKeyframe) mKeyframes.get(i);
        if (fraction < nextKeyframe.getFraction()) {
            final TimeInterpolator interpolator = nextKeyframe.getInterpolator();
            float intervalFraction = (fraction - prevKeyframe.getFraction()) / (nextKeyframe.getFraction() - prevKeyframe.getFraction());
            int prevValue = prevKeyframe.getIntValue();
            int nextValue = nextKeyframe.getIntValue();
            // Apply interpolator on the proportional duration.
            if (interpolator != null) {
                intervalFraction = interpolator.getInterpolation(intervalFraction);
            }
            return mEvaluator == null ? prevValue + (int) (intervalFraction * (nextValue - prevValue)) : ((Number) mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).intValue();
        }
        prevKeyframe = nextKeyframe;
    }
    // shouldn't get here
    return ((Number) mKeyframes.get(mNumKeyframes - 1).getValue()).intValue();
}","{
    if (fraction <= 0f) {
        final IntKeyframe prevKeyframe = (IntKeyframe) mKeyframes.get(0);
        final IntKeyframe nextKeyframe = (IntKeyframe) mKeyframes.get(1);
        int prevValue = prevKeyframe.getIntValue();
        int nextValue = nextKeyframe.getIntValue();
        float prevFraction = prevKeyframe.getFraction();
        float nextFraction = nextKeyframe.getFraction();
        final TimeInterpolator interpolator = nextKeyframe.getInterpolator();
        if (interpolator != null) {
            fraction = interpolator.getInterpolation(fraction);
        }
        float intervalFraction = (fraction - prevFraction) / (nextFraction - prevFraction);
        return mEvaluator == null ? prevValue + (int) (intervalFraction * (nextValue - prevValue)) : ((Number) mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).intValue();
    } else if (fraction >= 1f) {
        final IntKeyframe prevKeyframe = (IntKeyframe) mKeyframes.get(mNumKeyframes - 2);
        final IntKeyframe nextKeyframe = (IntKeyframe) mKeyframes.get(mNumKeyframes - 1);
        int prevValue = prevKeyframe.getIntValue();
        int nextValue = nextKeyframe.getIntValue();
        float prevFraction = prevKeyframe.getFraction();
        float nextFraction = nextKeyframe.getFraction();
        final TimeInterpolator interpolator = nextKeyframe.getInterpolator();
        if (interpolator != null) {
            fraction = interpolator.getInterpolation(fraction);
        }
        float intervalFraction = (fraction - prevFraction) / (nextFraction - prevFraction);
        return mEvaluator == null ? prevValue + (int) (intervalFraction * (nextValue - prevValue)) : ((Number) mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).intValue();
    }
    IntKeyframe prevKeyframe = (IntKeyframe) mKeyframes.get(0);
    for (int i = 1; i < mNumKeyframes; ++i) {
        IntKeyframe nextKeyframe = (IntKeyframe) mKeyframes.get(i);
        if (fraction < nextKeyframe.getFraction()) {
            final TimeInterpolator interpolator = nextKeyframe.getInterpolator();
            float intervalFraction = (fraction - prevKeyframe.getFraction()) / (nextKeyframe.getFraction() - prevKeyframe.getFraction());
            int prevValue = prevKeyframe.getIntValue();
            int nextValue = nextKeyframe.getIntValue();
            // Apply interpolator on the proportional duration.
            if (interpolator != null) {
                intervalFraction = interpolator.getInterpolation(intervalFraction);
            }
            return mEvaluator == null ? prevValue + (int) (intervalFraction * (nextValue - prevValue)) : ((Number) mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).intValue();
        }
        prevKeyframe = nextKeyframe;
    }
    // shouldn't get here
    return ((Number) mKeyframes.get(mNumKeyframes - 1).getValue()).intValue();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
1043,"<android.app.WallpaperManager: int setStream(InputStream,Rect,boolean)>",25,26,"<android.app.WallpaperManager: int setStream(InputStream,Rect,boolean)>","<android.app.WallpaperManager: int setStream(InputStream,Rect,boolean)>",0,"{
    return setStream(bitmapData, visibleCropHint, allowBackup, FLAG_SYSTEM);
}","{
    return setStream(bitmapData, visibleCropHint, allowBackup, FLAG_SYSTEM | FLAG_LOCK);
}",1,"/**
 * Change the current system wallpaper to a specific byte stream, specifying a
 * hint about which subrectangle of the full image is to be visible.  The OS will
 * then try to best present the given portion of the full image as the static system
 * wallpaper image.  The data from the given InputStream is copied into persistent
 * storage and will then be used as the system wallpaper.  Currently the data must
 * be either a JPEG or PNG image.  On success, the intent
 * {@link Intent#ACTION_WALLPAPER_CHANGED} is broadcast.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#SET_WALLPAPER}.
 *
 * @param bitmapData A stream containing the raw data to install as a wallpaper.  This
 * data can be in any format handled by {@link BitmapRegionDecoder}.
 * @param visibleCropHint The rectangular subregion of the streamed image that should be
 * displayed as wallpaper.  Passing {@code null} for this parameter means that
 * the full image should be displayed if possible given the image's and device's
 * aspect ratios, etc.
 * @param allowBackup {@code true} if the OS is permitted to back up this wallpaper
 * image for restore to a future device; {@code false} otherwise.
 * @return An integer ID assigned to the newly active wallpaper; or zero on failure.
 *
 * @see #getWallpaperId(int)
 *
 * @throws IOException If an error occurs when attempting to set the wallpaper
 * based on the provided image data.
 * @throws IllegalArgumentException If the {@code visibleCropHint} rectangle is
 * empty or invalid.
 */
","/**
 * Change the current system wallpaper to a specific byte stream, specifying a
 * hint about which subrectangle of the full image is to be visible.  The OS will
 * then try to best present the given portion of the full image as the static system
 * wallpaper image.  The data from the given InputStream is copied into persistent
 * storage and will then be used as the system wallpaper.  Currently the data must
 * be either a JPEG or PNG image.  On success, the intent
 * {@link Intent#ACTION_WALLPAPER_CHANGED} is broadcast.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#SET_WALLPAPER}.
 *
 * @param bitmapData A stream containing the raw data to install as a wallpaper.  This
 * data can be in any format handled by {@link BitmapRegionDecoder}.
 * @param visibleCropHint The rectangular subregion of the streamed image that should be
 * displayed as wallpaper.  Passing {@code null} for this parameter means that
 * the full image should be displayed if possible given the image's and device's
 * aspect ratios, etc.
 * @param allowBackup {@code true} if the OS is permitted to back up this wallpaper
 * image for restore to a future device; {@code false} otherwise.
 * @return An integer ID assigned to the newly active wallpaper; or zero on failure.
 *
 * @see #getWallpaperId(int)
 *
 * @throws IOException If an error occurs when attempting to set the wallpaper
 * based on the provided image data.
 * @throws IllegalArgumentException If the {@code visibleCropHint} rectangle is
 * empty or invalid.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The setStream method has changed the flags passed to it by adding FLAG_LOCK to FLAG_SYSTEM flag, which modifies the behavior by setting additional flag(s).","As a new flag (FLAG_LOCK) has been added to the flags passed to setStream, this can potentially lead to different behavior as the method might perform actions or checks based on these flags. Therefore, the CI type is 1."
1044,<android.widget.AbsListView.PositionScroller: void run()>,25,26,<android.widget.AbsListView.PositionScroller: void run()>,<android.widget.AbsListView.PositionScroller: void run()>,0,"{
    final int listHeight = getHeight();
    final int firstPos = mFirstPosition;
    switch(mMode) {
        case MOVE_DOWN_POS:
            {
                final int lastViewIndex = getChildCount() - 1;
                final int lastPos = firstPos + lastViewIndex;
                if (lastViewIndex < 0) {
                    return;
                }
                if (lastPos == mLastSeenPos) {
                    // No new views, let things keep going.
                    postOnAnimation(this);
                    return;
                }
                final View lastView = getChildAt(lastViewIndex);
                final int lastViewHeight = lastView.getHeight();
                final int lastViewTop = lastView.getTop();
                final int lastViewPixelsShowing = listHeight - lastViewTop;
                final int extraScroll = lastPos < mItemCount - 1 ? Math.max(mListPadding.bottom, mExtraScroll) : mListPadding.bottom;
                final int scrollBy = lastViewHeight - lastViewPixelsShowing + extraScroll;
                smoothScrollBy(scrollBy, mScrollDuration, true);
                mLastSeenPos = lastPos;
                if (lastPos < mTargetPos) {
                    postOnAnimation(this);
                }
                break;
            }
        case MOVE_DOWN_BOUND:
            {
                final int nextViewIndex = 1;
                final int childCount = getChildCount();
                if (firstPos == mBoundPos || childCount <= nextViewIndex || firstPos + childCount >= mItemCount) {
                    return;
                }
                final int nextPos = firstPos + nextViewIndex;
                if (nextPos == mLastSeenPos) {
                    // No new views, let things keep going.
                    postOnAnimation(this);
                    return;
                }
                final View nextView = getChildAt(nextViewIndex);
                final int nextViewHeight = nextView.getHeight();
                final int nextViewTop = nextView.getTop();
                final int extraScroll = Math.max(mListPadding.bottom, mExtraScroll);
                if (nextPos < mBoundPos) {
                    smoothScrollBy(Math.max(0, nextViewHeight + nextViewTop - extraScroll), mScrollDuration, true);
                    mLastSeenPos = nextPos;
                    postOnAnimation(this);
                } else {
                    if (nextViewTop > extraScroll) {
                        smoothScrollBy(nextViewTop - extraScroll, mScrollDuration, true);
                    }
                }
                break;
            }
        case MOVE_UP_POS:
            {
                if (firstPos == mLastSeenPos) {
                    // No new views, let things keep going.
                    postOnAnimation(this);
                    return;
                }
                final View firstView = getChildAt(0);
                if (firstView == null) {
                    return;
                }
                final int firstViewTop = firstView.getTop();
                final int extraScroll = firstPos > 0 ? Math.max(mExtraScroll, mListPadding.top) : mListPadding.top;
                smoothScrollBy(firstViewTop - extraScroll, mScrollDuration, true);
                mLastSeenPos = firstPos;
                if (firstPos > mTargetPos) {
                    postOnAnimation(this);
                }
                break;
            }
        case MOVE_UP_BOUND:
            {
                final int lastViewIndex = getChildCount() - 2;
                if (lastViewIndex < 0) {
                    return;
                }
                final int lastPos = firstPos + lastViewIndex;
                if (lastPos == mLastSeenPos) {
                    // No new views, let things keep going.
                    postOnAnimation(this);
                    return;
                }
                final View lastView = getChildAt(lastViewIndex);
                final int lastViewHeight = lastView.getHeight();
                final int lastViewTop = lastView.getTop();
                final int lastViewPixelsShowing = listHeight - lastViewTop;
                final int extraScroll = Math.max(mListPadding.top, mExtraScroll);
                mLastSeenPos = lastPos;
                if (lastPos > mBoundPos) {
                    smoothScrollBy(-(lastViewPixelsShowing - extraScroll), mScrollDuration, true);
                    postOnAnimation(this);
                } else {
                    final int bottom = listHeight - extraScroll;
                    final int lastViewBottom = lastViewTop + lastViewHeight;
                    if (bottom > lastViewBottom) {
                        smoothScrollBy(-(bottom - lastViewBottom), mScrollDuration, true);
                    }
                }
                break;
            }
        case MOVE_OFFSET:
            {
                if (mLastSeenPos == firstPos) {
                    // No new views, let things keep going.
                    postOnAnimation(this);
                    return;
                }
                mLastSeenPos = firstPos;
                final int childCount = getChildCount();
                final int position = mTargetPos;
                final int lastPos = firstPos + childCount - 1;
                int viewTravelCount = 0;
                if (position < firstPos) {
                    viewTravelCount = firstPos - position + 1;
                } else if (position > lastPos) {
                    viewTravelCount = position - lastPos;
                }
                // Estimate how many screens we should travel
                final float screenTravelCount = (float) viewTravelCount / childCount;
                final float modifier = Math.min(Math.abs(screenTravelCount), 1.f);
                if (position < firstPos) {
                    final int distance = (int) (-getHeight() * modifier);
                    final int duration = (int) (mScrollDuration * modifier);
                    smoothScrollBy(distance, duration, true);
                    postOnAnimation(this);
                } else if (position > lastPos) {
                    final int distance = (int) (getHeight() * modifier);
                    final int duration = (int) (mScrollDuration * modifier);
                    smoothScrollBy(distance, duration, true);
                    postOnAnimation(this);
                } else {
                    // On-screen, just scroll.
                    final int targetTop = getChildAt(position - firstPos).getTop();
                    final int distance = targetTop - mOffsetFromTop;
                    final int duration = (int) (mScrollDuration * ((float) Math.abs(distance) / getHeight()));
                    smoothScrollBy(distance, duration, true);
                }
                break;
            }
        default:
            break;
    }
}","{
    final int listHeight = getHeight();
    final int firstPos = mFirstPosition;
    switch(mMode) {
        case MOVE_DOWN_POS:
            {
                final int lastViewIndex = getChildCount() - 1;
                final int lastPos = firstPos + lastViewIndex;
                if (lastViewIndex < 0) {
                    return;
                }
                if (lastPos == mLastSeenPos) {
                    // No new views, let things keep going.
                    postOnAnimation(this);
                    return;
                }
                final View lastView = getChildAt(lastViewIndex);
                final int lastViewHeight = lastView.getHeight();
                final int lastViewTop = lastView.getTop();
                final int lastViewPixelsShowing = listHeight - lastViewTop;
                final int extraScroll = lastPos < mItemCount - 1 ? Math.max(mListPadding.bottom, mExtraScroll) : mListPadding.bottom;
                final int scrollBy = lastViewHeight - lastViewPixelsShowing + extraScroll;
                smoothScrollBy(scrollBy, mScrollDuration, true, lastPos < mTargetPos);
                mLastSeenPos = lastPos;
                if (lastPos < mTargetPos) {
                    postOnAnimation(this);
                }
                break;
            }
        case MOVE_DOWN_BOUND:
            {
                final int nextViewIndex = 1;
                final int childCount = getChildCount();
                if (firstPos == mBoundPos || childCount <= nextViewIndex || firstPos + childCount >= mItemCount) {
                    reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                    return;
                }
                final int nextPos = firstPos + nextViewIndex;
                if (nextPos == mLastSeenPos) {
                    // No new views, let things keep going.
                    postOnAnimation(this);
                    return;
                }
                final View nextView = getChildAt(nextViewIndex);
                final int nextViewHeight = nextView.getHeight();
                final int nextViewTop = nextView.getTop();
                final int extraScroll = Math.max(mListPadding.bottom, mExtraScroll);
                if (nextPos < mBoundPos) {
                    smoothScrollBy(Math.max(0, nextViewHeight + nextViewTop - extraScroll), mScrollDuration, true, true);
                    mLastSeenPos = nextPos;
                    postOnAnimation(this);
                } else {
                    if (nextViewTop > extraScroll) {
                        smoothScrollBy(nextViewTop - extraScroll, mScrollDuration, true, false);
                    } else {
                        reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                    }
                }
                break;
            }
        case MOVE_UP_POS:
            {
                if (firstPos == mLastSeenPos) {
                    // No new views, let things keep going.
                    postOnAnimation(this);
                    return;
                }
                final View firstView = getChildAt(0);
                if (firstView == null) {
                    return;
                }
                final int firstViewTop = firstView.getTop();
                final int extraScroll = firstPos > 0 ? Math.max(mExtraScroll, mListPadding.top) : mListPadding.top;
                smoothScrollBy(firstViewTop - extraScroll, mScrollDuration, true, firstPos > mTargetPos);
                mLastSeenPos = firstPos;
                if (firstPos > mTargetPos) {
                    postOnAnimation(this);
                }
                break;
            }
        case MOVE_UP_BOUND:
            {
                final int lastViewIndex = getChildCount() - 2;
                if (lastViewIndex < 0) {
                    return;
                }
                final int lastPos = firstPos + lastViewIndex;
                if (lastPos == mLastSeenPos) {
                    // No new views, let things keep going.
                    postOnAnimation(this);
                    return;
                }
                final View lastView = getChildAt(lastViewIndex);
                final int lastViewHeight = lastView.getHeight();
                final int lastViewTop = lastView.getTop();
                final int lastViewPixelsShowing = listHeight - lastViewTop;
                final int extraScroll = Math.max(mListPadding.top, mExtraScroll);
                mLastSeenPos = lastPos;
                if (lastPos > mBoundPos) {
                    smoothScrollBy(-(lastViewPixelsShowing - extraScroll), mScrollDuration, true, true);
                    postOnAnimation(this);
                } else {
                    final int bottom = listHeight - extraScroll;
                    final int lastViewBottom = lastViewTop + lastViewHeight;
                    if (bottom > lastViewBottom) {
                        smoothScrollBy(-(bottom - lastViewBottom), mScrollDuration, true, false);
                    } else {
                        reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                    }
                }
                break;
            }
        case MOVE_OFFSET:
            {
                if (mLastSeenPos == firstPos) {
                    // No new views, let things keep going.
                    postOnAnimation(this);
                    return;
                }
                mLastSeenPos = firstPos;
                final int childCount = getChildCount();
                final int position = mTargetPos;
                final int lastPos = firstPos + childCount - 1;
                // Account for the visible ""portion"" of the first / last child when we estimate
                // how many screens we should travel to reach our target
                final View firstChild = getChildAt(0);
                final int firstChildHeight = firstChild.getHeight();
                final View lastChild = getChildAt(childCount - 1);
                final int lastChildHeight = lastChild.getHeight();
                final float firstPositionVisiblePart = (firstChildHeight == 0.0f) ? 1.0f : (float) (firstChildHeight + firstChild.getTop()) / firstChildHeight;
                final float lastPositionVisiblePart = (lastChildHeight == 0.0f) ? 1.0f : (float) (lastChildHeight + getHeight() - lastChild.getBottom()) / lastChildHeight;
                float viewTravelCount = 0;
                if (position < firstPos) {
                    viewTravelCount = firstPos - position + (1.0f - firstPositionVisiblePart) + 1;
                } else if (position > lastPos) {
                    viewTravelCount = position - lastPos + (1.0f - lastPositionVisiblePart);
                }
                // Estimate how many screens we should travel
                final float screenTravelCount = viewTravelCount / childCount;
                final float modifier = Math.min(Math.abs(screenTravelCount), 1.f);
                if (position < firstPos) {
                    final int distance = (int) (-getHeight() * modifier);
                    final int duration = (int) (mScrollDuration * modifier);
                    smoothScrollBy(distance, duration, true, true);
                    postOnAnimation(this);
                } else if (position > lastPos) {
                    final int distance = (int) (getHeight() * modifier);
                    final int duration = (int) (mScrollDuration * modifier);
                    smoothScrollBy(distance, duration, true, true);
                    postOnAnimation(this);
                } else {
                    // On-screen, just scroll.
                    final int targetTop = getChildAt(position - firstPos).getTop();
                    final int distance = targetTop - mOffsetFromTop;
                    final int duration = (int) (mScrollDuration * ((float) Math.abs(distance) / getHeight()));
                    smoothScrollBy(distance, duration, true, false);
                }
                break;
            }
        default:
            break;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
1045,<android.app.Activity: boolean isImmersive()>,25,26,<android.app.Activity: boolean isImmersive()>,<android.app.Activity: boolean isImmersive()>,0,"{
    try {
        return ActivityManagerNative.getDefault().isImmersive(mToken);
    } catch (RemoteException e) {
        return false;
    }
}","{
    try {
        return ActivityManager.getService().isImmersive(mToken);
    } catch (RemoteException e) {
        return false;
    }
}",1,"/**
 * Bit indicating that this activity is ""immersive"" and should not be
 * interrupted by notifications if possible.
 *
 * This value is initially set by the manifest property
 * <code>android:immersive</code> but may be changed at runtime by
 * {@link #setImmersive}.
 *
 * @see #setImmersive(boolean)
 * @see android.content.pm.ActivityInfo#FLAG_IMMERSIVE
 */
","/**
 * Bit indicating that this activity is ""immersive"" and should not be
 * interrupted by notifications if possible.
 *
 * This value is initially set by the manifest property
 * <code>android:immersive</code> but may be changed at runtime by
 * {@link #setImmersive}.
 *
 * @see #setImmersive(boolean)
 * @see android.content.pm.ActivityInfo#FLAG_IMMERSIVE
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The API being called has changed from `ActivityManagerNative.getDefault().isImmersive(mToken)` to `ActivityManager.getService().isImmersive(mToken)`, indicating a change in the dependent method, so the code change type is 5.","Due to the dependent API being a direct replacement, as long as the new `ActivityManager.getService().isImmersive(mToken)` is intended to be functionally equivalent to the old `ActivityManagerNative.getDefault().isImmersive(mToken)`, it would not lead to a different return value or type, and thus no compatibility issue is expected in this case. The exception handling remains the same and does not lead to a CI."
1046,<android.app.ContextImpl: Display getDisplay()>,25,26,<android.app.ContextImpl: Display getDisplay()>,<android.app.ContextImpl: Display getDisplay()>,0,"{
    final DisplayAdjustments displayAdjustments = mResources.getDisplayAdjustments();
    if (mDisplay == null) {
        return mResourcesManager.getAdjustedDisplay(Display.DEFAULT_DISPLAY, displayAdjustments);
    }
    if (!mDisplay.getDisplayAdjustments().equals(displayAdjustments)) {
        mDisplay = mResourcesManager.getAdjustedDisplay(mDisplay.getDisplayId(), displayAdjustments);
    }
    return mDisplay;
}","{
    if (mDisplay == null) {
        return mResourcesManager.getAdjustedDisplay(Display.DEFAULT_DISPLAY, mResources);
    }
    return mDisplay;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"There's a removal of the condition and update of the 'mDisplay' object when its adjustments don't match the current 'displayAdjustments'. Also, 'displayAdjustments' are no longer retrieved from 'mResources', it is now directly using 'mResources' which also changes the number of arguments passed to 'getAdjustedDisplay'. Hence, the code change type is 1,4.","The change leads to a potential different 'mDisplay' being returned due to the removed check and object update, which may cause the API to return a different value than before. Thus, the CI type is 1."
1047,"<android.app.ContextImpl: int checkPermission(String,int,int)>",25,26,"<android.app.ContextImpl: int checkPermission(String,int,int)>","<android.app.ContextImpl: int checkPermission(String,int,int)>",0,"{
    if (permission == null) {
        throw new IllegalArgumentException(""permission is null"");
    }
    try {
        return ActivityManagerNative.getDefault().checkPermission(permission, pid, uid);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    if (permission == null) {
        throw new IllegalArgumentException(""permission is null"");
    }
    final IActivityManager am = ActivityManager.getService();
    if (am == null) {
        // Well this is super awkward; we somehow don't have an active
        // ActivityManager instance. If we're testing a root or system
        // UID, then they totally have whatever permission this is.
        final int appId = UserHandle.getAppId(uid);
        if (appId == Process.ROOT_UID || appId == Process.SYSTEM_UID) {
            Slog.w(TAG, ""Missing ActivityManager; assuming "" + uid + "" holds "" + permission);
            return PackageManager.PERMISSION_GRANTED;
        }
    }
    try {
        return am.checkPermission(permission, pid, uid);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,3,4,5","1,2","The late version introduces a check for a null ActivityManager, conditional granting of permission based on the UID being root or system and a change from ActivityManagerNative.getDefault() to ActivityManager.getService() along with logic to handle the case where ActivityManager is null. Since there's a new return statement added for some specific cases, an 'if' condition has been modified, statements added after the 'if' condition, and a different ActivityManager method is being called, the change types are 2, 3, 4, and 5.","The late version could potentially return a different value from the PackageManager.PERMISSION_GRANTED conditionally granted permissions for the root or system UIDs when there's no ActivityManager instance. It also changes the behavior in the case of a RemoteException by calling rethrowFromSystemServer() on the exception object directly, so this could potentially lead to a different exception being thrown compared to the early version. Therefore, CI types are 1 (due to new return values for some cases) and 2 (due to different exception handling)."
1048,"<android.view.ViewGroup: ViewParent invalidateChildInParent(int[],Rect)>",25,26,"<android.view.ViewGroup: ViewParent invalidateChildInParent(int[],Rect)>","<android.view.ViewGroup: ViewParent invalidateChildInParent(int[],Rect)>",0,"{
    if ((mPrivateFlags & PFLAG_DRAWN) == PFLAG_DRAWN || (mPrivateFlags & PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID) {
        if ((mGroupFlags & (FLAG_OPTIMIZE_INVALIDATE | FLAG_ANIMATION_DONE)) != FLAG_OPTIMIZE_INVALIDATE) {
            dirty.offset(location[CHILD_LEFT_INDEX] - mScrollX, location[CHILD_TOP_INDEX] - mScrollY);
            if ((mGroupFlags & FLAG_CLIP_CHILDREN) == 0) {
                dirty.union(0, 0, mRight - mLeft, mBottom - mTop);
            }
            final int left = mLeft;
            final int top = mTop;
            if ((mGroupFlags & FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN) {
                if (!dirty.intersect(0, 0, mRight - left, mBottom - top)) {
                    dirty.setEmpty();
                }
            }
            mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
            location[CHILD_LEFT_INDEX] = left;
            location[CHILD_TOP_INDEX] = top;
            if (mLayerType != LAYER_TYPE_NONE) {
                mPrivateFlags |= PFLAG_INVALIDATED;
            }
            return mParent;
        } else {
            mPrivateFlags &= ~PFLAG_DRAWN & ~PFLAG_DRAWING_CACHE_VALID;
            location[CHILD_LEFT_INDEX] = mLeft;
            location[CHILD_TOP_INDEX] = mTop;
            if ((mGroupFlags & FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN) {
                dirty.set(0, 0, mRight - mLeft, mBottom - mTop);
            } else {
                // in case the dirty rect extends outside the bounds of this container
                dirty.union(0, 0, mRight - mLeft, mBottom - mTop);
            }
            if (mLayerType != LAYER_TYPE_NONE) {
                mPrivateFlags |= PFLAG_INVALIDATED;
            }
            return mParent;
        }
    }
    return null;
}","{
    if ((mPrivateFlags & (PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID)) != 0) {
        // either DRAWN, or DRAWING_CACHE_VALID
        if ((mGroupFlags & (FLAG_OPTIMIZE_INVALIDATE | FLAG_ANIMATION_DONE)) != FLAG_OPTIMIZE_INVALIDATE) {
            dirty.offset(location[CHILD_LEFT_INDEX] - mScrollX, location[CHILD_TOP_INDEX] - mScrollY);
            if ((mGroupFlags & FLAG_CLIP_CHILDREN) == 0) {
                dirty.union(0, 0, mRight - mLeft, mBottom - mTop);
            }
            final int left = mLeft;
            final int top = mTop;
            if ((mGroupFlags & FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN) {
                if (!dirty.intersect(0, 0, mRight - left, mBottom - top)) {
                    dirty.setEmpty();
                }
            }
            location[CHILD_LEFT_INDEX] = left;
            location[CHILD_TOP_INDEX] = top;
        } else {
            if ((mGroupFlags & FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN) {
                dirty.set(0, 0, mRight - mLeft, mBottom - mTop);
            } else {
                // in case the dirty rect extends outside the bounds of this container
                dirty.union(0, 0, mRight - mLeft, mBottom - mTop);
            }
            location[CHILD_LEFT_INDEX] = mLeft;
            location[CHILD_TOP_INDEX] = mTop;
            mPrivateFlags &= ~PFLAG_DRAWN;
        }
        mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
        if (mLayerType != LAYER_TYPE_NONE) {
            mPrivateFlags |= PFLAG_INVALIDATED;
        }
        return mParent;
    }
    return null;
}",1,"/**
 * Don't call or override this method. It is used for the implementation of
 * the view hierarchy.
 *
 * This implementation returns null if this ViewGroup does not have a parent,
 * if this ViewGroup is already fully invalidated or if the dirty rectangle
 * does not intersect with this ViewGroup's bounds.
 */
","/**
 * Don't call or override this method. It is used for the implementation of
 * the view hierarchy.
 *
 * This implementation returns null if this ViewGroup does not have a parent,
 * if this ViewGroup is already fully invalidated or if the dirty rectangle
 * does not intersect with this ViewGroup's bounds.
 *
 * @deprecated Use {@link #onDescendantInvalidated(View, View)} instead to observe updates to
 * draw state in descendants.
 */
",-1,[@Override],"[@Deprecated, @Override]",-1,-1,-1,-1,-1,-1,"3,4",0,"The condition checking the mPrivateFlags has simplified from two separate checks to a single combined check, and several modifications to the 'mPrivateFlags' within the if-else statements have been reorganized. Also, the last return statement is slightly changed by removing the redundant setting of flags. Although these are alterations in control flow and other statements, none of them change the behavior of the method. The types of code changes here are 3 and 4.","These changes don't affect the output values or exception flow of this method since the conditions that guide the execution path, overall logic, and actual return values aren't altered in a way that could lead to a incompatibility issue. Therefore, the CI type is 0."
1051,"<android.app.FragmentManagerImpl: boolean popBackStackImmediate(int,int)>",25,26,"<android.app.FragmentManagerImpl: boolean popBackStackImmediate(int,int)>","<android.app.FragmentManagerImpl: boolean popBackStackImmediate(int,int)>",0,"{
    checkStateLoss();
    executePendingTransactions();
    if (id < 0) {
        throw new IllegalArgumentException(""Bad id: "" + id);
    }
    return popBackStackState(mHost.getHandler(), null, id, flags);
}","{
    checkStateLoss();
    if (id < 0) {
        throw new IllegalArgumentException(""Bad id: "" + id);
    }
    return popBackStackImmediate(null, id, flags);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4,5",1,"The method `executePendingTransactions()` is removed, which alters the execution flow, and the method `popBackStackState()` is replaced with `popBackStackImmediate()` with different parameters, leading to code changes of types 1, 4, and 5.","The removal of `executePendingTransactions()` changes when state loss is checked, and the change from `popBackStackState()` to `popBackStackImmediate()` likely changes the value returned by the method since it is a different function—potentially leading to a different result. Therefore, the CI type is 1."
1052,"<android.database.sqlite.SQLiteDatabase: int updateWithOnConflict(String,ContentValues,String,String[],int)>",25,26,"<android.database.sqlite.SQLiteDatabase: int updateWithOnConflict(String,ContentValues,String,String[],int)>","<android.database.sqlite.SQLiteDatabase: int updateWithOnConflict(String,ContentValues,String,String[],int)>",0,"{
    if (values == null || values.size() == 0) {
        throw new IllegalArgumentException(""Empty values"");
    }
    acquireReference();
    try {
        StringBuilder sql = new StringBuilder(120);
        sql.append(""UPDATE "");
        sql.append(CONFLICT_VALUES[conflictAlgorithm]);
        sql.append(table);
        sql.append("" SET "");
        // move all bind args to one array
        int setValuesSize = values.size();
        int bindArgsSize = (whereArgs == null) ? setValuesSize : (setValuesSize + whereArgs.length);
        Object[] bindArgs = new Object[bindArgsSize];
        int i = 0;
        for (String colName : values.keySet()) {
            sql.append((i > 0) ? "","" : """");
            sql.append(colName);
            bindArgs[i++] = values.get(colName);
            sql.append(""=?"");
        }
        if (whereArgs != null) {
            for (i = setValuesSize; i < bindArgsSize; i++) {
                bindArgs[i] = whereArgs[i - setValuesSize];
            }
        }
        if (!TextUtils.isEmpty(whereClause)) {
            sql.append("" WHERE "");
            sql.append(whereClause);
        }
        SQLiteStatement statement = new SQLiteStatement(this, sql.toString(), bindArgs);
        try {
            return statement.executeUpdateDelete();
        } finally {
            statement.close();
        }
    } finally {
        releaseReference();
    }
}","{
    if (values == null || values.isEmpty()) {
        throw new IllegalArgumentException(""Empty values"");
    }
    acquireReference();
    try {
        StringBuilder sql = new StringBuilder(120);
        sql.append(""UPDATE "");
        sql.append(CONFLICT_VALUES[conflictAlgorithm]);
        sql.append(table);
        sql.append("" SET "");
        // move all bind args to one array
        int setValuesSize = values.size();
        int bindArgsSize = (whereArgs == null) ? setValuesSize : (setValuesSize + whereArgs.length);
        Object[] bindArgs = new Object[bindArgsSize];
        int i = 0;
        for (String colName : values.keySet()) {
            sql.append((i > 0) ? "","" : """");
            sql.append(colName);
            bindArgs[i++] = values.get(colName);
            sql.append(""=?"");
        }
        if (whereArgs != null) {
            for (i = setValuesSize; i < bindArgsSize; i++) {
                bindArgs[i] = whereArgs[i - setValuesSize];
            }
        }
        if (!TextUtils.isEmpty(whereClause)) {
            sql.append("" WHERE "");
            sql.append(whereClause);
        }
        SQLiteStatement statement = new SQLiteStatement(this, sql.toString(), bindArgs);
        try {
            return statement.executeUpdateDelete();
        } finally {
            statement.close();
        }
    } finally {
        releaseReference();
    }
}",1,"/**
 * Convenience method for updating rows in the database.
 *
 * @param table the table to update in
 * @param values a map from column names to new column values. null is a
 * valid value that will be translated to NULL.
 * @param whereClause the optional WHERE clause to apply when updating.
 * Passing null will update all rows.
 * @param whereArgs You may include ?s in the where clause, which
 * will be replaced by the values from whereArgs. The values
 * will be bound as Strings.
 * @param conflictAlgorithm for update conflict resolver
 * @return the number of rows affected
 */
","/**
 * Convenience method for updating rows in the database.
 *
 * @param table the table to update in
 * @param values a map from column names to new column values. null is a
 * valid value that will be translated to NULL.
 * @param whereClause the optional WHERE clause to apply when updating.
 * Passing null will update all rows.
 * @param whereArgs You may include ?s in the where clause, which
 * will be replaced by the values from whereArgs. The values
 * will be bound as Strings.
 * @param conflictAlgorithm for update conflict resolver
 * @return the number of rows affected
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change made in the method implementation is replacing `values.size() == 0` with `values.isEmpty()`. Since this is purely syntactical and does not cause any change in behavior (both the early and late version are checking for the same condition: whether the `values` is empty), the code change type is 4 (Other statement changed).",There is no Compatibility Issue because the change from `values.size() == 0` to `values.isEmpty()` does not affect the functionality or output of the method. The behavior will remain the same in both versions for any given input so the pred_CI is 0 (No Compatibility Issue).
1054,<android.content.ClipDescription: String getMimeType(int)>,25,26,<android.content.ClipDescription: String getMimeType(int)>,<android.content.ClipDescription: String getMimeType(int)>,0,"{
    return mMimeTypes[index];
}","{
    return mMimeTypes.get(index);
}",1,"/**
 * Return one of the possible clip MIME types.
 */
","/**
 * Return one of the possible clip MIME types.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The way to access the array element changed from array indexing (mMimeTypes[index]) to a method call (mMimeTypes.get(index)), indicating the probability of a changed underlying data structure, therefore the code change type is 5.","There is no direct evidence that this alteration would lead to a compatibility issue because the visible behavior of the method, in terms of returning a String type by index, remains consistent. The implementation details are abstracted, so the clients of the API should not be affected by this change. The CI type is 0."
1056,<android.appwidget.AppWidgetManager: List<AppWidgetProviderInfo> getInstalledProviders()>,25,26,<android.appwidget.AppWidgetManager: List<AppWidgetProviderInfo> getInstalledProviders()>,<android.appwidget.AppWidgetManager: List<AppWidgetProviderInfo> getInstalledProviders()>,0,"{
    if (mService == null) {
        return Collections.emptyList();
    }
    return getInstalledProvidersForProfile(AppWidgetProviderInfo.WIDGET_CATEGORY_HOME_SCREEN, null);
}","{
    if (mService == null) {
        return Collections.emptyList();
    }
    return getInstalledProvidersForProfile(AppWidgetProviderInfo.WIDGET_CATEGORY_HOME_SCREEN, null, null);
}",1,"/**
 * Return a list of the AppWidget providers that are currently installed.
 */
","/**
 * Return a list of the AppWidget providers that are currently installed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method `getInstalledProvidersForProfile` is now called with an additional `null` parameter in the late version, which indicates that a dependent API has likely changed its signature to accommodate an additional input. This change is therefore classified as type 5.","There is no indication of a Compatibility Issue since the additional parameter is simply `null` which doesn't change the behavior of the method or alter its output in any observable way. The method `getInstalledProvidersForProfile` is likely overloaded to handle this new parameter, and the previous functionality remains the same, so clients using this method will not experience any different behavior."
1057,<android.text.method.DateKeyListener: int getInputType()>,25,26,<android.text.method.DateKeyListener: int getInputType()>,<android.text.method.DateKeyListener: int getInputType()>,0,"{
    return InputType.TYPE_CLASS_DATETIME | InputType.TYPE_DATETIME_VARIATION_DATE;
}","{
    if (mNeedsAdvancedInput) {
        return InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_NORMAL;
    } else {
        return InputType.TYPE_CLASS_DATETIME | InputType.TYPE_DATETIME_VARIATION_DATE;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The addition of a new 'if' control statement, which conditionally returns a different input type, is a change in both a control dependency and other statement, therefore the change types are 3 and 4.","The new control statement introduces a condition that can potentially return a different value depending on the state of 'mNeedsAdvancedInput'. This constitutes a potential change in behavior that can lead to a different return value, hence a Compatibility Issue of type 1 is detected."
1058,<android.app.ActivityOptions: void update(ActivityOptions)>,25,26,<android.app.ActivityOptions: void update(ActivityOptions)>,<android.app.ActivityOptions: void update(ActivityOptions)>,0,"{
    if (otherOptions.mPackageName != null) {
        mPackageName = otherOptions.mPackageName;
    }
    mUsageTimeReport = otherOptions.mUsageTimeReport;
    mTransitionReceiver = null;
    mSharedElementNames = null;
    mIsReturning = false;
    mResultData = null;
    mResultCode = 0;
    mExitCoordinatorIndex = 0;
    mAnimationType = otherOptions.mAnimationType;
    switch(otherOptions.mAnimationType) {
        case ANIM_CUSTOM:
            mCustomEnterResId = otherOptions.mCustomEnterResId;
            mCustomExitResId = otherOptions.mCustomExitResId;
            mThumbnail = null;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = otherOptions.mAnimationStartedListener;
            break;
        case ANIM_CUSTOM_IN_PLACE:
            mCustomInPlaceResId = otherOptions.mCustomInPlaceResId;
            break;
        case ANIM_SCALE_UP:
            mStartX = otherOptions.mStartX;
            mStartY = otherOptions.mStartY;
            mWidth = otherOptions.mWidth;
            mHeight = otherOptions.mHeight;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = null;
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
        case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
        case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
            mThumbnail = otherOptions.mThumbnail;
            mStartX = otherOptions.mStartX;
            mStartY = otherOptions.mStartY;
            mWidth = otherOptions.mWidth;
            mHeight = otherOptions.mHeight;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = otherOptions.mAnimationStartedListener;
            break;
        case ANIM_SCENE_TRANSITION:
            mTransitionReceiver = otherOptions.mTransitionReceiver;
            mSharedElementNames = otherOptions.mSharedElementNames;
            mIsReturning = otherOptions.mIsReturning;
            mThumbnail = null;
            mAnimationStartedListener = null;
            mResultData = otherOptions.mResultData;
            mResultCode = otherOptions.mResultCode;
            mExitCoordinatorIndex = otherOptions.mExitCoordinatorIndex;
            break;
    }
    mAnimSpecs = otherOptions.mAnimSpecs;
    mAnimationFinishedListener = otherOptions.mAnimationFinishedListener;
}","{
    if (otherOptions.mPackageName != null) {
        mPackageName = otherOptions.mPackageName;
    }
    mUsageTimeReport = otherOptions.mUsageTimeReport;
    mTransitionReceiver = null;
    mSharedElementNames = null;
    mIsReturning = false;
    mResultData = null;
    mResultCode = 0;
    mExitCoordinatorIndex = 0;
    mAnimationType = otherOptions.mAnimationType;
    switch(otherOptions.mAnimationType) {
        case ANIM_CUSTOM:
            mCustomEnterResId = otherOptions.mCustomEnterResId;
            mCustomExitResId = otherOptions.mCustomExitResId;
            mThumbnail = null;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = otherOptions.mAnimationStartedListener;
            break;
        case ANIM_CUSTOM_IN_PLACE:
            mCustomInPlaceResId = otherOptions.mCustomInPlaceResId;
            break;
        case ANIM_SCALE_UP:
            mStartX = otherOptions.mStartX;
            mStartY = otherOptions.mStartY;
            mWidth = otherOptions.mWidth;
            mHeight = otherOptions.mHeight;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = null;
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
        case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
        case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
            mThumbnail = otherOptions.mThumbnail;
            mStartX = otherOptions.mStartX;
            mStartY = otherOptions.mStartY;
            mWidth = otherOptions.mWidth;
            mHeight = otherOptions.mHeight;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = otherOptions.mAnimationStartedListener;
            break;
        case ANIM_SCENE_TRANSITION:
            mTransitionReceiver = otherOptions.mTransitionReceiver;
            mSharedElementNames = otherOptions.mSharedElementNames;
            mIsReturning = otherOptions.mIsReturning;
            mThumbnail = null;
            mAnimationStartedListener = null;
            mResultData = otherOptions.mResultData;
            mResultCode = otherOptions.mResultCode;
            mExitCoordinatorIndex = otherOptions.mExitCoordinatorIndex;
            break;
    }
    mAnimSpecs = otherOptions.mAnimSpecs;
    mAnimationFinishedListener = otherOptions.mAnimationFinishedListener;
    mSpecsFuture = otherOptions.mSpecsFuture;
}",1,"/**
 * Update the current values in this ActivityOptions from those supplied
 * in <var>otherOptions</var>.  Any values
 * defined in <var>otherOptions</var> replace those in the base options.
 */
","/**
 * Update the current values in this ActivityOptions from those supplied
 * in <var>otherOptions</var>.  Any values
 * defined in <var>otherOptions</var> replace those in the base options.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
1059,<android.app.admin.DevicePolicyManager: void uninstallAllUserCaCerts(ComponentName)>,25,26,<android.app.admin.DevicePolicyManager: void uninstallAllUserCaCerts(ComponentName)>,<android.app.admin.DevicePolicyManager: void uninstallAllUserCaCerts(ComponentName)>,0,"{
    throwIfParentInstance(""uninstallAllUserCaCerts"");
    if (mService != null) {
        try {
            mService.uninstallCaCerts(admin, new TrustedCertificateStore().userAliases().toArray(new String[0]));
        } catch (RemoteException re) {
            throw re.rethrowFromSystemServer();
        }
    }
}","{
    throwIfParentInstance(""uninstallAllUserCaCerts"");
    if (mService != null) {
        try {
            mService.uninstallCaCerts(admin, mContext.getPackageName(), new TrustedCertificateStore().userAliases().toArray(new String[0]));
        } catch (RemoteException re) {
            throw re.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Uninstalls all custom trusted CA certificates from the profile. Certificates installed by
 * means other than device policy will also be removed, except for system CA certificates.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or
 * {@code null} if calling from a delegated certificate installer.
 * @throws SecurityException if {@code admin} is not {@code null} and not a device or profile
 * owner.
 */
","/**
 * Uninstalls all custom trusted CA certificates from the profile. Certificates installed by
 * means other than device policy will also be removed, except for system CA certificates.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or
 * {@code null} if calling from a delegated certificate installer.
 * @throws SecurityException if {@code admin} is not {@code null} and not a device or profile
 * owner.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method call mService.uninstallCaCerts() in the late version has an additional argument, mContext.getPackageName(), which signifies a change in the type of Other statement changed (type 4) and also a Dependent API changed (type 5).","The additional argument does not lead to a different return type or value, nor does it change exception handling. Therefore, there is no Compatibility Issue (type 0)."
1061,<android.os.PatternMatcher: String toString()>,25,26,<android.os.PatternMatcher: String toString()>,<android.os.PatternMatcher: String toString()>,0,"{
    String type = ""? "";
    switch(mType) {
        case PATTERN_LITERAL:
            type = ""LITERAL: "";
            break;
        case PATTERN_PREFIX:
            type = ""PREFIX: "";
            break;
        case PATTERN_SIMPLE_GLOB:
            type = ""GLOB: "";
            break;
    }
    return ""PatternMatcher{"" + type + mPattern + ""}"";
}","{
    String type = ""? "";
    switch(mType) {
        case PATTERN_LITERAL:
            type = ""LITERAL: "";
            break;
        case PATTERN_PREFIX:
            type = ""PREFIX: "";
            break;
        case PATTERN_SIMPLE_GLOB:
            type = ""GLOB: "";
            break;
        case PATTERN_ADVANCED_GLOB:
            type = ""ADVANCED: "";
            break;
    }
    return ""PatternMatcher{"" + type + mPattern + ""}"";
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The method's control flow has been changed by adding a case for `PATTERN_ADVANCED_GLOB` in the switch statement, and the return statement now depends on the new case, changing the value that may be returned by the method in cases where `mType` matches `PATTERN_ADVANCED_GLOB`. Thus, this is a change in the control dependency and return statement, which corresponds to change types 1 and 3.","Since a new case in the switch statement adds the possibility of a different string (with ""ADVANCED: "") being part of the return value, the change potentially causes the API to return a different value when `mType` is `PATTERN_ADVANCED_GLOB`. Therefore, the API has a Compatibility Issue of type 1 due to potential different return values."
1063,<android.accounts.AccountManager.GetAuthTokenByTypeAndFeaturesTask: void run(AccountManagerFuture<Bundle>)>,25,26,<android.accounts.AccountManager.GetAuthTokenByTypeAndFeaturesTask: void run(AccountManagerFuture<Bundle>)>,<android.accounts.AccountManager.GetAuthTokenByTypeAndFeaturesTask: void run(AccountManagerFuture<Bundle>)>,0,"{
    try {
        final Bundle result = future.getResult();
        if (mNumAccounts == 0) {
            final String accountName = result.getString(KEY_ACCOUNT_NAME);
            final String accountType = result.getString(KEY_ACCOUNT_TYPE);
            if (TextUtils.isEmpty(accountName) || TextUtils.isEmpty(accountType)) {
                setException(new AuthenticatorException(""account not in result""));
                return;
            }
            final Account account = new Account(accountName, accountType);
            mNumAccounts = 1;
            getAuthToken(account, mAuthTokenType, null, /* options */
            mActivity, mMyCallback, mHandler);
            return;
        }
        set(result);
    } catch (OperationCanceledException e) {
        cancel(true);
    } catch (IOException e) {
        setException(e);
    } catch (AuthenticatorException e) {
        setException(e);
    }
}","{
    try {
        final Bundle result = future.getResult();
        if (mNumAccounts == 0) {
            final String accountName = result.getString(KEY_ACCOUNT_NAME);
            final String accountType = result.getString(KEY_ACCOUNT_TYPE);
            if (TextUtils.isEmpty(accountName) || TextUtils.isEmpty(accountType)) {
                setException(new AuthenticatorException(""account not in result""));
                return;
            }
            final String accessId = result.getString(KEY_ACCOUNT_ACCESS_ID);
            final Account account = new Account(accountName, accountType, accessId);
            mNumAccounts = 1;
            getAuthToken(account, mAuthTokenType, null, /* options */
            mActivity, mMyCallback, mHandler);
            return;
        }
        set(result);
    } catch (OperationCanceledException e) {
        cancel(true);
    } catch (IOException e) {
        setException(e);
    } catch (AuthenticatorException e) {
        setException(e);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The only change here is the introduction of the new variable `accessId` and constructing `Account` with this new variable. No return statements or exception handling statements have changed, and the control dependency remains the same. The change is allocating a new piece of data, but it doesn't affect the existing behavior, so the code change type is 4.","There is no Compatibility Issue since the existing control flow, return values, and exception handling have not been altered. Therefore, the clients using the API will not experience any different behavior concerning the method's output or the exceptions thrown. The introduction of the new variable doesn't cause the API to act differently for the client code that relies on previous behavior."
1064,<android.view.View: boolean onHoverEvent(MotionEvent)>,25,26,<android.view.View: boolean onHoverEvent(MotionEvent)>,<android.view.View: boolean onHoverEvent(MotionEvent)>,0,"{
    // The root view may receive hover (or touch) events that are outside the bounds of
    // the window.  This code ensures that we only send accessibility events for
    // hovers that are actually within the bounds of the root view.
    final int action = event.getActionMasked();
    if (!mSendingHoverAccessibilityEvents) {
        if ((action == MotionEvent.ACTION_HOVER_ENTER || action == MotionEvent.ACTION_HOVER_MOVE) && !hasHoveredChild() && pointInView(event.getX(), event.getY())) {
            sendAccessibilityHoverEvent(AccessibilityEvent.TYPE_VIEW_HOVER_ENTER);
            mSendingHoverAccessibilityEvents = true;
        }
    } else {
        if (action == MotionEvent.ACTION_HOVER_EXIT || (action == MotionEvent.ACTION_MOVE && !pointInView(event.getX(), event.getY()))) {
            mSendingHoverAccessibilityEvents = false;
            sendAccessibilityHoverEvent(AccessibilityEvent.TYPE_VIEW_HOVER_EXIT);
        }
    }
    if ((action == MotionEvent.ACTION_HOVER_ENTER || action == MotionEvent.ACTION_HOVER_MOVE) && event.isFromSource(InputDevice.SOURCE_MOUSE) && isOnScrollbar(event.getX(), event.getY())) {
        awakenScrollBars();
    }
    if (isHoverable()) {
        switch(action) {
            case MotionEvent.ACTION_HOVER_ENTER:
                setHovered(true);
                break;
            case MotionEvent.ACTION_HOVER_EXIT:
                setHovered(false);
                break;
        }
        // Dispatch the event to onGenericMotionEvent before returning true.
        // This is to provide compatibility with existing applications that
        // handled HOVER_MOVE events in onGenericMotionEvent and that would
        // break because of the new default handling for hoverable views
        // in onHoverEvent.
        // Note that onGenericMotionEvent will be called by default when
        // onHoverEvent returns false (refer to dispatchGenericMotionEvent).
        dispatchGenericMotionEventInternal(event);
        // return true.
        return true;
    }
    return false;
}","{
    // The root view may receive hover (or touch) events that are outside the bounds of
    // the window.  This code ensures that we only send accessibility events for
    // hovers that are actually within the bounds of the root view.
    final int action = event.getActionMasked();
    if (!mSendingHoverAccessibilityEvents) {
        if ((action == MotionEvent.ACTION_HOVER_ENTER || action == MotionEvent.ACTION_HOVER_MOVE) && !hasHoveredChild() && pointInView(event.getX(), event.getY())) {
            sendAccessibilityHoverEvent(AccessibilityEvent.TYPE_VIEW_HOVER_ENTER);
            mSendingHoverAccessibilityEvents = true;
        }
    } else {
        if (action == MotionEvent.ACTION_HOVER_EXIT || (action == MotionEvent.ACTION_MOVE && !pointInView(event.getX(), event.getY()))) {
            mSendingHoverAccessibilityEvents = false;
            sendAccessibilityHoverEvent(AccessibilityEvent.TYPE_VIEW_HOVER_EXIT);
        }
    }
    if ((action == MotionEvent.ACTION_HOVER_ENTER || action == MotionEvent.ACTION_HOVER_MOVE) && event.isFromSource(InputDevice.SOURCE_MOUSE) && isOnScrollbar(event.getX(), event.getY())) {
        awakenScrollBars();
    }
    // handle changing state in response to ENTER and EXIT events.
    if (isHoverable() || isHovered()) {
        switch(action) {
            case MotionEvent.ACTION_HOVER_ENTER:
                setHovered(true);
                break;
            case MotionEvent.ACTION_HOVER_EXIT:
                setHovered(false);
                break;
        }
        // Dispatch the event to onGenericMotionEvent before returning true.
        // This is to provide compatibility with existing applications that
        // handled HOVER_MOVE events in onGenericMotionEvent and that would
        // break because of the new default handling for hoverable views
        // in onHoverEvent.
        // Note that onGenericMotionEvent will be called by default when
        // onHoverEvent returns false (refer to dispatchGenericMotionEvent).
        dispatchGenericMotionEventInternal(event);
        // return true.
        return true;
    }
    return false;
}",1,"/**
 * Implement this method to handle hover events.
 * <p>
 * This method is called whenever a pointer is hovering into, over, or out of the
 * bounds of a view and the view is not currently being touched.
 * Hover events are represented as pointer events with action
 * {@link MotionEvent#ACTION_HOVER_ENTER}, {@link MotionEvent#ACTION_HOVER_MOVE},
 * or {@link MotionEvent#ACTION_HOVER_EXIT}.
 * </p>
 * <ul>
 * <li>The view receives a hover event with action {@link MotionEvent#ACTION_HOVER_ENTER}
 * when the pointer enters the bounds of the view.</li>
 * <li>The view receives a hover event with action {@link MotionEvent#ACTION_HOVER_MOVE}
 * when the pointer has already entered the bounds of the view and has moved.</li>
 * <li>The view receives a hover event with action {@link MotionEvent#ACTION_HOVER_EXIT}
 * when the pointer has exited the bounds of the view or when the pointer is
 * about to go down due to a button click, tap, or similar user action that
 * causes the view to be touched.</li>
 * </ul>
 * <p>
 * The view should implement this method to return true to indicate that it is
 * handling the hover event, such as by changing its drawable state.
 * </p><p>
 * The default implementation calls {@link #setHovered} to update the hovered state
 * of the view when a hover enter or hover exit event is received, if the view
 * is enabled and is clickable.  The default implementation also sends hover
 * accessibility events.
 * </p>
 *
 * @param event The motion event that describes the hover.
 * @return True if the view handled the hover event.
 *
 * @see #isHovered
 * @see #setHovered
 * @see #onHoverChanged
 */
","/**
 * Implement this method to handle hover events.
 * <p>
 * This method is called whenever a pointer is hovering into, over, or out of the
 * bounds of a view and the view is not currently being touched.
 * Hover events are represented as pointer events with action
 * {@link MotionEvent#ACTION_HOVER_ENTER}, {@link MotionEvent#ACTION_HOVER_MOVE},
 * or {@link MotionEvent#ACTION_HOVER_EXIT}.
 * </p>
 * <ul>
 * <li>The view receives a hover event with action {@link MotionEvent#ACTION_HOVER_ENTER}
 * when the pointer enters the bounds of the view.</li>
 * <li>The view receives a hover event with action {@link MotionEvent#ACTION_HOVER_MOVE}
 * when the pointer has already entered the bounds of the view and has moved.</li>
 * <li>The view receives a hover event with action {@link MotionEvent#ACTION_HOVER_EXIT}
 * when the pointer has exited the bounds of the view or when the pointer is
 * about to go down due to a button click, tap, or similar user action that
 * causes the view to be touched.</li>
 * </ul>
 * <p>
 * The view should implement this method to return true to indicate that it is
 * handling the hover event, such as by changing its drawable state.
 * </p><p>
 * The default implementation calls {@link #setHovered} to update the hovered state
 * of the view when a hover enter or hover exit event is received, if the view
 * is enabled and is clickable.  The default implementation also sends hover
 * accessibility events.
 * </p>
 *
 * @param event The motion event that describes the hover.
 * @return True if the view handled the hover event.
 *
 * @see #isHovered
 * @see #setHovered
 * @see #onHoverChanged
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"The condition in the IF statement has been modified from `if (isHoverable())` to `if (isHoverable() || isHovered())`, which is a control dependency change and is classified as 3.","The change in the condition affects which code block gets executed, thus potentially altering the behavior of the method. Since `isHovered()` might return true under different circumstances compared to `isHoverable()`, this could lead to the `setHovered()` method being called in situations where it wasn't being called before, changing the return value of the method. Therefore, this change could cause the method to return a different value than before, which is a Compatibility Issue of type 1."
1065,"<android.app.SharedPreferencesImpl: String getString(String,String)>",25,26,"<android.app.SharedPreferencesImpl: String getString(String,String)>","<android.app.SharedPreferencesImpl: String getString(String,String)>",0,"{
    synchronized (this) {
        awaitLoadedLocked();
        String v = (String) mMap.get(key);
        return v != null ? v : defValue;
    }
}","{
    synchronized (mLock) {
        awaitLoadedLocked();
        String v = (String) mMap.get(key);
        return v != null ? v : defValue;
    }
}",1,,,-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,0,0,"The only change is the object on which the synchronized block is locked, from 'this' to 'mLock', which doesn't affect the behavior of the method as long as both locks serve to protect the same shared resources from concurrent access issues. The implementation logic remains the same.","Since the change in the locking mechanism is internal and does not affect the output of the method or the exceptions it might throw, no compatibility issue is introduced."
1068,"<android.os.Vibrator: void vibrate(long[],int,AudioAttributes)>",25,26,"<android.os.Vibrator: void vibrate(long[],int,AudioAttributes)>","<android.os.Vibrator: void vibrate(long[],int,AudioAttributes)>",0,"{
    vibrate(Process.myUid(), mPackageName, pattern, repeat, attributes);
}","{
    // exceptions for compatibility purposes
    if (repeat < -1 || repeat >= pattern.length) {
        Log.e(TAG, ""vibrate called with repeat index out of bounds"" + "" (pattern.length="" + pattern.length + "", index="" + repeat + "")"");
        throw new ArrayIndexOutOfBoundsException();
    }
    try {
        vibrate(VibrationEffect.createWaveform(pattern, repeat), attributes);
    } catch (IllegalArgumentException iae) {
        Log.e(TAG, ""Failed to create VibrationEffect"", iae);
    }
}",1,"/**
 * Vibrate with a given pattern.
 *
 * <p>
 * Pass in an array of ints that are the durations for which to turn on or off
 * the vibrator in milliseconds.  The first value indicates the number of milliseconds
 * to wait before turning the vibrator on.  The next value indicates the number of milliseconds
 * for which to keep the vibrator on before turning it off.  Subsequent values alternate
 * between durations in milliseconds to turn the vibrator off or to turn the vibrator on.
 * </p><p>
 * To cause the pattern to repeat, pass the index into the pattern array at which
 * to start the repeat, or -1 to disable repeating.
 * </p>
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#VIBRATE}.
 *
 * @param pattern an array of longs of times for which to turn the vibrator on or off.
 * @param repeat the index into pattern at which to repeat, or -1 if
 * you don't want to repeat.
 * @param attributes {@link AudioAttributes} corresponding to the vibration. For example,
 * specify {@link AudioAttributes#USAGE_ALARM} for alarm vibrations or
 * {@link AudioAttributes#USAGE_NOTIFICATION_RINGTONE} for
 * vibrations associated with incoming calls.
 */
","/**
 * Vibrate with a given pattern.
 *
 * <p>
 * Pass in an array of ints that are the durations for which to turn on or off
 * the vibrator in milliseconds.  The first value indicates the number of milliseconds
 * to wait before turning the vibrator on.  The next value indicates the number of milliseconds
 * for which to keep the vibrator on before turning it off.  Subsequent values alternate
 * between durations in milliseconds to turn the vibrator off or to turn the vibrator on.
 * </p><p>
 * To cause the pattern to repeat, pass the index into the pattern array at which
 * to start the repeat, or -1 to disable repeating.
 * </p>
 *
 * @param pattern an array of longs of times for which to turn the vibrator on or off.
 * @param repeat the index into pattern at which to repeat, or -1 if
 * you don't want to repeat.
 * @param attributes {@link AudioAttributes} corresponding to the vibration. For example,
 * specify {@link AudioAttributes#USAGE_ALARM} for alarm vibrations or
 * {@link AudioAttributes#USAGE_NOTIFICATION_RINGTONE} for
 * vibrations associated with incoming calls.
 *
 * @deprecated Use {@link #vibrate(VibrationEffect, AudioAttributes)} instead.
 */
",-1,,"[@Deprecated, @RequiresPermission(android.Manifest.permission.VIBRATE)]",-1,-1,-1,-1,-1,-1,"2,3,5",2,"In the late version implementation, there is a newly added conditional block that checks the repeat index and may throw a new ArrayIndexOutOfBoundsException, an exception handling added for IllegalArgumentException, and it no longer calls the 'vibrate' method with the same signature but instead creates a VibrationEffect, resulting in a dependent API change. Therefore, the code change is 2, 3, 5.","Due to the newly introduced exception throwing condition for 'ArrayIndexOutOfBoundsException', and the wrapped try-catch block for 'IllegalArgumentException', the late version may throw different exceptions, and thus the CI type is 2."
1069,<android.widget.TextView: void setTextIsSelectable(boolean)>,25,26,<android.widget.TextView: void setTextIsSelectable(boolean)>,<android.widget.TextView: void setTextIsSelectable(boolean)>,0,"{
    // false is default value with no edit data
    if (!selectable && mEditor == null)
        return;
    createEditorIfNeeded();
    if (mEditor.mTextIsSelectable == selectable)
        return;
    mEditor.mTextIsSelectable = selectable;
    setFocusableInTouchMode(selectable);
    setFocusable(selectable);
    setClickable(selectable);
    setLongClickable(selectable);
    // mInputType should already be EditorInfo.TYPE_NULL and mInput should be null
    setMovementMethod(selectable ? ArrowKeyMovementMethod.getInstance() : null);
    setText(mText, selectable ? BufferType.SPANNABLE : BufferType.NORMAL);
    // Called by setText above, but safer in case of future code changes
    mEditor.prepareCursorControllers();
}","{
    // false is default value with no edit data
    if (!selectable && mEditor == null)
        return;
    createEditorIfNeeded();
    if (mEditor.mTextIsSelectable == selectable)
        return;
    mEditor.mTextIsSelectable = selectable;
    setFocusableInTouchMode(selectable);
    setFocusable(FOCUSABLE_AUTO);
    setClickable(selectable);
    setLongClickable(selectable);
    // mInputType should already be EditorInfo.TYPE_NULL and mInput should be null
    setMovementMethod(selectable ? ArrowKeyMovementMethod.getInstance() : null);
    setText(mText, selectable ? BufferType.SPANNABLE : BufferType.NORMAL);
    // Called by setText above, but safer in case of future code changes
    mEditor.prepareCursorControllers();
}",1,"/**
 * Sets whether the content of this view is selectable by the user. The default is
 * {@code false}, meaning that the content is not selectable.
 * <p>
 * When you use a TextView to display a useful piece of information to the user (such as a
 * contact's address), make it selectable, so that the user can select and copy its
 * content. You can also use set the XML attribute
 * {@link android.R.styleable#TextView_textIsSelectable} to ""true"".
 * <p>
 * When you call this method to set the value of {@code textIsSelectable}, it sets
 * the flags {@code focusable}, {@code focusableInTouchMode}, {@code clickable},
 * and {@code longClickable} to the same value. These flags correspond to the attributes
 * {@link android.R.styleable#View_focusable android:focusable},
 * {@link android.R.styleable#View_focusableInTouchMode android:focusableInTouchMode},
 * {@link android.R.styleable#View_clickable android:clickable}, and
 * {@link android.R.styleable#View_longClickable android:longClickable}. To restore any of these
 * flags to a state you had set previously, call one or more of the following methods:
 * {@link #setFocusable(boolean) setFocusable()},
 * {@link #setFocusableInTouchMode(boolean) setFocusableInTouchMode()},
 * {@link #setClickable(boolean) setClickable()} or
 * {@link #setLongClickable(boolean) setLongClickable()}.
 *
 * @param selectable Whether the content of this TextView should be selectable.
 */
","/**
 * Sets whether the content of this view is selectable by the user. The default is
 * {@code false}, meaning that the content is not selectable.
 * <p>
 * When you use a TextView to display a useful piece of information to the user (such as a
 * contact's address), make it selectable, so that the user can select and copy its
 * content. You can also use set the XML attribute
 * {@link android.R.styleable#TextView_textIsSelectable} to ""true"".
 * <p>
 * When you call this method to set the value of {@code textIsSelectable}, it sets
 * the flags {@code focusable}, {@code focusableInTouchMode}, {@code clickable},
 * and {@code longClickable} to the same value. These flags correspond to the attributes
 * {@link android.R.styleable#View_focusable android:focusable},
 * {@link android.R.styleable#View_focusableInTouchMode android:focusableInTouchMode},
 * {@link android.R.styleable#View_clickable android:clickable}, and
 * {@link android.R.styleable#View_longClickable android:longClickable}. To restore any of these
 * flags to a state you had set previously, call one or more of the following methods:
 * {@link #setFocusable(boolean) setFocusable()},
 * {@link #setFocusableInTouchMode(boolean) setFocusableInTouchMode()},
 * {@link #setClickable(boolean) setClickable()} or
 * {@link #setLongClickable(boolean) setLongClickable()}.
 *
 * @param selectable Whether the content of this TextView should be selectable.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"There is only one line of code that has been changed, where the method `setFocusable(selectable);` has been replaced with `setFocusable(FOCUSABLE_AUTO);`. This change does not affect the return value nor the exceptions thrown by the method, so the change type is 4.","The modification does not introduce a change in behavior that can lead to a Compatibility Issue. The method does not return any value, and the exception handling has not been modified. As a result, there's no Compatibility Issue, and therefore the CI type is 0."
1070,<android.view.inputmethod.InputMethodManager: int sendInputEventOnMainLooperLocked(PendingEvent)>,25,26,<android.view.inputmethod.InputMethodManager: int sendInputEventOnMainLooperLocked(PendingEvent)>,<android.view.inputmethod.InputMethodManager: int sendInputEventOnMainLooperLocked(PendingEvent)>,0,"{
    if (mCurChannel != null) {
        if (mCurSender == null) {
            mCurSender = new ImeInputEventSender(mCurChannel, mH.getLooper());
        }
        final InputEvent event = p.mEvent;
        final int seq = event.getSequenceNumber();
        if (mCurSender.sendInputEvent(seq, event)) {
            mPendingEvents.put(seq, p);
            Trace.traceCounter(Trace.TRACE_TAG_INPUT, PENDING_EVENT_COUNTER, mPendingEvents.size());
            Message msg = mH.obtainMessage(MSG_TIMEOUT_INPUT_EVENT, p);
            msg.setAsynchronous(true);
            mH.sendMessageDelayed(msg, INPUT_METHOD_NOT_RESPONDING_TIMEOUT);
            return DISPATCH_IN_PROGRESS;
        }
        Log.w(TAG, ""Unable to send input event to IME: "" + mCurId + "" dropping: "" + event);
    }
    return DISPATCH_NOT_HANDLED;
}","{
    if (mCurChannel != null) {
        if (mCurSender == null) {
            mCurSender = new ImeInputEventSender(mCurChannel, mH.getLooper());
        }
        final InputEvent event = p.mEvent;
        final int seq = event.getSequenceNumber();
        if (mCurSender.sendInputEvent(seq, event)) {
            mPendingEvents.put(seq, p);
            Trace.traceCounter(Trace.TRACE_TAG_INPUT, PENDING_EVENT_COUNTER, mPendingEvents.size());
            Message msg = mH.obtainMessage(MSG_TIMEOUT_INPUT_EVENT, seq, 0, p);
            msg.setAsynchronous(true);
            mH.sendMessageDelayed(msg, INPUT_METHOD_NOT_RESPONDING_TIMEOUT);
            return DISPATCH_IN_PROGRESS;
        }
        Log.w(TAG, ""Unable to send input event to IME: "" + mCurId + "" dropping: "" + event);
    }
    return DISPATCH_NOT_HANDLED;
}",1,"// Must be called on the main looper
","// Must be called on the main looper
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change involves modifying the arguments passed to the method obtainMessage(), from 'obtainMessage(MSG_TIMEOUT_INPUT_EVENT, p)' to 'obtainMessage(MSG_TIMEOUT_INPUT_EVENT, seq, 0, p)'. This is an internal change to the arguments of a method call, so the code change type is 4.","This change does not affect the return value of the method nor does it introduce any new exceptions to be thrown, thus, there's no Compatibility Issue as per the given definition. The behavior of the method remains consistent in terms of its API contract: it returns the same constants and the logic of when these constants are returned remains the same."
1071,<android.app.Fragment: void instantiateChildFragmentManager()>,25,26,<android.app.Fragment: void instantiateChildFragmentManager()>,<android.app.Fragment: void instantiateChildFragmentManager()>,0,"{
    mChildFragmentManager = new FragmentManagerImpl();
    mChildFragmentManager.attachController(mHost, new FragmentContainer() {

        @Override
        @Nullable
        public View onFindViewById(int id) {
            if (mView == null) {
                throw new IllegalStateException(""Fragment does not have a view"");
            }
            return mView.findViewById(id);
        }

        @Override
        public boolean onHasView() {
            return (mView != null);
        }
    }, this);
}","{
    mChildFragmentManager = new FragmentManagerImpl();
    mChildFragmentManager.attachController(mHost, new FragmentContainer() {

        @Override
        @Nullable
        public <T extends View> T onFindViewById(int id) {
            if (mView == null) {
                throw new IllegalStateException(""Fragment does not have a view"");
            }
            return mView.findViewById(id);
        }

        @Override
        public boolean onHasView() {
            return (mView != null);
        }
    }, this);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method signature of onFindViewById within the anonymous class FragmentContainer has changed to include a generic return type (<T extends View> T). Although the method signature has changed, the actual implementation code of onFindViewById and the rest of instantiateChildFragmentManager() method remains the same. This is an update to the method definition to use generics for type safety on the return type. The code change types are 4 due to the change in the method signature inside an anonymous class, and 5 because the dependent API is changed as a result of the more explicit typing.","This change should not pose any compatibility issues because the updated generic method still returns the same type as before as per Java’s type erasure in generics; *onFindViewById* continue to return a View or a subtype of View. This will not affect existing code that does not use generics since it is backward-compatible with calls to the non-generic method. There is no change in exception handling, control flow, or other behavior that would lead to a different outcome. Thus, there are no potential different return values or types, and no potential different exception handling issues."
1073,<android.animation.AnimatorSet: void pause()>,25,26,<android.animation.AnimatorSet: void pause()>,<android.animation.AnimatorSet: void pause()>,0,"{
    boolean previouslyPaused = mPaused;
    super.pause();
    if (!previouslyPaused && mPaused) {
        if (mDelayAnim.isStarted()) {
            // If delay hasn't passed, pause the start delay animator.
            mDelayAnim.pause();
        } else {
            int size = mNodes.size();
            for (int i = 0; i < size; i++) {
                Node node = mNodes.get(i);
                if (node != mRootNode) {
                    node.mAnimation.pause();
                }
            }
        }
    }
}","{
    if (Looper.myLooper() == null) {
        throw new AndroidRuntimeException(""Animators may only be run on Looper threads"");
    }
    boolean previouslyPaused = mPaused;
    super.pause();
    if (!previouslyPaused && mPaused) {
        mPauseTime = -1;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,3,4","1,2","There is a new exception-throwing statement added at the beginning of the method, an assignment operation added, and the control dependency and the block of code that executed within the if (!previouslyPaused && mPaused) condition have been removed and changed. Therefore, the classification includes Exception handling statement changed (2), Control dependency changed (3), and Other statement changed (4).","The new exception-throwing statement at the start of the method represents a potential change in the exceptions thrown, which can cause a compatibility issue (2). Additionally, by removing a block of code that used to pause animations, the method's behavior is changed and it now potentially does something different than before when it's called, representing a potential issue with different return values or behaviors (1)."
1074,<android.app.ActivityManager: boolean isUserAMonkey()>,25,26,<android.app.ActivityManager: boolean isUserAMonkey()>,<android.app.ActivityManager: boolean isUserAMonkey()>,0,"{
    try {
        return ActivityManagerNative.getDefault().isUserAMonkey();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        return getService().isUserAMonkey();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns ""true"" if the user interface is currently being messed with
 * by a monkey.
 */
","/**
 * Returns ""true"" if the user interface is currently being messed with
 * by a monkey.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method used to obtain the service instance has changed from `ActivityManagerNative.getDefault()` to `getService()`. This change does not affect the return type or the exception throwing. It is considered as ""Other statement changed"" and ""Dependent API changed"", so the change types are 4,5.","There is no Compatibility Issue since neither the return statement nor exception throwing behavior has been altered. The method used to obtain the service instance, although it has changed, should still produce the same result when `isUserAMonkey()` is called, so the CI type is 0."
1075,"<android.app.backup.BackupAgent.BackupServiceBinder: void doRestoreFile(ParcelFileDescriptor,long,int,String,String,long,long,int,IBackupManager)>",25,26,"<android.app.backup.BackupAgent.BackupServiceBinder: void doRestoreFile(ParcelFileDescriptor,long,int,String,String,long,long,int,IBackupManager)>","<android.app.backup.BackupAgent.BackupServiceBinder: void doRestoreFile(ParcelFileDescriptor,long,int,String,String,long,long,int,IBackupManager)>",0,"{
    long ident = Binder.clearCallingIdentity();
    try {
        BackupAgent.this.onRestoreFile(data, size, type, domain, path, mode, mtime);
    } catch (IOException e) {
        Log.d(TAG, ""onRestoreFile ("" + BackupAgent.this.getClass().getName() + "") threw"", e);
        throw new RuntimeException(e);
    } finally {
        // Ensure that any side-effect SharedPreferences writes have landed
        waitForSharedPrefs();
        Binder.restoreCallingIdentity(ident);
        try {
            callbackBinder.opComplete(token, 0);
        } catch (RemoteException e) {
        // we'll time out anyway, so we're safe
        }
    }
}","{
    long ident = Binder.clearCallingIdentity();
    try {
        BackupAgent.this.onRestoreFile(data, size, type, domain, path, mode, mtime);
    } catch (IOException e) {
        Log.d(TAG, ""onRestoreFile ("" + BackupAgent.this.getClass().getName() + "") threw"", e);
        throw new RuntimeException(e);
    } finally {
        // Ensure that any side-effect SharedPreferences writes have landed
        waitForSharedPrefs();
        Binder.restoreCallingIdentity(ident);
        try {
            callbackBinder.opComplete(token, 0);
        } catch (RemoteException e) {
        // we'll time out anyway, so we're safe
        }
        if (Binder.getCallingPid() != Process.myPid()) {
            IoUtils.closeQuietly(data);
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"There is an added call to IoUtils.closeQuietly(data) within the finally block, which does not affect how the function returns a result or throws exceptions. So the code change type is 4.","The additional code does not lead to a different return value or exception handling in an external context, which means no Compatibility Issue (CI) arises as a result of this change. Hence, there is no CI in this case."
1076,<android.view.TextureView: HardwareLayer getHardwareLayer()>,25,26,<android.view.TextureView: HardwareLayer getHardwareLayer()>,<android.view.TextureView: HardwareLayer getHardwareLayer()>,0,"{
    if (mLayer == null) {
        if (mAttachInfo == null || mAttachInfo.mHardwareRenderer == null) {
            return null;
        }
        mLayer = mAttachInfo.mHardwareRenderer.createTextureLayer();
        boolean createNewSurface = (mSurface == null);
        if (createNewSurface) {
            // Create a new SurfaceTexture for the layer.
            mSurface = new SurfaceTexture(false);
            nCreateNativeWindow(mSurface);
        }
        mLayer.setSurfaceTexture(mSurface);
        mSurface.setDefaultBufferSize(getWidth(), getHeight());
        mSurface.setOnFrameAvailableListener(mUpdateListener, mAttachInfo.mHandler);
        if (mListener != null && createNewSurface) {
            mListener.onSurfaceTextureAvailable(mSurface, getWidth(), getHeight());
        }
        mLayer.setLayerPaint(mLayerPaint);
    }
    if (mUpdateSurface) {
        // Someone has requested that we use a specific SurfaceTexture, so
        // tell mLayer about it and set the SurfaceTexture to use the
        // current view size.
        mUpdateSurface = false;
        // Since we are updating the layer, force an update to ensure its
        // parameters are correct (width, height, transform, etc.)
        updateLayer();
        mMatrixChanged = true;
        mLayer.setSurfaceTexture(mSurface);
        mSurface.setDefaultBufferSize(getWidth(), getHeight());
    }
    return mLayer;
}","{
    if (mLayer == null) {
        if (mAttachInfo == null || mAttachInfo.mThreadedRenderer == null) {
            return null;
        }
        mLayer = mAttachInfo.mThreadedRenderer.createTextureLayer();
        boolean createNewSurface = (mSurface == null);
        if (createNewSurface) {
            // Create a new SurfaceTexture for the layer.
            mSurface = new SurfaceTexture(false);
            nCreateNativeWindow(mSurface);
        }
        mLayer.setSurfaceTexture(mSurface);
        mSurface.setDefaultBufferSize(getWidth(), getHeight());
        mSurface.setOnFrameAvailableListener(mUpdateListener, mAttachInfo.mHandler);
        if (mListener != null && createNewSurface) {
            mListener.onSurfaceTextureAvailable(mSurface, getWidth(), getHeight());
        }
        mLayer.setLayerPaint(mLayerPaint);
    }
    if (mUpdateSurface) {
        // Someone has requested that we use a specific SurfaceTexture, so
        // tell mLayer about it and set the SurfaceTexture to use the
        // current view size.
        mUpdateSurface = false;
        // Since we are updating the layer, force an update to ensure its
        // parameters are correct (width, height, transform, etc.)
        updateLayer();
        mMatrixChanged = true;
        mLayer.setSurfaceTexture(mSurface);
        mSurface.setDefaultBufferSize(getWidth(), getHeight());
    }
    return mLayer;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,5,0,The only changes between the early and the late version implementations are the renaming from mAttachInfo.mHardwareRenderer to mAttachInfo.mThreadedRenderer and the method createTextureLayer(). So the code change type is 5.,"There is no Compatibility Issue, as the change only involves renaming a variable and a method, which does not affect the behavior of the API from the perspective of the caller. The method still returns a HardwareLayer, and the control flow remains the same as before."
1077,<android.hardware.camera2.legacy.LegacyCameraDevice: int detectSurfaceType(Surface)>,25,26,<android.hardware.camera2.legacy.LegacyCameraDevice: int detectSurfaceType(Surface)>,<android.hardware.camera2.legacy.LegacyCameraDevice: int detectSurfaceType(Surface)>,0,"{
    checkNotNull(surface);
    return LegacyExceptionUtils.throwOnError(nativeDetectSurfaceType(surface));
}","{
    checkNotNull(surface);
    int surfaceType = nativeDetectSurfaceType(surface);
    // ImageFormat.PRIVATE. b/9487482
    if ((surfaceType >= LegacyMetadataMapper.HAL_PIXEL_FORMAT_RGBA_8888 && surfaceType <= LegacyMetadataMapper.HAL_PIXEL_FORMAT_BGRA_8888)) {
        surfaceType = ImageFormat.PRIVATE;
    }
    return LegacyExceptionUtils.throwOnError(surfaceType);
}",1,"/**
 * Query the surface for its currently configured format
 */
","/**
 * Query the surface for its currently configured format
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"There's a new set of statements introduced that assigns a new value to surfaceType and an additional condition that could change the behavior of the method. This also affects the return statement, so the code change type is 1,4.","The introduction of new condition and assignment statements for surfaceType could lead to a different return value, which constitutes a compatibility issue of type 1."
1078,<android.content.ContentResolver: List<UriPermission> getOutgoingPersistedUriPermissions()>,25,26,<android.content.ContentResolver: List<UriPermission> getOutgoingPersistedUriPermissions()>,<android.content.ContentResolver: List<UriPermission> getOutgoingPersistedUriPermissions()>,0,"{
    try {
        return ActivityManagerNative.getDefault().getPersistedUriPermissions(mPackageName, false).getList();
    } catch (RemoteException e) {
        throw new RuntimeException(""Activity manager has died"", e);
    }
}","{
    try {
        return ActivityManager.getService().getPersistedUriPermissions(mPackageName, false).getList();
    } catch (RemoteException e) {
        throw new RuntimeException(""Activity manager has died"", e);
    }
}",1,"/**
 * Return list of all persisted URI permission grants that are hosted by the
 * calling app. That is, the returned permissions have been granted
 * <em>from</em> the calling app. Only grants taken with
 * {@link #takePersistableUriPermission(Uri, int)} are returned.
 * <p>Note: Some of the returned URIs may not be usable until after the user is unlocked.
 */
","/**
 * Return list of all persisted URI permission grants that are hosted by the
 * calling app. That is, the returned permissions have been granted
 * <em>from</em> the calling app. Only grants taken with
 * {@link #takePersistableUriPermission(Uri, int)} are returned.
 * <p>Note: Some of the returned URIs may not be usable until after the user is unlocked.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,5,0,"The way of obtaining the ActivityManager service changed from ActivityManagerNative.getDefault() to ActivityManager.getService(). This indicates that the dependent API has changed. However, there's no explicit change in the return statements or exception handling, so the code change type is 5.","The underlying API used to get the service has changed, but as long as the new API (ActivityManager.getService()) returns a compatible result with the old API (ActivityManagerNative.getDefault()) and the rest of the invocation chain (getPersistedUriPermissions(mPackageName, false).getList()) behaves the same way, there won't be any Compatibility Issue. Therefore, the CI type is 0."
